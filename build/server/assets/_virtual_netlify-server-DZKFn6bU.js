import { createRequestHandler } from "@netlify/vite-plugin-react-router/serverless";
import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { PassThrough } from "node:stream";
import { createReadableStreamFromReadable } from "@react-router/node";
import { ServerRouter, UNSAFE_withComponentProps, Outlet, UNSAFE_withErrorBoundaryProps, isRouteErrorResponse, Meta, Links, ScrollRestoration, Scripts, NavLink, useNavigate, Link } from "react-router";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";
import * as React from "react";
import React__default, { createContext, useContext, useEffect, useRef, useState, useCallback, useMemo, cloneElement } from "react";
import { createPortal } from "react-dom";
import { CheckIcon, ChevronDownIcon, ChevronUpIcon, X as X$3, LoaderCircle, BusFront, ShieldUser, TriangleRight, Icon, DoorOpen, XIcon, Info, Navigation, Settings2, ChevronsUpDown, ChevronRight, Trees, Building, ArrowLeft, Layers, ExternalLink, LocateOff, Locate, Pause, RotateCcw, Play } from "lucide-react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { SelectTrigger as SelectTrigger$1 } from "@radix-ui/react-select";
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import * as LabelPrimitive from "@radix-ui/react-label";
import { chevronsUpDownSquare, escalatorArrowUpRight, stairsArrowUpRight } from "@lucide/lab";
import * as RechartsPrimitive from "recharts";
import { AreaChart, CartesianGrid, XAxis, Area } from "recharts";
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { TooltipTrigger as TooltipTrigger$1 } from "@radix-ui/react-tooltip";
import { useLocation } from "react-router-dom";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";
import * as SwitchPrimitive from "@radix-ui/react-switch";
import * as ProgressPrimitive from "@radix-ui/react-progress";
import * as SeparatorPrimitive from "@radix-ui/react-separator";
const streamTimeout = 5e3;
function handleRequest(request, responseStatusCode, responseHeaders, routerContext, loadContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = false;
    let userAgent = request.headers.get("user-agent");
    let readyOption = userAgent && isbot(userAgent) || routerContext.isSpaMode ? "onAllReady" : "onShellReady";
    let timeoutId = setTimeout(
      () => abort(),
      streamTimeout + 1e3
    );
    const { pipe, abort } = renderToPipeableStream(
      /* @__PURE__ */ jsx(ServerRouter, { context: routerContext, url: request.url }),
      {
        [readyOption]() {
          shellRendered = true;
          const body = new PassThrough({
            final(callback) {
              clearTimeout(timeoutId);
              timeoutId = void 0;
              callback();
            }
          });
          const stream = createReadableStreamFromReadable(body);
          responseHeaders.set("Content-Type", "text/html");
          pipe(body);
          resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          );
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500;
          if (shellRendered) {
            console.error(error);
          }
        }
      }
    );
  });
}
const entryServer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: handleRequest,
  streamTimeout
}, Symbol.toStringTag, { value: "Module" }));
const links = () => [{
  rel: "preconnect",
  href: "https://fonts.googleapis.com"
}, {
  rel: "preconnect",
  href: "https://fonts.gstatic.com",
  crossOrigin: "anonymous"
}, {
  rel: "stylesheet",
  href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
}];
function Layout({
  children
}) {
  return /* @__PURE__ */ jsxs("html", {
    lang: "en",
    children: [/* @__PURE__ */ jsxs("head", {
      children: [/* @__PURE__ */ jsx("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1"
      }), /* @__PURE__ */ jsx(Meta, {}), /* @__PURE__ */ jsx(Links, {})]
    }), /* @__PURE__ */ jsxs("body", {
      children: [children, /* @__PURE__ */ jsx(ScrollRestoration, {}), /* @__PURE__ */ jsx(Scripts, {})]
    })]
  });
}
const root = UNSAFE_withComponentProps(function App() {
  return /* @__PURE__ */ jsx(Outlet, {});
});
const ErrorBoundary = UNSAFE_withErrorBoundaryProps(function ErrorBoundary2({
  error
}) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack;
  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details = error.status === 404 ? "The requested page could not be found." : error.statusText || details;
  }
  return /* @__PURE__ */ jsxs("main", {
    className: "pt-16 p-4 container mx-auto",
    children: [/* @__PURE__ */ jsx("h1", {
      children: message
    }), /* @__PURE__ */ jsx("p", {
      children: details
    }), stack]
  });
});
const route0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ErrorBoundary,
  Layout,
  default: root,
  links
}, Symbol.toStringTag, { value: "Module" }));
var y = Object.create, u = Object.freeze, k$1 = Object.defineProperty, z$1 = Object.defineProperties, A$2 = Object.getOwnPropertyDescriptor, B$2 = Object.getOwnPropertyDescriptors, C = Object.getOwnPropertyNames, n = Object.getOwnPropertySymbols, D$2 = Object.getPrototypeOf, p$2 = Object.prototype.hasOwnProperty, v = Object.prototype.propertyIsEnumerable;
var m$2 = (a4, b) => (b = Symbol[a4]) ? b : Symbol.for("Symbol." + a4), q$3 = (a4) => {
  throw TypeError(a4);
};
var o = (a4, b, c) => b in a4 ? k$1(a4, b, { enumerable: true, configurable: true, writable: true, value: c }) : a4[b] = c, F$1 = (a4, b) => {
  for (var c in b || (b = {})) p$2.call(b, c) && o(a4, c, b[c]);
  if (n) for (var c of n(b)) v.call(b, c) && o(a4, c, b[c]);
  return a4;
}, G$1 = (a4, b) => z$1(a4, B$2(b)), H$3 = (a4, b) => k$1(a4, "name", { value: b, configurable: true });
var I$2 = (a4) => typeof a4 == "symbol" ? a4 : a4 + "", J$1 = (a4, b) => {
  var c = {};
  for (var d in a4) p$2.call(a4, d) && b.indexOf(d) < 0 && (c[d] = a4[d]);
  if (a4 != null && n) for (var d of n(a4)) b.indexOf(d) < 0 && v.call(a4, d) && (c[d] = a4[d]);
  return c;
};
var K = (a4, b) => () => (a4 && (b = a4(a4 = 0)), b);
var L = (a4, b) => () => (b || a4((b = { exports: {} }).exports, b), b.exports), M$1 = (a4, b) => {
  for (var c in b) k$1(a4, c, { get: b[c], enumerable: true });
}, E$1 = (a4, b, c, d) => {
  if (b && typeof b == "object" || typeof b == "function") for (let e of C(b)) !p$2.call(a4, e) && e !== c && k$1(a4, e, { get: () => b[e], enumerable: !(d = A$2(b, e)) || d.enumerable });
  return a4;
};
var N$2 = (a4, b, c) => (c = a4 != null ? y(D$2(a4)) : {}, E$1(b || !a4 || !a4.__esModule ? k$1(c, "default", { value: a4, enumerable: true }) : c, a4));
var O = (a4, b, c) => o(a4, typeof b != "symbol" ? b + "" : b, c), r = (a4, b, c) => b.has(a4) || q$3("Cannot " + c);
var P = (a4, b, c) => (r(a4, b, "read from private field"), c ? c.call(a4) : b.get(a4)), Q$3 = (a4, b, c) => b.has(a4) ? q$3("Cannot add the same private member more than once") : b instanceof WeakSet ? b.add(a4) : b.set(a4, c), R$1 = (a4, b, c, d) => (r(a4, b, "write to private field"), b.set(a4, c), c), S$1 = (a4, b, c) => (r(a4, b, "access private method"), c);
var T$2 = (a4, b) => u(k$1(a4, "raw", { value: u(b || a4.slice()) }));
var w = function(a4, b) {
  this[0] = a4, this[1] = b;
}, U$2 = (a4, b, c) => {
  var d = (g, h, i, l) => {
    try {
      var s5 = c[g](h), t = (h = s5.value) instanceof w, x2 = s5.done;
      Promise.resolve(t ? h[0] : h).then((j3) => t ? d(g === "return" ? g : "next", h[1] ? { done: j3.done, value: j3.value } : j3, i, l) : i({ value: j3, done: x2 })).catch((j3) => d("throw", j3, i, l));
    } catch (j3) {
      l(j3);
    }
  }, e = (g) => f[g] = (h) => new Promise((i, l) => d(g, h, i, l)), f = {};
  return c = c.apply(a4, b), f[m$2("asyncIterator")] = () => f, e("next"), e("throw"), e("return"), f;
}, V$2 = (a4) => {
  var b = a4[m$2("asyncIterator")], c = false, d, e = {};
  return b == null ? (b = a4[m$2("iterator")](), d = (f) => e[f] = (g) => b[f](g)) : (b = b.call(a4), d = (f) => e[f] = (g) => {
    if (c) {
      if (c = false, f === "throw") throw g;
      return g;
    }
    return c = true, { done: false, value: new w(new Promise((h) => {
      var i = b[f](g);
      i instanceof Object || q$3("Object expected"), h(i);
    }), 1) };
  }), e[m$2("iterator")] = () => e, d("next"), "throw" in b ? d("throw") : e.throw = (f) => {
    throw f;
  }, "return" in b && d("return"), e;
};
var p$1, a = K(() => {
  p$1 = { env: { NODE_ENV: "production", npm_package_version: "6.0.1-beta.53" } };
});
a();
var Aa$1 = "173", Tp$2 = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var Hd = 0, Kl$1 = 1, Gd$2 = 2;
var Ql$2 = 1, Wd$1 = 2, ln = 3, Sn$2 = 0, Le$2 = 1, cn$3 = 2, wn$3 = 0, ni$1 = 1, jl = 2, tc$1 = 3, ec$1 = 4, Xd$1 = 5, Vn$3 = 100, qd$1 = 101, Yd$2 = 102, Zd$1 = 103, Jd$2 = 104, $d$2 = 200, Kd$2 = 201, Qd$2 = 202, jd$2 = 203, Dr$1 = 204, Lr$2 = 205, tf$2 = 206, ef$2 = 207, nf$2 = 208, sf$2 = 209, rf$2 = 210, af$2 = 211, of$2 = 212, lf$2 = 213, cf$2 = 214, wa$2 = 0, Ca$2 = 1, Ra$1 = 2, ii$1 = 3, Ia$2 = 4, Pa$1 = 5, Da$1 = 6, La$1 = 7, Ua$1 = 0, hf$2 = 1, uf$2 = 2, Cn$3 = 0, df$2 = 1, ff$2 = 2, pf$2 = 3, mf$2 = 4, gf$2 = 5, _f$2 = 6, xf$2 = 7, rl$2 = "attached", vf$2 = "detached", nc$1 = 300, pi$2 = 301, mi$1 = 302, Na$1 = 303, Fa$1 = 304, Vs$2 = 306, Ur$1 = 1e3, zn$2 = 1001, Nr$2 = 1002, Fe$2 = 1003, yf$2 = 1004;
var Hs$1 = 1005;
var en$1 = 1006, Oa$1 = 1007;
var Wn$1 = 1008;
var hn = 1009, ic$1 = 1010, sc$1 = 1011, Zi$2 = 1012, Ba$1 = 1013, Rn$1 = 1014, Oe$1 = 1015, Ji$1 = 1016, za$1 = 1017, ka$1 = 1018, gi$1 = 1020, rc$1 = 35902, ac$1 = 1021, oc$1 = 1022, De$3 = 1023, lc$1 = 1024, cc$1 = 1025, ei$2 = 1026, si$2 = 1027, Va$1 = 1028, Gs$2 = 1029, hc$2 = 1030, Ha$1 = 1031;
var Ga$1 = 1033, Ws$1 = 33776, Xs$1 = 33777, qs$1 = 33778, Ys$1 = 33779, Wa$1 = 35840, Xa$1 = 35841, qa$2 = 35842, Ya$1 = 35843, Za$2 = 36196, Ja$1 = 37492, $a$1 = 37496, Ka$2 = 37808, Qa$2 = 37809, ja$1 = 37810, to$1 = 37811, eo$1 = 37812, no$1 = 37813, io$1 = 37814, so$1 = 37815, ro$1 = 37816, ao$2 = 37817, oo$1 = 37818, lo$2 = 37819, co$1 = 37820, ho$1 = 37821, Zs$1 = 36492, uo$2 = 36494, fo$1 = 36495, uc$1 = 36283, po$1 = 36284, mo$1 = 36285, go$1 = 36286;
var ps$2 = 2300, Fr$1 = 2301, Pr$3 = 2302, al$2 = 2400, ol$2 = 2401, ll$2 = 2402, Mf$2 = 2500;
var Ap$2 = 0, wp$2 = 1, Cp$2 = 2, Sf$2 = 3200, bf$2 = 3201;
var _o$2 = 0, Ef$1 = 1, In$2 = "", Ve$1 = "srgb", ri$1 = "srgb-linear", ms$1 = "linear", ie$2 = "srgb";
var jn$3 = 7680, Rp$2 = 7681;
var Ip$2 = 517;
var cl$2 = 519, Tf$2 = 512, Af$1 = 513, wf$2 = 514, dc$2 = 515, Cf$2 = 516, Rf$1 = 517, If$2 = 518, Pf$1 = 519, Or$3 = 35044, Pp$2 = 35048;
var fc$2 = "300 es", an = 2e3, gs$1 = 2001;
var Mc$2 = class Mc {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    let n4 = this._listeners;
    n4[t] === void 0 && (n4[t] = []), n4[t].indexOf(e) === -1 && n4[t].push(e);
  }
  hasEventListener(t, e) {
    let n4 = this._listeners;
    return n4 === void 0 ? false : n4[t] !== void 0 && n4[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    let n4 = this._listeners;
    if (n4 === void 0) return;
    let i = n4[t];
    if (i !== void 0) {
      let r5 = i.indexOf(e);
      r5 !== -1 && i.splice(r5, 1);
    }
  }
  dispatchEvent(t) {
    let e = this._listeners;
    if (e === void 0) return;
    let n4 = e[t.type];
    if (n4 !== void 0) {
      t.target = this;
      let i = n4.slice(0);
      for (let r5 = 0, a4 = i.length; r5 < a4; r5++) i[r5].call(this, t);
      t.target = null;
    }
  }
};
H$3(Mc$2, "EventDispatcher");
var bn$2 = Mc$2, Se$3 = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], Ku$1 = 1234567, ki$2 = Math.PI / 180, ai$1 = 180 / Math.PI;
function Ye() {
  let s5 = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n4 = Math.random() * 4294967295 | 0;
  return (Se$3[s5 & 255] + Se$3[s5 >> 8 & 255] + Se$3[s5 >> 16 & 255] + Se$3[s5 >> 24 & 255] + "-" + Se$3[t & 255] + Se$3[t >> 8 & 255] + "-" + Se$3[t >> 16 & 15 | 64] + Se$3[t >> 24 & 255] + "-" + Se$3[e & 63 | 128] + Se$3[e >> 8 & 255] + "-" + Se$3[e >> 16 & 255] + Se$3[e >> 24 & 255] + Se$3[n4 & 255] + Se$3[n4 >> 8 & 255] + Se$3[n4 >> 16 & 255] + Se$3[n4 >> 24 & 255]).toLowerCase();
}
H$3(Ye, "generateUUID");
function Gt$2(s5, t, e) {
  return Math.max(t, Math.min(e, s5));
}
H$3(Gt$2, "clamp");
function pc$2(s5, t) {
  return (s5 % t + t) % t;
}
H$3(pc$2, "euclideanModulo");
function Dp$2(s5, t, e, n4, i) {
  return n4 + (s5 - t) * (i - n4) / (e - t);
}
H$3(Dp$2, "mapLinear");
function Lp$2(s5, t, e) {
  return s5 !== t ? (e - s5) / (t - s5) : 0;
}
H$3(Lp$2, "inverseLerp");
function hs$2(s5, t, e) {
  return (1 - e) * s5 + e * t;
}
H$3(hs$2, "lerp");
function Up$2(s5, t, e, n4) {
  return hs$2(s5, t, 1 - Math.exp(-e * n4));
}
H$3(Up$2, "damp");
function Np$2(s5, t = 1) {
  return t - Math.abs(pc$2(s5, t * 2) - t);
}
H$3(Np$2, "pingpong");
function Fp$2(s5, t, e) {
  return s5 <= t ? 0 : s5 >= e ? 1 : (s5 = (s5 - t) / (e - t), s5 * s5 * (3 - 2 * s5));
}
H$3(Fp$2, "smoothstep");
function Op$2(s5, t, e) {
  return s5 <= t ? 0 : s5 >= e ? 1 : (s5 = (s5 - t) / (e - t), s5 * s5 * s5 * (s5 * (s5 * 6 - 15) + 10));
}
H$3(Op$2, "smootherstep");
function Bp$2(s5, t) {
  return s5 + Math.floor(Math.random() * (t - s5 + 1));
}
H$3(Bp$2, "randInt");
function zp$2(s5, t) {
  return s5 + Math.random() * (t - s5);
}
H$3(zp$2, "randFloat");
function kp$2(s5) {
  return s5 * (0.5 - Math.random());
}
H$3(kp$2, "randFloatSpread");
function Vp$2(s5) {
  s5 !== void 0 && (Ku$1 = s5);
  let t = Ku$1 += 1831565813;
  return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
}
H$3(Vp$2, "seededRandom");
function Hp$2(s5) {
  return s5 * ki$2;
}
H$3(Hp$2, "degToRad");
function Gp$2(s5) {
  return s5 * ai$1;
}
H$3(Gp$2, "radToDeg");
function Wp$2(s5) {
  return (s5 & s5 - 1) === 0 && s5 !== 0;
}
H$3(Wp$2, "isPowerOfTwo");
function Xp$2(s5) {
  return Math.pow(2, Math.ceil(Math.log(s5) / Math.LN2));
}
H$3(Xp$2, "ceilPowerOfTwo");
function qp$2(s5) {
  return Math.pow(2, Math.floor(Math.log(s5) / Math.LN2));
}
H$3(qp$2, "floorPowerOfTwo");
function Yp$2(s5, t, e, n4, i) {
  let r5 = Math.cos, a4 = Math.sin, o4 = r5(e / 2), l = a4(e / 2), c = r5((t + n4) / 2), u5 = a4((t + n4) / 2), d = r5((t - n4) / 2), f = a4((t - n4) / 2), m5 = r5((n4 - t) / 2), _ = a4((n4 - t) / 2);
  switch (i) {
    case "XYX":
      s5.set(o4 * u5, l * d, l * f, o4 * c);
      break;
    case "YZY":
      s5.set(l * f, o4 * u5, l * d, o4 * c);
      break;
    case "ZXZ":
      s5.set(l * d, l * f, o4 * u5, o4 * c);
      break;
    case "XZX":
      s5.set(o4 * u5, l * _, l * m5, o4 * c);
      break;
    case "YXY":
      s5.set(l * m5, o4 * u5, l * _, o4 * c);
      break;
    case "ZYZ":
      s5.set(l * _, l * m5, o4 * u5, o4 * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
H$3(Yp$2, "setQuaternionFromProperEuler");
function tn$2(s5, t) {
  switch (t.constructor) {
    case Float32Array:
      return s5;
    case Uint32Array:
      return s5 / 4294967295;
    case Uint16Array:
      return s5 / 65535;
    case Uint8Array:
      return s5 / 255;
    case Int32Array:
      return Math.max(s5 / 2147483647, -1);
    case Int16Array:
      return Math.max(s5 / 32767, -1);
    case Int8Array:
      return Math.max(s5 / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
H$3(tn$2, "denormalize");
function ne$1(s5, t) {
  switch (t.constructor) {
    case Float32Array:
      return s5;
    case Uint32Array:
      return Math.round(s5 * 4294967295);
    case Uint16Array:
      return Math.round(s5 * 65535);
    case Uint8Array:
      return Math.round(s5 * 255);
    case Int32Array:
      return Math.round(s5 * 2147483647);
    case Int16Array:
      return Math.round(s5 * 32767);
    case Int8Array:
      return Math.round(s5 * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
H$3(ne$1, "normalize");
var Zp$2 = { DEG2RAD: ki$2, RAD2DEG: ai$1, generateUUID: Ye, clamp: Gt$2, euclideanModulo: pc$2, mapLinear: Dp$2, inverseLerp: Lp$2, lerp: hs$2, damp: Up$2, pingpong: Np$2, smoothstep: Fp$2, smootherstep: Op$2, randInt: Bp$2, randFloat: zp$2, randFloatSpread: kp$2, seededRandom: Vp$2, degToRad: Hp$2, radToDeg: Gp$2, isPowerOfTwo: Wp$2, ceilPowerOfTwo: Xp$2, floorPowerOfTwo: qp$2, setQuaternionFromProperEuler: Yp$2, normalize: ne$1, denormalize: tn$2 }, ua$2 = class ua {
  constructor(t = 0, e = 0) {
    ua.prototype.isVector2 = true, this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    let e = this.x, n4 = this.y, i = t.elements;
    return this.x = i[0] * e + i[3] * n4 + i[6], this.y = i[1] * e + i[4] * n4 + i[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Gt$2(this.x, t.x, e.x), this.y = Gt$2(this.y, t.y, e.y), this;
  }
  clampScalar(t, e) {
    return this.x = Gt$2(this.x, t, e), this.y = Gt$2(this.y, t, e), this;
  }
  clampLength(t, e) {
    let n4 = this.length();
    return this.divideScalar(n4 || 1).multiplyScalar(Gt$2(n4, t, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    let e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    let n4 = this.dot(t) / e;
    return Math.acos(Gt$2(n4, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    let e = this.x - t.x, n4 = this.y - t.y;
    return e * e + n4 * n4;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, n4) {
    return this.x = t.x + (e.x - t.x) * n4, this.y = t.y + (e.y - t.y) * n4, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this;
  }
  rotateAround(t, e) {
    let n4 = Math.cos(e), i = Math.sin(e), r5 = this.x - t.x, a4 = this.y - t.y;
    return this.x = r5 * n4 - a4 * i + t.x, this.y = r5 * i + a4 * n4 + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
};
H$3(ua$2, "Vector2");
var ot$1 = ua$2, da$2 = class da {
  constructor(t, e, n4, i, r5, a4, o4, l, c) {
    da.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], t !== void 0 && this.set(t, e, n4, i, r5, a4, o4, l, c);
  }
  set(t, e, n4, i, r5, a4, o4, l, c) {
    let u5 = this.elements;
    return u5[0] = t, u5[1] = i, u5[2] = o4, u5[3] = e, u5[4] = r5, u5[5] = l, u5[6] = n4, u5[7] = a4, u5[8] = c, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    let e = this.elements, n4 = t.elements;
    return e[0] = n4[0], e[1] = n4[1], e[2] = n4[2], e[3] = n4[3], e[4] = n4[4], e[5] = n4[5], e[6] = n4[6], e[7] = n4[7], e[8] = n4[8], this;
  }
  extractBasis(t, e, n4) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n4.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    let e = t.elements;
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    let n4 = t.elements, i = e.elements, r5 = this.elements, a4 = n4[0], o4 = n4[3], l = n4[6], c = n4[1], u5 = n4[4], d = n4[7], f = n4[2], m5 = n4[5], _ = n4[8], x2 = i[0], g = i[3], p4 = i[6], w3 = i[1], b = i[4], y4 = i[7], D4 = i[2], C3 = i[5], R3 = i[8];
    return r5[0] = a4 * x2 + o4 * w3 + l * D4, r5[3] = a4 * g + o4 * b + l * C3, r5[6] = a4 * p4 + o4 * y4 + l * R3, r5[1] = c * x2 + u5 * w3 + d * D4, r5[4] = c * g + u5 * b + d * C3, r5[7] = c * p4 + u5 * y4 + d * R3, r5[2] = f * x2 + m5 * w3 + _ * D4, r5[5] = f * g + m5 * b + _ * C3, r5[8] = f * p4 + m5 * y4 + _ * R3, this;
  }
  multiplyScalar(t) {
    let e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    let t = this.elements, e = t[0], n4 = t[1], i = t[2], r5 = t[3], a4 = t[4], o4 = t[5], l = t[6], c = t[7], u5 = t[8];
    return e * a4 * u5 - e * o4 * c - n4 * r5 * u5 + n4 * o4 * l + i * r5 * c - i * a4 * l;
  }
  invert() {
    let t = this.elements, e = t[0], n4 = t[1], i = t[2], r5 = t[3], a4 = t[4], o4 = t[5], l = t[6], c = t[7], u5 = t[8], d = u5 * a4 - o4 * c, f = o4 * l - u5 * r5, m5 = c * r5 - a4 * l, _ = e * d + n4 * f + i * m5;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    let x2 = 1 / _;
    return t[0] = d * x2, t[1] = (i * c - u5 * n4) * x2, t[2] = (o4 * n4 - i * a4) * x2, t[3] = f * x2, t[4] = (u5 * e - i * l) * x2, t[5] = (i * r5 - o4 * e) * x2, t[6] = m5 * x2, t[7] = (n4 * l - c * e) * x2, t[8] = (a4 * e - n4 * r5) * x2, this;
  }
  transpose() {
    let t, e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    let e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, n4, i, r5, a4, o4) {
    let l = Math.cos(r5), c = Math.sin(r5);
    return this.set(n4 * l, n4 * c, -n4 * (l * a4 + c * o4) + a4 + t, -i * c, i * l, -i * (-c * a4 + l * o4) + o4 + e, 0, 0, 1), this;
  }
  scale(t, e) {
    return this.premultiply(wo$2.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(wo$2.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(wo$2.makeTranslation(t, e)), this;
  }
  makeTranslation(t, e) {
    return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this;
  }
  makeRotation(t) {
    let e = Math.cos(t), n4 = Math.sin(t);
    return this.set(e, -n4, 0, n4, e, 0, 0, 0, 1), this;
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
  }
  equals(t) {
    let e = this.elements, n4 = t.elements;
    for (let i = 0; i < 9; i++) if (e[i] !== n4[i]) return false;
    return true;
  }
  fromArray(t, e = 0) {
    for (let n4 = 0; n4 < 9; n4++) this.elements[n4] = t[n4 + e];
    return this;
  }
  toArray(t = [], e = 0) {
    let n4 = this.elements;
    return t[e] = n4[0], t[e + 1] = n4[1], t[e + 2] = n4[2], t[e + 3] = n4[3], t[e + 4] = n4[4], t[e + 5] = n4[5], t[e + 6] = n4[6], t[e + 7] = n4[7], t[e + 8] = n4[8], t;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
H$3(da$2, "Matrix3");
var Bt$2 = da$2, wo$2 = new Bt$2();
function mc$2(s5) {
  for (let t = s5.length - 1; t >= 0; --t) if (s5[t] >= 65535) return true;
  return false;
}
H$3(mc$2, "arrayNeedsUint32");
function Gi$2(s5) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s5);
}
H$3(Gi$2, "createElementNS");
function Df$1() {
  let s5 = Gi$2("canvas");
  return s5.style.display = "block", s5;
}
H$3(Df$1, "createCanvasElement");
var Qu$1 = {};
function _i$1(s5) {
  s5 in Qu$1 || (Qu$1[s5] = true, console.warn(s5));
}
H$3(_i$1, "warnOnce");
function Lf$1(s5, t, e) {
  return new Promise(function(n4, i) {
    function r5() {
      switch (s5.clientWaitSync(t, s5.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s5.WAIT_FAILED:
          i();
          break;
        case s5.TIMEOUT_EXPIRED:
          setTimeout(r5, e);
          break;
        default:
          n4();
      }
    }
    H$3(r5, "probe"), setTimeout(r5, e);
  });
}
H$3(Lf$1, "probeAsync");
function Uf$1(s5) {
  let t = s5.elements;
  t[2] = 0.5 * t[2] + 0.5 * t[3], t[6] = 0.5 * t[6] + 0.5 * t[7], t[10] = 0.5 * t[10] + 0.5 * t[11], t[14] = 0.5 * t[14] + 0.5 * t[15];
}
H$3(Uf$1, "toNormalizedProjectionMatrix");
function Nf$1(s5) {
  let t = s5.elements;
  t[11] === -1 ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = -t[14] + 1);
}
H$3(Nf$1, "toReversedProjectionMatrix");
var ju$2 = new Bt$2().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), td$1 = new Bt$2().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
function Jp$2() {
  let s5 = { enabled: true, workingColorSpace: ri$1, spaces: {}, convert: H$3(function(i, r5, a4) {
    return this.enabled === false || r5 === a4 || !r5 || !a4 || (this.spaces[r5].transfer === ie$2 && (i.r = Mn$2(i.r), i.g = Mn$2(i.g), i.b = Mn$2(i.b)), this.spaces[r5].primaries !== this.spaces[a4].primaries && (i.applyMatrix3(this.spaces[r5].toXYZ), i.applyMatrix3(this.spaces[a4].fromXYZ)), this.spaces[a4].transfer === ie$2 && (i.r = Vi$1(i.r), i.g = Vi$1(i.g), i.b = Vi$1(i.b))), i;
  }, "convert"), fromWorkingColorSpace: H$3(function(i, r5) {
    return this.convert(i, this.workingColorSpace, r5);
  }, "fromWorkingColorSpace"), toWorkingColorSpace: H$3(function(i, r5) {
    return this.convert(i, r5, this.workingColorSpace);
  }, "toWorkingColorSpace"), getPrimaries: H$3(function(i) {
    return this.spaces[i].primaries;
  }, "getPrimaries"), getTransfer: H$3(function(i) {
    return i === In$2 ? ms$1 : this.spaces[i].transfer;
  }, "getTransfer"), getLuminanceCoefficients: H$3(function(i, r5 = this.workingColorSpace) {
    return i.fromArray(this.spaces[r5].luminanceCoefficients);
  }, "getLuminanceCoefficients"), define: H$3(function(i) {
    Object.assign(this.spaces, i);
  }, "define"), _getMatrix: H$3(function(i, r5, a4) {
    return i.copy(this.spaces[r5].toXYZ).multiply(this.spaces[a4].fromXYZ);
  }, "_getMatrix"), _getDrawingBufferColorSpace: H$3(function(i) {
    return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
  }, "_getDrawingBufferColorSpace"), _getUnpackColorSpace: H$3(function(i = this.workingColorSpace) {
    return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
  }, "_getUnpackColorSpace") }, t = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], e = [0.2126, 0.7152, 0.0722], n4 = [0.3127, 0.329];
  return s5.define({ [ri$1]: { primaries: t, whitePoint: n4, transfer: ms$1, toXYZ: ju$2, fromXYZ: td$1, luminanceCoefficients: e, workingColorSpaceConfig: { unpackColorSpace: Ve$1 }, outputColorSpaceConfig: { drawingBufferColorSpace: Ve$1 } }, [Ve$1]: { primaries: t, whitePoint: n4, transfer: ie$2, toXYZ: ju$2, fromXYZ: td$1, luminanceCoefficients: e, outputColorSpaceConfig: { drawingBufferColorSpace: Ve$1 } } }), s5;
}
H$3(Jp$2, "createColorManagement");
var qt$2 = Jp$2();
function Mn$2(s5) {
  return s5 < 0.04045 ? s5 * 0.0773993808 : Math.pow(s5 * 0.9478672986 + 0.0521327014, 2.4);
}
H$3(Mn$2, "SRGBToLinear");
function Vi$1(s5) {
  return s5 < 31308e-7 ? s5 * 12.92 : 1.055 * Math.pow(s5, 0.41666) - 0.055;
}
H$3(Vi$1, "LinearToSRGB");
var Ei$1, Sc$2 = class Sc {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
    let e;
    if (t instanceof HTMLCanvasElement) e = t;
    else {
      Ei$1 === void 0 && (Ei$1 = Gi$2("canvas")), Ei$1.width = t.width, Ei$1.height = t.height;
      let n4 = Ei$1.getContext("2d");
      t instanceof ImageData ? n4.putImageData(t, 0, 0) : n4.drawImage(t, 0, 0, t.width, t.height), e = Ei$1;
    }
    return e.toDataURL("image/png");
  }
  static sRGBToLinear(t) {
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
      let e = Gi$2("canvas");
      e.width = t.width, e.height = t.height;
      let n4 = e.getContext("2d");
      n4.drawImage(t, 0, 0, t.width, t.height);
      let i = n4.getImageData(0, 0, t.width, t.height), r5 = i.data;
      for (let a4 = 0; a4 < r5.length; a4++) r5[a4] = Mn$2(r5[a4] / 255) * 255;
      return n4.putImageData(i, 0, 0), e;
    } else if (t.data) {
      let e = t.data.slice(0);
      for (let n4 = 0; n4 < e.length; n4++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n4] = Math.floor(Mn$2(e[n4] / 255) * 255) : e[n4] = Mn$2(e[n4]);
      return { data: e, width: t.width, height: t.height };
    } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
  }
};
H$3(Sc$2, "ImageUtils");
var Br$2 = Sc$2, $p$2 = 0, bc$2 = class bc {
  constructor(t = null) {
    this.isSource = true, Object.defineProperty(this, "id", { value: $p$2++ }), this.uuid = Ye(), this.data = t, this.dataReady = true, this.version = 0;
  }
  set needsUpdate(t) {
    t === true && this.version++;
  }
  toJSON(t) {
    let e = t === void 0 || typeof t == "string";
    if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid];
    let n4 = { uuid: this.uuid, url: "" }, i = this.data;
    if (i !== null) {
      let r5;
      if (Array.isArray(i)) {
        r5 = [];
        for (let a4 = 0, o4 = i.length; a4 < o4; a4++) i[a4].isDataTexture ? r5.push(Co$2(i[a4].image)) : r5.push(Co$2(i[a4]));
      } else r5 = Co$2(i);
      n4.url = r5;
    }
    return e || (t.images[this.uuid] = n4), n4;
  }
};
H$3(bc$2, "Source");
var _s$1 = bc$2;
function Co$2(s5) {
  return typeof HTMLImageElement < "u" && s5 instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s5 instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s5 instanceof ImageBitmap ? Br$2.getDataURL(s5) : s5.data ? { data: Array.from(s5.data), width: s5.width, height: s5.height, type: s5.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
H$3(Co$2, "serializeImage");
var Kp$2 = 0, Bi$1 = class Bi extends bn$2 {
  constructor(t = Bi.DEFAULT_IMAGE, e = Bi.DEFAULT_MAPPING, n4 = zn$2, i = zn$2, r5 = en$1, a4 = Wn$1, o4 = De$3, l = hn, c = Bi.DEFAULT_ANISOTROPY, u5 = In$2) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: Kp$2++ }), this.uuid = Ye(), this.name = "", this.source = new _s$1(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n4, this.wrapT = i, this.magFilter = r5, this.minFilter = a4, this.anisotropy = c, this.format = o4, this.internalFormat = null, this.type = l, this.offset = new ot$1(0, 0), this.repeat = new ot$1(1, 1), this.center = new ot$1(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Bt$2(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = u5, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = true, this;
  }
  toJSON(t) {
    let e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
    let n4 = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(t).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (n4.userData = this.userData), e || (t.textures[this.uuid] = n4), n4;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== nc$1) return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
      case Ur$1:
        t.x = t.x - Math.floor(t.x);
        break;
      case zn$2:
        t.x = t.x < 0 ? 0 : 1;
        break;
      case Nr$2:
        Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
        break;
    }
    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
      case Ur$1:
        t.y = t.y - Math.floor(t.y);
        break;
      case zn$2:
        t.y = t.y < 0 ? 0 : 1;
        break;
      case Nr$2:
        Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
        break;
    }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === true && (this.version++, this.source.needsUpdate = true);
  }
  set needsPMREMUpdate(t) {
    t === true && this.pmremVersion++;
  }
};
H$3(Bi$1, "Texture");
var we$2 = Bi$1;
we$2.DEFAULT_IMAGE = null;
we$2.DEFAULT_MAPPING = nc$1;
we$2.DEFAULT_ANISOTROPY = 1;
var fa$2 = class fa {
  constructor(t = 0, e = 0, n4 = 0, i = 1) {
    fa.prototype.isVector4 = true, this.x = t, this.y = e, this.z = n4, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, n4, i) {
    return this.x = t, this.y = e, this.z = n4, this.w = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    let e = this.x, n4 = this.y, i = this.z, r5 = this.w, a4 = t.elements;
    return this.x = a4[0] * e + a4[4] * n4 + a4[8] * i + a4[12] * r5, this.y = a4[1] * e + a4[5] * n4 + a4[9] * i + a4[13] * r5, this.z = a4[2] * e + a4[6] * n4 + a4[10] * i + a4[14] * r5, this.w = a4[3] * e + a4[7] * n4 + a4[11] * i + a4[15] * r5, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    let e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n4, i, r5, l = t.elements, c = l[0], u5 = l[4], d = l[8], f = l[1], m5 = l[5], _ = l[9], x2 = l[2], g = l[6], p4 = l[10];
    if (Math.abs(u5 - f) < 0.01 && Math.abs(d - x2) < 0.01 && Math.abs(_ - g) < 0.01) {
      if (Math.abs(u5 + f) < 0.1 && Math.abs(d + x2) < 0.1 && Math.abs(_ + g) < 0.1 && Math.abs(c + m5 + p4 - 3) < 0.1) return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      let b = (c + 1) / 2, y4 = (m5 + 1) / 2, D4 = (p4 + 1) / 2, C3 = (u5 + f) / 4, R3 = (d + x2) / 4, L3 = (_ + g) / 4;
      return b > y4 && b > D4 ? b < 0.01 ? (n4 = 0, i = 0.707106781, r5 = 0.707106781) : (n4 = Math.sqrt(b), i = C3 / n4, r5 = R3 / n4) : y4 > D4 ? y4 < 0.01 ? (n4 = 0.707106781, i = 0, r5 = 0.707106781) : (i = Math.sqrt(y4), n4 = C3 / i, r5 = L3 / i) : D4 < 0.01 ? (n4 = 0.707106781, i = 0.707106781, r5 = 0) : (r5 = Math.sqrt(D4), n4 = R3 / r5, i = L3 / r5), this.set(n4, i, r5, e), this;
    }
    let w3 = Math.sqrt((g - _) * (g - _) + (d - x2) * (d - x2) + (f - u5) * (f - u5));
    return Math.abs(w3) < 1e-3 && (w3 = 1), this.x = (g - _) / w3, this.y = (d - x2) / w3, this.z = (f - u5) / w3, this.w = Math.acos((c + m5 + p4 - 1) / 2), this;
  }
  setFromMatrixPosition(t) {
    let e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Gt$2(this.x, t.x, e.x), this.y = Gt$2(this.y, t.y, e.y), this.z = Gt$2(this.z, t.z, e.z), this.w = Gt$2(this.w, t.w, e.w), this;
  }
  clampScalar(t, e) {
    return this.x = Gt$2(this.x, t, e), this.y = Gt$2(this.y, t, e), this.z = Gt$2(this.z, t, e), this.w = Gt$2(this.w, t, e), this;
  }
  clampLength(t, e) {
    let n4 = this.length();
    return this.divideScalar(n4 || 1).multiplyScalar(Gt$2(n4, t, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, n4) {
    return this.x = t.x + (e.x - t.x) * n4, this.y = t.y + (e.y - t.y) * n4, this.z = t.z + (e.z - t.z) * n4, this.w = t.w + (e.w - t.w) * n4, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
};
H$3(fa$2, "Vector4");
var $t$3 = fa$2, Ec$2 = class Ec extends bn$2 {
  constructor(t = 1, e = 1, n4 = {}) {
    super(), this.isRenderTarget = true, this.width = t, this.height = e, this.depth = 1, this.scissor = new $t$3(0, 0, t, e), this.scissorTest = false, this.viewport = new $t$3(0, 0, t, e);
    let i = { width: t, height: e, depth: 1 };
    n4 = Object.assign({ generateMipmaps: false, internalFormat: null, minFilter: en$1, depthBuffer: true, stencilBuffer: false, resolveDepthBuffer: true, resolveStencilBuffer: true, depthTexture: null, samples: 0, count: 1 }, n4);
    let r5 = new we$2(i, n4.mapping, n4.wrapS, n4.wrapT, n4.magFilter, n4.minFilter, n4.format, n4.type, n4.anisotropy, n4.colorSpace);
    r5.flipY = false, r5.generateMipmaps = n4.generateMipmaps, r5.internalFormat = n4.internalFormat, this.textures = [];
    let a4 = n4.count;
    for (let o4 = 0; o4 < a4; o4++) this.textures[o4] = r5.clone(), this.textures[o4].isRenderTargetTexture = true, this.textures[o4].renderTarget = this;
    this.depthBuffer = n4.depthBuffer, this.stencilBuffer = n4.stencilBuffer, this.resolveDepthBuffer = n4.resolveDepthBuffer, this.resolveStencilBuffer = n4.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n4.depthTexture, this.samples = n4.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(t) {
    this.textures[0] = t;
  }
  set depthTexture(t) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), t !== null && (t.renderTarget = this), this._depthTexture = t;
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(t, e, n4 = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n4) {
      this.width = t, this.height = e, this.depth = n4;
      for (let i = 0, r5 = this.textures.length; i < r5; i++) this.textures[i].image.width = t, this.textures[i].image.height = e, this.textures[i].image.depth = n4;
      this.dispose();
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
    for (let n4 = 0, i = t.textures.length; n4 < i; n4++) this.textures[n4] = t.textures[n4].clone(), this.textures[n4].isRenderTargetTexture = true, this.textures[n4].renderTarget = this;
    let e = Object.assign({}, t.texture.image);
    return this.texture.source = new _s$1(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
H$3(Ec$2, "RenderTarget");
var zr$1 = Ec$2, Tc$2 = class Tc extends zr$1 {
  constructor(t = 1, e = 1, n4 = {}) {
    super(t, e, n4), this.isWebGLRenderTarget = true;
  }
};
H$3(Tc$2, "WebGLRenderTarget");
var on$3 = Tc$2, Ac$2 = class Ac extends we$2 {
  constructor(t = null, e = 1, n4 = 1, i = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: t, width: e, height: n4, depth: i }, this.magFilter = Fe$2, this.minFilter = Fe$2, this.wrapR = zn$2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
};
H$3(Ac$2, "DataArrayTexture");
var xs$1 = Ac$2;
var wc$2 = class wc extends we$2 {
  constructor(t = null, e = 1, n4 = 1, i = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: t, width: e, height: n4, depth: i }, this.magFilter = Fe$2, this.minFilter = Fe$2, this.wrapR = zn$2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
H$3(wc$2, "Data3DTexture");
var kr$1 = wc$2;
var Cc$2 = class Cc {
  constructor(t = 0, e = 0, n4 = 0, i = 1) {
    this.isQuaternion = true, this._x = t, this._y = e, this._z = n4, this._w = i;
  }
  static slerpFlat(t, e, n4, i, r5, a4, o4) {
    let l = n4[i + 0], c = n4[i + 1], u5 = n4[i + 2], d = n4[i + 3], f = r5[a4 + 0], m5 = r5[a4 + 1], _ = r5[a4 + 2], x2 = r5[a4 + 3];
    if (o4 === 0) {
      t[e + 0] = l, t[e + 1] = c, t[e + 2] = u5, t[e + 3] = d;
      return;
    }
    if (o4 === 1) {
      t[e + 0] = f, t[e + 1] = m5, t[e + 2] = _, t[e + 3] = x2;
      return;
    }
    if (d !== x2 || l !== f || c !== m5 || u5 !== _) {
      let g = 1 - o4, p4 = l * f + c * m5 + u5 * _ + d * x2, w3 = p4 >= 0 ? 1 : -1, b = 1 - p4 * p4;
      if (b > Number.EPSILON) {
        let D4 = Math.sqrt(b), C3 = Math.atan2(D4, p4 * w3);
        g = Math.sin(g * C3) / D4, o4 = Math.sin(o4 * C3) / D4;
      }
      let y4 = o4 * w3;
      if (l = l * g + f * y4, c = c * g + m5 * y4, u5 = u5 * g + _ * y4, d = d * g + x2 * y4, g === 1 - o4) {
        let D4 = 1 / Math.sqrt(l * l + c * c + u5 * u5 + d * d);
        l *= D4, c *= D4, u5 *= D4, d *= D4;
      }
    }
    t[e] = l, t[e + 1] = c, t[e + 2] = u5, t[e + 3] = d;
  }
  static multiplyQuaternionsFlat(t, e, n4, i, r5, a4) {
    let o4 = n4[i], l = n4[i + 1], c = n4[i + 2], u5 = n4[i + 3], d = r5[a4], f = r5[a4 + 1], m5 = r5[a4 + 2], _ = r5[a4 + 3];
    return t[e] = o4 * _ + u5 * d + l * m5 - c * f, t[e + 1] = l * _ + u5 * f + c * d - o4 * m5, t[e + 2] = c * _ + u5 * m5 + o4 * f - l * d, t[e + 3] = u5 * _ - o4 * d - l * f - c * m5, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, n4, i) {
    return this._x = t, this._y = e, this._z = n4, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e = true) {
    let n4 = t._x, i = t._y, r5 = t._z, a4 = t._order, o4 = Math.cos, l = Math.sin, c = o4(n4 / 2), u5 = o4(i / 2), d = o4(r5 / 2), f = l(n4 / 2), m5 = l(i / 2), _ = l(r5 / 2);
    switch (a4) {
      case "XYZ":
        this._x = f * u5 * d + c * m5 * _, this._y = c * m5 * d - f * u5 * _, this._z = c * u5 * _ + f * m5 * d, this._w = c * u5 * d - f * m5 * _;
        break;
      case "YXZ":
        this._x = f * u5 * d + c * m5 * _, this._y = c * m5 * d - f * u5 * _, this._z = c * u5 * _ - f * m5 * d, this._w = c * u5 * d + f * m5 * _;
        break;
      case "ZXY":
        this._x = f * u5 * d - c * m5 * _, this._y = c * m5 * d + f * u5 * _, this._z = c * u5 * _ + f * m5 * d, this._w = c * u5 * d - f * m5 * _;
        break;
      case "ZYX":
        this._x = f * u5 * d - c * m5 * _, this._y = c * m5 * d + f * u5 * _, this._z = c * u5 * _ - f * m5 * d, this._w = c * u5 * d + f * m5 * _;
        break;
      case "YZX":
        this._x = f * u5 * d + c * m5 * _, this._y = c * m5 * d + f * u5 * _, this._z = c * u5 * _ - f * m5 * d, this._w = c * u5 * d - f * m5 * _;
        break;
      case "XZY":
        this._x = f * u5 * d - c * m5 * _, this._y = c * m5 * d - f * u5 * _, this._z = c * u5 * _ + f * m5 * d, this._w = c * u5 * d + f * m5 * _;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a4);
    }
    return e === true && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    let n4 = e / 2, i = Math.sin(n4);
    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n4), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    let e = t.elements, n4 = e[0], i = e[4], r5 = e[8], a4 = e[1], o4 = e[5], l = e[9], c = e[2], u5 = e[6], d = e[10], f = n4 + o4 + d;
    if (f > 0) {
      let m5 = 0.5 / Math.sqrt(f + 1);
      this._w = 0.25 / m5, this._x = (u5 - l) * m5, this._y = (r5 - c) * m5, this._z = (a4 - i) * m5;
    } else if (n4 > o4 && n4 > d) {
      let m5 = 2 * Math.sqrt(1 + n4 - o4 - d);
      this._w = (u5 - l) / m5, this._x = 0.25 * m5, this._y = (i + a4) / m5, this._z = (r5 + c) / m5;
    } else if (o4 > d) {
      let m5 = 2 * Math.sqrt(1 + o4 - n4 - d);
      this._w = (r5 - c) / m5, this._x = (i + a4) / m5, this._y = 0.25 * m5, this._z = (l + u5) / m5;
    } else {
      let m5 = 2 * Math.sqrt(1 + d - n4 - o4);
      this._w = (a4 - i) / m5, this._x = (r5 + c) / m5, this._y = (l + u5) / m5, this._z = 0.25 * m5;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let n4 = t.dot(e) + 1;
    return n4 < Number.EPSILON ? (n4 = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n4) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n4)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n4), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(Gt$2(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    let n4 = this.angleTo(t);
    if (n4 === 0) return this;
    let i = Math.min(1, e / n4);
    return this.slerp(t, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    let n4 = t._x, i = t._y, r5 = t._z, a4 = t._w, o4 = e._x, l = e._y, c = e._z, u5 = e._w;
    return this._x = n4 * u5 + a4 * o4 + i * c - r5 * l, this._y = i * u5 + a4 * l + r5 * o4 - n4 * c, this._z = r5 * u5 + a4 * c + n4 * l - i * o4, this._w = a4 * u5 - n4 * o4 - i * l - r5 * c, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(t);
    let n4 = this._x, i = this._y, r5 = this._z, a4 = this._w, o4 = a4 * t._w + n4 * t._x + i * t._y + r5 * t._z;
    if (o4 < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o4 = -o4) : this.copy(t), o4 >= 1) return this._w = a4, this._x = n4, this._y = i, this._z = r5, this;
    let l = 1 - o4 * o4;
    if (l <= Number.EPSILON) {
      let m5 = 1 - e;
      return this._w = m5 * a4 + e * this._w, this._x = m5 * n4 + e * this._x, this._y = m5 * i + e * this._y, this._z = m5 * r5 + e * this._z, this.normalize(), this;
    }
    let c = Math.sqrt(l), u5 = Math.atan2(c, o4), d = Math.sin((1 - e) * u5) / c, f = Math.sin(e * u5) / c;
    return this._w = a4 * d + this._w * f, this._x = n4 * d + this._x * f, this._y = i * d + this._y * f, this._z = r5 * d + this._z * f, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, n4) {
    return this.copy(t).slerp(e, n4);
  }
  random() {
    let t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), n4 = Math.random(), i = Math.sqrt(1 - n4), r5 = Math.sqrt(n4);
    return this.set(i * Math.sin(t), i * Math.cos(t), r5 * Math.sin(e), r5 * Math.cos(e));
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  fromBufferAttribute(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
};
H$3(Cc$2, "Quaternion");
var En$1 = Cc$2, pa$2 = class pa {
  constructor(t = 0, e = 0, n4 = 0) {
    pa.prototype.isVector3 = true, this.x = t, this.y = e, this.z = n4;
  }
  set(t, e, n4) {
    return n4 === void 0 && (n4 = this.z), this.x = t, this.y = e, this.z = n4, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(ed$2.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(ed$2.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    let e = this.x, n4 = this.y, i = this.z, r5 = t.elements;
    return this.x = r5[0] * e + r5[3] * n4 + r5[6] * i, this.y = r5[1] * e + r5[4] * n4 + r5[7] * i, this.z = r5[2] * e + r5[5] * n4 + r5[8] * i, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    let e = this.x, n4 = this.y, i = this.z, r5 = t.elements, a4 = 1 / (r5[3] * e + r5[7] * n4 + r5[11] * i + r5[15]);
    return this.x = (r5[0] * e + r5[4] * n4 + r5[8] * i + r5[12]) * a4, this.y = (r5[1] * e + r5[5] * n4 + r5[9] * i + r5[13]) * a4, this.z = (r5[2] * e + r5[6] * n4 + r5[10] * i + r5[14]) * a4, this;
  }
  applyQuaternion(t) {
    let e = this.x, n4 = this.y, i = this.z, r5 = t.x, a4 = t.y, o4 = t.z, l = t.w, c = 2 * (a4 * i - o4 * n4), u5 = 2 * (o4 * e - r5 * i), d = 2 * (r5 * n4 - a4 * e);
    return this.x = e + l * c + a4 * d - o4 * u5, this.y = n4 + l * u5 + o4 * c - r5 * d, this.z = i + l * d + r5 * u5 - a4 * c, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    let e = this.x, n4 = this.y, i = this.z, r5 = t.elements;
    return this.x = r5[0] * e + r5[4] * n4 + r5[8] * i, this.y = r5[1] * e + r5[5] * n4 + r5[9] * i, this.z = r5[2] * e + r5[6] * n4 + r5[10] * i, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Gt$2(this.x, t.x, e.x), this.y = Gt$2(this.y, t.y, e.y), this.z = Gt$2(this.z, t.z, e.z), this;
  }
  clampScalar(t, e) {
    return this.x = Gt$2(this.x, t, e), this.y = Gt$2(this.y, t, e), this.z = Gt$2(this.z, t, e), this;
  }
  clampLength(t, e) {
    let n4 = this.length();
    return this.divideScalar(n4 || 1).multiplyScalar(Gt$2(n4, t, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, n4) {
    return this.x = t.x + (e.x - t.x) * n4, this.y = t.y + (e.y - t.y) * n4, this.z = t.z + (e.z - t.z) * n4, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    let n4 = t.x, i = t.y, r5 = t.z, a4 = e.x, o4 = e.y, l = e.z;
    return this.x = i * l - r5 * o4, this.y = r5 * a4 - n4 * l, this.z = n4 * o4 - i * a4, this;
  }
  projectOnVector(t) {
    let e = t.lengthSq();
    if (e === 0) return this.set(0, 0, 0);
    let n4 = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n4);
  }
  projectOnPlane(t) {
    return Ro$2.copy(this).projectOnVector(t), this.sub(Ro$2);
  }
  reflect(t) {
    return this.sub(Ro$2.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    let e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    let n4 = this.dot(t) / e;
    return Math.acos(Gt$2(n4, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    let e = this.x - t.x, n4 = this.y - t.y, i = this.z - t.z;
    return e * e + n4 * n4 + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, n4) {
    let i = Math.sin(e) * t;
    return this.x = i * Math.sin(n4), this.y = Math.cos(e) * t, this.z = i * Math.cos(n4), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, n4) {
    return this.x = t * Math.sin(e), this.y = n4, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    let e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    let e = this.setFromMatrixColumn(t, 0).length(), n4 = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = n4, this.z = i, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  setFromColor(t) {
    return this.x = t.r, this.y = t.g, this.z = t.b, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    let t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, n4 = Math.sqrt(1 - e * e);
    return this.x = n4 * Math.cos(t), this.y = e, this.z = n4 * Math.sin(t), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
H$3(pa$2, "Vector3");
var I$1 = pa$2, Ro$2 = new I$1(), ed$2 = new En$1(), Rc$2 = class Rc {
  constructor(t = new I$1(1 / 0, 1 / 0, 1 / 0), e = new I$1(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = t, this.max = e;
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let e = 0, n4 = t.length; e < n4; e += 3) this.expandByPoint(Ke$1.fromArray(t, e));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let e = 0, n4 = t.count; e < n4; e++) this.expandByPoint(Ke$1.fromBufferAttribute(t, e));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n4 = t.length; e < n4; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    let n4 = Ke$1.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n4), this.max.copy(t).add(n4), this;
  }
  setFromObject(t, e = false) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = false) {
    t.updateWorldMatrix(false, false);
    let n4 = t.geometry;
    if (n4 !== void 0) {
      let r5 = n4.getAttribute("position");
      if (e === true && r5 !== void 0 && t.isInstancedMesh !== true) for (let a4 = 0, o4 = r5.count; a4 < o4; a4++) t.isMesh === true ? t.getVertexPosition(a4, Ke$1) : Ke$1.fromBufferAttribute(r5, a4), Ke$1.applyMatrix4(t.matrixWorld), this.expandByPoint(Ke$1);
      else t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), js$2.copy(t.boundingBox)) : (n4.boundingBox === null && n4.computeBoundingBox(), js$2.copy(n4.boundingBox)), js$2.applyMatrix4(t.matrixWorld), this.union(js$2);
    }
    let i = t.children;
    for (let r5 = 0, a4 = i.length; r5 < a4; r5++) this.expandByObject(i[r5], e);
    return this;
  }
  containsPoint(t) {
    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  }
  getParameter(t, e) {
    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(t) {
    return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z;
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, Ke$1), Ke$1.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let e, n4;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n4 = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n4 = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n4 += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n4 += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n4 += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n4 += t.normal.z * this.min.z), e <= -t.constant && n4 >= -t.constant;
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return false;
    this.getCenter(es), tr$3.subVectors(this.max, es), Ti$3.subVectors(t.a, es), Ai$2.subVectors(t.b, es), wi$2.subVectors(t.c, es), Pn$3.subVectors(Ai$2, Ti$3), Dn$1.subVectors(wi$2, Ai$2), Yn$1.subVectors(Ti$3, wi$2);
    let e = [0, -Pn$3.z, Pn$3.y, 0, -Dn$1.z, Dn$1.y, 0, -Yn$1.z, Yn$1.y, Pn$3.z, 0, -Pn$3.x, Dn$1.z, 0, -Dn$1.x, Yn$1.z, 0, -Yn$1.x, -Pn$3.y, Pn$3.x, 0, -Dn$1.y, Dn$1.x, 0, -Yn$1.y, Yn$1.x, 0];
    return !Io$2(e, Ti$3, Ai$2, wi$2, tr$3) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Io$2(e, Ti$3, Ai$2, wi$2, tr$3)) ? false : (er$2.crossVectors(Pn$3, Dn$1), e = [er$2.x, er$2.y, er$2.z], Io$2(e, Ti$3, Ai$2, wi$2, tr$3));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, Ke$1).distanceTo(t);
  }
  getBoundingSphere(t) {
    return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(Ke$1).length() * 0.5), t;
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty() ? this : (fn$1[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), fn$1[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), fn$1[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), fn$1[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), fn$1[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), fn$1[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), fn$1[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), fn$1[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(fn$1), this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
};
H$3(Rc$2, "Box3");
var Pe$3 = Rc$2, fn$1 = [new I$1(), new I$1(), new I$1(), new I$1(), new I$1(), new I$1(), new I$1(), new I$1()], Ke$1 = new I$1(), js$2 = new Pe$3(), Ti$3 = new I$1(), Ai$2 = new I$1(), wi$2 = new I$1(), Pn$3 = new I$1(), Dn$1 = new I$1(), Yn$1 = new I$1(), es = new I$1(), tr$3 = new I$1(), er$2 = new I$1(), Zn$1 = new I$1();
function Io$2(s5, t, e, n4, i) {
  for (let r5 = 0, a4 = s5.length - 3; r5 <= a4; r5 += 3) {
    Zn$1.fromArray(s5, r5);
    let o4 = i.x * Math.abs(Zn$1.x) + i.y * Math.abs(Zn$1.y) + i.z * Math.abs(Zn$1.z), l = t.dot(Zn$1), c = e.dot(Zn$1), u5 = n4.dot(Zn$1);
    if (Math.max(-Math.max(l, c, u5), Math.min(l, c, u5)) > o4) return false;
  }
  return true;
}
H$3(Io$2, "satForAxes");
var Qp$2 = new Pe$3(), ns$1 = new I$1(), Po$2 = new I$1(), Ic$2 = class Ic {
  constructor(t = new I$1(), e = -1) {
    this.isSphere = true, this.center = t, this.radius = e;
  }
  set(t, e) {
    return this.center.copy(t), this.radius = e, this;
  }
  setFromPoints(t, e) {
    let n4 = this.center;
    e !== void 0 ? n4.copy(e) : Qp$2.setFromPoints(t).getCenter(n4);
    let i = 0;
    for (let r5 = 0, a4 = t.length; r5 < a4; r5++) i = Math.max(i, n4.distanceToSquared(t[r5]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    let e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    let n4 = this.center.distanceToSquared(t);
    return e.copy(t), n4 > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(t) {
    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
    ns$1.subVectors(t, this.center);
    let e = ns$1.lengthSq();
    if (e > this.radius * this.radius) {
      let n4 = Math.sqrt(e), i = (n4 - this.radius) * 0.5;
      this.center.addScaledVector(ns$1, i / n4), this.radius += i;
    }
    return this;
  }
  union(t) {
    return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === true ? this.radius = Math.max(this.radius, t.radius) : (Po$2.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(ns$1.copy(t.center).add(Po$2)), this.expandByPoint(ns$1.copy(t.center).sub(Po$2))), this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
H$3(Ic$2, "Sphere");
var Ae$3 = Ic$2, pn = new I$1(), Do$2 = new I$1(), nr$2 = new I$1(), Ln$2 = new I$1(), Lo$2 = new I$1(), ir$2 = new I$1(), Uo$2 = new I$1(), Pc$2 = class Pc {
  constructor(t = new I$1(), e = new I$1(0, 0, -1)) {
    this.origin = t, this.direction = e;
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, pn)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    let n4 = e.dot(this.direction);
    return n4 < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n4);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    let e = pn.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (pn.copy(this.origin).addScaledVector(this.direction, e), pn.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, n4, i) {
    Do$2.copy(t).add(e).multiplyScalar(0.5), nr$2.copy(e).sub(t).normalize(), Ln$2.copy(this.origin).sub(Do$2);
    let r5 = t.distanceTo(e) * 0.5, a4 = -this.direction.dot(nr$2), o4 = Ln$2.dot(this.direction), l = -Ln$2.dot(nr$2), c = Ln$2.lengthSq(), u5 = Math.abs(1 - a4 * a4), d, f, m5, _;
    if (u5 > 0) if (d = a4 * l - o4, f = a4 * o4 - l, _ = r5 * u5, d >= 0) if (f >= -_) if (f <= _) {
      let x2 = 1 / u5;
      d *= x2, f *= x2, m5 = d * (d + a4 * f + 2 * o4) + f * (a4 * d + f + 2 * l) + c;
    } else f = r5, d = Math.max(0, -(a4 * f + o4)), m5 = -d * d + f * (f + 2 * l) + c;
    else f = -r5, d = Math.max(0, -(a4 * f + o4)), m5 = -d * d + f * (f + 2 * l) + c;
    else f <= -_ ? (d = Math.max(0, -(-a4 * r5 + o4)), f = d > 0 ? -r5 : Math.min(Math.max(-r5, -l), r5), m5 = -d * d + f * (f + 2 * l) + c) : f <= _ ? (d = 0, f = Math.min(Math.max(-r5, -l), r5), m5 = f * (f + 2 * l) + c) : (d = Math.max(0, -(a4 * r5 + o4)), f = d > 0 ? r5 : Math.min(Math.max(-r5, -l), r5), m5 = -d * d + f * (f + 2 * l) + c);
    else f = a4 > 0 ? -r5 : r5, d = Math.max(0, -(a4 * f + o4)), m5 = -d * d + f * (f + 2 * l) + c;
    return n4 && n4.copy(this.origin).addScaledVector(this.direction, d), i && i.copy(Do$2).addScaledVector(nr$2, f), m5;
  }
  intersectSphere(t, e) {
    pn.subVectors(t.center, this.origin);
    let n4 = pn.dot(this.direction), i = pn.dot(pn) - n4 * n4, r5 = t.radius * t.radius;
    if (i > r5) return null;
    let a4 = Math.sqrt(r5 - i), o4 = n4 - a4, l = n4 + a4;
    return l < 0 ? null : o4 < 0 ? this.at(l, e) : this.at(o4, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    let e = t.normal.dot(this.direction);
    if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    let n4 = -(this.origin.dot(t.normal) + t.constant) / e;
    return n4 >= 0 ? n4 : null;
  }
  intersectPlane(t, e) {
    let n4 = this.distanceToPlane(t);
    return n4 === null ? null : this.at(n4, e);
  }
  intersectsPlane(t) {
    let e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let n4, i, r5, a4, o4, l, c = 1 / this.direction.x, u5 = 1 / this.direction.y, d = 1 / this.direction.z, f = this.origin;
    return c >= 0 ? (n4 = (t.min.x - f.x) * c, i = (t.max.x - f.x) * c) : (n4 = (t.max.x - f.x) * c, i = (t.min.x - f.x) * c), u5 >= 0 ? (r5 = (t.min.y - f.y) * u5, a4 = (t.max.y - f.y) * u5) : (r5 = (t.max.y - f.y) * u5, a4 = (t.min.y - f.y) * u5), n4 > a4 || r5 > i || ((r5 > n4 || isNaN(n4)) && (n4 = r5), (a4 < i || isNaN(i)) && (i = a4), d >= 0 ? (o4 = (t.min.z - f.z) * d, l = (t.max.z - f.z) * d) : (o4 = (t.max.z - f.z) * d, l = (t.min.z - f.z) * d), n4 > l || o4 > i) || ((o4 > n4 || n4 !== n4) && (n4 = o4), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n4 >= 0 ? n4 : i, e);
  }
  intersectsBox(t) {
    return this.intersectBox(t, pn) !== null;
  }
  intersectTriangle(t, e, n4, i, r5) {
    Lo$2.subVectors(e, t), ir$2.subVectors(n4, t), Uo$2.crossVectors(Lo$2, ir$2);
    let a4 = this.direction.dot(Uo$2), o4;
    if (a4 > 0) {
      if (i) return null;
      o4 = 1;
    } else if (a4 < 0) o4 = -1, a4 = -a4;
    else return null;
    Ln$2.subVectors(this.origin, t);
    let l = o4 * this.direction.dot(ir$2.crossVectors(Ln$2, ir$2));
    if (l < 0) return null;
    let c = o4 * this.direction.dot(Lo$2.cross(Ln$2));
    if (c < 0 || l + c > a4) return null;
    let u5 = -o4 * Ln$2.dot(Uo$2);
    return u5 < 0 ? null : this.at(u5 / a4, r5);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
H$3(Pc$2, "Ray");
var Hn$1 = Pc$2, fs$2 = class fs {
  constructor(t, e, n4, i, r5, a4, o4, l, c, u5, d, f, m5, _, x2, g) {
    fs.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], t !== void 0 && this.set(t, e, n4, i, r5, a4, o4, l, c, u5, d, f, m5, _, x2, g);
  }
  set(t, e, n4, i, r5, a4, o4, l, c, u5, d, f, m5, _, x2, g) {
    let p4 = this.elements;
    return p4[0] = t, p4[4] = e, p4[8] = n4, p4[12] = i, p4[1] = r5, p4[5] = a4, p4[9] = o4, p4[13] = l, p4[2] = c, p4[6] = u5, p4[10] = d, p4[14] = f, p4[3] = m5, p4[7] = _, p4[11] = x2, p4[15] = g, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new fs().fromArray(this.elements);
  }
  copy(t) {
    let e = this.elements, n4 = t.elements;
    return e[0] = n4[0], e[1] = n4[1], e[2] = n4[2], e[3] = n4[3], e[4] = n4[4], e[5] = n4[5], e[6] = n4[6], e[7] = n4[7], e[8] = n4[8], e[9] = n4[9], e[10] = n4[10], e[11] = n4[11], e[12] = n4[12], e[13] = n4[13], e[14] = n4[14], e[15] = n4[15], this;
  }
  copyPosition(t) {
    let e = this.elements, n4 = t.elements;
    return e[12] = n4[12], e[13] = n4[13], e[14] = n4[14], this;
  }
  setFromMatrix3(t) {
    let e = t.elements;
    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(t, e, n4) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n4.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, n4) {
    return this.set(t.x, e.x, n4.x, 0, t.y, e.y, n4.y, 0, t.z, e.z, n4.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(t) {
    let e = this.elements, n4 = t.elements, i = 1 / Ci$1.setFromMatrixColumn(t, 0).length(), r5 = 1 / Ci$1.setFromMatrixColumn(t, 1).length(), a4 = 1 / Ci$1.setFromMatrixColumn(t, 2).length();
    return e[0] = n4[0] * i, e[1] = n4[1] * i, e[2] = n4[2] * i, e[3] = 0, e[4] = n4[4] * r5, e[5] = n4[5] * r5, e[6] = n4[6] * r5, e[7] = 0, e[8] = n4[8] * a4, e[9] = n4[9] * a4, e[10] = n4[10] * a4, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    let e = this.elements, n4 = t.x, i = t.y, r5 = t.z, a4 = Math.cos(n4), o4 = Math.sin(n4), l = Math.cos(i), c = Math.sin(i), u5 = Math.cos(r5), d = Math.sin(r5);
    if (t.order === "XYZ") {
      let f = a4 * u5, m5 = a4 * d, _ = o4 * u5, x2 = o4 * d;
      e[0] = l * u5, e[4] = -l * d, e[8] = c, e[1] = m5 + _ * c, e[5] = f - x2 * c, e[9] = -o4 * l, e[2] = x2 - f * c, e[6] = _ + m5 * c, e[10] = a4 * l;
    } else if (t.order === "YXZ") {
      let f = l * u5, m5 = l * d, _ = c * u5, x2 = c * d;
      e[0] = f + x2 * o4, e[4] = _ * o4 - m5, e[8] = a4 * c, e[1] = a4 * d, e[5] = a4 * u5, e[9] = -o4, e[2] = m5 * o4 - _, e[6] = x2 + f * o4, e[10] = a4 * l;
    } else if (t.order === "ZXY") {
      let f = l * u5, m5 = l * d, _ = c * u5, x2 = c * d;
      e[0] = f - x2 * o4, e[4] = -a4 * d, e[8] = _ + m5 * o4, e[1] = m5 + _ * o4, e[5] = a4 * u5, e[9] = x2 - f * o4, e[2] = -a4 * c, e[6] = o4, e[10] = a4 * l;
    } else if (t.order === "ZYX") {
      let f = a4 * u5, m5 = a4 * d, _ = o4 * u5, x2 = o4 * d;
      e[0] = l * u5, e[4] = _ * c - m5, e[8] = f * c + x2, e[1] = l * d, e[5] = x2 * c + f, e[9] = m5 * c - _, e[2] = -c, e[6] = o4 * l, e[10] = a4 * l;
    } else if (t.order === "YZX") {
      let f = a4 * l, m5 = a4 * c, _ = o4 * l, x2 = o4 * c;
      e[0] = l * u5, e[4] = x2 - f * d, e[8] = _ * d + m5, e[1] = d, e[5] = a4 * u5, e[9] = -o4 * u5, e[2] = -c * u5, e[6] = m5 * d + _, e[10] = f - x2 * d;
    } else if (t.order === "XZY") {
      let f = a4 * l, m5 = a4 * c, _ = o4 * l, x2 = o4 * c;
      e[0] = l * u5, e[4] = -d, e[8] = c * u5, e[1] = f * d + x2, e[5] = a4 * u5, e[9] = m5 * d - _, e[2] = _ * d - m5, e[6] = o4 * u5, e[10] = x2 * d + f;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(jp$2, t, tm$2);
  }
  lookAt(t, e, n4) {
    let i = this.elements;
    return ze$1.subVectors(t, e), ze$1.lengthSq() === 0 && (ze$1.z = 1), ze$1.normalize(), Un$2.crossVectors(n4, ze$1), Un$2.lengthSq() === 0 && (Math.abs(n4.z) === 1 ? ze$1.x += 1e-4 : ze$1.z += 1e-4, ze$1.normalize(), Un$2.crossVectors(n4, ze$1)), Un$2.normalize(), sr$1.crossVectors(ze$1, Un$2), i[0] = Un$2.x, i[4] = sr$1.x, i[8] = ze$1.x, i[1] = Un$2.y, i[5] = sr$1.y, i[9] = ze$1.y, i[2] = Un$2.z, i[6] = sr$1.z, i[10] = ze$1.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    let n4 = t.elements, i = e.elements, r5 = this.elements, a4 = n4[0], o4 = n4[4], l = n4[8], c = n4[12], u5 = n4[1], d = n4[5], f = n4[9], m5 = n4[13], _ = n4[2], x2 = n4[6], g = n4[10], p4 = n4[14], w3 = n4[3], b = n4[7], y4 = n4[11], D4 = n4[15], C3 = i[0], R3 = i[4], L3 = i[8], E4 = i[12], S4 = i[1], P4 = i[5], G3 = i[9], B3 = i[13], V3 = i[2], J4 = i[6], H5 = i[10], it2 = i[14], W4 = i[3], lt2 = i[7], gt2 = i[11], bt2 = i[15];
    return r5[0] = a4 * C3 + o4 * S4 + l * V3 + c * W4, r5[4] = a4 * R3 + o4 * P4 + l * J4 + c * lt2, r5[8] = a4 * L3 + o4 * G3 + l * H5 + c * gt2, r5[12] = a4 * E4 + o4 * B3 + l * it2 + c * bt2, r5[1] = u5 * C3 + d * S4 + f * V3 + m5 * W4, r5[5] = u5 * R3 + d * P4 + f * J4 + m5 * lt2, r5[9] = u5 * L3 + d * G3 + f * H5 + m5 * gt2, r5[13] = u5 * E4 + d * B3 + f * it2 + m5 * bt2, r5[2] = _ * C3 + x2 * S4 + g * V3 + p4 * W4, r5[6] = _ * R3 + x2 * P4 + g * J4 + p4 * lt2, r5[10] = _ * L3 + x2 * G3 + g * H5 + p4 * gt2, r5[14] = _ * E4 + x2 * B3 + g * it2 + p4 * bt2, r5[3] = w3 * C3 + b * S4 + y4 * V3 + D4 * W4, r5[7] = w3 * R3 + b * P4 + y4 * J4 + D4 * lt2, r5[11] = w3 * L3 + b * G3 + y4 * H5 + D4 * gt2, r5[15] = w3 * E4 + b * B3 + y4 * it2 + D4 * bt2, this;
  }
  multiplyScalar(t) {
    let e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    let t = this.elements, e = t[0], n4 = t[4], i = t[8], r5 = t[12], a4 = t[1], o4 = t[5], l = t[9], c = t[13], u5 = t[2], d = t[6], f = t[10], m5 = t[14], _ = t[3], x2 = t[7], g = t[11], p4 = t[15];
    return _ * (+r5 * l * d - i * c * d - r5 * o4 * f + n4 * c * f + i * o4 * m5 - n4 * l * m5) + x2 * (+e * l * m5 - e * c * f + r5 * a4 * f - i * a4 * m5 + i * c * u5 - r5 * l * u5) + g * (+e * c * d - e * o4 * m5 - r5 * a4 * d + n4 * a4 * m5 + r5 * o4 * u5 - n4 * c * u5) + p4 * (-i * o4 * u5 - e * l * d + e * o4 * f + i * a4 * d - n4 * a4 * f + n4 * l * u5);
  }
  transpose() {
    let t = this.elements, e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, n4) {
    let i = this.elements;
    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n4), this;
  }
  invert() {
    let t = this.elements, e = t[0], n4 = t[1], i = t[2], r5 = t[3], a4 = t[4], o4 = t[5], l = t[6], c = t[7], u5 = t[8], d = t[9], f = t[10], m5 = t[11], _ = t[12], x2 = t[13], g = t[14], p4 = t[15], w3 = d * g * c - x2 * f * c + x2 * l * m5 - o4 * g * m5 - d * l * p4 + o4 * f * p4, b = _ * f * c - u5 * g * c - _ * l * m5 + a4 * g * m5 + u5 * l * p4 - a4 * f * p4, y4 = u5 * x2 * c - _ * d * c + _ * o4 * m5 - a4 * x2 * m5 - u5 * o4 * p4 + a4 * d * p4, D4 = _ * d * l - u5 * x2 * l - _ * o4 * f + a4 * x2 * f + u5 * o4 * g - a4 * d * g, C3 = e * w3 + n4 * b + i * y4 + r5 * D4;
    if (C3 === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    let R3 = 1 / C3;
    return t[0] = w3 * R3, t[1] = (x2 * f * r5 - d * g * r5 - x2 * i * m5 + n4 * g * m5 + d * i * p4 - n4 * f * p4) * R3, t[2] = (o4 * g * r5 - x2 * l * r5 + x2 * i * c - n4 * g * c - o4 * i * p4 + n4 * l * p4) * R3, t[3] = (d * l * r5 - o4 * f * r5 - d * i * c + n4 * f * c + o4 * i * m5 - n4 * l * m5) * R3, t[4] = b * R3, t[5] = (u5 * g * r5 - _ * f * r5 + _ * i * m5 - e * g * m5 - u5 * i * p4 + e * f * p4) * R3, t[6] = (_ * l * r5 - a4 * g * r5 - _ * i * c + e * g * c + a4 * i * p4 - e * l * p4) * R3, t[7] = (a4 * f * r5 - u5 * l * r5 + u5 * i * c - e * f * c - a4 * i * m5 + e * l * m5) * R3, t[8] = y4 * R3, t[9] = (_ * d * r5 - u5 * x2 * r5 - _ * n4 * m5 + e * x2 * m5 + u5 * n4 * p4 - e * d * p4) * R3, t[10] = (a4 * x2 * r5 - _ * o4 * r5 + _ * n4 * c - e * x2 * c - a4 * n4 * p4 + e * o4 * p4) * R3, t[11] = (u5 * o4 * r5 - a4 * d * r5 - u5 * n4 * c + e * d * c + a4 * n4 * m5 - e * o4 * m5) * R3, t[12] = D4 * R3, t[13] = (u5 * x2 * i - _ * d * i + _ * n4 * f - e * x2 * f - u5 * n4 * g + e * d * g) * R3, t[14] = (_ * o4 * i - a4 * x2 * i - _ * n4 * l + e * x2 * l + a4 * n4 * g - e * o4 * g) * R3, t[15] = (a4 * d * i - u5 * o4 * i + u5 * n4 * l - e * d * l - a4 * n4 * f + e * o4 * f) * R3, this;
  }
  scale(t) {
    let e = this.elements, n4 = t.x, i = t.y, r5 = t.z;
    return e[0] *= n4, e[4] *= i, e[8] *= r5, e[1] *= n4, e[5] *= i, e[9] *= r5, e[2] *= n4, e[6] *= i, e[10] *= r5, e[3] *= n4, e[7] *= i, e[11] *= r5, this;
  }
  getMaxScaleOnAxis() {
    let t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n4 = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n4, i));
  }
  makeTranslation(t, e, n4) {
    return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n4, 0, 0, 0, 1), this;
  }
  makeRotationX(t) {
    let e = Math.cos(t), n4 = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -n4, 0, 0, n4, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    let e = Math.cos(t), n4 = Math.sin(t);
    return this.set(e, 0, n4, 0, 0, 1, 0, 0, -n4, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    let e = Math.cos(t), n4 = Math.sin(t);
    return this.set(e, -n4, 0, 0, n4, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    let n4 = Math.cos(e), i = Math.sin(e), r5 = 1 - n4, a4 = t.x, o4 = t.y, l = t.z, c = r5 * a4, u5 = r5 * o4;
    return this.set(c * a4 + n4, c * o4 - i * l, c * l + i * o4, 0, c * o4 + i * l, u5 * o4 + n4, u5 * l - i * a4, 0, c * l - i * o4, u5 * l + i * a4, r5 * l * l + n4, 0, 0, 0, 0, 1), this;
  }
  makeScale(t, e, n4) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n4, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, n4, i, r5, a4) {
    return this.set(1, n4, r5, 0, t, 1, a4, 0, e, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, n4) {
    let i = this.elements, r5 = e._x, a4 = e._y, o4 = e._z, l = e._w, c = r5 + r5, u5 = a4 + a4, d = o4 + o4, f = r5 * c, m5 = r5 * u5, _ = r5 * d, x2 = a4 * u5, g = a4 * d, p4 = o4 * d, w3 = l * c, b = l * u5, y4 = l * d, D4 = n4.x, C3 = n4.y, R3 = n4.z;
    return i[0] = (1 - (x2 + p4)) * D4, i[1] = (m5 + y4) * D4, i[2] = (_ - b) * D4, i[3] = 0, i[4] = (m5 - y4) * C3, i[5] = (1 - (f + p4)) * C3, i[6] = (g + w3) * C3, i[7] = 0, i[8] = (_ + b) * R3, i[9] = (g - w3) * R3, i[10] = (1 - (f + x2)) * R3, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
  }
  decompose(t, e, n4) {
    let i = this.elements, r5 = Ci$1.set(i[0], i[1], i[2]).length(), a4 = Ci$1.set(i[4], i[5], i[6]).length(), o4 = Ci$1.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r5 = -r5), t.x = i[12], t.y = i[13], t.z = i[14], Qe$1.copy(this);
    let c = 1 / r5, u5 = 1 / a4, d = 1 / o4;
    return Qe$1.elements[0] *= c, Qe$1.elements[1] *= c, Qe$1.elements[2] *= c, Qe$1.elements[4] *= u5, Qe$1.elements[5] *= u5, Qe$1.elements[6] *= u5, Qe$1.elements[8] *= d, Qe$1.elements[9] *= d, Qe$1.elements[10] *= d, e.setFromRotationMatrix(Qe$1), n4.x = r5, n4.y = a4, n4.z = o4, this;
  }
  makePerspective(t, e, n4, i, r5, a4, o4 = an) {
    let l = this.elements, c = 2 * r5 / (e - t), u5 = 2 * r5 / (n4 - i), d = (e + t) / (e - t), f = (n4 + i) / (n4 - i), m5, _;
    if (o4 === an) m5 = -(a4 + r5) / (a4 - r5), _ = -2 * a4 * r5 / (a4 - r5);
    else if (o4 === gs$1) m5 = -a4 / (a4 - r5), _ = -a4 * r5 / (a4 - r5);
    else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o4);
    return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = u5, l[9] = f, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m5, l[14] = _, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(t, e, n4, i, r5, a4, o4 = an) {
    let l = this.elements, c = 1 / (e - t), u5 = 1 / (n4 - i), d = 1 / (a4 - r5), f = (e + t) * c, m5 = (n4 + i) * u5, _, x2;
    if (o4 === an) _ = (a4 + r5) * d, x2 = -2 * d;
    else if (o4 === gs$1) _ = r5 * d, x2 = -1 * d;
    else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o4);
    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -f, l[1] = 0, l[5] = 2 * u5, l[9] = 0, l[13] = -m5, l[2] = 0, l[6] = 0, l[10] = x2, l[14] = -_, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(t) {
    let e = this.elements, n4 = t.elements;
    for (let i = 0; i < 16; i++) if (e[i] !== n4[i]) return false;
    return true;
  }
  fromArray(t, e = 0) {
    for (let n4 = 0; n4 < 16; n4++) this.elements[n4] = t[n4 + e];
    return this;
  }
  toArray(t = [], e = 0) {
    let n4 = this.elements;
    return t[e] = n4[0], t[e + 1] = n4[1], t[e + 2] = n4[2], t[e + 3] = n4[3], t[e + 4] = n4[4], t[e + 5] = n4[5], t[e + 6] = n4[6], t[e + 7] = n4[7], t[e + 8] = n4[8], t[e + 9] = n4[9], t[e + 10] = n4[10], t[e + 11] = n4[11], t[e + 12] = n4[12], t[e + 13] = n4[13], t[e + 14] = n4[14], t[e + 15] = n4[15], t;
  }
};
H$3(fs$2, "Matrix4");
var Vt$2 = fs$2, Ci$1 = new I$1(), Qe$1 = new Vt$2(), jp$2 = new I$1(0, 0, 0), tm$2 = new I$1(1, 1, 1), Un$2 = new I$1(), sr$1 = new I$1(), ze$1 = new I$1(), nd$1 = new Vt$2(), id$1 = new En$1(), ma$2 = class ma {
  constructor(t = 0, e = 0, n4 = 0, i = ma.DEFAULT_ORDER) {
    this.isEuler = true, this._x = t, this._y = e, this._z = n4, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, n4, i = this._order) {
    return this._x = t, this._y = e, this._z = n4, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, n4 = true) {
    let i = t.elements, r5 = i[0], a4 = i[4], o4 = i[8], l = i[1], c = i[5], u5 = i[9], d = i[2], f = i[6], m5 = i[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(Gt$2(o4, -1, 1)), Math.abs(o4) < 0.9999999 ? (this._x = Math.atan2(-u5, m5), this._z = Math.atan2(-a4, r5)) : (this._x = Math.atan2(f, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Gt$2(u5, -1, 1)), Math.abs(u5) < 0.9999999 ? (this._y = Math.atan2(o4, m5), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, r5), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Gt$2(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(-d, m5), this._z = Math.atan2(-a4, c)) : (this._y = 0, this._z = Math.atan2(l, r5));
        break;
      case "ZYX":
        this._y = Math.asin(-Gt$2(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(f, m5), this._z = Math.atan2(l, r5)) : (this._x = 0, this._z = Math.atan2(-a4, c));
        break;
      case "YZX":
        this._z = Math.asin(Gt$2(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u5, c), this._y = Math.atan2(-d, r5)) : (this._x = 0, this._y = Math.atan2(o4, m5));
        break;
      case "XZY":
        this._z = Math.asin(-Gt$2(a4, -1, 1)), Math.abs(a4) < 0.9999999 ? (this._x = Math.atan2(f, c), this._y = Math.atan2(o4, r5)) : (this._x = Math.atan2(-u5, m5), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, n4 === true && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, n4) {
    return nd$1.makeRotationFromQuaternion(t), this.setFromRotationMatrix(nd$1, e, n4);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return id$1.setFromEuler(this), this.setFromQuaternion(id$1, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
};
H$3(ma$2, "Euler");
var Ze$1 = ma$2;
Ze$1.DEFAULT_ORDER = "XYZ";
var Dc$1 = class Dc {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t | 0) >>> 0;
  }
  enable(t) {
    this.mask |= 1 << t | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t | 0;
  }
  disable(t) {
    this.mask &= ~(1 << t | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & (1 << t | 0)) !== 0;
  }
};
H$3(Dc$1, "Layers");
var Wi$2 = Dc$1, em$1 = 0, sd$1 = new I$1(), Ri$1 = new En$1(), mn$1 = new Vt$2(), rr$2 = new I$1(), is$1 = new I$1(), nm$2 = new I$1(), im$2 = new En$1(), rd$2 = new I$1(1, 0, 0), ad$1 = new I$1(0, 1, 0), od$1 = new I$1(0, 0, 1), ld$2 = { type: "added" }, sm$2 = { type: "removed" }, Ii$1 = { type: "childadded", child: null }, No$1 = { type: "childremoved", child: null }, zi$2 = class zi extends bn$2 {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: em$1++ }), this.uuid = Ye(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = zi.DEFAULT_UP.clone();
    let t = new I$1(), e = new Ze$1(), n4 = new En$1(), i = new I$1(1, 1, 1);
    function r5() {
      n4.setFromEuler(e, false);
    }
    H$3(r5, "onRotationChange");
    function a4() {
      e.setFromQuaternion(n4, void 0, false);
    }
    H$3(a4, "onQuaternionChange"), e._onChange(r5), n4._onChange(a4), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t }, rotation: { configurable: true, enumerable: true, value: e }, quaternion: { configurable: true, enumerable: true, value: n4 }, scale: { configurable: true, enumerable: true, value: i }, modelViewMatrix: { value: new Vt$2() }, normalMatrix: { value: new Bt$2() } }), this.matrix = new Vt$2(), this.matrixWorld = new Vt$2(), this.matrixAutoUpdate = zi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = zi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Wi$2(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, true);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return Ri$1.setFromAxisAngle(t, e), this.quaternion.multiply(Ri$1), this;
  }
  rotateOnWorldAxis(t, e) {
    return Ri$1.setFromAxisAngle(t, e), this.quaternion.premultiply(Ri$1), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(rd$2, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(ad$1, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(od$1, t);
  }
  translateOnAxis(t, e) {
    return sd$1.copy(t).applyQuaternion(this.quaternion), this.position.add(sd$1.multiplyScalar(e)), this;
  }
  translateX(t) {
    return this.translateOnAxis(rd$2, t);
  }
  translateY(t) {
    return this.translateOnAxis(ad$1, t);
  }
  translateZ(t) {
    return this.translateOnAxis(od$1, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(true, false), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(true, false), t.applyMatrix4(mn$1.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, n4) {
    t.isVector3 ? rr$2.copy(t) : rr$2.set(t, e, n4);
    let i = this.parent;
    this.updateWorldMatrix(true, false), is$1.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? mn$1.lookAt(is$1, rr$2, this.up) : mn$1.lookAt(rr$2, is$1, this.up), this.quaternion.setFromRotationMatrix(mn$1), i && (mn$1.extractRotation(i.matrixWorld), Ri$1.setFromRotationMatrix(mn$1), this.quaternion.premultiply(Ri$1.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(ld$2), Ii$1.child = t, this.dispatchEvent(Ii$1), Ii$1.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let n4 = 0; n4 < arguments.length; n4++) this.remove(arguments[n4]);
      return this;
    }
    let e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(sm$2), No$1.child = t, this.dispatchEvent(No$1), No$1.child = null), this;
  }
  removeFromParent() {
    let t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return this.updateWorldMatrix(true, false), mn$1.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(true, false), mn$1.multiply(t.parent.matrixWorld)), t.applyMatrix4(mn$1), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(false, true), t.dispatchEvent(ld$2), Ii$1.child = t, this.dispatchEvent(Ii$1), Ii$1.child = null, this;
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this;
    for (let n4 = 0, i = this.children.length; n4 < i; n4++) {
      let a4 = this.children[n4].getObjectByProperty(t, e);
      if (a4 !== void 0) return a4;
    }
  }
  getObjectsByProperty(t, e, n4 = []) {
    this[t] === e && n4.push(this);
    let i = this.children;
    for (let r5 = 0, a4 = i.length; r5 < a4; r5++) i[r5].getObjectsByProperty(t, e, n4);
    return n4;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(is$1, t, nm$2), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(is$1, im$2, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(true, false);
    let e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(t) {
    t(this);
    let e = this.children;
    for (let n4 = 0, i = e.length; n4 < i; n4++) e[n4].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === false) return;
    t(this);
    let e = this.children;
    for (let n4 = 0, i = e.length; n4 < i; n4++) e[n4].traverseVisible(t);
  }
  traverseAncestors(t) {
    let e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, t = true);
    let e = this.children;
    for (let n4 = 0, i = e.length; n4 < i; n4++) e[n4].updateMatrixWorld(t);
  }
  updateWorldMatrix(t, e) {
    let n4 = this.parent;
    if (t === true && n4 !== null && n4.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), e === true) {
      let i = this.children;
      for (let r5 = 0, a4 = i.length; r5 < a4; r5++) i[r5].updateWorldMatrix(false, true);
    }
  }
  toJSON(t) {
    let e = t === void 0 || typeof t == "string", n4 = {};
    e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n4.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
    let i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === true && (i.castShadow = true), this.receiveShadow === true && (i.receiveShadow = true), this.visible === false && (i.visible = false), this.frustumCulled === false && (i.frustumCulled = false), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === false && (i.matrixAutoUpdate = false), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((o4) => ({ boxInitialized: o4.boxInitialized, boxMin: o4.box.min.toArray(), boxMax: o4.box.max.toArray(), sphereInitialized: o4.sphereInitialized, sphereRadius: o4.sphere.radius, sphereCenter: o4.sphere.center.toArray() })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (i.boundingSphere = { center: i.boundingSphere.center.toArray(), radius: i.boundingSphere.radius }), this.boundingBox !== null && (i.boundingBox = { min: i.boundingBox.min.toArray(), max: i.boundingBox.max.toArray() }));
    function r5(o4, l) {
      return o4[l.uuid] === void 0 && (o4[l.uuid] = l.toJSON(t)), l.uuid;
    }
    if (H$3(r5, "serialize"), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (i.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r5(t.geometries, this.geometry);
      let o4 = this.geometry.parameters;
      if (o4 !== void 0 && o4.shapes !== void 0) {
        let l = o4.shapes;
        if (Array.isArray(l)) for (let c = 0, u5 = l.length; c < u5; c++) {
          let d = l[c];
          r5(t.shapes, d);
        }
        else r5(t.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r5(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
      let o4 = [];
      for (let l = 0, c = this.material.length; l < c; l++) o4.push(r5(t.materials, this.material[l]));
      i.material = o4;
    } else i.material = r5(t.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o4 = 0; o4 < this.children.length; o4++) i.children.push(this.children[o4].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let o4 = 0; o4 < this.animations.length; o4++) {
        let l = this.animations[o4];
        i.animations.push(r5(t.animations, l));
      }
    }
    if (e) {
      let o4 = a4(t.geometries), l = a4(t.materials), c = a4(t.textures), u5 = a4(t.images), d = a4(t.shapes), f = a4(t.skeletons), m5 = a4(t.animations), _ = a4(t.nodes);
      o4.length > 0 && (n4.geometries = o4), l.length > 0 && (n4.materials = l), c.length > 0 && (n4.textures = c), u5.length > 0 && (n4.images = u5), d.length > 0 && (n4.shapes = d), f.length > 0 && (n4.skeletons = f), m5.length > 0 && (n4.animations = m5), _.length > 0 && (n4.nodes = _);
    }
    return n4.object = i, n4;
    function a4(o4) {
      let l = [];
      for (let c in o4) {
        let u5 = o4[c];
        delete u5.metadata, l.push(u5);
      }
      return l;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = true) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === true) for (let n4 = 0; n4 < t.children.length; n4++) {
      let i = t.children[n4];
      this.add(i.clone());
    }
    return this;
  }
};
H$3(zi$2, "Object3D");
var fe$2 = zi$2;
fe$2.DEFAULT_UP = new I$1(0, 1, 0);
fe$2.DEFAULT_MATRIX_AUTO_UPDATE = true;
fe$2.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var je$2 = new I$1(), gn$1 = new I$1(), Fo$2 = new I$1(), _n$2 = new I$1(), Pi$3 = new I$1(), Di$2 = new I$1(), cd$1 = new I$1(), Oo$2 = new I$1(), Bo$3 = new I$1(), zo$2 = new I$1(), ko$1 = new $t$3(), Vo$3 = new $t$3(), Ho$2 = new $t$3(), On$2 = class On {
  constructor(t = new I$1(), e = new I$1(), n4 = new I$1()) {
    this.a = t, this.b = e, this.c = n4;
  }
  static getNormal(t, e, n4, i) {
    i.subVectors(n4, e), je$2.subVectors(t, e), i.cross(je$2);
    let r5 = i.lengthSq();
    return r5 > 0 ? i.multiplyScalar(1 / Math.sqrt(r5)) : i.set(0, 0, 0);
  }
  static getBarycoord(t, e, n4, i, r5) {
    je$2.subVectors(i, e), gn$1.subVectors(n4, e), Fo$2.subVectors(t, e);
    let a4 = je$2.dot(je$2), o4 = je$2.dot(gn$1), l = je$2.dot(Fo$2), c = gn$1.dot(gn$1), u5 = gn$1.dot(Fo$2), d = a4 * c - o4 * o4;
    if (d === 0) return r5.set(0, 0, 0), null;
    let f = 1 / d, m5 = (c * l - o4 * u5) * f, _ = (a4 * u5 - o4 * l) * f;
    return r5.set(1 - m5 - _, _, m5);
  }
  static containsPoint(t, e, n4, i) {
    return this.getBarycoord(t, e, n4, i, _n$2) === null ? false : _n$2.x >= 0 && _n$2.y >= 0 && _n$2.x + _n$2.y <= 1;
  }
  static getInterpolation(t, e, n4, i, r5, a4, o4, l) {
    return this.getBarycoord(t, e, n4, i, _n$2) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r5, _n$2.x), l.addScaledVector(a4, _n$2.y), l.addScaledVector(o4, _n$2.z), l);
  }
  static getInterpolatedAttribute(t, e, n4, i, r5, a4) {
    return ko$1.setScalar(0), Vo$3.setScalar(0), Ho$2.setScalar(0), ko$1.fromBufferAttribute(t, e), Vo$3.fromBufferAttribute(t, n4), Ho$2.fromBufferAttribute(t, i), a4.setScalar(0), a4.addScaledVector(ko$1, r5.x), a4.addScaledVector(Vo$3, r5.y), a4.addScaledVector(Ho$2, r5.z), a4;
  }
  static isFrontFacing(t, e, n4, i) {
    return je$2.subVectors(n4, e), gn$1.subVectors(t, e), je$2.cross(gn$1).dot(i) < 0;
  }
  set(t, e, n4) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n4), this;
  }
  setFromPointsAndIndices(t, e, n4, i) {
    return this.a.copy(t[e]), this.b.copy(t[n4]), this.c.copy(t[i]), this;
  }
  setFromAttributeAndIndices(t, e, n4, i) {
    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n4), this.c.fromBufferAttribute(t, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return je$2.subVectors(this.c, this.b), gn$1.subVectors(this.a, this.b), je$2.cross(gn$1).length() * 0.5;
  }
  getMidpoint(t) {
    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return On.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return On.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getInterpolation(t, e, n4, i, r5) {
    return On.getInterpolation(t, this.a, this.b, this.c, e, n4, i, r5);
  }
  containsPoint(t) {
    return On.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return On.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    let n4 = this.a, i = this.b, r5 = this.c, a4, o4;
    Pi$3.subVectors(i, n4), Di$2.subVectors(r5, n4), Oo$2.subVectors(t, n4);
    let l = Pi$3.dot(Oo$2), c = Di$2.dot(Oo$2);
    if (l <= 0 && c <= 0) return e.copy(n4);
    Bo$3.subVectors(t, i);
    let u5 = Pi$3.dot(Bo$3), d = Di$2.dot(Bo$3);
    if (u5 >= 0 && d <= u5) return e.copy(i);
    let f = l * d - u5 * c;
    if (f <= 0 && l >= 0 && u5 <= 0) return a4 = l / (l - u5), e.copy(n4).addScaledVector(Pi$3, a4);
    zo$2.subVectors(t, r5);
    let m5 = Pi$3.dot(zo$2), _ = Di$2.dot(zo$2);
    if (_ >= 0 && m5 <= _) return e.copy(r5);
    let x2 = m5 * c - l * _;
    if (x2 <= 0 && c >= 0 && _ <= 0) return o4 = c / (c - _), e.copy(n4).addScaledVector(Di$2, o4);
    let g = u5 * _ - m5 * d;
    if (g <= 0 && d - u5 >= 0 && m5 - _ >= 0) return cd$1.subVectors(r5, i), o4 = (d - u5) / (d - u5 + (m5 - _)), e.copy(i).addScaledVector(cd$1, o4);
    let p4 = 1 / (g + x2 + f);
    return a4 = x2 * p4, o4 = f * p4, e.copy(n4).addScaledVector(Pi$3, a4).addScaledVector(Di$2, o4);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
};
H$3(On$2, "Triangle");
var vn$1 = On$2, Ff$1 = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Nn$2 = { h: 0, s: 0, l: 0 }, ar$1 = { h: 0, s: 0, l: 0 };
function Go$1(s5, t, e) {
  return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? s5 + (t - s5) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? s5 + (t - s5) * 6 * (2 / 3 - e) : s5;
}
H$3(Go$1, "hue2rgb");
var Lc$1 = class Lc {
  constructor(t, e, n4) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n4);
  }
  set(t, e, n4) {
    if (e === void 0 && n4 === void 0) {
      let i = t;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(t, e, n4);
    return this;
  }
  setScalar(t) {
    return this.r = t, this.g = t, this.b = t, this;
  }
  setHex(t, e = Ve$1) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, qt$2.toWorkingColorSpace(this, e), this;
  }
  setRGB(t, e, n4, i = qt$2.workingColorSpace) {
    return this.r = t, this.g = e, this.b = n4, qt$2.toWorkingColorSpace(this, i), this;
  }
  setHSL(t, e, n4, i = qt$2.workingColorSpace) {
    if (t = pc$2(t, 1), e = Gt$2(e, 0, 1), n4 = Gt$2(n4, 0, 1), e === 0) this.r = this.g = this.b = n4;
    else {
      let r5 = n4 <= 0.5 ? n4 * (1 + e) : n4 + e - n4 * e, a4 = 2 * n4 - r5;
      this.r = Go$1(a4, r5, t + 1 / 3), this.g = Go$1(a4, r5, t), this.b = Go$1(a4, r5, t - 1 / 3);
    }
    return qt$2.toWorkingColorSpace(this, i), this;
  }
  setStyle(t, e = Ve$1) {
    function n4(r5) {
      r5 !== void 0 && parseFloat(r5) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    H$3(n4, "handleAlpha");
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
      let r5, a4 = i[1], o4 = i[2];
      switch (a4) {
        case "rgb":
        case "rgba":
          if (r5 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o4)) return n4(r5[4]), this.setRGB(Math.min(255, parseInt(r5[1], 10)) / 255, Math.min(255, parseInt(r5[2], 10)) / 255, Math.min(255, parseInt(r5[3], 10)) / 255, e);
          if (r5 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o4)) return n4(r5[4]), this.setRGB(Math.min(100, parseInt(r5[1], 10)) / 100, Math.min(100, parseInt(r5[2], 10)) / 100, Math.min(100, parseInt(r5[3], 10)) / 100, e);
          break;
        case "hsl":
        case "hsla":
          if (r5 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o4)) return n4(r5[4]), this.setHSL(parseFloat(r5[1]) / 360, parseFloat(r5[2]) / 100, parseFloat(r5[3]) / 100, e);
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + t);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
      let r5 = i[1], a4 = r5.length;
      if (a4 === 3) return this.setRGB(parseInt(r5.charAt(0), 16) / 15, parseInt(r5.charAt(1), 16) / 15, parseInt(r5.charAt(2), 16) / 15, e);
      if (a4 === 6) return this.setHex(parseInt(r5, 16), e);
      console.warn("THREE.Color: Invalid hex color " + t);
    } else if (t && t.length > 0) return this.setColorName(t, e);
    return this;
  }
  setColorName(t, e = Ve$1) {
    let n4 = Ff$1[t.toLowerCase()];
    return n4 !== void 0 ? this.setHex(n4, e) : console.warn("THREE.Color: Unknown color " + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  }
  copySRGBToLinear(t) {
    return this.r = Mn$2(t.r), this.g = Mn$2(t.g), this.b = Mn$2(t.b), this;
  }
  copyLinearToSRGB(t) {
    return this.r = Vi$1(t.r), this.g = Vi$1(t.g), this.b = Vi$1(t.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = Ve$1) {
    return qt$2.fromWorkingColorSpace(be$2.copy(this), t), Math.round(Gt$2(be$2.r * 255, 0, 255)) * 65536 + Math.round(Gt$2(be$2.g * 255, 0, 255)) * 256 + Math.round(Gt$2(be$2.b * 255, 0, 255));
  }
  getHexString(t = Ve$1) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = qt$2.workingColorSpace) {
    qt$2.fromWorkingColorSpace(be$2.copy(this), e);
    let n4 = be$2.r, i = be$2.g, r5 = be$2.b, a4 = Math.max(n4, i, r5), o4 = Math.min(n4, i, r5), l, c, u5 = (o4 + a4) / 2;
    if (o4 === a4) l = 0, c = 0;
    else {
      let d = a4 - o4;
      switch (c = u5 <= 0.5 ? d / (a4 + o4) : d / (2 - a4 - o4), a4) {
        case n4:
          l = (i - r5) / d + (i < r5 ? 6 : 0);
          break;
        case i:
          l = (r5 - n4) / d + 2;
          break;
        case r5:
          l = (n4 - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return t.h = l, t.s = c, t.l = u5, t;
  }
  getRGB(t, e = qt$2.workingColorSpace) {
    return qt$2.fromWorkingColorSpace(be$2.copy(this), e), t.r = be$2.r, t.g = be$2.g, t.b = be$2.b, t;
  }
  getStyle(t = Ve$1) {
    qt$2.fromWorkingColorSpace(be$2.copy(this), t);
    let e = be$2.r, n4 = be$2.g, i = be$2.b;
    return t !== Ve$1 ? "color(".concat(t, " ").concat(e.toFixed(3), " ").concat(n4.toFixed(3), " ").concat(i.toFixed(3), ")") : "rgb(".concat(Math.round(e * 255), ",").concat(Math.round(n4 * 255), ",").concat(Math.round(i * 255), ")");
  }
  offsetHSL(t, e, n4) {
    return this.getHSL(Nn$2), this.setHSL(Nn$2.h + t, Nn$2.s + e, Nn$2.l + n4);
  }
  add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  }
  addColors(t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  }
  addScalar(t) {
    return this.r += t, this.g += t, this.b += t, this;
  }
  sub(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  }
  multiply(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  }
  multiplyScalar(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  }
  lerp(t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  }
  lerpColors(t, e, n4) {
    return this.r = t.r + (e.r - t.r) * n4, this.g = t.g + (e.g - t.g) * n4, this.b = t.b + (e.b - t.b) * n4, this;
  }
  lerpHSL(t, e) {
    this.getHSL(Nn$2), t.getHSL(ar$1);
    let n4 = hs$2(Nn$2.h, ar$1.h, e), i = hs$2(Nn$2.s, ar$1.s, e), r5 = hs$2(Nn$2.l, ar$1.l, e);
    return this.setHSL(n4, i, r5), this;
  }
  setFromVector3(t) {
    return this.r = t.x, this.g = t.y, this.b = t.z, this;
  }
  applyMatrix3(t) {
    let e = this.r, n4 = this.g, i = this.b, r5 = t.elements;
    return this.r = r5[0] * e + r5[3] * n4 + r5[6] * i, this.g = r5[1] * e + r5[4] * n4 + r5[7] * i, this.b = r5[2] * e + r5[5] * n4 + r5[8] * i, this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  }
  fromBufferAttribute(t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
H$3(Lc$1, "Color");
var Ft$3 = Lc$1, be$2 = new Ft$3();
Ft$3.NAMES = Ff$1;
var rm$1 = 0, Uc$2 = class Uc extends bn$2 {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: rm$1++ }), this.uuid = Ye(), this.name = "", this.type = "Material", this.blending = ni$1, this.side = Sn$2, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = Dr$1, this.blendDst = Lr$2, this.blendEquation = Vn$3, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ft$3(0, 0, 0), this.blendAlpha = 0, this.depthFunc = ii$1, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = cl$2, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = jn$3, this.stencilZFail = jn$3, this.stencilZPass = jn$3, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0) for (let e in t) {
      let n4 = t[e];
      if (n4 === void 0) {
        console.warn("THREE.Material: parameter '".concat(e, "' has value of undefined."));
        continue;
      }
      let i = this[e];
      if (i === void 0) {
        console.warn("THREE.Material: '".concat(e, "' is not a property of THREE.").concat(this.type, "."));
        continue;
      }
      i && i.isColor ? i.set(n4) : i && i.isVector3 && n4 && n4.isVector3 ? i.copy(n4) : this[e] = n4;
    }
  }
  toJSON(t) {
    let e = t === void 0 || typeof t == "string";
    e && (t = { textures: {}, images: {} });
    let n4 = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
    n4.uuid = this.uuid, n4.type = this.type, this.name !== "" && (n4.name = this.name), this.color && this.color.isColor && (n4.color = this.color.getHex()), this.roughness !== void 0 && (n4.roughness = this.roughness), this.metalness !== void 0 && (n4.metalness = this.metalness), this.sheen !== void 0 && (n4.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n4.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n4.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n4.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n4.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n4.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n4.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n4.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n4.shininess = this.shininess), this.clearcoat !== void 0 && (n4.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n4.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n4.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n4.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n4.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n4.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n4.dispersion = this.dispersion), this.iridescence !== void 0 && (n4.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n4.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n4.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n4.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n4.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (n4.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n4.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n4.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n4.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n4.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n4.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n4.lightMap = this.lightMap.toJSON(t).uuid, n4.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n4.aoMap = this.aoMap.toJSON(t).uuid, n4.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n4.bumpMap = this.bumpMap.toJSON(t).uuid, n4.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n4.normalMap = this.normalMap.toJSON(t).uuid, n4.normalMapType = this.normalMapType, n4.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n4.displacementMap = this.displacementMap.toJSON(t).uuid, n4.displacementScale = this.displacementScale, n4.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n4.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n4.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n4.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n4.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n4.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n4.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n4.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n4.combine = this.combine)), this.envMapRotation !== void 0 && (n4.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n4.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n4.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n4.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n4.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n4.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n4.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n4.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n4.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n4.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n4.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n4.size = this.size), this.shadowSide !== null && (n4.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n4.sizeAttenuation = this.sizeAttenuation), this.blending !== ni$1 && (n4.blending = this.blending), this.side !== Sn$2 && (n4.side = this.side), this.vertexColors === true && (n4.vertexColors = true), this.opacity < 1 && (n4.opacity = this.opacity), this.transparent === true && (n4.transparent = true), this.blendSrc !== Dr$1 && (n4.blendSrc = this.blendSrc), this.blendDst !== Lr$2 && (n4.blendDst = this.blendDst), this.blendEquation !== Vn$3 && (n4.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n4.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n4.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n4.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n4.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n4.blendAlpha = this.blendAlpha), this.depthFunc !== ii$1 && (n4.depthFunc = this.depthFunc), this.depthTest === false && (n4.depthTest = this.depthTest), this.depthWrite === false && (n4.depthWrite = this.depthWrite), this.colorWrite === false && (n4.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n4.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== cl$2 && (n4.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n4.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n4.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== jn$3 && (n4.stencilFail = this.stencilFail), this.stencilZFail !== jn$3 && (n4.stencilZFail = this.stencilZFail), this.stencilZPass !== jn$3 && (n4.stencilZPass = this.stencilZPass), this.stencilWrite === true && (n4.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n4.rotation = this.rotation), this.polygonOffset === true && (n4.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n4.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n4.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n4.linewidth = this.linewidth), this.dashSize !== void 0 && (n4.dashSize = this.dashSize), this.gapSize !== void 0 && (n4.gapSize = this.gapSize), this.scale !== void 0 && (n4.scale = this.scale), this.dithering === true && (n4.dithering = true), this.alphaTest > 0 && (n4.alphaTest = this.alphaTest), this.alphaHash === true && (n4.alphaHash = true), this.alphaToCoverage === true && (n4.alphaToCoverage = true), this.premultipliedAlpha === true && (n4.premultipliedAlpha = true), this.forceSinglePass === true && (n4.forceSinglePass = true), this.wireframe === true && (n4.wireframe = true), this.wireframeLinewidth > 1 && (n4.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n4.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n4.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n4.flatShading = true), this.visible === false && (n4.visible = false), this.toneMapped === false && (n4.toneMapped = false), this.fog === false && (n4.fog = false), Object.keys(this.userData).length > 0 && (n4.userData = this.userData);
    function i(r5) {
      let a4 = [];
      for (let o4 in r5) {
        let l = r5[o4];
        delete l.metadata, a4.push(l);
      }
      return a4;
    }
    if (H$3(i, "extractFromCache"), e) {
      let r5 = i(t.textures), a4 = i(t.images);
      r5.length > 0 && (n4.textures = r5), a4.length > 0 && (n4.images = a4);
    }
    return n4;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    let e = t.clippingPlanes, n4 = null;
    if (e !== null) {
      let i = e.length;
      n4 = new Array(i);
      for (let r5 = 0; r5 !== i; ++r5) n4[r5] = e[r5].clone();
    }
    return this.clippingPlanes = n4, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === true && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
};
H$3(Uc$2, "Material");
var nn$2 = Uc$2, Nc$2 = class Nc extends nn$2 {
  constructor(t) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Ft$3(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ze$1(), this.combine = Ua$1, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
};
H$3(Nc$2, "MeshBasicMaterial");
var vs$1 = Nc$2;
var de$2 = new I$1(), or$2 = new ot$1(), am$2 = 0, Fc$2 = class Fc {
  constructor(t, e, n4 = false) {
    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, Object.defineProperty(this, "id", { value: am$2++ }), this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n4, this.usage = Or$3, this.updateRanges = [], this.gpuType = Oe$1, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === true && this.version++;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
  }
  copyAt(t, e, n4) {
    t *= this.itemSize, n4 *= e.itemSize;
    for (let i = 0, r5 = this.itemSize; i < r5; i++) this.array[t + i] = e.array[n4 + i];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2) for (let e = 0, n4 = this.count; e < n4; e++) or$2.fromBufferAttribute(this, e), or$2.applyMatrix3(t), this.setXY(e, or$2.x, or$2.y);
    else if (this.itemSize === 3) for (let e = 0, n4 = this.count; e < n4; e++) de$2.fromBufferAttribute(this, e), de$2.applyMatrix3(t), this.setXYZ(e, de$2.x, de$2.y, de$2.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, n4 = this.count; e < n4; e++) de$2.fromBufferAttribute(this, e), de$2.applyMatrix4(t), this.setXYZ(e, de$2.x, de$2.y, de$2.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n4 = this.count; e < n4; e++) de$2.fromBufferAttribute(this, e), de$2.applyNormalMatrix(t), this.setXYZ(e, de$2.x, de$2.y, de$2.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n4 = this.count; e < n4; e++) de$2.fromBufferAttribute(this, e), de$2.transformDirection(t), this.setXYZ(e, de$2.x, de$2.y, de$2.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getComponent(t, e) {
    let n4 = this.array[t * this.itemSize + e];
    return this.normalized && (n4 = tn$2(n4, this.array)), n4;
  }
  setComponent(t, e, n4) {
    return this.normalized && (n4 = ne$1(n4, this.array)), this.array[t * this.itemSize + e] = n4, this;
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  setX(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.array[t * this.itemSize] = e, this;
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  setY(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  setZ(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  setW(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
  }
  setXY(t, e, n4) {
    return t *= this.itemSize, this.normalized && (e = ne$1(e, this.array), n4 = ne$1(n4, this.array)), this.array[t + 0] = e, this.array[t + 1] = n4, this;
  }
  setXYZ(t, e, n4, i) {
    return t *= this.itemSize, this.normalized && (e = ne$1(e, this.array), n4 = ne$1(n4, this.array), i = ne$1(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n4, this.array[t + 2] = i, this;
  }
  setXYZW(t, e, n4, i, r5) {
    return t *= this.itemSize, this.normalized && (e = ne$1(e, this.array), n4 = ne$1(n4, this.array), i = ne$1(i, this.array), r5 = ne$1(r5, this.array)), this.array[t + 0] = e, this.array[t + 1] = n4, this.array[t + 2] = i, this.array[t + 3] = r5, this;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    let t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (t.name = this.name), this.usage !== Or$3 && (t.usage = this.usage), t;
  }
};
H$3(Fc$2, "BufferAttribute");
var ve$3 = Fc$2;
var Oc$2 = class Oc extends ve$3 {
  constructor(t, e, n4) {
    super(new Uint16Array(t), e, n4);
  }
};
H$3(Oc$2, "Uint16BufferAttribute");
var ys$1 = Oc$2;
var Bc$2 = class Bc extends ve$3 {
  constructor(t, e, n4) {
    super(new Uint32Array(t), e, n4);
  }
};
H$3(Bc$2, "Uint32BufferAttribute");
var Ms$1 = Bc$2;
var zc$2 = class zc extends ve$3 {
  constructor(t, e, n4) {
    super(new Float32Array(t), e, n4);
  }
};
H$3(zc$2, "Float32BufferAttribute");
var re$4 = zc$2, om$2 = 0, qe$2 = new Vt$2(), Wo$2 = new fe$2(), Li$3 = new I$1(), ke$2 = new Pe$3(), ss$2 = new Pe$3(), _e$2 = new I$1(), ga$2 = class ga extends bn$2 {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: om$2++ }), this.uuid = Ye(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? this.index = new (mc$2(t) ? Ms$1 : ys$1)(t, 1) : this.index = t, this;
  }
  setIndirect(t) {
    return this.indirect = t, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return this.attributes[t] = e, this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, n4 = 0) {
    this.groups.push({ start: t, count: e, materialIndex: n4 });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  }
  applyMatrix4(t) {
    let e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = true);
    let n4 = this.attributes.normal;
    if (n4 !== void 0) {
      let r5 = new Bt$2().getNormalMatrix(t);
      n4.applyNormalMatrix(r5), n4.needsUpdate = true;
    }
    let i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(t), i.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t) {
    return qe$2.makeRotationFromQuaternion(t), this.applyMatrix4(qe$2), this;
  }
  rotateX(t) {
    return qe$2.makeRotationX(t), this.applyMatrix4(qe$2), this;
  }
  rotateY(t) {
    return qe$2.makeRotationY(t), this.applyMatrix4(qe$2), this;
  }
  rotateZ(t) {
    return qe$2.makeRotationZ(t), this.applyMatrix4(qe$2), this;
  }
  translate(t, e, n4) {
    return qe$2.makeTranslation(t, e, n4), this.applyMatrix4(qe$2), this;
  }
  scale(t, e, n4) {
    return qe$2.makeScale(t, e, n4), this.applyMatrix4(qe$2), this;
  }
  lookAt(t) {
    return Wo$2.lookAt(t), Wo$2.updateMatrix(), this.applyMatrix4(Wo$2.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Li$3).negate(), this.translate(Li$3.x, Li$3.y, Li$3.z), this;
  }
  setFromPoints(t) {
    let e = this.getAttribute("position");
    if (e === void 0) {
      let n4 = [];
      for (let i = 0, r5 = t.length; i < r5; i++) {
        let a4 = t[i];
        n4.push(a4.x, a4.y, a4.z || 0);
      }
      this.setAttribute("position", new re$4(n4, 3));
    } else {
      let n4 = Math.min(t.length, e.count);
      for (let i = 0; i < n4; i++) {
        let r5 = t[i];
        e.setXYZ(i, r5.x, r5.y, r5.z || 0);
      }
      t.length > e.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), e.needsUpdate = true;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Pe$3());
    let t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new I$1(-1 / 0, -1 / 0, -1 / 0), new I$1(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e) for (let n4 = 0, i = e.length; n4 < i; n4++) {
        let r5 = e[n4];
        ke$2.setFromBufferAttribute(r5), this.morphTargetsRelative ? (_e$2.addVectors(this.boundingBox.min, ke$2.min), this.boundingBox.expandByPoint(_e$2), _e$2.addVectors(this.boundingBox.max, ke$2.max), this.boundingBox.expandByPoint(_e$2)) : (this.boundingBox.expandByPoint(ke$2.min), this.boundingBox.expandByPoint(ke$2.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ae$3());
    let t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new I$1(), 1 / 0);
      return;
    }
    if (t) {
      let n4 = this.boundingSphere.center;
      if (ke$2.setFromBufferAttribute(t), e) for (let r5 = 0, a4 = e.length; r5 < a4; r5++) {
        let o4 = e[r5];
        ss$2.setFromBufferAttribute(o4), this.morphTargetsRelative ? (_e$2.addVectors(ke$2.min, ss$2.min), ke$2.expandByPoint(_e$2), _e$2.addVectors(ke$2.max, ss$2.max), ke$2.expandByPoint(_e$2)) : (ke$2.expandByPoint(ss$2.min), ke$2.expandByPoint(ss$2.max));
      }
      ke$2.getCenter(n4);
      let i = 0;
      for (let r5 = 0, a4 = t.count; r5 < a4; r5++) _e$2.fromBufferAttribute(t, r5), i = Math.max(i, n4.distanceToSquared(_e$2));
      if (e) for (let r5 = 0, a4 = e.length; r5 < a4; r5++) {
        let o4 = e[r5], l = this.morphTargetsRelative;
        for (let c = 0, u5 = o4.count; c < u5; c++) _e$2.fromBufferAttribute(o4, c), l && (Li$3.fromBufferAttribute(t, c), _e$2.add(Li$3)), i = Math.max(i, n4.distanceToSquared(_e$2));
      }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    let t = this.index, e = this.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    let n4 = e.position, i = e.normal, r5 = e.uv;
    this.hasAttribute("tangent") === false && this.setAttribute("tangent", new ve$3(new Float32Array(4 * n4.count), 4));
    let a4 = this.getAttribute("tangent"), o4 = [], l = [];
    for (let L3 = 0; L3 < n4.count; L3++) o4[L3] = new I$1(), l[L3] = new I$1();
    let c = new I$1(), u5 = new I$1(), d = new I$1(), f = new ot$1(), m5 = new ot$1(), _ = new ot$1(), x2 = new I$1(), g = new I$1();
    function p4(L3, E4, S4) {
      c.fromBufferAttribute(n4, L3), u5.fromBufferAttribute(n4, E4), d.fromBufferAttribute(n4, S4), f.fromBufferAttribute(r5, L3), m5.fromBufferAttribute(r5, E4), _.fromBufferAttribute(r5, S4), u5.sub(c), d.sub(c), m5.sub(f), _.sub(f);
      let P4 = 1 / (m5.x * _.y - _.x * m5.y);
      isFinite(P4) && (x2.copy(u5).multiplyScalar(_.y).addScaledVector(d, -m5.y).multiplyScalar(P4), g.copy(d).multiplyScalar(m5.x).addScaledVector(u5, -_.x).multiplyScalar(P4), o4[L3].add(x2), o4[E4].add(x2), o4[S4].add(x2), l[L3].add(g), l[E4].add(g), l[S4].add(g));
    }
    H$3(p4, "handleTriangle");
    let w3 = this.groups;
    w3.length === 0 && (w3 = [{ start: 0, count: t.count }]);
    for (let L3 = 0, E4 = w3.length; L3 < E4; ++L3) {
      let S4 = w3[L3], P4 = S4.start, G3 = S4.count;
      for (let B3 = P4, V3 = P4 + G3; B3 < V3; B3 += 3) p4(t.getX(B3 + 0), t.getX(B3 + 1), t.getX(B3 + 2));
    }
    let b = new I$1(), y4 = new I$1(), D4 = new I$1(), C3 = new I$1();
    function R3(L3) {
      D4.fromBufferAttribute(i, L3), C3.copy(D4);
      let E4 = o4[L3];
      b.copy(E4), b.sub(D4.multiplyScalar(D4.dot(E4))).normalize(), y4.crossVectors(C3, E4);
      let P4 = y4.dot(l[L3]) < 0 ? -1 : 1;
      a4.setXYZW(L3, b.x, b.y, b.z, P4);
    }
    H$3(R3, "handleVertex");
    for (let L3 = 0, E4 = w3.length; L3 < E4; ++L3) {
      let S4 = w3[L3], P4 = S4.start, G3 = S4.count;
      for (let B3 = P4, V3 = P4 + G3; B3 < V3; B3 += 3) R3(t.getX(B3 + 0)), R3(t.getX(B3 + 1)), R3(t.getX(B3 + 2));
    }
  }
  computeVertexNormals() {
    let t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let n4 = this.getAttribute("normal");
      if (n4 === void 0) n4 = new ve$3(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n4);
      else for (let f = 0, m5 = n4.count; f < m5; f++) n4.setXYZ(f, 0, 0, 0);
      let i = new I$1(), r5 = new I$1(), a4 = new I$1(), o4 = new I$1(), l = new I$1(), c = new I$1(), u5 = new I$1(), d = new I$1();
      if (t) for (let f = 0, m5 = t.count; f < m5; f += 3) {
        let _ = t.getX(f + 0), x2 = t.getX(f + 1), g = t.getX(f + 2);
        i.fromBufferAttribute(e, _), r5.fromBufferAttribute(e, x2), a4.fromBufferAttribute(e, g), u5.subVectors(a4, r5), d.subVectors(i, r5), u5.cross(d), o4.fromBufferAttribute(n4, _), l.fromBufferAttribute(n4, x2), c.fromBufferAttribute(n4, g), o4.add(u5), l.add(u5), c.add(u5), n4.setXYZ(_, o4.x, o4.y, o4.z), n4.setXYZ(x2, l.x, l.y, l.z), n4.setXYZ(g, c.x, c.y, c.z);
      }
      else for (let f = 0, m5 = e.count; f < m5; f += 3) i.fromBufferAttribute(e, f + 0), r5.fromBufferAttribute(e, f + 1), a4.fromBufferAttribute(e, f + 2), u5.subVectors(a4, r5), d.subVectors(i, r5), u5.cross(d), n4.setXYZ(f + 0, u5.x, u5.y, u5.z), n4.setXYZ(f + 1, u5.x, u5.y, u5.z), n4.setXYZ(f + 2, u5.x, u5.y, u5.z);
      this.normalizeNormals(), n4.needsUpdate = true;
    }
  }
  normalizeNormals() {
    let t = this.attributes.normal;
    for (let e = 0, n4 = t.count; e < n4; e++) _e$2.fromBufferAttribute(t, e), _e$2.normalize(), t.setXYZ(e, _e$2.x, _e$2.y, _e$2.z);
  }
  toNonIndexed() {
    function t(o4, l) {
      let c = o4.array, u5 = o4.itemSize, d = o4.normalized, f = new c.constructor(l.length * u5), m5 = 0, _ = 0;
      for (let x2 = 0, g = l.length; x2 < g; x2++) {
        o4.isInterleavedBufferAttribute ? m5 = l[x2] * o4.data.stride + o4.offset : m5 = l[x2] * u5;
        for (let p4 = 0; p4 < u5; p4++) f[_++] = c[m5++];
      }
      return new ve$3(f, u5, d);
    }
    if (H$3(t, "convertBufferAttribute"), this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    let e = new ga(), n4 = this.index.array, i = this.attributes;
    for (let o4 in i) {
      let l = i[o4], c = t(l, n4);
      e.setAttribute(o4, c);
    }
    let r5 = this.morphAttributes;
    for (let o4 in r5) {
      let l = [], c = r5[o4];
      for (let u5 = 0, d = c.length; u5 < d; u5++) {
        let f = c[u5], m5 = t(f, n4);
        l.push(m5);
      }
      e.morphAttributes[o4] = l;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    let a4 = this.groups;
    for (let o4 = 0, l = a4.length; o4 < l; o4++) {
      let c = a4[o4];
      e.addGroup(c.start, c.count, c.materialIndex);
    }
    return e;
  }
  toJSON() {
    let t = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      let l = this.parameters;
      for (let c in l) l[c] !== void 0 && (t[c] = l[c]);
      return t;
    }
    t.data = { attributes: {} };
    let e = this.index;
    e !== null && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
    let n4 = this.attributes;
    for (let l in n4) {
      let c = n4[l];
      t.data.attributes[l] = c.toJSON(t.data);
    }
    let i = {}, r5 = false;
    for (let l in this.morphAttributes) {
      let c = this.morphAttributes[l], u5 = [];
      for (let d = 0, f = c.length; d < f; d++) {
        let m5 = c[d];
        u5.push(m5.toJSON(t.data));
      }
      u5.length > 0 && (i[l] = u5, r5 = true);
    }
    r5 && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
    let a4 = this.groups;
    a4.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a4)));
    let o4 = this.boundingSphere;
    return o4 !== null && (t.data.boundingSphere = { center: o4.center.toArray(), radius: o4.radius }), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    let e = {};
    this.name = t.name;
    let n4 = t.index;
    n4 !== null && this.setIndex(n4.clone(e));
    let i = t.attributes;
    for (let c in i) {
      let u5 = i[c];
      this.setAttribute(c, u5.clone(e));
    }
    let r5 = t.morphAttributes;
    for (let c in r5) {
      let u5 = [], d = r5[c];
      for (let f = 0, m5 = d.length; f < m5; f++) u5.push(d[f].clone(e));
      this.morphAttributes[c] = u5;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    let a4 = t.groups;
    for (let c = 0, u5 = a4.length; c < u5; c++) {
      let d = a4[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    let o4 = t.boundingBox;
    o4 !== null && (this.boundingBox = o4.clone());
    let l = t.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
H$3(ga$2, "BufferGeometry");
var pe$3 = ga$2, hd$2 = new Vt$2(), Jn$1 = new Hn$1(), lr$1 = new Ae$3(), ud$2 = new I$1(), cr$1 = new I$1(), hr$1 = new I$1(), ur$1 = new I$1(), Xo$2 = new I$1(), dr = new I$1(), dd$2 = new I$1(), fr$2 = new I$1(), kc$2 = class kc extends fe$2 {
  constructor(t = new pe$3(), e = new vs$1()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  updateMorphTargets() {
    let e = this.geometry.morphAttributes, n4 = Object.keys(e);
    if (n4.length > 0) {
      let i = e[n4[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r5 = 0, a4 = i.length; r5 < a4; r5++) {
          let o4 = i[r5].name || String(r5);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o4] = r5;
        }
      }
    }
  }
  getVertexPosition(t, e) {
    let n4 = this.geometry, i = n4.attributes.position, r5 = n4.morphAttributes.position, a4 = n4.morphTargetsRelative;
    e.fromBufferAttribute(i, t);
    let o4 = this.morphTargetInfluences;
    if (r5 && o4) {
      dr.set(0, 0, 0);
      for (let l = 0, c = r5.length; l < c; l++) {
        let u5 = o4[l], d = r5[l];
        u5 !== 0 && (Xo$2.fromBufferAttribute(d, t), a4 ? dr.addScaledVector(Xo$2, u5) : dr.addScaledVector(Xo$2.sub(e), u5));
      }
      e.add(dr);
    }
    return e;
  }
  raycast(t, e) {
    let n4 = this.geometry, i = this.material, r5 = this.matrixWorld;
    i !== void 0 && (n4.boundingSphere === null && n4.computeBoundingSphere(), lr$1.copy(n4.boundingSphere), lr$1.applyMatrix4(r5), Jn$1.copy(t.ray).recast(t.near), !(lr$1.containsPoint(Jn$1.origin) === false && (Jn$1.intersectSphere(lr$1, ud$2) === null || Jn$1.origin.distanceToSquared(ud$2) > (t.far - t.near) ** 2)) && (hd$2.copy(r5).invert(), Jn$1.copy(t.ray).applyMatrix4(hd$2), !(n4.boundingBox !== null && Jn$1.intersectsBox(n4.boundingBox) === false) && this._computeIntersections(t, e, Jn$1)));
  }
  _computeIntersections(t, e, n4) {
    let i, r5 = this.geometry, a4 = this.material, o4 = r5.index, l = r5.attributes.position, c = r5.attributes.uv, u5 = r5.attributes.uv1, d = r5.attributes.normal, f = r5.groups, m5 = r5.drawRange;
    if (o4 !== null) if (Array.isArray(a4)) for (let _ = 0, x2 = f.length; _ < x2; _++) {
      let g = f[_], p4 = a4[g.materialIndex], w3 = Math.max(g.start, m5.start), b = Math.min(o4.count, Math.min(g.start + g.count, m5.start + m5.count));
      for (let y4 = w3, D4 = b; y4 < D4; y4 += 3) {
        let C3 = o4.getX(y4), R3 = o4.getX(y4 + 1), L3 = o4.getX(y4 + 2);
        i = pr$1(this, p4, t, n4, c, u5, d, C3, R3, L3), i && (i.faceIndex = Math.floor(y4 / 3), i.face.materialIndex = g.materialIndex, e.push(i));
      }
    }
    else {
      let _ = Math.max(0, m5.start), x2 = Math.min(o4.count, m5.start + m5.count);
      for (let g = _, p4 = x2; g < p4; g += 3) {
        let w3 = o4.getX(g), b = o4.getX(g + 1), y4 = o4.getX(g + 2);
        i = pr$1(this, a4, t, n4, c, u5, d, w3, b, y4), i && (i.faceIndex = Math.floor(g / 3), e.push(i));
      }
    }
    else if (l !== void 0) if (Array.isArray(a4)) for (let _ = 0, x2 = f.length; _ < x2; _++) {
      let g = f[_], p4 = a4[g.materialIndex], w3 = Math.max(g.start, m5.start), b = Math.min(l.count, Math.min(g.start + g.count, m5.start + m5.count));
      for (let y4 = w3, D4 = b; y4 < D4; y4 += 3) {
        let C3 = y4, R3 = y4 + 1, L3 = y4 + 2;
        i = pr$1(this, p4, t, n4, c, u5, d, C3, R3, L3), i && (i.faceIndex = Math.floor(y4 / 3), i.face.materialIndex = g.materialIndex, e.push(i));
      }
    }
    else {
      let _ = Math.max(0, m5.start), x2 = Math.min(l.count, m5.start + m5.count);
      for (let g = _, p4 = x2; g < p4; g += 3) {
        let w3 = g, b = g + 1, y4 = g + 2;
        i = pr$1(this, a4, t, n4, c, u5, d, w3, b, y4), i && (i.faceIndex = Math.floor(g / 3), e.push(i));
      }
    }
  }
};
H$3(kc$2, "Mesh");
var ye$1 = kc$2;
function lm$2(s5, t, e, n4, i, r5, a4, o4) {
  let l;
  if (t.side === Le$2 ? l = n4.intersectTriangle(a4, r5, i, true, o4) : l = n4.intersectTriangle(i, r5, a4, t.side === Sn$2, o4), l === null) return null;
  fr$2.copy(o4), fr$2.applyMatrix4(s5.matrixWorld);
  let c = e.ray.origin.distanceTo(fr$2);
  return c < e.near || c > e.far ? null : { distance: c, point: fr$2.clone(), object: s5 };
}
H$3(lm$2, "checkIntersection$1");
function pr$1(s5, t, e, n4, i, r5, a4, o4, l, c) {
  s5.getVertexPosition(o4, cr$1), s5.getVertexPosition(l, hr$1), s5.getVertexPosition(c, ur$1);
  let u5 = lm$2(s5, t, e, n4, cr$1, hr$1, ur$1, dd$2);
  if (u5) {
    let d = new I$1();
    vn$1.getBarycoord(dd$2, cr$1, hr$1, ur$1, d), i && (u5.uv = vn$1.getInterpolatedAttribute(i, o4, l, c, d, new ot$1())), r5 && (u5.uv1 = vn$1.getInterpolatedAttribute(r5, o4, l, c, d, new ot$1())), a4 && (u5.normal = vn$1.getInterpolatedAttribute(a4, o4, l, c, d, new I$1()), u5.normal.dot(n4.direction) > 0 && u5.normal.multiplyScalar(-1));
    let f = { a: o4, b: l, c, normal: new I$1(), materialIndex: 0 };
    vn$1.getNormal(cr$1, hr$1, ur$1, f.normal), u5.face = f, u5.barycoord = d;
  }
  return u5;
}
H$3(pr$1, "checkGeometryIntersection");
var _a$2 = class _a extends pe$3 {
  constructor(t = 1, e = 1, n4 = 1, i = 1, r5 = 1, a4 = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n4, widthSegments: i, heightSegments: r5, depthSegments: a4 };
    let o4 = this;
    i = Math.floor(i), r5 = Math.floor(r5), a4 = Math.floor(a4);
    let l = [], c = [], u5 = [], d = [], f = 0, m5 = 0;
    _("z", "y", "x", -1, -1, n4, e, t, a4, r5, 0), _("z", "y", "x", 1, -1, n4, e, -t, a4, r5, 1), _("x", "z", "y", 1, 1, t, n4, e, i, a4, 2), _("x", "z", "y", 1, -1, t, n4, -e, i, a4, 3), _("x", "y", "z", 1, -1, t, e, n4, i, r5, 4), _("x", "y", "z", -1, -1, t, e, -n4, i, r5, 5), this.setIndex(l), this.setAttribute("position", new re$4(c, 3)), this.setAttribute("normal", new re$4(u5, 3)), this.setAttribute("uv", new re$4(d, 2));
    function _(x2, g, p4, w3, b, y4, D4, C3, R3, L3, E4) {
      let S4 = y4 / R3, P4 = D4 / L3, G3 = y4 / 2, B3 = D4 / 2, V3 = C3 / 2, J4 = R3 + 1, H5 = L3 + 1, it2 = 0, W4 = 0, lt2 = new I$1();
      for (let gt2 = 0; gt2 < H5; gt2++) {
        let bt2 = gt2 * P4 - B3;
        for (let Ot2 = 0; Ot2 < J4; Ot2++) {
          let Qt2 = Ot2 * S4 - G3;
          lt2[x2] = Qt2 * w3, lt2[g] = bt2 * b, lt2[p4] = V3, c.push(lt2.x, lt2.y, lt2.z), lt2[x2] = 0, lt2[g] = 0, lt2[p4] = C3 > 0 ? 1 : -1, u5.push(lt2.x, lt2.y, lt2.z), d.push(Ot2 / R3), d.push(1 - gt2 / L3), it2 += 1;
        }
      }
      for (let gt2 = 0; gt2 < L3; gt2++) for (let bt2 = 0; bt2 < R3; bt2++) {
        let Ot2 = f + bt2 + J4 * gt2, Qt2 = f + bt2 + J4 * (gt2 + 1), Z4 = f + (bt2 + 1) + J4 * (gt2 + 1), rt2 = f + (bt2 + 1) + J4 * gt2;
        l.push(Ot2, Qt2, rt2), l.push(Qt2, Z4, rt2), W4 += 6;
      }
      o4.addGroup(m5, W4, E4), m5 += W4, f += it2;
    }
    H$3(_, "buildPlane");
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new _a(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
  }
};
H$3(_a$2, "BoxGeometry");
var Xi$2 = _a$2;
function xi$1(s5) {
  let t = {};
  for (let e in s5) {
    t[e] = {};
    for (let n4 in s5[e]) {
      let i = s5[e][n4];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][n4] = null) : t[e][n4] = i.clone() : Array.isArray(i) ? t[e][n4] = i.slice() : t[e][n4] = i;
    }
  }
  return t;
}
H$3(xi$1, "cloneUniforms");
function Ce$3(s5) {
  let t = {};
  for (let e = 0; e < s5.length; e++) {
    let n4 = xi$1(s5[e]);
    for (let i in n4) t[i] = n4[i];
  }
  return t;
}
H$3(Ce$3, "mergeUniforms");
function cm$2(s5) {
  let t = [];
  for (let e = 0; e < s5.length; e++) t.push(s5[e].clone());
  return t;
}
H$3(cm$2, "cloneUniformsGroups");
function gc$2(s5) {
  let t = s5.getRenderTarget();
  return t === null ? s5.outputColorSpace : t.isXRRenderTarget === true ? t.texture.colorSpace : qt$2.workingColorSpace;
}
H$3(gc$2, "getUnlitUniformColorSpace");
var Of$1 = { clone: xi$1, merge: Ce$3 }, hm$2 = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", um$2 = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", Vc$2 = class Vc extends nn$2 {
  constructor(t) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = hm$2, this.fragmentShader = um$2, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = { clipCullDistance: false, multiDraw: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = xi$1(t.uniforms), this.uniformsGroups = cm$2(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }
  toJSON(t) {
    let e = super.toJSON(t);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (let i in this.uniforms) {
      let a4 = this.uniforms[i].value;
      a4 && a4.isTexture ? e.uniforms[i] = { type: "t", value: a4.toJSON(t).uuid } : a4 && a4.isColor ? e.uniforms[i] = { type: "c", value: a4.getHex() } : a4 && a4.isVector2 ? e.uniforms[i] = { type: "v2", value: a4.toArray() } : a4 && a4.isVector3 ? e.uniforms[i] = { type: "v3", value: a4.toArray() } : a4 && a4.isVector4 ? e.uniforms[i] = { type: "v4", value: a4.toArray() } : a4 && a4.isMatrix3 ? e.uniforms[i] = { type: "m3", value: a4.toArray() } : a4 && a4.isMatrix4 ? e.uniforms[i] = { type: "m4", value: a4.toArray() } : e.uniforms[i] = { value: a4 };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    let n4 = {};
    for (let i in this.extensions) this.extensions[i] === true && (n4[i] = true);
    return Object.keys(n4).length > 0 && (e.extensions = n4), e;
  }
};
H$3(Vc$2, "ShaderMaterial");
var sn$1 = Vc$2, Hc$2 = class Hc extends fe$2 {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Vt$2(), this.projectionMatrix = new Vt$2(), this.projectionMatrixInverse = new Vt$2(), this.coordinateSystem = an;
  }
  copy(t, e) {
    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
H$3(Hc$2, "Camera");
var Ss$1 = Hc$2, Fn$1 = new I$1(), fd$2 = new ot$1(), pd$2 = new ot$1(), Gc$2 = class Gc extends Ss$1 {
  constructor(t = 50, e = 1, n4 = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n4, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  }
  setFocalLength(t) {
    let e = 0.5 * this.getFilmHeight() / t;
    this.fov = ai$1 * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  getFocalLength() {
    let t = Math.tan(ki$2 * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  }
  getEffectiveFOV() {
    return ai$1 * 2 * Math.atan(Math.tan(ki$2 * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(t, e, n4) {
    Fn$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(Fn$1.x, Fn$1.y).multiplyScalar(-t / Fn$1.z), Fn$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n4.set(Fn$1.x, Fn$1.y).multiplyScalar(-t / Fn$1.z);
  }
  getViewSize(t, e) {
    return this.getViewBounds(t, fd$2, pd$2), e.subVectors(pd$2, fd$2);
  }
  setViewOffset(t, e, n4, i, r5, a4) {
    this.aspect = t / e, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n4, this.view.offsetY = i, this.view.width = r5, this.view.height = a4, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    let t = this.near, e = t * Math.tan(ki$2 * 0.5 * this.fov) / this.zoom, n4 = 2 * e, i = this.aspect * n4, r5 = -0.5 * i, a4 = this.view;
    if (this.view !== null && this.view.enabled) {
      let l = a4.fullWidth, c = a4.fullHeight;
      r5 += a4.offsetX * i / l, e -= a4.offsetY * n4 / c, i *= a4.width / l, n4 *= a4.height / c;
    }
    let o4 = this.filmOffset;
    o4 !== 0 && (r5 += t * o4 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r5, r5 + i, e, e - n4, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    let e = super.toJSON(t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
};
H$3(Gc$2, "PerspectiveCamera");
var Te$1 = Gc$2, Ui$1 = -90, Ni$2 = 1, Wc$2 = class Wc extends fe$2 {
  constructor(t, e, n4) {
    super(), this.type = "CubeCamera", this.renderTarget = n4, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    let i = new Te$1(Ui$1, Ni$2, t, e);
    i.layers = this.layers, this.add(i);
    let r5 = new Te$1(Ui$1, Ni$2, t, e);
    r5.layers = this.layers, this.add(r5);
    let a4 = new Te$1(Ui$1, Ni$2, t, e);
    a4.layers = this.layers, this.add(a4);
    let o4 = new Te$1(Ui$1, Ni$2, t, e);
    o4.layers = this.layers, this.add(o4);
    let l = new Te$1(Ui$1, Ni$2, t, e);
    l.layers = this.layers, this.add(l);
    let c = new Te$1(Ui$1, Ni$2, t, e);
    c.layers = this.layers, this.add(c);
  }
  updateCoordinateSystem() {
    let t = this.coordinateSystem, e = this.children.concat(), [n4, i, r5, a4, o4, l] = e;
    for (let c of e) this.remove(c);
    if (t === an) n4.up.set(0, 1, 0), n4.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r5.up.set(0, 0, -1), r5.lookAt(0, 1, 0), a4.up.set(0, 0, 1), a4.lookAt(0, -1, 0), o4.up.set(0, 1, 0), o4.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (t === gs$1) n4.up.set(0, -1, 0), n4.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r5.up.set(0, 0, 1), r5.lookAt(0, 1, 0), a4.up.set(0, 0, -1), a4.lookAt(0, -1, 0), o4.up.set(0, -1, 0), o4.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
    for (let c of e) this.add(c), c.updateMatrixWorld();
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    let { renderTarget: n4, activeMipmapLevel: i } = this;
    this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
    let [r5, a4, o4, l, c, u5] = this.children, d = t.getRenderTarget(), f = t.getActiveCubeFace(), m5 = t.getActiveMipmapLevel(), _ = t.xr.enabled;
    t.xr.enabled = false;
    let x2 = n4.texture.generateMipmaps;
    n4.texture.generateMipmaps = false, t.setRenderTarget(n4, 0, i), t.render(e, r5), t.setRenderTarget(n4, 1, i), t.render(e, a4), t.setRenderTarget(n4, 2, i), t.render(e, o4), t.setRenderTarget(n4, 3, i), t.render(e, l), t.setRenderTarget(n4, 4, i), t.render(e, c), n4.texture.generateMipmaps = x2, t.setRenderTarget(n4, 5, i), t.render(e, u5), t.setRenderTarget(d, f, m5), t.xr.enabled = _, n4.texture.needsPMREMUpdate = true;
  }
};
H$3(Wc$2, "CubeCamera");
var Vr$2 = Wc$2, Xc$2 = class Xc extends we$2 {
  constructor(t, e, n4, i, r5, a4, o4, l, c, u5) {
    t = t !== void 0 ? t : [], e = e !== void 0 ? e : pi$2, super(t, e, n4, i, r5, a4, o4, l, c, u5), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
};
H$3(Xc$2, "CubeTexture");
var bs$1 = Xc$2, qc$2 = class qc extends on$3 {
  constructor(t = 1, e = {}) {
    super(t, t, e), this.isWebGLCubeRenderTarget = true;
    let n4 = { width: t, height: t, depth: 1 }, i = [n4, n4, n4, n4, n4, n4];
    this.texture = new bs$1(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : false, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : en$1;
  }
  fromEquirectangularTexture(t, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    let n4 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, i = new Xi$2(5, 5, 5), r5 = new sn$1({ name: "CubemapFromEquirect", uniforms: xi$1(n4.uniforms), vertexShader: n4.vertexShader, fragmentShader: n4.fragmentShader, side: Le$2, blending: wn$3 });
    r5.uniforms.tEquirect.value = e;
    let a4 = new ye$1(i, r5), o4 = e.minFilter;
    return e.minFilter === Wn$1 && (e.minFilter = en$1), new Vr$2(1, 10, this).update(t, a4), e.minFilter = o4, a4.geometry.dispose(), a4.material.dispose(), this;
  }
  clear(t, e, n4, i) {
    let r5 = t.getRenderTarget();
    for (let a4 = 0; a4 < 6; a4++) t.setRenderTarget(this, a4), t.clear(e, n4, i);
    t.setRenderTarget(r5);
  }
};
H$3(qc$2, "WebGLCubeRenderTarget");
var Hr$2 = qc$2, Yc$2 = class Yc extends fe$2 {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
};
H$3(Yc$2, "Group");
var ti$2 = Yc$2, dm$2 = { type: "move" }, Zc$1 = class Zc {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new ti$2(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new ti$2(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new I$1(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new I$1()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new ti$2(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new I$1(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new I$1()), this._grip;
  }
  dispatchEvent(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  }
  connect(t) {
    if (t && t.hand) {
      let e = this._hand;
      if (e) for (let n4 of t.hand.values()) this._getHandJoint(e, n4);
    }
    return this.dispatchEvent({ type: "connected", data: t }), this;
  }
  disconnect(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
  }
  update(t, e, n4) {
    let i = null, r5 = null, a4 = null, o4 = this._targetRay, l = this._grip, c = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred") {
      if (c && t.hand) {
        a4 = true;
        for (let x2 of t.hand.values()) {
          let g = e.getJointPose(x2, n4), p4 = this._getHandJoint(c, x2);
          g !== null && (p4.matrix.fromArray(g.transform.matrix), p4.matrix.decompose(p4.position, p4.rotation, p4.scale), p4.matrixWorldNeedsUpdate = true, p4.jointRadius = g.radius), p4.visible = g !== null;
        }
        let u5 = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], f = u5.position.distanceTo(d.position), m5 = 0.02, _ = 5e-3;
        c.inputState.pinching && f > m5 + _ ? (c.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && f <= m5 - _ && (c.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }));
      } else l !== null && t.gripSpace && (r5 = e.getPose(t.gripSpace, n4), r5 !== null && (l.matrix.fromArray(r5.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, r5.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(r5.linearVelocity)) : l.hasLinearVelocity = false, r5.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(r5.angularVelocity)) : l.hasAngularVelocity = false));
      o4 !== null && (i = e.getPose(t.targetRaySpace, n4), i === null && r5 !== null && (i = r5), i !== null && (o4.matrix.fromArray(i.transform.matrix), o4.matrix.decompose(o4.position, o4.rotation, o4.scale), o4.matrixWorldNeedsUpdate = true, i.linearVelocity ? (o4.hasLinearVelocity = true, o4.linearVelocity.copy(i.linearVelocity)) : o4.hasLinearVelocity = false, i.angularVelocity ? (o4.hasAngularVelocity = true, o4.angularVelocity.copy(i.angularVelocity)) : o4.hasAngularVelocity = false, this.dispatchEvent(dm$2)));
    }
    return o4 !== null && (o4.visible = i !== null), l !== null && (l.visible = r5 !== null), c !== null && (c.visible = a4 !== null), this;
  }
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      let n4 = new ti$2();
      n4.matrixAutoUpdate = false, n4.visible = false, t.joints[e.jointName] = n4, t.add(n4);
    }
    return t.joints[e.jointName];
  }
};
H$3(Zc$1, "WebXRController");
var qi$2 = Zc$1;
var Jc$2 = class Jc extends fe$2 {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Ze$1(), this.environmentIntensity = 1, this.environmentRotation = new Ze$1(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t, e) {
    return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  }
  toJSON(t) {
    let e = super.toJSON(t);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
};
H$3(Jc$2, "Scene");
var hl$2 = Jc$2, $c$2 = class $c {
  constructor(t, e) {
    this.isInterleavedBuffer = true, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = Or$3, this.updateRanges = [], this.version = 0, this.uuid = Ye();
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === true && this.version++;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
  }
  copyAt(t, e, n4) {
    t *= this.stride, n4 *= e.stride;
    for (let i = 0, r5 = this.stride; i < r5; i++) this.array[t + i] = e.array[n4 + i];
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  clone(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ye()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    let e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n4 = new this.constructor(e, this.stride);
    return n4.setUsage(this.usage), n4;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  toJSON(t) {
    return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ye()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
};
H$3($c$2, "InterleavedBuffer");
var ul$1 = $c$2, Ie$2 = new I$1(), xa$2 = class xa {
  constructor(t, e, n4, i = false) {
    this.isInterleavedBufferAttribute = true, this.name = "", this.data = t, this.itemSize = e, this.offset = n4, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t;
  }
  applyMatrix4(t) {
    for (let e = 0, n4 = this.data.count; e < n4; e++) Ie$2.fromBufferAttribute(this, e), Ie$2.applyMatrix4(t), this.setXYZ(e, Ie$2.x, Ie$2.y, Ie$2.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n4 = this.count; e < n4; e++) Ie$2.fromBufferAttribute(this, e), Ie$2.applyNormalMatrix(t), this.setXYZ(e, Ie$2.x, Ie$2.y, Ie$2.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n4 = this.count; e < n4; e++) Ie$2.fromBufferAttribute(this, e), Ie$2.transformDirection(t), this.setXYZ(e, Ie$2.x, Ie$2.y, Ie$2.z);
    return this;
  }
  getComponent(t, e) {
    let n4 = this.array[t * this.data.stride + this.offset + e];
    return this.normalized && (n4 = tn$2(n4, this.array)), n4;
  }
  setComponent(t, e, n4) {
    return this.normalized && (n4 = ne$1(n4, this.array)), this.data.array[t * this.data.stride + this.offset + e] = n4, this;
  }
  setX(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this;
  }
  setY(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this;
  }
  setZ(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this;
  }
  setW(t, e) {
    return this.normalized && (e = ne$1(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this;
  }
  getX(t) {
    let e = this.data.array[t * this.data.stride + this.offset];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  getY(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 1];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  getZ(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 2];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  getW(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 3];
    return this.normalized && (e = tn$2(e, this.array)), e;
  }
  setXY(t, e, n4) {
    return t = t * this.data.stride + this.offset, this.normalized && (e = ne$1(e, this.array), n4 = ne$1(n4, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n4, this;
  }
  setXYZ(t, e, n4, i) {
    return t = t * this.data.stride + this.offset, this.normalized && (e = ne$1(e, this.array), n4 = ne$1(n4, this.array), i = ne$1(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n4, this.data.array[t + 2] = i, this;
  }
  setXYZW(t, e, n4, i, r5) {
    return t = t * this.data.stride + this.offset, this.normalized && (e = ne$1(e, this.array), n4 = ne$1(n4, this.array), i = ne$1(i, this.array), r5 = ne$1(r5, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n4, this.data.array[t + 2] = i, this.data.array[t + 3] = r5, this;
  }
  clone(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      let e = [];
      for (let n4 = 0; n4 < this.count; n4++) {
        let i = n4 * this.data.stride + this.offset;
        for (let r5 = 0; r5 < this.itemSize; r5++) e.push(this.data.array[i + r5]);
      }
      return new ve$3(new this.array.constructor(e), this.itemSize, this.normalized);
    } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new xa(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(t) {
    if (t === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      let e = [];
      for (let n4 = 0; n4 < this.count; n4++) {
        let i = n4 * this.data.stride + this.offset;
        for (let r5 = 0; r5 < this.itemSize; r5++) e.push(this.data.array[i + r5]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized };
    } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
};
H$3(xa$2, "InterleavedBufferAttribute");
var dl$2 = xa$2;
var md$2 = new I$1(), gd$1 = new $t$3(), _d$2 = new $t$3(), fm$2 = new I$1(), xd$2 = new Vt$2(), mr = new I$1(), qo$1 = new Ae$3(), vd$2 = new Vt$2(), Yo$2 = new Hn$1(), Kc$2 = class Kc extends ye$1 {
  constructor(t, e) {
    super(t, e), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = rl$2, this.bindMatrix = new Vt$2(), this.bindMatrixInverse = new Vt$2(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    let t = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Pe$3()), this.boundingBox.makeEmpty();
    let e = t.getAttribute("position");
    for (let n4 = 0; n4 < e.count; n4++) this.getVertexPosition(n4, mr), this.boundingBox.expandByPoint(mr);
  }
  computeBoundingSphere() {
    let t = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Ae$3()), this.boundingSphere.makeEmpty();
    let e = t.getAttribute("position");
    for (let n4 = 0; n4 < e.count; n4++) this.getVertexPosition(n4, mr), this.boundingSphere.expandByPoint(mr);
  }
  copy(t, e) {
    return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
  }
  raycast(t, e) {
    let n4 = this.material, i = this.matrixWorld;
    n4 !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), qo$1.copy(this.boundingSphere), qo$1.applyMatrix4(i), t.ray.intersectsSphere(qo$1) !== false && (vd$2.copy(i).invert(), Yo$2.copy(t.ray).applyMatrix4(vd$2), !(this.boundingBox !== null && Yo$2.intersectsBox(this.boundingBox) === false) && this._computeIntersections(t, e, Yo$2)));
  }
  getVertexPosition(t, e) {
    return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e;
  }
  bind(t, e) {
    this.skeleton = t, e === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    let t = new $t$3(), e = this.geometry.attributes.skinWeight;
    for (let n4 = 0, i = e.count; n4 < i; n4++) {
      t.fromBufferAttribute(e, n4);
      let r5 = 1 / t.manhattanLength();
      r5 !== 1 / 0 ? t.multiplyScalar(r5) : t.set(1, 0, 0, 0), e.setXYZW(n4, t.x, t.y, t.z, t.w);
    }
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.bindMode === rl$2 ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === vf$2 ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(t, e) {
    let n4 = this.skeleton, i = this.geometry;
    gd$1.fromBufferAttribute(i.attributes.skinIndex, t), _d$2.fromBufferAttribute(i.attributes.skinWeight, t), md$2.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
    for (let r5 = 0; r5 < 4; r5++) {
      let a4 = _d$2.getComponent(r5);
      if (a4 !== 0) {
        let o4 = gd$1.getComponent(r5);
        xd$2.multiplyMatrices(n4.bones[o4].matrixWorld, n4.boneInverses[o4]), e.addScaledVector(fm$2.copy(md$2).applyMatrix4(xd$2), a4);
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse);
  }
};
H$3(Kc$2, "SkinnedMesh");
var fl$2 = Kc$2, Qc$2 = class Qc extends fe$2 {
  constructor() {
    super(), this.isBone = true, this.type = "Bone";
  }
};
H$3(Qc$2, "Bone");
var Gr$1 = Qc$2, jc$2 = class jc extends we$2 {
  constructor(t = null, e = 1, n4 = 1, i, r5, a4, o4, l, c = Fe$2, u5 = Fe$2, d, f) {
    super(null, a4, o4, l, c, u5, i, r5, d, f), this.isDataTexture = true, this.image = { data: t, width: e, height: n4 }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
H$3(jc$2, "DataTexture");
var kn$1 = jc$2, yd$2 = new Vt$2(), pm$2 = new Vt$2(), va$2 = class va {
  constructor(t = [], e = []) {
    this.uuid = Ye(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    let t = this.bones, e = this.boneInverses;
    if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0) this.calculateInverses();
    else if (t.length !== e.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n4 = 0, i = this.bones.length; n4 < i; n4++) this.boneInverses.push(new Vt$2());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let t = 0, e = this.bones.length; t < e; t++) {
      let n4 = new Vt$2();
      this.bones[t] && n4.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n4);
    }
  }
  pose() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      let n4 = this.bones[t];
      n4 && n4.matrixWorld.copy(this.boneInverses[t]).invert();
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      let n4 = this.bones[t];
      n4 && (n4.parent && n4.parent.isBone ? (n4.matrix.copy(n4.parent.matrixWorld).invert(), n4.matrix.multiply(n4.matrixWorld)) : n4.matrix.copy(n4.matrixWorld), n4.matrix.decompose(n4.position, n4.quaternion, n4.scale));
    }
  }
  update() {
    let t = this.bones, e = this.boneInverses, n4 = this.boneMatrices, i = this.boneTexture;
    for (let r5 = 0, a4 = t.length; r5 < a4; r5++) {
      let o4 = t[r5] ? t[r5].matrixWorld : pm$2;
      yd$2.multiplyMatrices(o4, e[r5]), yd$2.toArray(n4, r5 * 16);
    }
    i !== null && (i.needsUpdate = true);
  }
  clone() {
    return new va(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let t = Math.sqrt(this.bones.length * 4);
    t = Math.ceil(t / 4) * 4, t = Math.max(t, 4);
    let e = new Float32Array(t * t * 4);
    e.set(this.boneMatrices);
    let n4 = new kn$1(e, t, t, De$3, Oe$1);
    return n4.needsUpdate = true, this.boneMatrices = e, this.boneTexture = n4, this;
  }
  getBoneByName(t) {
    for (let e = 0, n4 = this.bones.length; e < n4; e++) {
      let i = this.bones[e];
      if (i.name === t) return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(t, e) {
    this.uuid = t.uuid;
    for (let n4 = 0, i = t.bones.length; n4 < i; n4++) {
      let r5 = t.bones[n4], a4 = e[r5];
      a4 === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r5), a4 = new Gr$1()), this.bones.push(a4), this.boneInverses.push(new Vt$2().fromArray(t.boneInverses[n4]));
    }
    return this.init(), this;
  }
  toJSON() {
    let t = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    t.uuid = this.uuid;
    let e = this.bones, n4 = this.boneInverses;
    for (let i = 0, r5 = e.length; i < r5; i++) {
      let a4 = e[i];
      t.bones.push(a4.uuid);
      let o4 = n4[i];
      t.boneInverses.push(o4.toArray());
    }
    return t;
  }
};
H$3(va$2, "Skeleton");
var pl$2 = va$2, th$2 = class th extends ve$3 {
  constructor(t, e, n4, i = 1) {
    super(t, e, n4), this.isInstancedBufferAttribute = true, this.meshPerAttribute = i;
  }
  copy(t) {
    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = true, t;
  }
};
H$3(th$2, "InstancedBufferAttribute");
var Es$2 = th$2, Fi$1 = new Vt$2(), Md$2 = new Vt$2(), gr$2 = [], Sd$2 = new Pe$3(), mm$2 = new Vt$2(), rs$1 = new ye$1(), as$2 = new Ae$3(), eh$2 = class eh extends ye$1 {
  constructor(t, e, n4) {
    super(t, e), this.isInstancedMesh = true, this.instanceMatrix = new Es$2(new Float32Array(n4 * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n4, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n4; i++) this.setMatrixAt(i, mm$2);
  }
  computeBoundingBox() {
    let t = this.geometry, e = this.count;
    this.boundingBox === null && (this.boundingBox = new Pe$3()), t.boundingBox === null && t.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n4 = 0; n4 < e; n4++) this.getMatrixAt(n4, Fi$1), Sd$2.copy(t.boundingBox).applyMatrix4(Fi$1), this.boundingBox.union(Sd$2);
  }
  computeBoundingSphere() {
    let t = this.geometry, e = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Ae$3()), t.boundingSphere === null && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n4 = 0; n4 < e; n4++) this.getMatrixAt(n4, Fi$1), as$2.copy(t.boundingSphere).applyMatrix4(Fi$1), this.boundingSphere.union(as$2);
  }
  copy(t, e) {
    return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, t * 3);
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  }
  getMorphAt(t, e) {
    let n4 = e.morphTargetInfluences, i = this.morphTexture.source.data.data, r5 = n4.length + 1, a4 = t * r5 + 1;
    for (let o4 = 0; o4 < n4.length; o4++) n4[o4] = i[a4 + o4];
  }
  raycast(t, e) {
    let n4 = this.matrixWorld, i = this.count;
    if (rs$1.geometry = this.geometry, rs$1.material = this.material, rs$1.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), as$2.copy(this.boundingSphere), as$2.applyMatrix4(n4), t.ray.intersectsSphere(as$2) !== false)) for (let r5 = 0; r5 < i; r5++) {
      this.getMatrixAt(r5, Fi$1), Md$2.multiplyMatrices(n4, Fi$1), rs$1.matrixWorld = Md$2, rs$1.raycast(t, gr$2);
      for (let a4 = 0, o4 = gr$2.length; a4 < o4; a4++) {
        let l = gr$2[a4];
        l.instanceId = r5, l.object = this, e.push(l);
      }
      gr$2.length = 0;
    }
  }
  setColorAt(t, e) {
    this.instanceColor === null && (this.instanceColor = new Es$2(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), e.toArray(this.instanceColor.array, t * 3);
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  }
  setMorphAt(t, e) {
    let n4 = e.morphTargetInfluences, i = n4.length + 1;
    this.morphTexture === null && (this.morphTexture = new kn$1(new Float32Array(i * this.count), i, this.count, Va$1, Oe$1));
    let r5 = this.morphTexture.source.data.data, a4 = 0;
    for (let c = 0; c < n4.length; c++) a4 += n4[c];
    let o4 = this.geometry.morphTargetsRelative ? 1 : 1 - a4, l = i * t;
    r5[l] = o4, r5.set(n4, l + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
};
H$3(eh$2, "InstancedMesh");
var ml$2 = eh$2, Zo$1 = new I$1(), gm$2 = new I$1(), _m$2 = new Bt$2(), nh$2 = class nh {
  constructor(t = new I$1(1, 0, 0), e = 0) {
    this.isPlane = true, this.normal = t, this.constant = e;
  }
  set(t, e) {
    return this.normal.copy(t), this.constant = e, this;
  }
  setComponents(t, e, n4, i) {
    return this.normal.set(t, e, n4), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(t, e, n4) {
    let i = Zo$1.subVectors(n4, e).cross(gm$2.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  }
  normalize() {
    let t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
  }
  intersectLine(t, e) {
    let n4 = t.delta(Zo$1), i = this.normal.dot(n4);
    if (i === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    let r5 = -(t.start.dot(this.normal) + this.constant) / i;
    return r5 < 0 || r5 > 1 ? null : e.copy(t.start).addScaledVector(n4, r5);
  }
  intersectsLine(t) {
    let e = this.distanceToPoint(t.start), n4 = this.distanceToPoint(t.end);
    return e < 0 && n4 > 0 || n4 < 0 && e > 0;
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    let n4 = e || _m$2.getNormalMatrix(t), i = this.coplanarPoint(Zo$1).applyMatrix4(t), r5 = this.normal.applyMatrix3(n4).normalize();
    return this.constant = -i.dot(r5), this;
  }
  translate(t) {
    return this.constant -= t.dot(this.normal), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
H$3(nh$2, "Plane");
var rn$1 = nh$2, $n$1 = new Ae$3(), _r$2 = new I$1(), ih$2 = class ih {
  constructor(t = new rn$1(), e = new rn$1(), n4 = new rn$1(), i = new rn$1(), r5 = new rn$1(), a4 = new rn$1()) {
    this.planes = [t, e, n4, i, r5, a4];
  }
  set(t, e, n4, i, r5, a4) {
    let o4 = this.planes;
    return o4[0].copy(t), o4[1].copy(e), o4[2].copy(n4), o4[3].copy(i), o4[4].copy(r5), o4[5].copy(a4), this;
  }
  copy(t) {
    let e = this.planes;
    for (let n4 = 0; n4 < 6; n4++) e[n4].copy(t.planes[n4]);
    return this;
  }
  setFromProjectionMatrix(t, e = an) {
    let n4 = this.planes, i = t.elements, r5 = i[0], a4 = i[1], o4 = i[2], l = i[3], c = i[4], u5 = i[5], d = i[6], f = i[7], m5 = i[8], _ = i[9], x2 = i[10], g = i[11], p4 = i[12], w3 = i[13], b = i[14], y4 = i[15];
    if (n4[0].setComponents(l - r5, f - c, g - m5, y4 - p4).normalize(), n4[1].setComponents(l + r5, f + c, g + m5, y4 + p4).normalize(), n4[2].setComponents(l + a4, f + u5, g + _, y4 + w3).normalize(), n4[3].setComponents(l - a4, f - u5, g - _, y4 - w3).normalize(), n4[4].setComponents(l - o4, f - d, g - x2, y4 - b).normalize(), e === an) n4[5].setComponents(l + o4, f + d, g + x2, y4 + b).normalize();
    else if (e === gs$1) n4[5].setComponents(o4, d, x2, b).normalize();
    else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), $n$1.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
    else {
      let e = t.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), $n$1.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
    }
    return this.intersectsSphere($n$1);
  }
  intersectsSprite(t) {
    return $n$1.center.set(0, 0, 0), $n$1.radius = 0.7071067811865476, $n$1.applyMatrix4(t.matrixWorld), this.intersectsSphere($n$1);
  }
  intersectsSphere(t) {
    let e = this.planes, n4 = t.center, i = -t.radius;
    for (let r5 = 0; r5 < 6; r5++) if (e[r5].distanceToPoint(n4) < i) return false;
    return true;
  }
  intersectsBox(t) {
    let e = this.planes;
    for (let n4 = 0; n4 < 6; n4++) {
      let i = e[n4];
      if (_r$2.x = i.normal.x > 0 ? t.max.x : t.min.x, _r$2.y = i.normal.y > 0 ? t.max.y : t.min.y, _r$2.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(_r$2) < 0) return false;
    }
    return true;
  }
  containsPoint(t) {
    let e = this.planes;
    for (let n4 = 0; n4 < 6; n4++) if (e[n4].distanceToPoint(t) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
H$3(ih$2, "Frustum");
var oi$1 = ih$2;
function Jo$2(s5, t) {
  return s5 - t;
}
H$3(Jo$2, "ascIdSort");
function xm$2(s5, t) {
  return s5.z - t.z;
}
H$3(xm$2, "sortOpaque");
function vm$2(s5, t) {
  return t.z - s5.z;
}
H$3(vm$2, "sortTransparent");
var sh$2 = class sh {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(t, e, n4, i) {
    let r5 = this.pool, a4 = this.list;
    this.index >= r5.length && r5.push({ start: -1, count: -1, z: -1, index: -1 });
    let o4 = r5[this.index];
    a4.push(o4), this.index++, o4.start = t, o4.count = e, o4.z = n4, o4.index = i;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
};
H$3(sh$2, "MultiDrawRenderList");
var gl$2 = sh$2, Ne$2 = new Vt$2(), ym$2 = new Ft$3(1, 1, 1), $o$1 = new oi$1(), xr$1 = new Pe$3(), Kn$1 = new Ae$3(), os$2 = new I$1(), bd$2 = new I$1(), Mm$1 = new I$1(), Ko$1 = new gl$2(), Ee$2 = new ye$1(), vr$1 = [];
function Sm$2(s5, t, e = 0) {
  let n4 = t.itemSize;
  if (s5.isInterleavedBufferAttribute || s5.array.constructor !== t.array.constructor) {
    let i = s5.count;
    for (let r5 = 0; r5 < i; r5++) for (let a4 = 0; a4 < n4; a4++) t.setComponent(r5 + e, a4, s5.getComponent(r5, a4));
  } else t.array.set(s5.array, e * n4);
  t.needsUpdate = true;
}
H$3(Sm$2, "copyAttributeData");
function Qn$2(s5, t) {
  if (s5.constructor !== t.constructor) {
    let e = Math.min(s5.length, t.length);
    for (let n4 = 0; n4 < e; n4++) t[n4] = s5[n4];
  } else {
    let e = Math.min(s5.length, t.length);
    t.set(new s5.constructor(s5.buffer, 0, e));
  }
}
H$3(Qn$2, "copyArrayContents");
var rh$2 = class rh extends ye$1 {
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  constructor(t, e, n4 = e * 2, i) {
    super(new pe$3(), i), this.isBatchedMesh = true, this.perObjectFrustumCulled = true, this.sortObjects = true, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = true, this._geometryInitialized = false, this._maxInstanceCount = t, this._maxVertexCount = e, this._maxIndexCount = n4, this._multiDrawCounts = new Int32Array(t), this._multiDrawStarts = new Int32Array(t), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
  }
  _initMatricesTexture() {
    let t = Math.sqrt(this._maxInstanceCount * 4);
    t = Math.ceil(t / 4) * 4, t = Math.max(t, 4);
    let e = new Float32Array(t * t * 4), n4 = new kn$1(e, t, t, De$3, Oe$1);
    this._matricesTexture = n4;
  }
  _initIndirectTexture() {
    let t = Math.sqrt(this._maxInstanceCount);
    t = Math.ceil(t);
    let e = new Uint32Array(t * t), n4 = new kn$1(e, t, t, Gs$2, Rn$1);
    this._indirectTexture = n4;
  }
  _initColorsTexture() {
    let t = Math.sqrt(this._maxInstanceCount);
    t = Math.ceil(t);
    let e = new Float32Array(t * t * 4).fill(1), n4 = new kn$1(e, t, t, De$3, Oe$1);
    n4.colorSpace = qt$2.workingColorSpace, this._colorsTexture = n4;
  }
  _initializeGeometry(t) {
    let e = this.geometry, n4 = this._maxVertexCount, i = this._maxIndexCount;
    if (this._geometryInitialized === false) {
      for (let r5 in t.attributes) {
        let a4 = t.getAttribute(r5), { array: o4, itemSize: l, normalized: c } = a4, u5 = new o4.constructor(n4 * l), d = new ve$3(u5, l, c);
        e.setAttribute(r5, d);
      }
      if (t.getIndex() !== null) {
        let r5 = n4 > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        e.setIndex(new ve$3(r5, 1));
      }
      this._geometryInitialized = true;
    }
  }
  _validateGeometry(t) {
    let e = this.geometry;
    if (!!t.getIndex() != !!e.getIndex()) throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
    for (let n4 in e.attributes) {
      if (!t.hasAttribute(n4)) throw new Error('THREE.BatchedMesh: Added geometry missing "'.concat(n4, '". All geometries must have consistent attributes.'));
      let i = t.getAttribute(n4), r5 = e.getAttribute(n4);
      if (i.itemSize !== r5.itemSize || i.normalized !== r5.normalized) throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  validateInstanceId(t) {
    let e = this._instanceInfo;
    if (t < 0 || t >= e.length || e[t].active === false) throw new Error("THREE.BatchedMesh: Invalid instanceId ".concat(t, ". Instance is either out of range or has been deleted."));
  }
  validateGeometryId(t) {
    let e = this._geometryInfo;
    if (t < 0 || t >= e.length || e[t].active === false) throw new Error("THREE.BatchedMesh: Invalid geometryId ".concat(t, ". Geometry is either out of range or has been deleted."));
  }
  setCustomSort(t) {
    return this.customSort = t, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Pe$3());
    let t = this.boundingBox, e = this._instanceInfo;
    t.makeEmpty();
    for (let n4 = 0, i = e.length; n4 < i; n4++) {
      if (e[n4].active === false) continue;
      let r5 = e[n4].geometryIndex;
      this.getMatrixAt(n4, Ne$2), this.getBoundingBoxAt(r5, xr$1).applyMatrix4(Ne$2), t.union(xr$1);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ae$3());
    let t = this.boundingSphere, e = this._instanceInfo;
    t.makeEmpty();
    for (let n4 = 0, i = e.length; n4 < i; n4++) {
      if (e[n4].active === false) continue;
      let r5 = e[n4].geometryIndex;
      this.getMatrixAt(n4, Ne$2), this.getBoundingSphereAt(r5, Kn$1).applyMatrix4(Ne$2), t.union(Kn$1);
    }
  }
  addInstance(t) {
    if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    let n4 = { visible: true, active: true, geometryIndex: t }, i = null;
    this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(Jo$2), i = this._availableInstanceIds.shift(), this._instanceInfo[i] = n4) : (i = this._instanceInfo.length, this._instanceInfo.push(n4));
    let r5 = this._matricesTexture;
    Ne$2.identity().toArray(r5.image.data, i * 16), r5.needsUpdate = true;
    let a4 = this._colorsTexture;
    return a4 && (ym$2.toArray(a4.image.data, i * 4), a4.needsUpdate = true), this._visibilityChanged = true, i;
  }
  addGeometry(t, e = -1, n4 = -1) {
    this._initializeGeometry(t), this._validateGeometry(t);
    let i = { vertexStart: -1, vertexCount: -1, reservedVertexCount: -1, indexStart: -1, indexCount: -1, reservedIndexCount: -1, start: -1, count: -1, boundingBox: null, boundingSphere: null, active: true }, r5 = this._geometryInfo;
    i.vertexStart = this._nextVertexStart, i.reservedVertexCount = e === -1 ? t.getAttribute("position").count : e;
    let a4 = t.getIndex();
    if (a4 !== null && (i.indexStart = this._nextIndexStart, i.reservedIndexCount = n4 === -1 ? a4.count : n4), i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount) throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    let l;
    return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(Jo$2), l = this._availableGeometryIds.shift(), r5[l] = i) : (l = this._geometryCount, this._geometryCount++, r5.push(i)), this.setGeometryAt(l, t), this._nextIndexStart = i.indexStart + i.reservedIndexCount, this._nextVertexStart = i.vertexStart + i.reservedVertexCount, l;
  }
  setGeometryAt(t, e) {
    if (t >= this._geometryCount) throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(e);
    let n4 = this.geometry, i = n4.getIndex() !== null, r5 = n4.getIndex(), a4 = e.getIndex(), o4 = this._geometryInfo[t];
    if (i && a4.count > o4.reservedIndexCount || e.attributes.position.count > o4.reservedVertexCount) throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
    let l = o4.vertexStart, c = o4.reservedVertexCount;
    o4.vertexCount = e.getAttribute("position").count;
    for (let u5 in n4.attributes) {
      let d = e.getAttribute(u5), f = n4.getAttribute(u5);
      Sm$2(d, f, l);
      let m5 = d.itemSize;
      for (let _ = d.count, x2 = c; _ < x2; _++) {
        let g = l + _;
        for (let p4 = 0; p4 < m5; p4++) f.setComponent(g, p4, 0);
      }
      f.needsUpdate = true, f.addUpdateRange(l * m5, c * m5);
    }
    if (i) {
      let u5 = o4.indexStart, d = o4.reservedIndexCount;
      o4.indexCount = e.getIndex().count;
      for (let f = 0; f < a4.count; f++) r5.setX(u5 + f, l + a4.getX(f));
      for (let f = a4.count, m5 = d; f < m5; f++) r5.setX(u5 + f, l);
      r5.needsUpdate = true, r5.addUpdateRange(u5, o4.reservedIndexCount);
    }
    return o4.start = i ? o4.indexStart : o4.vertexStart, o4.count = i ? o4.indexCount : o4.vertexCount, o4.boundingBox = null, e.boundingBox !== null && (o4.boundingBox = e.boundingBox.clone()), o4.boundingSphere = null, e.boundingSphere !== null && (o4.boundingSphere = e.boundingSphere.clone()), this._visibilityChanged = true, t;
  }
  deleteGeometry(t) {
    let e = this._geometryInfo;
    if (t >= e.length || e[t].active === false) return this;
    let n4 = this._instanceInfo;
    for (let i = 0, r5 = n4.length; i < r5; i++) n4[i].active && n4[i].geometryIndex === t && this.deleteInstance(i);
    return e[t].active = false, this._availableGeometryIds.push(t), this._visibilityChanged = true, this;
  }
  deleteInstance(t) {
    return this.validateInstanceId(t), this._instanceInfo[t].active = false, this._availableInstanceIds.push(t), this._visibilityChanged = true, this;
  }
  optimize() {
    let t = 0, e = 0, n4 = this._geometryInfo, i = n4.map((a4, o4) => o4).sort((a4, o4) => n4[a4].vertexStart - n4[o4].vertexStart), r5 = this.geometry;
    for (let a4 = 0, o4 = n4.length; a4 < o4; a4++) {
      let l = i[a4], c = n4[l];
      if (c.active !== false) {
        if (r5.index !== null) {
          if (c.indexStart !== e) {
            let { indexStart: u5, vertexStart: d, reservedIndexCount: f } = c, m5 = r5.index, _ = m5.array, x2 = t - d;
            for (let g = u5; g < u5 + f; g++) _[g] = _[g] + x2;
            m5.array.copyWithin(e, u5, u5 + f), m5.addUpdateRange(e, f), c.indexStart = e;
          }
          e += c.reservedIndexCount;
        }
        if (c.vertexStart !== t) {
          let { vertexStart: u5, reservedVertexCount: d } = c, f = r5.attributes;
          for (let m5 in f) {
            let _ = f[m5], { array: x2, itemSize: g } = _;
            x2.copyWithin(t * g, u5 * g, (u5 + d) * g), _.addUpdateRange(t * g, d * g);
          }
          c.vertexStart = t;
        }
        t += c.reservedVertexCount, c.start = r5.index ? c.indexStart : c.vertexStart, this._nextIndexStart = r5.index ? c.indexStart + c.reservedIndexCount : 0, this._nextVertexStart = c.vertexStart + c.reservedVertexCount;
      }
    }
    return this;
  }
  getBoundingBoxAt(t, e) {
    if (t >= this._geometryCount) return null;
    let n4 = this.geometry, i = this._geometryInfo[t];
    if (i.boundingBox === null) {
      let r5 = new Pe$3(), a4 = n4.index, o4 = n4.attributes.position;
      for (let l = i.start, c = i.start + i.count; l < c; l++) {
        let u5 = l;
        a4 && (u5 = a4.getX(u5)), r5.expandByPoint(os$2.fromBufferAttribute(o4, u5));
      }
      i.boundingBox = r5;
    }
    return e.copy(i.boundingBox), e;
  }
  getBoundingSphereAt(t, e) {
    if (t >= this._geometryCount) return null;
    let n4 = this.geometry, i = this._geometryInfo[t];
    if (i.boundingSphere === null) {
      let r5 = new Ae$3();
      this.getBoundingBoxAt(t, xr$1), xr$1.getCenter(r5.center);
      let a4 = n4.index, o4 = n4.attributes.position, l = 0;
      for (let c = i.start, u5 = i.start + i.count; c < u5; c++) {
        let d = c;
        a4 && (d = a4.getX(d)), os$2.fromBufferAttribute(o4, d), l = Math.max(l, r5.center.distanceToSquared(os$2));
      }
      r5.radius = Math.sqrt(l), i.boundingSphere = r5;
    }
    return e.copy(i.boundingSphere), e;
  }
  setMatrixAt(t, e) {
    this.validateInstanceId(t);
    let n4 = this._matricesTexture, i = this._matricesTexture.image.data;
    return e.toArray(i, t * 16), n4.needsUpdate = true, this;
  }
  getMatrixAt(t, e) {
    return this.validateInstanceId(t), e.fromArray(this._matricesTexture.image.data, t * 16);
  }
  setColorAt(t, e) {
    return this.validateInstanceId(t), this._colorsTexture === null && this._initColorsTexture(), e.toArray(this._colorsTexture.image.data, t * 4), this._colorsTexture.needsUpdate = true, this;
  }
  getColorAt(t, e) {
    return this.validateInstanceId(t), e.fromArray(this._colorsTexture.image.data, t * 4);
  }
  setVisibleAt(t, e) {
    return this.validateInstanceId(t), this._instanceInfo[t].visible === e ? this : (this._instanceInfo[t].visible = e, this._visibilityChanged = true, this);
  }
  getVisibleAt(t) {
    return this.validateInstanceId(t), this._instanceInfo[t].visible;
  }
  setGeometryIdAt(t, e) {
    return this.validateInstanceId(t), this.validateGeometryId(e), this._instanceInfo[t].geometryIndex = e, this;
  }
  getGeometryIdAt(t) {
    return this.validateInstanceId(t), this._instanceInfo[t].geometryIndex;
  }
  getGeometryRangeAt(t, e = {}) {
    this.validateGeometryId(t);
    let n4 = this._geometryInfo[t];
    return e.vertexStart = n4.vertexStart, e.vertexCount = n4.vertexCount, e.reservedVertexCount = n4.reservedVertexCount, e.indexStart = n4.indexStart, e.indexCount = n4.indexCount, e.reservedIndexCount = n4.reservedIndexCount, e.start = n4.start, e.count = n4.count, e;
  }
  setInstanceCount(t) {
    let e = this._availableInstanceIds, n4 = this._instanceInfo;
    for (e.sort(Jo$2); e[e.length - 1] === n4.length; ) n4.pop(), e.pop();
    if (t < n4.length) throw new Error("BatchedMesh: Instance ids outside the range ".concat(t, " are being used. Cannot shrink instance count."));
    let i = new Int32Array(t), r5 = new Int32Array(t);
    Qn$2(this._multiDrawCounts, i), Qn$2(this._multiDrawStarts, r5), this._multiDrawCounts = i, this._multiDrawStarts = r5, this._maxInstanceCount = t;
    let a4 = this._indirectTexture, o4 = this._matricesTexture, l = this._colorsTexture;
    a4.dispose(), this._initIndirectTexture(), Qn$2(a4.image.data, this._indirectTexture.image.data), o4.dispose(), this._initMatricesTexture(), Qn$2(o4.image.data, this._matricesTexture.image.data), l && (l.dispose(), this._initColorsTexture(), Qn$2(l.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(t, e) {
    let n4 = [...this._geometryInfo].filter((o4) => o4.active);
    if (Math.max(...n4.map((o4) => o4.vertexStart + o4.reservedVertexCount)) > t) throw new Error("BatchedMesh: Geometry vertex values are being used outside the range ".concat(e, ". Cannot shrink further."));
    if (this.geometry.index && Math.max(...n4.map((l) => l.indexStart + l.reservedIndexCount)) > e) throw new Error("BatchedMesh: Geometry index values are being used outside the range ".concat(e, ". Cannot shrink further."));
    let r5 = this.geometry;
    r5.dispose(), this._maxVertexCount = t, this._maxIndexCount = e, this._geometryInitialized && (this._geometryInitialized = false, this.geometry = new pe$3(), this._initializeGeometry(r5));
    let a4 = this.geometry;
    r5.index && Qn$2(r5.index.array, a4.index.array);
    for (let o4 in r5.attributes) Qn$2(r5.attributes[o4].array, a4.attributes[o4].array);
  }
  raycast(t, e) {
    let n4 = this._instanceInfo, i = this._geometryInfo, r5 = this.matrixWorld, a4 = this.geometry;
    Ee$2.material = this.material, Ee$2.geometry.index = a4.index, Ee$2.geometry.attributes = a4.attributes, Ee$2.geometry.boundingBox === null && (Ee$2.geometry.boundingBox = new Pe$3()), Ee$2.geometry.boundingSphere === null && (Ee$2.geometry.boundingSphere = new Ae$3());
    for (let o4 = 0, l = n4.length; o4 < l; o4++) {
      if (!n4[o4].visible || !n4[o4].active) continue;
      let c = n4[o4].geometryIndex, u5 = i[c];
      Ee$2.geometry.setDrawRange(u5.start, u5.count), this.getMatrixAt(o4, Ee$2.matrixWorld).premultiply(r5), this.getBoundingBoxAt(c, Ee$2.geometry.boundingBox), this.getBoundingSphereAt(c, Ee$2.geometry.boundingSphere), Ee$2.raycast(t, vr$1);
      for (let d = 0, f = vr$1.length; d < f; d++) {
        let m5 = vr$1[d];
        m5.object = this, m5.batchId = o4, e.push(m5);
      }
      vr$1.length = 0;
    }
    Ee$2.material = null, Ee$2.geometry.index = null, Ee$2.geometry.attributes = {}, Ee$2.geometry.setDrawRange(0, 1 / 0);
  }
  copy(t) {
    return super.copy(t), this.geometry = t.geometry.clone(), this.perObjectFrustumCulled = t.perObjectFrustumCulled, this.sortObjects = t.sortObjects, this.boundingBox = t.boundingBox !== null ? t.boundingBox.clone() : null, this.boundingSphere = t.boundingSphere !== null ? t.boundingSphere.clone() : null, this._geometryInfo = t._geometryInfo.map((e) => G$1(F$1({}, e), { boundingBox: e.boundingBox !== null ? e.boundingBox.clone() : null, boundingSphere: e.boundingSphere !== null ? e.boundingSphere.clone() : null })), this._instanceInfo = t._instanceInfo.map((e) => F$1({}, e)), this._maxInstanceCount = t._maxInstanceCount, this._maxVertexCount = t._maxVertexCount, this._maxIndexCount = t._maxIndexCount, this._geometryInitialized = t._geometryInitialized, this._geometryCount = t._geometryCount, this._multiDrawCounts = t._multiDrawCounts.slice(), this._multiDrawStarts = t._multiDrawStarts.slice(), this._matricesTexture = t._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = t._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null), this;
  }
  onBeforeRender(t, e, n4, i, r5) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
    let a4 = i.getIndex(), o4 = a4 === null ? 1 : a4.array.BYTES_PER_ELEMENT, l = this._instanceInfo, c = this._multiDrawStarts, u5 = this._multiDrawCounts, d = this._geometryInfo, f = this.perObjectFrustumCulled, m5 = this._indirectTexture, _ = m5.image.data;
    f && (Ne$2.multiplyMatrices(n4.projectionMatrix, n4.matrixWorldInverse).multiply(this.matrixWorld), $o$1.setFromProjectionMatrix(Ne$2, t.coordinateSystem));
    let x2 = 0;
    if (this.sortObjects) {
      Ne$2.copy(this.matrixWorld).invert(), os$2.setFromMatrixPosition(n4.matrixWorld).applyMatrix4(Ne$2), bd$2.set(0, 0, -1).transformDirection(n4.matrixWorld).transformDirection(Ne$2);
      for (let w3 = 0, b = l.length; w3 < b; w3++) if (l[w3].visible && l[w3].active) {
        let y4 = l[w3].geometryIndex;
        this.getMatrixAt(w3, Ne$2), this.getBoundingSphereAt(y4, Kn$1).applyMatrix4(Ne$2);
        let D4 = false;
        if (f && (D4 = !$o$1.intersectsSphere(Kn$1)), !D4) {
          let C3 = d[y4], R3 = Mm$1.subVectors(Kn$1.center, os$2).dot(bd$2);
          Ko$1.push(C3.start, C3.count, R3, w3);
        }
      }
      let g = Ko$1.list, p4 = this.customSort;
      p4 === null ? g.sort(r5.transparent ? vm$2 : xm$2) : p4.call(this, g, n4);
      for (let w3 = 0, b = g.length; w3 < b; w3++) {
        let y4 = g[w3];
        c[x2] = y4.start * o4, u5[x2] = y4.count, _[x2] = y4.index, x2++;
      }
      Ko$1.reset();
    } else for (let g = 0, p4 = l.length; g < p4; g++) if (l[g].visible && l[g].active) {
      let w3 = l[g].geometryIndex, b = false;
      if (f && (this.getMatrixAt(g, Ne$2), this.getBoundingSphereAt(w3, Kn$1).applyMatrix4(Ne$2), b = !$o$1.intersectsSphere(Kn$1)), !b) {
        let y4 = d[w3];
        c[x2] = y4.start * o4, u5[x2] = y4.count, _[x2] = g, x2++;
      }
    }
    m5.needsUpdate = true, this._multiDrawCount = x2, this._visibilityChanged = false;
  }
  onBeforeShadow(t, e, n4, i, r5, a4) {
    this.onBeforeRender(t, null, i, r5, a4);
  }
};
H$3(rh$2, "BatchedMesh");
var _l$2 = rh$2, ah$2 = class ah extends nn$2 {
  constructor(t) {
    super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Ft$3(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
  }
};
H$3(ah$2, "LineBasicMaterial");
var Ts$2 = ah$2, Wr = new I$1(), Xr$3 = new I$1(), Ed$2 = new Vt$2(), ls$2 = new Hn$1(), yr$2 = new Ae$3(), Qo$1 = new I$1(), Td$2 = new I$1(), oh$2 = class oh extends fe$2 {
  constructor(t = new pe$3(), e = new Ts$2()) {
    super(), this.isLine = true, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  computeLineDistances() {
    let t = this.geometry;
    if (t.index === null) {
      let e = t.attributes.position, n4 = [0];
      for (let i = 1, r5 = e.count; i < r5; i++) Wr.fromBufferAttribute(e, i - 1), Xr$3.fromBufferAttribute(e, i), n4[i] = n4[i - 1], n4[i] += Wr.distanceTo(Xr$3);
      t.setAttribute("lineDistance", new re$4(n4, 1));
    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(t, e) {
    let n4 = this.geometry, i = this.matrixWorld, r5 = t.params.Line.threshold, a4 = n4.drawRange;
    if (n4.boundingSphere === null && n4.computeBoundingSphere(), yr$2.copy(n4.boundingSphere), yr$2.applyMatrix4(i), yr$2.radius += r5, t.ray.intersectsSphere(yr$2) === false) return;
    Ed$2.copy(i).invert(), ls$2.copy(t.ray).applyMatrix4(Ed$2);
    let o4 = r5 / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o4 * o4, c = this.isLineSegments ? 2 : 1, u5 = n4.index, f = n4.attributes.position;
    if (u5 !== null) {
      let m5 = Math.max(0, a4.start), _ = Math.min(u5.count, a4.start + a4.count);
      for (let x2 = m5, g = _ - 1; x2 < g; x2 += c) {
        let p4 = u5.getX(x2), w3 = u5.getX(x2 + 1), b = Mr$1(this, t, ls$2, l, p4, w3, x2);
        b && e.push(b);
      }
      if (this.isLineLoop) {
        let x2 = u5.getX(_ - 1), g = u5.getX(m5), p4 = Mr$1(this, t, ls$2, l, x2, g, _ - 1);
        p4 && e.push(p4);
      }
    } else {
      let m5 = Math.max(0, a4.start), _ = Math.min(f.count, a4.start + a4.count);
      for (let x2 = m5, g = _ - 1; x2 < g; x2 += c) {
        let p4 = Mr$1(this, t, ls$2, l, x2, x2 + 1, x2);
        p4 && e.push(p4);
      }
      if (this.isLineLoop) {
        let x2 = Mr$1(this, t, ls$2, l, _ - 1, m5, _ - 1);
        x2 && e.push(x2);
      }
    }
  }
  updateMorphTargets() {
    let e = this.geometry.morphAttributes, n4 = Object.keys(e);
    if (n4.length > 0) {
      let i = e[n4[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r5 = 0, a4 = i.length; r5 < a4; r5++) {
          let o4 = i[r5].name || String(r5);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o4] = r5;
        }
      }
    }
  }
};
H$3(oh$2, "Line");
var As$2 = oh$2;
function Mr$1(s5, t, e, n4, i, r5, a4) {
  let o4 = s5.geometry.attributes.position;
  if (Wr.fromBufferAttribute(o4, i), Xr$3.fromBufferAttribute(o4, r5), e.distanceSqToSegment(Wr, Xr$3, Qo$1, Td$2) > n4) return;
  Qo$1.applyMatrix4(s5.matrixWorld);
  let c = t.ray.origin.distanceTo(Qo$1);
  if (!(c < t.near || c > t.far)) return { distance: c, point: Td$2.clone().applyMatrix4(s5.matrixWorld), index: a4, face: null, faceIndex: null, barycoord: null, object: s5 };
}
H$3(Mr$1, "checkIntersection");
var Ad$2 = new I$1(), wd$2 = new I$1(), lh$2 = class lh extends As$2 {
  constructor(t, e) {
    super(t, e), this.isLineSegments = true, this.type = "LineSegments";
  }
  computeLineDistances() {
    let t = this.geometry;
    if (t.index === null) {
      let e = t.attributes.position, n4 = [];
      for (let i = 0, r5 = e.count; i < r5; i += 2) Ad$2.fromBufferAttribute(e, i), wd$2.fromBufferAttribute(e, i + 1), n4[i] = i === 0 ? 0 : n4[i - 1], n4[i + 1] = n4[i] + Ad$2.distanceTo(wd$2);
      t.setAttribute("lineDistance", new re$4(n4, 1));
    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
};
H$3(lh$2, "LineSegments");
var qr = lh$2, ch$2 = class ch extends As$2 {
  constructor(t, e) {
    super(t, e), this.isLineLoop = true, this.type = "LineLoop";
  }
};
H$3(ch$2, "LineLoop");
var xl$2 = ch$2, hh$2 = class hh extends nn$2 {
  constructor(t) {
    super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Ft$3(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this;
  }
};
H$3(hh$2, "PointsMaterial");
var Yr$2 = hh$2, Cd$2 = new Vt$2(), vl$2 = new Hn$1(), Sr$2 = new Ae$3(), br$1 = new I$1(), uh$2 = class uh extends fe$2 {
  constructor(t = new pe$3(), e = new Yr$2()) {
    super(), this.isPoints = true, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  raycast(t, e) {
    let n4 = this.geometry, i = this.matrixWorld, r5 = t.params.Points.threshold, a4 = n4.drawRange;
    if (n4.boundingSphere === null && n4.computeBoundingSphere(), Sr$2.copy(n4.boundingSphere), Sr$2.applyMatrix4(i), Sr$2.radius += r5, t.ray.intersectsSphere(Sr$2) === false) return;
    Cd$2.copy(i).invert(), vl$2.copy(t.ray).applyMatrix4(Cd$2);
    let o4 = r5 / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o4 * o4, c = n4.index, d = n4.attributes.position;
    if (c !== null) {
      let f = Math.max(0, a4.start), m5 = Math.min(c.count, a4.start + a4.count);
      for (let _ = f, x2 = m5; _ < x2; _++) {
        let g = c.getX(_);
        br$1.fromBufferAttribute(d, g), Rd$2(br$1, g, l, i, t, e, this);
      }
    } else {
      let f = Math.max(0, a4.start), m5 = Math.min(d.count, a4.start + a4.count);
      for (let _ = f, x2 = m5; _ < x2; _++) br$1.fromBufferAttribute(d, _), Rd$2(br$1, _, l, i, t, e, this);
    }
  }
  updateMorphTargets() {
    let e = this.geometry.morphAttributes, n4 = Object.keys(e);
    if (n4.length > 0) {
      let i = e[n4[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r5 = 0, a4 = i.length; r5 < a4; r5++) {
          let o4 = i[r5].name || String(r5);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o4] = r5;
        }
      }
    }
  }
};
H$3(uh$2, "Points");
var yl$2 = uh$2;
function Rd$2(s5, t, e, n4, i, r5, a4) {
  let o4 = vl$2.distanceSqToPoint(s5);
  if (o4 < e) {
    let l = new I$1();
    vl$2.closestPointToPoint(s5, l), l.applyMatrix4(n4);
    let c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    r5.push({ distance: c, distanceToRay: Math.sqrt(o4), point: l, index: t, face: null, faceIndex: null, barycoord: null, object: a4 });
  }
}
H$3(Rd$2, "testPoint");
var dh$2 = class dh extends we$2 {
  constructor(t, e, n4, i, r5, a4, o4, l, c, u5, d, f) {
    super(null, a4, o4, l, c, u5, i, r5, d, f), this.isCompressedTexture = true, this.image = { width: e, height: n4 }, this.mipmaps = t, this.flipY = false, this.generateMipmaps = false;
  }
};
H$3(dh$2, "CompressedTexture");
var Ml$2 = dh$2;
var fh$2 = class fh extends we$2 {
  constructor(t, e, n4, i, r5, a4, o4, l, c, u5 = ei$2) {
    if (u5 !== ei$2 && u5 !== si$2) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n4 === void 0 && u5 === ei$2 && (n4 = Rn$1), n4 === void 0 && u5 === si$2 && (n4 = gi$1), super(null, i, r5, a4, o4, l, u5, n4, c), this.isDepthTexture = true, this.image = { width: t, height: e }, this.magFilter = o4 !== void 0 ? o4 : Fe$2, this.minFilter = l !== void 0 ? l : Fe$2, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
  }
  copy(t) {
    return super.copy(t), this.compareFunction = t.compareFunction, this;
  }
  toJSON(t) {
    let e = super.toJSON(t);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
};
H$3(fh$2, "DepthTexture");
var ws$2 = fh$2, ph$2 = class ph {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(t, e) {
    let n4 = this.getUtoTmapping(t);
    return this.getPoint(n4, e);
  }
  getPoints(t = 5) {
    let e = [];
    for (let n4 = 0; n4 <= t; n4++) e.push(this.getPoint(n4 / t));
    return e;
  }
  getSpacedPoints(t = 5) {
    let e = [];
    for (let n4 = 0; n4 <= t; n4++) e.push(this.getPointAt(n4 / t));
    return e;
  }
  getLength() {
    let t = this.getLengths();
    return t[t.length - 1];
  }
  getLengths(t = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = false;
    let e = [], n4, i = this.getPoint(0), r5 = 0;
    e.push(0);
    for (let a4 = 1; a4 <= t; a4++) n4 = this.getPoint(a4 / t), r5 += n4.distanceTo(i), e.push(r5), i = n4;
    return this.cacheArcLengths = e, e;
  }
  updateArcLengths() {
    this.needsUpdate = true, this.getLengths();
  }
  getUtoTmapping(t, e) {
    let n4 = this.getLengths(), i = 0, r5 = n4.length, a4;
    e ? a4 = e : a4 = t * n4[r5 - 1];
    let o4 = 0, l = r5 - 1, c;
    for (; o4 <= l; ) if (i = Math.floor(o4 + (l - o4) / 2), c = n4[i] - a4, c < 0) o4 = i + 1;
    else if (c > 0) l = i - 1;
    else {
      l = i;
      break;
    }
    if (i = l, n4[i] === a4) return i / (r5 - 1);
    let u5 = n4[i], f = n4[i + 1] - u5, m5 = (a4 - u5) / f;
    return (i + m5) / (r5 - 1);
  }
  getTangent(t, e) {
    let i = t - 1e-4, r5 = t + 1e-4;
    i < 0 && (i = 0), r5 > 1 && (r5 = 1);
    let a4 = this.getPoint(i), o4 = this.getPoint(r5), l = e || (a4.isVector2 ? new ot$1() : new I$1());
    return l.copy(o4).sub(a4).normalize(), l;
  }
  getTangentAt(t, e) {
    let n4 = this.getUtoTmapping(t);
    return this.getTangent(n4, e);
  }
  computeFrenetFrames(t, e) {
    let n4 = new I$1(), i = [], r5 = [], a4 = [], o4 = new I$1(), l = new Vt$2();
    for (let m5 = 0; m5 <= t; m5++) {
      let _ = m5 / t;
      i[m5] = this.getTangentAt(_, new I$1());
    }
    r5[0] = new I$1(), a4[0] = new I$1();
    let c = Number.MAX_VALUE, u5 = Math.abs(i[0].x), d = Math.abs(i[0].y), f = Math.abs(i[0].z);
    u5 <= c && (c = u5, n4.set(1, 0, 0)), d <= c && (c = d, n4.set(0, 1, 0)), f <= c && n4.set(0, 0, 1), o4.crossVectors(i[0], n4).normalize(), r5[0].crossVectors(i[0], o4), a4[0].crossVectors(i[0], r5[0]);
    for (let m5 = 1; m5 <= t; m5++) {
      if (r5[m5] = r5[m5 - 1].clone(), a4[m5] = a4[m5 - 1].clone(), o4.crossVectors(i[m5 - 1], i[m5]), o4.length() > Number.EPSILON) {
        o4.normalize();
        let _ = Math.acos(Gt$2(i[m5 - 1].dot(i[m5]), -1, 1));
        r5[m5].applyMatrix4(l.makeRotationAxis(o4, _));
      }
      a4[m5].crossVectors(i[m5], r5[m5]);
    }
    if (e === true) {
      let m5 = Math.acos(Gt$2(r5[0].dot(r5[t]), -1, 1));
      m5 /= t, i[0].dot(o4.crossVectors(r5[0], r5[t])) > 0 && (m5 = -m5);
      for (let _ = 1; _ <= t; _++) r5[_].applyMatrix4(l.makeRotationAxis(i[_], m5 * _)), a4[_].crossVectors(i[_], r5[_]);
    }
    return { tangents: i, normals: r5, binormals: a4 };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
  toJSON() {
    let t = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
  }
  fromJSON(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
};
H$3(ph$2, "Curve");
var He$1 = ph$2, mh$2 = class mh extends He$1 {
  constructor(t = 0, e = 0, n4 = 1, i = 1, r5 = 0, a4 = Math.PI * 2, o4 = false, l = 0) {
    super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n4, this.yRadius = i, this.aStartAngle = r5, this.aEndAngle = a4, this.aClockwise = o4, this.aRotation = l;
  }
  getPoint(t, e = new ot$1()) {
    let n4 = e, i = Math.PI * 2, r5 = this.aEndAngle - this.aStartAngle, a4 = Math.abs(r5) < Number.EPSILON;
    for (; r5 < 0; ) r5 += i;
    for (; r5 > i; ) r5 -= i;
    r5 < Number.EPSILON && (a4 ? r5 = 0 : r5 = i), this.aClockwise === true && !a4 && (r5 === i ? r5 = -i : r5 = r5 - i);
    let o4 = this.aStartAngle + t * r5, l = this.aX + this.xRadius * Math.cos(o4), c = this.aY + this.yRadius * Math.sin(o4);
    if (this.aRotation !== 0) {
      let u5 = Math.cos(this.aRotation), d = Math.sin(this.aRotation), f = l - this.aX, m5 = c - this.aY;
      l = f * u5 - m5 * d + this.aX, c = f * d + m5 * u5 + this.aY;
    }
    return n4.set(l, c);
  }
  copy(t) {
    return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }
};
H$3(mh$2, "EllipseCurve");
var Yi$2 = mh$2, gh$2 = class gh extends Yi$2 {
  constructor(t, e, n4, i, r5, a4) {
    super(t, e, n4, n4, i, r5, a4), this.isArcCurve = true, this.type = "ArcCurve";
  }
};
H$3(gh$2, "ArcCurve");
var Zr$1 = gh$2;
function _c$2() {
  let s5 = 0, t = 0, e = 0, n4 = 0;
  function i(r5, a4, o4, l) {
    s5 = r5, t = o4, e = -3 * r5 + 3 * a4 - 2 * o4 - l, n4 = 2 * r5 - 2 * a4 + o4 + l;
  }
  return H$3(i, "init"), { initCatmullRom: H$3(function(r5, a4, o4, l, c) {
    i(a4, o4, c * (o4 - r5), c * (l - a4));
  }, "initCatmullRom"), initNonuniformCatmullRom: H$3(function(r5, a4, o4, l, c, u5, d) {
    let f = (a4 - r5) / c - (o4 - r5) / (c + u5) + (o4 - a4) / u5, m5 = (o4 - a4) / u5 - (l - a4) / (u5 + d) + (l - o4) / d;
    f *= u5, m5 *= u5, i(a4, o4, f, m5);
  }, "initNonuniformCatmullRom"), calc: H$3(function(r5) {
    let a4 = r5 * r5, o4 = a4 * r5;
    return s5 + t * r5 + e * a4 + n4 * o4;
  }, "calc") };
}
H$3(_c$2, "CubicPoly");
var Er$1 = new I$1(), jo$2 = new _c$2(), tl$2 = new _c$2(), el$2 = new _c$2(), _h$2 = class _h extends He$1 {
  constructor(t = [], e = false, n4 = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n4, this.tension = i;
  }
  getPoint(t, e = new I$1()) {
    let n4 = e, i = this.points, r5 = i.length, a4 = (r5 - (this.closed ? 0 : 1)) * t, o4 = Math.floor(a4), l = a4 - o4;
    this.closed ? o4 += o4 > 0 ? 0 : (Math.floor(Math.abs(o4) / r5) + 1) * r5 : l === 0 && o4 === r5 - 1 && (o4 = r5 - 2, l = 1);
    let c, u5;
    this.closed || o4 > 0 ? c = i[(o4 - 1) % r5] : (Er$1.subVectors(i[0], i[1]).add(i[0]), c = Er$1);
    let d = i[o4 % r5], f = i[(o4 + 1) % r5];
    if (this.closed || o4 + 2 < r5 ? u5 = i[(o4 + 2) % r5] : (Er$1.subVectors(i[r5 - 1], i[r5 - 2]).add(i[r5 - 1]), u5 = Er$1), this.curveType === "centripetal" || this.curveType === "chordal") {
      let m5 = this.curveType === "chordal" ? 0.5 : 0.25, _ = Math.pow(c.distanceToSquared(d), m5), x2 = Math.pow(d.distanceToSquared(f), m5), g = Math.pow(f.distanceToSquared(u5), m5);
      x2 < 1e-4 && (x2 = 1), _ < 1e-4 && (_ = x2), g < 1e-4 && (g = x2), jo$2.initNonuniformCatmullRom(c.x, d.x, f.x, u5.x, _, x2, g), tl$2.initNonuniformCatmullRom(c.y, d.y, f.y, u5.y, _, x2, g), el$2.initNonuniformCatmullRom(c.z, d.z, f.z, u5.z, _, x2, g);
    } else this.curveType === "catmullrom" && (jo$2.initCatmullRom(c.x, d.x, f.x, u5.x, this.tension), tl$2.initCatmullRom(c.y, d.y, f.y, u5.y, this.tension), el$2.initCatmullRom(c.z, d.z, f.z, u5.z, this.tension));
    return n4.set(jo$2.calc(l), tl$2.calc(l), el$2.calc(l)), n4;
  }
  copy(t) {
    super.copy(t), this.points = [];
    for (let e = 0, n4 = t.points.length; e < n4; e++) {
      let i = t.points[e];
      this.points.push(i.clone());
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }
  toJSON() {
    let t = super.toJSON();
    t.points = [];
    for (let e = 0, n4 = this.points.length; e < n4; e++) {
      let i = this.points[e];
      t.points.push(i.toArray());
    }
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.points = [];
    for (let e = 0, n4 = t.points.length; e < n4; e++) {
      let i = t.points[e];
      this.points.push(new I$1().fromArray(i));
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }
};
H$3(_h$2, "CatmullRomCurve3");
var Jr$2 = _h$2;
function Id$2(s5, t, e, n4, i) {
  let r5 = (n4 - t) * 0.5, a4 = (i - e) * 0.5, o4 = s5 * s5, l = s5 * o4;
  return (2 * e - 2 * n4 + r5 + a4) * l + (-3 * e + 3 * n4 - 2 * r5 - a4) * o4 + r5 * s5 + e;
}
H$3(Id$2, "CatmullRom");
function bm$2(s5, t) {
  let e = 1 - s5;
  return e * e * t;
}
H$3(bm$2, "QuadraticBezierP0");
function Em$2(s5, t) {
  return 2 * (1 - s5) * s5 * t;
}
H$3(Em$2, "QuadraticBezierP1");
function Tm$2(s5, t) {
  return s5 * s5 * t;
}
H$3(Tm$2, "QuadraticBezierP2");
function us$2(s5, t, e, n4) {
  return bm$2(s5, t) + Em$2(s5, e) + Tm$2(s5, n4);
}
H$3(us$2, "QuadraticBezier");
function Am$1(s5, t) {
  let e = 1 - s5;
  return e * e * e * t;
}
H$3(Am$1, "CubicBezierP0");
function wm$2(s5, t) {
  let e = 1 - s5;
  return 3 * e * e * s5 * t;
}
H$3(wm$2, "CubicBezierP1");
function Cm$1(s5, t) {
  return 3 * (1 - s5) * s5 * s5 * t;
}
H$3(Cm$1, "CubicBezierP2");
function Rm$2(s5, t) {
  return s5 * s5 * s5 * t;
}
H$3(Rm$2, "CubicBezierP3");
function ds$1(s5, t, e, n4, i) {
  return Am$1(s5, t) + wm$2(s5, e) + Cm$1(s5, n4) + Rm$2(s5, i);
}
H$3(ds$1, "CubicBezier");
var xh$2 = class xh extends He$1 {
  constructor(t = new ot$1(), e = new ot$1(), n4 = new ot$1(), i = new ot$1()) {
    super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n4, this.v3 = i;
  }
  getPoint(t, e = new ot$1()) {
    let n4 = e, i = this.v0, r5 = this.v1, a4 = this.v2, o4 = this.v3;
    return n4.set(ds$1(t, i.x, r5.x, a4.x, o4.x), ds$1(t, i.y, r5.y, a4.y, o4.y)), n4;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }
};
H$3(xh$2, "CubicBezierCurve");
var Cs$1 = xh$2, vh$2 = class vh extends He$1 {
  constructor(t = new I$1(), e = new I$1(), n4 = new I$1(), i = new I$1()) {
    super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n4, this.v3 = i;
  }
  getPoint(t, e = new I$1()) {
    let n4 = e, i = this.v0, r5 = this.v1, a4 = this.v2, o4 = this.v3;
    return n4.set(ds$1(t, i.x, r5.x, a4.x, o4.x), ds$1(t, i.y, r5.y, a4.y, o4.y), ds$1(t, i.z, r5.z, a4.z, o4.z)), n4;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }
};
H$3(vh$2, "CubicBezierCurve3");
var $r$1 = vh$2, yh$2 = class yh extends He$1 {
  constructor(t = new ot$1(), e = new ot$1()) {
    super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = t, this.v2 = e;
  }
  getPoint(t, e = new ot$1()) {
    let n4 = e;
    return t === 1 ? n4.copy(this.v2) : (n4.copy(this.v2).sub(this.v1), n4.multiplyScalar(t).add(this.v1)), n4;
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new ot$1()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
};
H$3(yh$2, "LineCurve");
var Rs$1 = yh$2, Mh$2 = class Mh extends He$1 {
  constructor(t = new I$1(), e = new I$1()) {
    super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = t, this.v2 = e;
  }
  getPoint(t, e = new I$1()) {
    let n4 = e;
    return t === 1 ? n4.copy(this.v2) : (n4.copy(this.v2).sub(this.v1), n4.multiplyScalar(t).add(this.v1)), n4;
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new I$1()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
};
H$3(Mh$2, "LineCurve3");
var Kr$2 = Mh$2, Sh$2 = class Sh extends He$1 {
  constructor(t = new ot$1(), e = new ot$1(), n4 = new ot$1()) {
    super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n4;
  }
  getPoint(t, e = new ot$1()) {
    let n4 = e, i = this.v0, r5 = this.v1, a4 = this.v2;
    return n4.set(us$2(t, i.x, r5.x, a4.x), us$2(t, i.y, r5.y, a4.y)), n4;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
};
H$3(Sh$2, "QuadraticBezierCurve");
var Is$1 = Sh$2, bh$2 = class bh extends He$1 {
  constructor(t = new I$1(), e = new I$1(), n4 = new I$1()) {
    super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n4;
  }
  getPoint(t, e = new I$1()) {
    let n4 = e, i = this.v0, r5 = this.v1, a4 = this.v2;
    return n4.set(us$2(t, i.x, r5.x, a4.x), us$2(t, i.y, r5.y, a4.y), us$2(t, i.z, r5.z, a4.z)), n4;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
};
H$3(bh$2, "QuadraticBezierCurve3");
var Ps$2 = bh$2, Eh$2 = class Eh extends He$1 {
  constructor(t = []) {
    super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = t;
  }
  getPoint(t, e = new ot$1()) {
    let n4 = e, i = this.points, r5 = (i.length - 1) * t, a4 = Math.floor(r5), o4 = r5 - a4, l = i[a4 === 0 ? a4 : a4 - 1], c = i[a4], u5 = i[a4 > i.length - 2 ? i.length - 1 : a4 + 1], d = i[a4 > i.length - 3 ? i.length - 1 : a4 + 2];
    return n4.set(Id$2(o4, l.x, c.x, u5.x, d.x), Id$2(o4, l.y, c.y, u5.y, d.y)), n4;
  }
  copy(t) {
    super.copy(t), this.points = [];
    for (let e = 0, n4 = t.points.length; e < n4; e++) {
      let i = t.points[e];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    let t = super.toJSON();
    t.points = [];
    for (let e = 0, n4 = this.points.length; e < n4; e++) {
      let i = this.points[e];
      t.points.push(i.toArray());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.points = [];
    for (let e = 0, n4 = t.points.length; e < n4; e++) {
      let i = t.points[e];
      this.points.push(new ot$1().fromArray(i));
    }
    return this;
  }
};
H$3(Eh$2, "SplineCurve");
var Ds$2 = Eh$2, Qr$2 = Object.freeze({ __proto__: null, ArcCurve: Zr$1, CatmullRomCurve3: Jr$2, CubicBezierCurve: Cs$1, CubicBezierCurve3: $r$1, EllipseCurve: Yi$2, LineCurve: Rs$1, LineCurve3: Kr$2, QuadraticBezierCurve: Is$1, QuadraticBezierCurve3: Ps$2, SplineCurve: Ds$2 }), Th$2 = class Th extends He$1 {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
  }
  add(t) {
    this.curves.push(t);
  }
  closePath() {
    let t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    if (!t.equals(e)) {
      let n4 = t.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Qr$2[n4](e, t));
    }
    return this;
  }
  getPoint(t, e) {
    let n4 = t * this.getLength(), i = this.getCurveLengths(), r5 = 0;
    for (; r5 < i.length; ) {
      if (i[r5] >= n4) {
        let a4 = i[r5] - n4, o4 = this.curves[r5], l = o4.getLength(), c = l === 0 ? 0 : 1 - a4 / l;
        return o4.getPointAt(c, e);
      }
      r5++;
    }
    return null;
  }
  getLength() {
    let t = this.getCurveLengths();
    return t[t.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    let t = [], e = 0;
    for (let n4 = 0, i = this.curves.length; n4 < i; n4++) e += this.curves[n4].getLength(), t.push(e);
    return this.cacheLengths = t, t;
  }
  getSpacedPoints(t = 40) {
    let e = [];
    for (let n4 = 0; n4 <= t; n4++) e.push(this.getPoint(n4 / t));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(t = 12) {
    let e = [], n4;
    for (let i = 0, r5 = this.curves; i < r5.length; i++) {
      let a4 = r5[i], o4 = a4.isEllipseCurve ? t * 2 : a4.isLineCurve || a4.isLineCurve3 ? 1 : a4.isSplineCurve ? t * a4.points.length : t, l = a4.getPoints(o4);
      for (let c = 0; c < l.length; c++) {
        let u5 = l[c];
        n4 && n4.equals(u5) || (e.push(u5), n4 = u5);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  }
  copy(t) {
    super.copy(t), this.curves = [];
    for (let e = 0, n4 = t.curves.length; e < n4; e++) {
      let i = t.curves[e];
      this.curves.push(i.clone());
    }
    return this.autoClose = t.autoClose, this;
  }
  toJSON() {
    let t = super.toJSON();
    t.autoClose = this.autoClose, t.curves = [];
    for (let e = 0, n4 = this.curves.length; e < n4; e++) {
      let i = this.curves[e];
      t.curves.push(i.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
    for (let e = 0, n4 = t.curves.length; e < n4; e++) {
      let i = t.curves[e];
      this.curves.push(new Qr$2[i.type]().fromJSON(i));
    }
    return this;
  }
};
H$3(Th$2, "CurvePath");
var jr$1 = Th$2, Ah$2 = class Ah extends jr$1 {
  constructor(t) {
    super(), this.type = "Path", this.currentPoint = new ot$1(), t && this.setFromPoints(t);
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n4 = t.length; e < n4; e++) this.lineTo(t[e].x, t[e].y);
    return this;
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this;
  }
  lineTo(t, e) {
    let n4 = new Rs$1(this.currentPoint.clone(), new ot$1(t, e));
    return this.curves.push(n4), this.currentPoint.set(t, e), this;
  }
  quadraticCurveTo(t, e, n4, i) {
    let r5 = new Is$1(this.currentPoint.clone(), new ot$1(t, e), new ot$1(n4, i));
    return this.curves.push(r5), this.currentPoint.set(n4, i), this;
  }
  bezierCurveTo(t, e, n4, i, r5, a4) {
    let o4 = new Cs$1(this.currentPoint.clone(), new ot$1(t, e), new ot$1(n4, i), new ot$1(r5, a4));
    return this.curves.push(o4), this.currentPoint.set(r5, a4), this;
  }
  splineThru(t) {
    let e = [this.currentPoint.clone()].concat(t), n4 = new Ds$2(e);
    return this.curves.push(n4), this.currentPoint.copy(t[t.length - 1]), this;
  }
  arc(t, e, n4, i, r5, a4) {
    let o4 = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(t + o4, e + l, n4, i, r5, a4), this;
  }
  absarc(t, e, n4, i, r5, a4) {
    return this.absellipse(t, e, n4, n4, i, r5, a4), this;
  }
  ellipse(t, e, n4, i, r5, a4, o4, l) {
    let c = this.currentPoint.x, u5 = this.currentPoint.y;
    return this.absellipse(t + c, e + u5, n4, i, r5, a4, o4, l), this;
  }
  absellipse(t, e, n4, i, r5, a4, o4, l) {
    let c = new Yi$2(t, e, n4, i, r5, a4, o4, l);
    if (this.curves.length > 0) {
      let d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    let u5 = c.getPoint(1);
    return this.currentPoint.copy(u5), this;
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.currentPoint = this.currentPoint.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
  }
};
H$3(Ah$2, "Path");
var Ls$2 = Ah$2;
var ya$2 = class ya extends pe$3 {
  constructor(t = 1, e = 1, n4 = 1, i = 32, r5 = 1, a4 = false, o4 = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n4, radialSegments: i, heightSegments: r5, openEnded: a4, thetaStart: o4, thetaLength: l };
    let c = this;
    i = Math.floor(i), r5 = Math.floor(r5);
    let u5 = [], d = [], f = [], m5 = [], _ = 0, x2 = [], g = n4 / 2, p4 = 0;
    w3(), a4 === false && (t > 0 && b(true), e > 0 && b(false)), this.setIndex(u5), this.setAttribute("position", new re$4(d, 3)), this.setAttribute("normal", new re$4(f, 3)), this.setAttribute("uv", new re$4(m5, 2));
    function w3() {
      let y4 = new I$1(), D4 = new I$1(), C3 = 0, R3 = (e - t) / n4;
      for (let L3 = 0; L3 <= r5; L3++) {
        let E4 = [], S4 = L3 / r5, P4 = S4 * (e - t) + t;
        for (let G3 = 0; G3 <= i; G3++) {
          let B3 = G3 / i, V3 = B3 * l + o4, J4 = Math.sin(V3), H5 = Math.cos(V3);
          D4.x = P4 * J4, D4.y = -S4 * n4 + g, D4.z = P4 * H5, d.push(D4.x, D4.y, D4.z), y4.set(J4, R3, H5).normalize(), f.push(y4.x, y4.y, y4.z), m5.push(B3, 1 - S4), E4.push(_++);
        }
        x2.push(E4);
      }
      for (let L3 = 0; L3 < i; L3++) for (let E4 = 0; E4 < r5; E4++) {
        let S4 = x2[E4][L3], P4 = x2[E4 + 1][L3], G3 = x2[E4 + 1][L3 + 1], B3 = x2[E4][L3 + 1];
        (t > 0 || E4 !== 0) && (u5.push(S4, P4, B3), C3 += 3), (e > 0 || E4 !== r5 - 1) && (u5.push(P4, G3, B3), C3 += 3);
      }
      c.addGroup(p4, C3, 0), p4 += C3;
    }
    H$3(w3, "generateTorso");
    function b(y4) {
      let D4 = _, C3 = new ot$1(), R3 = new I$1(), L3 = 0, E4 = y4 === true ? t : e, S4 = y4 === true ? 1 : -1;
      for (let G3 = 1; G3 <= i; G3++) d.push(0, g * S4, 0), f.push(0, S4, 0), m5.push(0.5, 0.5), _++;
      let P4 = _;
      for (let G3 = 0; G3 <= i; G3++) {
        let V3 = G3 / i * l + o4, J4 = Math.cos(V3), H5 = Math.sin(V3);
        R3.x = E4 * H5, R3.y = g * S4, R3.z = E4 * J4, d.push(R3.x, R3.y, R3.z), f.push(0, S4, 0), C3.x = J4 * 0.5 + 0.5, C3.y = H5 * 0.5 * S4 + 0.5, m5.push(C3.x, C3.y), _++;
      }
      for (let G3 = 0; G3 < i; G3++) {
        let B3 = D4 + G3, V3 = P4 + G3;
        y4 === true ? u5.push(V3, V3 + 1, B3) : u5.push(V3 + 1, V3, B3), L3 += 3;
      }
      c.addGroup(p4, L3, y4 === true ? 1 : 2), p4 += L3;
    }
    H$3(b, "generateCap");
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new ya(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
  }
};
H$3(ya$2, "CylinderGeometry");
var Sl$2 = ya$2;
var Tr$1 = new I$1(), Ar$2 = new I$1(), nl$2 = new I$1(), wr$2 = new vn$1(), wh$2 = class wh extends pe$3 {
  constructor(t = null, e = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: t, thresholdAngle: e }, t !== null) {
      let i = Math.pow(10, 4), r5 = Math.cos(ki$2 * e), a4 = t.getIndex(), o4 = t.getAttribute("position"), l = a4 ? a4.count : o4.count, c = [0, 0, 0], u5 = ["a", "b", "c"], d = new Array(3), f = {}, m5 = [];
      for (let _ = 0; _ < l; _ += 3) {
        a4 ? (c[0] = a4.getX(_), c[1] = a4.getX(_ + 1), c[2] = a4.getX(_ + 2)) : (c[0] = _, c[1] = _ + 1, c[2] = _ + 2);
        let { a: x2, b: g, c: p4 } = wr$2;
        if (x2.fromBufferAttribute(o4, c[0]), g.fromBufferAttribute(o4, c[1]), p4.fromBufferAttribute(o4, c[2]), wr$2.getNormal(nl$2), d[0] = "".concat(Math.round(x2.x * i), ",").concat(Math.round(x2.y * i), ",").concat(Math.round(x2.z * i)), d[1] = "".concat(Math.round(g.x * i), ",").concat(Math.round(g.y * i), ",").concat(Math.round(g.z * i)), d[2] = "".concat(Math.round(p4.x * i), ",").concat(Math.round(p4.y * i), ",").concat(Math.round(p4.z * i)), !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0])) for (let w3 = 0; w3 < 3; w3++) {
          let b = (w3 + 1) % 3, y4 = d[w3], D4 = d[b], C3 = wr$2[u5[w3]], R3 = wr$2[u5[b]], L3 = "".concat(y4, "_").concat(D4), E4 = "".concat(D4, "_").concat(y4);
          E4 in f && f[E4] ? (nl$2.dot(f[E4].normal) <= r5 && (m5.push(C3.x, C3.y, C3.z), m5.push(R3.x, R3.y, R3.z)), f[E4] = null) : L3 in f || (f[L3] = { index0: c[w3], index1: c[b], normal: nl$2.clone() });
        }
      }
      for (let _ in f) if (f[_]) {
        let { index0: x2, index1: g } = f[_];
        Tr$1.fromBufferAttribute(o4, x2), Ar$2.fromBufferAttribute(o4, g), m5.push(Tr$1.x, Tr$1.y, Tr$1.z), m5.push(Ar$2.x, Ar$2.y, Ar$2.z);
      }
      this.setAttribute("position", new re$4(m5, 3));
    }
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
};
H$3(wh$2, "EdgesGeometry");
var bl$2 = wh$2, Ch$2 = class Ch extends Ls$2 {
  constructor(t) {
    super(t), this.uuid = Ye(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(t) {
    let e = [];
    for (let n4 = 0, i = this.holes.length; n4 < i; n4++) e[n4] = this.holes[n4].getPoints(t);
    return e;
  }
  extractPoints(t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
  }
  copy(t) {
    super.copy(t), this.holes = [];
    for (let e = 0, n4 = t.holes.length; e < n4; e++) {
      let i = t.holes[e];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    let t = super.toJSON();
    t.uuid = this.uuid, t.holes = [];
    for (let e = 0, n4 = this.holes.length; e < n4; e++) {
      let i = this.holes[e];
      t.holes.push(i.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
    for (let e = 0, n4 = t.holes.length; e < n4; e++) {
      let i = t.holes[e];
      this.holes.push(new Ls$2().fromJSON(i));
    }
    return this;
  }
};
H$3(Ch$2, "Shape");
var ta$1 = Ch$2, Im$1 = { triangulate: H$3(function(s5, t, e = 2) {
  let n4 = t && t.length, i = n4 ? t[0] * e : s5.length, r5 = Bf$1(s5, 0, i, e, true), a4 = [];
  if (!r5 || r5.next === r5.prev) return a4;
  let o4, l, c, u5, d, f, m5;
  if (n4 && (r5 = Nm$2(s5, t, r5, e)), s5.length > 80 * e) {
    o4 = c = s5[0], l = u5 = s5[1];
    for (let _ = e; _ < i; _ += e) d = s5[_], f = s5[_ + 1], d < o4 && (o4 = d), f < l && (l = f), d > c && (c = d), f > u5 && (u5 = f);
    m5 = Math.max(c - o4, u5 - l), m5 = m5 !== 0 ? 32767 / m5 : 0;
  }
  return Us$2(r5, a4, e, o4, l, m5, 0), a4;
}, "triangulate") };
function Bf$1(s5, t, e, n4, i) {
  let r5, a4;
  if (i === qm$2(s5, t, e, n4) > 0) for (r5 = t; r5 < e; r5 += n4) a4 = Pd$2(r5, s5[r5], s5[r5 + 1], a4);
  else for (r5 = e - n4; r5 >= t; r5 -= n4) a4 = Pd$2(r5, s5[r5], s5[r5 + 1], a4);
  return a4 && xo$2(a4, a4.next) && (Fs$2(a4), a4 = a4.next), a4;
}
H$3(Bf$1, "linkedList");
function li$2(s5, t) {
  if (!s5) return s5;
  t || (t = s5);
  let e = s5, n4;
  do
    if (n4 = false, !e.steiner && (xo$2(e, e.next) || le$2(e.prev, e, e.next) === 0)) {
      if (Fs$2(e), e = t = e.prev, e === e.next) break;
      n4 = true;
    } else e = e.next;
  while (n4 || e !== t);
  return t;
}
H$3(li$2, "filterPoints");
function Us$2(s5, t, e, n4, i, r5, a4) {
  if (!s5) return;
  !a4 && r5 && km$2(s5, n4, i, r5);
  let o4 = s5, l, c;
  for (; s5.prev !== s5.next; ) {
    if (l = s5.prev, c = s5.next, r5 ? Dm$1(s5, n4, i, r5) : Pm$2(s5)) {
      t.push(l.i / e | 0), t.push(s5.i / e | 0), t.push(c.i / e | 0), Fs$2(s5), s5 = c.next, o4 = c.next;
      continue;
    }
    if (s5 = c, s5 === o4) {
      a4 ? a4 === 1 ? (s5 = Lm$2(li$2(s5), t, e), Us$2(s5, t, e, n4, i, r5, 2)) : a4 === 2 && Um$2(s5, t, e, n4, i, r5) : Us$2(li$2(s5), t, e, n4, i, r5, 1);
      break;
    }
  }
}
H$3(Us$2, "earcutLinked");
function Pm$2(s5) {
  let t = s5.prev, e = s5, n4 = s5.next;
  if (le$2(t, e, n4) >= 0) return false;
  let i = t.x, r5 = e.x, a4 = n4.x, o4 = t.y, l = e.y, c = n4.y, u5 = i < r5 ? i < a4 ? i : a4 : r5 < a4 ? r5 : a4, d = o4 < l ? o4 < c ? o4 : c : l < c ? l : c, f = i > r5 ? i > a4 ? i : a4 : r5 > a4 ? r5 : a4, m5 = o4 > l ? o4 > c ? o4 : c : l > c ? l : c, _ = n4.next;
  for (; _ !== t; ) {
    if (_.x >= u5 && _.x <= f && _.y >= d && _.y <= m5 && Oi$3(i, o4, r5, l, a4, c, _.x, _.y) && le$2(_.prev, _, _.next) >= 0) return false;
    _ = _.next;
  }
  return true;
}
H$3(Pm$2, "isEar");
function Dm$1(s5, t, e, n4) {
  let i = s5.prev, r5 = s5, a4 = s5.next;
  if (le$2(i, r5, a4) >= 0) return false;
  let o4 = i.x, l = r5.x, c = a4.x, u5 = i.y, d = r5.y, f = a4.y, m5 = o4 < l ? o4 < c ? o4 : c : l < c ? l : c, _ = u5 < d ? u5 < f ? u5 : f : d < f ? d : f, x2 = o4 > l ? o4 > c ? o4 : c : l > c ? l : c, g = u5 > d ? u5 > f ? u5 : f : d > f ? d : f, p4 = El$2(m5, _, t, e, n4), w3 = El$2(x2, g, t, e, n4), b = s5.prevZ, y4 = s5.nextZ;
  for (; b && b.z >= p4 && y4 && y4.z <= w3; ) {
    if (b.x >= m5 && b.x <= x2 && b.y >= _ && b.y <= g && b !== i && b !== a4 && Oi$3(o4, u5, l, d, c, f, b.x, b.y) && le$2(b.prev, b, b.next) >= 0 || (b = b.prevZ, y4.x >= m5 && y4.x <= x2 && y4.y >= _ && y4.y <= g && y4 !== i && y4 !== a4 && Oi$3(o4, u5, l, d, c, f, y4.x, y4.y) && le$2(y4.prev, y4, y4.next) >= 0)) return false;
    y4 = y4.nextZ;
  }
  for (; b && b.z >= p4; ) {
    if (b.x >= m5 && b.x <= x2 && b.y >= _ && b.y <= g && b !== i && b !== a4 && Oi$3(o4, u5, l, d, c, f, b.x, b.y) && le$2(b.prev, b, b.next) >= 0) return false;
    b = b.prevZ;
  }
  for (; y4 && y4.z <= w3; ) {
    if (y4.x >= m5 && y4.x <= x2 && y4.y >= _ && y4.y <= g && y4 !== i && y4 !== a4 && Oi$3(o4, u5, l, d, c, f, y4.x, y4.y) && le$2(y4.prev, y4, y4.next) >= 0) return false;
    y4 = y4.nextZ;
  }
  return true;
}
H$3(Dm$1, "isEarHashed");
function Lm$2(s5, t, e) {
  let n4 = s5;
  do {
    let i = n4.prev, r5 = n4.next.next;
    !xo$2(i, r5) && zf$1(i, n4, n4.next, r5) && Ns$2(i, r5) && Ns$2(r5, i) && (t.push(i.i / e | 0), t.push(n4.i / e | 0), t.push(r5.i / e | 0), Fs$2(n4), Fs$2(n4.next), n4 = s5 = r5), n4 = n4.next;
  } while (n4 !== s5);
  return li$2(n4);
}
H$3(Lm$2, "cureLocalIntersections");
function Um$2(s5, t, e, n4, i, r5) {
  let a4 = s5;
  do {
    let o4 = a4.next.next;
    for (; o4 !== a4.prev; ) {
      if (a4.i !== o4.i && Gm$2(a4, o4)) {
        let l = kf$1(a4, o4);
        a4 = li$2(a4, a4.next), l = li$2(l, l.next), Us$2(a4, t, e, n4, i, r5, 0), Us$2(l, t, e, n4, i, r5, 0);
        return;
      }
      o4 = o4.next;
    }
    a4 = a4.next;
  } while (a4 !== s5);
}
H$3(Um$2, "splitEarcut");
function Nm$2(s5, t, e, n4) {
  let i = [], r5, a4, o4, l, c;
  for (r5 = 0, a4 = t.length; r5 < a4; r5++) o4 = t[r5] * n4, l = r5 < a4 - 1 ? t[r5 + 1] * n4 : s5.length, c = Bf$1(s5, o4, l, n4, false), c === c.next && (c.steiner = true), i.push(Hm$1(c));
  for (i.sort(Fm$2), r5 = 0; r5 < i.length; r5++) e = Om$2(i[r5], e);
  return e;
}
H$3(Nm$2, "eliminateHoles");
function Fm$2(s5, t) {
  return s5.x - t.x;
}
H$3(Fm$2, "compareX");
function Om$2(s5, t) {
  let e = Bm$2(s5, t);
  if (!e) return t;
  let n4 = kf$1(e, s5);
  return li$2(n4, n4.next), li$2(e, e.next);
}
H$3(Om$2, "eliminateHole");
function Bm$2(s5, t) {
  let e = t, n4 = -1 / 0, i, r5 = s5.x, a4 = s5.y;
  do {
    if (a4 <= e.y && a4 >= e.next.y && e.next.y !== e.y) {
      let f = e.x + (a4 - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (f <= r5 && f > n4 && (n4 = f, i = e.x < e.next.x ? e : e.next, f === r5)) return i;
    }
    e = e.next;
  } while (e !== t);
  if (!i) return null;
  let o4 = i, l = i.x, c = i.y, u5 = 1 / 0, d;
  e = i;
  do
    r5 >= e.x && e.x >= l && r5 !== e.x && Oi$3(a4 < c ? r5 : n4, a4, l, c, a4 < c ? n4 : r5, a4, e.x, e.y) && (d = Math.abs(a4 - e.y) / (r5 - e.x), Ns$2(e, s5) && (d < u5 || d === u5 && (e.x > i.x || e.x === i.x && zm$2(i, e))) && (i = e, u5 = d)), e = e.next;
  while (e !== o4);
  return i;
}
H$3(Bm$2, "findHoleBridge");
function zm$2(s5, t) {
  return le$2(s5.prev, s5, t.prev) < 0 && le$2(t.next, s5, s5.next) < 0;
}
H$3(zm$2, "sectorContainsSector");
function km$2(s5, t, e, n4) {
  let i = s5;
  do
    i.z === 0 && (i.z = El$2(i.x, i.y, t, e, n4)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== s5);
  i.prevZ.nextZ = null, i.prevZ = null, Vm$2(i);
}
H$3(km$2, "indexCurve");
function Vm$2(s5) {
  let t, e, n4, i, r5, a4, o4, l, c = 1;
  do {
    for (e = s5, s5 = null, r5 = null, a4 = 0; e; ) {
      for (a4++, n4 = e, o4 = 0, t = 0; t < c && (o4++, n4 = n4.nextZ, !!n4); t++) ;
      for (l = c; o4 > 0 || l > 0 && n4; ) o4 !== 0 && (l === 0 || !n4 || e.z <= n4.z) ? (i = e, e = e.nextZ, o4--) : (i = n4, n4 = n4.nextZ, l--), r5 ? r5.nextZ = i : s5 = i, i.prevZ = r5, r5 = i;
      e = n4;
    }
    r5.nextZ = null, c *= 2;
  } while (a4 > 1);
  return s5;
}
H$3(Vm$2, "sortLinked");
function El$2(s5, t, e, n4, i) {
  return s5 = (s5 - e) * i | 0, t = (t - n4) * i | 0, s5 = (s5 | s5 << 8) & 16711935, s5 = (s5 | s5 << 4) & 252645135, s5 = (s5 | s5 << 2) & 858993459, s5 = (s5 | s5 << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, s5 | t << 1;
}
H$3(El$2, "zOrder");
function Hm$1(s5) {
  let t = s5, e = s5;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== s5);
  return e;
}
H$3(Hm$1, "getLeftmost");
function Oi$3(s5, t, e, n4, i, r5, a4, o4) {
  return (i - a4) * (t - o4) >= (s5 - a4) * (r5 - o4) && (s5 - a4) * (n4 - o4) >= (e - a4) * (t - o4) && (e - a4) * (r5 - o4) >= (i - a4) * (n4 - o4);
}
H$3(Oi$3, "pointInTriangle");
function Gm$2(s5, t) {
  return s5.next.i !== t.i && s5.prev.i !== t.i && !Wm$2(s5, t) && (Ns$2(s5, t) && Ns$2(t, s5) && Xm$2(s5, t) && (le$2(s5.prev, s5, t.prev) || le$2(s5, t.prev, t)) || xo$2(s5, t) && le$2(s5.prev, s5, s5.next) > 0 && le$2(t.prev, t, t.next) > 0);
}
H$3(Gm$2, "isValidDiagonal");
function le$2(s5, t, e) {
  return (t.y - s5.y) * (e.x - t.x) - (t.x - s5.x) * (e.y - t.y);
}
H$3(le$2, "area");
function xo$2(s5, t) {
  return s5.x === t.x && s5.y === t.y;
}
H$3(xo$2, "equals");
function zf$1(s5, t, e, n4) {
  let i = Rr$1(le$2(s5, t, e)), r5 = Rr$1(le$2(s5, t, n4)), a4 = Rr$1(le$2(e, n4, s5)), o4 = Rr$1(le$2(e, n4, t));
  return !!(i !== r5 && a4 !== o4 || i === 0 && Cr$2(s5, e, t) || r5 === 0 && Cr$2(s5, n4, t) || a4 === 0 && Cr$2(e, s5, n4) || o4 === 0 && Cr$2(e, t, n4));
}
H$3(zf$1, "intersects");
function Cr$2(s5, t, e) {
  return t.x <= Math.max(s5.x, e.x) && t.x >= Math.min(s5.x, e.x) && t.y <= Math.max(s5.y, e.y) && t.y >= Math.min(s5.y, e.y);
}
H$3(Cr$2, "onSegment");
function Rr$1(s5) {
  return s5 > 0 ? 1 : s5 < 0 ? -1 : 0;
}
H$3(Rr$1, "sign");
function Wm$2(s5, t) {
  let e = s5;
  do {
    if (e.i !== s5.i && e.next.i !== s5.i && e.i !== t.i && e.next.i !== t.i && zf$1(e, e.next, s5, t)) return true;
    e = e.next;
  } while (e !== s5);
  return false;
}
H$3(Wm$2, "intersectsPolygon");
function Ns$2(s5, t) {
  return le$2(s5.prev, s5, s5.next) < 0 ? le$2(s5, t, s5.next) >= 0 && le$2(s5, s5.prev, t) >= 0 : le$2(s5, t, s5.prev) < 0 || le$2(s5, s5.next, t) < 0;
}
H$3(Ns$2, "locallyInside");
function Xm$2(s5, t) {
  let e = s5, n4 = false, i = (s5.x + t.x) / 2, r5 = (s5.y + t.y) / 2;
  do
    e.y > r5 != e.next.y > r5 && e.next.y !== e.y && i < (e.next.x - e.x) * (r5 - e.y) / (e.next.y - e.y) + e.x && (n4 = !n4), e = e.next;
  while (e !== s5);
  return n4;
}
H$3(Xm$2, "middleInside");
function kf$1(s5, t) {
  let e = new Tl$1(s5.i, s5.x, s5.y), n4 = new Tl$1(t.i, t.x, t.y), i = s5.next, r5 = t.prev;
  return s5.next = t, t.prev = s5, e.next = i, i.prev = e, n4.next = e, e.prev = n4, r5.next = n4, n4.prev = r5, n4;
}
H$3(kf$1, "splitPolygon");
function Pd$2(s5, t, e, n4) {
  let i = new Tl$1(s5, t, e);
  return n4 ? (i.next = n4.next, i.prev = n4, n4.next.prev = i, n4.next = i) : (i.prev = i, i.next = i), i;
}
H$3(Pd$2, "insertNode");
function Fs$2(s5) {
  s5.next.prev = s5.prev, s5.prev.next = s5.next, s5.prevZ && (s5.prevZ.nextZ = s5.nextZ), s5.nextZ && (s5.nextZ.prevZ = s5.prevZ);
}
H$3(Fs$2, "removeNode");
function Tl$1(s5, t, e) {
  this.i = s5, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
H$3(Tl$1, "Node");
function qm$2(s5, t, e, n4) {
  let i = 0;
  for (let r5 = t, a4 = e - n4; r5 < e; r5 += n4) i += (s5[a4] - s5[r5]) * (s5[r5 + 1] + s5[a4 + 1]), a4 = r5;
  return i;
}
H$3(qm$2, "signedArea");
var Ma$2 = class Ma {
  static area(t) {
    let e = t.length, n4 = 0;
    for (let i = e - 1, r5 = 0; r5 < e; i = r5++) n4 += t[i].x * t[r5].y - t[r5].x * t[i].y;
    return n4 * 0.5;
  }
  static isClockWise(t) {
    return Ma.area(t) < 0;
  }
  static triangulateShape(t, e) {
    let n4 = [], i = [], r5 = [];
    Dd$2(t), Ld$2(n4, t);
    let a4 = t.length;
    e.forEach(Dd$2);
    for (let l = 0; l < e.length; l++) i.push(a4), a4 += e[l].length, Ld$2(n4, e[l]);
    let o4 = Im$1.triangulate(n4, i);
    for (let l = 0; l < o4.length; l += 3) r5.push(o4.slice(l, l + 3));
    return r5;
  }
};
H$3(Ma$2, "ShapeUtils");
var Hi$2 = Ma$2;
function Dd$2(s5) {
  let t = s5.length;
  t > 2 && s5[t - 1].equals(s5[0]) && s5.pop();
}
H$3(Dd$2, "removeDupEndPts");
function Ld$2(s5, t) {
  for (let e = 0; e < t.length; e++) s5.push(t[e].x), s5.push(t[e].y);
}
H$3(Ld$2, "addContour");
var Sa$2 = class Sa extends pe$3 {
  constructor(t = new ta$1([new ot$1(0.5, 0.5), new ot$1(-0.5, 0.5), new ot$1(-0.5, -0.5), new ot$1(0.5, -0.5)]), e = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
    let n4 = this, i = [], r5 = [];
    for (let o4 = 0, l = t.length; o4 < l; o4++) {
      let c = t[o4];
      a4(c);
    }
    this.setAttribute("position", new re$4(i, 3)), this.setAttribute("uv", new re$4(r5, 2)), this.computeVertexNormals();
    function a4(o4) {
      let l = [], c = e.curveSegments !== void 0 ? e.curveSegments : 12, u5 = e.steps !== void 0 ? e.steps : 1, d = e.depth !== void 0 ? e.depth : 1, f = e.bevelEnabled !== void 0 ? e.bevelEnabled : true, m5 = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2, _ = e.bevelSize !== void 0 ? e.bevelSize : m5 - 0.1, x2 = e.bevelOffset !== void 0 ? e.bevelOffset : 0, g = e.bevelSegments !== void 0 ? e.bevelSegments : 3, p4 = e.extrudePath, w3 = e.UVGenerator !== void 0 ? e.UVGenerator : Ym$2, b, y4 = false, D4, C3, R3, L3;
      p4 && (b = p4.getSpacedPoints(u5), y4 = true, f = false, D4 = p4.computeFrenetFrames(u5, false), C3 = new I$1(), R3 = new I$1(), L3 = new I$1()), f || (g = 0, m5 = 0, _ = 0, x2 = 0);
      let E4 = o4.extractPoints(c), S4 = E4.shape, P4 = E4.holes;
      if (!Hi$2.isClockWise(S4)) {
        S4 = S4.reverse();
        for (let j3 = 0, Q4 = P4.length; j3 < Q4; j3++) {
          let A3 = P4[j3];
          Hi$2.isClockWise(A3) && (P4[j3] = A3.reverse());
        }
      }
      let B3 = Hi$2.triangulateShape(S4, P4), V3 = S4;
      for (let j3 = 0, Q4 = P4.length; j3 < Q4; j3++) {
        let A3 = P4[j3];
        S4 = S4.concat(A3);
      }
      function J4(j3, Q4, A3) {
        return Q4 || console.error("THREE.ExtrudeGeometry: vec does not exist"), j3.clone().addScaledVector(Q4, A3);
      }
      H$3(J4, "scalePt2");
      let H5 = S4.length, it2 = B3.length;
      function W4(j3, Q4, A3) {
        let At2, tt2, xt2, st2 = j3.x - Q4.x, Dt2 = j3.y - Q4.y, ft2 = A3.x - j3.x, T3 = A3.y - j3.y, v3 = st2 * st2 + Dt2 * Dt2, O4 = st2 * T3 - Dt2 * ft2;
        if (Math.abs(O4) > Number.EPSILON) {
          let q4 = Math.sqrt(v3), K4 = Math.sqrt(ft2 * ft2 + T3 * T3), Y3 = Q4.x - Dt2 / q4, Tt2 = Q4.y + st2 / q4, ht2 = A3.x - T3 / K4, _t2 = A3.y + ft2 / K4, Wt2 = ((ht2 - Y3) * T3 - (_t2 - Tt2) * ft2) / (st2 * T3 - Dt2 * ft2);
          At2 = Y3 + st2 * Wt2 - j3.x, tt2 = Tt2 + Dt2 * Wt2 - j3.y;
          let nt2 = At2 * At2 + tt2 * tt2;
          if (nt2 <= 2) return new ot$1(At2, tt2);
          xt2 = Math.sqrt(nt2 / 2);
        } else {
          let q4 = false;
          st2 > Number.EPSILON ? ft2 > Number.EPSILON && (q4 = true) : st2 < -Number.EPSILON ? ft2 < -Number.EPSILON && (q4 = true) : Math.sign(Dt2) === Math.sign(T3) && (q4 = true), q4 ? (At2 = -Dt2, tt2 = st2, xt2 = Math.sqrt(v3)) : (At2 = st2, tt2 = Dt2, xt2 = Math.sqrt(v3 / 2));
        }
        return new ot$1(At2 / xt2, tt2 / xt2);
      }
      H$3(W4, "getBevelVec");
      let lt2 = [];
      for (let j3 = 0, Q4 = V3.length, A3 = Q4 - 1, At2 = j3 + 1; j3 < Q4; j3++, A3++, At2++) A3 === Q4 && (A3 = 0), At2 === Q4 && (At2 = 0), lt2[j3] = W4(V3[j3], V3[A3], V3[At2]);
      let gt2 = [], bt2, Ot2 = lt2.concat();
      for (let j3 = 0, Q4 = P4.length; j3 < Q4; j3++) {
        let A3 = P4[j3];
        bt2 = [];
        for (let At2 = 0, tt2 = A3.length, xt2 = tt2 - 1, st2 = At2 + 1; At2 < tt2; At2++, xt2++, st2++) xt2 === tt2 && (xt2 = 0), st2 === tt2 && (st2 = 0), bt2[At2] = W4(A3[At2], A3[xt2], A3[st2]);
        gt2.push(bt2), Ot2 = Ot2.concat(bt2);
      }
      for (let j3 = 0; j3 < g; j3++) {
        let Q4 = j3 / g, A3 = m5 * Math.cos(Q4 * Math.PI / 2), At2 = _ * Math.sin(Q4 * Math.PI / 2) + x2;
        for (let tt2 = 0, xt2 = V3.length; tt2 < xt2; tt2++) {
          let st2 = J4(V3[tt2], lt2[tt2], At2);
          at2(st2.x, st2.y, -A3);
        }
        for (let tt2 = 0, xt2 = P4.length; tt2 < xt2; tt2++) {
          let st2 = P4[tt2];
          bt2 = gt2[tt2];
          for (let Dt2 = 0, ft2 = st2.length; Dt2 < ft2; Dt2++) {
            let T3 = J4(st2[Dt2], bt2[Dt2], At2);
            at2(T3.x, T3.y, -A3);
          }
        }
      }
      let Qt2 = _ + x2;
      for (let j3 = 0; j3 < H5; j3++) {
        let Q4 = f ? J4(S4[j3], Ot2[j3], Qt2) : S4[j3];
        y4 ? (R3.copy(D4.normals[0]).multiplyScalar(Q4.x), C3.copy(D4.binormals[0]).multiplyScalar(Q4.y), L3.copy(b[0]).add(R3).add(C3), at2(L3.x, L3.y, L3.z)) : at2(Q4.x, Q4.y, 0);
      }
      for (let j3 = 1; j3 <= u5; j3++) for (let Q4 = 0; Q4 < H5; Q4++) {
        let A3 = f ? J4(S4[Q4], Ot2[Q4], Qt2) : S4[Q4];
        y4 ? (R3.copy(D4.normals[j3]).multiplyScalar(A3.x), C3.copy(D4.binormals[j3]).multiplyScalar(A3.y), L3.copy(b[j3]).add(R3).add(C3), at2(L3.x, L3.y, L3.z)) : at2(A3.x, A3.y, d / u5 * j3);
      }
      for (let j3 = g - 1; j3 >= 0; j3--) {
        let Q4 = j3 / g, A3 = m5 * Math.cos(Q4 * Math.PI / 2), At2 = _ * Math.sin(Q4 * Math.PI / 2) + x2;
        for (let tt2 = 0, xt2 = V3.length; tt2 < xt2; tt2++) {
          let st2 = J4(V3[tt2], lt2[tt2], At2);
          at2(st2.x, st2.y, d + A3);
        }
        for (let tt2 = 0, xt2 = P4.length; tt2 < xt2; tt2++) {
          let st2 = P4[tt2];
          bt2 = gt2[tt2];
          for (let Dt2 = 0, ft2 = st2.length; Dt2 < ft2; Dt2++) {
            let T3 = J4(st2[Dt2], bt2[Dt2], At2);
            y4 ? at2(T3.x, T3.y + b[u5 - 1].y, b[u5 - 1].x + A3) : at2(T3.x, T3.y, d + A3);
          }
        }
      }
      Z4(), rt2();
      function Z4() {
        let j3 = i.length / 3;
        if (f) {
          let Q4 = 0, A3 = H5 * Q4;
          for (let At2 = 0; At2 < it2; At2++) {
            let tt2 = B3[At2];
            Ct2(tt2[2] + A3, tt2[1] + A3, tt2[0] + A3);
          }
          Q4 = u5 + g * 2, A3 = H5 * Q4;
          for (let At2 = 0; At2 < it2; At2++) {
            let tt2 = B3[At2];
            Ct2(tt2[0] + A3, tt2[1] + A3, tt2[2] + A3);
          }
        } else {
          for (let Q4 = 0; Q4 < it2; Q4++) {
            let A3 = B3[Q4];
            Ct2(A3[2], A3[1], A3[0]);
          }
          for (let Q4 = 0; Q4 < it2; Q4++) {
            let A3 = B3[Q4];
            Ct2(A3[0] + H5 * u5, A3[1] + H5 * u5, A3[2] + H5 * u5);
          }
        }
        n4.addGroup(j3, i.length / 3 - j3, 0);
      }
      H$3(Z4, "buildLidFaces");
      function rt2() {
        let j3 = i.length / 3, Q4 = 0;
        Et2(V3, Q4), Q4 += V3.length;
        for (let A3 = 0, At2 = P4.length; A3 < At2; A3++) {
          let tt2 = P4[A3];
          Et2(tt2, Q4), Q4 += tt2.length;
        }
        n4.addGroup(j3, i.length / 3 - j3, 1);
      }
      H$3(rt2, "buildSideFaces");
      function Et2(j3, Q4) {
        let A3 = j3.length;
        for (; --A3 >= 0; ) {
          let At2 = A3, tt2 = A3 - 1;
          tt2 < 0 && (tt2 = j3.length - 1);
          for (let xt2 = 0, st2 = u5 + g * 2; xt2 < st2; xt2++) {
            let Dt2 = H5 * xt2, ft2 = H5 * (xt2 + 1), T3 = Q4 + At2 + Dt2, v3 = Q4 + tt2 + Dt2, O4 = Q4 + tt2 + ft2, q4 = Q4 + At2 + ft2;
            Yt2(T3, v3, O4, q4);
          }
        }
      }
      H$3(Et2, "sidewalls");
      function at2(j3, Q4, A3) {
        l.push(j3), l.push(Q4), l.push(A3);
      }
      H$3(at2, "v");
      function Ct2(j3, Q4, A3) {
        wt2(j3), wt2(Q4), wt2(A3);
        let At2 = i.length / 3, tt2 = w3.generateTopUV(n4, i, At2 - 3, At2 - 2, At2 - 1);
        Kt2(tt2[0]), Kt2(tt2[1]), Kt2(tt2[2]);
      }
      H$3(Ct2, "f3");
      function Yt2(j3, Q4, A3, At2) {
        wt2(j3), wt2(Q4), wt2(At2), wt2(Q4), wt2(A3), wt2(At2);
        let tt2 = i.length / 3, xt2 = w3.generateSideWallUV(n4, i, tt2 - 6, tt2 - 3, tt2 - 2, tt2 - 1);
        Kt2(xt2[0]), Kt2(xt2[1]), Kt2(xt2[3]), Kt2(xt2[1]), Kt2(xt2[2]), Kt2(xt2[3]);
      }
      H$3(Yt2, "f4");
      function wt2(j3) {
        i.push(l[j3 * 3 + 0]), i.push(l[j3 * 3 + 1]), i.push(l[j3 * 3 + 2]);
      }
      H$3(wt2, "addVertex");
      function Kt2(j3) {
        r5.push(j3.x), r5.push(j3.y);
      }
      H$3(Kt2, "addUV");
    }
    H$3(a4, "addShape");
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  toJSON() {
    let t = super.toJSON(), e = this.parameters.shapes, n4 = this.parameters.options;
    return Zm$1(e, n4, t);
  }
  static fromJSON(t, e) {
    let n4 = [];
    for (let r5 = 0, a4 = t.shapes.length; r5 < a4; r5++) {
      let o4 = e[t.shapes[r5]];
      n4.push(o4);
    }
    let i = t.options.extrudePath;
    return i !== void 0 && (t.options.extrudePath = new Qr$2[i.type]().fromJSON(i)), new Sa(n4, t.options);
  }
};
H$3(Sa$2, "ExtrudeGeometry");
var Al$1 = Sa$2, Ym$2 = { generateTopUV: H$3(function(s5, t, e, n4, i) {
  let r5 = t[e * 3], a4 = t[e * 3 + 1], o4 = t[n4 * 3], l = t[n4 * 3 + 1], c = t[i * 3], u5 = t[i * 3 + 1];
  return [new ot$1(r5, a4), new ot$1(o4, l), new ot$1(c, u5)];
}, "generateTopUV"), generateSideWallUV: H$3(function(s5, t, e, n4, i, r5) {
  let a4 = t[e * 3], o4 = t[e * 3 + 1], l = t[e * 3 + 2], c = t[n4 * 3], u5 = t[n4 * 3 + 1], d = t[n4 * 3 + 2], f = t[i * 3], m5 = t[i * 3 + 1], _ = t[i * 3 + 2], x2 = t[r5 * 3], g = t[r5 * 3 + 1], p4 = t[r5 * 3 + 2];
  return Math.abs(o4 - u5) < Math.abs(a4 - c) ? [new ot$1(a4, 1 - l), new ot$1(c, 1 - d), new ot$1(f, 1 - _), new ot$1(x2, 1 - p4)] : [new ot$1(o4, 1 - l), new ot$1(u5, 1 - d), new ot$1(m5, 1 - _), new ot$1(g, 1 - p4)];
}, "generateSideWallUV") };
function Zm$1(s5, t, e) {
  if (e.shapes = [], Array.isArray(s5)) for (let n4 = 0, i = s5.length; n4 < i; n4++) {
    let r5 = s5[n4];
    e.shapes.push(r5.uuid);
  }
  else e.shapes.push(s5.uuid);
  return e.options = Object.assign({}, t), t.extrudePath !== void 0 && (e.options.extrudePath = t.extrudePath.toJSON()), e;
}
H$3(Zm$1, "toJSON$1");
var ba$2 = class ba extends pe$3 {
  constructor(t = 1, e = 1, n4 = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n4, heightSegments: i };
    let r5 = t / 2, a4 = e / 2, o4 = Math.floor(n4), l = Math.floor(i), c = o4 + 1, u5 = l + 1, d = t / o4, f = e / l, m5 = [], _ = [], x2 = [], g = [];
    for (let p4 = 0; p4 < u5; p4++) {
      let w3 = p4 * f - a4;
      for (let b = 0; b < c; b++) {
        let y4 = b * d - r5;
        _.push(y4, -w3, 0), x2.push(0, 0, 1), g.push(b / o4), g.push(1 - p4 / l);
      }
    }
    for (let p4 = 0; p4 < l; p4++) for (let w3 = 0; w3 < o4; w3++) {
      let b = w3 + c * p4, y4 = w3 + c * (p4 + 1), D4 = w3 + 1 + c * (p4 + 1), C3 = w3 + 1 + c * p4;
      m5.push(b, y4, C3), m5.push(y4, D4, C3);
    }
    this.setIndex(m5), this.setAttribute("position", new re$4(_, 3)), this.setAttribute("normal", new re$4(x2, 3)), this.setAttribute("uv", new re$4(g, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new ba(t.width, t.height, t.widthSegments, t.heightSegments);
  }
};
H$3(ba$2, "PlaneGeometry");
var Os$2 = ba$2;
var Ea$1 = class Ea extends pe$3 {
  constructor(t = 1, e = 32, n4 = 16, i = 0, r5 = Math.PI * 2, a4 = 0, o4 = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n4, phiStart: i, phiLength: r5, thetaStart: a4, thetaLength: o4 }, e = Math.max(3, Math.floor(e)), n4 = Math.max(2, Math.floor(n4));
    let l = Math.min(a4 + o4, Math.PI), c = 0, u5 = [], d = new I$1(), f = new I$1(), m5 = [], _ = [], x2 = [], g = [];
    for (let p4 = 0; p4 <= n4; p4++) {
      let w3 = [], b = p4 / n4, y4 = 0;
      p4 === 0 && a4 === 0 ? y4 = 0.5 / e : p4 === n4 && l === Math.PI && (y4 = -0.5 / e);
      for (let D4 = 0; D4 <= e; D4++) {
        let C3 = D4 / e;
        d.x = -t * Math.cos(i + C3 * r5) * Math.sin(a4 + b * o4), d.y = t * Math.cos(a4 + b * o4), d.z = t * Math.sin(i + C3 * r5) * Math.sin(a4 + b * o4), _.push(d.x, d.y, d.z), f.copy(d).normalize(), x2.push(f.x, f.y, f.z), g.push(C3 + y4, 1 - b), w3.push(c++);
      }
      u5.push(w3);
    }
    for (let p4 = 0; p4 < n4; p4++) for (let w3 = 0; w3 < e; w3++) {
      let b = u5[p4][w3 + 1], y4 = u5[p4][w3], D4 = u5[p4 + 1][w3], C3 = u5[p4 + 1][w3 + 1];
      (p4 !== 0 || a4 > 0) && m5.push(b, y4, C3), (p4 !== n4 - 1 || l < Math.PI) && m5.push(y4, D4, C3);
    }
    this.setIndex(m5), this.setAttribute("position", new re$4(_, 3)), this.setAttribute("normal", new re$4(x2, 3)), this.setAttribute("uv", new re$4(g, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new Ea(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
  }
};
H$3(Ea$1, "SphereGeometry");
var Ta$2 = class Ta extends pe$3 {
  constructor(t = new Ps$2(new I$1(-1, -1, 0), new I$1(-1, 1, 0), new I$1(1, 1, 0)), e = 64, n4 = 1, i = 8, r5 = false) {
    super(), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n4, radialSegments: i, closed: r5 };
    let a4 = t.computeFrenetFrames(e, r5);
    this.tangents = a4.tangents, this.normals = a4.normals, this.binormals = a4.binormals;
    let o4 = new I$1(), l = new I$1(), c = new ot$1(), u5 = new I$1(), d = [], f = [], m5 = [], _ = [];
    x2(), this.setIndex(_), this.setAttribute("position", new re$4(d, 3)), this.setAttribute("normal", new re$4(f, 3)), this.setAttribute("uv", new re$4(m5, 2));
    function x2() {
      for (let b = 0; b < e; b++) g(b);
      g(r5 === false ? e : 0), w3(), p4();
    }
    H$3(x2, "generateBufferData");
    function g(b) {
      u5 = t.getPointAt(b / e, u5);
      let y4 = a4.normals[b], D4 = a4.binormals[b];
      for (let C3 = 0; C3 <= i; C3++) {
        let R3 = C3 / i * Math.PI * 2, L3 = Math.sin(R3), E4 = -Math.cos(R3);
        l.x = E4 * y4.x + L3 * D4.x, l.y = E4 * y4.y + L3 * D4.y, l.z = E4 * y4.z + L3 * D4.z, l.normalize(), f.push(l.x, l.y, l.z), o4.x = u5.x + n4 * l.x, o4.y = u5.y + n4 * l.y, o4.z = u5.z + n4 * l.z, d.push(o4.x, o4.y, o4.z);
      }
    }
    H$3(g, "generateSegment");
    function p4() {
      for (let b = 1; b <= e; b++) for (let y4 = 1; y4 <= i; y4++) {
        let D4 = (i + 1) * (b - 1) + (y4 - 1), C3 = (i + 1) * b + (y4 - 1), R3 = (i + 1) * b + y4, L3 = (i + 1) * (b - 1) + y4;
        _.push(D4, C3, L3), _.push(C3, R3, L3);
      }
    }
    H$3(p4, "generateIndices");
    function w3() {
      for (let b = 0; b <= e; b++) for (let y4 = 0; y4 <= i; y4++) c.x = b / e, c.y = y4 / i, m5.push(c.x, c.y);
    }
    H$3(w3, "generateUVs");
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.path = this.parameters.path.toJSON(), t;
  }
  static fromJSON(t) {
    return new Ta(new Qr$2[t.path.type]().fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed);
  }
};
H$3(Ta$2, "TubeGeometry");
var Cl$2 = Ta$2;
var Rh$2 = class Rh extends nn$2 {
  constructor(t) {
    super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new Ft$3(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ft$3(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _o$2, this.normalScale = new ot$1(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ze$1(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
};
H$3(Rh$2, "MeshStandardMaterial");
var ea$1 = Rh$2, Ih$2 = class Ih extends ea$1 {
  constructor(t) {
    super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ot$1(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: H$3(function() {
      return Gt$2(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, "get"), set: H$3(function(e) {
      this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
    }, "set") }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ft$3(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ft$3(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ft$3(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(t) {
    this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(t) {
    this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(t) {
    this._dispersion > 0 != t > 0 && this.version++, this._dispersion = t;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
};
H$3(Ih$2, "MeshPhysicalMaterial");
var Rl$1 = Ih$2;
var Ph$2 = class Ph extends nn$2 {
  constructor(t) {
    super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new Ft$3(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ft$3(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _o$2, this.normalScale = new ot$1(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ze$1(), this.combine = Ua$1, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
};
H$3(Ph$2, "MeshLambertMaterial");
var Il$2 = Ph$2, Dh$1 = class Dh extends nn$2 {
  constructor(t) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Sf$2, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }
};
H$3(Dh$1, "MeshDepthMaterial");
var na$1 = Dh$1, Lh$1 = class Lh extends nn$2 {
  constructor(t) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }
};
H$3(Lh$1, "MeshDistanceMaterial");
var ia$1 = Lh$1;
function Ir$2(s5, t, e) {
  return !s5 || !e && s5.constructor === t ? s5 : typeof t.BYTES_PER_ELEMENT == "number" ? new t(s5) : Array.prototype.slice.call(s5);
}
H$3(Ir$2, "convertArray");
function Jm$1(s5) {
  return ArrayBuffer.isView(s5) && !(s5 instanceof DataView);
}
H$3(Jm$1, "isTypedArray");
function $m$1(s5) {
  function t(i, r5) {
    return s5[i] - s5[r5];
  }
  H$3(t, "compareTime");
  let e = s5.length, n4 = new Array(e);
  for (let i = 0; i !== e; ++i) n4[i] = i;
  return n4.sort(t), n4;
}
H$3($m$1, "getKeyframeOrder");
function Ud$2(s5, t, e) {
  let n4 = s5.length, i = new s5.constructor(n4);
  for (let r5 = 0, a4 = 0; a4 !== n4; ++r5) {
    let o4 = e[r5] * t;
    for (let l = 0; l !== t; ++l) i[a4++] = s5[o4 + l];
  }
  return i;
}
H$3(Ud$2, "sortedArray");
function Vf$1(s5, t, e, n4) {
  let i = 1, r5 = s5[0];
  for (; r5 !== void 0 && r5[n4] === void 0; ) r5 = s5[i++];
  if (r5 === void 0) return;
  let a4 = r5[n4];
  if (a4 !== void 0) if (Array.isArray(a4)) do
    a4 = r5[n4], a4 !== void 0 && (t.push(r5.time), e.push.apply(e, a4)), r5 = s5[i++];
  while (r5 !== void 0);
  else if (a4.toArray !== void 0) do
    a4 = r5[n4], a4 !== void 0 && (t.push(r5.time), a4.toArray(e, e.length)), r5 = s5[i++];
  while (r5 !== void 0);
  else do
    a4 = r5[n4], a4 !== void 0 && (t.push(r5.time), e.push(a4)), r5 = s5[i++];
  while (r5 !== void 0);
}
H$3(Vf$1, "flattenJSON");
var Uh$2 = class Uh {
  constructor(t, e, n4, i) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new e.constructor(n4), this.sampleValues = e, this.valueSize = n4, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(t) {
    let e = this.parameterPositions, n4 = this._cachedIndex, i = e[n4], r5 = e[n4 - 1];
    n: {
      t: {
        let a4;
        e: {
          i: if (!(t < i)) {
            for (let o4 = n4 + 2; ; ) {
              if (i === void 0) {
                if (t < r5) break i;
                return n4 = e.length, this._cachedIndex = n4, this.copySampleValue_(n4 - 1);
              }
              if (n4 === o4) break;
              if (r5 = i, i = e[++n4], t < i) break t;
            }
            a4 = e.length;
            break e;
          }
          if (!(t >= r5)) {
            let o4 = e[1];
            t < o4 && (n4 = 2, r5 = o4);
            for (let l = n4 - 2; ; ) {
              if (r5 === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n4 === l) break;
              if (i = r5, r5 = e[--n4 - 1], t >= r5) break t;
            }
            a4 = n4, n4 = 0;
            break e;
          }
          break n;
        }
        for (; n4 < a4; ) {
          let o4 = n4 + a4 >>> 1;
          t < e[o4] ? a4 = o4 : n4 = o4 + 1;
        }
        if (i = e[n4], r5 = e[n4 - 1], r5 === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0) return n4 = e.length, this._cachedIndex = n4, this.copySampleValue_(n4 - 1);
      }
      this._cachedIndex = n4, this.intervalChanged_(n4, r5, i);
    }
    return this.interpolate_(n4, r5, t, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(t) {
    let e = this.resultBuffer, n4 = this.sampleValues, i = this.valueSize, r5 = t * i;
    for (let a4 = 0; a4 !== i; ++a4) e[a4] = n4[r5 + a4];
    return e;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
H$3(Uh$2, "Interpolant");
var ci$1 = Uh$2, Nh$1 = class Nh extends ci$1 {
  constructor(t, e, n4, i) {
    super(t, e, n4, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: al$2, endingEnd: al$2 };
  }
  intervalChanged_(t, e, n4) {
    let i = this.parameterPositions, r5 = t - 2, a4 = t + 1, o4 = i[r5], l = i[a4];
    if (o4 === void 0) switch (this.getSettings_().endingStart) {
      case ol$2:
        r5 = t, o4 = 2 * e - n4;
        break;
      case ll$2:
        r5 = i.length - 2, o4 = e + i[r5] - i[r5 + 1];
        break;
      default:
        r5 = t, o4 = n4;
    }
    if (l === void 0) switch (this.getSettings_().endingEnd) {
      case ol$2:
        a4 = t, l = 2 * n4 - e;
        break;
      case ll$2:
        a4 = 1, l = n4 + i[1] - i[0];
        break;
      default:
        a4 = t - 1, l = e;
    }
    let c = (n4 - e) * 0.5, u5 = this.valueSize;
    this._weightPrev = c / (e - o4), this._weightNext = c / (l - n4), this._offsetPrev = r5 * u5, this._offsetNext = a4 * u5;
  }
  interpolate_(t, e, n4, i) {
    let r5 = this.resultBuffer, a4 = this.sampleValues, o4 = this.valueSize, l = t * o4, c = l - o4, u5 = this._offsetPrev, d = this._offsetNext, f = this._weightPrev, m5 = this._weightNext, _ = (n4 - e) / (i - e), x2 = _ * _, g = x2 * _, p4 = -f * g + 2 * f * x2 - f * _, w3 = (1 + f) * g + (-1.5 - 2 * f) * x2 + (-0.5 + f) * _ + 1, b = (-1 - m5) * g + (1.5 + m5) * x2 + 0.5 * _, y4 = m5 * g - m5 * x2;
    for (let D4 = 0; D4 !== o4; ++D4) r5[D4] = p4 * a4[u5 + D4] + w3 * a4[c + D4] + b * a4[l + D4] + y4 * a4[d + D4];
    return r5;
  }
};
H$3(Nh$1, "CubicInterpolant");
var sa$2 = Nh$1, Fh$2 = class Fh extends ci$1 {
  constructor(t, e, n4, i) {
    super(t, e, n4, i);
  }
  interpolate_(t, e, n4, i) {
    let r5 = this.resultBuffer, a4 = this.sampleValues, o4 = this.valueSize, l = t * o4, c = l - o4, u5 = (n4 - e) / (i - e), d = 1 - u5;
    for (let f = 0; f !== o4; ++f) r5[f] = a4[c + f] * d + a4[l + f] * u5;
    return r5;
  }
};
H$3(Fh$2, "LinearInterpolant");
var ra$1 = Fh$2, Oh$1 = class Oh extends ci$1 {
  constructor(t, e, n4, i) {
    super(t, e, n4, i);
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1);
  }
};
H$3(Oh$1, "DiscreteInterpolant");
var aa$2 = Oh$1, Bh$2 = class Bh {
  constructor(t, e, n4, i) {
    if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = Ir$2(e, this.TimeBufferType), this.values = Ir$2(n4, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(t) {
    let e = t.constructor, n4;
    if (e.toJSON !== this.toJSON) n4 = e.toJSON(t);
    else {
      n4 = { name: t.name, times: Ir$2(t.times, Array), values: Ir$2(t.values, Array) };
      let i = t.getInterpolation();
      i !== t.DefaultInterpolation && (n4.interpolation = i);
    }
    return n4.type = t.ValueTypeName, n4;
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new aa$2(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodLinear(t) {
    return new ra$1(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodSmooth(t) {
    return new sa$2(this.times, this.values, this.getValueSize(), t);
  }
  setInterpolation(t) {
    let e;
    switch (t) {
      case ps$2:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case Fr$1:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case Pr$3:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      let n4 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
      else throw new Error(n4);
      return console.warn("THREE.KeyframeTrack:", n4), this;
    }
    return this.createInterpolant = e, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return ps$2;
      case this.InterpolantFactoryMethodLinear:
        return Fr$1;
      case this.InterpolantFactoryMethodSmooth:
        return Pr$3;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(t) {
    if (t !== 0) {
      let e = this.times;
      for (let n4 = 0, i = e.length; n4 !== i; ++n4) e[n4] += t;
    }
    return this;
  }
  scale(t) {
    if (t !== 1) {
      let e = this.times;
      for (let n4 = 0, i = e.length; n4 !== i; ++n4) e[n4] *= t;
    }
    return this;
  }
  trim(t, e) {
    let n4 = this.times, i = n4.length, r5 = 0, a4 = i - 1;
    for (; r5 !== i && n4[r5] < t; ) ++r5;
    for (; a4 !== -1 && n4[a4] > e; ) --a4;
    if (++a4, r5 !== 0 || a4 !== i) {
      r5 >= a4 && (a4 = Math.max(a4, 1), r5 = a4 - 1);
      let o4 = this.getValueSize();
      this.times = n4.slice(r5, a4), this.values = this.values.slice(r5 * o4, a4 * o4);
    }
    return this;
  }
  validate() {
    let t = true, e = this.getValueSize();
    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = false);
    let n4 = this.times, i = this.values, r5 = n4.length;
    r5 === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = false);
    let a4 = null;
    for (let o4 = 0; o4 !== r5; o4++) {
      let l = n4[o4];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o4, l), t = false;
        break;
      }
      if (a4 !== null && a4 > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o4, l, a4), t = false;
        break;
      }
      a4 = l;
    }
    if (i !== void 0 && Jm$1(i)) for (let o4 = 0, l = i.length; o4 !== l; ++o4) {
      let c = i[o4];
      if (isNaN(c)) {
        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o4, c), t = false;
        break;
      }
    }
    return t;
  }
  optimize() {
    let t = this.times.slice(), e = this.values.slice(), n4 = this.getValueSize(), i = this.getInterpolation() === Pr$3, r5 = t.length - 1, a4 = 1;
    for (let o4 = 1; o4 < r5; ++o4) {
      let l = false, c = t[o4], u5 = t[o4 + 1];
      if (c !== u5 && (o4 !== 1 || c !== t[0])) if (i) l = true;
      else {
        let d = o4 * n4, f = d - n4, m5 = d + n4;
        for (let _ = 0; _ !== n4; ++_) {
          let x2 = e[d + _];
          if (x2 !== e[f + _] || x2 !== e[m5 + _]) {
            l = true;
            break;
          }
        }
      }
      if (l) {
        if (o4 !== a4) {
          t[a4] = t[o4];
          let d = o4 * n4, f = a4 * n4;
          for (let m5 = 0; m5 !== n4; ++m5) e[f + m5] = e[d + m5];
        }
        ++a4;
      }
    }
    if (r5 > 0) {
      t[a4] = t[r5];
      for (let o4 = r5 * n4, l = a4 * n4, c = 0; c !== n4; ++c) e[l + c] = e[o4 + c];
      ++a4;
    }
    return a4 !== t.length ? (this.times = t.slice(0, a4), this.values = e.slice(0, a4 * n4)) : (this.times = t, this.values = e), this;
  }
  clone() {
    let t = this.times.slice(), e = this.values.slice(), n4 = this.constructor, i = new n4(this.name, t, e);
    return i.createInterpolant = this.createInterpolant, i;
  }
};
H$3(Bh$2, "KeyframeTrack");
var Ge$2 = Bh$2;
Ge$2.prototype.TimeBufferType = Float32Array;
Ge$2.prototype.ValueBufferType = Float32Array;
Ge$2.prototype.DefaultInterpolation = Fr$1;
var zh$2 = class zh extends Ge$2 {
  constructor(t, e, n4) {
    super(t, e, n4);
  }
};
H$3(zh$2, "BooleanKeyframeTrack");
var Tn$2 = zh$2;
Tn$2.prototype.ValueTypeName = "bool";
Tn$2.prototype.ValueBufferType = Array;
Tn$2.prototype.DefaultInterpolation = ps$2;
Tn$2.prototype.InterpolantFactoryMethodLinear = void 0;
Tn$2.prototype.InterpolantFactoryMethodSmooth = void 0;
var kh$1 = class kh extends Ge$2 {
};
H$3(kh$1, "ColorKeyframeTrack");
var Bs$2 = kh$1;
Bs$2.prototype.ValueTypeName = "color";
var Vh$1 = class Vh extends Ge$2 {
};
H$3(Vh$1, "NumberKeyframeTrack");
var hi$2 = Vh$1;
hi$2.prototype.ValueTypeName = "number";
var Hh$2 = class Hh extends ci$1 {
  constructor(t, e, n4, i) {
    super(t, e, n4, i);
  }
  interpolate_(t, e, n4, i) {
    let r5 = this.resultBuffer, a4 = this.sampleValues, o4 = this.valueSize, l = (n4 - e) / (i - e), c = t * o4;
    for (let u5 = c + o4; c !== u5; c += 4) En$1.slerpFlat(r5, 0, a4, c - o4, a4, c, l);
    return r5;
  }
};
H$3(Hh$2, "QuaternionLinearInterpolant");
var oa$1 = Hh$2, Gh$1 = class Gh extends Ge$2 {
  InterpolantFactoryMethodLinear(t) {
    return new oa$1(this.times, this.values, this.getValueSize(), t);
  }
};
H$3(Gh$1, "QuaternionKeyframeTrack");
var ui$2 = Gh$1;
ui$2.prototype.ValueTypeName = "quaternion";
ui$2.prototype.InterpolantFactoryMethodSmooth = void 0;
var Wh$2 = class Wh extends Ge$2 {
  constructor(t, e, n4) {
    super(t, e, n4);
  }
};
H$3(Wh$2, "StringKeyframeTrack");
var An$3 = Wh$2;
An$3.prototype.ValueTypeName = "string";
An$3.prototype.ValueBufferType = Array;
An$3.prototype.DefaultInterpolation = ps$2;
An$3.prototype.InterpolantFactoryMethodLinear = void 0;
An$3.prototype.InterpolantFactoryMethodSmooth = void 0;
var Xh$2 = class Xh extends Ge$2 {
};
H$3(Xh$2, "VectorKeyframeTrack");
var di = Xh$2;
di.prototype.ValueTypeName = "vector";
var qh$2 = class qh {
  constructor(t = "", e = -1, n4 = [], i = Mf$2) {
    this.name = t, this.tracks = n4, this.duration = e, this.blendMode = i, this.uuid = Ye(), this.duration < 0 && this.resetDuration();
  }
  static parse(t) {
    let e = [], n4 = t.tracks, i = 1 / (t.fps || 1);
    for (let a4 = 0, o4 = n4.length; a4 !== o4; ++a4) e.push(Qm$1(n4[a4]).scale(i));
    let r5 = new this(t.name, t.duration, e, t.blendMode);
    return r5.uuid = t.uuid, r5;
  }
  static toJSON(t) {
    let e = [], n4 = t.tracks, i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
    for (let r5 = 0, a4 = n4.length; r5 !== a4; ++r5) e.push(Ge$2.toJSON(n4[r5]));
    return i;
  }
  static CreateFromMorphTargetSequence(t, e, n4, i) {
    let r5 = e.length, a4 = [];
    for (let o4 = 0; o4 < r5; o4++) {
      let l = [], c = [];
      l.push((o4 + r5 - 1) % r5, o4, (o4 + 1) % r5), c.push(0, 1, 0);
      let u5 = $m$1(l);
      l = Ud$2(l, 1, u5), c = Ud$2(c, 1, u5), !i && l[0] === 0 && (l.push(r5), c.push(c[0])), a4.push(new hi$2(".morphTargetInfluences[" + e[o4].name + "]", l, c).scale(1 / n4));
    }
    return new this(t, -1, a4);
  }
  static findByName(t, e) {
    let n4 = t;
    if (!Array.isArray(t)) {
      let i = t;
      n4 = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < n4.length; i++) if (n4[i].name === e) return n4[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(t, e, n4) {
    let i = {}, r5 = /^([\w-]*?)([\d]+)$/;
    for (let o4 = 0, l = t.length; o4 < l; o4++) {
      let c = t[o4], u5 = c.name.match(r5);
      if (u5 && u5.length > 1) {
        let d = u5[1], f = i[d];
        f || (i[d] = f = []), f.push(c);
      }
    }
    let a4 = [];
    for (let o4 in i) a4.push(this.CreateFromMorphTargetSequence(o4, i[o4], e, n4));
    return a4;
  }
  static parseAnimation(t, e) {
    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    let n4 = H$3(function(d, f, m5, _, x2) {
      if (m5.length !== 0) {
        let g = [], p4 = [];
        Vf$1(m5, g, p4, _), g.length !== 0 && x2.push(new d(f, g, p4));
      }
    }, "addNonemptyTrack"), i = [], r5 = t.name || "default", a4 = t.fps || 30, o4 = t.blendMode, l = t.length || -1, c = t.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      let f = c[d].keys;
      if (!(!f || f.length === 0)) if (f[0].morphTargets) {
        let m5 = {}, _;
        for (_ = 0; _ < f.length; _++) if (f[_].morphTargets) for (let x2 = 0; x2 < f[_].morphTargets.length; x2++) m5[f[_].morphTargets[x2]] = -1;
        for (let x2 in m5) {
          let g = [], p4 = [];
          for (let w3 = 0; w3 !== f[_].morphTargets.length; ++w3) {
            let b = f[_];
            g.push(b.time), p4.push(b.morphTarget === x2 ? 1 : 0);
          }
          i.push(new hi$2(".morphTargetInfluence[" + x2 + "]", g, p4));
        }
        l = m5.length * a4;
      } else {
        let m5 = ".bones[" + e[d].name + "]";
        n4(di, m5 + ".position", f, "pos", i), n4(ui$2, m5 + ".quaternion", f, "rot", i), n4(di, m5 + ".scale", f, "scl", i);
      }
    }
    return i.length === 0 ? null : new this(r5, l, i, o4);
  }
  resetDuration() {
    let t = this.tracks, e = 0;
    for (let n4 = 0, i = t.length; n4 !== i; ++n4) {
      let r5 = this.tracks[n4];
      e = Math.max(e, r5.times[r5.times.length - 1]);
    }
    return this.duration = e, this;
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
    return this;
  }
  validate() {
    let t = true;
    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
    return t;
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
    return this;
  }
  clone() {
    let t = [];
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
    return new this.constructor(this.name, this.duration, t, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
H$3(qh$2, "AnimationClip");
var Pl$2 = qh$2;
function Km$1(s5) {
  switch (s5.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return hi$2;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return di;
    case "color":
      return Bs$2;
    case "quaternion":
      return ui$2;
    case "bool":
    case "boolean":
      return Tn$2;
    case "string":
      return An$3;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s5);
}
H$3(Km$1, "getTrackTypeForValueTypeName");
function Qm$1(s5) {
  if (s5.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  let t = Km$1(s5.type);
  if (s5.times === void 0) {
    let e = [], n4 = [];
    Vf$1(s5.keys, e, n4, "value"), s5.times = e, s5.values = n4;
  }
  return t.parse !== void 0 ? t.parse(s5) : new t(s5.name, s5.times, s5.values, s5.interpolation);
}
H$3(Qm$1, "parseKeyframeTrack");
var yn$1 = { enabled: false, files: {}, add: H$3(function(s5, t) {
  this.enabled !== false && (this.files[s5] = t);
}, "add"), get: H$3(function(s5) {
  if (this.enabled !== false) return this.files[s5];
}, "get"), remove: H$3(function(s5) {
  delete this.files[s5];
}, "remove"), clear: H$3(function() {
  this.files = {};
}, "clear") }, Yh$2 = class Yh {
  constructor(t, e, n4) {
    let i = this, r5 = false, a4 = 0, o4 = 0, l, c = [];
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n4, this.itemStart = function(u5) {
      o4++, r5 === false && i.onStart !== void 0 && i.onStart(u5, a4, o4), r5 = true;
    }, this.itemEnd = function(u5) {
      a4++, i.onProgress !== void 0 && i.onProgress(u5, a4, o4), a4 === o4 && (r5 = false, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(u5) {
      i.onError !== void 0 && i.onError(u5);
    }, this.resolveURL = function(u5) {
      return l ? l(u5) : u5;
    }, this.setURLModifier = function(u5) {
      return l = u5, this;
    }, this.addHandler = function(u5, d) {
      return c.push(u5, d), this;
    }, this.removeHandler = function(u5) {
      let d = c.indexOf(u5);
      return d !== -1 && c.splice(d, 2), this;
    }, this.getHandler = function(u5) {
      for (let d = 0, f = c.length; d < f; d += 2) {
        let m5 = c[d], _ = c[d + 1];
        if (m5.global && (m5.lastIndex = 0), m5.test(u5)) return _;
      }
      return null;
    };
  }
};
H$3(Yh$2, "LoadingManager");
var la$2 = Yh$2, Hf$1 = new la$2(), Zh$2 = class Zh {
  constructor(t) {
    this.manager = t !== void 0 ? t : Hf$1, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(t, e) {
    let n4 = this;
    return new Promise(function(i, r5) {
      n4.load(t, i, e, r5);
    });
  }
  parse() {
  }
  setCrossOrigin(t) {
    return this.crossOrigin = t, this;
  }
  setWithCredentials(t) {
    return this.withCredentials = t, this;
  }
  setPath(t) {
    return this.path = t, this;
  }
  setResourcePath(t) {
    return this.resourcePath = t, this;
  }
  setRequestHeader(t) {
    return this.requestHeader = t, this;
  }
};
H$3(Zh$2, "Loader");
var Gn$2 = Zh$2;
Gn$2.DEFAULT_MATERIAL_NAME = "__DEFAULT";
var xn$2 = {}, Jh$2 = class Jh extends Error {
  constructor(t, e) {
    super(t), this.response = e;
  }
};
H$3(Jh$2, "HttpError");
var Dl$1 = Jh$2, $h$2 = class $h extends Gn$2 {
  constructor(t) {
    super(t);
  }
  load(t, e, n4, i) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    let r5 = yn$1.get(t);
    if (r5 !== void 0) return this.manager.itemStart(t), setTimeout(() => {
      e && e(r5), this.manager.itemEnd(t);
    }, 0), r5;
    if (xn$2[t] !== void 0) {
      xn$2[t].push({ onLoad: e, onProgress: n4, onError: i });
      return;
    }
    xn$2[t] = [], xn$2[t].push({ onLoad: e, onProgress: n4, onError: i });
    let a4 = new Request(t, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o4 = this.mimeType, l = this.responseType;
    fetch(a4).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
        let u5 = xn$2[t], d = c.body.getReader(), f = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), m5 = f ? parseInt(f) : 0, _ = m5 !== 0, x2 = 0, g = new ReadableStream({ start(p4) {
          w3();
          function w3() {
            d.read().then(({ done: b, value: y4 }) => {
              if (b) p4.close();
              else {
                x2 += y4.byteLength;
                let D4 = new ProgressEvent("progress", { lengthComputable: _, loaded: x2, total: m5 });
                for (let C3 = 0, R3 = u5.length; C3 < R3; C3++) {
                  let L3 = u5[C3];
                  L3.onProgress && L3.onProgress(D4);
                }
                p4.enqueue(y4), w3();
              }
            }, (b) => {
              p4.error(b);
            });
          }
          H$3(w3, "readData");
        } });
        return new Response(g);
      } else throw new Dl$1('fetch for "'.concat(c.url, '" responded with ').concat(c.status, ": ").concat(c.statusText), c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((u5) => new DOMParser().parseFromString(u5, o4));
        case "json":
          return c.json();
        default:
          if (o4 === void 0) return c.text();
          {
            let d = /charset="?([^;"\s]*)"?/i.exec(o4), f = d && d[1] ? d[1].toLowerCase() : void 0, m5 = new TextDecoder(f);
            return c.arrayBuffer().then((_) => m5.decode(_));
          }
      }
    }).then((c) => {
      yn$1.add(t, c);
      let u5 = xn$2[t];
      delete xn$2[t];
      for (let d = 0, f = u5.length; d < f; d++) {
        let m5 = u5[d];
        m5.onLoad && m5.onLoad(c);
      }
    }).catch((c) => {
      let u5 = xn$2[t];
      if (u5 === void 0) throw this.manager.itemError(t), c;
      delete xn$2[t];
      for (let d = 0, f = u5.length; d < f; d++) {
        let m5 = u5[d];
        m5.onError && m5.onError(c);
      }
      this.manager.itemError(t);
    }).finally(() => {
      this.manager.itemEnd(t);
    }), this.manager.itemStart(t);
  }
  setResponseType(t) {
    return this.responseType = t, this;
  }
  setMimeType(t) {
    return this.mimeType = t, this;
  }
};
H$3($h$2, "FileLoader");
var Ll$1 = $h$2;
var Kh$2 = class Kh extends Gn$2 {
  constructor(t) {
    super(t);
  }
  load(t, e, n4, i) {
    this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    let r5 = this, a4 = yn$1.get(t);
    if (a4 !== void 0) return r5.manager.itemStart(t), setTimeout(function() {
      e && e(a4), r5.manager.itemEnd(t);
    }, 0), a4;
    let o4 = Gi$2("img");
    function l() {
      u5(), yn$1.add(t, this), e && e(this), r5.manager.itemEnd(t);
    }
    H$3(l, "onImageLoad");
    function c(d) {
      u5(), i && i(d), r5.manager.itemError(t), r5.manager.itemEnd(t);
    }
    H$3(c, "onImageError");
    function u5() {
      o4.removeEventListener("load", l, false), o4.removeEventListener("error", c, false);
    }
    return H$3(u5, "removeEventListeners"), o4.addEventListener("load", l, false), o4.addEventListener("error", c, false), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o4.crossOrigin = this.crossOrigin), r5.manager.itemStart(t), o4.src = t, o4;
  }
};
H$3(Kh$2, "ImageLoader");
var ca$2 = Kh$2;
var Qh$2 = class Qh extends Gn$2 {
  constructor(t) {
    super(t);
  }
  load(t, e, n4, i) {
    let r5 = new we$2(), a4 = new ca$2(this.manager);
    return a4.setCrossOrigin(this.crossOrigin), a4.setPath(this.path), a4.load(t, function(o4) {
      r5.image = o4, r5.needsUpdate = true, e !== void 0 && e(r5);
    }, n4, i), r5;
  }
};
H$3(Qh$2, "TextureLoader");
var Ul = Qh$2, jh$1 = class jh extends fe$2 {
  constructor(t, e = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new Ft$3(t), this.intensity = e;
  }
  dispose() {
  }
  copy(t, e) {
    return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
  }
  toJSON(t) {
    let e = super.toJSON(t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (e.object.target = this.target.uuid), e;
  }
};
H$3(jh$1, "Light");
var fi$2 = jh$1;
var il$2 = new Vt$2(), Nd$2 = new I$1(), Fd$2 = new I$1(), tu$2 = class tu {
  constructor(t) {
    this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ot$1(512, 512), this.map = null, this.mapPass = null, this.matrix = new Vt$2(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new oi$1(), this._frameExtents = new ot$1(1, 1), this._viewportCount = 1, this._viewports = [new $t$3(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    let e = this.camera, n4 = this.matrix;
    Nd$2.setFromMatrixPosition(t.matrixWorld), e.position.copy(Nd$2), Fd$2.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Fd$2), e.updateMatrixWorld(), il$2.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(il$2), n4.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n4.multiply(il$2);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    let t = {};
    return this.intensity !== 1 && (t.intensity = this.intensity), this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
  }
};
H$3(tu$2, "LightShadow");
var zs$2 = tu$2, eu$2 = class eu extends zs$2 {
  constructor() {
    super(new Te$1(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
  }
  updateMatrices(t) {
    let e = this.camera, n4 = ai$1 * 2 * t.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r5 = t.distance || e.far;
    (n4 !== e.fov || i !== e.aspect || r5 !== e.far) && (e.fov = n4, e.aspect = i, e.far = r5, e.updateProjectionMatrix()), super.updateMatrices(t);
  }
  copy(t) {
    return super.copy(t), this.focus = t.focus, this;
  }
};
H$3(eu$2, "SpotLightShadow");
var Nl = eu$2, nu$2 = class nu extends fi$2 {
  constructor(t, e, n4 = 0, i = Math.PI / 3, r5 = 0, a4 = 2) {
    super(t, e), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(fe$2.DEFAULT_UP), this.updateMatrix(), this.target = new fe$2(), this.distance = n4, this.angle = i, this.penumbra = r5, this.decay = a4, this.map = null, this.shadow = new Nl();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(t) {
    this.intensity = t / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
};
H$3(nu$2, "SpotLight");
var Fl$1 = nu$2, Od$2 = new Vt$2(), cs$2 = new I$1(), sl$2 = new I$1(), iu$2 = class iu extends zs$2 {
  constructor() {
    super(new Te$1(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new ot$1(4, 2), this._viewportCount = 6, this._viewports = [new $t$3(2, 1, 1, 1), new $t$3(0, 1, 1, 1), new $t$3(3, 1, 1, 1), new $t$3(1, 1, 1, 1), new $t$3(3, 0, 1, 1), new $t$3(1, 0, 1, 1)], this._cubeDirections = [new I$1(1, 0, 0), new I$1(-1, 0, 0), new I$1(0, 0, 1), new I$1(0, 0, -1), new I$1(0, 1, 0), new I$1(0, -1, 0)], this._cubeUps = [new I$1(0, 1, 0), new I$1(0, 1, 0), new I$1(0, 1, 0), new I$1(0, 1, 0), new I$1(0, 0, 1), new I$1(0, 0, -1)];
  }
  updateMatrices(t, e = 0) {
    let n4 = this.camera, i = this.matrix, r5 = t.distance || n4.far;
    r5 !== n4.far && (n4.far = r5, n4.updateProjectionMatrix()), cs$2.setFromMatrixPosition(t.matrixWorld), n4.position.copy(cs$2), sl$2.copy(n4.position), sl$2.add(this._cubeDirections[e]), n4.up.copy(this._cubeUps[e]), n4.lookAt(sl$2), n4.updateMatrixWorld(), i.makeTranslation(-cs$2.x, -cs$2.y, -cs$2.z), Od$2.multiplyMatrices(n4.projectionMatrix, n4.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Od$2);
  }
};
H$3(iu$2, "PointLightShadow");
var Ol$1 = iu$2, su$2 = class su extends fi$2 {
  constructor(t, e, n4 = 0, i = 2) {
    super(t, e), this.isPointLight = true, this.type = "PointLight", this.distance = n4, this.decay = i, this.shadow = new Ol$1();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t, e) {
    return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
  }
};
H$3(su$2, "PointLight");
var Bl$1 = su$2, ru$2 = class ru extends Ss$1 {
  constructor(t = -1, e = 1, n4 = 1, i = -1, r5 = 0.1, a4 = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n4, this.bottom = i, this.near = r5, this.far = a4, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  }
  setViewOffset(t, e, n4, i, r5, a4) {
    this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n4, this.view.offsetY = i, this.view.width = r5, this.view.height = a4, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    let t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n4 = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2, r5 = n4 - t, a4 = n4 + t, o4 = i + e, l = i - e;
    if (this.view !== null && this.view.enabled) {
      let c = (this.right - this.left) / this.view.fullWidth / this.zoom, u5 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r5 += c * this.view.offsetX, a4 = r5 + c * this.view.width, o4 -= u5 * this.view.offsetY, l = o4 - u5 * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r5, a4, o4, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    let e = super.toJSON(t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
};
H$3(ru$2, "OrthographicCamera");
var ks$2 = ru$2, au$2 = class au extends zs$2 {
  constructor() {
    super(new ks$2(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
  }
};
H$3(au$2, "DirectionalLightShadow");
var zl$1 = au$2, ou$2 = class ou extends fi$2 {
  constructor(t, e) {
    super(t, e), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(fe$2.DEFAULT_UP), this.updateMatrix(), this.target = new fe$2(), this.shadow = new zl$1();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
};
H$3(ou$2, "DirectionalLight");
var kl$1 = ou$2, lu$2 = class lu extends fi$2 {
  constructor(t, e) {
    super(t, e), this.isAmbientLight = true, this.type = "AmbientLight";
  }
};
H$3(lu$2, "AmbientLight");
var Vl = lu$2;
var cu$2 = class cu {
  static decodeText(t) {
    if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u") return new TextDecoder().decode(t);
    let e = "";
    for (let n4 = 0, i = t.length; n4 < i; n4++) e += String.fromCharCode(t[n4]);
    try {
      return decodeURIComponent(escape(e));
    } catch (n4) {
      return e;
    }
  }
  static extractUrlBase(t) {
    let e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.slice(0, e + 1);
  }
  static resolveURL(t, e) {
    return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
  }
};
H$3(cu$2, "LoaderUtils");
var Hl$1 = cu$2, hu$1 = class hu extends pe$3 {
  constructor() {
    super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(t) {
    return super.copy(t), this.instanceCount = t.instanceCount, this;
  }
  toJSON() {
    let t = super.toJSON();
    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = true, t;
  }
};
H$3(hu$1, "InstancedBufferGeometry");
var Gl = hu$1;
var uu$2 = class uu extends Gn$2 {
  constructor(t) {
    super(t), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(t) {
    return this.options = t, this;
  }
  load(t, e, n4, i) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    let r5 = this, a4 = yn$1.get(t);
    if (a4 !== void 0) {
      if (r5.manager.itemStart(t), a4.then) {
        a4.then((c) => {
          e && e(c), r5.manager.itemEnd(t);
        }).catch((c) => {
          i && i(c);
        });
        return;
      }
      return setTimeout(function() {
        e && e(a4), r5.manager.itemEnd(t);
      }, 0), a4;
    }
    let o4 = {};
    o4.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o4.headers = this.requestHeader;
    let l = fetch(t, o4).then(function(c) {
      return c.blob();
    }).then(function(c) {
      return createImageBitmap(c, Object.assign(r5.options, { colorSpaceConversion: "none" }));
    }).then(function(c) {
      return yn$1.add(t, c), e && e(c), r5.manager.itemEnd(t), c;
    }).catch(function(c) {
      i && i(c), yn$1.remove(t), r5.manager.itemError(t), r5.manager.itemEnd(t);
    });
    yn$1.add(t, l), r5.manager.itemStart(t);
  }
};
H$3(uu$2, "ImageBitmapLoader");
var Wl$1 = uu$2;
var du$2 = class du extends Te$1 {
  constructor(t = []) {
    super(), this.isArrayCamera = true, this.cameras = t, this.index = 0;
  }
};
H$3(du$2, "ArrayCamera");
var ha$2 = du$2, fu$1 = class fu {
  constructor(t = true) {
    this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
  }
  start() {
    this.startTime = Bd$2(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
  }
  stop() {
    this.getElapsedTime(), this.running = false, this.autoStart = false;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      let e = Bd$2();
      t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
    }
    return t;
  }
};
H$3(fu$1, "Clock");
var Xl = fu$1;
function Bd$2() {
  return performance.now();
}
H$3(Bd$2, "now");
var xc$2 = "\\[\\]\\.:\\/", jm$2 = new RegExp("[" + xc$2 + "]", "g"), vc$2 = "[^" + xc$2 + "]", tg$1 = "[^" + xc$2.replace("\\.", "") + "]", eg$1 = /((?:WC+[\/:])*)/.source.replace("WC", vc$2), ng$1 = /(WCOD+)?/.source.replace("WCOD", tg$1), ig$1 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", vc$2), sg$1 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", vc$2), rg$1 = new RegExp("^" + eg$1 + ng$1 + ig$1 + sg$1 + "$"), ag$1 = ["material", "materials", "bones", "map"], pu$2 = class pu {
  constructor(t, e, n4) {
    let i = n4 || ae$2.parseTrackName(e);
    this._targetGroup = t, this._bindings = t.subscribe_(e, i);
  }
  getValue(t, e) {
    this.bind();
    let n4 = this._targetGroup.nCachedObjects_, i = this._bindings[n4];
    i !== void 0 && i.getValue(t, e);
  }
  setValue(t, e) {
    let n4 = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r5 = n4.length; i !== r5; ++i) n4[i].setValue(t, e);
  }
  bind() {
    let t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n4 = t.length; e !== n4; ++e) t[e].bind();
  }
  unbind() {
    let t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n4 = t.length; e !== n4; ++e) t[e].unbind();
  }
};
H$3(pu$2, "Composite");
var ql$2 = pu$2, Bn$2 = class Bn {
  constructor(t, e, n4) {
    this.path = e, this.parsedPath = n4 || Bn.parseTrackName(e), this.node = Bn.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(t, e, n4) {
    return t && t.isAnimationObjectGroup ? new Bn.Composite(t, e, n4) : new Bn(t, e, n4);
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, "_").replace(jm$2, "");
  }
  static parseTrackName(t) {
    let e = rg$1.exec(t);
    if (e === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    let n4 = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, i = n4.nodeName && n4.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      let r5 = n4.nodeName.substring(i + 1);
      ag$1.indexOf(r5) !== -1 && (n4.nodeName = n4.nodeName.substring(0, i), n4.objectName = r5);
    }
    if (n4.propertyName === null || n4.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return n4;
  }
  static findNode(t, e) {
    if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid) return t;
    if (t.skeleton) {
      let n4 = t.skeleton.getBoneByName(e);
      if (n4 !== void 0) return n4;
    }
    if (t.children) {
      let n4 = H$3(function(r5) {
        for (let a4 = 0; a4 < r5.length; a4++) {
          let o4 = r5[a4];
          if (o4.name === e || o4.uuid === e) return o4;
          let l = n4(o4.children);
          if (l) return l;
        }
        return null;
      }, "searchNodeSubtree"), i = n4(t.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName];
  }
  _getValue_array(t, e) {
    let n4 = this.resolvedProperty;
    for (let i = 0, r5 = n4.length; i !== r5; ++i) t[e++] = n4[i];
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e);
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e];
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(t, e) {
    let n4 = this.resolvedProperty;
    for (let i = 0, r5 = n4.length; i !== r5; ++i) n4[i] = t[e++];
  }
  _setValue_array_setNeedsUpdate(t, e) {
    let n4 = this.resolvedProperty;
    for (let i = 0, r5 = n4.length; i !== r5; ++i) n4[i] = t[e++];
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    let n4 = this.resolvedProperty;
    for (let i = 0, r5 = n4.length; i !== r5; ++i) n4[i] = t[e++];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e];
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e);
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e);
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e);
  }
  bind() {
    let t = this.node, e = this.parsedPath, n4 = e.objectName, i = e.propertyName, r5 = e.propertyIndex;
    if (t || (t = Bn.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n4) {
      let c = e.objectIndex;
      switch (n4) {
        case "materials":
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          t = t.skeleton.bones;
          for (let u5 = 0; u5 < t.length; u5++) if (t[u5].name === c) {
            c = u5;
            break;
          }
          break;
        case "map":
          if ("map" in t) {
            t = t.map;
            break;
          }
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          t = t.material.map;
          break;
        default:
          if (t[n4] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          t = t[n4];
      }
      if (c !== void 0) {
        if (t[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          return;
        }
        t = t[c];
      }
    }
    let a4 = t[i];
    if (a4 === void 0) {
      let c = e.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", t);
      return;
    }
    let o4 = this.Versioning.None;
    this.targetObject = t, t.isMaterial === true ? o4 = this.Versioning.NeedsUpdate : t.isObject3D === true && (o4 = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r5 !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!t.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        t.morphTargetDictionary[r5] !== void 0 && (r5 = t.morphTargetDictionary[r5]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = a4, this.propertyIndex = r5;
    } else a4.fromArray !== void 0 && a4.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a4) : Array.isArray(a4) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a4) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o4];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
};
H$3(Bn$2, "PropertyBinding");
var ae$2 = Bn$2;
ae$2.Composite = ql$2;
ae$2.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
ae$2.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
ae$2.prototype.GetterByBindingType = [ae$2.prototype._getValue_direct, ae$2.prototype._getValue_array, ae$2.prototype._getValue_arrayElement, ae$2.prototype._getValue_toArray];
ae$2.prototype.SetterByBindingTypeAndVersioning = [[ae$2.prototype._setValue_direct, ae$2.prototype._setValue_direct_setNeedsUpdate, ae$2.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ae$2.prototype._setValue_array, ae$2.prototype._setValue_array_setNeedsUpdate, ae$2.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ae$2.prototype._setValue_arrayElement, ae$2.prototype._setValue_arrayElement_setNeedsUpdate, ae$2.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ae$2.prototype._setValue_fromArray, ae$2.prototype._setValue_fromArray_setNeedsUpdate, ae$2.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
var zd$1 = new Vt$2(), mu$1 = class mu {
  constructor(t, e, n4 = 0, i = 1 / 0) {
    this.ray = new Hn$1(t, e), this.near = n4, this.far = i, this.camera = null, this.layers = new Wi$2(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(t, e) {
    this.ray.set(t, e);
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  }
  setFromXRController(t) {
    return zd$1.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(zd$1), this;
  }
  intersectObject(t, e = true, n4 = []) {
    return Zl$2(t, this, n4, e), n4.sort(kd$2), n4;
  }
  intersectObjects(t, e = true, n4 = []) {
    for (let i = 0, r5 = t.length; i < r5; i++) Zl$2(t[i], this, n4, e);
    return n4.sort(kd$2), n4;
  }
};
H$3(mu$1, "Raycaster");
var Yl$2 = mu$1;
function kd$2(s5, t) {
  return s5.distance - t.distance;
}
H$3(kd$2, "ascSort");
function Zl$2(s5, t, e, n4) {
  let i = true;
  if (s5.layers.test(t.layers) && s5.raycast(t, e) === false && (i = false), i === true && n4 === true) {
    let r5 = s5.children;
    for (let a4 = 0, o4 = r5.length; a4 < o4; a4++) Zl$2(r5[a4], t, e, true);
  }
}
H$3(Zl$2, "intersect");
var Vd$2 = new ot$1(), gu$1 = class gu {
  constructor(t = new ot$1(1 / 0, 1 / 0), e = new ot$1(-1 / 0, -1 / 0)) {
    this.isBox2 = true, this.min = t, this.max = e;
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n4 = t.length; e < n4; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    let n4 = Vd$2.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n4), this.max.copy(t).add(n4), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  containsPoint(t) {
    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y;
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
  }
  getParameter(t, e) {
    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(t) {
    return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y;
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, Vd$2).distanceTo(t);
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
};
H$3(gu$1, "Box2");
var Jl$2 = gu$1;
var _u$2 = class _u extends qr {
  constructor(t = 1) {
    let e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], n4 = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], i = new pe$3();
    i.setAttribute("position", new re$4(e, 3)), i.setAttribute("color", new re$4(n4, 3));
    let r5 = new Ts$2({ vertexColors: true, toneMapped: false });
    super(i, r5), this.type = "AxesHelper";
  }
  setColors(t, e, n4) {
    let i = new Ft$3(), r5 = this.geometry.attributes.color.array;
    return i.set(t), i.toArray(r5, 0), i.toArray(r5, 3), i.set(e), i.toArray(r5, 6), i.toArray(r5, 9), i.set(n4), i.toArray(r5, 12), i.toArray(r5, 15), this.geometry.attributes.color.needsUpdate = true, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
H$3(_u$2, "AxesHelper");
function yc$2(s5, t, e, n4) {
  let i = og$1(n4);
  switch (e) {
    case ac$1:
      return s5 * t;
    case lc$1:
      return s5 * t;
    case cc$1:
      return s5 * t * 2;
    case Va$1:
      return s5 * t / i.components * i.byteLength;
    case Gs$2:
      return s5 * t / i.components * i.byteLength;
    case hc$2:
      return s5 * t * 2 / i.components * i.byteLength;
    case Ha$1:
      return s5 * t * 2 / i.components * i.byteLength;
    case oc$1:
      return s5 * t * 3 / i.components * i.byteLength;
    case De$3:
      return s5 * t * 4 / i.components * i.byteLength;
    case Ga$1:
      return s5 * t * 4 / i.components * i.byteLength;
    case Ws$1:
    case Xs$1:
      return Math.floor((s5 + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case qs$1:
    case Ys$1:
      return Math.floor((s5 + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case Xa$1:
    case Ya$1:
      return Math.max(s5, 16) * Math.max(t, 8) / 4;
    case Wa$1:
    case qa$2:
      return Math.max(s5, 8) * Math.max(t, 8) / 2;
    case Za$2:
    case Ja$1:
      return Math.floor((s5 + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case $a$1:
      return Math.floor((s5 + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case Ka$2:
      return Math.floor((s5 + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case Qa$2:
      return Math.floor((s5 + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case ja$1:
      return Math.floor((s5 + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case to$1:
      return Math.floor((s5 + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case eo$1:
      return Math.floor((s5 + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case no$1:
      return Math.floor((s5 + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case io$1:
      return Math.floor((s5 + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case so$1:
      return Math.floor((s5 + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case ro$1:
      return Math.floor((s5 + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case ao$2:
      return Math.floor((s5 + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case oo$1:
      return Math.floor((s5 + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case lo$2:
      return Math.floor((s5 + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case co$1:
      return Math.floor((s5 + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case ho$1:
      return Math.floor((s5 + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case Zs$1:
    case uo$2:
    case fo$1:
      return Math.ceil(s5 / 4) * Math.ceil(t / 4) * 16;
    case uc$1:
    case po$1:
      return Math.ceil(s5 / 4) * Math.ceil(t / 4) * 8;
    case mo$1:
    case go$1:
      return Math.ceil(s5 / 4) * Math.ceil(t / 4) * 16;
  }
  throw new Error("Unable to determine texture byte length for ".concat(e, " format."));
}
H$3(yc$2, "getByteLength");
function og$1(s5) {
  switch (s5) {
    case hn:
    case ic$1:
      return { byteLength: 1, components: 1 };
    case Zi$2:
    case sc$1:
    case Ji$1:
      return { byteLength: 2, components: 1 };
    case za$1:
    case ka$1:
      return { byteLength: 2, components: 4 };
    case Rn$1:
    case Ba$1:
    case Oe$1:
      return { byteLength: 4, components: 1 };
    case rc$1:
      return { byteLength: 4, components: 3 };
  }
  throw new Error("Unknown texture type ".concat(s5, "."));
}
H$3(og$1, "getTextureTypeByteLength");
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: Aa$1 } }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Aa$1);
a();
function fp$1() {
  let s5 = null, t = false, e = null, n4 = null;
  function i(r5, a4) {
    e(r5, a4), n4 = s5.requestAnimationFrame(i);
  }
  return H$3(i, "onAnimationFrame"), { start: H$3(function() {
    t !== true && e !== null && (n4 = s5.requestAnimationFrame(i), t = true);
  }, "start"), stop: H$3(function() {
    s5.cancelAnimationFrame(n4), t = false;
  }, "stop"), setAnimationLoop: H$3(function(r5) {
    e = r5;
  }, "setAnimationLoop"), setContext: H$3(function(r5) {
    s5 = r5;
  }, "setContext") };
}
H$3(fp$1, "WebGLAnimation");
function lg$1(s5) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(o4, l) {
    let c = o4.array, u5 = o4.usage, d = c.byteLength, f = s5.createBuffer();
    s5.bindBuffer(l, f), s5.bufferData(l, c, u5), o4.onUploadCallback();
    let m5;
    if (c instanceof Float32Array) m5 = s5.FLOAT;
    else if (c instanceof Uint16Array) o4.isFloat16BufferAttribute ? m5 = s5.HALF_FLOAT : m5 = s5.UNSIGNED_SHORT;
    else if (c instanceof Int16Array) m5 = s5.SHORT;
    else if (c instanceof Uint32Array) m5 = s5.UNSIGNED_INT;
    else if (c instanceof Int32Array) m5 = s5.INT;
    else if (c instanceof Int8Array) m5 = s5.BYTE;
    else if (c instanceof Uint8Array) m5 = s5.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) m5 = s5.UNSIGNED_BYTE;
    else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
    return { buffer: f, type: m5, bytesPerElement: c.BYTES_PER_ELEMENT, version: o4.version, size: d };
  }
  H$3(e, "createBuffer");
  function n4(o4, l, c) {
    let u5 = l.array, d = l.updateRanges;
    if (s5.bindBuffer(c, o4), d.length === 0) s5.bufferSubData(c, 0, u5);
    else {
      d.sort((m5, _) => m5.start - _.start);
      let f = 0;
      for (let m5 = 1; m5 < d.length; m5++) {
        let _ = d[f], x2 = d[m5];
        x2.start <= _.start + _.count + 1 ? _.count = Math.max(_.count, x2.start + x2.count - _.start) : (++f, d[f] = x2);
      }
      d.length = f + 1;
      for (let m5 = 0, _ = d.length; m5 < _; m5++) {
        let x2 = d[m5];
        s5.bufferSubData(c, x2.start * u5.BYTES_PER_ELEMENT, u5, x2.start, x2.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  H$3(n4, "updateBuffer");
  function i(o4) {
    return o4.isInterleavedBufferAttribute && (o4 = o4.data), t.get(o4);
  }
  H$3(i, "get");
  function r5(o4) {
    o4.isInterleavedBufferAttribute && (o4 = o4.data);
    let l = t.get(o4);
    l && (s5.deleteBuffer(l.buffer), t.delete(o4));
  }
  H$3(r5, "remove");
  function a4(o4, l) {
    if (o4.isInterleavedBufferAttribute && (o4 = o4.data), o4.isGLBufferAttribute) {
      let u5 = t.get(o4);
      (!u5 || u5.version < o4.version) && t.set(o4, { buffer: o4.buffer, type: o4.type, bytesPerElement: o4.elementSize, version: o4.version });
      return;
    }
    let c = t.get(o4);
    if (c === void 0) t.set(o4, e(o4, l));
    else if (c.version < o4.version) {
      if (c.size !== o4.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n4(c.buffer, o4, l), c.version = o4.version;
    }
  }
  return H$3(a4, "update"), { get: i, remove: r5, update: a4 };
}
H$3(lg$1, "WebGLAttributes");
var cg$1 = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif", hg$1 = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif", ug$1 = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif", dg$1 = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", fg$1 = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif", pg$1 = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", mg$1 = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", gg$1 = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", _g$1 = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif", xg$2 = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif", vg$2 = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif", yg$1 = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", Mg$1 = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated", Sg$2 = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif", bg$1 = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", Eg$2 = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif", Tg$1 = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", Ag$2 = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", wg$1 = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", Cg$1 = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", Rg$2 = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", Ig$1 = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif", Pg$1 = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif", Dg$2 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated", Lg$2 = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", Ug$2 = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", Ng$2 = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", Fg$2 = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif", Og$2 = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", Bg$2 = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", zg$2 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", kg$2 = "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", Vg$2 = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", Hg$2 = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", Gg$2 = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", Wg$2 = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", Xg$2 = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", qg$2 = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", Yg$2 = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", Zg$2 = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", Jg$2 = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", $g$2 = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}", Kg$2 = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", Qg$2 = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", jg$2 = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert", t_$1 = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", e_$1 = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif", n_$1 = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", i_$1 = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon", s_$1 = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", r_$1 = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong", a_$1 = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif", o_$1 = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", l_$1 = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", c_$1 = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", h_$1 = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif", u_$1 = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", d_$2 = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", f_$1 = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", p_$1 = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif", m_$2 = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif", g_$2 = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", __$1 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", x_$1 = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", v_$1 = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", y_$1 = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", M_$1 = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif", S_$1 = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", b_$2 = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif", E_$1 = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif", T_$1 = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif", A_$1 = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;", w_$1 = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", C_$1 = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", R_$1 = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", I_$1 = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", P_$1 = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif", D_$2 = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif", L_$1 = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif", U_$1 = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif", N_$1 = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif", F_$1 = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", O_$2 = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}", B_$2 = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", z_$1 = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", k_$1 = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", V_$1 = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", H_$1 = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", G_$1 = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", W_$1 = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif", X_$2 = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", q_$1 = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif", Y_$2 = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", Z_$2 = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", J_$2 = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif", $_$2 = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", K_$2 = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", Q_$2 = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", j_$1 = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", t0$2 = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", e0$1 = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", n0$2 = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif", i0$2 = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif", s0$2 = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", r0$2 = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", a0$2 = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif", o0$2 = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", l0$2 = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", c0$2 = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", h0$2 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", u0$2 = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", d0$2 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", f0$2 = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", p0$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", m0$2 = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}", g0$2 = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", _0$2 = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", x0$2 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", v0$2 = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", y0$2 = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", M0 = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", S0$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", b0$2 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", E0$1 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", T0 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", A0 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", w0$1 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", C0$2 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", R0$1 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", I0$1 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", P0 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", D0 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", L0$1 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", U0$1 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", N0$1 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", F0$1 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", O0$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", B0$1 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", z0$1 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}", k0$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", V0$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}", Ht$2 = { alphahash_fragment: cg$1, alphahash_pars_fragment: hg$1, alphamap_fragment: ug$1, alphamap_pars_fragment: dg$1, alphatest_fragment: fg$1, alphatest_pars_fragment: pg$1, aomap_fragment: mg$1, aomap_pars_fragment: gg$1, batching_pars_vertex: _g$1, batching_vertex: xg$2, begin_vertex: vg$2, beginnormal_vertex: yg$1, bsdfs: Mg$1, iridescence_fragment: Sg$2, bumpmap_pars_fragment: bg$1, clipping_planes_fragment: Eg$2, clipping_planes_pars_fragment: Tg$1, clipping_planes_pars_vertex: Ag$2, clipping_planes_vertex: wg$1, color_fragment: Cg$1, color_pars_fragment: Rg$2, color_pars_vertex: Ig$1, color_vertex: Pg$1, common: Dg$2, cube_uv_reflection_fragment: Lg$2, defaultnormal_vertex: Ug$2, displacementmap_pars_vertex: Ng$2, displacementmap_vertex: Fg$2, emissivemap_fragment: Og$2, emissivemap_pars_fragment: Bg$2, colorspace_fragment: zg$2, colorspace_pars_fragment: kg$2, envmap_fragment: Vg$2, envmap_common_pars_fragment: Hg$2, envmap_pars_fragment: Gg$2, envmap_pars_vertex: Wg$2, envmap_physical_pars_fragment: e_$1, envmap_vertex: Xg$2, fog_vertex: qg$2, fog_pars_vertex: Yg$2, fog_fragment: Zg$2, fog_pars_fragment: Jg$2, gradientmap_pars_fragment: $g$2, lightmap_pars_fragment: Kg$2, lights_lambert_fragment: Qg$2, lights_lambert_pars_fragment: jg$2, lights_pars_begin: t_$1, lights_toon_fragment: n_$1, lights_toon_pars_fragment: i_$1, lights_phong_fragment: s_$1, lights_phong_pars_fragment: r_$1, lights_physical_fragment: a_$1, lights_physical_pars_fragment: o_$1, lights_fragment_begin: l_$1, lights_fragment_maps: c_$1, lights_fragment_end: h_$1, logdepthbuf_fragment: u_$1, logdepthbuf_pars_fragment: d_$2, logdepthbuf_pars_vertex: f_$1, logdepthbuf_vertex: p_$1, map_fragment: m_$2, map_pars_fragment: g_$2, map_particle_fragment: __$1, map_particle_pars_fragment: x_$1, metalnessmap_fragment: v_$1, metalnessmap_pars_fragment: y_$1, morphinstance_vertex: M_$1, morphcolor_vertex: S_$1, morphnormal_vertex: b_$2, morphtarget_pars_vertex: E_$1, morphtarget_vertex: T_$1, normal_fragment_begin: A_$1, normal_fragment_maps: w_$1, normal_pars_fragment: C_$1, normal_pars_vertex: R_$1, normal_vertex: I_$1, normalmap_pars_fragment: P_$1, clearcoat_normal_fragment_begin: D_$2, clearcoat_normal_fragment_maps: L_$1, clearcoat_pars_fragment: U_$1, iridescence_pars_fragment: N_$1, opaque_fragment: F_$1, packing: O_$2, premultiplied_alpha_fragment: B_$2, project_vertex: z_$1, dithering_fragment: k_$1, dithering_pars_fragment: V_$1, roughnessmap_fragment: H_$1, roughnessmap_pars_fragment: G_$1, shadowmap_pars_fragment: W_$1, shadowmap_pars_vertex: X_$2, shadowmap_vertex: q_$1, shadowmask_pars_fragment: Y_$2, skinbase_vertex: Z_$2, skinning_pars_vertex: J_$2, skinning_vertex: $_$2, skinnormal_vertex: K_$2, specularmap_fragment: Q_$2, specularmap_pars_fragment: j_$1, tonemapping_fragment: t0$2, tonemapping_pars_fragment: e0$1, transmission_fragment: n0$2, transmission_pars_fragment: i0$2, uv_pars_fragment: s0$2, uv_pars_vertex: r0$2, uv_vertex: a0$2, worldpos_vertex: o0$2, background_vert: l0$2, background_frag: c0$2, backgroundCube_vert: h0$2, backgroundCube_frag: u0$2, cube_vert: d0$2, cube_frag: f0$2, depth_vert: p0$2, depth_frag: m0$2, distanceRGBA_vert: g0$2, distanceRGBA_frag: _0$2, equirect_vert: x0$2, equirect_frag: v0$2, linedashed_vert: y0$2, linedashed_frag: M0, meshbasic_vert: S0$2, meshbasic_frag: b0$2, meshlambert_vert: E0$1, meshlambert_frag: T0, meshmatcap_vert: A0, meshmatcap_frag: w0$1, meshnormal_vert: C0$2, meshnormal_frag: R0$1, meshphong_vert: I0$1, meshphong_frag: P0, meshphysical_vert: D0, meshphysical_frag: L0$1, meshtoon_vert: U0$1, meshtoon_frag: N0$1, points_vert: F0$1, points_frag: O0$1, shadow_vert: B0$1, shadow_frag: z0$1, sprite_vert: k0$1, sprite_frag: V0$1 }, ct$1 = { common: { diffuse: { value: new Ft$3(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Bt$2() }, alphaMap: { value: null }, alphaMapTransform: { value: new Bt$2() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Bt$2() } }, envmap: { envMap: { value: null }, envMapRotation: { value: new Bt$2() }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Bt$2() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Bt$2() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Bt$2() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Bt$2() }, normalScale: { value: new ot$1(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Bt$2() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Bt$2() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Bt$2() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Bt$2() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ft$3(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Ft$3(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Bt$2() }, alphaTest: { value: 0 }, uvTransform: { value: new Bt$2() } }, sprite: { diffuse: { value: new Ft$3(16777215) }, opacity: { value: 1 }, center: { value: new ot$1(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Bt$2() }, alphaMap: { value: null }, alphaMapTransform: { value: new Bt$2() }, alphaTest: { value: 0 } } }, un$1 = { basic: { uniforms: Ce$3([ct$1.common, ct$1.specularmap, ct$1.envmap, ct$1.aomap, ct$1.lightmap, ct$1.fog]), vertexShader: Ht$2.meshbasic_vert, fragmentShader: Ht$2.meshbasic_frag }, lambert: { uniforms: Ce$3([ct$1.common, ct$1.specularmap, ct$1.envmap, ct$1.aomap, ct$1.lightmap, ct$1.emissivemap, ct$1.bumpmap, ct$1.normalmap, ct$1.displacementmap, ct$1.fog, ct$1.lights, { emissive: { value: new Ft$3(0) } }]), vertexShader: Ht$2.meshlambert_vert, fragmentShader: Ht$2.meshlambert_frag }, phong: { uniforms: Ce$3([ct$1.common, ct$1.specularmap, ct$1.envmap, ct$1.aomap, ct$1.lightmap, ct$1.emissivemap, ct$1.bumpmap, ct$1.normalmap, ct$1.displacementmap, ct$1.fog, ct$1.lights, { emissive: { value: new Ft$3(0) }, specular: { value: new Ft$3(1118481) }, shininess: { value: 30 } }]), vertexShader: Ht$2.meshphong_vert, fragmentShader: Ht$2.meshphong_frag }, standard: { uniforms: Ce$3([ct$1.common, ct$1.envmap, ct$1.aomap, ct$1.lightmap, ct$1.emissivemap, ct$1.bumpmap, ct$1.normalmap, ct$1.displacementmap, ct$1.roughnessmap, ct$1.metalnessmap, ct$1.fog, ct$1.lights, { emissive: { value: new Ft$3(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Ht$2.meshphysical_vert, fragmentShader: Ht$2.meshphysical_frag }, toon: { uniforms: Ce$3([ct$1.common, ct$1.aomap, ct$1.lightmap, ct$1.emissivemap, ct$1.bumpmap, ct$1.normalmap, ct$1.displacementmap, ct$1.gradientmap, ct$1.fog, ct$1.lights, { emissive: { value: new Ft$3(0) } }]), vertexShader: Ht$2.meshtoon_vert, fragmentShader: Ht$2.meshtoon_frag }, matcap: { uniforms: Ce$3([ct$1.common, ct$1.bumpmap, ct$1.normalmap, ct$1.displacementmap, ct$1.fog, { matcap: { value: null } }]), vertexShader: Ht$2.meshmatcap_vert, fragmentShader: Ht$2.meshmatcap_frag }, points: { uniforms: Ce$3([ct$1.points, ct$1.fog]), vertexShader: Ht$2.points_vert, fragmentShader: Ht$2.points_frag }, dashed: { uniforms: Ce$3([ct$1.common, ct$1.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Ht$2.linedashed_vert, fragmentShader: Ht$2.linedashed_frag }, depth: { uniforms: Ce$3([ct$1.common, ct$1.displacementmap]), vertexShader: Ht$2.depth_vert, fragmentShader: Ht$2.depth_frag }, normal: { uniforms: Ce$3([ct$1.common, ct$1.bumpmap, ct$1.normalmap, ct$1.displacementmap, { opacity: { value: 1 } }]), vertexShader: Ht$2.meshnormal_vert, fragmentShader: Ht$2.meshnormal_frag }, sprite: { uniforms: Ce$3([ct$1.sprite, ct$1.fog]), vertexShader: Ht$2.sprite_vert, fragmentShader: Ht$2.sprite_frag }, background: { uniforms: { uvTransform: { value: new Bt$2() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Ht$2.background_vert, fragmentShader: Ht$2.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new Bt$2() } }, vertexShader: Ht$2.backgroundCube_vert, fragmentShader: Ht$2.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Ht$2.cube_vert, fragmentShader: Ht$2.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Ht$2.equirect_vert, fragmentShader: Ht$2.equirect_frag }, distanceRGBA: { uniforms: Ce$3([ct$1.common, ct$1.displacementmap, { referencePosition: { value: new I$1() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Ht$2.distanceRGBA_vert, fragmentShader: Ht$2.distanceRGBA_frag }, shadow: { uniforms: Ce$3([ct$1.lights, ct$1.fog, { color: { value: new Ft$3(0) }, opacity: { value: 1 } }]), vertexShader: Ht$2.shadow_vert, fragmentShader: Ht$2.shadow_frag } };
un$1.physical = { uniforms: Ce$3([un$1.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Bt$2() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Bt$2() }, clearcoatNormalScale: { value: new ot$1(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Bt$2() }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Bt$2() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Bt$2() }, sheen: { value: 0 }, sheenColor: { value: new Ft$3(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Bt$2() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Bt$2() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Bt$2() }, transmissionSamplerSize: { value: new ot$1() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Bt$2() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Ft$3(0) }, specularColor: { value: new Ft$3(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Bt$2() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Bt$2() }, anisotropyVector: { value: new ot$1() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Bt$2() } }]), vertexShader: Ht$2.meshphysical_vert, fragmentShader: Ht$2.meshphysical_frag };
var vo$1 = { r: 0, b: 0, g: 0 }, vi$1 = new Ze$1(), H0$1 = new Vt$2();
function G0$1(s5, t, e, n4, i, r5, a4) {
  let o4 = new Ft$3(0), l = r5 === true ? 0 : 1, c, u5, d = null, f = 0, m5 = null;
  function _(b) {
    let y4 = b.isScene === true ? b.background : null;
    return y4 && y4.isTexture && (y4 = (b.backgroundBlurriness > 0 ? e : t).get(y4)), y4;
  }
  H$3(_, "getBackground");
  function x2(b) {
    let y4 = false, D4 = _(b);
    D4 === null ? p4(o4, l) : D4 && D4.isColor && (p4(D4, 1), y4 = true);
    let C3 = s5.xr.getEnvironmentBlendMode();
    C3 === "additive" ? n4.buffers.color.setClear(0, 0, 0, 1, a4) : C3 === "alpha-blend" && n4.buffers.color.setClear(0, 0, 0, 0, a4), (s5.autoClear || y4) && (n4.buffers.depth.setTest(true), n4.buffers.depth.setMask(true), n4.buffers.color.setMask(true), s5.clear(s5.autoClearColor, s5.autoClearDepth, s5.autoClearStencil));
  }
  H$3(x2, "render");
  function g(b, y4) {
    let D4 = _(y4);
    D4 && (D4.isCubeTexture || D4.mapping === Vs$2) ? (u5 === void 0 && (u5 = new ye$1(new Xi$2(1, 1, 1), new sn$1({ name: "BackgroundCubeMaterial", uniforms: xi$1(un$1.backgroundCube.uniforms), vertexShader: un$1.backgroundCube.vertexShader, fragmentShader: un$1.backgroundCube.fragmentShader, side: Le$2, depthTest: false, depthWrite: false, fog: false })), u5.geometry.deleteAttribute("normal"), u5.geometry.deleteAttribute("uv"), u5.onBeforeRender = function(C3, R3, L3) {
      this.matrixWorld.copyPosition(L3.matrixWorld);
    }, Object.defineProperty(u5.material, "envMap", { get: H$3(function() {
      return this.uniforms.envMap.value;
    }, "get") }), i.update(u5)), vi$1.copy(y4.backgroundRotation), vi$1.x *= -1, vi$1.y *= -1, vi$1.z *= -1, D4.isCubeTexture && D4.isRenderTargetTexture === false && (vi$1.y *= -1, vi$1.z *= -1), u5.material.uniforms.envMap.value = D4, u5.material.uniforms.flipEnvMap.value = D4.isCubeTexture && D4.isRenderTargetTexture === false ? -1 : 1, u5.material.uniforms.backgroundBlurriness.value = y4.backgroundBlurriness, u5.material.uniforms.backgroundIntensity.value = y4.backgroundIntensity, u5.material.uniforms.backgroundRotation.value.setFromMatrix4(H0$1.makeRotationFromEuler(vi$1)), u5.material.toneMapped = qt$2.getTransfer(D4.colorSpace) !== ie$2, (d !== D4 || f !== D4.version || m5 !== s5.toneMapping) && (u5.material.needsUpdate = true, d = D4, f = D4.version, m5 = s5.toneMapping), u5.layers.enableAll(), b.unshift(u5, u5.geometry, u5.material, 0, 0, null)) : D4 && D4.isTexture && (c === void 0 && (c = new ye$1(new Os$2(2, 2), new sn$1({ name: "BackgroundMaterial", uniforms: xi$1(un$1.background.uniforms), vertexShader: un$1.background.vertexShader, fragmentShader: un$1.background.fragmentShader, side: Sn$2, depthTest: false, depthWrite: false, fog: false })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", { get: H$3(function() {
      return this.uniforms.t2D.value;
    }, "get") }), i.update(c)), c.material.uniforms.t2D.value = D4, c.material.uniforms.backgroundIntensity.value = y4.backgroundIntensity, c.material.toneMapped = qt$2.getTransfer(D4.colorSpace) !== ie$2, D4.matrixAutoUpdate === true && D4.updateMatrix(), c.material.uniforms.uvTransform.value.copy(D4.matrix), (d !== D4 || f !== D4.version || m5 !== s5.toneMapping) && (c.material.needsUpdate = true, d = D4, f = D4.version, m5 = s5.toneMapping), c.layers.enableAll(), b.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  H$3(g, "addToRenderList");
  function p4(b, y4) {
    b.getRGB(vo$1, gc$2(s5)), n4.buffers.color.setClear(vo$1.r, vo$1.g, vo$1.b, y4, a4);
  }
  H$3(p4, "setClear");
  function w3() {
    u5 !== void 0 && (u5.geometry.dispose(), u5.material.dispose(), u5 = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
  }
  return H$3(w3, "dispose"), { getClearColor: H$3(function() {
    return o4;
  }, "getClearColor"), setClearColor: H$3(function(b, y4 = 1) {
    o4.set(b), l = y4, p4(o4, l);
  }, "setClearColor"), getClearAlpha: H$3(function() {
    return l;
  }, "getClearAlpha"), setClearAlpha: H$3(function(b) {
    l = b, p4(o4, l);
  }, "setClearAlpha"), render: x2, addToRenderList: g, dispose: w3 };
}
H$3(G0$1, "WebGLBackground");
function W0$1(s5, t) {
  let e = s5.getParameter(s5.MAX_VERTEX_ATTRIBS), n4 = {}, i = f(null), r5 = i, a4 = false;
  function o4(S4, P4, G3, B3, V3) {
    let J4 = false, H5 = d(B3, G3, P4);
    r5 !== H5 && (r5 = H5, c(r5.object)), J4 = m5(S4, B3, G3, V3), J4 && _(S4, B3, G3, V3), V3 !== null && t.update(V3, s5.ELEMENT_ARRAY_BUFFER), (J4 || a4) && (a4 = false, y4(S4, P4, G3, B3), V3 !== null && s5.bindBuffer(s5.ELEMENT_ARRAY_BUFFER, t.get(V3).buffer));
  }
  H$3(o4, "setup");
  function l() {
    return s5.createVertexArray();
  }
  H$3(l, "createVertexArrayObject");
  function c(S4) {
    return s5.bindVertexArray(S4);
  }
  H$3(c, "bindVertexArrayObject");
  function u5(S4) {
    return s5.deleteVertexArray(S4);
  }
  H$3(u5, "deleteVertexArrayObject");
  function d(S4, P4, G3) {
    let B3 = G3.wireframe === true, V3 = n4[S4.id];
    V3 === void 0 && (V3 = {}, n4[S4.id] = V3);
    let J4 = V3[P4.id];
    J4 === void 0 && (J4 = {}, V3[P4.id] = J4);
    let H5 = J4[B3];
    return H5 === void 0 && (H5 = f(l()), J4[B3] = H5), H5;
  }
  H$3(d, "getBindingState");
  function f(S4) {
    let P4 = [], G3 = [], B3 = [];
    for (let V3 = 0; V3 < e; V3++) P4[V3] = 0, G3[V3] = 0, B3[V3] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: P4, enabledAttributes: G3, attributeDivisors: B3, object: S4, attributes: {}, index: null };
  }
  H$3(f, "createBindingState");
  function m5(S4, P4, G3, B3) {
    let V3 = r5.attributes, J4 = P4.attributes, H5 = 0, it2 = G3.getAttributes();
    for (let W4 in it2) if (it2[W4].location >= 0) {
      let gt2 = V3[W4], bt2 = J4[W4];
      if (bt2 === void 0 && (W4 === "instanceMatrix" && S4.instanceMatrix && (bt2 = S4.instanceMatrix), W4 === "instanceColor" && S4.instanceColor && (bt2 = S4.instanceColor)), gt2 === void 0 || gt2.attribute !== bt2 || bt2 && gt2.data !== bt2.data) return true;
      H5++;
    }
    return r5.attributesNum !== H5 || r5.index !== B3;
  }
  H$3(m5, "needsUpdate");
  function _(S4, P4, G3, B3) {
    let V3 = {}, J4 = P4.attributes, H5 = 0, it2 = G3.getAttributes();
    for (let W4 in it2) if (it2[W4].location >= 0) {
      let gt2 = J4[W4];
      gt2 === void 0 && (W4 === "instanceMatrix" && S4.instanceMatrix && (gt2 = S4.instanceMatrix), W4 === "instanceColor" && S4.instanceColor && (gt2 = S4.instanceColor));
      let bt2 = {};
      bt2.attribute = gt2, gt2 && gt2.data && (bt2.data = gt2.data), V3[W4] = bt2, H5++;
    }
    r5.attributes = V3, r5.attributesNum = H5, r5.index = B3;
  }
  H$3(_, "saveCache");
  function x2() {
    let S4 = r5.newAttributes;
    for (let P4 = 0, G3 = S4.length; P4 < G3; P4++) S4[P4] = 0;
  }
  H$3(x2, "initAttributes");
  function g(S4) {
    p4(S4, 0);
  }
  H$3(g, "enableAttribute");
  function p4(S4, P4) {
    let G3 = r5.newAttributes, B3 = r5.enabledAttributes, V3 = r5.attributeDivisors;
    G3[S4] = 1, B3[S4] === 0 && (s5.enableVertexAttribArray(S4), B3[S4] = 1), V3[S4] !== P4 && (s5.vertexAttribDivisor(S4, P4), V3[S4] = P4);
  }
  H$3(p4, "enableAttributeAndDivisor");
  function w3() {
    let S4 = r5.newAttributes, P4 = r5.enabledAttributes;
    for (let G3 = 0, B3 = P4.length; G3 < B3; G3++) P4[G3] !== S4[G3] && (s5.disableVertexAttribArray(G3), P4[G3] = 0);
  }
  H$3(w3, "disableUnusedAttributes");
  function b(S4, P4, G3, B3, V3, J4, H5) {
    H5 === true ? s5.vertexAttribIPointer(S4, P4, G3, V3, J4) : s5.vertexAttribPointer(S4, P4, G3, B3, V3, J4);
  }
  H$3(b, "vertexAttribPointer");
  function y4(S4, P4, G3, B3) {
    x2();
    let V3 = B3.attributes, J4 = G3.getAttributes(), H5 = P4.defaultAttributeValues;
    for (let it2 in J4) {
      let W4 = J4[it2];
      if (W4.location >= 0) {
        let lt2 = V3[it2];
        if (lt2 === void 0 && (it2 === "instanceMatrix" && S4.instanceMatrix && (lt2 = S4.instanceMatrix), it2 === "instanceColor" && S4.instanceColor && (lt2 = S4.instanceColor)), lt2 !== void 0) {
          let gt2 = lt2.normalized, bt2 = lt2.itemSize, Ot2 = t.get(lt2);
          if (Ot2 === void 0) continue;
          let Qt2 = Ot2.buffer, Z4 = Ot2.type, rt2 = Ot2.bytesPerElement, Et2 = Z4 === s5.INT || Z4 === s5.UNSIGNED_INT || lt2.gpuType === Ba$1;
          if (lt2.isInterleavedBufferAttribute) {
            let at2 = lt2.data, Ct2 = at2.stride, Yt2 = lt2.offset;
            if (at2.isInstancedInterleavedBuffer) {
              for (let wt2 = 0; wt2 < W4.locationSize; wt2++) p4(W4.location + wt2, at2.meshPerAttribute);
              S4.isInstancedMesh !== true && B3._maxInstanceCount === void 0 && (B3._maxInstanceCount = at2.meshPerAttribute * at2.count);
            } else for (let wt2 = 0; wt2 < W4.locationSize; wt2++) g(W4.location + wt2);
            s5.bindBuffer(s5.ARRAY_BUFFER, Qt2);
            for (let wt2 = 0; wt2 < W4.locationSize; wt2++) b(W4.location + wt2, bt2 / W4.locationSize, Z4, gt2, Ct2 * rt2, (Yt2 + bt2 / W4.locationSize * wt2) * rt2, Et2);
          } else {
            if (lt2.isInstancedBufferAttribute) {
              for (let at2 = 0; at2 < W4.locationSize; at2++) p4(W4.location + at2, lt2.meshPerAttribute);
              S4.isInstancedMesh !== true && B3._maxInstanceCount === void 0 && (B3._maxInstanceCount = lt2.meshPerAttribute * lt2.count);
            } else for (let at2 = 0; at2 < W4.locationSize; at2++) g(W4.location + at2);
            s5.bindBuffer(s5.ARRAY_BUFFER, Qt2);
            for (let at2 = 0; at2 < W4.locationSize; at2++) b(W4.location + at2, bt2 / W4.locationSize, Z4, gt2, bt2 * rt2, bt2 / W4.locationSize * at2 * rt2, Et2);
          }
        } else if (H5 !== void 0) {
          let gt2 = H5[it2];
          if (gt2 !== void 0) switch (gt2.length) {
            case 2:
              s5.vertexAttrib2fv(W4.location, gt2);
              break;
            case 3:
              s5.vertexAttrib3fv(W4.location, gt2);
              break;
            case 4:
              s5.vertexAttrib4fv(W4.location, gt2);
              break;
            default:
              s5.vertexAttrib1fv(W4.location, gt2);
          }
        }
      }
    }
    w3();
  }
  H$3(y4, "setupVertexAttributes");
  function D4() {
    L3();
    for (let S4 in n4) {
      let P4 = n4[S4];
      for (let G3 in P4) {
        let B3 = P4[G3];
        for (let V3 in B3) u5(B3[V3].object), delete B3[V3];
        delete P4[G3];
      }
      delete n4[S4];
    }
  }
  H$3(D4, "dispose");
  function C3(S4) {
    if (n4[S4.id] === void 0) return;
    let P4 = n4[S4.id];
    for (let G3 in P4) {
      let B3 = P4[G3];
      for (let V3 in B3) u5(B3[V3].object), delete B3[V3];
      delete P4[G3];
    }
    delete n4[S4.id];
  }
  H$3(C3, "releaseStatesOfGeometry");
  function R3(S4) {
    for (let P4 in n4) {
      let G3 = n4[P4];
      if (G3[S4.id] === void 0) continue;
      let B3 = G3[S4.id];
      for (let V3 in B3) u5(B3[V3].object), delete B3[V3];
      delete G3[S4.id];
    }
  }
  H$3(R3, "releaseStatesOfProgram");
  function L3() {
    E4(), a4 = true, r5 !== i && (r5 = i, c(r5.object));
  }
  H$3(L3, "reset");
  function E4() {
    i.geometry = null, i.program = null, i.wireframe = false;
  }
  return H$3(E4, "resetDefaultState"), { setup: o4, reset: L3, resetDefaultState: E4, dispose: D4, releaseStatesOfGeometry: C3, releaseStatesOfProgram: R3, initAttributes: x2, enableAttribute: g, disableUnusedAttributes: w3 };
}
H$3(W0$1, "WebGLBindingStates");
function X0$1(s5, t, e) {
  let n4;
  function i(c) {
    n4 = c;
  }
  H$3(i, "setMode");
  function r5(c, u5) {
    s5.drawArrays(n4, c, u5), e.update(u5, n4, 1);
  }
  H$3(r5, "render");
  function a4(c, u5, d) {
    d !== 0 && (s5.drawArraysInstanced(n4, c, u5, d), e.update(u5, n4, d));
  }
  H$3(a4, "renderInstances");
  function o4(c, u5, d) {
    if (d === 0) return;
    t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n4, c, 0, u5, 0, d);
    let m5 = 0;
    for (let _ = 0; _ < d; _++) m5 += u5[_];
    e.update(m5, n4, 1);
  }
  H$3(o4, "renderMultiDraw");
  function l(c, u5, d, f) {
    if (d === 0) return;
    let m5 = t.get("WEBGL_multi_draw");
    if (m5 === null) for (let _ = 0; _ < c.length; _++) a4(c[_], u5[_], f[_]);
    else {
      m5.multiDrawArraysInstancedWEBGL(n4, c, 0, u5, 0, f, 0, d);
      let _ = 0;
      for (let x2 = 0; x2 < d; x2++) _ += u5[x2] * f[x2];
      e.update(_, n4, 1);
    }
  }
  H$3(l, "renderMultiDrawInstances"), this.setMode = i, this.render = r5, this.renderInstances = a4, this.renderMultiDraw = o4, this.renderMultiDrawInstances = l;
}
H$3(X0$1, "WebGLBufferRenderer");
function q0$1(s5, t, e, n4) {
  let i;
  function r5() {
    if (i !== void 0) return i;
    if (t.has("EXT_texture_filter_anisotropic") === true) {
      let R3 = t.get("EXT_texture_filter_anisotropic");
      i = s5.getParameter(R3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  H$3(r5, "getMaxAnisotropy");
  function a4(R3) {
    return !(R3 !== De$3 && n4.convert(R3) !== s5.getParameter(s5.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  H$3(a4, "textureFormatReadable");
  function o4(R3) {
    let L3 = R3 === Ji$1 && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
    return !(R3 !== hn && n4.convert(R3) !== s5.getParameter(s5.IMPLEMENTATION_COLOR_READ_TYPE) && R3 !== Oe$1 && !L3);
  }
  H$3(o4, "textureTypeReadable");
  function l(R3) {
    if (R3 === "highp") {
      if (s5.getShaderPrecisionFormat(s5.VERTEX_SHADER, s5.HIGH_FLOAT).precision > 0 && s5.getShaderPrecisionFormat(s5.FRAGMENT_SHADER, s5.HIGH_FLOAT).precision > 0) return "highp";
      R3 = "mediump";
    }
    return R3 === "mediump" && s5.getShaderPrecisionFormat(s5.VERTEX_SHADER, s5.MEDIUM_FLOAT).precision > 0 && s5.getShaderPrecisionFormat(s5.FRAGMENT_SHADER, s5.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  H$3(l, "getMaxPrecision");
  let c = e.precision !== void 0 ? e.precision : "highp", u5 = l(c);
  u5 !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u5, "instead."), c = u5);
  let d = e.logarithmicDepthBuffer === true, f = e.reverseDepthBuffer === true && t.has("EXT_clip_control"), m5 = s5.getParameter(s5.MAX_TEXTURE_IMAGE_UNITS), _ = s5.getParameter(s5.MAX_VERTEX_TEXTURE_IMAGE_UNITS), x2 = s5.getParameter(s5.MAX_TEXTURE_SIZE), g = s5.getParameter(s5.MAX_CUBE_MAP_TEXTURE_SIZE), p4 = s5.getParameter(s5.MAX_VERTEX_ATTRIBS), w3 = s5.getParameter(s5.MAX_VERTEX_UNIFORM_VECTORS), b = s5.getParameter(s5.MAX_VARYING_VECTORS), y4 = s5.getParameter(s5.MAX_FRAGMENT_UNIFORM_VECTORS), D4 = _ > 0, C3 = s5.getParameter(s5.MAX_SAMPLES);
  return { isWebGL2: true, getMaxAnisotropy: r5, getMaxPrecision: l, textureFormatReadable: a4, textureTypeReadable: o4, precision: c, logarithmicDepthBuffer: d, reverseDepthBuffer: f, maxTextures: m5, maxVertexTextures: _, maxTextureSize: x2, maxCubemapSize: g, maxAttributes: p4, maxVertexUniforms: w3, maxVaryings: b, maxFragmentUniforms: y4, vertexTextures: D4, maxSamples: C3 };
}
H$3(q0$1, "WebGLCapabilities");
function Y0$1(s5) {
  let t = this, e = null, n4 = 0, i = false, r5 = false, a4 = new rn$1(), o4 = new Bt$2(), l = { value: null, needsUpdate: false };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, f) {
    let m5 = d.length !== 0 || f || n4 !== 0 || i;
    return i = f, n4 = d.length, m5;
  }, this.beginShadows = function() {
    r5 = true, u5(null);
  }, this.endShadows = function() {
    r5 = false;
  }, this.setGlobalState = function(d, f) {
    e = u5(d, f, 0);
  }, this.setState = function(d, f, m5) {
    let _ = d.clippingPlanes, x2 = d.clipIntersection, g = d.clipShadows, p4 = s5.get(d);
    if (!i || _ === null || _.length === 0 || r5 && !g) r5 ? u5(null) : c();
    else {
      let w3 = r5 ? 0 : n4, b = w3 * 4, y4 = p4.clippingState || null;
      l.value = y4, y4 = u5(_, f, b, m5);
      for (let D4 = 0; D4 !== b; ++D4) y4[D4] = e[D4];
      p4.clippingState = y4, this.numIntersection = x2 ? this.numPlanes : 0, this.numPlanes += w3;
    }
  };
  function c() {
    l.value !== e && (l.value = e, l.needsUpdate = n4 > 0), t.numPlanes = n4, t.numIntersection = 0;
  }
  H$3(c, "resetGlobalState");
  function u5(d, f, m5, _) {
    let x2 = d !== null ? d.length : 0, g = null;
    if (x2 !== 0) {
      if (g = l.value, _ !== true || g === null) {
        let p4 = m5 + x2 * 4, w3 = f.matrixWorldInverse;
        o4.getNormalMatrix(w3), (g === null || g.length < p4) && (g = new Float32Array(p4));
        for (let b = 0, y4 = m5; b !== x2; ++b, y4 += 4) a4.copy(d[b]).applyMatrix4(w3, o4), a4.normal.toArray(g, y4), g[y4 + 3] = a4.constant;
      }
      l.value = g, l.needsUpdate = true;
    }
    return t.numPlanes = x2, t.numIntersection = 0, g;
  }
  H$3(u5, "projectPlanes");
}
H$3(Y0$1, "WebGLClipping");
function Z0$1(s5) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(a4, o4) {
    return o4 === Na$1 ? a4.mapping = pi$2 : o4 === Fa$1 && (a4.mapping = mi$1), a4;
  }
  H$3(e, "mapTextureMapping");
  function n4(a4) {
    if (a4 && a4.isTexture) {
      let o4 = a4.mapping;
      if (o4 === Na$1 || o4 === Fa$1) if (t.has(a4)) {
        let l = t.get(a4).texture;
        return e(l, a4.mapping);
      } else {
        let l = a4.image;
        if (l && l.height > 0) {
          let c = new Hr$2(l.height);
          return c.fromEquirectangularTexture(s5, a4), t.set(a4, c), a4.addEventListener("dispose", i), e(c.texture, a4.mapping);
        } else return null;
      }
    }
    return a4;
  }
  H$3(n4, "get");
  function i(a4) {
    let o4 = a4.target;
    o4.removeEventListener("dispose", i);
    let l = t.get(o4);
    l !== void 0 && (t.delete(o4), l.dispose());
  }
  H$3(i, "onTextureDispose");
  function r5() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return H$3(r5, "dispose"), { get: n4, dispose: r5 };
}
H$3(Z0$1, "WebGLCubeMaps");
var Ki$1 = 4, Gf$1 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Si$2 = 20, xu$2 = new ks$2(), Wf$1 = new Ft$3(), vu$2 = null, yu$1 = 0, Mu$2 = 0, Su$2 = false, Mi$3 = (1 + Math.sqrt(5)) / 2, $i$1 = 1 / Mi$3, Xf$1 = [new I$1(-Mi$3, $i$1, 0), new I$1(Mi$3, $i$1, 0), new I$1(-$i$1, 0, Mi$3), new I$1($i$1, 0, Mi$3), new I$1(0, Mi$3, -$i$1), new I$1(0, Mi$3, $i$1), new I$1(-1, 1, -1), new I$1(1, 1, -1), new I$1(-1, 1, 1), new I$1(1, 1, 1)], Lu$2 = class Lu {
  constructor(t) {
    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(t, e = 0, n4 = 0.1, i = 100) {
    vu$2 = this._renderer.getRenderTarget(), yu$1 = this._renderer.getActiveCubeFace(), Mu$2 = this._renderer.getActiveMipmapLevel(), Su$2 = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
    let r5 = this._allocateTargets();
    return r5.depthBuffer = true, this._sceneToCubeUV(t, n4, i, r5), e > 0 && this._blur(r5, 0, 0, e), this._applyPMREM(r5), this._cleanup(r5), r5;
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Zf$1(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Yf$1(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(t) {
    this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(vu$2, yu$1, Mu$2), this._renderer.xr.enabled = Su$2, t.scissorTest = false, yo$1(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === pi$2 || t.mapping === mi$1 ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), vu$2 = this._renderer.getRenderTarget(), yu$1 = this._renderer.getActiveCubeFace(), Mu$2 = this._renderer.getActiveMipmapLevel(), Su$2 = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
    let n4 = e || this._allocateTargets();
    return this._textureToCubeUV(t, n4), this._applyPMREM(n4), this._cleanup(n4), n4;
  }
  _allocateTargets() {
    let t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n4 = { magFilter: en$1, minFilter: en$1, generateMipmaps: false, type: Ji$1, format: De$3, colorSpace: ri$1, depthBuffer: false }, i = qf$1(t, e, n4);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = qf$1(t, e, n4);
      let { _lodMax: r5 } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = J0$1(r5)), this._blurMaterial = $0$1(r5, t, e);
    }
    return i;
  }
  _compileMaterial(t) {
    let e = new ye$1(this._lodPlanes[0], t);
    this._renderer.compile(e, xu$2);
  }
  _sceneToCubeUV(t, e, n4, i) {
    let o4 = new Te$1(90, 1, e, n4), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], u5 = this._renderer, d = u5.autoClear, f = u5.toneMapping;
    u5.getClearColor(Wf$1), u5.toneMapping = Cn$3, u5.autoClear = false;
    let m5 = new vs$1({ name: "PMREM.Background", side: Le$2, depthWrite: false, depthTest: false }), _ = new ye$1(new Xi$2(), m5), x2 = false, g = t.background;
    g ? g.isColor && (m5.color.copy(g), t.background = null, x2 = true) : (m5.color.copy(Wf$1), x2 = true);
    for (let p4 = 0; p4 < 6; p4++) {
      let w3 = p4 % 3;
      w3 === 0 ? (o4.up.set(0, l[p4], 0), o4.lookAt(c[p4], 0, 0)) : w3 === 1 ? (o4.up.set(0, 0, l[p4]), o4.lookAt(0, c[p4], 0)) : (o4.up.set(0, l[p4], 0), o4.lookAt(0, 0, c[p4]));
      let b = this._cubeSize;
      yo$1(i, w3 * b, p4 > 2 ? b : 0, b, b), u5.setRenderTarget(i), x2 && u5.render(_, o4), u5.render(t, o4);
    }
    _.geometry.dispose(), _.material.dispose(), u5.toneMapping = f, u5.autoClear = d, t.background = g;
  }
  _textureToCubeUV(t, e) {
    let n4 = this._renderer, i = t.mapping === pi$2 || t.mapping === mi$1;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Zf$1()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Yf$1());
    let r5 = i ? this._cubemapMaterial : this._equirectMaterial, a4 = new ye$1(this._lodPlanes[0], r5), o4 = r5.uniforms;
    o4.envMap.value = t;
    let l = this._cubeSize;
    yo$1(e, 0, 0, 3 * l, 2 * l), n4.setRenderTarget(e), n4.render(a4, xu$2);
  }
  _applyPMREM(t) {
    let e = this._renderer, n4 = e.autoClear;
    e.autoClear = false;
    let i = this._lodPlanes.length;
    for (let r5 = 1; r5 < i; r5++) {
      let a4 = Math.sqrt(this._sigmas[r5] * this._sigmas[r5] - this._sigmas[r5 - 1] * this._sigmas[r5 - 1]), o4 = Xf$1[(i - r5 - 1) % Xf$1.length];
      this._blur(t, r5 - 1, r5, a4, o4);
    }
    e.autoClear = n4;
  }
  _blur(t, e, n4, i, r5) {
    let a4 = this._pingPongRenderTarget;
    this._halfBlur(t, a4, e, n4, i, "latitudinal", r5), this._halfBlur(a4, t, n4, n4, i, "longitudinal", r5);
  }
  _halfBlur(t, e, n4, i, r5, a4, o4) {
    let l = this._renderer, c = this._blurMaterial;
    a4 !== "latitudinal" && a4 !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    let u5 = 3, d = new ye$1(this._lodPlanes[i], c), f = c.uniforms, m5 = this._sizeLods[n4] - 1, _ = isFinite(r5) ? Math.PI / (2 * m5) : 2 * Math.PI / (2 * Si$2 - 1), x2 = r5 / _, g = isFinite(r5) ? 1 + Math.floor(u5 * x2) : Si$2;
    g > Si$2 && console.warn("sigmaRadians, ".concat(r5, ", is too large and will clip, as it requested ").concat(g, " samples when the maximum is set to ").concat(Si$2));
    let p4 = [], w3 = 0;
    for (let R3 = 0; R3 < Si$2; ++R3) {
      let L3 = R3 / x2, E4 = Math.exp(-L3 * L3 / 2);
      p4.push(E4), R3 === 0 ? w3 += E4 : R3 < g && (w3 += 2 * E4);
    }
    for (let R3 = 0; R3 < p4.length; R3++) p4[R3] = p4[R3] / w3;
    f.envMap.value = t.texture, f.samples.value = g, f.weights.value = p4, f.latitudinal.value = a4 === "latitudinal", o4 && (f.poleAxis.value = o4);
    let { _lodMax: b } = this;
    f.dTheta.value = _, f.mipInt.value = b - n4;
    let y4 = this._sizeLods[i], D4 = 3 * y4 * (i > b - Ki$1 ? i - b + Ki$1 : 0), C3 = 4 * (this._cubeSize - y4);
    yo$1(e, D4, C3, 3 * y4, 2 * y4), l.setRenderTarget(e), l.render(d, xu$2);
  }
};
H$3(Lu$2, "PMREMGenerator");
var So$2 = Lu$2;
function J0$1(s5) {
  let t = [], e = [], n4 = [], i = s5, r5 = s5 - Ki$1 + 1 + Gf$1.length;
  for (let a4 = 0; a4 < r5; a4++) {
    let o4 = Math.pow(2, i);
    e.push(o4);
    let l = 1 / o4;
    a4 > s5 - Ki$1 ? l = Gf$1[a4 - s5 + Ki$1 - 1] : a4 === 0 && (l = 0), n4.push(l);
    let c = 1 / (o4 - 2), u5 = -c, d = 1 + c, f = [u5, u5, d, u5, d, d, u5, u5, d, d, u5, d], m5 = 6, _ = 6, x2 = 3, g = 2, p4 = 1, w3 = new Float32Array(x2 * _ * m5), b = new Float32Array(g * _ * m5), y4 = new Float32Array(p4 * _ * m5);
    for (let C3 = 0; C3 < m5; C3++) {
      let R3 = C3 % 3 * 2 / 3 - 1, L3 = C3 > 2 ? 0 : -1, E4 = [R3, L3, 0, R3 + 2 / 3, L3, 0, R3 + 2 / 3, L3 + 1, 0, R3, L3, 0, R3 + 2 / 3, L3 + 1, 0, R3, L3 + 1, 0];
      w3.set(E4, x2 * _ * C3), b.set(f, g * _ * C3);
      let S4 = [C3, C3, C3, C3, C3, C3];
      y4.set(S4, p4 * _ * C3);
    }
    let D4 = new pe$3();
    D4.setAttribute("position", new ve$3(w3, x2)), D4.setAttribute("uv", new ve$3(b, g)), D4.setAttribute("faceIndex", new ve$3(y4, p4)), t.push(D4), i > Ki$1 && i--;
  }
  return { lodPlanes: t, sizeLods: e, sigmas: n4 };
}
H$3(J0$1, "_createPlanes");
function qf$1(s5, t, e) {
  let n4 = new on$3(s5, t, e);
  return n4.texture.mapping = Vs$2, n4.texture.name = "PMREM.cubeUv", n4.scissorTest = true, n4;
}
H$3(qf$1, "_createRenderTarget");
function yo$1(s5, t, e, n4, i) {
  s5.viewport.set(t, e, n4, i), s5.scissor.set(t, e, n4, i);
}
H$3(yo$1, "_setViewport");
function $0$1(s5, t, e) {
  let n4 = new Float32Array(Si$2), i = new I$1(0, 1, 0);
  return new sn$1({ name: "SphericalGaussianBlur", defines: { n: Si$2, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / e, CUBEUV_MAX_MIP: "".concat(s5, ".0") }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n4 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i } }, vertexShader: Du$2(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		", blending: wn$3, depthTest: false, depthWrite: false });
}
H$3($0$1, "_getBlurShader");
function Yf$1() {
  return new sn$1({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: Du$2(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		", blending: wn$3, depthTest: false, depthWrite: false });
}
H$3(Yf$1, "_getEquirectMaterial");
function Zf$1() {
  return new sn$1({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: Du$2(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		", blending: wn$3, depthTest: false, depthWrite: false });
}
H$3(Zf$1, "_getCubemapMaterial");
function Du$2() {
  return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
}
H$3(Du$2, "_getCommonVertexShader");
function K0$1(s5) {
  let t = /* @__PURE__ */ new WeakMap(), e = null;
  function n4(o4) {
    if (o4 && o4.isTexture) {
      let l = o4.mapping, c = l === Na$1 || l === Fa$1, u5 = l === pi$2 || l === mi$1;
      if (c || u5) {
        let d = t.get(o4), f = d !== void 0 ? d.texture.pmremVersion : 0;
        if (o4.isRenderTargetTexture && o4.pmremVersion !== f) return e === null && (e = new So$2(s5)), d = c ? e.fromEquirectangular(o4, d) : e.fromCubemap(o4, d), d.texture.pmremVersion = o4.pmremVersion, t.set(o4, d), d.texture;
        if (d !== void 0) return d.texture;
        {
          let m5 = o4.image;
          return c && m5 && m5.height > 0 || u5 && m5 && i(m5) ? (e === null && (e = new So$2(s5)), d = c ? e.fromEquirectangular(o4) : e.fromCubemap(o4), d.texture.pmremVersion = o4.pmremVersion, t.set(o4, d), o4.addEventListener("dispose", r5), d.texture) : null;
        }
      }
    }
    return o4;
  }
  H$3(n4, "get");
  function i(o4) {
    let l = 0, c = 6;
    for (let u5 = 0; u5 < c; u5++) o4[u5] !== void 0 && l++;
    return l === c;
  }
  H$3(i, "isCubeTextureComplete");
  function r5(o4) {
    let l = o4.target;
    l.removeEventListener("dispose", r5);
    let c = t.get(l);
    c !== void 0 && (t.delete(l), c.dispose());
  }
  H$3(r5, "onTextureDispose");
  function a4() {
    t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
  }
  return H$3(a4, "dispose"), { get: n4, dispose: a4 };
}
H$3(K0$1, "WebGLCubeUVMaps");
function Q0$1(s5) {
  let t = {};
  function e(n4) {
    if (t[n4] !== void 0) return t[n4];
    let i;
    switch (n4) {
      case "WEBGL_depth_texture":
        i = s5.getExtension("WEBGL_depth_texture") || s5.getExtension("MOZ_WEBGL_depth_texture") || s5.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = s5.getExtension("EXT_texture_filter_anisotropic") || s5.getExtension("MOZ_EXT_texture_filter_anisotropic") || s5.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = s5.getExtension("WEBGL_compressed_texture_s3tc") || s5.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s5.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = s5.getExtension("WEBGL_compressed_texture_pvrtc") || s5.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s5.getExtension(n4);
    }
    return t[n4] = i, i;
  }
  return H$3(e, "getExtension"), { has: H$3(function(n4) {
    return e(n4) !== null;
  }, "has"), init: H$3(function() {
    e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
  }, "init"), get: H$3(function(n4) {
    let i = e(n4);
    return i === null && _i$1("THREE.WebGLRenderer: " + n4 + " extension not supported."), i;
  }, "get") };
}
H$3(Q0$1, "WebGLExtensions");
function j0$1(s5, t, e, n4) {
  let i = {}, r5 = /* @__PURE__ */ new WeakMap();
  function a4(d) {
    let f = d.target;
    f.index !== null && t.remove(f.index);
    for (let _ in f.attributes) t.remove(f.attributes[_]);
    f.removeEventListener("dispose", a4), delete i[f.id];
    let m5 = r5.get(f);
    m5 && (t.remove(m5), r5.delete(f)), n4.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === true && delete f._maxInstanceCount, e.memory.geometries--;
  }
  H$3(a4, "onGeometryDispose");
  function o4(d, f) {
    return i[f.id] === true || (f.addEventListener("dispose", a4), i[f.id] = true, e.memory.geometries++), f;
  }
  H$3(o4, "get");
  function l(d) {
    let f = d.attributes;
    for (let m5 in f) t.update(f[m5], s5.ARRAY_BUFFER);
  }
  H$3(l, "update");
  function c(d) {
    let f = [], m5 = d.index, _ = d.attributes.position, x2 = 0;
    if (m5 !== null) {
      let w3 = m5.array;
      x2 = m5.version;
      for (let b = 0, y4 = w3.length; b < y4; b += 3) {
        let D4 = w3[b + 0], C3 = w3[b + 1], R3 = w3[b + 2];
        f.push(D4, C3, C3, R3, R3, D4);
      }
    } else if (_ !== void 0) {
      let w3 = _.array;
      x2 = _.version;
      for (let b = 0, y4 = w3.length / 3 - 1; b < y4; b += 3) {
        let D4 = b + 0, C3 = b + 1, R3 = b + 2;
        f.push(D4, C3, C3, R3, R3, D4);
      }
    } else return;
    let g = new (mc$2(f) ? Ms$1 : ys$1)(f, 1);
    g.version = x2;
    let p4 = r5.get(d);
    p4 && t.remove(p4), r5.set(d, g);
  }
  H$3(c, "updateWireframeAttribute");
  function u5(d) {
    let f = r5.get(d);
    if (f) {
      let m5 = d.index;
      m5 !== null && f.version < m5.version && c(d);
    } else c(d);
    return r5.get(d);
  }
  return H$3(u5, "getWireframeAttribute"), { get: o4, update: l, getWireframeAttribute: u5 };
}
H$3(j0$1, "WebGLGeometries");
function tx$2(s5, t, e) {
  let n4;
  function i(f) {
    n4 = f;
  }
  H$3(i, "setMode");
  let r5, a4;
  function o4(f) {
    r5 = f.type, a4 = f.bytesPerElement;
  }
  H$3(o4, "setIndex");
  function l(f, m5) {
    s5.drawElements(n4, m5, r5, f * a4), e.update(m5, n4, 1);
  }
  H$3(l, "render");
  function c(f, m5, _) {
    _ !== 0 && (s5.drawElementsInstanced(n4, m5, r5, f * a4, _), e.update(m5, n4, _));
  }
  H$3(c, "renderInstances");
  function u5(f, m5, _) {
    if (_ === 0) return;
    t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n4, m5, 0, r5, f, 0, _);
    let g = 0;
    for (let p4 = 0; p4 < _; p4++) g += m5[p4];
    e.update(g, n4, 1);
  }
  H$3(u5, "renderMultiDraw");
  function d(f, m5, _, x2) {
    if (_ === 0) return;
    let g = t.get("WEBGL_multi_draw");
    if (g === null) for (let p4 = 0; p4 < f.length; p4++) c(f[p4] / a4, m5[p4], x2[p4]);
    else {
      g.multiDrawElementsInstancedWEBGL(n4, m5, 0, r5, f, 0, x2, 0, _);
      let p4 = 0;
      for (let w3 = 0; w3 < _; w3++) p4 += m5[w3] * x2[w3];
      e.update(p4, n4, 1);
    }
  }
  H$3(d, "renderMultiDrawInstances"), this.setMode = i, this.setIndex = o4, this.render = l, this.renderInstances = c, this.renderMultiDraw = u5, this.renderMultiDrawInstances = d;
}
H$3(tx$2, "WebGLIndexedBufferRenderer");
function ex$2(s5) {
  let t = { geometries: 0, textures: 0 }, e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n4(r5, a4, o4) {
    switch (e.calls++, a4) {
      case s5.TRIANGLES:
        e.triangles += o4 * (r5 / 3);
        break;
      case s5.LINES:
        e.lines += o4 * (r5 / 2);
        break;
      case s5.LINE_STRIP:
        e.lines += o4 * (r5 - 1);
        break;
      case s5.LINE_LOOP:
        e.lines += o4 * r5;
        break;
      case s5.POINTS:
        e.points += o4 * r5;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a4);
        break;
    }
  }
  H$3(n4, "update");
  function i() {
    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }
  return H$3(i, "reset"), { memory: t, render: e, programs: null, autoReset: true, reset: i, update: n4 };
}
H$3(ex$2, "WebGLInfo");
function nx$2(s5, t, e) {
  let n4 = /* @__PURE__ */ new WeakMap(), i = new $t$3();
  function r5(a4, o4, l) {
    let c = a4.morphTargetInfluences, u5 = o4.morphAttributes.position || o4.morphAttributes.normal || o4.morphAttributes.color, d = u5 !== void 0 ? u5.length : 0, f = n4.get(o4);
    if (f === void 0 || f.count !== d) {
      let E4 = function() {
        R3.dispose(), n4.delete(o4), o4.removeEventListener("dispose", E4);
      };
      H$3(E4, "disposeTexture"), f !== void 0 && f.texture.dispose();
      let m5 = o4.morphAttributes.position !== void 0, _ = o4.morphAttributes.normal !== void 0, x2 = o4.morphAttributes.color !== void 0, g = o4.morphAttributes.position || [], p4 = o4.morphAttributes.normal || [], w3 = o4.morphAttributes.color || [], b = 0;
      m5 === true && (b = 1), _ === true && (b = 2), x2 === true && (b = 3);
      let y4 = o4.attributes.position.count * b, D4 = 1;
      y4 > t.maxTextureSize && (D4 = Math.ceil(y4 / t.maxTextureSize), y4 = t.maxTextureSize);
      let C3 = new Float32Array(y4 * D4 * 4 * d), R3 = new xs$1(C3, y4, D4, d);
      R3.type = Oe$1, R3.needsUpdate = true;
      let L3 = b * 4;
      for (let S4 = 0; S4 < d; S4++) {
        let P4 = g[S4], G3 = p4[S4], B3 = w3[S4], V3 = y4 * D4 * 4 * S4;
        for (let J4 = 0; J4 < P4.count; J4++) {
          let H5 = J4 * L3;
          m5 === true && (i.fromBufferAttribute(P4, J4), C3[V3 + H5 + 0] = i.x, C3[V3 + H5 + 1] = i.y, C3[V3 + H5 + 2] = i.z, C3[V3 + H5 + 3] = 0), _ === true && (i.fromBufferAttribute(G3, J4), C3[V3 + H5 + 4] = i.x, C3[V3 + H5 + 5] = i.y, C3[V3 + H5 + 6] = i.z, C3[V3 + H5 + 7] = 0), x2 === true && (i.fromBufferAttribute(B3, J4), C3[V3 + H5 + 8] = i.x, C3[V3 + H5 + 9] = i.y, C3[V3 + H5 + 10] = i.z, C3[V3 + H5 + 11] = B3.itemSize === 4 ? i.w : 1);
        }
      }
      f = { count: d, texture: R3, size: new ot$1(y4, D4) }, n4.set(o4, f), o4.addEventListener("dispose", E4);
    }
    if (a4.isInstancedMesh === true && a4.morphTexture !== null) l.getUniforms().setValue(s5, "morphTexture", a4.morphTexture, e);
    else {
      let m5 = 0;
      for (let x2 = 0; x2 < c.length; x2++) m5 += c[x2];
      let _ = o4.morphTargetsRelative ? 1 : 1 - m5;
      l.getUniforms().setValue(s5, "morphTargetBaseInfluence", _), l.getUniforms().setValue(s5, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(s5, "morphTargetsTexture", f.texture, e), l.getUniforms().setValue(s5, "morphTargetsTextureSize", f.size);
  }
  return H$3(r5, "update"), { update: r5 };
}
H$3(nx$2, "WebGLMorphtargets");
function ix$2(s5, t, e, n4) {
  let i = /* @__PURE__ */ new WeakMap();
  function r5(l) {
    let c = n4.render.frame, u5 = l.geometry, d = t.get(l, u5);
    if (i.get(d) !== c && (t.update(d), i.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o4) === false && l.addEventListener("dispose", o4), i.get(l) !== c && (e.update(l.instanceMatrix, s5.ARRAY_BUFFER), l.instanceColor !== null && e.update(l.instanceColor, s5.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
      let f = l.skeleton;
      i.get(f) !== c && (f.update(), i.set(f, c));
    }
    return d;
  }
  H$3(r5, "update");
  function a4() {
    i = /* @__PURE__ */ new WeakMap();
  }
  H$3(a4, "dispose");
  function o4(l) {
    let c = l.target;
    c.removeEventListener("dispose", o4), e.remove(c.instanceMatrix), c.instanceColor !== null && e.remove(c.instanceColor);
  }
  return H$3(o4, "onInstancedMeshDispose"), { update: r5, dispose: a4 };
}
H$3(ix$2, "WebGLObjects");
var pp$1 = new we$2(), Jf = new ws$2(1, 1), mp$1 = new xs$1(), gp = new kr$1(), _p$2 = new bs$1(), $f$1 = [], Kf = [], Qf$1 = new Float32Array(16), jf$1 = new Float32Array(9), tp$2 = new Float32Array(4);
function ji$1(s5, t, e) {
  let n4 = s5[0];
  if (n4 <= 0 || n4 > 0) return s5;
  let i = t * e, r5 = $f$1[i];
  if (r5 === void 0 && (r5 = new Float32Array(i), $f$1[i] = r5), t !== 0) {
    n4.toArray(r5, 0);
    for (let a4 = 1, o4 = 0; a4 !== t; ++a4) o4 += e, s5[a4].toArray(r5, o4);
  }
  return r5;
}
H$3(ji$1, "flatten");
function me$2(s5, t) {
  if (s5.length !== t.length) return false;
  for (let e = 0, n4 = s5.length; e < n4; e++) if (s5[e] !== t[e]) return false;
  return true;
}
H$3(me$2, "arraysEqual");
function ge$1(s5, t) {
  for (let e = 0, n4 = t.length; e < n4; e++) s5[e] = t[e];
}
H$3(ge$1, "copyArray");
function bo$1(s5, t) {
  let e = Kf[t];
  e === void 0 && (e = new Int32Array(t), Kf[t] = e);
  for (let n4 = 0; n4 !== t; ++n4) e[n4] = s5.allocateTextureUnit();
  return e;
}
H$3(bo$1, "allocTexUnits");
function sx$1(s5, t) {
  let e = this.cache;
  e[0] !== t && (s5.uniform1f(this.addr, t), e[0] = t);
}
H$3(sx$1, "setValueV1f");
function rx$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (s5.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (me$2(e, t)) return;
    s5.uniform2fv(this.addr, t), ge$1(e, t);
  }
}
H$3(rx$2, "setValueV2f");
function ax$1(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (s5.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (s5.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
  else {
    if (me$2(e, t)) return;
    s5.uniform3fv(this.addr, t), ge$1(e, t);
  }
}
H$3(ax$1, "setValueV3f");
function ox$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (s5.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (me$2(e, t)) return;
    s5.uniform4fv(this.addr, t), ge$1(e, t);
  }
}
H$3(ox$2, "setValueV4f");
function lx$1(s5, t) {
  let e = this.cache, n4 = t.elements;
  if (n4 === void 0) {
    if (me$2(e, t)) return;
    s5.uniformMatrix2fv(this.addr, false, t), ge$1(e, t);
  } else {
    if (me$2(e, n4)) return;
    tp$2.set(n4), s5.uniformMatrix2fv(this.addr, false, tp$2), ge$1(e, n4);
  }
}
H$3(lx$1, "setValueM2");
function cx$1(s5, t) {
  let e = this.cache, n4 = t.elements;
  if (n4 === void 0) {
    if (me$2(e, t)) return;
    s5.uniformMatrix3fv(this.addr, false, t), ge$1(e, t);
  } else {
    if (me$2(e, n4)) return;
    jf$1.set(n4), s5.uniformMatrix3fv(this.addr, false, jf$1), ge$1(e, n4);
  }
}
H$3(cx$1, "setValueM3");
function hx$2(s5, t) {
  let e = this.cache, n4 = t.elements;
  if (n4 === void 0) {
    if (me$2(e, t)) return;
    s5.uniformMatrix4fv(this.addr, false, t), ge$1(e, t);
  } else {
    if (me$2(e, n4)) return;
    Qf$1.set(n4), s5.uniformMatrix4fv(this.addr, false, Qf$1), ge$1(e, n4);
  }
}
H$3(hx$2, "setValueM4");
function ux$1(s5, t) {
  let e = this.cache;
  e[0] !== t && (s5.uniform1i(this.addr, t), e[0] = t);
}
H$3(ux$1, "setValueV1i");
function dx$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (s5.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (me$2(e, t)) return;
    s5.uniform2iv(this.addr, t), ge$1(e, t);
  }
}
H$3(dx$2, "setValueV2i");
function fx$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (s5.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (me$2(e, t)) return;
    s5.uniform3iv(this.addr, t), ge$1(e, t);
  }
}
H$3(fx$2, "setValueV3i");
function px$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (s5.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (me$2(e, t)) return;
    s5.uniform4iv(this.addr, t), ge$1(e, t);
  }
}
H$3(px$2, "setValueV4i");
function mx$2(s5, t) {
  let e = this.cache;
  e[0] !== t && (s5.uniform1ui(this.addr, t), e[0] = t);
}
H$3(mx$2, "setValueV1ui");
function gx$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (s5.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (me$2(e, t)) return;
    s5.uniform2uiv(this.addr, t), ge$1(e, t);
  }
}
H$3(gx$2, "setValueV2ui");
function _x$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (s5.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (me$2(e, t)) return;
    s5.uniform3uiv(this.addr, t), ge$1(e, t);
  }
}
H$3(_x$2, "setValueV3ui");
function xx$2(s5, t) {
  let e = this.cache;
  if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (s5.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (me$2(e, t)) return;
    s5.uniform4uiv(this.addr, t), ge$1(e, t);
  }
}
H$3(xx$2, "setValueV4ui");
function vx$2(s5, t, e) {
  let n4 = this.cache, i = e.allocateTextureUnit();
  n4[0] !== i && (s5.uniform1i(this.addr, i), n4[0] = i);
  let r5;
  this.type === s5.SAMPLER_2D_SHADOW ? (Jf.compareFunction = dc$2, r5 = Jf) : r5 = pp$1, e.setTexture2D(t || r5, i);
}
H$3(vx$2, "setValueT1");
function yx$2(s5, t, e) {
  let n4 = this.cache, i = e.allocateTextureUnit();
  n4[0] !== i && (s5.uniform1i(this.addr, i), n4[0] = i), e.setTexture3D(t || gp, i);
}
H$3(yx$2, "setValueT3D1");
function Mx$2(s5, t, e) {
  let n4 = this.cache, i = e.allocateTextureUnit();
  n4[0] !== i && (s5.uniform1i(this.addr, i), n4[0] = i), e.setTextureCube(t || _p$2, i);
}
H$3(Mx$2, "setValueT6");
function Sx$1(s5, t, e) {
  let n4 = this.cache, i = e.allocateTextureUnit();
  n4[0] !== i && (s5.uniform1i(this.addr, i), n4[0] = i), e.setTexture2DArray(t || mp$1, i);
}
H$3(Sx$1, "setValueT2DArray1");
function bx$2(s5) {
  switch (s5) {
    case 5126:
      return sx$1;
    case 35664:
      return rx$2;
    case 35665:
      return ax$1;
    case 35666:
      return ox$2;
    case 35674:
      return lx$1;
    case 35675:
      return cx$1;
    case 35676:
      return hx$2;
    case 5124:
    case 35670:
      return ux$1;
    case 35667:
    case 35671:
      return dx$2;
    case 35668:
    case 35672:
      return fx$2;
    case 35669:
    case 35673:
      return px$2;
    case 5125:
      return mx$2;
    case 36294:
      return gx$2;
    case 36295:
      return _x$2;
    case 36296:
      return xx$2;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return vx$2;
    case 35679:
    case 36299:
    case 36307:
      return yx$2;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Mx$2;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Sx$1;
  }
}
H$3(bx$2, "getSingularSetter");
function Ex$1(s5, t) {
  s5.uniform1fv(this.addr, t);
}
H$3(Ex$1, "setValueV1fArray");
function Tx$2(s5, t) {
  let e = ji$1(t, this.size, 2);
  s5.uniform2fv(this.addr, e);
}
H$3(Tx$2, "setValueV2fArray");
function Ax$2(s5, t) {
  let e = ji$1(t, this.size, 3);
  s5.uniform3fv(this.addr, e);
}
H$3(Ax$2, "setValueV3fArray");
function wx$2(s5, t) {
  let e = ji$1(t, this.size, 4);
  s5.uniform4fv(this.addr, e);
}
H$3(wx$2, "setValueV4fArray");
function Cx$2(s5, t) {
  let e = ji$1(t, this.size, 4);
  s5.uniformMatrix2fv(this.addr, false, e);
}
H$3(Cx$2, "setValueM2Array");
function Rx$1(s5, t) {
  let e = ji$1(t, this.size, 9);
  s5.uniformMatrix3fv(this.addr, false, e);
}
H$3(Rx$1, "setValueM3Array");
function Ix$1(s5, t) {
  let e = ji$1(t, this.size, 16);
  s5.uniformMatrix4fv(this.addr, false, e);
}
H$3(Ix$1, "setValueM4Array");
function Px$2(s5, t) {
  s5.uniform1iv(this.addr, t);
}
H$3(Px$2, "setValueV1iArray");
function Dx$2(s5, t) {
  s5.uniform2iv(this.addr, t);
}
H$3(Dx$2, "setValueV2iArray");
function Lx$1(s5, t) {
  s5.uniform3iv(this.addr, t);
}
H$3(Lx$1, "setValueV3iArray");
function Ux$1(s5, t) {
  s5.uniform4iv(this.addr, t);
}
H$3(Ux$1, "setValueV4iArray");
function Nx$1(s5, t) {
  s5.uniform1uiv(this.addr, t);
}
H$3(Nx$1, "setValueV1uiArray");
function Fx$2(s5, t) {
  s5.uniform2uiv(this.addr, t);
}
H$3(Fx$2, "setValueV2uiArray");
function Ox$1(s5, t) {
  s5.uniform3uiv(this.addr, t);
}
H$3(Ox$1, "setValueV3uiArray");
function Bx$2(s5, t) {
  s5.uniform4uiv(this.addr, t);
}
H$3(Bx$2, "setValueV4uiArray");
function zx$1(s5, t, e) {
  let n4 = this.cache, i = t.length, r5 = bo$1(e, i);
  me$2(n4, r5) || (s5.uniform1iv(this.addr, r5), ge$1(n4, r5));
  for (let a4 = 0; a4 !== i; ++a4) e.setTexture2D(t[a4] || pp$1, r5[a4]);
}
H$3(zx$1, "setValueT1Array");
function kx$2(s5, t, e) {
  let n4 = this.cache, i = t.length, r5 = bo$1(e, i);
  me$2(n4, r5) || (s5.uniform1iv(this.addr, r5), ge$1(n4, r5));
  for (let a4 = 0; a4 !== i; ++a4) e.setTexture3D(t[a4] || gp, r5[a4]);
}
H$3(kx$2, "setValueT3DArray");
function Vx$1(s5, t, e) {
  let n4 = this.cache, i = t.length, r5 = bo$1(e, i);
  me$2(n4, r5) || (s5.uniform1iv(this.addr, r5), ge$1(n4, r5));
  for (let a4 = 0; a4 !== i; ++a4) e.setTextureCube(t[a4] || _p$2, r5[a4]);
}
H$3(Vx$1, "setValueT6Array");
function Hx$2(s5, t, e) {
  let n4 = this.cache, i = t.length, r5 = bo$1(e, i);
  me$2(n4, r5) || (s5.uniform1iv(this.addr, r5), ge$1(n4, r5));
  for (let a4 = 0; a4 !== i; ++a4) e.setTexture2DArray(t[a4] || mp$1, r5[a4]);
}
H$3(Hx$2, "setValueT2DArrayArray");
function Gx$1(s5) {
  switch (s5) {
    case 5126:
      return Ex$1;
    case 35664:
      return Tx$2;
    case 35665:
      return Ax$2;
    case 35666:
      return wx$2;
    case 35674:
      return Cx$2;
    case 35675:
      return Rx$1;
    case 35676:
      return Ix$1;
    case 5124:
    case 35670:
      return Px$2;
    case 35667:
    case 35671:
      return Dx$2;
    case 35668:
    case 35672:
      return Lx$1;
    case 35669:
    case 35673:
      return Ux$1;
    case 5125:
      return Nx$1;
    case 36294:
      return Fx$2;
    case 36295:
      return Ox$1;
    case 36296:
      return Bx$2;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return zx$1;
    case 35679:
    case 36299:
    case 36307:
      return kx$2;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Vx$1;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Hx$2;
  }
}
H$3(Gx$1, "getPureArraySetter");
var Uu$2 = class Uu {
  constructor(t, e, n4) {
    this.id = t, this.addr = n4, this.cache = [], this.type = e.type, this.setValue = bx$2(e.type);
  }
};
H$3(Uu$2, "SingleUniform");
var Eu$2 = Uu$2, Nu$2 = class Nu {
  constructor(t, e, n4) {
    this.id = t, this.addr = n4, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = Gx$1(e.type);
  }
};
H$3(Nu$2, "PureArrayUniform");
var Tu$2 = Nu$2, Fu$2 = class Fu {
  constructor(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  setValue(t, e, n4) {
    let i = this.seq;
    for (let r5 = 0, a4 = i.length; r5 !== a4; ++r5) {
      let o4 = i[r5];
      o4.setValue(t, e[o4.id], n4);
    }
  }
};
H$3(Fu$2, "StructuredUniform");
var Au$2 = Fu$2, bu$2 = /(\w+)(\])?(\[|\.)?/g;
function ep$2(s5, t) {
  s5.seq.push(t), s5.map[t.id] = t;
}
H$3(ep$2, "addUniform");
function Wx$2(s5, t, e) {
  let n4 = s5.name, i = n4.length;
  for (bu$2.lastIndex = 0; ; ) {
    let r5 = bu$2.exec(n4), a4 = bu$2.lastIndex, o4 = r5[1], l = r5[2] === "]", c = r5[3];
    if (l && (o4 = o4 | 0), c === void 0 || c === "[" && a4 + 2 === i) {
      ep$2(e, c === void 0 ? new Eu$2(o4, s5, t) : new Tu$2(o4, s5, t));
      break;
    } else {
      let d = e.map[o4];
      d === void 0 && (d = new Au$2(o4), ep$2(e, d)), e = d;
    }
  }
}
H$3(Wx$2, "parseUniform");
var Ou$2 = class Ou {
  constructor(t, e) {
    this.seq = [], this.map = {};
    let n4 = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let i = 0; i < n4; ++i) {
      let r5 = t.getActiveUniform(e, i), a4 = t.getUniformLocation(e, r5.name);
      Wx$2(r5, a4, this);
    }
  }
  setValue(t, e, n4, i) {
    let r5 = this.map[e];
    r5 !== void 0 && r5.setValue(t, n4, i);
  }
  setOptional(t, e, n4) {
    let i = e[n4];
    i !== void 0 && this.setValue(t, n4, i);
  }
  static upload(t, e, n4, i) {
    for (let r5 = 0, a4 = e.length; r5 !== a4; ++r5) {
      let o4 = e[r5], l = n4[o4.id];
      l.needsUpdate !== false && o4.setValue(t, l.value, i);
    }
  }
  static seqWithValue(t, e) {
    let n4 = [];
    for (let i = 0, r5 = t.length; i !== r5; ++i) {
      let a4 = t[i];
      a4.id in e && n4.push(a4);
    }
    return n4;
  }
};
H$3(Ou$2, "WebGLUniforms");
var Qi$1 = Ou$2;
function np$1(s5, t, e) {
  let n4 = s5.createShader(t);
  return s5.shaderSource(n4, e), s5.compileShader(n4), n4;
}
H$3(np$1, "WebGLShader");
var Xx$2 = 37297, qx$1 = 0;
function Yx$2(s5, t) {
  let e = s5.split("\n"), n4 = [], i = Math.max(t - 6, 0), r5 = Math.min(t + 6, e.length);
  for (let a4 = i; a4 < r5; a4++) {
    let o4 = a4 + 1;
    n4.push("".concat(o4 === t ? ">" : " ", " ").concat(o4, ": ").concat(e[a4]));
  }
  return n4.join("\n");
}
H$3(Yx$2, "handleSource");
var ip$1 = new Bt$2();
function Zx$2(s5) {
  qt$2._getMatrix(ip$1, qt$2.workingColorSpace, s5);
  let t = "mat3( ".concat(ip$1.elements.map((e) => e.toFixed(4)), " )");
  switch (qt$2.getTransfer(s5)) {
    case ms$1:
      return [t, "LinearTransferOETF"];
    case ie$2:
      return [t, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", s5), [t, "LinearTransferOETF"];
  }
}
H$3(Zx$2, "getEncodingComponents");
function sp$1(s5, t, e) {
  let n4 = s5.getShaderParameter(t, s5.COMPILE_STATUS), i = s5.getShaderInfoLog(t).trim();
  if (n4 && i === "") return "";
  let r5 = /ERROR: 0:(\d+)/.exec(i);
  if (r5) {
    let a4 = parseInt(r5[1]);
    return e.toUpperCase() + "\n\n" + i + "\n\n" + Yx$2(s5.getShaderSource(t), a4);
  } else return i;
}
H$3(sp$1, "getShaderErrors");
function Jx$2(s5, t) {
  let e = Zx$2(t);
  return ["vec4 ".concat(s5, "( vec4 value ) {"), "	return ".concat(e[1], "( vec4( value.rgb * ").concat(e[0], ", value.a ) );"), "}"].join("\n");
}
H$3(Jx$2, "getTexelEncodingFunction");
function $x$2(s5, t) {
  let e;
  switch (t) {
    case df$2:
      e = "Linear";
      break;
    case ff$2:
      e = "Reinhard";
      break;
    case pf$2:
      e = "Cineon";
      break;
    case mf$2:
      e = "ACESFilmic";
      break;
    case _f$2:
      e = "AgX";
      break;
    case xf$2:
      e = "Neutral";
      break;
    case gf$2:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
  }
  return "vec3 " + s5 + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
}
H$3($x$2, "getToneMappingFunction");
var Mo$2 = new I$1();
function Kx$2() {
  qt$2.getLuminanceCoefficients(Mo$2);
  let s5 = Mo$2.x.toFixed(4), t = Mo$2.y.toFixed(4), e = Mo$2.z.toFixed(4);
  return ["float luminance( const in vec3 rgb ) {", "	const vec3 weights = vec3( ".concat(s5, ", ").concat(t, ", ").concat(e, " );"), "	return dot( weights, rgb );", "}"].join("\n");
}
H$3(Kx$2, "getLuminanceFunction");
function Qx$2(s5) {
  return [s5.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", s5.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Js$1).join("\n");
}
H$3(Qx$2, "generateVertexExtensions");
function jx$1(s5) {
  let t = [];
  for (let e in s5) {
    let n4 = s5[e];
    n4 !== false && t.push("#define " + e + " " + n4);
  }
  return t.join("\n");
}
H$3(jx$1, "generateDefines");
function tv$1(s5, t) {
  let e = {}, n4 = s5.getProgramParameter(t, s5.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n4; i++) {
    let r5 = s5.getActiveAttrib(t, i), a4 = r5.name, o4 = 1;
    r5.type === s5.FLOAT_MAT2 && (o4 = 2), r5.type === s5.FLOAT_MAT3 && (o4 = 3), r5.type === s5.FLOAT_MAT4 && (o4 = 4), e[a4] = { type: r5.type, location: s5.getAttribLocation(t, a4), locationSize: o4 };
  }
  return e;
}
H$3(tv$1, "fetchAttributeLocations");
function Js$1(s5) {
  return s5 !== "";
}
H$3(Js$1, "filterEmptyLine");
function rp$1(s5, t) {
  let e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return s5.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
H$3(rp$1, "replaceLightNums");
function ap$1(s5, t) {
  return s5.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
H$3(ap$1, "replaceClippingPlaneNums");
var ev$1 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function wu$2(s5) {
  return s5.replace(ev$1, iv$1);
}
H$3(wu$2, "resolveIncludes");
var nv$2 = /* @__PURE__ */ new Map();
function iv$1(s5, t) {
  let e = Ht$2[t];
  if (e === void 0) {
    let n4 = nv$2.get(t);
    if (n4 !== void 0) e = Ht$2[n4], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, n4);
    else throw new Error("Can not resolve #include <" + t + ">");
  }
  return wu$2(e);
}
H$3(iv$1, "includeReplacer");
var sv$1 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function op$1(s5) {
  return s5.replace(sv$1, rv$1);
}
H$3(op$1, "unrollLoops");
function rv$1(s5, t, e, n4) {
  let i = "";
  for (let r5 = parseInt(t); r5 < parseInt(e); r5++) i += n4.replace(/\[\s*i\s*\]/g, "[ " + r5 + " ]").replace(/UNROLLED_LOOP_INDEX/g, r5);
  return i;
}
H$3(rv$1, "loopReplacer");
function lp$1(s5) {
  let t = "precision ".concat(s5.precision, " float;\n	precision ").concat(s5.precision, " int;\n	precision ").concat(s5.precision, " sampler2D;\n	precision ").concat(s5.precision, " samplerCube;\n	precision ").concat(s5.precision, " sampler3D;\n	precision ").concat(s5.precision, " sampler2DArray;\n	precision ").concat(s5.precision, " sampler2DShadow;\n	precision ").concat(s5.precision, " samplerCubeShadow;\n	precision ").concat(s5.precision, " sampler2DArrayShadow;\n	precision ").concat(s5.precision, " isampler2D;\n	precision ").concat(s5.precision, " isampler3D;\n	precision ").concat(s5.precision, " isamplerCube;\n	precision ").concat(s5.precision, " isampler2DArray;\n	precision ").concat(s5.precision, " usampler2D;\n	precision ").concat(s5.precision, " usampler3D;\n	precision ").concat(s5.precision, " usamplerCube;\n	precision ").concat(s5.precision, " usampler2DArray;\n	");
  return s5.precision === "highp" ? t += "\n#define HIGH_PRECISION" : s5.precision === "mediump" ? t += "\n#define MEDIUM_PRECISION" : s5.precision === "lowp" && (t += "\n#define LOW_PRECISION"), t;
}
H$3(lp$1, "generatePrecision");
function av$1(s5) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return s5.shadowMapType === Ql$2 ? t = "SHADOWMAP_TYPE_PCF" : s5.shadowMapType === Wd$1 ? t = "SHADOWMAP_TYPE_PCF_SOFT" : s5.shadowMapType === ln && (t = "SHADOWMAP_TYPE_VSM"), t;
}
H$3(av$1, "generateShadowMapTypeDefine");
function ov$1(s5) {
  let t = "ENVMAP_TYPE_CUBE";
  if (s5.envMap) switch (s5.envMapMode) {
    case pi$2:
    case mi$1:
      t = "ENVMAP_TYPE_CUBE";
      break;
    case Vs$2:
      t = "ENVMAP_TYPE_CUBE_UV";
      break;
  }
  return t;
}
H$3(ov$1, "generateEnvMapTypeDefine");
function lv$1(s5) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (s5.envMap) switch (s5.envMapMode) {
    case mi$1:
      t = "ENVMAP_MODE_REFRACTION";
      break;
  }
  return t;
}
H$3(lv$1, "generateEnvMapModeDefine");
function cv$1(s5) {
  let t = "ENVMAP_BLENDING_NONE";
  if (s5.envMap) switch (s5.combine) {
    case Ua$1:
      t = "ENVMAP_BLENDING_MULTIPLY";
      break;
    case hf$2:
      t = "ENVMAP_BLENDING_MIX";
      break;
    case uf$2:
      t = "ENVMAP_BLENDING_ADD";
      break;
  }
  return t;
}
H$3(cv$1, "generateEnvMapBlendingDefine");
function hv$1(s5) {
  let t = s5.envMapCubeUVHeight;
  if (t === null) return null;
  let e = Math.log2(t) - 2, n4 = 1 / t;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: n4, maxMip: e };
}
H$3(hv$1, "generateCubeUVSize");
function uv$1(s5, t, e, n4) {
  let i = s5.getContext(), r5 = e.defines, a4 = e.vertexShader, o4 = e.fragmentShader, l = av$1(e), c = ov$1(e), u5 = lv$1(e), d = cv$1(e), f = hv$1(e), m5 = Qx$2(e), _ = jx$1(r5), x2 = i.createProgram(), g, p4, w3 = e.glslVersion ? "#version " + e.glslVersion + "\n" : "";
  e.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, _].filter(Js$1).join("\n"), g.length > 0 && (g += "\n"), p4 = ["#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, _].filter(Js$1).join("\n"), p4.length > 0 && (p4 += "\n")) : (g = [lp$1(e), "#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, _, e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", e.batching ? "#define USE_BATCHING" : "", e.batchingColor ? "#define USE_BATCHING_COLOR" : "", e.instancing ? "#define USE_INSTANCING" : "", e.instancingColor ? "#define USE_INSTANCING_COLOR" : "", e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + u5 : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.anisotropy ? "#define USE_ANISOTROPY" : "", e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaHash ? "#define USE_ALPHAHASH" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", e.mapUv ? "#define MAP_UV " + e.mapUv : "", e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "", e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "", e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "", e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "", e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "", e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "", e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "", e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "", e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "", e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "", e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "", e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "", e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "", e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "", e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "", e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "", e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "", e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "", e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "", e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "", e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "", e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "", e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUv1s ? "#define USE_UV1" : "", e.vertexUv2s ? "#define USE_UV2" : "", e.vertexUv3s ? "#define USE_UV3" : "", e.pointsUvs ? "#define USE_POINTS_UV" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && e.flatShading === false ? "#define USE_MORPHNORMALS" : "", e.morphColors ? "#define USE_MORPHCOLORS" : "", e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "", e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Js$1).join("\n"), p4 = [lp$1(e), "#define SHADER_TYPE " + e.shaderType, "#define SHADER_NAME " + e.shaderName, _, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", e.map ? "#define USE_MAP" : "", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + c : "", e.envMap ? "#define " + u5 : "", e.envMap ? "#define " + d : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.anisotropy ? "#define USE_ANISOTROPY" : "", e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", e.clearcoat ? "#define USE_CLEARCOAT" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.dispersion ? "#define USE_DISPERSION" : "", e.iridescence ? "#define USE_IRIDESCENCE" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaTest ? "#define USE_ALPHATEST" : "", e.alphaHash ? "#define USE_ALPHAHASH" : "", e.sheen ? "#define USE_SHEEN" : "", e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.vertexTangents && e.flatShading === false ? "#define USE_TANGENT" : "", e.vertexColors || e.instancingColor || e.batchingColor ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUv1s ? "#define USE_UV1" : "", e.vertexUv2s ? "#define USE_UV2" : "", e.vertexUv3s ? "#define USE_UV3" : "", e.pointsUvs ? "#define USE_POINTS_UV" : "", e.gradientMap ? "#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", e.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", e.toneMapping !== Cn$3 ? "#define TONE_MAPPING" : "", e.toneMapping !== Cn$3 ? Ht$2.tonemapping_pars_fragment : "", e.toneMapping !== Cn$3 ? $x$2("toneMapping", e.toneMapping) : "", e.dithering ? "#define DITHERING" : "", e.opaque ? "#define OPAQUE" : "", Ht$2.colorspace_pars_fragment, Jx$2("linearToOutputTexel", e.outputColorSpace), Kx$2(), e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", "\n"].filter(Js$1).join("\n")), a4 = wu$2(a4), a4 = rp$1(a4, e), a4 = ap$1(a4, e), o4 = wu$2(o4), o4 = rp$1(o4, e), o4 = ap$1(o4, e), a4 = op$1(a4), o4 = op$1(o4), e.isRawShaderMaterial !== true && (w3 = "#version 300 es\n", g = [m5, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, p4 = ["#define varying in", e.glslVersion === fc$2 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", e.glslVersion === fc$2 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + p4);
  let b = w3 + g + a4, y4 = w3 + p4 + o4, D4 = np$1(i, i.VERTEX_SHADER, b), C3 = np$1(i, i.FRAGMENT_SHADER, y4);
  i.attachShader(x2, D4), i.attachShader(x2, C3), e.index0AttributeName !== void 0 ? i.bindAttribLocation(x2, 0, e.index0AttributeName) : e.morphTargets === true && i.bindAttribLocation(x2, 0, "position"), i.linkProgram(x2);
  function R3(P4) {
    if (s5.debug.checkShaderErrors) {
      let G3 = i.getProgramInfoLog(x2).trim(), B3 = i.getShaderInfoLog(D4).trim(), V3 = i.getShaderInfoLog(C3).trim(), J4 = true, H5 = true;
      if (i.getProgramParameter(x2, i.LINK_STATUS) === false) if (J4 = false, typeof s5.debug.onShaderError == "function") s5.debug.onShaderError(i, x2, D4, C3);
      else {
        let it2 = sp$1(i, D4, "vertex"), W4 = sp$1(i, C3, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(x2, i.VALIDATE_STATUS) + "\n\nMaterial Name: " + P4.name + "\nMaterial Type: " + P4.type + "\n\nProgram Info Log: " + G3 + "\n" + it2 + "\n" + W4);
      }
      else G3 !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", G3) : (B3 === "" || V3 === "") && (H5 = false);
      H5 && (P4.diagnostics = { runnable: J4, programLog: G3, vertexShader: { log: B3, prefix: g }, fragmentShader: { log: V3, prefix: p4 } });
    }
    i.deleteShader(D4), i.deleteShader(C3), L3 = new Qi$1(i, x2), E4 = tv$1(i, x2);
  }
  H$3(R3, "onFirstUse");
  let L3;
  this.getUniforms = function() {
    return L3 === void 0 && R3(this), L3;
  };
  let E4;
  this.getAttributes = function() {
    return E4 === void 0 && R3(this), E4;
  };
  let S4 = e.rendererExtensionParallelShaderCompile === false;
  return this.isReady = function() {
    return S4 === false && (S4 = i.getProgramParameter(x2, Xx$2)), S4;
  }, this.destroy = function() {
    n4.releaseStatesOfProgram(this), i.deleteProgram(x2), this.program = void 0;
  }, this.type = e.shaderType, this.name = e.shaderName, this.id = qx$1++, this.cacheKey = t, this.usedTimes = 1, this.program = x2, this.vertexShader = D4, this.fragmentShader = C3, this;
}
H$3(uv$1, "WebGLProgram");
var dv$1 = 0, Bu$2 = class Bu {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t) {
    let e = t.vertexShader, n4 = t.fragmentShader, i = this._getShaderStage(e), r5 = this._getShaderStage(n4), a4 = this._getShaderCacheForMaterial(t);
    return a4.has(i) === false && (a4.add(i), i.usedTimes++), a4.has(r5) === false && (a4.add(r5), r5.usedTimes++), this;
  }
  remove(t) {
    let e = this.materialCache.get(t);
    for (let n4 of e) n4.usedTimes--, n4.usedTimes === 0 && this.shaderCache.delete(n4.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    let e = this.materialCache, n4 = e.get(t);
    return n4 === void 0 && (n4 = /* @__PURE__ */ new Set(), e.set(t, n4)), n4;
  }
  _getShaderStage(t) {
    let e = this.shaderCache, n4 = e.get(t);
    return n4 === void 0 && (n4 = new Ru$2(t), e.set(t, n4)), n4;
  }
};
H$3(Bu$2, "WebGLShaderCache");
var Cu$2 = Bu$2, zu$2 = class zu {
  constructor(t) {
    this.id = dv$1++, this.code = t, this.usedTimes = 0;
  }
};
H$3(zu$2, "WebGLShaderStage");
var Ru$2 = zu$2;
function fv$1(s5, t, e, n4, i, r5, a4) {
  let o4 = new Wi$2(), l = new Cu$2(), c = /* @__PURE__ */ new Set(), u5 = [], d = i.logarithmicDepthBuffer, f = i.vertexTextures, m5 = i.precision, _ = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function x2(E4) {
    return c.add(E4), E4 === 0 ? "uv" : "uv".concat(E4);
  }
  H$3(x2, "getChannel");
  function g(E4, S4, P4, G3, B3) {
    let V3 = G3.fog, J4 = B3.geometry, H5 = E4.isMeshStandardMaterial ? G3.environment : null, it2 = (E4.isMeshStandardMaterial ? e : t).get(E4.envMap || H5), W4 = it2 && it2.mapping === Vs$2 ? it2.image.height : null, lt2 = _[E4.type];
    E4.precision !== null && (m5 = i.getMaxPrecision(E4.precision), m5 !== E4.precision && console.warn("THREE.WebGLProgram.getParameters:", E4.precision, "not supported, using", m5, "instead."));
    let gt2 = J4.morphAttributes.position || J4.morphAttributes.normal || J4.morphAttributes.color, bt2 = gt2 !== void 0 ? gt2.length : 0, Ot2 = 0;
    J4.morphAttributes.position !== void 0 && (Ot2 = 1), J4.morphAttributes.normal !== void 0 && (Ot2 = 2), J4.morphAttributes.color !== void 0 && (Ot2 = 3);
    let Qt2, Z4, rt2, Et2;
    if (lt2) {
      let ee2 = un$1[lt2];
      Qt2 = ee2.vertexShader, Z4 = ee2.fragmentShader;
    } else Qt2 = E4.vertexShader, Z4 = E4.fragmentShader, l.update(E4), rt2 = l.getVertexShaderID(E4), Et2 = l.getFragmentShaderID(E4);
    let at2 = s5.getRenderTarget(), Ct2 = s5.state.buffers.depth.getReversed(), Yt2 = B3.isInstancedMesh === true, wt2 = B3.isBatchedMesh === true, Kt2 = !!E4.map, j3 = !!E4.matcap, Q4 = !!it2, A3 = !!E4.aoMap, At2 = !!E4.lightMap, tt2 = !!E4.bumpMap, xt2 = !!E4.normalMap, st2 = !!E4.displacementMap, Dt2 = !!E4.emissiveMap, ft2 = !!E4.metalnessMap, T3 = !!E4.roughnessMap, v3 = E4.anisotropy > 0, O4 = E4.clearcoat > 0, q4 = E4.dispersion > 0, K4 = E4.iridescence > 0, Y3 = E4.sheen > 0, Tt2 = E4.transmission > 0, ht2 = v3 && !!E4.anisotropyMap, _t2 = O4 && !!E4.clearcoatMap, Wt2 = O4 && !!E4.clearcoatNormalMap, nt2 = O4 && !!E4.clearcoatRoughnessMap, yt2 = K4 && !!E4.iridescenceMap, Pt3 = K4 && !!E4.iridescenceThicknessMap, Lt2 = Y3 && !!E4.sheenColorMap, Mt2 = Y3 && !!E4.sheenRoughnessMap, Xt2 = !!E4.specularMap, kt2 = !!E4.specularColorMap, se3 = !!E4.specularIntensityMap, U3 = Tt2 && !!E4.transmissionMap, ut2 = Tt2 && !!E4.thicknessMap, X4 = !!E4.gradientMap, $5 = !!E4.alphaMap, mt2 = E4.alphaTest > 0, pt2 = !!E4.alphaHash, zt2 = !!E4.extensions, ce2 = Cn$3;
    E4.toneMapped && (at2 === null || at2.isXRRenderTarget === true) && (ce2 = s5.toneMapping);
    let Me2 = { shaderID: lt2, shaderType: E4.type, shaderName: E4.name, vertexShader: Qt2, fragmentShader: Z4, defines: E4.defines, customVertexShaderID: rt2, customFragmentShaderID: Et2, isRawShaderMaterial: E4.isRawShaderMaterial === true, glslVersion: E4.glslVersion, precision: m5, batching: wt2, batchingColor: wt2 && B3._colorsTexture !== null, instancing: Yt2, instancingColor: Yt2 && B3.instanceColor !== null, instancingMorph: Yt2 && B3.morphTexture !== null, supportsVertexTextures: f, outputColorSpace: at2 === null ? s5.outputColorSpace : at2.isXRRenderTarget === true ? at2.texture.colorSpace : ri$1, alphaToCoverage: !!E4.alphaToCoverage, map: Kt2, matcap: j3, envMap: Q4, envMapMode: Q4 && it2.mapping, envMapCubeUVHeight: W4, aoMap: A3, lightMap: At2, bumpMap: tt2, normalMap: xt2, displacementMap: f && st2, emissiveMap: Dt2, normalMapObjectSpace: xt2 && E4.normalMapType === Ef$1, normalMapTangentSpace: xt2 && E4.normalMapType === _o$2, metalnessMap: ft2, roughnessMap: T3, anisotropy: v3, anisotropyMap: ht2, clearcoat: O4, clearcoatMap: _t2, clearcoatNormalMap: Wt2, clearcoatRoughnessMap: nt2, dispersion: q4, iridescence: K4, iridescenceMap: yt2, iridescenceThicknessMap: Pt3, sheen: Y3, sheenColorMap: Lt2, sheenRoughnessMap: Mt2, specularMap: Xt2, specularColorMap: kt2, specularIntensityMap: se3, transmission: Tt2, transmissionMap: U3, thicknessMap: ut2, gradientMap: X4, opaque: E4.transparent === false && E4.blending === ni$1 && E4.alphaToCoverage === false, alphaMap: $5, alphaTest: mt2, alphaHash: pt2, combine: E4.combine, mapUv: Kt2 && x2(E4.map.channel), aoMapUv: A3 && x2(E4.aoMap.channel), lightMapUv: At2 && x2(E4.lightMap.channel), bumpMapUv: tt2 && x2(E4.bumpMap.channel), normalMapUv: xt2 && x2(E4.normalMap.channel), displacementMapUv: st2 && x2(E4.displacementMap.channel), emissiveMapUv: Dt2 && x2(E4.emissiveMap.channel), metalnessMapUv: ft2 && x2(E4.metalnessMap.channel), roughnessMapUv: T3 && x2(E4.roughnessMap.channel), anisotropyMapUv: ht2 && x2(E4.anisotropyMap.channel), clearcoatMapUv: _t2 && x2(E4.clearcoatMap.channel), clearcoatNormalMapUv: Wt2 && x2(E4.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: nt2 && x2(E4.clearcoatRoughnessMap.channel), iridescenceMapUv: yt2 && x2(E4.iridescenceMap.channel), iridescenceThicknessMapUv: Pt3 && x2(E4.iridescenceThicknessMap.channel), sheenColorMapUv: Lt2 && x2(E4.sheenColorMap.channel), sheenRoughnessMapUv: Mt2 && x2(E4.sheenRoughnessMap.channel), specularMapUv: Xt2 && x2(E4.specularMap.channel), specularColorMapUv: kt2 && x2(E4.specularColorMap.channel), specularIntensityMapUv: se3 && x2(E4.specularIntensityMap.channel), transmissionMapUv: U3 && x2(E4.transmissionMap.channel), thicknessMapUv: ut2 && x2(E4.thicknessMap.channel), alphaMapUv: $5 && x2(E4.alphaMap.channel), vertexTangents: !!J4.attributes.tangent && (xt2 || v3), vertexColors: E4.vertexColors, vertexAlphas: E4.vertexColors === true && !!J4.attributes.color && J4.attributes.color.itemSize === 4, pointsUvs: B3.isPoints === true && !!J4.attributes.uv && (Kt2 || $5), fog: !!V3, useFog: E4.fog === true, fogExp2: !!V3 && V3.isFogExp2, flatShading: E4.flatShading === true, sizeAttenuation: E4.sizeAttenuation === true, logarithmicDepthBuffer: d, reverseDepthBuffer: Ct2, skinning: B3.isSkinnedMesh === true, morphTargets: J4.morphAttributes.position !== void 0, morphNormals: J4.morphAttributes.normal !== void 0, morphColors: J4.morphAttributes.color !== void 0, morphTargetsCount: bt2, morphTextureStride: Ot2, numDirLights: S4.directional.length, numPointLights: S4.point.length, numSpotLights: S4.spot.length, numSpotLightMaps: S4.spotLightMap.length, numRectAreaLights: S4.rectArea.length, numHemiLights: S4.hemi.length, numDirLightShadows: S4.directionalShadowMap.length, numPointLightShadows: S4.pointShadowMap.length, numSpotLightShadows: S4.spotShadowMap.length, numSpotLightShadowsWithMaps: S4.numSpotLightShadowsWithMaps, numLightProbes: S4.numLightProbes, numClippingPlanes: a4.numPlanes, numClipIntersection: a4.numIntersection, dithering: E4.dithering, shadowMapEnabled: s5.shadowMap.enabled && P4.length > 0, shadowMapType: s5.shadowMap.type, toneMapping: ce2, decodeVideoTexture: Kt2 && E4.map.isVideoTexture === true && qt$2.getTransfer(E4.map.colorSpace) === ie$2, decodeVideoTextureEmissive: Dt2 && E4.emissiveMap.isVideoTexture === true && qt$2.getTransfer(E4.emissiveMap.colorSpace) === ie$2, premultipliedAlpha: E4.premultipliedAlpha, doubleSided: E4.side === cn$3, flipSided: E4.side === Le$2, useDepthPacking: E4.depthPacking >= 0, depthPacking: E4.depthPacking || 0, index0AttributeName: E4.index0AttributeName, extensionClipCullDistance: zt2 && E4.extensions.clipCullDistance === true && n4.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (zt2 && E4.extensions.multiDraw === true || wt2) && n4.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: n4.has("KHR_parallel_shader_compile"), customProgramCacheKey: E4.customProgramCacheKey() };
    return Me2.vertexUv1s = c.has(1), Me2.vertexUv2s = c.has(2), Me2.vertexUv3s = c.has(3), c.clear(), Me2;
  }
  H$3(g, "getParameters");
  function p4(E4) {
    let S4 = [];
    if (E4.shaderID ? S4.push(E4.shaderID) : (S4.push(E4.customVertexShaderID), S4.push(E4.customFragmentShaderID)), E4.defines !== void 0) for (let P4 in E4.defines) S4.push(P4), S4.push(E4.defines[P4]);
    return E4.isRawShaderMaterial === false && (w3(S4, E4), b(S4, E4), S4.push(s5.outputColorSpace)), S4.push(E4.customProgramCacheKey), S4.join();
  }
  H$3(p4, "getProgramCacheKey");
  function w3(E4, S4) {
    E4.push(S4.precision), E4.push(S4.outputColorSpace), E4.push(S4.envMapMode), E4.push(S4.envMapCubeUVHeight), E4.push(S4.mapUv), E4.push(S4.alphaMapUv), E4.push(S4.lightMapUv), E4.push(S4.aoMapUv), E4.push(S4.bumpMapUv), E4.push(S4.normalMapUv), E4.push(S4.displacementMapUv), E4.push(S4.emissiveMapUv), E4.push(S4.metalnessMapUv), E4.push(S4.roughnessMapUv), E4.push(S4.anisotropyMapUv), E4.push(S4.clearcoatMapUv), E4.push(S4.clearcoatNormalMapUv), E4.push(S4.clearcoatRoughnessMapUv), E4.push(S4.iridescenceMapUv), E4.push(S4.iridescenceThicknessMapUv), E4.push(S4.sheenColorMapUv), E4.push(S4.sheenRoughnessMapUv), E4.push(S4.specularMapUv), E4.push(S4.specularColorMapUv), E4.push(S4.specularIntensityMapUv), E4.push(S4.transmissionMapUv), E4.push(S4.thicknessMapUv), E4.push(S4.combine), E4.push(S4.fogExp2), E4.push(S4.sizeAttenuation), E4.push(S4.morphTargetsCount), E4.push(S4.morphAttributeCount), E4.push(S4.numDirLights), E4.push(S4.numPointLights), E4.push(S4.numSpotLights), E4.push(S4.numSpotLightMaps), E4.push(S4.numHemiLights), E4.push(S4.numRectAreaLights), E4.push(S4.numDirLightShadows), E4.push(S4.numPointLightShadows), E4.push(S4.numSpotLightShadows), E4.push(S4.numSpotLightShadowsWithMaps), E4.push(S4.numLightProbes), E4.push(S4.shadowMapType), E4.push(S4.toneMapping), E4.push(S4.numClippingPlanes), E4.push(S4.numClipIntersection), E4.push(S4.depthPacking);
  }
  H$3(w3, "getProgramCacheKeyParameters");
  function b(E4, S4) {
    o4.disableAll(), S4.supportsVertexTextures && o4.enable(0), S4.instancing && o4.enable(1), S4.instancingColor && o4.enable(2), S4.instancingMorph && o4.enable(3), S4.matcap && o4.enable(4), S4.envMap && o4.enable(5), S4.normalMapObjectSpace && o4.enable(6), S4.normalMapTangentSpace && o4.enable(7), S4.clearcoat && o4.enable(8), S4.iridescence && o4.enable(9), S4.alphaTest && o4.enable(10), S4.vertexColors && o4.enable(11), S4.vertexAlphas && o4.enable(12), S4.vertexUv1s && o4.enable(13), S4.vertexUv2s && o4.enable(14), S4.vertexUv3s && o4.enable(15), S4.vertexTangents && o4.enable(16), S4.anisotropy && o4.enable(17), S4.alphaHash && o4.enable(18), S4.batching && o4.enable(19), S4.dispersion && o4.enable(20), S4.batchingColor && o4.enable(21), E4.push(o4.mask), o4.disableAll(), S4.fog && o4.enable(0), S4.useFog && o4.enable(1), S4.flatShading && o4.enable(2), S4.logarithmicDepthBuffer && o4.enable(3), S4.reverseDepthBuffer && o4.enable(4), S4.skinning && o4.enable(5), S4.morphTargets && o4.enable(6), S4.morphNormals && o4.enable(7), S4.morphColors && o4.enable(8), S4.premultipliedAlpha && o4.enable(9), S4.shadowMapEnabled && o4.enable(10), S4.doubleSided && o4.enable(11), S4.flipSided && o4.enable(12), S4.useDepthPacking && o4.enable(13), S4.dithering && o4.enable(14), S4.transmission && o4.enable(15), S4.sheen && o4.enable(16), S4.opaque && o4.enable(17), S4.pointsUvs && o4.enable(18), S4.decodeVideoTexture && o4.enable(19), S4.decodeVideoTextureEmissive && o4.enable(20), S4.alphaToCoverage && o4.enable(21), E4.push(o4.mask);
  }
  H$3(b, "getProgramCacheKeyBooleans");
  function y4(E4) {
    let S4 = _[E4.type], P4;
    if (S4) {
      let G3 = un$1[S4];
      P4 = Of$1.clone(G3.uniforms);
    } else P4 = E4.uniforms;
    return P4;
  }
  H$3(y4, "getUniforms");
  function D4(E4, S4) {
    let P4;
    for (let G3 = 0, B3 = u5.length; G3 < B3; G3++) {
      let V3 = u5[G3];
      if (V3.cacheKey === S4) {
        P4 = V3, ++P4.usedTimes;
        break;
      }
    }
    return P4 === void 0 && (P4 = new uv$1(s5, S4, E4, r5), u5.push(P4)), P4;
  }
  H$3(D4, "acquireProgram");
  function C3(E4) {
    if (--E4.usedTimes === 0) {
      let S4 = u5.indexOf(E4);
      u5[S4] = u5[u5.length - 1], u5.pop(), E4.destroy();
    }
  }
  H$3(C3, "releaseProgram");
  function R3(E4) {
    l.remove(E4);
  }
  H$3(R3, "releaseShaderCache");
  function L3() {
    l.dispose();
  }
  return H$3(L3, "dispose"), { getParameters: g, getProgramCacheKey: p4, getUniforms: y4, acquireProgram: D4, releaseProgram: C3, releaseShaderCache: R3, programs: u5, dispose: L3 };
}
H$3(fv$1, "WebGLPrograms");
function pv$1() {
  let s5 = /* @__PURE__ */ new WeakMap();
  function t(a4) {
    return s5.has(a4);
  }
  H$3(t, "has");
  function e(a4) {
    let o4 = s5.get(a4);
    return o4 === void 0 && (o4 = {}, s5.set(a4, o4)), o4;
  }
  H$3(e, "get");
  function n4(a4) {
    s5.delete(a4);
  }
  H$3(n4, "remove");
  function i(a4, o4, l) {
    s5.get(a4)[o4] = l;
  }
  H$3(i, "update");
  function r5() {
    s5 = /* @__PURE__ */ new WeakMap();
  }
  return H$3(r5, "dispose"), { has: t, get: e, remove: n4, update: i, dispose: r5 };
}
H$3(pv$1, "WebGLProperties");
function mv$2(s5, t) {
  return s5.groupOrder !== t.groupOrder ? s5.groupOrder - t.groupOrder : s5.renderOrder !== t.renderOrder ? s5.renderOrder - t.renderOrder : s5.material.id !== t.material.id ? s5.material.id - t.material.id : s5.z !== t.z ? s5.z - t.z : s5.id - t.id;
}
H$3(mv$2, "painterSortStable");
function cp$1(s5, t) {
  return s5.groupOrder !== t.groupOrder ? s5.groupOrder - t.groupOrder : s5.renderOrder !== t.renderOrder ? s5.renderOrder - t.renderOrder : s5.z !== t.z ? t.z - s5.z : s5.id - t.id;
}
H$3(cp$1, "reversePainterSortStable");
function hp$1() {
  let s5 = [], t = 0, e = [], n4 = [], i = [];
  function r5() {
    t = 0, e.length = 0, n4.length = 0, i.length = 0;
  }
  H$3(r5, "init");
  function a4(d, f, m5, _, x2, g) {
    let p4 = s5[t];
    return p4 === void 0 ? (p4 = { id: d.id, object: d, geometry: f, material: m5, groupOrder: _, renderOrder: d.renderOrder, z: x2, group: g }, s5[t] = p4) : (p4.id = d.id, p4.object = d, p4.geometry = f, p4.material = m5, p4.groupOrder = _, p4.renderOrder = d.renderOrder, p4.z = x2, p4.group = g), t++, p4;
  }
  H$3(a4, "getNextRenderItem");
  function o4(d, f, m5, _, x2, g) {
    let p4 = a4(d, f, m5, _, x2, g);
    m5.transmission > 0 ? n4.push(p4) : m5.transparent === true ? i.push(p4) : e.push(p4);
  }
  H$3(o4, "push");
  function l(d, f, m5, _, x2, g) {
    let p4 = a4(d, f, m5, _, x2, g);
    m5.transmission > 0 ? n4.unshift(p4) : m5.transparent === true ? i.unshift(p4) : e.unshift(p4);
  }
  H$3(l, "unshift");
  function c(d, f) {
    e.length > 1 && e.sort(d || mv$2), n4.length > 1 && n4.sort(f || cp$1), i.length > 1 && i.sort(f || cp$1);
  }
  H$3(c, "sort");
  function u5() {
    for (let d = t, f = s5.length; d < f; d++) {
      let m5 = s5[d];
      if (m5.id === null) break;
      m5.id = null, m5.object = null, m5.geometry = null, m5.material = null, m5.group = null;
    }
  }
  return H$3(u5, "finish"), { opaque: e, transmissive: n4, transparent: i, init: r5, push: o4, unshift: l, finish: u5, sort: c };
}
H$3(hp$1, "WebGLRenderList");
function gv$1() {
  let s5 = /* @__PURE__ */ new WeakMap();
  function t(n4, i) {
    let r5 = s5.get(n4), a4;
    return r5 === void 0 ? (a4 = new hp$1(), s5.set(n4, [a4])) : i >= r5.length ? (a4 = new hp$1(), r5.push(a4)) : a4 = r5[i], a4;
  }
  H$3(t, "get");
  function e() {
    s5 = /* @__PURE__ */ new WeakMap();
  }
  return H$3(e, "dispose"), { get: t, dispose: e };
}
H$3(gv$1, "WebGLRenderLists");
function _v$1() {
  let s5 = {};
  return { get: H$3(function(t) {
    if (s5[t.id] !== void 0) return s5[t.id];
    let e;
    switch (t.type) {
      case "DirectionalLight":
        e = { direction: new I$1(), color: new Ft$3() };
        break;
      case "SpotLight":
        e = { position: new I$1(), direction: new I$1(), color: new Ft$3(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        e = { position: new I$1(), color: new Ft$3(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        e = { direction: new I$1(), skyColor: new Ft$3(), groundColor: new Ft$3() };
        break;
      case "RectAreaLight":
        e = { color: new Ft$3(), position: new I$1(), halfWidth: new I$1(), halfHeight: new I$1() };
        break;
    }
    return s5[t.id] = e, e;
  }, "get") };
}
H$3(_v$1, "UniformsCache");
function xv$2() {
  let s5 = {};
  return { get: H$3(function(t) {
    if (s5[t.id] !== void 0) return s5[t.id];
    let e;
    switch (t.type) {
      case "DirectionalLight":
        e = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ot$1() };
        break;
      case "SpotLight":
        e = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ot$1() };
        break;
      case "PointLight":
        e = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ot$1(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        break;
    }
    return s5[t.id] = e, e;
  }, "get") };
}
H$3(xv$2, "ShadowUniformsCache");
var vv$1 = 0;
function yv$2(s5, t) {
  return (t.castShadow ? 2 : 0) - (s5.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (s5.map ? 1 : 0);
}
H$3(yv$2, "shadowCastingAndTexturingLightsFirst");
function Mv$2(s5) {
  let t = new _v$1(), e = xv$2(), n4 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
  for (let c = 0; c < 9; c++) n4.probe.push(new I$1());
  let i = new I$1(), r5 = new Vt$2(), a4 = new Vt$2();
  function o4(c) {
    let u5 = 0, d = 0, f = 0;
    for (let E4 = 0; E4 < 9; E4++) n4.probe[E4].set(0, 0, 0);
    let m5 = 0, _ = 0, x2 = 0, g = 0, p4 = 0, w3 = 0, b = 0, y4 = 0, D4 = 0, C3 = 0, R3 = 0;
    c.sort(yv$2);
    for (let E4 = 0, S4 = c.length; E4 < S4; E4++) {
      let P4 = c[E4], G3 = P4.color, B3 = P4.intensity, V3 = P4.distance, J4 = P4.shadow && P4.shadow.map ? P4.shadow.map.texture : null;
      if (P4.isAmbientLight) u5 += G3.r * B3, d += G3.g * B3, f += G3.b * B3;
      else if (P4.isLightProbe) {
        for (let H5 = 0; H5 < 9; H5++) n4.probe[H5].addScaledVector(P4.sh.coefficients[H5], B3);
        R3++;
      } else if (P4.isDirectionalLight) {
        let H5 = t.get(P4);
        if (H5.color.copy(P4.color).multiplyScalar(P4.intensity), P4.castShadow) {
          let it2 = P4.shadow, W4 = e.get(P4);
          W4.shadowIntensity = it2.intensity, W4.shadowBias = it2.bias, W4.shadowNormalBias = it2.normalBias, W4.shadowRadius = it2.radius, W4.shadowMapSize = it2.mapSize, n4.directionalShadow[m5] = W4, n4.directionalShadowMap[m5] = J4, n4.directionalShadowMatrix[m5] = P4.shadow.matrix, w3++;
        }
        n4.directional[m5] = H5, m5++;
      } else if (P4.isSpotLight) {
        let H5 = t.get(P4);
        H5.position.setFromMatrixPosition(P4.matrixWorld), H5.color.copy(G3).multiplyScalar(B3), H5.distance = V3, H5.coneCos = Math.cos(P4.angle), H5.penumbraCos = Math.cos(P4.angle * (1 - P4.penumbra)), H5.decay = P4.decay, n4.spot[x2] = H5;
        let it2 = P4.shadow;
        if (P4.map && (n4.spotLightMap[D4] = P4.map, D4++, it2.updateMatrices(P4), P4.castShadow && C3++), n4.spotLightMatrix[x2] = it2.matrix, P4.castShadow) {
          let W4 = e.get(P4);
          W4.shadowIntensity = it2.intensity, W4.shadowBias = it2.bias, W4.shadowNormalBias = it2.normalBias, W4.shadowRadius = it2.radius, W4.shadowMapSize = it2.mapSize, n4.spotShadow[x2] = W4, n4.spotShadowMap[x2] = J4, y4++;
        }
        x2++;
      } else if (P4.isRectAreaLight) {
        let H5 = t.get(P4);
        H5.color.copy(G3).multiplyScalar(B3), H5.halfWidth.set(P4.width * 0.5, 0, 0), H5.halfHeight.set(0, P4.height * 0.5, 0), n4.rectArea[g] = H5, g++;
      } else if (P4.isPointLight) {
        let H5 = t.get(P4);
        if (H5.color.copy(P4.color).multiplyScalar(P4.intensity), H5.distance = P4.distance, H5.decay = P4.decay, P4.castShadow) {
          let it2 = P4.shadow, W4 = e.get(P4);
          W4.shadowIntensity = it2.intensity, W4.shadowBias = it2.bias, W4.shadowNormalBias = it2.normalBias, W4.shadowRadius = it2.radius, W4.shadowMapSize = it2.mapSize, W4.shadowCameraNear = it2.camera.near, W4.shadowCameraFar = it2.camera.far, n4.pointShadow[_] = W4, n4.pointShadowMap[_] = J4, n4.pointShadowMatrix[_] = P4.shadow.matrix, b++;
        }
        n4.point[_] = H5, _++;
      } else if (P4.isHemisphereLight) {
        let H5 = t.get(P4);
        H5.skyColor.copy(P4.color).multiplyScalar(B3), H5.groundColor.copy(P4.groundColor).multiplyScalar(B3), n4.hemi[p4] = H5, p4++;
      }
    }
    g > 0 && (s5.has("OES_texture_float_linear") === true ? (n4.rectAreaLTC1 = ct$1.LTC_FLOAT_1, n4.rectAreaLTC2 = ct$1.LTC_FLOAT_2) : (n4.rectAreaLTC1 = ct$1.LTC_HALF_1, n4.rectAreaLTC2 = ct$1.LTC_HALF_2)), n4.ambient[0] = u5, n4.ambient[1] = d, n4.ambient[2] = f;
    let L3 = n4.hash;
    (L3.directionalLength !== m5 || L3.pointLength !== _ || L3.spotLength !== x2 || L3.rectAreaLength !== g || L3.hemiLength !== p4 || L3.numDirectionalShadows !== w3 || L3.numPointShadows !== b || L3.numSpotShadows !== y4 || L3.numSpotMaps !== D4 || L3.numLightProbes !== R3) && (n4.directional.length = m5, n4.spot.length = x2, n4.rectArea.length = g, n4.point.length = _, n4.hemi.length = p4, n4.directionalShadow.length = w3, n4.directionalShadowMap.length = w3, n4.pointShadow.length = b, n4.pointShadowMap.length = b, n4.spotShadow.length = y4, n4.spotShadowMap.length = y4, n4.directionalShadowMatrix.length = w3, n4.pointShadowMatrix.length = b, n4.spotLightMatrix.length = y4 + D4 - C3, n4.spotLightMap.length = D4, n4.numSpotLightShadowsWithMaps = C3, n4.numLightProbes = R3, L3.directionalLength = m5, L3.pointLength = _, L3.spotLength = x2, L3.rectAreaLength = g, L3.hemiLength = p4, L3.numDirectionalShadows = w3, L3.numPointShadows = b, L3.numSpotShadows = y4, L3.numSpotMaps = D4, L3.numLightProbes = R3, n4.version = vv$1++);
  }
  H$3(o4, "setup");
  function l(c, u5) {
    let d = 0, f = 0, m5 = 0, _ = 0, x2 = 0, g = u5.matrixWorldInverse;
    for (let p4 = 0, w3 = c.length; p4 < w3; p4++) {
      let b = c[p4];
      if (b.isDirectionalLight) {
        let y4 = n4.directional[d];
        y4.direction.setFromMatrixPosition(b.matrixWorld), i.setFromMatrixPosition(b.target.matrixWorld), y4.direction.sub(i), y4.direction.transformDirection(g), d++;
      } else if (b.isSpotLight) {
        let y4 = n4.spot[m5];
        y4.position.setFromMatrixPosition(b.matrixWorld), y4.position.applyMatrix4(g), y4.direction.setFromMatrixPosition(b.matrixWorld), i.setFromMatrixPosition(b.target.matrixWorld), y4.direction.sub(i), y4.direction.transformDirection(g), m5++;
      } else if (b.isRectAreaLight) {
        let y4 = n4.rectArea[_];
        y4.position.setFromMatrixPosition(b.matrixWorld), y4.position.applyMatrix4(g), a4.identity(), r5.copy(b.matrixWorld), r5.premultiply(g), a4.extractRotation(r5), y4.halfWidth.set(b.width * 0.5, 0, 0), y4.halfHeight.set(0, b.height * 0.5, 0), y4.halfWidth.applyMatrix4(a4), y4.halfHeight.applyMatrix4(a4), _++;
      } else if (b.isPointLight) {
        let y4 = n4.point[f];
        y4.position.setFromMatrixPosition(b.matrixWorld), y4.position.applyMatrix4(g), f++;
      } else if (b.isHemisphereLight) {
        let y4 = n4.hemi[x2];
        y4.direction.setFromMatrixPosition(b.matrixWorld), y4.direction.transformDirection(g), x2++;
      }
    }
  }
  return H$3(l, "setupView"), { setup: o4, setupView: l, state: n4 };
}
H$3(Mv$2, "WebGLLights");
function up$1(s5) {
  let t = new Mv$2(s5), e = [], n4 = [];
  function i(u5) {
    c.camera = u5, e.length = 0, n4.length = 0;
  }
  H$3(i, "init");
  function r5(u5) {
    e.push(u5);
  }
  H$3(r5, "pushLight");
  function a4(u5) {
    n4.push(u5);
  }
  H$3(a4, "pushShadow");
  function o4() {
    t.setup(e);
  }
  H$3(o4, "setupLights");
  function l(u5) {
    t.setupView(e, u5);
  }
  H$3(l, "setupLightsView");
  let c = { lightsArray: e, shadowsArray: n4, camera: null, lights: t, transmissionRenderTarget: {} };
  return { init: i, state: c, setupLights: o4, setupLightsView: l, pushLight: r5, pushShadow: a4 };
}
H$3(up$1, "WebGLRenderState");
function Sv$2(s5) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(i, r5 = 0) {
    let a4 = t.get(i), o4;
    return a4 === void 0 ? (o4 = new up$1(s5), t.set(i, [o4])) : r5 >= a4.length ? (o4 = new up$1(s5), a4.push(o4)) : o4 = a4[r5], o4;
  }
  H$3(e, "get");
  function n4() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return H$3(n4, "dispose"), { get: e, dispose: n4 };
}
H$3(Sv$2, "WebGLRenderStates");
var bv$1 = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", Ev$1 = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function Tv$1(s5, t, e) {
  let n4 = new oi$1(), i = new ot$1(), r5 = new ot$1(), a4 = new $t$3(), o4 = new na$1({ depthPacking: bf$2 }), l = new ia$1(), c = {}, u5 = e.maxTextureSize, d = { [Sn$2]: Le$2, [Le$2]: Sn$2, [cn$3]: cn$3 }, f = new sn$1({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new ot$1() }, radius: { value: 4 } }, vertexShader: bv$1, fragmentShader: Ev$1 }), m5 = f.clone();
  m5.defines.HORIZONTAL_PASS = 1;
  let _ = new pe$3();
  _.setAttribute("position", new ve$3(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  let x2 = new ye$1(_, f), g = this;
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = Ql$2;
  let p4 = this.type;
  this.render = function(C3, R3, L3) {
    if (g.enabled === false || g.autoUpdate === false && g.needsUpdate === false || C3.length === 0) return;
    let E4 = s5.getRenderTarget(), S4 = s5.getActiveCubeFace(), P4 = s5.getActiveMipmapLevel(), G3 = s5.state;
    G3.setBlending(wn$3), G3.buffers.color.setClear(1, 1, 1, 1), G3.buffers.depth.setTest(true), G3.setScissorTest(false);
    let B3 = p4 !== ln && this.type === ln, V3 = p4 === ln && this.type !== ln;
    for (let J4 = 0, H5 = C3.length; J4 < H5; J4++) {
      let it2 = C3[J4], W4 = it2.shadow;
      if (W4 === void 0) {
        console.warn("THREE.WebGLShadowMap:", it2, "has no shadow.");
        continue;
      }
      if (W4.autoUpdate === false && W4.needsUpdate === false) continue;
      i.copy(W4.mapSize);
      let lt2 = W4.getFrameExtents();
      if (i.multiply(lt2), r5.copy(W4.mapSize), (i.x > u5 || i.y > u5) && (i.x > u5 && (r5.x = Math.floor(u5 / lt2.x), i.x = r5.x * lt2.x, W4.mapSize.x = r5.x), i.y > u5 && (r5.y = Math.floor(u5 / lt2.y), i.y = r5.y * lt2.y, W4.mapSize.y = r5.y)), W4.map === null || B3 === true || V3 === true) {
        let bt2 = this.type !== ln ? { minFilter: Fe$2, magFilter: Fe$2 } : {};
        W4.map !== null && W4.map.dispose(), W4.map = new on$3(i.x, i.y, bt2), W4.map.texture.name = it2.name + ".shadowMap", W4.camera.updateProjectionMatrix();
      }
      s5.setRenderTarget(W4.map), s5.clear();
      let gt2 = W4.getViewportCount();
      for (let bt2 = 0; bt2 < gt2; bt2++) {
        let Ot2 = W4.getViewport(bt2);
        a4.set(r5.x * Ot2.x, r5.y * Ot2.y, r5.x * Ot2.z, r5.y * Ot2.w), G3.viewport(a4), W4.updateMatrices(it2, bt2), n4 = W4.getFrustum(), y4(R3, L3, W4.camera, it2, this.type);
      }
      W4.isPointLightShadow !== true && this.type === ln && w3(W4, L3), W4.needsUpdate = false;
    }
    p4 = this.type, g.needsUpdate = false, s5.setRenderTarget(E4, S4, P4);
  };
  function w3(C3, R3) {
    let L3 = t.update(x2);
    f.defines.VSM_SAMPLES !== C3.blurSamples && (f.defines.VSM_SAMPLES = C3.blurSamples, m5.defines.VSM_SAMPLES = C3.blurSamples, f.needsUpdate = true, m5.needsUpdate = true), C3.mapPass === null && (C3.mapPass = new on$3(i.x, i.y)), f.uniforms.shadow_pass.value = C3.map.texture, f.uniforms.resolution.value = C3.mapSize, f.uniforms.radius.value = C3.radius, s5.setRenderTarget(C3.mapPass), s5.clear(), s5.renderBufferDirect(R3, null, L3, f, x2, null), m5.uniforms.shadow_pass.value = C3.mapPass.texture, m5.uniforms.resolution.value = C3.mapSize, m5.uniforms.radius.value = C3.radius, s5.setRenderTarget(C3.map), s5.clear(), s5.renderBufferDirect(R3, null, L3, m5, x2, null);
  }
  H$3(w3, "VSMPass");
  function b(C3, R3, L3, E4) {
    let S4 = null, P4 = L3.isPointLight === true ? C3.customDistanceMaterial : C3.customDepthMaterial;
    if (P4 !== void 0) S4 = P4;
    else if (S4 = L3.isPointLight === true ? l : o4, s5.localClippingEnabled && R3.clipShadows === true && Array.isArray(R3.clippingPlanes) && R3.clippingPlanes.length !== 0 || R3.displacementMap && R3.displacementScale !== 0 || R3.alphaMap && R3.alphaTest > 0 || R3.map && R3.alphaTest > 0) {
      let G3 = S4.uuid, B3 = R3.uuid, V3 = c[G3];
      V3 === void 0 && (V3 = {}, c[G3] = V3);
      let J4 = V3[B3];
      J4 === void 0 && (J4 = S4.clone(), V3[B3] = J4, R3.addEventListener("dispose", D4)), S4 = J4;
    }
    if (S4.visible = R3.visible, S4.wireframe = R3.wireframe, E4 === ln ? S4.side = R3.shadowSide !== null ? R3.shadowSide : R3.side : S4.side = R3.shadowSide !== null ? R3.shadowSide : d[R3.side], S4.alphaMap = R3.alphaMap, S4.alphaTest = R3.alphaTest, S4.map = R3.map, S4.clipShadows = R3.clipShadows, S4.clippingPlanes = R3.clippingPlanes, S4.clipIntersection = R3.clipIntersection, S4.displacementMap = R3.displacementMap, S4.displacementScale = R3.displacementScale, S4.displacementBias = R3.displacementBias, S4.wireframeLinewidth = R3.wireframeLinewidth, S4.linewidth = R3.linewidth, L3.isPointLight === true && S4.isMeshDistanceMaterial === true) {
      let G3 = s5.properties.get(S4);
      G3.light = L3;
    }
    return S4;
  }
  H$3(b, "getDepthMaterial");
  function y4(C3, R3, L3, E4, S4) {
    if (C3.visible === false) return;
    if (C3.layers.test(R3.layers) && (C3.isMesh || C3.isLine || C3.isPoints) && (C3.castShadow || C3.receiveShadow && S4 === ln) && (!C3.frustumCulled || n4.intersectsObject(C3))) {
      C3.modelViewMatrix.multiplyMatrices(L3.matrixWorldInverse, C3.matrixWorld);
      let B3 = t.update(C3), V3 = C3.material;
      if (Array.isArray(V3)) {
        let J4 = B3.groups;
        for (let H5 = 0, it2 = J4.length; H5 < it2; H5++) {
          let W4 = J4[H5], lt2 = V3[W4.materialIndex];
          if (lt2 && lt2.visible) {
            let gt2 = b(C3, lt2, E4, S4);
            C3.onBeforeShadow(s5, C3, R3, L3, B3, gt2, W4), s5.renderBufferDirect(L3, null, B3, gt2, C3, W4), C3.onAfterShadow(s5, C3, R3, L3, B3, gt2, W4);
          }
        }
      } else if (V3.visible) {
        let J4 = b(C3, V3, E4, S4);
        C3.onBeforeShadow(s5, C3, R3, L3, B3, J4, null), s5.renderBufferDirect(L3, null, B3, J4, C3, null), C3.onAfterShadow(s5, C3, R3, L3, B3, J4, null);
      }
    }
    let G3 = C3.children;
    for (let B3 = 0, V3 = G3.length; B3 < V3; B3++) y4(G3[B3], R3, L3, E4, S4);
  }
  H$3(y4, "renderObject");
  function D4(C3) {
    C3.target.removeEventListener("dispose", D4);
    for (let L3 in c) {
      let E4 = c[L3], S4 = C3.target.uuid;
      S4 in E4 && (E4[S4].dispose(), delete E4[S4]);
    }
  }
  H$3(D4, "onMaterialDispose");
}
H$3(Tv$1, "WebGLShadowMap");
var Av$1 = { [wa$2]: Ca$2, [Ra$1]: Da$1, [Ia$2]: La$1, [ii$1]: Pa$1, [Ca$2]: wa$2, [Da$1]: Ra$1, [La$1]: Ia$2, [Pa$1]: ii$1 };
function wv$1(s5, t) {
  function e() {
    let U3 = false, ut2 = new $t$3(), X4 = null, $5 = new $t$3(0, 0, 0, 0);
    return { setMask: H$3(function(mt2) {
      X4 !== mt2 && !U3 && (s5.colorMask(mt2, mt2, mt2, mt2), X4 = mt2);
    }, "setMask"), setLocked: H$3(function(mt2) {
      U3 = mt2;
    }, "setLocked"), setClear: H$3(function(mt2, pt2, zt2, ce2, Me2) {
      Me2 === true && (mt2 *= ce2, pt2 *= ce2, zt2 *= ce2), ut2.set(mt2, pt2, zt2, ce2), $5.equals(ut2) === false && (s5.clearColor(mt2, pt2, zt2, ce2), $5.copy(ut2));
    }, "setClear"), reset: H$3(function() {
      U3 = false, X4 = null, $5.set(-1, 0, 0, 0);
    }, "reset") };
  }
  H$3(e, "ColorBuffer");
  function n4() {
    let U3 = false, ut2 = false, X4 = null, $5 = null, mt2 = null;
    return { setReversed: H$3(function(pt2) {
      if (ut2 !== pt2) {
        let zt2 = t.get("EXT_clip_control");
        ut2 ? zt2.clipControlEXT(zt2.LOWER_LEFT_EXT, zt2.ZERO_TO_ONE_EXT) : zt2.clipControlEXT(zt2.LOWER_LEFT_EXT, zt2.NEGATIVE_ONE_TO_ONE_EXT);
        let ce2 = mt2;
        mt2 = null, this.setClear(ce2);
      }
      ut2 = pt2;
    }, "setReversed"), getReversed: H$3(function() {
      return ut2;
    }, "getReversed"), setTest: H$3(function(pt2) {
      pt2 ? at2(s5.DEPTH_TEST) : Ct2(s5.DEPTH_TEST);
    }, "setTest"), setMask: H$3(function(pt2) {
      X4 !== pt2 && !U3 && (s5.depthMask(pt2), X4 = pt2);
    }, "setMask"), setFunc: H$3(function(pt2) {
      if (ut2 && (pt2 = Av$1[pt2]), $5 !== pt2) {
        switch (pt2) {
          case wa$2:
            s5.depthFunc(s5.NEVER);
            break;
          case Ca$2:
            s5.depthFunc(s5.ALWAYS);
            break;
          case Ra$1:
            s5.depthFunc(s5.LESS);
            break;
          case ii$1:
            s5.depthFunc(s5.LEQUAL);
            break;
          case Ia$2:
            s5.depthFunc(s5.EQUAL);
            break;
          case Pa$1:
            s5.depthFunc(s5.GEQUAL);
            break;
          case Da$1:
            s5.depthFunc(s5.GREATER);
            break;
          case La$1:
            s5.depthFunc(s5.NOTEQUAL);
            break;
          default:
            s5.depthFunc(s5.LEQUAL);
        }
        $5 = pt2;
      }
    }, "setFunc"), setLocked: H$3(function(pt2) {
      U3 = pt2;
    }, "setLocked"), setClear: H$3(function(pt2) {
      mt2 !== pt2 && (ut2 && (pt2 = 1 - pt2), s5.clearDepth(pt2), mt2 = pt2);
    }, "setClear"), reset: H$3(function() {
      U3 = false, X4 = null, $5 = null, mt2 = null, ut2 = false;
    }, "reset") };
  }
  H$3(n4, "DepthBuffer");
  function i() {
    let U3 = false, ut2 = null, X4 = null, $5 = null, mt2 = null, pt2 = null, zt2 = null, ce2 = null, Me2 = null;
    return { setTest: H$3(function(ee2) {
      U3 || (ee2 ? at2(s5.STENCIL_TEST) : Ct2(s5.STENCIL_TEST));
    }, "setTest"), setMask: H$3(function(ee2) {
      ut2 !== ee2 && !U3 && (s5.stencilMask(ee2), ut2 = ee2);
    }, "setMask"), setFunc: H$3(function(ee2, Je2, dn2) {
      (X4 !== ee2 || $5 !== Je2 || mt2 !== dn2) && (s5.stencilFunc(ee2, Je2, dn2), X4 = ee2, $5 = Je2, mt2 = dn2);
    }, "setFunc"), setOp: H$3(function(ee2, Je2, dn2) {
      (pt2 !== ee2 || zt2 !== Je2 || ce2 !== dn2) && (s5.stencilOp(ee2, Je2, dn2), pt2 = ee2, zt2 = Je2, ce2 = dn2);
    }, "setOp"), setLocked: H$3(function(ee2) {
      U3 = ee2;
    }, "setLocked"), setClear: H$3(function(ee2) {
      Me2 !== ee2 && (s5.clearStencil(ee2), Me2 = ee2);
    }, "setClear"), reset: H$3(function() {
      U3 = false, ut2 = null, X4 = null, $5 = null, mt2 = null, pt2 = null, zt2 = null, ce2 = null, Me2 = null;
    }, "reset") };
  }
  H$3(i, "StencilBuffer");
  let r5 = new e(), a4 = new n4(), o4 = new i(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), u5 = {}, d = {}, f = /* @__PURE__ */ new WeakMap(), m5 = [], _ = null, x2 = false, g = null, p4 = null, w3 = null, b = null, y4 = null, D4 = null, C3 = null, R3 = new Ft$3(0, 0, 0), L3 = 0, E4 = false, S4 = null, P4 = null, G3 = null, B3 = null, V3 = null, J4 = s5.getParameter(s5.MAX_COMBINED_TEXTURE_IMAGE_UNITS), H5 = false, it2 = 0, W4 = s5.getParameter(s5.VERSION);
  W4.indexOf("WebGL") !== -1 ? (it2 = parseFloat(/^WebGL (\d)/.exec(W4)[1]), H5 = it2 >= 1) : W4.indexOf("OpenGL ES") !== -1 && (it2 = parseFloat(/^OpenGL ES (\d)/.exec(W4)[1]), H5 = it2 >= 2);
  let lt2 = null, gt2 = {}, bt2 = s5.getParameter(s5.SCISSOR_BOX), Ot2 = s5.getParameter(s5.VIEWPORT), Qt2 = new $t$3().fromArray(bt2), Z4 = new $t$3().fromArray(Ot2);
  function rt2(U3, ut2, X4, $5) {
    let mt2 = new Uint8Array(4), pt2 = s5.createTexture();
    s5.bindTexture(U3, pt2), s5.texParameteri(U3, s5.TEXTURE_MIN_FILTER, s5.NEAREST), s5.texParameteri(U3, s5.TEXTURE_MAG_FILTER, s5.NEAREST);
    for (let zt2 = 0; zt2 < X4; zt2++) U3 === s5.TEXTURE_3D || U3 === s5.TEXTURE_2D_ARRAY ? s5.texImage3D(ut2, 0, s5.RGBA, 1, 1, $5, 0, s5.RGBA, s5.UNSIGNED_BYTE, mt2) : s5.texImage2D(ut2 + zt2, 0, s5.RGBA, 1, 1, 0, s5.RGBA, s5.UNSIGNED_BYTE, mt2);
    return pt2;
  }
  H$3(rt2, "createTexture");
  let Et2 = {};
  Et2[s5.TEXTURE_2D] = rt2(s5.TEXTURE_2D, s5.TEXTURE_2D, 1), Et2[s5.TEXTURE_CUBE_MAP] = rt2(s5.TEXTURE_CUBE_MAP, s5.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Et2[s5.TEXTURE_2D_ARRAY] = rt2(s5.TEXTURE_2D_ARRAY, s5.TEXTURE_2D_ARRAY, 1, 1), Et2[s5.TEXTURE_3D] = rt2(s5.TEXTURE_3D, s5.TEXTURE_3D, 1, 1), r5.setClear(0, 0, 0, 1), a4.setClear(1), o4.setClear(0), at2(s5.DEPTH_TEST), a4.setFunc(ii$1), tt2(false), xt2(Kl$1), at2(s5.CULL_FACE), A3(wn$3);
  function at2(U3) {
    u5[U3] !== true && (s5.enable(U3), u5[U3] = true);
  }
  H$3(at2, "enable");
  function Ct2(U3) {
    u5[U3] !== false && (s5.disable(U3), u5[U3] = false);
  }
  H$3(Ct2, "disable");
  function Yt2(U3, ut2) {
    return d[U3] !== ut2 ? (s5.bindFramebuffer(U3, ut2), d[U3] = ut2, U3 === s5.DRAW_FRAMEBUFFER && (d[s5.FRAMEBUFFER] = ut2), U3 === s5.FRAMEBUFFER && (d[s5.DRAW_FRAMEBUFFER] = ut2), true) : false;
  }
  H$3(Yt2, "bindFramebuffer");
  function wt2(U3, ut2) {
    let X4 = m5, $5 = false;
    if (U3) {
      X4 = f.get(ut2), X4 === void 0 && (X4 = [], f.set(ut2, X4));
      let mt2 = U3.textures;
      if (X4.length !== mt2.length || X4[0] !== s5.COLOR_ATTACHMENT0) {
        for (let pt2 = 0, zt2 = mt2.length; pt2 < zt2; pt2++) X4[pt2] = s5.COLOR_ATTACHMENT0 + pt2;
        X4.length = mt2.length, $5 = true;
      }
    } else X4[0] !== s5.BACK && (X4[0] = s5.BACK, $5 = true);
    $5 && s5.drawBuffers(X4);
  }
  H$3(wt2, "drawBuffers");
  function Kt2(U3) {
    return _ !== U3 ? (s5.useProgram(U3), _ = U3, true) : false;
  }
  H$3(Kt2, "useProgram");
  let j3 = { [Vn$3]: s5.FUNC_ADD, [qd$1]: s5.FUNC_SUBTRACT, [Yd$2]: s5.FUNC_REVERSE_SUBTRACT };
  j3[Zd$1] = s5.MIN, j3[Jd$2] = s5.MAX;
  let Q4 = { [$d$2]: s5.ZERO, [Kd$2]: s5.ONE, [Qd$2]: s5.SRC_COLOR, [Dr$1]: s5.SRC_ALPHA, [rf$2]: s5.SRC_ALPHA_SATURATE, [nf$2]: s5.DST_COLOR, [tf$2]: s5.DST_ALPHA, [jd$2]: s5.ONE_MINUS_SRC_COLOR, [Lr$2]: s5.ONE_MINUS_SRC_ALPHA, [sf$2]: s5.ONE_MINUS_DST_COLOR, [ef$2]: s5.ONE_MINUS_DST_ALPHA, [af$2]: s5.CONSTANT_COLOR, [of$2]: s5.ONE_MINUS_CONSTANT_COLOR, [lf$2]: s5.CONSTANT_ALPHA, [cf$2]: s5.ONE_MINUS_CONSTANT_ALPHA };
  function A3(U3, ut2, X4, $5, mt2, pt2, zt2, ce2, Me2, ee2) {
    if (U3 === wn$3) {
      x2 === true && (Ct2(s5.BLEND), x2 = false);
      return;
    }
    if (x2 === false && (at2(s5.BLEND), x2 = true), U3 !== Xd$1) {
      if (U3 !== g || ee2 !== E4) {
        if ((p4 !== Vn$3 || y4 !== Vn$3) && (s5.blendEquation(s5.FUNC_ADD), p4 = Vn$3, y4 = Vn$3), ee2) switch (U3) {
          case ni$1:
            s5.blendFuncSeparate(s5.ONE, s5.ONE_MINUS_SRC_ALPHA, s5.ONE, s5.ONE_MINUS_SRC_ALPHA);
            break;
          case jl:
            s5.blendFunc(s5.ONE, s5.ONE);
            break;
          case tc$1:
            s5.blendFuncSeparate(s5.ZERO, s5.ONE_MINUS_SRC_COLOR, s5.ZERO, s5.ONE);
            break;
          case ec$1:
            s5.blendFuncSeparate(s5.ZERO, s5.SRC_COLOR, s5.ZERO, s5.SRC_ALPHA);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", U3);
            break;
        }
        else switch (U3) {
          case ni$1:
            s5.blendFuncSeparate(s5.SRC_ALPHA, s5.ONE_MINUS_SRC_ALPHA, s5.ONE, s5.ONE_MINUS_SRC_ALPHA);
            break;
          case jl:
            s5.blendFunc(s5.SRC_ALPHA, s5.ONE);
            break;
          case tc$1:
            s5.blendFuncSeparate(s5.ZERO, s5.ONE_MINUS_SRC_COLOR, s5.ZERO, s5.ONE);
            break;
          case ec$1:
            s5.blendFunc(s5.ZERO, s5.SRC_COLOR);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", U3);
            break;
        }
        w3 = null, b = null, D4 = null, C3 = null, R3.set(0, 0, 0), L3 = 0, g = U3, E4 = ee2;
      }
      return;
    }
    mt2 = mt2 || ut2, pt2 = pt2 || X4, zt2 = zt2 || $5, (ut2 !== p4 || mt2 !== y4) && (s5.blendEquationSeparate(j3[ut2], j3[mt2]), p4 = ut2, y4 = mt2), (X4 !== w3 || $5 !== b || pt2 !== D4 || zt2 !== C3) && (s5.blendFuncSeparate(Q4[X4], Q4[$5], Q4[pt2], Q4[zt2]), w3 = X4, b = $5, D4 = pt2, C3 = zt2), (ce2.equals(R3) === false || Me2 !== L3) && (s5.blendColor(ce2.r, ce2.g, ce2.b, Me2), R3.copy(ce2), L3 = Me2), g = U3, E4 = false;
  }
  H$3(A3, "setBlending");
  function At2(U3, ut2) {
    U3.side === cn$3 ? Ct2(s5.CULL_FACE) : at2(s5.CULL_FACE);
    let X4 = U3.side === Le$2;
    ut2 && (X4 = !X4), tt2(X4), U3.blending === ni$1 && U3.transparent === false ? A3(wn$3) : A3(U3.blending, U3.blendEquation, U3.blendSrc, U3.blendDst, U3.blendEquationAlpha, U3.blendSrcAlpha, U3.blendDstAlpha, U3.blendColor, U3.blendAlpha, U3.premultipliedAlpha), a4.setFunc(U3.depthFunc), a4.setTest(U3.depthTest), a4.setMask(U3.depthWrite), r5.setMask(U3.colorWrite);
    let $5 = U3.stencilWrite;
    o4.setTest($5), $5 && (o4.setMask(U3.stencilWriteMask), o4.setFunc(U3.stencilFunc, U3.stencilRef, U3.stencilFuncMask), o4.setOp(U3.stencilFail, U3.stencilZFail, U3.stencilZPass)), Dt2(U3.polygonOffset, U3.polygonOffsetFactor, U3.polygonOffsetUnits), U3.alphaToCoverage === true ? at2(s5.SAMPLE_ALPHA_TO_COVERAGE) : Ct2(s5.SAMPLE_ALPHA_TO_COVERAGE);
  }
  H$3(At2, "setMaterial");
  function tt2(U3) {
    S4 !== U3 && (U3 ? s5.frontFace(s5.CW) : s5.frontFace(s5.CCW), S4 = U3);
  }
  H$3(tt2, "setFlipSided");
  function xt2(U3) {
    U3 !== Hd ? (at2(s5.CULL_FACE), U3 !== P4 && (U3 === Kl$1 ? s5.cullFace(s5.BACK) : U3 === Gd$2 ? s5.cullFace(s5.FRONT) : s5.cullFace(s5.FRONT_AND_BACK))) : Ct2(s5.CULL_FACE), P4 = U3;
  }
  H$3(xt2, "setCullFace");
  function st2(U3) {
    U3 !== G3 && (H5 && s5.lineWidth(U3), G3 = U3);
  }
  H$3(st2, "setLineWidth");
  function Dt2(U3, ut2, X4) {
    U3 ? (at2(s5.POLYGON_OFFSET_FILL), (B3 !== ut2 || V3 !== X4) && (s5.polygonOffset(ut2, X4), B3 = ut2, V3 = X4)) : Ct2(s5.POLYGON_OFFSET_FILL);
  }
  H$3(Dt2, "setPolygonOffset");
  function ft2(U3) {
    U3 ? at2(s5.SCISSOR_TEST) : Ct2(s5.SCISSOR_TEST);
  }
  H$3(ft2, "setScissorTest");
  function T3(U3) {
    U3 === void 0 && (U3 = s5.TEXTURE0 + J4 - 1), lt2 !== U3 && (s5.activeTexture(U3), lt2 = U3);
  }
  H$3(T3, "activeTexture");
  function v3(U3, ut2, X4) {
    X4 === void 0 && (lt2 === null ? X4 = s5.TEXTURE0 + J4 - 1 : X4 = lt2);
    let $5 = gt2[X4];
    $5 === void 0 && ($5 = { type: void 0, texture: void 0 }, gt2[X4] = $5), ($5.type !== U3 || $5.texture !== ut2) && (lt2 !== X4 && (s5.activeTexture(X4), lt2 = X4), s5.bindTexture(U3, ut2 || Et2[U3]), $5.type = U3, $5.texture = ut2);
  }
  H$3(v3, "bindTexture");
  function O4() {
    let U3 = gt2[lt2];
    U3 !== void 0 && U3.type !== void 0 && (s5.bindTexture(U3.type, null), U3.type = void 0, U3.texture = void 0);
  }
  H$3(O4, "unbindTexture");
  function q4() {
    try {
      s5.compressedTexImage2D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(q4, "compressedTexImage2D");
  function K4() {
    try {
      s5.compressedTexImage3D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(K4, "compressedTexImage3D");
  function Y3() {
    try {
      s5.texSubImage2D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(Y3, "texSubImage2D");
  function Tt2() {
    try {
      s5.texSubImage3D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(Tt2, "texSubImage3D");
  function ht2() {
    try {
      s5.compressedTexSubImage2D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(ht2, "compressedTexSubImage2D");
  function _t2() {
    try {
      s5.compressedTexSubImage3D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(_t2, "compressedTexSubImage3D");
  function Wt2() {
    try {
      s5.texStorage2D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(Wt2, "texStorage2D");
  function nt2() {
    try {
      s5.texStorage3D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(nt2, "texStorage3D");
  function yt2() {
    try {
      s5.texImage2D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(yt2, "texImage2D");
  function Pt3() {
    try {
      s5.texImage3D.apply(s5, arguments);
    } catch (U3) {
      console.error("THREE.WebGLState:", U3);
    }
  }
  H$3(Pt3, "texImage3D");
  function Lt2(U3) {
    Qt2.equals(U3) === false && (s5.scissor(U3.x, U3.y, U3.z, U3.w), Qt2.copy(U3));
  }
  H$3(Lt2, "scissor");
  function Mt2(U3) {
    Z4.equals(U3) === false && (s5.viewport(U3.x, U3.y, U3.z, U3.w), Z4.copy(U3));
  }
  H$3(Mt2, "viewport");
  function Xt2(U3, ut2) {
    let X4 = c.get(ut2);
    X4 === void 0 && (X4 = /* @__PURE__ */ new WeakMap(), c.set(ut2, X4));
    let $5 = X4.get(U3);
    $5 === void 0 && ($5 = s5.getUniformBlockIndex(ut2, U3.name), X4.set(U3, $5));
  }
  H$3(Xt2, "updateUBOMapping");
  function kt2(U3, ut2) {
    let $5 = c.get(ut2).get(U3);
    l.get(ut2) !== $5 && (s5.uniformBlockBinding(ut2, $5, U3.__bindingPointIndex), l.set(ut2, $5));
  }
  H$3(kt2, "uniformBlockBinding");
  function se3() {
    s5.disable(s5.BLEND), s5.disable(s5.CULL_FACE), s5.disable(s5.DEPTH_TEST), s5.disable(s5.POLYGON_OFFSET_FILL), s5.disable(s5.SCISSOR_TEST), s5.disable(s5.STENCIL_TEST), s5.disable(s5.SAMPLE_ALPHA_TO_COVERAGE), s5.blendEquation(s5.FUNC_ADD), s5.blendFunc(s5.ONE, s5.ZERO), s5.blendFuncSeparate(s5.ONE, s5.ZERO, s5.ONE, s5.ZERO), s5.blendColor(0, 0, 0, 0), s5.colorMask(true, true, true, true), s5.clearColor(0, 0, 0, 0), s5.depthMask(true), s5.depthFunc(s5.LESS), a4.setReversed(false), s5.clearDepth(1), s5.stencilMask(4294967295), s5.stencilFunc(s5.ALWAYS, 0, 4294967295), s5.stencilOp(s5.KEEP, s5.KEEP, s5.KEEP), s5.clearStencil(0), s5.cullFace(s5.BACK), s5.frontFace(s5.CCW), s5.polygonOffset(0, 0), s5.activeTexture(s5.TEXTURE0), s5.bindFramebuffer(s5.FRAMEBUFFER, null), s5.bindFramebuffer(s5.DRAW_FRAMEBUFFER, null), s5.bindFramebuffer(s5.READ_FRAMEBUFFER, null), s5.useProgram(null), s5.lineWidth(1), s5.scissor(0, 0, s5.canvas.width, s5.canvas.height), s5.viewport(0, 0, s5.canvas.width, s5.canvas.height), u5 = {}, lt2 = null, gt2 = {}, d = {}, f = /* @__PURE__ */ new WeakMap(), m5 = [], _ = null, x2 = false, g = null, p4 = null, w3 = null, b = null, y4 = null, D4 = null, C3 = null, R3 = new Ft$3(0, 0, 0), L3 = 0, E4 = false, S4 = null, P4 = null, G3 = null, B3 = null, V3 = null, Qt2.set(0, 0, s5.canvas.width, s5.canvas.height), Z4.set(0, 0, s5.canvas.width, s5.canvas.height), r5.reset(), a4.reset(), o4.reset();
  }
  return H$3(se3, "reset"), { buffers: { color: r5, depth: a4, stencil: o4 }, enable: at2, disable: Ct2, bindFramebuffer: Yt2, drawBuffers: wt2, useProgram: Kt2, setBlending: A3, setMaterial: At2, setFlipSided: tt2, setCullFace: xt2, setLineWidth: st2, setPolygonOffset: Dt2, setScissorTest: ft2, activeTexture: T3, bindTexture: v3, unbindTexture: O4, compressedTexImage2D: q4, compressedTexImage3D: K4, texImage2D: yt2, texImage3D: Pt3, updateUBOMapping: Xt2, uniformBlockBinding: kt2, texStorage2D: Wt2, texStorage3D: nt2, texSubImage2D: Y3, texSubImage3D: Tt2, compressedTexSubImage2D: ht2, compressedTexSubImage3D: _t2, scissor: Lt2, viewport: Mt2, reset: se3 };
}
H$3(wv$1, "WebGLState");
function Cv$1(s5, t, e, n4, i, r5, a4) {
  let o4 = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new ot$1(), u5 = /* @__PURE__ */ new WeakMap(), d, f = /* @__PURE__ */ new WeakMap(), m5 = false;
  try {
    m5 = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (T3) {
  }
  function _(T3, v3) {
    return m5 ? new OffscreenCanvas(T3, v3) : Gi$2("canvas");
  }
  H$3(_, "createCanvas");
  function x2(T3, v3, O4) {
    let q4 = 1, K4 = ft2(T3);
    if ((K4.width > O4 || K4.height > O4) && (q4 = O4 / Math.max(K4.width, K4.height)), q4 < 1) if (typeof HTMLImageElement < "u" && T3 instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && T3 instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && T3 instanceof ImageBitmap || typeof VideoFrame < "u" && T3 instanceof VideoFrame) {
      let Y3 = Math.floor(q4 * K4.width), Tt2 = Math.floor(q4 * K4.height);
      d === void 0 && (d = _(Y3, Tt2));
      let ht2 = v3 ? _(Y3, Tt2) : d;
      return ht2.width = Y3, ht2.height = Tt2, ht2.getContext("2d").drawImage(T3, 0, 0, Y3, Tt2), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + K4.width + "x" + K4.height + ") to (" + Y3 + "x" + Tt2 + ")."), ht2;
    } else return "data" in T3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + K4.width + "x" + K4.height + ")."), T3;
    return T3;
  }
  H$3(x2, "resizeImage");
  function g(T3) {
    return T3.generateMipmaps;
  }
  H$3(g, "textureNeedsGenerateMipmaps");
  function p4(T3) {
    s5.generateMipmap(T3);
  }
  H$3(p4, "generateMipmap");
  function w3(T3) {
    return T3.isWebGLCubeRenderTarget ? s5.TEXTURE_CUBE_MAP : T3.isWebGL3DRenderTarget ? s5.TEXTURE_3D : T3.isWebGLArrayRenderTarget || T3.isCompressedArrayTexture ? s5.TEXTURE_2D_ARRAY : s5.TEXTURE_2D;
  }
  H$3(w3, "getTargetType");
  function b(T3, v3, O4, q4, K4 = false) {
    if (T3 !== null) {
      if (s5[T3] !== void 0) return s5[T3];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + T3 + "'");
    }
    let Y3 = v3;
    if (v3 === s5.RED && (O4 === s5.FLOAT && (Y3 = s5.R32F), O4 === s5.HALF_FLOAT && (Y3 = s5.R16F), O4 === s5.UNSIGNED_BYTE && (Y3 = s5.R8)), v3 === s5.RED_INTEGER && (O4 === s5.UNSIGNED_BYTE && (Y3 = s5.R8UI), O4 === s5.UNSIGNED_SHORT && (Y3 = s5.R16UI), O4 === s5.UNSIGNED_INT && (Y3 = s5.R32UI), O4 === s5.BYTE && (Y3 = s5.R8I), O4 === s5.SHORT && (Y3 = s5.R16I), O4 === s5.INT && (Y3 = s5.R32I)), v3 === s5.RG && (O4 === s5.FLOAT && (Y3 = s5.RG32F), O4 === s5.HALF_FLOAT && (Y3 = s5.RG16F), O4 === s5.UNSIGNED_BYTE && (Y3 = s5.RG8)), v3 === s5.RG_INTEGER && (O4 === s5.UNSIGNED_BYTE && (Y3 = s5.RG8UI), O4 === s5.UNSIGNED_SHORT && (Y3 = s5.RG16UI), O4 === s5.UNSIGNED_INT && (Y3 = s5.RG32UI), O4 === s5.BYTE && (Y3 = s5.RG8I), O4 === s5.SHORT && (Y3 = s5.RG16I), O4 === s5.INT && (Y3 = s5.RG32I)), v3 === s5.RGB_INTEGER && (O4 === s5.UNSIGNED_BYTE && (Y3 = s5.RGB8UI), O4 === s5.UNSIGNED_SHORT && (Y3 = s5.RGB16UI), O4 === s5.UNSIGNED_INT && (Y3 = s5.RGB32UI), O4 === s5.BYTE && (Y3 = s5.RGB8I), O4 === s5.SHORT && (Y3 = s5.RGB16I), O4 === s5.INT && (Y3 = s5.RGB32I)), v3 === s5.RGBA_INTEGER && (O4 === s5.UNSIGNED_BYTE && (Y3 = s5.RGBA8UI), O4 === s5.UNSIGNED_SHORT && (Y3 = s5.RGBA16UI), O4 === s5.UNSIGNED_INT && (Y3 = s5.RGBA32UI), O4 === s5.BYTE && (Y3 = s5.RGBA8I), O4 === s5.SHORT && (Y3 = s5.RGBA16I), O4 === s5.INT && (Y3 = s5.RGBA32I)), v3 === s5.RGB && O4 === s5.UNSIGNED_INT_5_9_9_9_REV && (Y3 = s5.RGB9_E5), v3 === s5.RGBA) {
      let Tt2 = K4 ? ms$1 : qt$2.getTransfer(q4);
      O4 === s5.FLOAT && (Y3 = s5.RGBA32F), O4 === s5.HALF_FLOAT && (Y3 = s5.RGBA16F), O4 === s5.UNSIGNED_BYTE && (Y3 = Tt2 === ie$2 ? s5.SRGB8_ALPHA8 : s5.RGBA8), O4 === s5.UNSIGNED_SHORT_4_4_4_4 && (Y3 = s5.RGBA4), O4 === s5.UNSIGNED_SHORT_5_5_5_1 && (Y3 = s5.RGB5_A1);
    }
    return (Y3 === s5.R16F || Y3 === s5.R32F || Y3 === s5.RG16F || Y3 === s5.RG32F || Y3 === s5.RGBA16F || Y3 === s5.RGBA32F) && t.get("EXT_color_buffer_float"), Y3;
  }
  H$3(b, "getInternalFormat");
  function y4(T3, v3) {
    let O4;
    return T3 ? v3 === null || v3 === Rn$1 || v3 === gi$1 ? O4 = s5.DEPTH24_STENCIL8 : v3 === Oe$1 ? O4 = s5.DEPTH32F_STENCIL8 : v3 === Zi$2 && (O4 = s5.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : v3 === null || v3 === Rn$1 || v3 === gi$1 ? O4 = s5.DEPTH_COMPONENT24 : v3 === Oe$1 ? O4 = s5.DEPTH_COMPONENT32F : v3 === Zi$2 && (O4 = s5.DEPTH_COMPONENT16), O4;
  }
  H$3(y4, "getInternalDepthFormat");
  function D4(T3, v3) {
    return g(T3) === true || T3.isFramebufferTexture && T3.minFilter !== Fe$2 && T3.minFilter !== en$1 ? Math.log2(Math.max(v3.width, v3.height)) + 1 : T3.mipmaps !== void 0 && T3.mipmaps.length > 0 ? T3.mipmaps.length : T3.isCompressedTexture && Array.isArray(T3.image) ? v3.mipmaps.length : 1;
  }
  H$3(D4, "getMipLevels");
  function C3(T3) {
    let v3 = T3.target;
    v3.removeEventListener("dispose", C3), L3(v3), v3.isVideoTexture && u5.delete(v3);
  }
  H$3(C3, "onTextureDispose");
  function R3(T3) {
    let v3 = T3.target;
    v3.removeEventListener("dispose", R3), S4(v3);
  }
  H$3(R3, "onRenderTargetDispose");
  function L3(T3) {
    let v3 = n4.get(T3);
    if (v3.__webglInit === void 0) return;
    let O4 = T3.source, q4 = f.get(O4);
    if (q4) {
      let K4 = q4[v3.__cacheKey];
      K4.usedTimes--, K4.usedTimes === 0 && E4(T3), Object.keys(q4).length === 0 && f.delete(O4);
    }
    n4.remove(T3);
  }
  H$3(L3, "deallocateTexture");
  function E4(T3) {
    let v3 = n4.get(T3);
    s5.deleteTexture(v3.__webglTexture);
    let O4 = T3.source, q4 = f.get(O4);
    delete q4[v3.__cacheKey], a4.memory.textures--;
  }
  H$3(E4, "deleteTexture");
  function S4(T3) {
    let v3 = n4.get(T3);
    if (T3.depthTexture && (T3.depthTexture.dispose(), n4.remove(T3.depthTexture)), T3.isWebGLCubeRenderTarget) for (let q4 = 0; q4 < 6; q4++) {
      if (Array.isArray(v3.__webglFramebuffer[q4])) for (let K4 = 0; K4 < v3.__webglFramebuffer[q4].length; K4++) s5.deleteFramebuffer(v3.__webglFramebuffer[q4][K4]);
      else s5.deleteFramebuffer(v3.__webglFramebuffer[q4]);
      v3.__webglDepthbuffer && s5.deleteRenderbuffer(v3.__webglDepthbuffer[q4]);
    }
    else {
      if (Array.isArray(v3.__webglFramebuffer)) for (let q4 = 0; q4 < v3.__webglFramebuffer.length; q4++) s5.deleteFramebuffer(v3.__webglFramebuffer[q4]);
      else s5.deleteFramebuffer(v3.__webglFramebuffer);
      if (v3.__webglDepthbuffer && s5.deleteRenderbuffer(v3.__webglDepthbuffer), v3.__webglMultisampledFramebuffer && s5.deleteFramebuffer(v3.__webglMultisampledFramebuffer), v3.__webglColorRenderbuffer) for (let q4 = 0; q4 < v3.__webglColorRenderbuffer.length; q4++) v3.__webglColorRenderbuffer[q4] && s5.deleteRenderbuffer(v3.__webglColorRenderbuffer[q4]);
      v3.__webglDepthRenderbuffer && s5.deleteRenderbuffer(v3.__webglDepthRenderbuffer);
    }
    let O4 = T3.textures;
    for (let q4 = 0, K4 = O4.length; q4 < K4; q4++) {
      let Y3 = n4.get(O4[q4]);
      Y3.__webglTexture && (s5.deleteTexture(Y3.__webglTexture), a4.memory.textures--), n4.remove(O4[q4]);
    }
    n4.remove(T3);
  }
  H$3(S4, "deallocateRenderTarget");
  let P4 = 0;
  function G3() {
    P4 = 0;
  }
  H$3(G3, "resetTextureUnits");
  function B3() {
    let T3 = P4;
    return T3 >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + T3 + " texture units while this GPU supports only " + i.maxTextures), P4 += 1, T3;
  }
  H$3(B3, "allocateTextureUnit");
  function V3(T3) {
    let v3 = [];
    return v3.push(T3.wrapS), v3.push(T3.wrapT), v3.push(T3.wrapR || 0), v3.push(T3.magFilter), v3.push(T3.minFilter), v3.push(T3.anisotropy), v3.push(T3.internalFormat), v3.push(T3.format), v3.push(T3.type), v3.push(T3.generateMipmaps), v3.push(T3.premultiplyAlpha), v3.push(T3.flipY), v3.push(T3.unpackAlignment), v3.push(T3.colorSpace), v3.join();
  }
  H$3(V3, "getTextureCacheKey");
  function J4(T3, v3) {
    let O4 = n4.get(T3);
    if (T3.isVideoTexture && st2(T3), T3.isRenderTargetTexture === false && T3.version > 0 && O4.__version !== T3.version) {
      let q4 = T3.image;
      if (q4 === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (q4.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Z4(O4, T3, v3);
        return;
      }
    }
    e.bindTexture(s5.TEXTURE_2D, O4.__webglTexture, s5.TEXTURE0 + v3);
  }
  H$3(J4, "setTexture2D");
  function H5(T3, v3) {
    let O4 = n4.get(T3);
    if (T3.version > 0 && O4.__version !== T3.version) {
      Z4(O4, T3, v3);
      return;
    }
    e.bindTexture(s5.TEXTURE_2D_ARRAY, O4.__webglTexture, s5.TEXTURE0 + v3);
  }
  H$3(H5, "setTexture2DArray");
  function it2(T3, v3) {
    let O4 = n4.get(T3);
    if (T3.version > 0 && O4.__version !== T3.version) {
      Z4(O4, T3, v3);
      return;
    }
    e.bindTexture(s5.TEXTURE_3D, O4.__webglTexture, s5.TEXTURE0 + v3);
  }
  H$3(it2, "setTexture3D");
  function W4(T3, v3) {
    let O4 = n4.get(T3);
    if (T3.version > 0 && O4.__version !== T3.version) {
      rt2(O4, T3, v3);
      return;
    }
    e.bindTexture(s5.TEXTURE_CUBE_MAP, O4.__webglTexture, s5.TEXTURE0 + v3);
  }
  H$3(W4, "setTextureCube");
  let lt2 = { [Ur$1]: s5.REPEAT, [zn$2]: s5.CLAMP_TO_EDGE, [Nr$2]: s5.MIRRORED_REPEAT }, gt2 = { [Fe$2]: s5.NEAREST, [yf$2]: s5.NEAREST_MIPMAP_NEAREST, [Hs$1]: s5.NEAREST_MIPMAP_LINEAR, [en$1]: s5.LINEAR, [Oa$1]: s5.LINEAR_MIPMAP_NEAREST, [Wn$1]: s5.LINEAR_MIPMAP_LINEAR }, bt2 = { [Tf$2]: s5.NEVER, [Pf$1]: s5.ALWAYS, [Af$1]: s5.LESS, [dc$2]: s5.LEQUAL, [wf$2]: s5.EQUAL, [If$2]: s5.GEQUAL, [Cf$2]: s5.GREATER, [Rf$1]: s5.NOTEQUAL };
  function Ot2(T3, v3) {
    if (v3.type === Oe$1 && t.has("OES_texture_float_linear") === false && (v3.magFilter === en$1 || v3.magFilter === Oa$1 || v3.magFilter === Hs$1 || v3.magFilter === Wn$1 || v3.minFilter === en$1 || v3.minFilter === Oa$1 || v3.minFilter === Hs$1 || v3.minFilter === Wn$1) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s5.texParameteri(T3, s5.TEXTURE_WRAP_S, lt2[v3.wrapS]), s5.texParameteri(T3, s5.TEXTURE_WRAP_T, lt2[v3.wrapT]), (T3 === s5.TEXTURE_3D || T3 === s5.TEXTURE_2D_ARRAY) && s5.texParameteri(T3, s5.TEXTURE_WRAP_R, lt2[v3.wrapR]), s5.texParameteri(T3, s5.TEXTURE_MAG_FILTER, gt2[v3.magFilter]), s5.texParameteri(T3, s5.TEXTURE_MIN_FILTER, gt2[v3.minFilter]), v3.compareFunction && (s5.texParameteri(T3, s5.TEXTURE_COMPARE_MODE, s5.COMPARE_REF_TO_TEXTURE), s5.texParameteri(T3, s5.TEXTURE_COMPARE_FUNC, bt2[v3.compareFunction])), t.has("EXT_texture_filter_anisotropic") === true) {
      if (v3.magFilter === Fe$2 || v3.minFilter !== Hs$1 && v3.minFilter !== Wn$1 || v3.type === Oe$1 && t.has("OES_texture_float_linear") === false) return;
      if (v3.anisotropy > 1 || n4.get(v3).__currentAnisotropy) {
        let O4 = t.get("EXT_texture_filter_anisotropic");
        s5.texParameterf(T3, O4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(v3.anisotropy, i.getMaxAnisotropy())), n4.get(v3).__currentAnisotropy = v3.anisotropy;
      }
    }
  }
  H$3(Ot2, "setTextureParameters");
  function Qt2(T3, v3) {
    let O4 = false;
    T3.__webglInit === void 0 && (T3.__webglInit = true, v3.addEventListener("dispose", C3));
    let q4 = v3.source, K4 = f.get(q4);
    K4 === void 0 && (K4 = {}, f.set(q4, K4));
    let Y3 = V3(v3);
    if (Y3 !== T3.__cacheKey) {
      K4[Y3] === void 0 && (K4[Y3] = { texture: s5.createTexture(), usedTimes: 0 }, a4.memory.textures++, O4 = true), K4[Y3].usedTimes++;
      let Tt2 = K4[T3.__cacheKey];
      Tt2 !== void 0 && (K4[T3.__cacheKey].usedTimes--, Tt2.usedTimes === 0 && E4(v3)), T3.__cacheKey = Y3, T3.__webglTexture = K4[Y3].texture;
    }
    return O4;
  }
  H$3(Qt2, "initTexture");
  function Z4(T3, v3, O4) {
    let q4 = s5.TEXTURE_2D;
    (v3.isDataArrayTexture || v3.isCompressedArrayTexture) && (q4 = s5.TEXTURE_2D_ARRAY), v3.isData3DTexture && (q4 = s5.TEXTURE_3D);
    let K4 = Qt2(T3, v3), Y3 = v3.source;
    e.bindTexture(q4, T3.__webglTexture, s5.TEXTURE0 + O4);
    let Tt2 = n4.get(Y3);
    if (Y3.version !== Tt2.__version || K4 === true) {
      e.activeTexture(s5.TEXTURE0 + O4);
      let ht2 = qt$2.getPrimaries(qt$2.workingColorSpace), _t2 = v3.colorSpace === In$2 ? null : qt$2.getPrimaries(v3.colorSpace), Wt2 = v3.colorSpace === In$2 || ht2 === _t2 ? s5.NONE : s5.BROWSER_DEFAULT_WEBGL;
      s5.pixelStorei(s5.UNPACK_FLIP_Y_WEBGL, v3.flipY), s5.pixelStorei(s5.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v3.premultiplyAlpha), s5.pixelStorei(s5.UNPACK_ALIGNMENT, v3.unpackAlignment), s5.pixelStorei(s5.UNPACK_COLORSPACE_CONVERSION_WEBGL, Wt2);
      let nt2 = x2(v3.image, false, i.maxTextureSize);
      nt2 = Dt2(v3, nt2);
      let yt2 = r5.convert(v3.format, v3.colorSpace), Pt3 = r5.convert(v3.type), Lt2 = b(v3.internalFormat, yt2, Pt3, v3.colorSpace, v3.isVideoTexture);
      Ot2(q4, v3);
      let Mt2, Xt2 = v3.mipmaps, kt2 = v3.isVideoTexture !== true, se3 = Tt2.__version === void 0 || K4 === true, U3 = Y3.dataReady, ut2 = D4(v3, nt2);
      if (v3.isDepthTexture) Lt2 = y4(v3.format === si$2, v3.type), se3 && (kt2 ? e.texStorage2D(s5.TEXTURE_2D, 1, Lt2, nt2.width, nt2.height) : e.texImage2D(s5.TEXTURE_2D, 0, Lt2, nt2.width, nt2.height, 0, yt2, Pt3, null));
      else if (v3.isDataTexture) if (Xt2.length > 0) {
        kt2 && se3 && e.texStorage2D(s5.TEXTURE_2D, ut2, Lt2, Xt2[0].width, Xt2[0].height);
        for (let X4 = 0, $5 = Xt2.length; X4 < $5; X4++) Mt2 = Xt2[X4], kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_2D, X4, 0, 0, Mt2.width, Mt2.height, yt2, Pt3, Mt2.data) : e.texImage2D(s5.TEXTURE_2D, X4, Lt2, Mt2.width, Mt2.height, 0, yt2, Pt3, Mt2.data);
        v3.generateMipmaps = false;
      } else kt2 ? (se3 && e.texStorage2D(s5.TEXTURE_2D, ut2, Lt2, nt2.width, nt2.height), U3 && e.texSubImage2D(s5.TEXTURE_2D, 0, 0, 0, nt2.width, nt2.height, yt2, Pt3, nt2.data)) : e.texImage2D(s5.TEXTURE_2D, 0, Lt2, nt2.width, nt2.height, 0, yt2, Pt3, nt2.data);
      else if (v3.isCompressedTexture) if (v3.isCompressedArrayTexture) {
        kt2 && se3 && e.texStorage3D(s5.TEXTURE_2D_ARRAY, ut2, Lt2, Xt2[0].width, Xt2[0].height, nt2.depth);
        for (let X4 = 0, $5 = Xt2.length; X4 < $5; X4++) if (Mt2 = Xt2[X4], v3.format !== De$3) if (yt2 !== null) if (kt2) {
          if (U3) if (v3.layerUpdates.size > 0) {
            let mt2 = yc$2(Mt2.width, Mt2.height, v3.format, v3.type);
            for (let pt2 of v3.layerUpdates) {
              let zt2 = Mt2.data.subarray(pt2 * mt2 / Mt2.data.BYTES_PER_ELEMENT, (pt2 + 1) * mt2 / Mt2.data.BYTES_PER_ELEMENT);
              e.compressedTexSubImage3D(s5.TEXTURE_2D_ARRAY, X4, 0, 0, pt2, Mt2.width, Mt2.height, 1, yt2, zt2);
            }
            v3.clearLayerUpdates();
          } else e.compressedTexSubImage3D(s5.TEXTURE_2D_ARRAY, X4, 0, 0, 0, Mt2.width, Mt2.height, nt2.depth, yt2, Mt2.data);
        } else e.compressedTexImage3D(s5.TEXTURE_2D_ARRAY, X4, Lt2, Mt2.width, Mt2.height, nt2.depth, 0, Mt2.data, 0, 0);
        else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
        else kt2 ? U3 && e.texSubImage3D(s5.TEXTURE_2D_ARRAY, X4, 0, 0, 0, Mt2.width, Mt2.height, nt2.depth, yt2, Pt3, Mt2.data) : e.texImage3D(s5.TEXTURE_2D_ARRAY, X4, Lt2, Mt2.width, Mt2.height, nt2.depth, 0, yt2, Pt3, Mt2.data);
      } else {
        kt2 && se3 && e.texStorage2D(s5.TEXTURE_2D, ut2, Lt2, Xt2[0].width, Xt2[0].height);
        for (let X4 = 0, $5 = Xt2.length; X4 < $5; X4++) Mt2 = Xt2[X4], v3.format !== De$3 ? yt2 !== null ? kt2 ? U3 && e.compressedTexSubImage2D(s5.TEXTURE_2D, X4, 0, 0, Mt2.width, Mt2.height, yt2, Mt2.data) : e.compressedTexImage2D(s5.TEXTURE_2D, X4, Lt2, Mt2.width, Mt2.height, 0, Mt2.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_2D, X4, 0, 0, Mt2.width, Mt2.height, yt2, Pt3, Mt2.data) : e.texImage2D(s5.TEXTURE_2D, X4, Lt2, Mt2.width, Mt2.height, 0, yt2, Pt3, Mt2.data);
      }
      else if (v3.isDataArrayTexture) if (kt2) {
        if (se3 && e.texStorage3D(s5.TEXTURE_2D_ARRAY, ut2, Lt2, nt2.width, nt2.height, nt2.depth), U3) if (v3.layerUpdates.size > 0) {
          let X4 = yc$2(nt2.width, nt2.height, v3.format, v3.type);
          for (let $5 of v3.layerUpdates) {
            let mt2 = nt2.data.subarray($5 * X4 / nt2.data.BYTES_PER_ELEMENT, ($5 + 1) * X4 / nt2.data.BYTES_PER_ELEMENT);
            e.texSubImage3D(s5.TEXTURE_2D_ARRAY, 0, 0, 0, $5, nt2.width, nt2.height, 1, yt2, Pt3, mt2);
          }
          v3.clearLayerUpdates();
        } else e.texSubImage3D(s5.TEXTURE_2D_ARRAY, 0, 0, 0, 0, nt2.width, nt2.height, nt2.depth, yt2, Pt3, nt2.data);
      } else e.texImage3D(s5.TEXTURE_2D_ARRAY, 0, Lt2, nt2.width, nt2.height, nt2.depth, 0, yt2, Pt3, nt2.data);
      else if (v3.isData3DTexture) kt2 ? (se3 && e.texStorage3D(s5.TEXTURE_3D, ut2, Lt2, nt2.width, nt2.height, nt2.depth), U3 && e.texSubImage3D(s5.TEXTURE_3D, 0, 0, 0, 0, nt2.width, nt2.height, nt2.depth, yt2, Pt3, nt2.data)) : e.texImage3D(s5.TEXTURE_3D, 0, Lt2, nt2.width, nt2.height, nt2.depth, 0, yt2, Pt3, nt2.data);
      else if (v3.isFramebufferTexture) {
        if (se3) if (kt2) e.texStorage2D(s5.TEXTURE_2D, ut2, Lt2, nt2.width, nt2.height);
        else {
          let X4 = nt2.width, $5 = nt2.height;
          for (let mt2 = 0; mt2 < ut2; mt2++) e.texImage2D(s5.TEXTURE_2D, mt2, Lt2, X4, $5, 0, yt2, Pt3, null), X4 >>= 1, $5 >>= 1;
        }
      } else if (Xt2.length > 0) {
        if (kt2 && se3) {
          let X4 = ft2(Xt2[0]);
          e.texStorage2D(s5.TEXTURE_2D, ut2, Lt2, X4.width, X4.height);
        }
        for (let X4 = 0, $5 = Xt2.length; X4 < $5; X4++) Mt2 = Xt2[X4], kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_2D, X4, 0, 0, yt2, Pt3, Mt2) : e.texImage2D(s5.TEXTURE_2D, X4, Lt2, yt2, Pt3, Mt2);
        v3.generateMipmaps = false;
      } else if (kt2) {
        if (se3) {
          let X4 = ft2(nt2);
          e.texStorage2D(s5.TEXTURE_2D, ut2, Lt2, X4.width, X4.height);
        }
        U3 && e.texSubImage2D(s5.TEXTURE_2D, 0, 0, 0, yt2, Pt3, nt2);
      } else e.texImage2D(s5.TEXTURE_2D, 0, Lt2, yt2, Pt3, nt2);
      g(v3) && p4(q4), Tt2.__version = Y3.version, v3.onUpdate && v3.onUpdate(v3);
    }
    T3.__version = v3.version;
  }
  H$3(Z4, "uploadTexture");
  function rt2(T3, v3, O4) {
    if (v3.image.length !== 6) return;
    let q4 = Qt2(T3, v3), K4 = v3.source;
    e.bindTexture(s5.TEXTURE_CUBE_MAP, T3.__webglTexture, s5.TEXTURE0 + O4);
    let Y3 = n4.get(K4);
    if (K4.version !== Y3.__version || q4 === true) {
      e.activeTexture(s5.TEXTURE0 + O4);
      let Tt2 = qt$2.getPrimaries(qt$2.workingColorSpace), ht2 = v3.colorSpace === In$2 ? null : qt$2.getPrimaries(v3.colorSpace), _t2 = v3.colorSpace === In$2 || Tt2 === ht2 ? s5.NONE : s5.BROWSER_DEFAULT_WEBGL;
      s5.pixelStorei(s5.UNPACK_FLIP_Y_WEBGL, v3.flipY), s5.pixelStorei(s5.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v3.premultiplyAlpha), s5.pixelStorei(s5.UNPACK_ALIGNMENT, v3.unpackAlignment), s5.pixelStorei(s5.UNPACK_COLORSPACE_CONVERSION_WEBGL, _t2);
      let Wt2 = v3.isCompressedTexture || v3.image[0].isCompressedTexture, nt2 = v3.image[0] && v3.image[0].isDataTexture, yt2 = [];
      for (let $5 = 0; $5 < 6; $5++) !Wt2 && !nt2 ? yt2[$5] = x2(v3.image[$5], true, i.maxCubemapSize) : yt2[$5] = nt2 ? v3.image[$5].image : v3.image[$5], yt2[$5] = Dt2(v3, yt2[$5]);
      let Pt3 = yt2[0], Lt2 = r5.convert(v3.format, v3.colorSpace), Mt2 = r5.convert(v3.type), Xt2 = b(v3.internalFormat, Lt2, Mt2, v3.colorSpace), kt2 = v3.isVideoTexture !== true, se3 = Y3.__version === void 0 || q4 === true, U3 = K4.dataReady, ut2 = D4(v3, Pt3);
      Ot2(s5.TEXTURE_CUBE_MAP, v3);
      let X4;
      if (Wt2) {
        kt2 && se3 && e.texStorage2D(s5.TEXTURE_CUBE_MAP, ut2, Xt2, Pt3.width, Pt3.height);
        for (let $5 = 0; $5 < 6; $5++) {
          X4 = yt2[$5].mipmaps;
          for (let mt2 = 0; mt2 < X4.length; mt2++) {
            let pt2 = X4[mt2];
            v3.format !== De$3 ? Lt2 !== null ? kt2 ? U3 && e.compressedTexSubImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2, 0, 0, pt2.width, pt2.height, Lt2, pt2.data) : e.compressedTexImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2, Xt2, pt2.width, pt2.height, 0, pt2.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2, 0, 0, pt2.width, pt2.height, Lt2, Mt2, pt2.data) : e.texImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2, Xt2, pt2.width, pt2.height, 0, Lt2, Mt2, pt2.data);
          }
        }
      } else {
        if (X4 = v3.mipmaps, kt2 && se3) {
          X4.length > 0 && ut2++;
          let $5 = ft2(yt2[0]);
          e.texStorage2D(s5.TEXTURE_CUBE_MAP, ut2, Xt2, $5.width, $5.height);
        }
        for (let $5 = 0; $5 < 6; $5++) if (nt2) {
          kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, 0, 0, 0, yt2[$5].width, yt2[$5].height, Lt2, Mt2, yt2[$5].data) : e.texImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, 0, Xt2, yt2[$5].width, yt2[$5].height, 0, Lt2, Mt2, yt2[$5].data);
          for (let mt2 = 0; mt2 < X4.length; mt2++) {
            let zt2 = X4[mt2].image[$5].image;
            kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2 + 1, 0, 0, zt2.width, zt2.height, Lt2, Mt2, zt2.data) : e.texImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2 + 1, Xt2, zt2.width, zt2.height, 0, Lt2, Mt2, zt2.data);
          }
        } else {
          kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, 0, 0, 0, Lt2, Mt2, yt2[$5]) : e.texImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, 0, Xt2, Lt2, Mt2, yt2[$5]);
          for (let mt2 = 0; mt2 < X4.length; mt2++) {
            let pt2 = X4[mt2];
            kt2 ? U3 && e.texSubImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2 + 1, 0, 0, Lt2, Mt2, pt2.image[$5]) : e.texImage2D(s5.TEXTURE_CUBE_MAP_POSITIVE_X + $5, mt2 + 1, Xt2, Lt2, Mt2, pt2.image[$5]);
          }
        }
      }
      g(v3) && p4(s5.TEXTURE_CUBE_MAP), Y3.__version = K4.version, v3.onUpdate && v3.onUpdate(v3);
    }
    T3.__version = v3.version;
  }
  H$3(rt2, "uploadCubeTexture");
  function Et2(T3, v3, O4, q4, K4, Y3) {
    let Tt2 = r5.convert(O4.format, O4.colorSpace), ht2 = r5.convert(O4.type), _t2 = b(O4.internalFormat, Tt2, ht2, O4.colorSpace), Wt2 = n4.get(v3), nt2 = n4.get(O4);
    if (nt2.__renderTarget = v3, !Wt2.__hasExternalTextures) {
      let yt2 = Math.max(1, v3.width >> Y3), Pt3 = Math.max(1, v3.height >> Y3);
      K4 === s5.TEXTURE_3D || K4 === s5.TEXTURE_2D_ARRAY ? e.texImage3D(K4, Y3, _t2, yt2, Pt3, v3.depth, 0, Tt2, ht2, null) : e.texImage2D(K4, Y3, _t2, yt2, Pt3, 0, Tt2, ht2, null);
    }
    e.bindFramebuffer(s5.FRAMEBUFFER, T3), xt2(v3) ? o4.framebufferTexture2DMultisampleEXT(s5.FRAMEBUFFER, q4, K4, nt2.__webglTexture, 0, tt2(v3)) : (K4 === s5.TEXTURE_2D || K4 >= s5.TEXTURE_CUBE_MAP_POSITIVE_X && K4 <= s5.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s5.framebufferTexture2D(s5.FRAMEBUFFER, q4, K4, nt2.__webglTexture, Y3), e.bindFramebuffer(s5.FRAMEBUFFER, null);
  }
  H$3(Et2, "setupFrameBufferTexture");
  function at2(T3, v3, O4) {
    if (s5.bindRenderbuffer(s5.RENDERBUFFER, T3), v3.depthBuffer) {
      let q4 = v3.depthTexture, K4 = q4 && q4.isDepthTexture ? q4.type : null, Y3 = y4(v3.stencilBuffer, K4), Tt2 = v3.stencilBuffer ? s5.DEPTH_STENCIL_ATTACHMENT : s5.DEPTH_ATTACHMENT, ht2 = tt2(v3);
      xt2(v3) ? o4.renderbufferStorageMultisampleEXT(s5.RENDERBUFFER, ht2, Y3, v3.width, v3.height) : O4 ? s5.renderbufferStorageMultisample(s5.RENDERBUFFER, ht2, Y3, v3.width, v3.height) : s5.renderbufferStorage(s5.RENDERBUFFER, Y3, v3.width, v3.height), s5.framebufferRenderbuffer(s5.FRAMEBUFFER, Tt2, s5.RENDERBUFFER, T3);
    } else {
      let q4 = v3.textures;
      for (let K4 = 0; K4 < q4.length; K4++) {
        let Y3 = q4[K4], Tt2 = r5.convert(Y3.format, Y3.colorSpace), ht2 = r5.convert(Y3.type), _t2 = b(Y3.internalFormat, Tt2, ht2, Y3.colorSpace), Wt2 = tt2(v3);
        O4 && xt2(v3) === false ? s5.renderbufferStorageMultisample(s5.RENDERBUFFER, Wt2, _t2, v3.width, v3.height) : xt2(v3) ? o4.renderbufferStorageMultisampleEXT(s5.RENDERBUFFER, Wt2, _t2, v3.width, v3.height) : s5.renderbufferStorage(s5.RENDERBUFFER, _t2, v3.width, v3.height);
      }
    }
    s5.bindRenderbuffer(s5.RENDERBUFFER, null);
  }
  H$3(at2, "setupRenderBufferStorage");
  function Ct2(T3, v3) {
    if (v3 && v3.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(s5.FRAMEBUFFER, T3), !(v3.depthTexture && v3.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    let q4 = n4.get(v3.depthTexture);
    q4.__renderTarget = v3, (!q4.__webglTexture || v3.depthTexture.image.width !== v3.width || v3.depthTexture.image.height !== v3.height) && (v3.depthTexture.image.width = v3.width, v3.depthTexture.image.height = v3.height, v3.depthTexture.needsUpdate = true), J4(v3.depthTexture, 0);
    let K4 = q4.__webglTexture, Y3 = tt2(v3);
    if (v3.depthTexture.format === ei$2) xt2(v3) ? o4.framebufferTexture2DMultisampleEXT(s5.FRAMEBUFFER, s5.DEPTH_ATTACHMENT, s5.TEXTURE_2D, K4, 0, Y3) : s5.framebufferTexture2D(s5.FRAMEBUFFER, s5.DEPTH_ATTACHMENT, s5.TEXTURE_2D, K4, 0);
    else if (v3.depthTexture.format === si$2) xt2(v3) ? o4.framebufferTexture2DMultisampleEXT(s5.FRAMEBUFFER, s5.DEPTH_STENCIL_ATTACHMENT, s5.TEXTURE_2D, K4, 0, Y3) : s5.framebufferTexture2D(s5.FRAMEBUFFER, s5.DEPTH_STENCIL_ATTACHMENT, s5.TEXTURE_2D, K4, 0);
    else throw new Error("Unknown depthTexture format");
  }
  H$3(Ct2, "setupDepthTexture");
  function Yt2(T3) {
    let v3 = n4.get(T3), O4 = T3.isWebGLCubeRenderTarget === true;
    if (v3.__boundDepthTexture !== T3.depthTexture) {
      let q4 = T3.depthTexture;
      if (v3.__depthDisposeCallback && v3.__depthDisposeCallback(), q4) {
        let K4 = H$3(() => {
          delete v3.__boundDepthTexture, delete v3.__depthDisposeCallback, q4.removeEventListener("dispose", K4);
        }, "disposeEvent");
        q4.addEventListener("dispose", K4), v3.__depthDisposeCallback = K4;
      }
      v3.__boundDepthTexture = q4;
    }
    if (T3.depthTexture && !v3.__autoAllocateDepthBuffer) {
      if (O4) throw new Error("target.depthTexture not supported in Cube render targets");
      Ct2(v3.__webglFramebuffer, T3);
    } else if (O4) {
      v3.__webglDepthbuffer = [];
      for (let q4 = 0; q4 < 6; q4++) if (e.bindFramebuffer(s5.FRAMEBUFFER, v3.__webglFramebuffer[q4]), v3.__webglDepthbuffer[q4] === void 0) v3.__webglDepthbuffer[q4] = s5.createRenderbuffer(), at2(v3.__webglDepthbuffer[q4], T3, false);
      else {
        let K4 = T3.stencilBuffer ? s5.DEPTH_STENCIL_ATTACHMENT : s5.DEPTH_ATTACHMENT, Y3 = v3.__webglDepthbuffer[q4];
        s5.bindRenderbuffer(s5.RENDERBUFFER, Y3), s5.framebufferRenderbuffer(s5.FRAMEBUFFER, K4, s5.RENDERBUFFER, Y3);
      }
    } else if (e.bindFramebuffer(s5.FRAMEBUFFER, v3.__webglFramebuffer), v3.__webglDepthbuffer === void 0) v3.__webglDepthbuffer = s5.createRenderbuffer(), at2(v3.__webglDepthbuffer, T3, false);
    else {
      let q4 = T3.stencilBuffer ? s5.DEPTH_STENCIL_ATTACHMENT : s5.DEPTH_ATTACHMENT, K4 = v3.__webglDepthbuffer;
      s5.bindRenderbuffer(s5.RENDERBUFFER, K4), s5.framebufferRenderbuffer(s5.FRAMEBUFFER, q4, s5.RENDERBUFFER, K4);
    }
    e.bindFramebuffer(s5.FRAMEBUFFER, null);
  }
  H$3(Yt2, "setupDepthRenderbuffer");
  function wt2(T3, v3, O4) {
    let q4 = n4.get(T3);
    v3 !== void 0 && Et2(q4.__webglFramebuffer, T3, T3.texture, s5.COLOR_ATTACHMENT0, s5.TEXTURE_2D, 0), O4 !== void 0 && Yt2(T3);
  }
  H$3(wt2, "rebindTextures");
  function Kt2(T3) {
    let v3 = T3.texture, O4 = n4.get(T3), q4 = n4.get(v3);
    T3.addEventListener("dispose", R3);
    let K4 = T3.textures, Y3 = T3.isWebGLCubeRenderTarget === true, Tt2 = K4.length > 1;
    if (Tt2 || (q4.__webglTexture === void 0 && (q4.__webglTexture = s5.createTexture()), q4.__version = v3.version, a4.memory.textures++), Y3) {
      O4.__webglFramebuffer = [];
      for (let ht2 = 0; ht2 < 6; ht2++) if (v3.mipmaps && v3.mipmaps.length > 0) {
        O4.__webglFramebuffer[ht2] = [];
        for (let _t2 = 0; _t2 < v3.mipmaps.length; _t2++) O4.__webglFramebuffer[ht2][_t2] = s5.createFramebuffer();
      } else O4.__webglFramebuffer[ht2] = s5.createFramebuffer();
    } else {
      if (v3.mipmaps && v3.mipmaps.length > 0) {
        O4.__webglFramebuffer = [];
        for (let ht2 = 0; ht2 < v3.mipmaps.length; ht2++) O4.__webglFramebuffer[ht2] = s5.createFramebuffer();
      } else O4.__webglFramebuffer = s5.createFramebuffer();
      if (Tt2) for (let ht2 = 0, _t2 = K4.length; ht2 < _t2; ht2++) {
        let Wt2 = n4.get(K4[ht2]);
        Wt2.__webglTexture === void 0 && (Wt2.__webglTexture = s5.createTexture(), a4.memory.textures++);
      }
      if (T3.samples > 0 && xt2(T3) === false) {
        O4.__webglMultisampledFramebuffer = s5.createFramebuffer(), O4.__webglColorRenderbuffer = [], e.bindFramebuffer(s5.FRAMEBUFFER, O4.__webglMultisampledFramebuffer);
        for (let ht2 = 0; ht2 < K4.length; ht2++) {
          let _t2 = K4[ht2];
          O4.__webglColorRenderbuffer[ht2] = s5.createRenderbuffer(), s5.bindRenderbuffer(s5.RENDERBUFFER, O4.__webglColorRenderbuffer[ht2]);
          let Wt2 = r5.convert(_t2.format, _t2.colorSpace), nt2 = r5.convert(_t2.type), yt2 = b(_t2.internalFormat, Wt2, nt2, _t2.colorSpace, T3.isXRRenderTarget === true), Pt3 = tt2(T3);
          s5.renderbufferStorageMultisample(s5.RENDERBUFFER, Pt3, yt2, T3.width, T3.height), s5.framebufferRenderbuffer(s5.FRAMEBUFFER, s5.COLOR_ATTACHMENT0 + ht2, s5.RENDERBUFFER, O4.__webglColorRenderbuffer[ht2]);
        }
        s5.bindRenderbuffer(s5.RENDERBUFFER, null), T3.depthBuffer && (O4.__webglDepthRenderbuffer = s5.createRenderbuffer(), at2(O4.__webglDepthRenderbuffer, T3, true)), e.bindFramebuffer(s5.FRAMEBUFFER, null);
      }
    }
    if (Y3) {
      e.bindTexture(s5.TEXTURE_CUBE_MAP, q4.__webglTexture), Ot2(s5.TEXTURE_CUBE_MAP, v3);
      for (let ht2 = 0; ht2 < 6; ht2++) if (v3.mipmaps && v3.mipmaps.length > 0) for (let _t2 = 0; _t2 < v3.mipmaps.length; _t2++) Et2(O4.__webglFramebuffer[ht2][_t2], T3, v3, s5.COLOR_ATTACHMENT0, s5.TEXTURE_CUBE_MAP_POSITIVE_X + ht2, _t2);
      else Et2(O4.__webglFramebuffer[ht2], T3, v3, s5.COLOR_ATTACHMENT0, s5.TEXTURE_CUBE_MAP_POSITIVE_X + ht2, 0);
      g(v3) && p4(s5.TEXTURE_CUBE_MAP), e.unbindTexture();
    } else if (Tt2) {
      for (let ht2 = 0, _t2 = K4.length; ht2 < _t2; ht2++) {
        let Wt2 = K4[ht2], nt2 = n4.get(Wt2);
        e.bindTexture(s5.TEXTURE_2D, nt2.__webglTexture), Ot2(s5.TEXTURE_2D, Wt2), Et2(O4.__webglFramebuffer, T3, Wt2, s5.COLOR_ATTACHMENT0 + ht2, s5.TEXTURE_2D, 0), g(Wt2) && p4(s5.TEXTURE_2D);
      }
      e.unbindTexture();
    } else {
      let ht2 = s5.TEXTURE_2D;
      if ((T3.isWebGL3DRenderTarget || T3.isWebGLArrayRenderTarget) && (ht2 = T3.isWebGL3DRenderTarget ? s5.TEXTURE_3D : s5.TEXTURE_2D_ARRAY), e.bindTexture(ht2, q4.__webglTexture), Ot2(ht2, v3), v3.mipmaps && v3.mipmaps.length > 0) for (let _t2 = 0; _t2 < v3.mipmaps.length; _t2++) Et2(O4.__webglFramebuffer[_t2], T3, v3, s5.COLOR_ATTACHMENT0, ht2, _t2);
      else Et2(O4.__webglFramebuffer, T3, v3, s5.COLOR_ATTACHMENT0, ht2, 0);
      g(v3) && p4(ht2), e.unbindTexture();
    }
    T3.depthBuffer && Yt2(T3);
  }
  H$3(Kt2, "setupRenderTarget");
  function j3(T3) {
    let v3 = T3.textures;
    for (let O4 = 0, q4 = v3.length; O4 < q4; O4++) {
      let K4 = v3[O4];
      if (g(K4)) {
        let Y3 = w3(T3), Tt2 = n4.get(K4).__webglTexture;
        e.bindTexture(Y3, Tt2), p4(Y3), e.unbindTexture();
      }
    }
  }
  H$3(j3, "updateRenderTargetMipmap");
  let Q4 = [], A3 = [];
  function At2(T3) {
    if (T3.samples > 0) {
      if (xt2(T3) === false) {
        let v3 = T3.textures, O4 = T3.width, q4 = T3.height, K4 = s5.COLOR_BUFFER_BIT, Y3 = T3.stencilBuffer ? s5.DEPTH_STENCIL_ATTACHMENT : s5.DEPTH_ATTACHMENT, Tt2 = n4.get(T3), ht2 = v3.length > 1;
        if (ht2) for (let _t2 = 0; _t2 < v3.length; _t2++) e.bindFramebuffer(s5.FRAMEBUFFER, Tt2.__webglMultisampledFramebuffer), s5.framebufferRenderbuffer(s5.FRAMEBUFFER, s5.COLOR_ATTACHMENT0 + _t2, s5.RENDERBUFFER, null), e.bindFramebuffer(s5.FRAMEBUFFER, Tt2.__webglFramebuffer), s5.framebufferTexture2D(s5.DRAW_FRAMEBUFFER, s5.COLOR_ATTACHMENT0 + _t2, s5.TEXTURE_2D, null, 0);
        e.bindFramebuffer(s5.READ_FRAMEBUFFER, Tt2.__webglMultisampledFramebuffer), e.bindFramebuffer(s5.DRAW_FRAMEBUFFER, Tt2.__webglFramebuffer);
        for (let _t2 = 0; _t2 < v3.length; _t2++) {
          if (T3.resolveDepthBuffer && (T3.depthBuffer && (K4 |= s5.DEPTH_BUFFER_BIT), T3.stencilBuffer && T3.resolveStencilBuffer && (K4 |= s5.STENCIL_BUFFER_BIT)), ht2) {
            s5.framebufferRenderbuffer(s5.READ_FRAMEBUFFER, s5.COLOR_ATTACHMENT0, s5.RENDERBUFFER, Tt2.__webglColorRenderbuffer[_t2]);
            let Wt2 = n4.get(v3[_t2]).__webglTexture;
            s5.framebufferTexture2D(s5.DRAW_FRAMEBUFFER, s5.COLOR_ATTACHMENT0, s5.TEXTURE_2D, Wt2, 0);
          }
          s5.blitFramebuffer(0, 0, O4, q4, 0, 0, O4, q4, K4, s5.NEAREST), l === true && (Q4.length = 0, A3.length = 0, Q4.push(s5.COLOR_ATTACHMENT0 + _t2), T3.depthBuffer && T3.resolveDepthBuffer === false && (Q4.push(Y3), A3.push(Y3), s5.invalidateFramebuffer(s5.DRAW_FRAMEBUFFER, A3)), s5.invalidateFramebuffer(s5.READ_FRAMEBUFFER, Q4));
        }
        if (e.bindFramebuffer(s5.READ_FRAMEBUFFER, null), e.bindFramebuffer(s5.DRAW_FRAMEBUFFER, null), ht2) for (let _t2 = 0; _t2 < v3.length; _t2++) {
          e.bindFramebuffer(s5.FRAMEBUFFER, Tt2.__webglMultisampledFramebuffer), s5.framebufferRenderbuffer(s5.FRAMEBUFFER, s5.COLOR_ATTACHMENT0 + _t2, s5.RENDERBUFFER, Tt2.__webglColorRenderbuffer[_t2]);
          let Wt2 = n4.get(v3[_t2]).__webglTexture;
          e.bindFramebuffer(s5.FRAMEBUFFER, Tt2.__webglFramebuffer), s5.framebufferTexture2D(s5.DRAW_FRAMEBUFFER, s5.COLOR_ATTACHMENT0 + _t2, s5.TEXTURE_2D, Wt2, 0);
        }
        e.bindFramebuffer(s5.DRAW_FRAMEBUFFER, Tt2.__webglMultisampledFramebuffer);
      } else if (T3.depthBuffer && T3.resolveDepthBuffer === false && l) {
        let v3 = T3.stencilBuffer ? s5.DEPTH_STENCIL_ATTACHMENT : s5.DEPTH_ATTACHMENT;
        s5.invalidateFramebuffer(s5.DRAW_FRAMEBUFFER, [v3]);
      }
    }
  }
  H$3(At2, "updateMultisampleRenderTarget");
  function tt2(T3) {
    return Math.min(i.maxSamples, T3.samples);
  }
  H$3(tt2, "getRenderTargetSamples");
  function xt2(T3) {
    let v3 = n4.get(T3);
    return T3.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === true && v3.__useRenderToTexture !== false;
  }
  H$3(xt2, "useMultisampledRTT");
  function st2(T3) {
    let v3 = a4.render.frame;
    u5.get(T3) !== v3 && (u5.set(T3, v3), T3.update());
  }
  H$3(st2, "updateVideoTexture");
  function Dt2(T3, v3) {
    let O4 = T3.colorSpace, q4 = T3.format, K4 = T3.type;
    return T3.isCompressedTexture === true || T3.isVideoTexture === true || O4 !== ri$1 && O4 !== In$2 && (qt$2.getTransfer(O4) === ie$2 ? (q4 !== De$3 || K4 !== hn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", O4)), v3;
  }
  H$3(Dt2, "verifyColorSpace");
  function ft2(T3) {
    return typeof HTMLImageElement < "u" && T3 instanceof HTMLImageElement ? (c.width = T3.naturalWidth || T3.width, c.height = T3.naturalHeight || T3.height) : typeof VideoFrame < "u" && T3 instanceof VideoFrame ? (c.width = T3.displayWidth, c.height = T3.displayHeight) : (c.width = T3.width, c.height = T3.height), c;
  }
  H$3(ft2, "getDimensions"), this.allocateTextureUnit = B3, this.resetTextureUnits = G3, this.setTexture2D = J4, this.setTexture2DArray = H5, this.setTexture3D = it2, this.setTextureCube = W4, this.rebindTextures = wt2, this.setupRenderTarget = Kt2, this.updateRenderTargetMipmap = j3, this.updateMultisampleRenderTarget = At2, this.setupDepthRenderbuffer = Yt2, this.setupFrameBufferTexture = Et2, this.useMultisampledRTT = xt2;
}
H$3(Cv$1, "WebGLTextures");
function Rv$1(s5, t) {
  function e(n4, i = In$2) {
    let r5, a4 = qt$2.getTransfer(i);
    if (n4 === hn) return s5.UNSIGNED_BYTE;
    if (n4 === za$1) return s5.UNSIGNED_SHORT_4_4_4_4;
    if (n4 === ka$1) return s5.UNSIGNED_SHORT_5_5_5_1;
    if (n4 === rc$1) return s5.UNSIGNED_INT_5_9_9_9_REV;
    if (n4 === ic$1) return s5.BYTE;
    if (n4 === sc$1) return s5.SHORT;
    if (n4 === Zi$2) return s5.UNSIGNED_SHORT;
    if (n4 === Ba$1) return s5.INT;
    if (n4 === Rn$1) return s5.UNSIGNED_INT;
    if (n4 === Oe$1) return s5.FLOAT;
    if (n4 === Ji$1) return s5.HALF_FLOAT;
    if (n4 === ac$1) return s5.ALPHA;
    if (n4 === oc$1) return s5.RGB;
    if (n4 === De$3) return s5.RGBA;
    if (n4 === lc$1) return s5.LUMINANCE;
    if (n4 === cc$1) return s5.LUMINANCE_ALPHA;
    if (n4 === ei$2) return s5.DEPTH_COMPONENT;
    if (n4 === si$2) return s5.DEPTH_STENCIL;
    if (n4 === Va$1) return s5.RED;
    if (n4 === Gs$2) return s5.RED_INTEGER;
    if (n4 === hc$2) return s5.RG;
    if (n4 === Ha$1) return s5.RG_INTEGER;
    if (n4 === Ga$1) return s5.RGBA_INTEGER;
    if (n4 === Ws$1 || n4 === Xs$1 || n4 === qs$1 || n4 === Ys$1) if (a4 === ie$2) if (r5 = t.get("WEBGL_compressed_texture_s3tc_srgb"), r5 !== null) {
      if (n4 === Ws$1) return r5.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      if (n4 === Xs$1) return r5.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      if (n4 === qs$1) return r5.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
      if (n4 === Ys$1) return r5.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    } else return null;
    else if (r5 = t.get("WEBGL_compressed_texture_s3tc"), r5 !== null) {
      if (n4 === Ws$1) return r5.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (n4 === Xs$1) return r5.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (n4 === qs$1) return r5.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (n4 === Ys$1) return r5.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    } else return null;
    if (n4 === Wa$1 || n4 === Xa$1 || n4 === qa$2 || n4 === Ya$1) if (r5 = t.get("WEBGL_compressed_texture_pvrtc"), r5 !== null) {
      if (n4 === Wa$1) return r5.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (n4 === Xa$1) return r5.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (n4 === qa$2) return r5.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (n4 === Ya$1) return r5.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    } else return null;
    if (n4 === Za$2 || n4 === Ja$1 || n4 === $a$1) if (r5 = t.get("WEBGL_compressed_texture_etc"), r5 !== null) {
      if (n4 === Za$2 || n4 === Ja$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ETC2 : r5.COMPRESSED_RGB8_ETC2;
      if (n4 === $a$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r5.COMPRESSED_RGBA8_ETC2_EAC;
    } else return null;
    if (n4 === Ka$2 || n4 === Qa$2 || n4 === ja$1 || n4 === to$1 || n4 === eo$1 || n4 === no$1 || n4 === io$1 || n4 === so$1 || n4 === ro$1 || n4 === ao$2 || n4 === oo$1 || n4 === lo$2 || n4 === co$1 || n4 === ho$1) if (r5 = t.get("WEBGL_compressed_texture_astc"), r5 !== null) {
      if (n4 === Ka$2) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r5.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (n4 === Qa$2) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r5.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (n4 === ja$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r5.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (n4 === to$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r5.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (n4 === eo$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r5.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (n4 === no$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r5.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (n4 === io$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r5.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (n4 === so$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r5.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (n4 === ro$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r5.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (n4 === ao$2) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r5.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (n4 === oo$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r5.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (n4 === lo$2) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r5.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (n4 === co$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r5.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (n4 === ho$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r5.COMPRESSED_RGBA_ASTC_12x12_KHR;
    } else return null;
    if (n4 === Zs$1 || n4 === uo$2 || n4 === fo$1) if (r5 = t.get("EXT_texture_compression_bptc"), r5 !== null) {
      if (n4 === Zs$1) return a4 === ie$2 ? r5.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r5.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      if (n4 === uo$2) return r5.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
      if (n4 === fo$1) return r5.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
    } else return null;
    if (n4 === uc$1 || n4 === po$1 || n4 === mo$1 || n4 === go$1) if (r5 = t.get("EXT_texture_compression_rgtc"), r5 !== null) {
      if (n4 === Zs$1) return r5.COMPRESSED_RED_RGTC1_EXT;
      if (n4 === po$1) return r5.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (n4 === mo$1) return r5.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (n4 === go$1) return r5.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    } else return null;
    return n4 === gi$1 ? s5.UNSIGNED_INT_24_8 : s5[n4] !== void 0 ? s5[n4] : null;
  }
  return H$3(e, "convert"), { convert: e };
}
H$3(Rv$1, "WebGLUtils");
var Iv$2 = "\nvoid main() {\n\n	gl_Position = vec4( position, 1.0 );\n\n}", Pv$2 = "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n	if ( coord.x >= 1.0 ) {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n	} else {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n	}\n\n}", ku$2 = class ku {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(t, e, n4) {
    if (this.texture === null) {
      let i = new we$2(), r5 = t.properties.get(i);
      r5.__webglTexture = e.texture, (e.depthNear !== n4.depthNear || e.depthFar !== n4.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = i;
    }
  }
  getMesh(t) {
    if (this.texture !== null && this.mesh === null) {
      let e = t.cameras[0].viewport, n4 = new sn$1({ vertexShader: Iv$2, fragmentShader: Pv$2, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: e.z }, depthHeight: { value: e.w } } });
      this.mesh = new ye$1(new Os$2(20, 20), n4);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
};
H$3(ku$2, "WebXRDepthSensing");
var Iu$2 = ku$2, Vu$2 = class Vu extends bn$2 {
  constructor(t, e) {
    super();
    let n4 = this, i = null, r5 = 1, a4 = null, o4 = "local-floor", l = 1, c = null, u5 = null, d = null, f = null, m5 = null, _ = null, x2 = new Iu$2(), g = e.getContextAttributes(), p4 = null, w3 = null, b = [], y4 = [], D4 = new ot$1(), C3 = null, R3 = new Te$1();
    R3.viewport = new $t$3();
    let L3 = new Te$1();
    L3.viewport = new $t$3();
    let E4 = [R3, L3], S4 = new ha$2(), P4 = null, G3 = null;
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(Z4) {
      let rt2 = b[Z4];
      return rt2 === void 0 && (rt2 = new qi$2(), b[Z4] = rt2), rt2.getTargetRaySpace();
    }, this.getControllerGrip = function(Z4) {
      let rt2 = b[Z4];
      return rt2 === void 0 && (rt2 = new qi$2(), b[Z4] = rt2), rt2.getGripSpace();
    }, this.getHand = function(Z4) {
      let rt2 = b[Z4];
      return rt2 === void 0 && (rt2 = new qi$2(), b[Z4] = rt2), rt2.getHandSpace();
    };
    function B3(Z4) {
      let rt2 = y4.indexOf(Z4.inputSource);
      if (rt2 === -1) return;
      let Et2 = b[rt2];
      Et2 !== void 0 && (Et2.update(Z4.inputSource, Z4.frame, c || a4), Et2.dispatchEvent({ type: Z4.type, data: Z4.inputSource }));
    }
    H$3(B3, "onSessionEvent");
    function V3() {
      i.removeEventListener("select", B3), i.removeEventListener("selectstart", B3), i.removeEventListener("selectend", B3), i.removeEventListener("squeeze", B3), i.removeEventListener("squeezestart", B3), i.removeEventListener("squeezeend", B3), i.removeEventListener("end", V3), i.removeEventListener("inputsourceschange", J4);
      for (let Z4 = 0; Z4 < b.length; Z4++) {
        let rt2 = y4[Z4];
        rt2 !== null && (y4[Z4] = null, b[Z4].disconnect(rt2));
      }
      P4 = null, G3 = null, x2.reset(), t.setRenderTarget(p4), m5 = null, f = null, d = null, i = null, w3 = null, Qt2.stop(), n4.isPresenting = false, t.setPixelRatio(C3), t.setSize(D4.width, D4.height, false), n4.dispatchEvent({ type: "sessionend" });
    }
    H$3(V3, "onSessionEnd"), this.setFramebufferScaleFactor = function(Z4) {
      r5 = Z4, n4.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(Z4) {
      o4 = Z4, n4.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return c || a4;
    }, this.setReferenceSpace = function(Z4) {
      c = Z4;
    }, this.getBaseLayer = function() {
      return f !== null ? f : m5;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return _;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(Z4) {
      if (i = Z4, i !== null) {
        if (p4 = t.getRenderTarget(), i.addEventListener("select", B3), i.addEventListener("selectstart", B3), i.addEventListener("selectend", B3), i.addEventListener("squeeze", B3), i.addEventListener("squeezestart", B3), i.addEventListener("squeezeend", B3), i.addEventListener("end", V3), i.addEventListener("inputsourceschange", J4), g.xrCompatible !== true && await e.makeXRCompatible(), C3 = t.getPixelRatio(), t.getSize(D4), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
          let Et2 = null, at2 = null, Ct2 = null;
          g.depth && (Ct2 = g.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, Et2 = g.stencil ? si$2 : ei$2, at2 = g.stencil ? gi$1 : Rn$1);
          let Yt2 = { colorFormat: e.RGBA8, depthFormat: Ct2, scaleFactor: r5 };
          d = new XRWebGLBinding(i, e), f = d.createProjectionLayer(Yt2), i.updateRenderState({ layers: [f] }), t.setPixelRatio(1), t.setSize(f.textureWidth, f.textureHeight, false), w3 = new on$3(f.textureWidth, f.textureHeight, { format: De$3, type: hn, depthTexture: new ws$2(f.textureWidth, f.textureHeight, at2, void 0, void 0, void 0, void 0, void 0, void 0, Et2), stencilBuffer: g.stencil, colorSpace: t.outputColorSpace, samples: g.antialias ? 4 : 0, resolveDepthBuffer: f.ignoreDepthValues === false });
        } else {
          let Et2 = { antialias: g.antialias, alpha: true, depth: g.depth, stencil: g.stencil, framebufferScaleFactor: r5 };
          m5 = new XRWebGLLayer(i, e, Et2), i.updateRenderState({ baseLayer: m5 }), t.setPixelRatio(1), t.setSize(m5.framebufferWidth, m5.framebufferHeight, false), w3 = new on$3(m5.framebufferWidth, m5.framebufferHeight, { format: De$3, type: hn, colorSpace: t.outputColorSpace, stencilBuffer: g.stencil });
        }
        w3.isXRRenderTarget = true, this.setFoveation(l), c = null, a4 = await i.requestReferenceSpace(o4), Qt2.setContext(i), Qt2.start(), n4.isPresenting = true, n4.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null) return i.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return x2.getDepthTexture();
    };
    function J4(Z4) {
      for (let rt2 = 0; rt2 < Z4.removed.length; rt2++) {
        let Et2 = Z4.removed[rt2], at2 = y4.indexOf(Et2);
        at2 >= 0 && (y4[at2] = null, b[at2].disconnect(Et2));
      }
      for (let rt2 = 0; rt2 < Z4.added.length; rt2++) {
        let Et2 = Z4.added[rt2], at2 = y4.indexOf(Et2);
        if (at2 === -1) {
          for (let Yt2 = 0; Yt2 < b.length; Yt2++) if (Yt2 >= y4.length) {
            y4.push(Et2), at2 = Yt2;
            break;
          } else if (y4[Yt2] === null) {
            y4[Yt2] = Et2, at2 = Yt2;
            break;
          }
          if (at2 === -1) break;
        }
        let Ct2 = b[at2];
        Ct2 && Ct2.connect(Et2);
      }
    }
    H$3(J4, "onInputSourcesChange");
    let H5 = new I$1(), it2 = new I$1();
    function W4(Z4, rt2, Et2) {
      H5.setFromMatrixPosition(rt2.matrixWorld), it2.setFromMatrixPosition(Et2.matrixWorld);
      let at2 = H5.distanceTo(it2), Ct2 = rt2.projectionMatrix.elements, Yt2 = Et2.projectionMatrix.elements, wt2 = Ct2[14] / (Ct2[10] - 1), Kt2 = Ct2[14] / (Ct2[10] + 1), j3 = (Ct2[9] + 1) / Ct2[5], Q4 = (Ct2[9] - 1) / Ct2[5], A3 = (Ct2[8] - 1) / Ct2[0], At2 = (Yt2[8] + 1) / Yt2[0], tt2 = wt2 * A3, xt2 = wt2 * At2, st2 = at2 / (-A3 + At2), Dt2 = st2 * -A3;
      if (rt2.matrixWorld.decompose(Z4.position, Z4.quaternion, Z4.scale), Z4.translateX(Dt2), Z4.translateZ(st2), Z4.matrixWorld.compose(Z4.position, Z4.quaternion, Z4.scale), Z4.matrixWorldInverse.copy(Z4.matrixWorld).invert(), Ct2[10] === -1) Z4.projectionMatrix.copy(rt2.projectionMatrix), Z4.projectionMatrixInverse.copy(rt2.projectionMatrixInverse);
      else {
        let ft2 = wt2 + st2, T3 = Kt2 + st2, v3 = tt2 - Dt2, O4 = xt2 + (at2 - Dt2), q4 = j3 * Kt2 / T3 * ft2, K4 = Q4 * Kt2 / T3 * ft2;
        Z4.projectionMatrix.makePerspective(v3, O4, q4, K4, ft2, T3), Z4.projectionMatrixInverse.copy(Z4.projectionMatrix).invert();
      }
    }
    H$3(W4, "setProjectionFromUnion");
    function lt2(Z4, rt2) {
      rt2 === null ? Z4.matrixWorld.copy(Z4.matrix) : Z4.matrixWorld.multiplyMatrices(rt2.matrixWorld, Z4.matrix), Z4.matrixWorldInverse.copy(Z4.matrixWorld).invert();
    }
    H$3(lt2, "updateCamera"), this.updateCamera = function(Z4) {
      if (i === null) return;
      let rt2 = Z4.near, Et2 = Z4.far;
      x2.texture !== null && (x2.depthNear > 0 && (rt2 = x2.depthNear), x2.depthFar > 0 && (Et2 = x2.depthFar)), S4.near = L3.near = R3.near = rt2, S4.far = L3.far = R3.far = Et2, (P4 !== S4.near || G3 !== S4.far) && (i.updateRenderState({ depthNear: S4.near, depthFar: S4.far }), P4 = S4.near, G3 = S4.far), R3.layers.mask = Z4.layers.mask | 2, L3.layers.mask = Z4.layers.mask | 4, S4.layers.mask = R3.layers.mask | L3.layers.mask;
      let at2 = Z4.parent, Ct2 = S4.cameras;
      lt2(S4, at2);
      for (let Yt2 = 0; Yt2 < Ct2.length; Yt2++) lt2(Ct2[Yt2], at2);
      Ct2.length === 2 ? W4(S4, R3, L3) : S4.projectionMatrix.copy(R3.projectionMatrix), gt2(Z4, S4, at2);
    };
    function gt2(Z4, rt2, Et2) {
      Et2 === null ? Z4.matrix.copy(rt2.matrixWorld) : (Z4.matrix.copy(Et2.matrixWorld), Z4.matrix.invert(), Z4.matrix.multiply(rt2.matrixWorld)), Z4.matrix.decompose(Z4.position, Z4.quaternion, Z4.scale), Z4.updateMatrixWorld(true), Z4.projectionMatrix.copy(rt2.projectionMatrix), Z4.projectionMatrixInverse.copy(rt2.projectionMatrixInverse), Z4.isPerspectiveCamera && (Z4.fov = ai$1 * 2 * Math.atan(1 / Z4.projectionMatrix.elements[5]), Z4.zoom = 1);
    }
    H$3(gt2, "updateUserCamera"), this.getCamera = function() {
      return S4;
    }, this.getFoveation = function() {
      if (!(f === null && m5 === null)) return l;
    }, this.setFoveation = function(Z4) {
      l = Z4, f !== null && (f.fixedFoveation = Z4), m5 !== null && m5.fixedFoveation !== void 0 && (m5.fixedFoveation = Z4);
    }, this.hasDepthSensing = function() {
      return x2.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return x2.getMesh(S4);
    };
    let bt2 = null;
    function Ot2(Z4, rt2) {
      if (u5 = rt2.getViewerPose(c || a4), _ = rt2, u5 !== null) {
        let Et2 = u5.views;
        m5 !== null && (t.setRenderTargetFramebuffer(w3, m5.framebuffer), t.setRenderTarget(w3));
        let at2 = false;
        Et2.length !== S4.cameras.length && (S4.cameras.length = 0, at2 = true);
        for (let wt2 = 0; wt2 < Et2.length; wt2++) {
          let Kt2 = Et2[wt2], j3 = null;
          if (m5 !== null) j3 = m5.getViewport(Kt2);
          else {
            let A3 = d.getViewSubImage(f, Kt2);
            j3 = A3.viewport, wt2 === 0 && (t.setRenderTargetTextures(w3, A3.colorTexture, f.ignoreDepthValues ? void 0 : A3.depthStencilTexture), t.setRenderTarget(w3));
          }
          let Q4 = E4[wt2];
          Q4 === void 0 && (Q4 = new Te$1(), Q4.layers.enable(wt2), Q4.viewport = new $t$3(), E4[wt2] = Q4), Q4.matrix.fromArray(Kt2.transform.matrix), Q4.matrix.decompose(Q4.position, Q4.quaternion, Q4.scale), Q4.projectionMatrix.fromArray(Kt2.projectionMatrix), Q4.projectionMatrixInverse.copy(Q4.projectionMatrix).invert(), Q4.viewport.set(j3.x, j3.y, j3.width, j3.height), wt2 === 0 && (S4.matrix.copy(Q4.matrix), S4.matrix.decompose(S4.position, S4.quaternion, S4.scale)), at2 === true && S4.cameras.push(Q4);
        }
        let Ct2 = i.enabledFeatures;
        if (Ct2 && Ct2.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && d) {
          let wt2 = d.getDepthInformation(Et2[0]);
          wt2 && wt2.isValid && wt2.texture && x2.init(t, wt2, i.renderState);
        }
      }
      for (let Et2 = 0; Et2 < b.length; Et2++) {
        let at2 = y4[Et2], Ct2 = b[Et2];
        at2 !== null && Ct2 !== void 0 && Ct2.update(at2, rt2, c || a4);
      }
      bt2 && bt2(Z4, rt2), rt2.detectedPlanes && n4.dispatchEvent({ type: "planesdetected", data: rt2 }), _ = null;
    }
    H$3(Ot2, "onAnimationFrame");
    let Qt2 = new fp$1();
    Qt2.setAnimationLoop(Ot2), this.setAnimationLoop = function(Z4) {
      bt2 = Z4;
    }, this.dispose = function() {
    };
  }
};
H$3(Vu$2, "WebXRManager");
var Pu$2 = Vu$2, yi$1 = new Ze$1(), Dv$2 = new Vt$2();
function Lv$1(s5, t) {
  function e(g, p4) {
    g.matrixAutoUpdate === true && g.updateMatrix(), p4.value.copy(g.matrix);
  }
  H$3(e, "refreshTransformUniform");
  function n4(g, p4) {
    p4.color.getRGB(g.fogColor.value, gc$2(s5)), p4.isFog ? (g.fogNear.value = p4.near, g.fogFar.value = p4.far) : p4.isFogExp2 && (g.fogDensity.value = p4.density);
  }
  H$3(n4, "refreshFogUniforms");
  function i(g, p4, w3, b, y4) {
    p4.isMeshBasicMaterial || p4.isMeshLambertMaterial ? r5(g, p4) : p4.isMeshToonMaterial ? (r5(g, p4), d(g, p4)) : p4.isMeshPhongMaterial ? (r5(g, p4), u5(g, p4)) : p4.isMeshStandardMaterial ? (r5(g, p4), f(g, p4), p4.isMeshPhysicalMaterial && m5(g, p4, y4)) : p4.isMeshMatcapMaterial ? (r5(g, p4), _(g, p4)) : p4.isMeshDepthMaterial ? r5(g, p4) : p4.isMeshDistanceMaterial ? (r5(g, p4), x2(g, p4)) : p4.isMeshNormalMaterial ? r5(g, p4) : p4.isLineBasicMaterial ? (a4(g, p4), p4.isLineDashedMaterial && o4(g, p4)) : p4.isPointsMaterial ? l(g, p4, w3, b) : p4.isSpriteMaterial ? c(g, p4) : p4.isShadowMaterial ? (g.color.value.copy(p4.color), g.opacity.value = p4.opacity) : p4.isShaderMaterial && (p4.uniformsNeedUpdate = false);
  }
  H$3(i, "refreshMaterialUniforms");
  function r5(g, p4) {
    g.opacity.value = p4.opacity, p4.color && g.diffuse.value.copy(p4.color), p4.emissive && g.emissive.value.copy(p4.emissive).multiplyScalar(p4.emissiveIntensity), p4.map && (g.map.value = p4.map, e(p4.map, g.mapTransform)), p4.alphaMap && (g.alphaMap.value = p4.alphaMap, e(p4.alphaMap, g.alphaMapTransform)), p4.bumpMap && (g.bumpMap.value = p4.bumpMap, e(p4.bumpMap, g.bumpMapTransform), g.bumpScale.value = p4.bumpScale, p4.side === Le$2 && (g.bumpScale.value *= -1)), p4.normalMap && (g.normalMap.value = p4.normalMap, e(p4.normalMap, g.normalMapTransform), g.normalScale.value.copy(p4.normalScale), p4.side === Le$2 && g.normalScale.value.negate()), p4.displacementMap && (g.displacementMap.value = p4.displacementMap, e(p4.displacementMap, g.displacementMapTransform), g.displacementScale.value = p4.displacementScale, g.displacementBias.value = p4.displacementBias), p4.emissiveMap && (g.emissiveMap.value = p4.emissiveMap, e(p4.emissiveMap, g.emissiveMapTransform)), p4.specularMap && (g.specularMap.value = p4.specularMap, e(p4.specularMap, g.specularMapTransform)), p4.alphaTest > 0 && (g.alphaTest.value = p4.alphaTest);
    let w3 = t.get(p4), b = w3.envMap, y4 = w3.envMapRotation;
    b && (g.envMap.value = b, yi$1.copy(y4), yi$1.x *= -1, yi$1.y *= -1, yi$1.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === false && (yi$1.y *= -1, yi$1.z *= -1), g.envMapRotation.value.setFromMatrix4(Dv$2.makeRotationFromEuler(yi$1)), g.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === false ? -1 : 1, g.reflectivity.value = p4.reflectivity, g.ior.value = p4.ior, g.refractionRatio.value = p4.refractionRatio), p4.lightMap && (g.lightMap.value = p4.lightMap, g.lightMapIntensity.value = p4.lightMapIntensity, e(p4.lightMap, g.lightMapTransform)), p4.aoMap && (g.aoMap.value = p4.aoMap, g.aoMapIntensity.value = p4.aoMapIntensity, e(p4.aoMap, g.aoMapTransform));
  }
  H$3(r5, "refreshUniformsCommon");
  function a4(g, p4) {
    g.diffuse.value.copy(p4.color), g.opacity.value = p4.opacity, p4.map && (g.map.value = p4.map, e(p4.map, g.mapTransform));
  }
  H$3(a4, "refreshUniformsLine");
  function o4(g, p4) {
    g.dashSize.value = p4.dashSize, g.totalSize.value = p4.dashSize + p4.gapSize, g.scale.value = p4.scale;
  }
  H$3(o4, "refreshUniformsDash");
  function l(g, p4, w3, b) {
    g.diffuse.value.copy(p4.color), g.opacity.value = p4.opacity, g.size.value = p4.size * w3, g.scale.value = b * 0.5, p4.map && (g.map.value = p4.map, e(p4.map, g.uvTransform)), p4.alphaMap && (g.alphaMap.value = p4.alphaMap, e(p4.alphaMap, g.alphaMapTransform)), p4.alphaTest > 0 && (g.alphaTest.value = p4.alphaTest);
  }
  H$3(l, "refreshUniformsPoints");
  function c(g, p4) {
    g.diffuse.value.copy(p4.color), g.opacity.value = p4.opacity, g.rotation.value = p4.rotation, p4.map && (g.map.value = p4.map, e(p4.map, g.mapTransform)), p4.alphaMap && (g.alphaMap.value = p4.alphaMap, e(p4.alphaMap, g.alphaMapTransform)), p4.alphaTest > 0 && (g.alphaTest.value = p4.alphaTest);
  }
  H$3(c, "refreshUniformsSprites");
  function u5(g, p4) {
    g.specular.value.copy(p4.specular), g.shininess.value = Math.max(p4.shininess, 1e-4);
  }
  H$3(u5, "refreshUniformsPhong");
  function d(g, p4) {
    p4.gradientMap && (g.gradientMap.value = p4.gradientMap);
  }
  H$3(d, "refreshUniformsToon");
  function f(g, p4) {
    g.metalness.value = p4.metalness, p4.metalnessMap && (g.metalnessMap.value = p4.metalnessMap, e(p4.metalnessMap, g.metalnessMapTransform)), g.roughness.value = p4.roughness, p4.roughnessMap && (g.roughnessMap.value = p4.roughnessMap, e(p4.roughnessMap, g.roughnessMapTransform)), p4.envMap && (g.envMapIntensity.value = p4.envMapIntensity);
  }
  H$3(f, "refreshUniformsStandard");
  function m5(g, p4, w3) {
    g.ior.value = p4.ior, p4.sheen > 0 && (g.sheenColor.value.copy(p4.sheenColor).multiplyScalar(p4.sheen), g.sheenRoughness.value = p4.sheenRoughness, p4.sheenColorMap && (g.sheenColorMap.value = p4.sheenColorMap, e(p4.sheenColorMap, g.sheenColorMapTransform)), p4.sheenRoughnessMap && (g.sheenRoughnessMap.value = p4.sheenRoughnessMap, e(p4.sheenRoughnessMap, g.sheenRoughnessMapTransform))), p4.clearcoat > 0 && (g.clearcoat.value = p4.clearcoat, g.clearcoatRoughness.value = p4.clearcoatRoughness, p4.clearcoatMap && (g.clearcoatMap.value = p4.clearcoatMap, e(p4.clearcoatMap, g.clearcoatMapTransform)), p4.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = p4.clearcoatRoughnessMap, e(p4.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), p4.clearcoatNormalMap && (g.clearcoatNormalMap.value = p4.clearcoatNormalMap, e(p4.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(p4.clearcoatNormalScale), p4.side === Le$2 && g.clearcoatNormalScale.value.negate())), p4.dispersion > 0 && (g.dispersion.value = p4.dispersion), p4.iridescence > 0 && (g.iridescence.value = p4.iridescence, g.iridescenceIOR.value = p4.iridescenceIOR, g.iridescenceThicknessMinimum.value = p4.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = p4.iridescenceThicknessRange[1], p4.iridescenceMap && (g.iridescenceMap.value = p4.iridescenceMap, e(p4.iridescenceMap, g.iridescenceMapTransform)), p4.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = p4.iridescenceThicknessMap, e(p4.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), p4.transmission > 0 && (g.transmission.value = p4.transmission, g.transmissionSamplerMap.value = w3.texture, g.transmissionSamplerSize.value.set(w3.width, w3.height), p4.transmissionMap && (g.transmissionMap.value = p4.transmissionMap, e(p4.transmissionMap, g.transmissionMapTransform)), g.thickness.value = p4.thickness, p4.thicknessMap && (g.thicknessMap.value = p4.thicknessMap, e(p4.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = p4.attenuationDistance, g.attenuationColor.value.copy(p4.attenuationColor)), p4.anisotropy > 0 && (g.anisotropyVector.value.set(p4.anisotropy * Math.cos(p4.anisotropyRotation), p4.anisotropy * Math.sin(p4.anisotropyRotation)), p4.anisotropyMap && (g.anisotropyMap.value = p4.anisotropyMap, e(p4.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = p4.specularIntensity, g.specularColor.value.copy(p4.specularColor), p4.specularColorMap && (g.specularColorMap.value = p4.specularColorMap, e(p4.specularColorMap, g.specularColorMapTransform)), p4.specularIntensityMap && (g.specularIntensityMap.value = p4.specularIntensityMap, e(p4.specularIntensityMap, g.specularIntensityMapTransform));
  }
  H$3(m5, "refreshUniformsPhysical");
  function _(g, p4) {
    p4.matcap && (g.matcap.value = p4.matcap);
  }
  H$3(_, "refreshUniformsMatcap");
  function x2(g, p4) {
    let w3 = t.get(p4).light;
    g.referencePosition.value.setFromMatrixPosition(w3.matrixWorld), g.nearDistance.value = w3.shadow.camera.near, g.farDistance.value = w3.shadow.camera.far;
  }
  return H$3(x2, "refreshUniformsDistance"), { refreshFogUniforms: n4, refreshMaterialUniforms: i };
}
H$3(Lv$1, "WebGLMaterials");
function Uv$1(s5, t, e, n4) {
  let i = {}, r5 = {}, a4 = [], o4 = s5.getParameter(s5.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(w3, b) {
    let y4 = b.program;
    n4.uniformBlockBinding(w3, y4);
  }
  H$3(l, "bind");
  function c(w3, b) {
    let y4 = i[w3.id];
    y4 === void 0 && (_(w3), y4 = u5(w3), i[w3.id] = y4, w3.addEventListener("dispose", g));
    let D4 = b.program;
    n4.updateUBOMapping(w3, D4);
    let C3 = t.render.frame;
    r5[w3.id] !== C3 && (f(w3), r5[w3.id] = C3);
  }
  H$3(c, "update");
  function u5(w3) {
    let b = d();
    w3.__bindingPointIndex = b;
    let y4 = s5.createBuffer(), D4 = w3.__size, C3 = w3.usage;
    return s5.bindBuffer(s5.UNIFORM_BUFFER, y4), s5.bufferData(s5.UNIFORM_BUFFER, D4, C3), s5.bindBuffer(s5.UNIFORM_BUFFER, null), s5.bindBufferBase(s5.UNIFORM_BUFFER, b, y4), y4;
  }
  H$3(u5, "createBuffer");
  function d() {
    for (let w3 = 0; w3 < o4; w3++) if (a4.indexOf(w3) === -1) return a4.push(w3), w3;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  H$3(d, "allocateBindingPointIndex");
  function f(w3) {
    let b = i[w3.id], y4 = w3.uniforms, D4 = w3.__cache;
    s5.bindBuffer(s5.UNIFORM_BUFFER, b);
    for (let C3 = 0, R3 = y4.length; C3 < R3; C3++) {
      let L3 = Array.isArray(y4[C3]) ? y4[C3] : [y4[C3]];
      for (let E4 = 0, S4 = L3.length; E4 < S4; E4++) {
        let P4 = L3[E4];
        if (m5(P4, C3, E4, D4) === true) {
          let G3 = P4.__offset, B3 = Array.isArray(P4.value) ? P4.value : [P4.value], V3 = 0;
          for (let J4 = 0; J4 < B3.length; J4++) {
            let H5 = B3[J4], it2 = x2(H5);
            typeof H5 == "number" || typeof H5 == "boolean" ? (P4.__data[0] = H5, s5.bufferSubData(s5.UNIFORM_BUFFER, G3 + V3, P4.__data)) : H5.isMatrix3 ? (P4.__data[0] = H5.elements[0], P4.__data[1] = H5.elements[1], P4.__data[2] = H5.elements[2], P4.__data[3] = 0, P4.__data[4] = H5.elements[3], P4.__data[5] = H5.elements[4], P4.__data[6] = H5.elements[5], P4.__data[7] = 0, P4.__data[8] = H5.elements[6], P4.__data[9] = H5.elements[7], P4.__data[10] = H5.elements[8], P4.__data[11] = 0) : (H5.toArray(P4.__data, V3), V3 += it2.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s5.bufferSubData(s5.UNIFORM_BUFFER, G3, P4.__data);
        }
      }
    }
    s5.bindBuffer(s5.UNIFORM_BUFFER, null);
  }
  H$3(f, "updateBufferData");
  function m5(w3, b, y4, D4) {
    let C3 = w3.value, R3 = b + "_" + y4;
    if (D4[R3] === void 0) return typeof C3 == "number" || typeof C3 == "boolean" ? D4[R3] = C3 : D4[R3] = C3.clone(), true;
    {
      let L3 = D4[R3];
      if (typeof C3 == "number" || typeof C3 == "boolean") {
        if (L3 !== C3) return D4[R3] = C3, true;
      } else if (L3.equals(C3) === false) return L3.copy(C3), true;
    }
    return false;
  }
  H$3(m5, "hasUniformChanged");
  function _(w3) {
    let b = w3.uniforms, y4 = 0, D4 = 16;
    for (let R3 = 0, L3 = b.length; R3 < L3; R3++) {
      let E4 = Array.isArray(b[R3]) ? b[R3] : [b[R3]];
      for (let S4 = 0, P4 = E4.length; S4 < P4; S4++) {
        let G3 = E4[S4], B3 = Array.isArray(G3.value) ? G3.value : [G3.value];
        for (let V3 = 0, J4 = B3.length; V3 < J4; V3++) {
          let H5 = B3[V3], it2 = x2(H5), W4 = y4 % D4, lt2 = W4 % it2.boundary, gt2 = W4 + lt2;
          y4 += lt2, gt2 !== 0 && D4 - gt2 < it2.storage && (y4 += D4 - gt2), G3.__data = new Float32Array(it2.storage / Float32Array.BYTES_PER_ELEMENT), G3.__offset = y4, y4 += it2.storage;
        }
      }
    }
    let C3 = y4 % D4;
    return C3 > 0 && (y4 += D4 - C3), w3.__size = y4, w3.__cache = {}, this;
  }
  H$3(_, "prepareUniformsGroup");
  function x2(w3) {
    let b = { boundary: 0, storage: 0 };
    return typeof w3 == "number" || typeof w3 == "boolean" ? (b.boundary = 4, b.storage = 4) : w3.isVector2 ? (b.boundary = 8, b.storage = 8) : w3.isVector3 || w3.isColor ? (b.boundary = 16, b.storage = 12) : w3.isVector4 ? (b.boundary = 16, b.storage = 16) : w3.isMatrix3 ? (b.boundary = 48, b.storage = 48) : w3.isMatrix4 ? (b.boundary = 64, b.storage = 64) : w3.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w3), b;
  }
  H$3(x2, "getUniformSize");
  function g(w3) {
    let b = w3.target;
    b.removeEventListener("dispose", g);
    let y4 = a4.indexOf(b.__bindingPointIndex);
    a4.splice(y4, 1), s5.deleteBuffer(i[b.id]), delete i[b.id], delete r5[b.id];
  }
  H$3(g, "onUniformsGroupsDispose");
  function p4() {
    for (let w3 in i) s5.deleteBuffer(i[w3]);
    a4 = [], i = {}, r5 = {};
  }
  return H$3(p4, "dispose"), { bind: l, update: c, dispose: p4 };
}
H$3(Uv$1, "WebGLUniformsGroups");
var Hu$2 = class Hu {
  constructor(t = {}) {
    let { canvas: e = Df$1(), context: n4 = null, depth: i = true, stencil: r5 = false, alpha: a4 = false, antialias: o4 = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: u5 = "default", failIfMajorPerformanceCaveat: d = false, reverseDepthBuffer: f = false } = t;
    this.isWebGLRenderer = true;
    let m5;
    if (n4 !== null) {
      if (typeof WebGLRenderingContext < "u" && n4 instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      m5 = n4.getContextAttributes().alpha;
    } else m5 = a4;
    let _ = new Uint32Array(4), x2 = new Int32Array(4), g = null, p4 = null, w3 = [], b = [];
    this.domElement = e, this.debug = { checkShaderErrors: true, onShaderError: null }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Ve$1, this.toneMapping = Cn$3, this.toneMappingExposure = 1;
    let y4 = this, D4 = false, C3 = 0, R3 = 0, L3 = null, E4 = -1, S4 = null, P4 = new $t$3(), G3 = new $t$3(), B3 = null, V3 = new Ft$3(0), J4 = 0, H5 = e.width, it2 = e.height, W4 = 1, lt2 = null, gt2 = null, bt2 = new $t$3(0, 0, H5, it2), Ot2 = new $t$3(0, 0, H5, it2), Qt2 = false, Z4 = new oi$1(), rt2 = false, Et2 = false;
    this.transmissionResolutionScale = 1;
    let at2 = new Vt$2(), Ct2 = new Vt$2(), Yt2 = new I$1(), wt2 = new $t$3(), Kt2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true }, j3 = false;
    function Q4() {
      return L3 === null ? W4 : 1;
    }
    H$3(Q4, "getTargetPixelRatio");
    let A3 = n4;
    function At2(M3, N3) {
      return e.getContext(M3, N3);
    }
    H$3(At2, "getContext");
    try {
      let M3 = { alpha: true, depth: i, stencil: r5, antialias: o4, premultipliedAlpha: l, preserveDrawingBuffer: c, powerPreference: u5, failIfMajorPerformanceCaveat: d };
      if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r".concat(Aa$1)), e.addEventListener("webglcontextlost", $5, false), e.addEventListener("webglcontextrestored", mt2, false), e.addEventListener("webglcontextcreationerror", pt2, false), A3 === null) {
        let N3 = "webgl2";
        if (A3 = At2(N3, M3), A3 === null) throw At2(N3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (M3) {
      throw console.error("THREE.WebGLRenderer: " + M3.message), M3;
    }
    let tt2, xt2, st2, Dt2, ft2, T3, v3, O4, q4, K4, Y3, Tt2, ht2, _t2, Wt2, nt2, yt2, Pt3, Lt2, Mt2, Xt2, kt2, se3, U3;
    function ut2() {
      tt2 = new Q0$1(A3), tt2.init(), kt2 = new Rv$1(A3, tt2), xt2 = new q0$1(A3, tt2, t, kt2), st2 = new wv$1(A3, tt2), xt2.reverseDepthBuffer && f && st2.buffers.depth.setReversed(true), Dt2 = new ex$2(A3), ft2 = new pv$1(), T3 = new Cv$1(A3, tt2, st2, ft2, xt2, kt2, Dt2), v3 = new Z0$1(y4), O4 = new K0$1(y4), q4 = new lg$1(A3), se3 = new W0$1(A3, q4), K4 = new j0$1(A3, q4, Dt2, se3), Y3 = new ix$2(A3, K4, q4, Dt2), Lt2 = new nx$2(A3, xt2, T3), nt2 = new Y0$1(ft2), Tt2 = new fv$1(y4, v3, O4, tt2, xt2, se3, nt2), ht2 = new Lv$1(y4, ft2), _t2 = new gv$1(), Wt2 = new Sv$2(tt2), Pt3 = new G0$1(y4, v3, O4, st2, Y3, m5, l), yt2 = new Tv$1(y4, Y3, xt2), U3 = new Uv$1(A3, Dt2, xt2, st2), Mt2 = new X0$1(A3, tt2, Dt2), Xt2 = new tx$2(A3, tt2, Dt2), Dt2.programs = Tt2.programs, y4.capabilities = xt2, y4.extensions = tt2, y4.properties = ft2, y4.renderLists = _t2, y4.shadowMap = yt2, y4.state = st2, y4.info = Dt2;
    }
    H$3(ut2, "initGLContext"), ut2();
    let X4 = new Pu$2(y4, A3);
    this.xr = X4, this.getContext = function() {
      return A3;
    }, this.getContextAttributes = function() {
      return A3.getContextAttributes();
    }, this.forceContextLoss = function() {
      let M3 = tt2.get("WEBGL_lose_context");
      M3 && M3.loseContext();
    }, this.forceContextRestore = function() {
      let M3 = tt2.get("WEBGL_lose_context");
      M3 && M3.restoreContext();
    }, this.getPixelRatio = function() {
      return W4;
    }, this.setPixelRatio = function(M3) {
      M3 !== void 0 && (W4 = M3, this.setSize(H5, it2, false));
    }, this.getSize = function(M3) {
      return M3.set(H5, it2);
    }, this.setSize = function(M3, N3, z4 = true) {
      if (X4.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      H5 = M3, it2 = N3, e.width = Math.floor(M3 * W4), e.height = Math.floor(N3 * W4), z4 === true && (e.style.width = M3 + "px", e.style.height = N3 + "px"), this.setViewport(0, 0, M3, N3);
    }, this.getDrawingBufferSize = function(M3) {
      return M3.set(H5 * W4, it2 * W4).floor();
    }, this.setDrawingBufferSize = function(M3, N3, z4) {
      H5 = M3, it2 = N3, W4 = z4, e.width = Math.floor(M3 * z4), e.height = Math.floor(N3 * z4), this.setViewport(0, 0, M3, N3);
    }, this.getCurrentViewport = function(M3) {
      return M3.copy(P4);
    }, this.getViewport = function(M3) {
      return M3.copy(bt2);
    }, this.setViewport = function(M3, N3, z4, k3) {
      M3.isVector4 ? bt2.set(M3.x, M3.y, M3.z, M3.w) : bt2.set(M3, N3, z4, k3), st2.viewport(P4.copy(bt2).multiplyScalar(W4).round());
    }, this.getScissor = function(M3) {
      return M3.copy(Ot2);
    }, this.setScissor = function(M3, N3, z4, k3) {
      M3.isVector4 ? Ot2.set(M3.x, M3.y, M3.z, M3.w) : Ot2.set(M3, N3, z4, k3), st2.scissor(G3.copy(Ot2).multiplyScalar(W4).round());
    }, this.getScissorTest = function() {
      return Qt2;
    }, this.setScissorTest = function(M3) {
      st2.setScissorTest(Qt2 = M3);
    }, this.setOpaqueSort = function(M3) {
      lt2 = M3;
    }, this.setTransparentSort = function(M3) {
      gt2 = M3;
    }, this.getClearColor = function(M3) {
      return M3.copy(Pt3.getClearColor());
    }, this.setClearColor = function() {
      Pt3.setClearColor.apply(Pt3, arguments);
    }, this.getClearAlpha = function() {
      return Pt3.getClearAlpha();
    }, this.setClearAlpha = function() {
      Pt3.setClearAlpha.apply(Pt3, arguments);
    }, this.clear = function(M3 = true, N3 = true, z4 = true) {
      let k3 = 0;
      if (M3) {
        let F3 = false;
        if (L3 !== null) {
          let et2 = L3.texture.format;
          F3 = et2 === Ga$1 || et2 === Ha$1 || et2 === Gs$2;
        }
        if (F3) {
          let et2 = L3.texture.type, dt2 = et2 === hn || et2 === Rn$1 || et2 === Zi$2 || et2 === gi$1 || et2 === za$1 || et2 === ka$1, vt2 = Pt3.getClearColor(), St2 = Pt3.getClearAlpha(), Ut2 = vt2.r, Nt2 = vt2.g, Rt2 = vt2.b;
          dt2 ? (_[0] = Ut2, _[1] = Nt2, _[2] = Rt2, _[3] = St2, A3.clearBufferuiv(A3.COLOR, 0, _)) : (x2[0] = Ut2, x2[1] = Nt2, x2[2] = Rt2, x2[3] = St2, A3.clearBufferiv(A3.COLOR, 0, x2));
        } else k3 |= A3.COLOR_BUFFER_BIT;
      }
      N3 && (k3 |= A3.DEPTH_BUFFER_BIT), z4 && (k3 |= A3.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), A3.clear(k3);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", $5, false), e.removeEventListener("webglcontextrestored", mt2, false), e.removeEventListener("webglcontextcreationerror", pt2, false), Pt3.dispose(), _t2.dispose(), Wt2.dispose(), ft2.dispose(), v3.dispose(), O4.dispose(), Y3.dispose(), se3.dispose(), U3.dispose(), Tt2.dispose(), X4.dispose(), X4.removeEventListener("sessionstart", Gu2), X4.removeEventListener("sessionend", Wu2), Xn2.stop();
    };
    function $5(M3) {
      M3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), D4 = true;
    }
    H$3($5, "onContextLost");
    function mt2() {
      console.log("THREE.WebGLRenderer: Context Restored."), D4 = false;
      let M3 = Dt2.autoReset, N3 = yt2.enabled, z4 = yt2.autoUpdate, k3 = yt2.needsUpdate, F3 = yt2.type;
      ut2(), Dt2.autoReset = M3, yt2.enabled = N3, yt2.autoUpdate = z4, yt2.needsUpdate = k3, yt2.type = F3;
    }
    H$3(mt2, "onContextRestore");
    function pt2(M3) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", M3.statusMessage);
    }
    H$3(pt2, "onContextCreationError");
    function zt2(M3) {
      let N3 = M3.target;
      N3.removeEventListener("dispose", zt2), ce2(N3);
    }
    H$3(zt2, "onMaterialDispose");
    function ce2(M3) {
      Me2(M3), ft2.remove(M3);
    }
    H$3(ce2, "deallocateMaterial");
    function Me2(M3) {
      let N3 = ft2.get(M3).programs;
      N3 !== void 0 && (N3.forEach(function(z4) {
        Tt2.releaseProgram(z4);
      }), M3.isShaderMaterial && Tt2.releaseShaderCache(M3));
    }
    H$3(Me2, "releaseMaterialProgramReferences"), this.renderBufferDirect = function(M3, N3, z4, k3, F3, et2) {
      N3 === null && (N3 = Kt2);
      let dt2 = F3.isMesh && F3.matrixWorld.determinant() < 0, vt2 = xp2(M3, N3, z4, k3, F3);
      st2.setMaterial(k3, dt2);
      let St2 = z4.index, Ut2 = 1;
      if (k3.wireframe === true) {
        if (St2 = K4.getWireframeAttribute(z4), St2 === void 0) return;
        Ut2 = 2;
      }
      let Nt2 = z4.drawRange, Rt2 = z4.attributes.position, Zt2 = Nt2.start * Ut2, jt2 = (Nt2.start + Nt2.count) * Ut2;
      et2 !== null && (Zt2 = Math.max(Zt2, et2.start * Ut2), jt2 = Math.min(jt2, (et2.start + et2.count) * Ut2)), St2 !== null ? (Zt2 = Math.max(Zt2, 0), jt2 = Math.min(jt2, St2.count)) : Rt2 != null && (Zt2 = Math.max(Zt2, 0), jt2 = Math.min(jt2, Rt2.count));
      let ue2 = jt2 - Zt2;
      if (ue2 < 0 || ue2 === 1 / 0) return;
      se3.setup(F3, k3, vt2, z4, St2);
      let he2, Jt2 = Mt2;
      if (St2 !== null && (he2 = q4.get(St2), Jt2 = Xt2, Jt2.setIndex(he2)), F3.isMesh) k3.wireframe === true ? (st2.setLineWidth(k3.wireframeLinewidth * Q4()), Jt2.setMode(A3.LINES)) : Jt2.setMode(A3.TRIANGLES);
      else if (F3.isLine) {
        let It2 = k3.linewidth;
        It2 === void 0 && (It2 = 1), st2.setLineWidth(It2 * Q4()), F3.isLineSegments ? Jt2.setMode(A3.LINES) : F3.isLineLoop ? Jt2.setMode(A3.LINE_LOOP) : Jt2.setMode(A3.LINE_STRIP);
      } else F3.isPoints ? Jt2.setMode(A3.POINTS) : F3.isSprite && Jt2.setMode(A3.TRIANGLES);
      if (F3.isBatchedMesh) if (F3._multiDrawInstances !== null) Jt2.renderMultiDrawInstances(F3._multiDrawStarts, F3._multiDrawCounts, F3._multiDrawCount, F3._multiDrawInstances);
      else if (tt2.get("WEBGL_multi_draw")) Jt2.renderMultiDraw(F3._multiDrawStarts, F3._multiDrawCounts, F3._multiDrawCount);
      else {
        let It2 = F3._multiDrawStarts, xe2 = F3._multiDrawCounts, te2 = F3._multiDrawCount, $e3 = St2 ? q4.get(St2).bytesPerElement : 1, bi3 = ft2.get(k3).currentProgram.getUniforms();
        for (let Be3 = 0; Be3 < te2; Be3++) bi3.setValue(A3, "_gl_DrawID", Be3), Jt2.render(It2[Be3] / $e3, xe2[Be3]);
      }
      else if (F3.isInstancedMesh) Jt2.renderInstances(Zt2, ue2, F3.count);
      else if (z4.isInstancedBufferGeometry) {
        let It2 = z4._maxInstanceCount !== void 0 ? z4._maxInstanceCount : 1 / 0, xe2 = Math.min(z4.instanceCount, It2);
        Jt2.renderInstances(Zt2, ue2, xe2);
      } else Jt2.render(Zt2, ue2);
    };
    function ee2(M3, N3, z4) {
      M3.transparent === true && M3.side === cn$3 && M3.forceSinglePass === false ? (M3.side = Le$2, M3.needsUpdate = true, Ks2(M3, N3, z4), M3.side = Sn$2, M3.needsUpdate = true, Ks2(M3, N3, z4), M3.side = cn$3) : Ks2(M3, N3, z4);
    }
    H$3(ee2, "prepareMaterial"), this.compile = function(M3, N3, z4 = null) {
      z4 === null && (z4 = M3), p4 = Wt2.get(z4), p4.init(N3), b.push(p4), z4.traverseVisible(function(F3) {
        F3.isLight && F3.layers.test(N3.layers) && (p4.pushLight(F3), F3.castShadow && p4.pushShadow(F3));
      }), M3 !== z4 && M3.traverseVisible(function(F3) {
        F3.isLight && F3.layers.test(N3.layers) && (p4.pushLight(F3), F3.castShadow && p4.pushShadow(F3));
      }), p4.setupLights();
      let k3 = /* @__PURE__ */ new Set();
      return M3.traverse(function(F3) {
        if (!(F3.isMesh || F3.isPoints || F3.isLine || F3.isSprite)) return;
        let et2 = F3.material;
        if (et2) if (Array.isArray(et2)) for (let dt2 = 0; dt2 < et2.length; dt2++) {
          let vt2 = et2[dt2];
          ee2(vt2, z4, F3), k3.add(vt2);
        }
        else ee2(et2, z4, F3), k3.add(et2);
      }), b.pop(), p4 = null, k3;
    }, this.compileAsync = function(M3, N3, z4 = null) {
      let k3 = this.compile(M3, N3, z4);
      return new Promise((F3) => {
        function et2() {
          if (k3.forEach(function(dt2) {
            ft2.get(dt2).currentProgram.isReady() && k3.delete(dt2);
          }), k3.size === 0) {
            F3(M3);
            return;
          }
          setTimeout(et2, 10);
        }
        H$3(et2, "checkMaterialsReady"), tt2.get("KHR_parallel_shader_compile") !== null ? et2() : setTimeout(et2, 10);
      });
    };
    let Je2 = null;
    function dn2(M3) {
      Je2 && Je2(M3);
    }
    H$3(dn2, "onAnimationFrame");
    function Gu2() {
      Xn2.stop();
    }
    H$3(Gu2, "onXRSessionStart");
    function Wu2() {
      Xn2.start();
    }
    H$3(Wu2, "onXRSessionEnd");
    let Xn2 = new fp$1();
    Xn2.setAnimationLoop(dn2), typeof self < "u" && Xn2.setContext(self), this.setAnimationLoop = function(M3) {
      Je2 = M3, X4.setAnimationLoop(M3), M3 === null ? Xn2.stop() : Xn2.start();
    }, X4.addEventListener("sessionstart", Gu2), X4.addEventListener("sessionend", Wu2), this.render = function(M3, N3) {
      if (N3 !== void 0 && N3.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (D4 === true) return;
      if (M3.matrixWorldAutoUpdate === true && M3.updateMatrixWorld(), N3.parent === null && N3.matrixWorldAutoUpdate === true && N3.updateMatrixWorld(), X4.enabled === true && X4.isPresenting === true && (X4.cameraAutoUpdate === true && X4.updateCamera(N3), N3 = X4.getCamera()), M3.isScene === true && M3.onBeforeRender(y4, M3, N3, L3), p4 = Wt2.get(M3, b.length), p4.init(N3), b.push(p4), Ct2.multiplyMatrices(N3.projectionMatrix, N3.matrixWorldInverse), Z4.setFromProjectionMatrix(Ct2), Et2 = this.localClippingEnabled, rt2 = nt2.init(this.clippingPlanes, Et2), g = _t2.get(M3, w3.length), g.init(), w3.push(g), X4.enabled === true && X4.isPresenting === true) {
        let et2 = y4.xr.getDepthSensingMesh();
        et2 !== null && Eo2(et2, N3, -1 / 0, y4.sortObjects);
      }
      Eo2(M3, N3, 0, y4.sortObjects), g.finish(), y4.sortObjects === true && g.sort(lt2, gt2), j3 = X4.enabled === false || X4.isPresenting === false || X4.hasDepthSensing() === false, j3 && Pt3.addToRenderList(g, M3), this.info.render.frame++, rt2 === true && nt2.beginShadows();
      let z4 = p4.state.shadowsArray;
      yt2.render(z4, M3, N3), rt2 === true && nt2.endShadows(), this.info.autoReset === true && this.info.reset();
      let k3 = g.opaque, F3 = g.transmissive;
      if (p4.setupLights(), N3.isArrayCamera) {
        let et2 = N3.cameras;
        if (F3.length > 0) for (let dt2 = 0, vt2 = et2.length; dt2 < vt2; dt2++) {
          let St2 = et2[dt2];
          qu2(k3, F3, M3, St2);
        }
        j3 && Pt3.render(M3);
        for (let dt2 = 0, vt2 = et2.length; dt2 < vt2; dt2++) {
          let St2 = et2[dt2];
          Xu2(g, M3, St2, St2.viewport);
        }
      } else F3.length > 0 && qu2(k3, F3, M3, N3), j3 && Pt3.render(M3), Xu2(g, M3, N3);
      L3 !== null && R3 === 0 && (T3.updateMultisampleRenderTarget(L3), T3.updateRenderTargetMipmap(L3)), M3.isScene === true && M3.onAfterRender(y4, M3, N3), se3.resetDefaultState(), E4 = -1, S4 = null, b.pop(), b.length > 0 ? (p4 = b[b.length - 1], rt2 === true && nt2.setGlobalState(y4.clippingPlanes, p4.state.camera)) : p4 = null, w3.pop(), w3.length > 0 ? g = w3[w3.length - 1] : g = null;
    };
    function Eo2(M3, N3, z4, k3) {
      if (M3.visible === false) return;
      if (M3.layers.test(N3.layers)) {
        if (M3.isGroup) z4 = M3.renderOrder;
        else if (M3.isLOD) M3.autoUpdate === true && M3.update(N3);
        else if (M3.isLight) p4.pushLight(M3), M3.castShadow && p4.pushShadow(M3);
        else if (M3.isSprite) {
          if (!M3.frustumCulled || Z4.intersectsSprite(M3)) {
            k3 && wt2.setFromMatrixPosition(M3.matrixWorld).applyMatrix4(Ct2);
            let dt2 = Y3.update(M3), vt2 = M3.material;
            vt2.visible && g.push(M3, dt2, vt2, z4, wt2.z, null);
          }
        } else if ((M3.isMesh || M3.isLine || M3.isPoints) && (!M3.frustumCulled || Z4.intersectsObject(M3))) {
          let dt2 = Y3.update(M3), vt2 = M3.material;
          if (k3 && (M3.boundingSphere !== void 0 ? (M3.boundingSphere === null && M3.computeBoundingSphere(), wt2.copy(M3.boundingSphere.center)) : (dt2.boundingSphere === null && dt2.computeBoundingSphere(), wt2.copy(dt2.boundingSphere.center)), wt2.applyMatrix4(M3.matrixWorld).applyMatrix4(Ct2)), Array.isArray(vt2)) {
            let St2 = dt2.groups;
            for (let Ut2 = 0, Nt2 = St2.length; Ut2 < Nt2; Ut2++) {
              let Rt2 = St2[Ut2], Zt2 = vt2[Rt2.materialIndex];
              Zt2 && Zt2.visible && g.push(M3, dt2, Zt2, z4, wt2.z, Rt2);
            }
          } else vt2.visible && g.push(M3, dt2, vt2, z4, wt2.z, null);
        }
      }
      let et2 = M3.children;
      for (let dt2 = 0, vt2 = et2.length; dt2 < vt2; dt2++) Eo2(et2[dt2], N3, z4, k3);
    }
    H$3(Eo2, "projectObject");
    function Xu2(M3, N3, z4, k3) {
      let F3 = M3.opaque, et2 = M3.transmissive, dt2 = M3.transparent;
      p4.setupLightsView(z4), rt2 === true && nt2.setGlobalState(y4.clippingPlanes, z4), k3 && st2.viewport(P4.copy(k3)), F3.length > 0 && $s3(F3, N3, z4), et2.length > 0 && $s3(et2, N3, z4), dt2.length > 0 && $s3(dt2, N3, z4), st2.buffers.depth.setTest(true), st2.buffers.depth.setMask(true), st2.buffers.color.setMask(true), st2.setPolygonOffset(false);
    }
    H$3(Xu2, "renderScene");
    function qu2(M3, N3, z4, k3) {
      if ((z4.isScene === true ? z4.overrideMaterial : null) !== null) return;
      p4.state.transmissionRenderTarget[k3.id] === void 0 && (p4.state.transmissionRenderTarget[k3.id] = new on$3(1, 1, { generateMipmaps: true, type: tt2.has("EXT_color_buffer_half_float") || tt2.has("EXT_color_buffer_float") ? Ji$1 : hn, minFilter: Wn$1, samples: 4, stencilBuffer: r5, resolveDepthBuffer: false, resolveStencilBuffer: false, colorSpace: qt$2.workingColorSpace }));
      let et2 = p4.state.transmissionRenderTarget[k3.id], dt2 = k3.viewport || P4;
      et2.setSize(dt2.z * y4.transmissionResolutionScale, dt2.w * y4.transmissionResolutionScale);
      let vt2 = y4.getRenderTarget();
      y4.setRenderTarget(et2), y4.getClearColor(V3), J4 = y4.getClearAlpha(), J4 < 1 && y4.setClearColor(16777215, 0.5), y4.clear(), j3 && Pt3.render(z4);
      let St2 = y4.toneMapping;
      y4.toneMapping = Cn$3;
      let Ut2 = k3.viewport;
      if (k3.viewport !== void 0 && (k3.viewport = void 0), p4.setupLightsView(k3), rt2 === true && nt2.setGlobalState(y4.clippingPlanes, k3), $s3(M3, z4, k3), T3.updateMultisampleRenderTarget(et2), T3.updateRenderTargetMipmap(et2), tt2.has("WEBGL_multisampled_render_to_texture") === false) {
        let Nt2 = false;
        for (let Rt2 = 0, Zt2 = N3.length; Rt2 < Zt2; Rt2++) {
          let jt2 = N3[Rt2], ue2 = jt2.object, he2 = jt2.geometry, Jt2 = jt2.material, It2 = jt2.group;
          if (Jt2.side === cn$3 && ue2.layers.test(k3.layers)) {
            let xe2 = Jt2.side;
            Jt2.side = Le$2, Jt2.needsUpdate = true, Yu2(ue2, z4, k3, he2, Jt2, It2), Jt2.side = xe2, Jt2.needsUpdate = true, Nt2 = true;
          }
        }
        Nt2 === true && (T3.updateMultisampleRenderTarget(et2), T3.updateRenderTargetMipmap(et2));
      }
      y4.setRenderTarget(vt2), y4.setClearColor(V3, J4), Ut2 !== void 0 && (k3.viewport = Ut2), y4.toneMapping = St2;
    }
    H$3(qu2, "renderTransmissionPass");
    function $s3(M3, N3, z4) {
      let k3 = N3.isScene === true ? N3.overrideMaterial : null;
      for (let F3 = 0, et2 = M3.length; F3 < et2; F3++) {
        let dt2 = M3[F3], vt2 = dt2.object, St2 = dt2.geometry, Ut2 = k3 === null ? dt2.material : k3, Nt2 = dt2.group;
        vt2.layers.test(z4.layers) && Yu2(vt2, N3, z4, St2, Ut2, Nt2);
      }
    }
    H$3($s3, "renderObjects");
    function Yu2(M3, N3, z4, k3, F3, et2) {
      M3.onBeforeRender(y4, N3, z4, k3, F3, et2), M3.modelViewMatrix.multiplyMatrices(z4.matrixWorldInverse, M3.matrixWorld), M3.normalMatrix.getNormalMatrix(M3.modelViewMatrix), F3.onBeforeRender(y4, N3, z4, k3, M3, et2), F3.transparent === true && F3.side === cn$3 && F3.forceSinglePass === false ? (F3.side = Le$2, F3.needsUpdate = true, y4.renderBufferDirect(z4, N3, k3, F3, M3, et2), F3.side = Sn$2, F3.needsUpdate = true, y4.renderBufferDirect(z4, N3, k3, F3, M3, et2), F3.side = cn$3) : y4.renderBufferDirect(z4, N3, k3, F3, M3, et2), M3.onAfterRender(y4, N3, z4, k3, F3, et2);
    }
    H$3(Yu2, "renderObject");
    function Ks2(M3, N3, z4) {
      N3.isScene !== true && (N3 = Kt2);
      let k3 = ft2.get(M3), F3 = p4.state.lights, et2 = p4.state.shadowsArray, dt2 = F3.state.version, vt2 = Tt2.getParameters(M3, F3.state, et2, N3, z4), St2 = Tt2.getProgramCacheKey(vt2), Ut2 = k3.programs;
      k3.environment = M3.isMeshStandardMaterial ? N3.environment : null, k3.fog = N3.fog, k3.envMap = (M3.isMeshStandardMaterial ? O4 : v3).get(M3.envMap || k3.environment), k3.envMapRotation = k3.environment !== null && M3.envMap === null ? N3.environmentRotation : M3.envMapRotation, Ut2 === void 0 && (M3.addEventListener("dispose", zt2), Ut2 = /* @__PURE__ */ new Map(), k3.programs = Ut2);
      let Nt2 = Ut2.get(St2);
      if (Nt2 !== void 0) {
        if (k3.currentProgram === Nt2 && k3.lightsStateVersion === dt2) return Ju2(M3, vt2), Nt2;
      } else vt2.uniforms = Tt2.getUniforms(M3), M3.onBeforeCompile(vt2, y4), Nt2 = Tt2.acquireProgram(vt2, St2), Ut2.set(St2, Nt2), k3.uniforms = vt2.uniforms;
      let Rt2 = k3.uniforms;
      return (!M3.isShaderMaterial && !M3.isRawShaderMaterial || M3.clipping === true) && (Rt2.clippingPlanes = nt2.uniform), Ju2(M3, vt2), k3.needsLights = yp(M3), k3.lightsStateVersion = dt2, k3.needsLights && (Rt2.ambientLightColor.value = F3.state.ambient, Rt2.lightProbe.value = F3.state.probe, Rt2.directionalLights.value = F3.state.directional, Rt2.directionalLightShadows.value = F3.state.directionalShadow, Rt2.spotLights.value = F3.state.spot, Rt2.spotLightShadows.value = F3.state.spotShadow, Rt2.rectAreaLights.value = F3.state.rectArea, Rt2.ltc_1.value = F3.state.rectAreaLTC1, Rt2.ltc_2.value = F3.state.rectAreaLTC2, Rt2.pointLights.value = F3.state.point, Rt2.pointLightShadows.value = F3.state.pointShadow, Rt2.hemisphereLights.value = F3.state.hemi, Rt2.directionalShadowMap.value = F3.state.directionalShadowMap, Rt2.directionalShadowMatrix.value = F3.state.directionalShadowMatrix, Rt2.spotShadowMap.value = F3.state.spotShadowMap, Rt2.spotLightMatrix.value = F3.state.spotLightMatrix, Rt2.spotLightMap.value = F3.state.spotLightMap, Rt2.pointShadowMap.value = F3.state.pointShadowMap, Rt2.pointShadowMatrix.value = F3.state.pointShadowMatrix), k3.currentProgram = Nt2, k3.uniformsList = null, Nt2;
    }
    H$3(Ks2, "getProgram");
    function Zu2(M3) {
      if (M3.uniformsList === null) {
        let N3 = M3.currentProgram.getUniforms();
        M3.uniformsList = Qi$1.seqWithValue(N3.seq, M3.uniforms);
      }
      return M3.uniformsList;
    }
    H$3(Zu2, "getUniformList");
    function Ju2(M3, N3) {
      let z4 = ft2.get(M3);
      z4.outputColorSpace = N3.outputColorSpace, z4.batching = N3.batching, z4.batchingColor = N3.batchingColor, z4.instancing = N3.instancing, z4.instancingColor = N3.instancingColor, z4.instancingMorph = N3.instancingMorph, z4.skinning = N3.skinning, z4.morphTargets = N3.morphTargets, z4.morphNormals = N3.morphNormals, z4.morphColors = N3.morphColors, z4.morphTargetsCount = N3.morphTargetsCount, z4.numClippingPlanes = N3.numClippingPlanes, z4.numIntersection = N3.numClipIntersection, z4.vertexAlphas = N3.vertexAlphas, z4.vertexTangents = N3.vertexTangents, z4.toneMapping = N3.toneMapping;
    }
    H$3(Ju2, "updateCommonMaterialProperties");
    function xp2(M3, N3, z4, k3, F3) {
      N3.isScene !== true && (N3 = Kt2), T3.resetTextureUnits();
      let et2 = N3.fog, dt2 = k3.isMeshStandardMaterial ? N3.environment : null, vt2 = L3 === null ? y4.outputColorSpace : L3.isXRRenderTarget === true ? L3.texture.colorSpace : ri$1, St2 = (k3.isMeshStandardMaterial ? O4 : v3).get(k3.envMap || dt2), Ut2 = k3.vertexColors === true && !!z4.attributes.color && z4.attributes.color.itemSize === 4, Nt2 = !!z4.attributes.tangent && (!!k3.normalMap || k3.anisotropy > 0), Rt2 = !!z4.morphAttributes.position, Zt2 = !!z4.morphAttributes.normal, jt2 = !!z4.morphAttributes.color, ue2 = Cn$3;
      k3.toneMapped && (L3 === null || L3.isXRRenderTarget === true) && (ue2 = y4.toneMapping);
      let he2 = z4.morphAttributes.position || z4.morphAttributes.normal || z4.morphAttributes.color, Jt2 = he2 !== void 0 ? he2.length : 0, It2 = ft2.get(k3), xe2 = p4.state.lights;
      if (rt2 === true && (Et2 === true || M3 !== S4)) {
        let Re3 = M3 === S4 && k3.id === E4;
        nt2.setState(k3, M3, Re3);
      }
      let te2 = false;
      k3.version === It2.__version ? (It2.needsLights && It2.lightsStateVersion !== xe2.state.version || It2.outputColorSpace !== vt2 || F3.isBatchedMesh && It2.batching === false || !F3.isBatchedMesh && It2.batching === true || F3.isBatchedMesh && It2.batchingColor === true && F3.colorTexture === null || F3.isBatchedMesh && It2.batchingColor === false && F3.colorTexture !== null || F3.isInstancedMesh && It2.instancing === false || !F3.isInstancedMesh && It2.instancing === true || F3.isSkinnedMesh && It2.skinning === false || !F3.isSkinnedMesh && It2.skinning === true || F3.isInstancedMesh && It2.instancingColor === true && F3.instanceColor === null || F3.isInstancedMesh && It2.instancingColor === false && F3.instanceColor !== null || F3.isInstancedMesh && It2.instancingMorph === true && F3.morphTexture === null || F3.isInstancedMesh && It2.instancingMorph === false && F3.morphTexture !== null || It2.envMap !== St2 || k3.fog === true && It2.fog !== et2 || It2.numClippingPlanes !== void 0 && (It2.numClippingPlanes !== nt2.numPlanes || It2.numIntersection !== nt2.numIntersection) || It2.vertexAlphas !== Ut2 || It2.vertexTangents !== Nt2 || It2.morphTargets !== Rt2 || It2.morphNormals !== Zt2 || It2.morphColors !== jt2 || It2.toneMapping !== ue2 || It2.morphTargetsCount !== Jt2) && (te2 = true) : (te2 = true, It2.__version = k3.version);
      let $e3 = It2.currentProgram;
      te2 === true && ($e3 = Ks2(k3, N3, F3));
      let bi3 = false, Be3 = false, ts2 = false, oe2 = $e3.getUniforms(), We2 = It2.uniforms;
      if (st2.useProgram($e3.program) && (bi3 = true, Be3 = true, ts2 = true), k3.id !== E4 && (E4 = k3.id, Be3 = true), bi3 || S4 !== M3) {
        st2.buffers.depth.getReversed() ? (at2.copy(M3.projectionMatrix), Uf$1(at2), Nf$1(at2), oe2.setValue(A3, "projectionMatrix", at2)) : oe2.setValue(A3, "projectionMatrix", M3.projectionMatrix), oe2.setValue(A3, "viewMatrix", M3.matrixWorldInverse);
        let Ue3 = oe2.map.cameraPosition;
        Ue3 !== void 0 && Ue3.setValue(A3, Yt2.setFromMatrixPosition(M3.matrixWorld)), xt2.logarithmicDepthBuffer && oe2.setValue(A3, "logDepthBufFC", 2 / (Math.log(M3.far + 1) / Math.LN2)), (k3.isMeshPhongMaterial || k3.isMeshToonMaterial || k3.isMeshLambertMaterial || k3.isMeshBasicMaterial || k3.isMeshStandardMaterial || k3.isShaderMaterial) && oe2.setValue(A3, "isOrthographic", M3.isOrthographicCamera === true), S4 !== M3 && (S4 = M3, Be3 = true, ts2 = true);
      }
      if (F3.isSkinnedMesh) {
        oe2.setOptional(A3, F3, "bindMatrix"), oe2.setOptional(A3, F3, "bindMatrixInverse");
        let Re3 = F3.skeleton;
        Re3 && (Re3.boneTexture === null && Re3.computeBoneTexture(), oe2.setValue(A3, "boneTexture", Re3.boneTexture, T3));
      }
      F3.isBatchedMesh && (oe2.setOptional(A3, F3, "batchingTexture"), oe2.setValue(A3, "batchingTexture", F3._matricesTexture, T3), oe2.setOptional(A3, F3, "batchingIdTexture"), oe2.setValue(A3, "batchingIdTexture", F3._indirectTexture, T3), oe2.setOptional(A3, F3, "batchingColorTexture"), F3._colorsTexture !== null && oe2.setValue(A3, "batchingColorTexture", F3._colorsTexture, T3));
      let Xe2 = z4.morphAttributes;
      if ((Xe2.position !== void 0 || Xe2.normal !== void 0 || Xe2.color !== void 0) && Lt2.update(F3, z4, $e3), (Be3 || It2.receiveShadow !== F3.receiveShadow) && (It2.receiveShadow = F3.receiveShadow, oe2.setValue(A3, "receiveShadow", F3.receiveShadow)), k3.isMeshGouraudMaterial && k3.envMap !== null && (We2.envMap.value = St2, We2.flipEnvMap.value = St2.isCubeTexture && St2.isRenderTargetTexture === false ? -1 : 1), k3.isMeshStandardMaterial && k3.envMap === null && N3.environment !== null && (We2.envMapIntensity.value = N3.environmentIntensity), Be3 && (oe2.setValue(A3, "toneMappingExposure", y4.toneMappingExposure), It2.needsLights && vp3(We2, ts2), et2 && k3.fog === true && ht2.refreshFogUniforms(We2, et2), ht2.refreshMaterialUniforms(We2, k3, W4, it2, p4.state.transmissionRenderTarget[M3.id]), Qi$1.upload(A3, Zu2(It2), We2, T3)), k3.isShaderMaterial && k3.uniformsNeedUpdate === true && (Qi$1.upload(A3, Zu2(It2), We2, T3), k3.uniformsNeedUpdate = false), k3.isSpriteMaterial && oe2.setValue(A3, "center", F3.center), oe2.setValue(A3, "modelViewMatrix", F3.modelViewMatrix), oe2.setValue(A3, "normalMatrix", F3.normalMatrix), oe2.setValue(A3, "modelMatrix", F3.matrixWorld), k3.isShaderMaterial || k3.isRawShaderMaterial) {
        let Re3 = k3.uniformsGroups;
        for (let Ue3 = 0, To2 = Re3.length; Ue3 < To2; Ue3++) {
          let qn3 = Re3[Ue3];
          U3.update(qn3, $e3), U3.bind(qn3, $e3);
        }
      }
      return $e3;
    }
    H$3(xp2, "setProgram");
    function vp3(M3, N3) {
      M3.ambientLightColor.needsUpdate = N3, M3.lightProbe.needsUpdate = N3, M3.directionalLights.needsUpdate = N3, M3.directionalLightShadows.needsUpdate = N3, M3.pointLights.needsUpdate = N3, M3.pointLightShadows.needsUpdate = N3, M3.spotLights.needsUpdate = N3, M3.spotLightShadows.needsUpdate = N3, M3.rectAreaLights.needsUpdate = N3, M3.hemisphereLights.needsUpdate = N3;
    }
    H$3(vp3, "markUniformsLightsNeedsUpdate");
    function yp(M3) {
      return M3.isMeshLambertMaterial || M3.isMeshToonMaterial || M3.isMeshPhongMaterial || M3.isMeshStandardMaterial || M3.isShadowMaterial || M3.isShaderMaterial && M3.lights === true;
    }
    H$3(yp, "materialNeedsLights"), this.getActiveCubeFace = function() {
      return C3;
    }, this.getActiveMipmapLevel = function() {
      return R3;
    }, this.getRenderTarget = function() {
      return L3;
    }, this.setRenderTargetTextures = function(M3, N3, z4) {
      ft2.get(M3.texture).__webglTexture = N3, ft2.get(M3.depthTexture).__webglTexture = z4;
      let k3 = ft2.get(M3);
      k3.__hasExternalTextures = true, k3.__autoAllocateDepthBuffer = z4 === void 0, k3.__autoAllocateDepthBuffer || tt2.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), k3.__useRenderToTexture = false);
    }, this.setRenderTargetFramebuffer = function(M3, N3) {
      let z4 = ft2.get(M3);
      z4.__webglFramebuffer = N3, z4.__useDefaultFramebuffer = N3 === void 0;
    };
    let Mp2 = A3.createFramebuffer();
    this.setRenderTarget = function(M3, N3 = 0, z4 = 0) {
      L3 = M3, C3 = N3, R3 = z4;
      let k3 = true, F3 = null, et2 = false, dt2 = false;
      if (M3) {
        let St2 = ft2.get(M3);
        if (St2.__useDefaultFramebuffer !== void 0) st2.bindFramebuffer(A3.FRAMEBUFFER, null), k3 = false;
        else if (St2.__webglFramebuffer === void 0) T3.setupRenderTarget(M3);
        else if (St2.__hasExternalTextures) T3.rebindTextures(M3, ft2.get(M3.texture).__webglTexture, ft2.get(M3.depthTexture).__webglTexture);
        else if (M3.depthBuffer) {
          let Rt2 = M3.depthTexture;
          if (St2.__boundDepthTexture !== Rt2) {
            if (Rt2 !== null && ft2.has(Rt2) && (M3.width !== Rt2.image.width || M3.height !== Rt2.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            T3.setupDepthRenderbuffer(M3);
          }
        }
        let Ut2 = M3.texture;
        (Ut2.isData3DTexture || Ut2.isDataArrayTexture || Ut2.isCompressedArrayTexture) && (dt2 = true);
        let Nt2 = ft2.get(M3).__webglFramebuffer;
        M3.isWebGLCubeRenderTarget ? (Array.isArray(Nt2[N3]) ? F3 = Nt2[N3][z4] : F3 = Nt2[N3], et2 = true) : M3.samples > 0 && T3.useMultisampledRTT(M3) === false ? F3 = ft2.get(M3).__webglMultisampledFramebuffer : Array.isArray(Nt2) ? F3 = Nt2[z4] : F3 = Nt2, P4.copy(M3.viewport), G3.copy(M3.scissor), B3 = M3.scissorTest;
      } else P4.copy(bt2).multiplyScalar(W4).floor(), G3.copy(Ot2).multiplyScalar(W4).floor(), B3 = Qt2;
      if (z4 !== 0 && (F3 = Mp2), st2.bindFramebuffer(A3.FRAMEBUFFER, F3) && k3 && st2.drawBuffers(M3, F3), st2.viewport(P4), st2.scissor(G3), st2.setScissorTest(B3), et2) {
        let St2 = ft2.get(M3.texture);
        A3.framebufferTexture2D(A3.FRAMEBUFFER, A3.COLOR_ATTACHMENT0, A3.TEXTURE_CUBE_MAP_POSITIVE_X + N3, St2.__webglTexture, z4);
      } else if (dt2) {
        let St2 = ft2.get(M3.texture), Ut2 = N3;
        A3.framebufferTextureLayer(A3.FRAMEBUFFER, A3.COLOR_ATTACHMENT0, St2.__webglTexture, z4, Ut2);
      } else if (M3 !== null && z4 !== 0) {
        let St2 = ft2.get(M3.texture);
        A3.framebufferTexture2D(A3.FRAMEBUFFER, A3.COLOR_ATTACHMENT0, A3.TEXTURE_2D, St2.__webglTexture, z4);
      }
      E4 = -1;
    }, this.readRenderTargetPixels = function(M3, N3, z4, k3, F3, et2, dt2) {
      if (!(M3 && M3.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let vt2 = ft2.get(M3).__webglFramebuffer;
      if (M3.isWebGLCubeRenderTarget && dt2 !== void 0 && (vt2 = vt2[dt2]), vt2) {
        st2.bindFramebuffer(A3.FRAMEBUFFER, vt2);
        try {
          let St2 = M3.texture, Ut2 = St2.format, Nt2 = St2.type;
          if (!xt2.textureFormatReadable(Ut2)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!xt2.textureTypeReadable(Nt2)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          N3 >= 0 && N3 <= M3.width - k3 && z4 >= 0 && z4 <= M3.height - F3 && A3.readPixels(N3, z4, k3, F3, kt2.convert(Ut2), kt2.convert(Nt2), et2);
        } finally {
          let St2 = L3 !== null ? ft2.get(L3).__webglFramebuffer : null;
          st2.bindFramebuffer(A3.FRAMEBUFFER, St2);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(M3, N3, z4, k3, F3, et2, dt2) {
      if (!(M3 && M3.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let vt2 = ft2.get(M3).__webglFramebuffer;
      if (M3.isWebGLCubeRenderTarget && dt2 !== void 0 && (vt2 = vt2[dt2]), vt2) {
        let St2 = M3.texture, Ut2 = St2.format, Nt2 = St2.type;
        if (!xt2.textureFormatReadable(Ut2)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!xt2.textureTypeReadable(Nt2)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (N3 >= 0 && N3 <= M3.width - k3 && z4 >= 0 && z4 <= M3.height - F3) {
          st2.bindFramebuffer(A3.FRAMEBUFFER, vt2);
          let Rt2 = A3.createBuffer();
          A3.bindBuffer(A3.PIXEL_PACK_BUFFER, Rt2), A3.bufferData(A3.PIXEL_PACK_BUFFER, et2.byteLength, A3.STREAM_READ), A3.readPixels(N3, z4, k3, F3, kt2.convert(Ut2), kt2.convert(Nt2), 0);
          let Zt2 = L3 !== null ? ft2.get(L3).__webglFramebuffer : null;
          st2.bindFramebuffer(A3.FRAMEBUFFER, Zt2);
          let jt2 = A3.fenceSync(A3.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return A3.flush(), await Lf$1(A3, jt2, 4), A3.bindBuffer(A3.PIXEL_PACK_BUFFER, Rt2), A3.getBufferSubData(A3.PIXEL_PACK_BUFFER, 0, et2), A3.deleteBuffer(Rt2), A3.deleteSync(jt2), et2;
        } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(M3, N3 = null, z4 = 0) {
      M3.isTexture !== true && (_i$1("WebGLRenderer: copyFramebufferToTexture function signature has changed."), N3 = arguments[0] || null, M3 = arguments[1]);
      let k3 = Math.pow(2, -z4), F3 = Math.floor(M3.image.width * k3), et2 = Math.floor(M3.image.height * k3), dt2 = N3 !== null ? N3.x : 0, vt2 = N3 !== null ? N3.y : 0;
      T3.setTexture2D(M3, 0), A3.copyTexSubImage2D(A3.TEXTURE_2D, z4, 0, 0, dt2, vt2, F3, et2), st2.unbindTexture();
    };
    let Sp2 = A3.createFramebuffer(), bp2 = A3.createFramebuffer();
    this.copyTextureToTexture = function(M3, N3, z4 = null, k3 = null, F3 = 0, et2 = null) {
      M3.isTexture !== true && (_i$1("WebGLRenderer: copyTextureToTexture function signature has changed."), k3 = arguments[0] || null, M3 = arguments[1], N3 = arguments[2], et2 = arguments[3] || 0, z4 = null), et2 === null && (F3 !== 0 ? (_i$1("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), et2 = F3, F3 = 0) : et2 = 0);
      let dt2, vt2, St2, Ut2, Nt2, Rt2, Zt2, jt2, ue2, he2 = M3.isCompressedTexture ? M3.mipmaps[et2] : M3.image;
      if (z4 !== null) dt2 = z4.max.x - z4.min.x, vt2 = z4.max.y - z4.min.y, St2 = z4.isBox3 ? z4.max.z - z4.min.z : 1, Ut2 = z4.min.x, Nt2 = z4.min.y, Rt2 = z4.isBox3 ? z4.min.z : 0;
      else {
        let Xe2 = Math.pow(2, -F3);
        dt2 = Math.floor(he2.width * Xe2), vt2 = Math.floor(he2.height * Xe2), M3.isDataArrayTexture ? St2 = he2.depth : M3.isData3DTexture ? St2 = Math.floor(he2.depth * Xe2) : St2 = 1, Ut2 = 0, Nt2 = 0, Rt2 = 0;
      }
      k3 !== null ? (Zt2 = k3.x, jt2 = k3.y, ue2 = k3.z) : (Zt2 = 0, jt2 = 0, ue2 = 0);
      let Jt2 = kt2.convert(N3.format), It2 = kt2.convert(N3.type), xe2;
      N3.isData3DTexture ? (T3.setTexture3D(N3, 0), xe2 = A3.TEXTURE_3D) : N3.isDataArrayTexture || N3.isCompressedArrayTexture ? (T3.setTexture2DArray(N3, 0), xe2 = A3.TEXTURE_2D_ARRAY) : (T3.setTexture2D(N3, 0), xe2 = A3.TEXTURE_2D), A3.pixelStorei(A3.UNPACK_FLIP_Y_WEBGL, N3.flipY), A3.pixelStorei(A3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N3.premultiplyAlpha), A3.pixelStorei(A3.UNPACK_ALIGNMENT, N3.unpackAlignment);
      let te2 = A3.getParameter(A3.UNPACK_ROW_LENGTH), $e3 = A3.getParameter(A3.UNPACK_IMAGE_HEIGHT), bi3 = A3.getParameter(A3.UNPACK_SKIP_PIXELS), Be3 = A3.getParameter(A3.UNPACK_SKIP_ROWS), ts2 = A3.getParameter(A3.UNPACK_SKIP_IMAGES);
      A3.pixelStorei(A3.UNPACK_ROW_LENGTH, he2.width), A3.pixelStorei(A3.UNPACK_IMAGE_HEIGHT, he2.height), A3.pixelStorei(A3.UNPACK_SKIP_PIXELS, Ut2), A3.pixelStorei(A3.UNPACK_SKIP_ROWS, Nt2), A3.pixelStorei(A3.UNPACK_SKIP_IMAGES, Rt2);
      let oe2 = M3.isDataArrayTexture || M3.isData3DTexture, We2 = N3.isDataArrayTexture || N3.isData3DTexture;
      if (M3.isDepthTexture) {
        let Xe2 = ft2.get(M3), Re3 = ft2.get(N3), Ue3 = ft2.get(Xe2.__renderTarget), To2 = ft2.get(Re3.__renderTarget);
        st2.bindFramebuffer(A3.READ_FRAMEBUFFER, Ue3.__webglFramebuffer), st2.bindFramebuffer(A3.DRAW_FRAMEBUFFER, To2.__webglFramebuffer);
        for (let qn3 = 0; qn3 < St2; qn3++) oe2 && (A3.framebufferTextureLayer(A3.READ_FRAMEBUFFER, A3.COLOR_ATTACHMENT0, ft2.get(M3).__webglTexture, F3, Rt2 + qn3), A3.framebufferTextureLayer(A3.DRAW_FRAMEBUFFER, A3.COLOR_ATTACHMENT0, ft2.get(N3).__webglTexture, et2, ue2 + qn3)), A3.blitFramebuffer(Ut2, Nt2, dt2, vt2, Zt2, jt2, dt2, vt2, A3.DEPTH_BUFFER_BIT, A3.NEAREST);
        st2.bindFramebuffer(A3.READ_FRAMEBUFFER, null), st2.bindFramebuffer(A3.DRAW_FRAMEBUFFER, null);
      } else if (F3 !== 0 || M3.isRenderTargetTexture || ft2.has(M3)) {
        let Xe2 = ft2.get(M3), Re3 = ft2.get(N3);
        st2.bindFramebuffer(A3.READ_FRAMEBUFFER, Sp2), st2.bindFramebuffer(A3.DRAW_FRAMEBUFFER, bp2);
        for (let Ue3 = 0; Ue3 < St2; Ue3++) oe2 ? A3.framebufferTextureLayer(A3.READ_FRAMEBUFFER, A3.COLOR_ATTACHMENT0, Xe2.__webglTexture, F3, Rt2 + Ue3) : A3.framebufferTexture2D(A3.READ_FRAMEBUFFER, A3.COLOR_ATTACHMENT0, A3.TEXTURE_2D, Xe2.__webglTexture, F3), We2 ? A3.framebufferTextureLayer(A3.DRAW_FRAMEBUFFER, A3.COLOR_ATTACHMENT0, Re3.__webglTexture, et2, ue2 + Ue3) : A3.framebufferTexture2D(A3.DRAW_FRAMEBUFFER, A3.COLOR_ATTACHMENT0, A3.TEXTURE_2D, Re3.__webglTexture, et2), F3 !== 0 ? A3.blitFramebuffer(Ut2, Nt2, dt2, vt2, Zt2, jt2, dt2, vt2, A3.COLOR_BUFFER_BIT, A3.NEAREST) : We2 ? A3.copyTexSubImage3D(xe2, et2, Zt2, jt2, ue2 + Ue3, Ut2, Nt2, dt2, vt2) : A3.copyTexSubImage2D(xe2, et2, Zt2, jt2, Ut2, Nt2, dt2, vt2);
        st2.bindFramebuffer(A3.READ_FRAMEBUFFER, null), st2.bindFramebuffer(A3.DRAW_FRAMEBUFFER, null);
      } else We2 ? M3.isDataTexture || M3.isData3DTexture ? A3.texSubImage3D(xe2, et2, Zt2, jt2, ue2, dt2, vt2, St2, Jt2, It2, he2.data) : N3.isCompressedArrayTexture ? A3.compressedTexSubImage3D(xe2, et2, Zt2, jt2, ue2, dt2, vt2, St2, Jt2, he2.data) : A3.texSubImage3D(xe2, et2, Zt2, jt2, ue2, dt2, vt2, St2, Jt2, It2, he2) : M3.isDataTexture ? A3.texSubImage2D(A3.TEXTURE_2D, et2, Zt2, jt2, dt2, vt2, Jt2, It2, he2.data) : M3.isCompressedTexture ? A3.compressedTexSubImage2D(A3.TEXTURE_2D, et2, Zt2, jt2, he2.width, he2.height, Jt2, he2.data) : A3.texSubImage2D(A3.TEXTURE_2D, et2, Zt2, jt2, dt2, vt2, Jt2, It2, he2);
      A3.pixelStorei(A3.UNPACK_ROW_LENGTH, te2), A3.pixelStorei(A3.UNPACK_IMAGE_HEIGHT, $e3), A3.pixelStorei(A3.UNPACK_SKIP_PIXELS, bi3), A3.pixelStorei(A3.UNPACK_SKIP_ROWS, Be3), A3.pixelStorei(A3.UNPACK_SKIP_IMAGES, ts2), et2 === 0 && N3.generateMipmaps && A3.generateMipmap(xe2), st2.unbindTexture();
    }, this.copyTextureToTexture3D = function(M3, N3, z4 = null, k3 = null, F3 = 0) {
      return M3.isTexture !== true && (_i$1("WebGLRenderer: copyTextureToTexture3D function signature has changed."), z4 = arguments[0] || null, k3 = arguments[1] || null, M3 = arguments[2], N3 = arguments[3], F3 = arguments[4] || 0), _i$1('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(M3, N3, z4, k3, F3);
    }, this.initRenderTarget = function(M3) {
      ft2.get(M3).__webglFramebuffer === void 0 && T3.setupRenderTarget(M3);
    }, this.initTexture = function(M3) {
      M3.isCubeTexture ? T3.setTextureCube(M3, 0) : M3.isData3DTexture ? T3.setTexture3D(M3, 0) : M3.isDataArrayTexture || M3.isCompressedArrayTexture ? T3.setTexture2DArray(M3, 0) : T3.setTexture2D(M3, 0), st2.unbindTexture();
    }, this.resetState = function() {
      C3 = 0, R3 = 0, L3 = null, st2.reset(), se3.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return an;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t;
    let e = this.getContext();
    e.drawingBufferColorspace = qt$2._getDrawingBufferColorSpace(t), e.unpackColorSpace = qt$2._getUnpackColorSpace();
  }
};
H$3(Hu$2, "WebGLRenderer");
var dp$1 = Hu$2;
a();
function R(o4, l = false) {
  let r5 = o4[0].index !== null, f = new Set(Object.keys(o4[0].attributes)), i = new Set(Object.keys(o4[0].morphAttributes)), c = {}, e = {}, h = o4[0].morphTargetsRelative, u5 = new pe$3(), d = 0;
  for (let t = 0; t < o4.length; ++t) {
    let s5 = o4[t], a4 = 0;
    if (r5 !== (s5.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (let n4 in s5.attributes) {
      if (!f.has(n4)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + '. All geometries must have compatible attributes; make sure "' + n4 + '" attribute exists among all geometries, or in none of them.'), null;
      c[n4] === void 0 && (c[n4] = []), c[n4].push(s5.attributes[n4]), a4++;
    }
    if (a4 !== f.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". Make sure all geometries have the same number of attributes."), null;
    if (h !== s5.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (let n4 in s5.morphAttributes) {
      if (!i.has(n4)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ".  .morphAttributes must be consistent throughout all geometries."), null;
      e[n4] === void 0 && (e[n4] = []), e[n4].push(s5.morphAttributes[n4]);
    }
    if (l) {
      let n4;
      if (r5) n4 = s5.index.count;
      else if (s5.attributes.position !== void 0) n4 = s5.attributes.position.count;
      else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + t + ". The geometry must have either an index or a position attribute"), null;
      u5.addGroup(d, n4, t), d += n4;
    }
  }
  if (r5) {
    let t = 0, s5 = [];
    for (let a4 = 0; a4 < o4.length; ++a4) {
      let n4 = o4[a4].index;
      for (let m5 = 0; m5 < n4.count; ++m5) s5.push(n4.getX(m5) + t);
      t += o4[a4].attributes.position.count;
    }
    u5.setIndex(s5);
  }
  for (let t in c) {
    let s5 = T$1(c[t]);
    if (!s5) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + t + " attribute."), null;
    u5.setAttribute(t, s5);
  }
  for (let t in e) {
    let s5 = e[t][0].length;
    if (s5 === 0) break;
    u5.morphAttributes = u5.morphAttributes || {}, u5.morphAttributes[t] = [];
    for (let a4 = 0; a4 < s5; ++a4) {
      let n4 = [];
      for (let p4 = 0; p4 < e[t].length; ++p4) n4.push(e[t][p4][a4]);
      let m5 = T$1(n4);
      if (!m5) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + t + " morphAttribute."), null;
      u5.morphAttributes[t].push(m5);
    }
  }
  return u5;
}
H$3(R, "mergeGeometries");
function T$1(o4) {
  let l, r5, f, i = -1, c = 0;
  for (let d = 0; d < o4.length; ++d) {
    let t = o4[d];
    if (l === void 0 && (l = t.array.constructor), l !== t.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (r5 === void 0 && (r5 = t.itemSize), r5 !== t.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (f === void 0 && (f = t.normalized), f !== t.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (i === -1 && (i = t.gpuType), i !== t.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    c += t.count * r5;
  }
  let e = new l(c), h = new ve$3(e, r5, f), u5 = 0;
  for (let d = 0; d < o4.length; ++d) {
    let t = o4[d];
    if (t.isInterleavedBufferAttribute) {
      let s5 = u5 / r5;
      for (let a4 = 0, n4 = t.count; a4 < n4; a4++) for (let m5 = 0; m5 < r5; m5++) {
        let p4 = t.getComponent(a4, m5);
        h.setComponent(a4 + s5, m5, p4);
      }
    } else e.set(t.array, u5);
    u5 += t.count * r5;
  }
  return i !== void 0 && (h.gpuType = i), h;
}
H$3(T$1, "mergeAttributes");
function X$2(o4, l) {
  if (l === Ap$2) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o4;
  if (l === Cp$2 || l === wp$2) {
    let r5 = o4.getIndex();
    if (r5 === null) {
      let e = [], h = o4.getAttribute("position");
      if (h !== void 0) {
        for (let u5 = 0; u5 < h.count; u5++) e.push(u5);
        o4.setIndex(e), r5 = o4.getIndex();
      } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), o4;
    }
    let f = r5.count - 2, i = [];
    if (l === Cp$2) for (let e = 1; e <= f; e++) i.push(r5.getX(0)), i.push(r5.getX(e)), i.push(r5.getX(e + 1));
    else for (let e = 0; e < f; e++) e % 2 === 0 ? (i.push(r5.getX(e)), i.push(r5.getX(e + 1)), i.push(r5.getX(e + 2))) : (i.push(r5.getX(e + 2)), i.push(r5.getX(e + 1)), i.push(r5.getX(e)));
    i.length / 3 !== f && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    let c = o4.clone();
    return c.setIndex(i), c.clearGroups(), c;
  } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", l), o4;
}
H$3(X$2, "toTrianglesDrawMode");
var m$1 = L((s5, c) => {
  a();
  (function(n4, u5) {
    typeof s5 == "object" && typeof c < "u" ? c.exports = u5() : typeof define == "function" && define.amd ? define(u5) : (n4 = n4 || self, n4.TinyQueue = u5());
  })(s5, function() {
    var n4 = H$3(function(t, i) {
      if (t === void 0 && (t = []), i === void 0 && (i = u5), this.data = t, this.length = this.data.length, this.compare = i, this.length > 0) for (var e = (this.length >> 1) - 1; e >= 0; e--) this._down(e);
    }, "TinyQueue");
    n4.prototype.push = H$3(function(t) {
      this.data.push(t), this.length++, this._up(this.length - 1);
    }, "push"), n4.prototype.pop = H$3(function() {
      if (this.length !== 0) {
        var t = this.data[0], i = this.data.pop();
        return this.length--, this.length > 0 && (this.data[0] = i, this._down(0)), t;
      }
    }, "pop"), n4.prototype.peek = H$3(function() {
      return this.data[0];
    }, "peek"), n4.prototype._up = H$3(function(t) {
      for (var i = this, e = i.data, o4 = i.compare, d = e[t]; t > 0; ) {
        var f = t - 1 >> 1, r5 = e[f];
        if (o4(d, r5) >= 0) break;
        e[t] = r5, t = f;
      }
      e[t] = d;
    }, "_up"), n4.prototype._down = H$3(function(t) {
      for (var i = this, e = i.data, o4 = i.compare, d = this.length >> 1, f = e[t]; t < d; ) {
        var r5 = (t << 1) + 1, p4 = e[r5], v3 = r5 + 1;
        if (v3 < this.length && o4(e[v3], p4) < 0 && (r5 = v3, p4 = e[v3]), o4(p4, f) >= 0) break;
        e[t] = p4, t = r5;
      }
      e[t] = f;
    }, "_down");
    function u5(a4, t) {
      return a4 < t ? -1 : a4 > t ? 1 : 0;
    }
    return H$3(u5, "defaultCompare"), n4;
  });
});
var ge = L((ID2, Gx2) => {
  a();
  Gx2.exports = Ei2;
  function Ei2(r5, e) {
    this.x = r5, this.y = e;
  }
  H$3(Ei2, "Point");
  Ei2.prototype = { clone: H$3(function() {
    return new Ei2(this.x, this.y);
  }, "clone"), add: H$3(function(r5) {
    return this.clone()._add(r5);
  }, "add"), sub: H$3(function(r5) {
    return this.clone()._sub(r5);
  }, "sub"), multByPoint: H$3(function(r5) {
    return this.clone()._multByPoint(r5);
  }, "multByPoint"), divByPoint: H$3(function(r5) {
    return this.clone()._divByPoint(r5);
  }, "divByPoint"), mult: H$3(function(r5) {
    return this.clone()._mult(r5);
  }, "mult"), div: H$3(function(r5) {
    return this.clone()._div(r5);
  }, "div"), rotate: H$3(function(r5) {
    return this.clone()._rotate(r5);
  }, "rotate"), rotateAround: H$3(function(r5, e) {
    return this.clone()._rotateAround(r5, e);
  }, "rotateAround"), matMult: H$3(function(r5) {
    return this.clone()._matMult(r5);
  }, "matMult"), unit: H$3(function() {
    return this.clone()._unit();
  }, "unit"), perp: H$3(function() {
    return this.clone()._perp();
  }, "perp"), round: H$3(function() {
    return this.clone()._round();
  }, "round"), mag: H$3(function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, "mag"), equals: H$3(function(r5) {
    return this.x === r5.x && this.y === r5.y;
  }, "equals"), dist: H$3(function(r5) {
    return Math.sqrt(this.distSqr(r5));
  }, "dist"), distSqr: H$3(function(r5) {
    var e = r5.x - this.x, t = r5.y - this.y;
    return e * e + t * t;
  }, "distSqr"), angle: H$3(function() {
    return Math.atan2(this.y, this.x);
  }, "angle"), angleTo: H$3(function(r5) {
    return Math.atan2(this.y - r5.y, this.x - r5.x);
  }, "angleTo"), angleWith: H$3(function(r5) {
    return this.angleWithSep(r5.x, r5.y);
  }, "angleWith"), angleWithSep: H$3(function(r5, e) {
    return Math.atan2(this.x * e - this.y * r5, this.x * r5 + this.y * e);
  }, "angleWithSep"), _matMult: H$3(function(r5) {
    var e = r5[0] * this.x + r5[1] * this.y, t = r5[2] * this.x + r5[3] * this.y;
    return this.x = e, this.y = t, this;
  }, "_matMult"), _add: H$3(function(r5) {
    return this.x += r5.x, this.y += r5.y, this;
  }, "_add"), _sub: H$3(function(r5) {
    return this.x -= r5.x, this.y -= r5.y, this;
  }, "_sub"), _mult: H$3(function(r5) {
    return this.x *= r5, this.y *= r5, this;
  }, "_mult"), _div: H$3(function(r5) {
    return this.x /= r5, this.y /= r5, this;
  }, "_div"), _multByPoint: H$3(function(r5) {
    return this.x *= r5.x, this.y *= r5.y, this;
  }, "_multByPoint"), _divByPoint: H$3(function(r5) {
    return this.x /= r5.x, this.y /= r5.y, this;
  }, "_divByPoint"), _unit: H$3(function() {
    return this._div(this.mag()), this;
  }, "_unit"), _perp: H$3(function() {
    var r5 = this.y;
    return this.y = this.x, this.x = -r5, this;
  }, "_perp"), _rotate: H$3(function(r5) {
    var e = Math.cos(r5), t = Math.sin(r5), i = e * this.x - t * this.y, n4 = t * this.x + e * this.y;
    return this.x = i, this.y = n4, this;
  }, "_rotate"), _rotateAround: H$3(function(r5, e) {
    var t = Math.cos(r5), i = Math.sin(r5), n4 = e.x + t * (this.x - e.x) - i * (this.y - e.y), o4 = e.y + i * (this.x - e.x) + t * (this.y - e.y);
    return this.x = n4, this.y = o4, this;
  }, "_rotateAround"), _round: H$3(function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }, "_round") };
  Ei2.convert = function(r5) {
    return r5 instanceof Ei2 ? r5 : Array.isArray(r5) ? new Ei2(r5[0], r5[1]) : r5;
  };
});
var Zx$1 = L((kD2, jx2) => {
  a();
  jx2.exports = qx2;
  function qx2(r5, e, t, i) {
    this.cx = 3 * r5, this.bx = 3 * (t - r5) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (i - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = r5, this.p1y = e, this.p2x = t, this.p2y = i;
  }
  H$3(qx2, "UnitBezier");
  qx2.prototype = { sampleCurveX: H$3(function(r5) {
    return ((this.ax * r5 + this.bx) * r5 + this.cx) * r5;
  }, "sampleCurveX"), sampleCurveY: H$3(function(r5) {
    return ((this.ay * r5 + this.by) * r5 + this.cy) * r5;
  }, "sampleCurveY"), sampleCurveDerivativeX: H$3(function(r5) {
    return (3 * this.ax * r5 + 2 * this.bx) * r5 + this.cx;
  }, "sampleCurveDerivativeX"), solveCurveX: H$3(function(r5, e) {
    if (e === void 0 && (e = 1e-6), r5 < 0) return 0;
    if (r5 > 1) return 1;
    for (var t = r5, i = 0; i < 8; i++) {
      var n4 = this.sampleCurveX(t) - r5;
      if (Math.abs(n4) < e) return t;
      var o4 = this.sampleCurveDerivativeX(t);
      if (Math.abs(o4) < 1e-6) break;
      t = t - n4 / o4;
    }
    var a4 = 0, s5 = 1;
    for (t = r5, i = 0; i < 20 && (n4 = this.sampleCurveX(t), !(Math.abs(n4 - r5) < e)); i++) r5 > n4 ? a4 = t : s5 = t, t = (s5 - a4) * 0.5 + a4;
    return t;
  }, "solveCurveX"), solve: H$3(function(r5, e) {
    return this.sampleCurveY(this.solveCurveX(r5, e));
  }, "solve") };
});
var z_ = L((_R, Kf2) => {
  a();
  function pM3(r5, e) {
    var t, i, n4, o4, a4, u5, p4, h;
    for (t = r5.length & 3, i = r5.length - t, n4 = e, a4 = 3432918353, u5 = 461845907, h = 0; h < i; ) p4 = r5.charCodeAt(h) & 255 | (r5.charCodeAt(++h) & 255) << 8 | (r5.charCodeAt(++h) & 255) << 16 | (r5.charCodeAt(++h) & 255) << 24, ++h, p4 = (p4 & 65535) * a4 + (((p4 >>> 16) * a4 & 65535) << 16) & 4294967295, p4 = p4 << 15 | p4 >>> 17, p4 = (p4 & 65535) * u5 + (((p4 >>> 16) * u5 & 65535) << 16) & 4294967295, n4 ^= p4, n4 = n4 << 13 | n4 >>> 19, o4 = (n4 & 65535) * 5 + (((n4 >>> 16) * 5 & 65535) << 16) & 4294967295, n4 = (o4 & 65535) + 27492 + (((o4 >>> 16) + 58964 & 65535) << 16);
    switch (p4 = 0, t) {
      case 3:
        p4 ^= (r5.charCodeAt(h + 2) & 255) << 16;
      case 2:
        p4 ^= (r5.charCodeAt(h + 1) & 255) << 8;
      case 1:
        p4 ^= r5.charCodeAt(h) & 255, p4 = (p4 & 65535) * a4 + (((p4 >>> 16) * a4 & 65535) << 16) & 4294967295, p4 = p4 << 15 | p4 >>> 17, p4 = (p4 & 65535) * u5 + (((p4 >>> 16) * u5 & 65535) << 16) & 4294967295, n4 ^= p4;
    }
    return n4 ^= r5.length, n4 ^= n4 >>> 16, n4 = (n4 & 65535) * 2246822507 + (((n4 >>> 16) * 2246822507 & 65535) << 16) & 4294967295, n4 ^= n4 >>> 13, n4 = (n4 & 65535) * 3266489909 + (((n4 >>> 16) * 3266489909 & 65535) << 16) & 4294967295, n4 ^= n4 >>> 16, n4 >>> 0;
  }
  H$3(pM3, "murmurhash3_32_gc");
  typeof Kf2 < "u" && (Kf2.exports = pM3);
});
var F_ = L((SR, Jf2) => {
  a();
  function hM3(r5, e) {
    for (var t = r5.length, i = e ^ t, n4 = 0, o4; t >= 4; ) o4 = r5.charCodeAt(n4) & 255 | (r5.charCodeAt(++n4) & 255) << 8 | (r5.charCodeAt(++n4) & 255) << 16 | (r5.charCodeAt(++n4) & 255) << 24, o4 = (o4 & 65535) * 1540483477 + (((o4 >>> 16) * 1540483477 & 65535) << 16), o4 ^= o4 >>> 24, o4 = (o4 & 65535) * 1540483477 + (((o4 >>> 16) * 1540483477 & 65535) << 16), i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16) ^ o4, t -= 4, ++n4;
    switch (t) {
      case 3:
        i ^= (r5.charCodeAt(n4 + 2) & 255) << 16;
      case 2:
        i ^= (r5.charCodeAt(n4 + 1) & 255) << 8;
      case 1:
        i ^= r5.charCodeAt(n4) & 255, i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16);
    }
    return i ^= i >>> 13, i = (i & 65535) * 1540483477 + (((i >>> 16) * 1540483477 & 65535) << 16), i ^= i >>> 15, i >>> 0;
  }
  H$3(hM3, "murmurhash2_32_gc");
  typeof Jf2 !== void 0 && (Jf2.exports = hM3);
});
var Yf = L((MR, Tl2) => {
  a();
  var R_2 = z_(), fM3 = F_();
  Tl2.exports = R_2;
  Tl2.exports.murmur3 = R_2;
  Tl2.exports.murmur2 = fM3;
});
var Em$1 = L((mO2, Cm2) => {
  a();
  Cm2.exports = Nl2;
  Cm2.exports.default = Nl2;
  function Nl2(r5, e, t) {
    t = t || 2;
    var i = e && e.length, n4 = i ? e[0] * t : r5.length, o4 = Nv(r5, 0, n4, t, true), a4 = [];
    if (!o4 || o4.next === o4.prev) return a4;
    var s5, u5, c, p4, h, f, m5;
    if (i && (o4 = SE(r5, e, o4, t)), r5.length > 80 * t) {
      s5 = c = r5[0], u5 = p4 = r5[1];
      for (var y4 = t; y4 < n4; y4 += t) h = r5[y4], f = r5[y4 + 1], h < s5 && (s5 = h), f < u5 && (u5 = f), h > c && (c = h), f > p4 && (p4 = f);
      m5 = Math.max(c - s5, p4 - u5), m5 = m5 !== 0 ? 32767 / m5 : 0;
    }
    return Go2(o4, a4, t, s5, u5, m5, 0), a4;
  }
  H$3(Nl2, "earcut");
  function Nv(r5, e, t, i, n4) {
    var o4, a4;
    if (n4 === Im2(r5, e, t, i) > 0) for (o4 = e; o4 < t; o4 += i) a4 = Uv2(o4, r5[o4], r5[o4 + 1], a4);
    else for (o4 = t - i; o4 >= e; o4 -= i) a4 = Uv2(o4, r5[o4], r5[o4 + 1], a4);
    return a4 && Gl2(a4, a4.next) && (jo2(a4), a4 = a4.next), a4;
  }
  H$3(Nv, "linkedList");
  function di2(r5, e) {
    if (!r5) return r5;
    e || (e = r5);
    var t = r5, i;
    do
      if (i = false, !t.steiner && (Gl2(t, t.next) || Oe2(t.prev, t, t.next) === 0)) {
        if (jo2(t), t = e = t.prev, t === t.next) break;
        i = true;
      } else t = t.next;
    while (i || t !== e);
    return e;
  }
  H$3(di2, "filterPoints");
  function Go2(r5, e, t, i, n4, o4, a4) {
    if (r5) {
      !a4 && o4 && IE(r5, i, n4, o4);
      for (var s5 = r5, u5, c; r5.prev !== r5.next; ) {
        if (u5 = r5.prev, c = r5.next, o4 ? _E(r5, i, n4, o4) : bE(r5)) {
          e.push(u5.i / t | 0), e.push(r5.i / t | 0), e.push(c.i / t | 0), jo2(r5), r5 = c.next, s5 = c.next;
          continue;
        }
        if (r5 = c, r5 === s5) {
          a4 ? a4 === 1 ? (r5 = vE2(di2(r5), e, t), Go2(r5, e, t, i, n4, o4, 2)) : a4 === 2 && wE(r5, e, t, i, n4, o4) : Go2(di2(r5), e, t, i, n4, o4, 1);
          break;
        }
      }
    }
  }
  H$3(Go2, "earcutLinked");
  function bE(r5) {
    var e = r5.prev, t = r5, i = r5.next;
    if (Oe2(e, t, i) >= 0) return false;
    for (var n4 = e.x, o4 = t.x, a4 = i.x, s5 = e.y, u5 = t.y, c = i.y, p4 = n4 < o4 ? n4 < a4 ? n4 : a4 : o4 < a4 ? o4 : a4, h = s5 < u5 ? s5 < c ? s5 : c : u5 < c ? u5 : c, f = n4 > o4 ? n4 > a4 ? n4 : a4 : o4 > a4 ? o4 : a4, m5 = s5 > u5 ? s5 > c ? s5 : c : u5 > c ? u5 : c, y4 = i.next; y4 !== e; ) {
      if (y4.x >= p4 && y4.x <= f && y4.y >= h && y4.y <= m5 && ln2(n4, s5, o4, u5, a4, c, y4.x, y4.y) && Oe2(y4.prev, y4, y4.next) >= 0) return false;
      y4 = y4.next;
    }
    return true;
  }
  H$3(bE, "isEar");
  function _E(r5, e, t, i) {
    var n4 = r5.prev, o4 = r5, a4 = r5.next;
    if (Oe2(n4, o4, a4) >= 0) return false;
    for (var s5 = n4.x, u5 = o4.x, c = a4.x, p4 = n4.y, h = o4.y, f = a4.y, m5 = s5 < u5 ? s5 < c ? s5 : c : u5 < c ? u5 : c, y4 = p4 < h ? p4 < f ? p4 : f : h < f ? h : f, g = s5 > u5 ? s5 > c ? s5 : c : u5 > c ? u5 : c, x2 = p4 > h ? p4 > f ? p4 : f : h > f ? h : f, b = Mm2(m5, y4, e, t, i), w3 = Mm2(g, x2, e, t, i), _ = r5.prevZ, S4 = r5.nextZ; _ && _.z >= b && S4 && S4.z <= w3; ) {
      if (_.x >= m5 && _.x <= g && _.y >= y4 && _.y <= x2 && _ !== n4 && _ !== a4 && ln2(s5, p4, u5, h, c, f, _.x, _.y) && Oe2(_.prev, _, _.next) >= 0 || (_ = _.prevZ, S4.x >= m5 && S4.x <= g && S4.y >= y4 && S4.y <= x2 && S4 !== n4 && S4 !== a4 && ln2(s5, p4, u5, h, c, f, S4.x, S4.y) && Oe2(S4.prev, S4, S4.next) >= 0)) return false;
      S4 = S4.nextZ;
    }
    for (; _ && _.z >= b; ) {
      if (_.x >= m5 && _.x <= g && _.y >= y4 && _.y <= x2 && _ !== n4 && _ !== a4 && ln2(s5, p4, u5, h, c, f, _.x, _.y) && Oe2(_.prev, _, _.next) >= 0) return false;
      _ = _.prevZ;
    }
    for (; S4 && S4.z <= w3; ) {
      if (S4.x >= m5 && S4.x <= g && S4.y >= y4 && S4.y <= x2 && S4 !== n4 && S4 !== a4 && ln2(s5, p4, u5, h, c, f, S4.x, S4.y) && Oe2(S4.prev, S4, S4.next) >= 0) return false;
      S4 = S4.nextZ;
    }
    return true;
  }
  H$3(_E, "isEarHashed");
  function vE2(r5, e, t) {
    var i = r5;
    do {
      var n4 = i.prev, o4 = i.next.next;
      !Gl2(n4, o4) && Gv(n4, i, i.next, o4) && qo2(n4, o4) && qo2(o4, n4) && (e.push(n4.i / t | 0), e.push(i.i / t | 0), e.push(o4.i / t | 0), jo2(i), jo2(i.next), i = r5 = o4), i = i.next;
    } while (i !== r5);
    return di2(i);
  }
  H$3(vE2, "cureLocalIntersections");
  function wE(r5, e, t, i, n4, o4) {
    var a4 = r5;
    do {
      for (var s5 = a4.next.next; s5 !== a4.prev; ) {
        if (a4.i !== s5.i && kE(a4, s5)) {
          var u5 = qv2(a4, s5);
          a4 = di2(a4, a4.next), u5 = di2(u5, u5.next), Go2(a4, e, t, i, n4, o4, 0), Go2(u5, e, t, i, n4, o4, 0);
          return;
        }
        s5 = s5.next;
      }
      a4 = a4.next;
    } while (a4 !== r5);
  }
  H$3(wE, "splitEarcut");
  function SE(r5, e, t, i) {
    var n4 = [], o4, a4, s5, u5, c;
    for (o4 = 0, a4 = e.length; o4 < a4; o4++) s5 = e[o4] * i, u5 = o4 < a4 - 1 ? e[o4 + 1] * i : r5.length, c = Nv(r5, s5, u5, i, false), c === c.next && (c.steiner = true), n4.push(EE2(c));
    for (n4.sort(PE), o4 = 0; o4 < n4.length; o4++) t = TE(n4[o4], t);
    return t;
  }
  H$3(SE, "eliminateHoles");
  function PE(r5, e) {
    return r5.x - e.x;
  }
  H$3(PE, "compareX");
  function TE(r5, e) {
    var t = ME(r5, e);
    if (!t) return e;
    var i = qv2(t, r5);
    return di2(i, i.next), di2(t, t.next);
  }
  H$3(TE, "eliminateHole");
  function ME(r5, e) {
    var t = e, i = r5.x, n4 = r5.y, o4 = -1 / 0, a4;
    do {
      if (n4 <= t.y && n4 >= t.next.y && t.next.y !== t.y) {
        var s5 = t.x + (n4 - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
        if (s5 <= i && s5 > o4 && (o4 = s5, a4 = t.x < t.next.x ? t : t.next, s5 === i)) return a4;
      }
      t = t.next;
    } while (t !== e);
    if (!a4) return null;
    var u5 = a4, c = a4.x, p4 = a4.y, h = 1 / 0, f;
    t = a4;
    do
      i >= t.x && t.x >= c && i !== t.x && ln2(n4 < p4 ? i : o4, n4, c, p4, n4 < p4 ? o4 : i, n4, t.x, t.y) && (f = Math.abs(n4 - t.y) / (i - t.x), qo2(t, r5) && (f < h || f === h && (t.x > a4.x || t.x === a4.x && AE(a4, t))) && (a4 = t, h = f)), t = t.next;
    while (t !== u5);
    return a4;
  }
  H$3(ME, "findHoleBridge");
  function AE(r5, e) {
    return Oe2(r5.prev, r5, e.prev) < 0 && Oe2(e.next, r5, r5.next) < 0;
  }
  H$3(AE, "sectorContainsSector");
  function IE(r5, e, t, i) {
    var n4 = r5;
    do
      n4.z === 0 && (n4.z = Mm2(n4.x, n4.y, e, t, i)), n4.prevZ = n4.prev, n4.nextZ = n4.next, n4 = n4.next;
    while (n4 !== r5);
    n4.prevZ.nextZ = null, n4.prevZ = null, CE(n4);
  }
  H$3(IE, "indexCurve");
  function CE(r5) {
    var e, t, i, n4, o4, a4, s5, u5, c = 1;
    do {
      for (t = r5, r5 = null, o4 = null, a4 = 0; t; ) {
        for (a4++, i = t, s5 = 0, e = 0; e < c && (s5++, i = i.nextZ, !!i); e++) ;
        for (u5 = c; s5 > 0 || u5 > 0 && i; ) s5 !== 0 && (u5 === 0 || !i || t.z <= i.z) ? (n4 = t, t = t.nextZ, s5--) : (n4 = i, i = i.nextZ, u5--), o4 ? o4.nextZ = n4 : r5 = n4, n4.prevZ = o4, o4 = n4;
        t = i;
      }
      o4.nextZ = null, c *= 2;
    } while (a4 > 1);
    return r5;
  }
  H$3(CE, "sortLinked");
  function Mm2(r5, e, t, i, n4) {
    return r5 = (r5 - t) * n4 | 0, e = (e - i) * n4 | 0, r5 = (r5 | r5 << 8) & 16711935, r5 = (r5 | r5 << 4) & 252645135, r5 = (r5 | r5 << 2) & 858993459, r5 = (r5 | r5 << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r5 | e << 1;
  }
  H$3(Mm2, "zOrder");
  function EE2(r5) {
    var e = r5, t = r5;
    do
      (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
    while (e !== r5);
    return t;
  }
  H$3(EE2, "getLeftmost");
  function ln2(r5, e, t, i, n4, o4, a4, s5) {
    return (n4 - a4) * (e - s5) >= (r5 - a4) * (o4 - s5) && (r5 - a4) * (i - s5) >= (t - a4) * (e - s5) && (t - a4) * (o4 - s5) >= (n4 - a4) * (i - s5);
  }
  H$3(ln2, "pointInTriangle");
  function kE(r5, e) {
    return r5.next.i !== e.i && r5.prev.i !== e.i && !LE(r5, e) && (qo2(r5, e) && qo2(e, r5) && DE(r5, e) && (Oe2(r5.prev, r5, e.prev) || Oe2(r5, e.prev, e)) || Gl2(r5, e) && Oe2(r5.prev, r5, r5.next) > 0 && Oe2(e.prev, e, e.next) > 0);
  }
  H$3(kE, "isValidDiagonal");
  function Oe2(r5, e, t) {
    return (e.y - r5.y) * (t.x - e.x) - (e.x - r5.x) * (t.y - e.y);
  }
  H$3(Oe2, "area");
  function Gl2(r5, e) {
    return r5.x === e.x && r5.y === e.y;
  }
  H$3(Gl2, "equals");
  function Gv(r5, e, t, i) {
    var n4 = Ul2(Oe2(r5, e, t)), o4 = Ul2(Oe2(r5, e, i)), a4 = Ul2(Oe2(t, i, r5)), s5 = Ul2(Oe2(t, i, e));
    return !!(n4 !== o4 && a4 !== s5 || n4 === 0 && Vl2(r5, t, e) || o4 === 0 && Vl2(r5, i, e) || a4 === 0 && Vl2(t, r5, i) || s5 === 0 && Vl2(t, e, i));
  }
  H$3(Gv, "intersects");
  function Vl2(r5, e, t) {
    return e.x <= Math.max(r5.x, t.x) && e.x >= Math.min(r5.x, t.x) && e.y <= Math.max(r5.y, t.y) && e.y >= Math.min(r5.y, t.y);
  }
  H$3(Vl2, "onSegment");
  function Ul2(r5) {
    return r5 > 0 ? 1 : r5 < 0 ? -1 : 0;
  }
  H$3(Ul2, "sign");
  function LE(r5, e) {
    var t = r5;
    do {
      if (t.i !== r5.i && t.next.i !== r5.i && t.i !== e.i && t.next.i !== e.i && Gv(t, t.next, r5, e)) return true;
      t = t.next;
    } while (t !== r5);
    return false;
  }
  H$3(LE, "intersectsPolygon");
  function qo2(r5, e) {
    return Oe2(r5.prev, r5, r5.next) < 0 ? Oe2(r5, e, r5.next) >= 0 && Oe2(r5, r5.prev, e) >= 0 : Oe2(r5, e, r5.prev) < 0 || Oe2(r5, r5.next, e) < 0;
  }
  H$3(qo2, "locallyInside");
  function DE(r5, e) {
    var t = r5, i = false, n4 = (r5.x + e.x) / 2, o4 = (r5.y + e.y) / 2;
    do
      t.y > o4 != t.next.y > o4 && t.next.y !== t.y && n4 < (t.next.x - t.x) * (o4 - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
    while (t !== r5);
    return i;
  }
  H$3(DE, "middleInside");
  function qv2(r5, e) {
    var t = new Am2(r5.i, r5.x, r5.y), i = new Am2(e.i, e.x, e.y), n4 = r5.next, o4 = e.prev;
    return r5.next = e, e.prev = r5, t.next = n4, n4.prev = t, i.next = t, t.prev = i, o4.next = i, i.prev = o4, i;
  }
  H$3(qv2, "splitPolygon");
  function Uv2(r5, e, t, i) {
    var n4 = new Am2(r5, e, t);
    return i ? (n4.next = i.next, n4.prev = i, i.next.prev = n4, i.next = n4) : (n4.prev = n4, n4.next = n4), n4;
  }
  H$3(Uv2, "insertNode");
  function jo2(r5) {
    r5.next.prev = r5.prev, r5.prev.next = r5.next, r5.prevZ && (r5.prevZ.nextZ = r5.nextZ), r5.nextZ && (r5.nextZ.prevZ = r5.prevZ);
  }
  H$3(jo2, "removeNode");
  function Am2(r5, e, t) {
    this.i = r5, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  H$3(Am2, "Node");
  Nl2.deviation = function(r5, e, t, i) {
    var n4 = e && e.length, o4 = n4 ? e[0] * t : r5.length, a4 = Math.abs(Im2(r5, 0, o4, t));
    if (n4) for (var s5 = 0, u5 = e.length; s5 < u5; s5++) {
      var c = e[s5] * t, p4 = s5 < u5 - 1 ? e[s5 + 1] * t : r5.length;
      a4 -= Math.abs(Im2(r5, c, p4, t));
    }
    var h = 0;
    for (s5 = 0; s5 < i.length; s5 += 3) {
      var f = i[s5] * t, m5 = i[s5 + 1] * t, y4 = i[s5 + 2] * t;
      h += Math.abs((r5[f] - r5[y4]) * (r5[m5 + 1] - r5[f + 1]) - (r5[f] - r5[m5]) * (r5[y4 + 1] - r5[f + 1]));
    }
    return a4 === 0 && h === 0 ? 0 : Math.abs((h - a4) / a4);
  };
  function Im2(r5, e, t, i) {
    for (var n4 = 0, o4 = e, a4 = t - i; o4 < t; o4 += i) n4 += (r5[a4] - r5[o4]) * (r5[o4 + 1] + r5[a4 + 1]), a4 = o4;
    return n4;
  }
  H$3(Im2, "signedArea");
  Nl2.flatten = function(r5) {
    for (var e = r5[0][0].length, t = { vertices: [], holes: [], dimensions: e }, i = 0, n4 = 0; n4 < r5.length; n4++) {
      for (var o4 = 0; o4 < r5[n4].length; o4++) for (var a4 = 0; a4 < e; a4++) t.vertices.push(r5[n4][o4][a4]);
      n4 > 0 && (i += r5[n4 - 1].length, t.holes.push(i));
    }
    return t;
  };
});
var zm$1 = L((h4, Jv2) => {
  a();
  var UE2 = ge();
  Jv2.exports = pn2;
  function pn2(r5, e, t, i, n4) {
    this.properties = {}, this.extent = t, this.type = 0, this._pbf = r5, this._geometry = -1, this._keys = i, this._values = n4, r5.readFields(NE, this, e);
  }
  H$3(pn2, "VectorTileFeature");
  function NE(r5, e, t) {
    r5 == 1 ? e.id = t.readVarint() : r5 == 2 ? GE(t, e) : r5 == 3 ? e.type = t.readVarint() : r5 == 4 && (e._geometry = t.pos);
  }
  H$3(NE, "readFeature");
  function GE(r5, e) {
    for (var t = r5.readVarint() + r5.pos; r5.pos < t; ) {
      var i = e._keys[r5.readVarint()], n4 = e._values[r5.readVarint()];
      e.properties[i] = n4;
    }
  }
  H$3(GE, "readTag");
  pn2.types = ["Unknown", "Point", "LineString", "Polygon"];
  pn2.prototype.loadGeometry = function() {
    var r5 = this._pbf;
    r5.pos = this._geometry;
    for (var e = r5.readVarint() + r5.pos, t = 1, i = 0, n4 = 0, o4 = 0, a4 = [], s5; r5.pos < e; ) {
      if (i <= 0) {
        var u5 = r5.readVarint();
        t = u5 & 7, i = u5 >> 3;
      }
      if (i--, t === 1 || t === 2) n4 += r5.readSVarint(), o4 += r5.readSVarint(), t === 1 && (s5 && a4.push(s5), s5 = []), s5.push(new UE2(n4, o4));
      else if (t === 7) s5 && s5.push(s5[0].clone());
      else throw new Error("unknown command " + t);
    }
    return s5 && a4.push(s5), a4;
  };
  pn2.prototype.bbox = function() {
    var r5 = this._pbf;
    r5.pos = this._geometry;
    for (var e = r5.readVarint() + r5.pos, t = 1, i = 0, n4 = 0, o4 = 0, a4 = 1 / 0, s5 = -1 / 0, u5 = 1 / 0, c = -1 / 0; r5.pos < e; ) {
      if (i <= 0) {
        var p4 = r5.readVarint();
        t = p4 & 7, i = p4 >> 3;
      }
      if (i--, t === 1 || t === 2) n4 += r5.readSVarint(), o4 += r5.readSVarint(), n4 < a4 && (a4 = n4), n4 > s5 && (s5 = n4), o4 < u5 && (u5 = o4), o4 > c && (c = o4);
      else if (t !== 7) throw new Error("unknown command " + t);
    }
    return [a4, u5, s5, c];
  };
  pn2.prototype.toGeoJSON = function(r5, e, t) {
    var i = this.extent * Math.pow(2, t), n4 = this.extent * r5, o4 = this.extent * e, a4 = this.loadGeometry(), s5 = pn2.types[this.type], u5, c;
    function p4(m5) {
      for (var y4 = 0; y4 < m5.length; y4++) {
        var g = m5[y4], x2 = 180 - (g.y + o4) * 360 / i;
        m5[y4] = [(g.x + n4) * 360 / i - 180, 360 / Math.PI * Math.atan(Math.exp(x2 * Math.PI / 180)) - 90];
      }
    }
    switch (H$3(p4, "project"), this.type) {
      case 1:
        var h = [];
        for (u5 = 0; u5 < a4.length; u5++) h[u5] = a4[u5][0];
        a4 = h, p4(a4);
        break;
      case 2:
        for (u5 = 0; u5 < a4.length; u5++) p4(a4[u5]);
        break;
      case 3:
        for (a4 = qE(a4), u5 = 0; u5 < a4.length; u5++) for (c = 0; c < a4[u5].length; c++) p4(a4[u5][c]);
        break;
    }
    a4.length === 1 ? a4 = a4[0] : s5 = "Multi" + s5;
    var f = { type: "Feature", geometry: { type: s5, coordinates: a4 }, properties: this.properties };
    return "id" in this && (f.id = this.id), f;
  };
  function qE(r5) {
    var e = r5.length;
    if (e <= 1) return [r5];
    for (var t = [], i, n4, o4 = 0; o4 < e; o4++) {
      var a4 = jE(r5[o4]);
      a4 !== 0 && (n4 === void 0 && (n4 = a4 < 0), n4 === a4 < 0 ? (i && t.push(i), i = [r5[o4]]) : i.push(r5[o4]));
    }
    return i && t.push(i), t;
  }
  H$3(qE, "classifyRings");
  function jE(r5) {
    for (var e = 0, t = 0, i = r5.length, n4 = i - 1, o4, a4; t < i; n4 = t++) o4 = r5[t], a4 = r5[n4], e += (a4.x - o4.x) * (o4.y + a4.y);
    return e;
  }
  H$3(jE, "signedArea");
});
var Fm$1 = L((d4, Qv) => {
  a();
  var ZE = zm$1();
  Qv.exports = Yv2;
  function Yv2(r5, e) {
    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = r5, this._keys = [], this._values = [], this._features = [], r5.readFields(HE, this, e), this.length = this._features.length;
  }
  H$3(Yv2, "VectorTileLayer");
  function HE(r5, e, t) {
    r5 === 15 ? e.version = t.readVarint() : r5 === 1 ? e.name = t.readString() : r5 === 5 ? e.extent = t.readVarint() : r5 === 2 ? e._features.push(t.pos) : r5 === 3 ? e._keys.push(t.readString()) : r5 === 4 && e._values.push($E2(t));
  }
  H$3(HE, "readLayer");
  function $E2(r5) {
    for (var e = null, t = r5.readVarint() + r5.pos; r5.pos < t; ) {
      var i = r5.readVarint() >> 3;
      e = i === 1 ? r5.readString() : i === 2 ? r5.readFloat() : i === 3 ? r5.readDouble() : i === 4 ? r5.readVarint64() : i === 5 ? r5.readVarint() : i === 6 ? r5.readSVarint() : i === 7 ? r5.readBoolean() : null;
    }
    return e;
  }
  H$3($E2, "readValueMessage");
  Yv2.prototype.feature = function(r5) {
    if (r5 < 0 || r5 >= this._features.length) throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[r5];
    var e = this._pbf.readVarint() + this._pbf.pos;
    return new ZE(this._pbf, e, this.extent, this._keys, this._values);
  };
});
var t0$1 = L((x42, e02) => {
  a();
  var WE2 = Fm$1();
  e02.exports = XE;
  function XE(r5, e) {
    this.layers = r5.readFields(KE2, {}, e);
  }
  H$3(XE, "VectorTile");
  function KE2(r5, e, t) {
    if (r5 === 3) {
      var i = new WE2(t, t.readVarint() + t.pos);
      i.length && (e[i.name] = i);
    }
  }
  H$3(KE2, "readTile");
});
var Wo$1 = L((v4, jl2) => {
  a();
  jl2.exports.VectorTile = t0$1();
  jl2.exports.VectorTileFeature = zm$1();
  jl2.exports.VectorTileLayer = Fm$1();
});
var S0$1 = L((Zm2) => {
  a();
  Zm2.read = function(r5, e, t, i, n4) {
    var o4, a4, s5 = n4 * 8 - i - 1, u5 = (1 << s5) - 1, c = u5 >> 1, p4 = -7, h = t ? n4 - 1 : 0, f = t ? -1 : 1, m5 = r5[e + h];
    for (h += f, o4 = m5 & (1 << -p4) - 1, m5 >>= -p4, p4 += s5; p4 > 0; o4 = o4 * 256 + r5[e + h], h += f, p4 -= 8) ;
    for (a4 = o4 & (1 << -p4) - 1, o4 >>= -p4, p4 += i; p4 > 0; a4 = a4 * 256 + r5[e + h], h += f, p4 -= 8) ;
    if (o4 === 0) o4 = 1 - c;
    else {
      if (o4 === u5) return a4 ? NaN : (m5 ? -1 : 1) * (1 / 0);
      a4 = a4 + Math.pow(2, i), o4 = o4 - c;
    }
    return (m5 ? -1 : 1) * a4 * Math.pow(2, o4 - i);
  };
  Zm2.write = function(r5, e, t, i, n4, o4) {
    var a4, s5, u5, c = o4 * 8 - n4 - 1, p4 = (1 << c) - 1, h = p4 >> 1, f = n4 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m5 = i ? 0 : o4 - 1, y4 = i ? 1 : -1, g = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s5 = isNaN(e) ? 1 : 0, a4 = p4) : (a4 = Math.floor(Math.log(e) / Math.LN2), e * (u5 = Math.pow(2, -a4)) < 1 && (a4--, u5 *= 2), a4 + h >= 1 ? e += f / u5 : e += f * Math.pow(2, 1 - h), e * u5 >= 2 && (a4++, u5 /= 2), a4 + h >= p4 ? (s5 = 0, a4 = p4) : a4 + h >= 1 ? (s5 = (e * u5 - 1) * Math.pow(2, n4), a4 = a4 + h) : (s5 = e * Math.pow(2, h - 1) * Math.pow(2, n4), a4 = 0)); n4 >= 8; r5[t + m5] = s5 & 255, m5 += y4, s5 /= 256, n4 -= 8) ;
    for (a4 = a4 << n4 | s5, c += n4; c > 0; r5[t + m5] = a4 & 255, m5 += y4, a4 /= 256, c -= 8) ;
    r5[t + m5 - y4] |= g * 128;
  };
});
var $m = L((AV2, I02) => {
  a();
  I02.exports = Te2;
  var Xl2 = S0$1();
  function Te2(r5) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r5) ? r5 : new Uint8Array(r5 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  H$3(Te2, "Pbf");
  Te2.Varint = 0;
  Te2.Fixed64 = 1;
  Te2.Bytes = 2;
  Te2.Fixed32 = 5;
  var Hm2 = 65536 * 65536, P02 = 1 / Hm2, dk = 12, A02 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
  Te2.prototype = { destroy: H$3(function() {
    this.buf = null;
  }, "destroy"), readFields: H$3(function(r5, e, t) {
    for (t = t || this.length; this.pos < t; ) {
      var i = this.readVarint(), n4 = i >> 3, o4 = this.pos;
      this.type = i & 7, r5(n4, e, this), this.pos === o4 && this.skip(i);
    }
    return e;
  }, "readFields"), readMessage: H$3(function(r5, e) {
    return this.readFields(r5, e, this.readVarint() + this.pos);
  }, "readMessage"), readFixed32: H$3(function() {
    var r5 = Kl2(this.buf, this.pos);
    return this.pos += 4, r5;
  }, "readFixed32"), readSFixed32: H$3(function() {
    var r5 = M02(this.buf, this.pos);
    return this.pos += 4, r5;
  }, "readSFixed32"), readFixed64: H$3(function() {
    var r5 = Kl2(this.buf, this.pos) + Kl2(this.buf, this.pos + 4) * Hm2;
    return this.pos += 8, r5;
  }, "readFixed64"), readSFixed64: H$3(function() {
    var r5 = Kl2(this.buf, this.pos) + M02(this.buf, this.pos + 4) * Hm2;
    return this.pos += 8, r5;
  }, "readSFixed64"), readFloat: H$3(function() {
    var r5 = Xl2.read(this.buf, this.pos, true, 23, 4);
    return this.pos += 4, r5;
  }, "readFloat"), readDouble: H$3(function() {
    var r5 = Xl2.read(this.buf, this.pos, true, 52, 8);
    return this.pos += 8, r5;
  }, "readDouble"), readVarint: H$3(function(r5) {
    var e = this.buf, t, i;
    return i = e[this.pos++], t = i & 127, i < 128 || (i = e[this.pos++], t |= (i & 127) << 7, i < 128) || (i = e[this.pos++], t |= (i & 127) << 14, i < 128) || (i = e[this.pos++], t |= (i & 127) << 21, i < 128) ? t : (i = e[this.pos], t |= (i & 15) << 28, yk(t, r5, this));
  }, "readVarint"), readVarint64: H$3(function() {
    return this.readVarint(true);
  }, "readVarint64"), readSVarint: H$3(function() {
    var r5 = this.readVarint();
    return r5 % 2 === 1 ? (r5 + 1) / -2 : r5 / 2;
  }, "readSVarint"), readBoolean: H$3(function() {
    return !!this.readVarint();
  }, "readBoolean"), readString: H$3(function() {
    var r5 = this.readVarint() + this.pos, e = this.pos;
    return this.pos = r5, r5 - e >= dk && A02 ? Ek(this.buf, e, r5) : Ck(this.buf, e, r5);
  }, "readString"), readBytes: H$3(function() {
    var r5 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, r5);
    return this.pos = r5, e;
  }, "readBytes"), readPackedVarint: H$3(function(r5, e) {
    if (this.type !== Te2.Bytes) return r5.push(this.readVarint(e));
    var t = ur2(this);
    for (r5 = r5 || []; this.pos < t; ) r5.push(this.readVarint(e));
    return r5;
  }, "readPackedVarint"), readPackedSVarint: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readSVarint());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readSVarint());
    return r5;
  }, "readPackedSVarint"), readPackedBoolean: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readBoolean());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readBoolean());
    return r5;
  }, "readPackedBoolean"), readPackedFloat: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readFloat());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readFloat());
    return r5;
  }, "readPackedFloat"), readPackedDouble: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readDouble());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readDouble());
    return r5;
  }, "readPackedDouble"), readPackedFixed32: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readFixed32());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readFixed32());
    return r5;
  }, "readPackedFixed32"), readPackedSFixed32: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readSFixed32());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readSFixed32());
    return r5;
  }, "readPackedSFixed32"), readPackedFixed64: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readFixed64());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readFixed64());
    return r5;
  }, "readPackedFixed64"), readPackedSFixed64: H$3(function(r5) {
    if (this.type !== Te2.Bytes) return r5.push(this.readSFixed64());
    var e = ur2(this);
    for (r5 = r5 || []; this.pos < e; ) r5.push(this.readSFixed64());
    return r5;
  }, "readPackedSFixed64"), skip: H$3(function(r5) {
    var e = r5 & 7;
    if (e === Te2.Varint) for (; this.buf[this.pos++] > 127; ) ;
    else if (e === Te2.Bytes) this.pos = this.readVarint() + this.pos;
    else if (e === Te2.Fixed32) this.pos += 4;
    else if (e === Te2.Fixed64) this.pos += 8;
    else throw new Error("Unimplemented type: " + e);
  }, "skip"), writeTag: H$3(function(r5, e) {
    this.writeVarint(r5 << 3 | e);
  }, "writeTag"), realloc: H$3(function(r5) {
    for (var e = this.length || 16; e < this.pos + r5; ) e *= 2;
    if (e !== this.length) {
      var t = new Uint8Array(e);
      t.set(this.buf), this.buf = t, this.length = e;
    }
  }, "realloc"), finish: H$3(function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  }, "finish"), writeFixed32: H$3(function(r5) {
    this.realloc(4), fn2(this.buf, r5, this.pos), this.pos += 4;
  }, "writeFixed32"), writeSFixed32: H$3(function(r5) {
    this.realloc(4), fn2(this.buf, r5, this.pos), this.pos += 4;
  }, "writeSFixed32"), writeFixed64: H$3(function(r5) {
    this.realloc(8), fn2(this.buf, r5 & -1, this.pos), fn2(this.buf, Math.floor(r5 * P02), this.pos + 4), this.pos += 8;
  }, "writeFixed64"), writeSFixed64: H$3(function(r5) {
    this.realloc(8), fn2(this.buf, r5 & -1, this.pos), fn2(this.buf, Math.floor(r5 * P02), this.pos + 4), this.pos += 8;
  }, "writeSFixed64"), writeVarint: H$3(function(r5) {
    if (r5 = +r5 || 0, r5 > 268435455 || r5 < 0) {
      gk(r5, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = r5 & 127 | (r5 > 127 ? 128 : 0), !(r5 <= 127) && (this.buf[this.pos++] = (r5 >>>= 7) & 127 | (r5 > 127 ? 128 : 0), !(r5 <= 127) && (this.buf[this.pos++] = (r5 >>>= 7) & 127 | (r5 > 127 ? 128 : 0), !(r5 <= 127) && (this.buf[this.pos++] = r5 >>> 7 & 127)));
  }, "writeVarint"), writeSVarint: H$3(function(r5) {
    this.writeVarint(r5 < 0 ? -r5 * 2 - 1 : r5 * 2);
  }, "writeSVarint"), writeBoolean: H$3(function(r5) {
    this.writeVarint(!!r5);
  }, "writeBoolean"), writeString: H$3(function(r5) {
    r5 = String(r5), this.realloc(r5.length * 4), this.pos++;
    var e = this.pos;
    this.pos = kk(this.buf, r5, this.pos);
    var t = this.pos - e;
    t >= 128 && T02(e, t, this), this.pos = e - 1, this.writeVarint(t), this.pos += t;
  }, "writeString"), writeFloat: H$3(function(r5) {
    this.realloc(4), Xl2.write(this.buf, r5, this.pos, true, 23, 4), this.pos += 4;
  }, "writeFloat"), writeDouble: H$3(function(r5) {
    this.realloc(8), Xl2.write(this.buf, r5, this.pos, true, 52, 8), this.pos += 8;
  }, "writeDouble"), writeBytes: H$3(function(r5) {
    var e = r5.length;
    this.writeVarint(e), this.realloc(e);
    for (var t = 0; t < e; t++) this.buf[this.pos++] = r5[t];
  }, "writeBytes"), writeRawMessage: H$3(function(r5, e) {
    this.pos++;
    var t = this.pos;
    r5(e, this);
    var i = this.pos - t;
    i >= 128 && T02(t, i, this), this.pos = t - 1, this.writeVarint(i), this.pos += i;
  }, "writeRawMessage"), writeMessage: H$3(function(r5, e, t) {
    this.writeTag(r5, Te2.Bytes), this.writeRawMessage(e, t);
  }, "writeMessage"), writePackedVarint: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, _k, e);
  }, "writePackedVarint"), writePackedSVarint: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, vk, e);
  }, "writePackedSVarint"), writePackedBoolean: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, Pk, e);
  }, "writePackedBoolean"), writePackedFloat: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, wk, e);
  }, "writePackedFloat"), writePackedDouble: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, Sk, e);
  }, "writePackedDouble"), writePackedFixed32: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, Tk, e);
  }, "writePackedFixed32"), writePackedSFixed32: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, Mk, e);
  }, "writePackedSFixed32"), writePackedFixed64: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, Ak, e);
  }, "writePackedFixed64"), writePackedSFixed64: H$3(function(r5, e) {
    e.length && this.writeMessage(r5, Ik, e);
  }, "writePackedSFixed64"), writeBytesField: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Bytes), this.writeBytes(e);
  }, "writeBytesField"), writeFixed32Field: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Fixed32), this.writeFixed32(e);
  }, "writeFixed32Field"), writeSFixed32Field: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Fixed32), this.writeSFixed32(e);
  }, "writeSFixed32Field"), writeFixed64Field: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Fixed64), this.writeFixed64(e);
  }, "writeFixed64Field"), writeSFixed64Field: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Fixed64), this.writeSFixed64(e);
  }, "writeSFixed64Field"), writeVarintField: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Varint), this.writeVarint(e);
  }, "writeVarintField"), writeSVarintField: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Varint), this.writeSVarint(e);
  }, "writeSVarintField"), writeStringField: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Bytes), this.writeString(e);
  }, "writeStringField"), writeFloatField: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Fixed32), this.writeFloat(e);
  }, "writeFloatField"), writeDoubleField: H$3(function(r5, e) {
    this.writeTag(r5, Te2.Fixed64), this.writeDouble(e);
  }, "writeDoubleField"), writeBooleanField: H$3(function(r5, e) {
    this.writeVarintField(r5, !!e);
  }, "writeBooleanField") };
  function yk(r5, e, t) {
    var i = t.buf, n4, o4;
    if (o4 = i[t.pos++], n4 = (o4 & 112) >> 4, o4 < 128 || (o4 = i[t.pos++], n4 |= (o4 & 127) << 3, o4 < 128) || (o4 = i[t.pos++], n4 |= (o4 & 127) << 10, o4 < 128) || (o4 = i[t.pos++], n4 |= (o4 & 127) << 17, o4 < 128) || (o4 = i[t.pos++], n4 |= (o4 & 127) << 24, o4 < 128) || (o4 = i[t.pos++], n4 |= (o4 & 1) << 31, o4 < 128)) return hn2(r5, n4, e);
    throw new Error("Expected varint not more than 10 bytes");
  }
  H$3(yk, "readVarintRemainder");
  function ur2(r5) {
    return r5.type === Te2.Bytes ? r5.readVarint() + r5.pos : r5.pos + 1;
  }
  H$3(ur2, "readPackedEnd");
  function hn2(r5, e, t) {
    return t ? e * 4294967296 + (r5 >>> 0) : (e >>> 0) * 4294967296 + (r5 >>> 0);
  }
  H$3(hn2, "toNum");
  function gk(r5, e) {
    var t, i;
    if (r5 >= 0 ? (t = r5 % 4294967296 | 0, i = r5 / 4294967296 | 0) : (t = ~(-r5 % 4294967296), i = ~(-r5 / 4294967296), t ^ 4294967295 ? t = t + 1 | 0 : (t = 0, i = i + 1 | 0)), r5 >= 18446744073709552e3 || r5 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
    e.realloc(10), xk(t, i, e), bk(i, e);
  }
  H$3(gk, "writeBigVarint");
  function xk(r5, e, t) {
    t.buf[t.pos++] = r5 & 127 | 128, r5 >>>= 7, t.buf[t.pos++] = r5 & 127 | 128, r5 >>>= 7, t.buf[t.pos++] = r5 & 127 | 128, r5 >>>= 7, t.buf[t.pos++] = r5 & 127 | 128, r5 >>>= 7, t.buf[t.pos] = r5 & 127;
  }
  H$3(xk, "writeBigVarintLow");
  function bk(r5, e) {
    var t = (r5 & 7) << 4;
    e.buf[e.pos++] |= t | ((r5 >>>= 3) ? 128 : 0), r5 && (e.buf[e.pos++] = r5 & 127 | ((r5 >>>= 7) ? 128 : 0), r5 && (e.buf[e.pos++] = r5 & 127 | ((r5 >>>= 7) ? 128 : 0), r5 && (e.buf[e.pos++] = r5 & 127 | ((r5 >>>= 7) ? 128 : 0), r5 && (e.buf[e.pos++] = r5 & 127 | ((r5 >>>= 7) ? 128 : 0), r5 && (e.buf[e.pos++] = r5 & 127)))));
  }
  H$3(bk, "writeBigVarintHigh");
  function T02(r5, e, t) {
    var i = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
    t.realloc(i);
    for (var n4 = t.pos - 1; n4 >= r5; n4--) t.buf[n4 + i] = t.buf[n4];
  }
  H$3(T02, "makeRoomForExtraLength");
  function _k(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeVarint(r5[t]);
  }
  H$3(_k, "writePackedVarint");
  function vk(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeSVarint(r5[t]);
  }
  H$3(vk, "writePackedSVarint");
  function wk(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeFloat(r5[t]);
  }
  H$3(wk, "writePackedFloat");
  function Sk(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeDouble(r5[t]);
  }
  H$3(Sk, "writePackedDouble");
  function Pk(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeBoolean(r5[t]);
  }
  H$3(Pk, "writePackedBoolean");
  function Tk(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeFixed32(r5[t]);
  }
  H$3(Tk, "writePackedFixed32");
  function Mk(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeSFixed32(r5[t]);
  }
  H$3(Mk, "writePackedSFixed32");
  function Ak(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeFixed64(r5[t]);
  }
  H$3(Ak, "writePackedFixed64");
  function Ik(r5, e) {
    for (var t = 0; t < r5.length; t++) e.writeSFixed64(r5[t]);
  }
  H$3(Ik, "writePackedSFixed64");
  function Kl2(r5, e) {
    return (r5[e] | r5[e + 1] << 8 | r5[e + 2] << 16) + r5[e + 3] * 16777216;
  }
  H$3(Kl2, "readUInt32");
  function fn2(r5, e, t) {
    r5[t] = e, r5[t + 1] = e >>> 8, r5[t + 2] = e >>> 16, r5[t + 3] = e >>> 24;
  }
  H$3(fn2, "writeInt32");
  function M02(r5, e) {
    return (r5[e] | r5[e + 1] << 8 | r5[e + 2] << 16) + (r5[e + 3] << 24);
  }
  H$3(M02, "readInt32");
  function Ck(r5, e, t) {
    for (var i = "", n4 = e; n4 < t; ) {
      var o4 = r5[n4], a4 = null, s5 = o4 > 239 ? 4 : o4 > 223 ? 3 : o4 > 191 ? 2 : 1;
      if (n4 + s5 > t) break;
      var u5, c, p4;
      s5 === 1 ? o4 < 128 && (a4 = o4) : s5 === 2 ? (u5 = r5[n4 + 1], (u5 & 192) === 128 && (a4 = (o4 & 31) << 6 | u5 & 63, a4 <= 127 && (a4 = null))) : s5 === 3 ? (u5 = r5[n4 + 1], c = r5[n4 + 2], (u5 & 192) === 128 && (c & 192) === 128 && (a4 = (o4 & 15) << 12 | (u5 & 63) << 6 | c & 63, (a4 <= 2047 || a4 >= 55296 && a4 <= 57343) && (a4 = null))) : s5 === 4 && (u5 = r5[n4 + 1], c = r5[n4 + 2], p4 = r5[n4 + 3], (u5 & 192) === 128 && (c & 192) === 128 && (p4 & 192) === 128 && (a4 = (o4 & 15) << 18 | (u5 & 63) << 12 | (c & 63) << 6 | p4 & 63, (a4 <= 65535 || a4 >= 1114112) && (a4 = null))), a4 === null ? (a4 = 65533, s5 = 1) : a4 > 65535 && (a4 -= 65536, i += String.fromCharCode(a4 >>> 10 & 1023 | 55296), a4 = 56320 | a4 & 1023), i += String.fromCharCode(a4), n4 += s5;
    }
    return i;
  }
  H$3(Ck, "readUtf8");
  function Ek(r5, e, t) {
    return A02.decode(r5.subarray(e, t));
  }
  H$3(Ek, "readUtf8TextDecoder");
  function kk(r5, e, t) {
    for (var i = 0, n4, o4; i < e.length; i++) {
      if (n4 = e.charCodeAt(i), n4 > 55295 && n4 < 57344) if (o4) if (n4 < 56320) {
        r5[t++] = 239, r5[t++] = 191, r5[t++] = 189, o4 = n4;
        continue;
      } else n4 = o4 - 55296 << 10 | n4 - 56320 | 65536, o4 = null;
      else {
        n4 > 56319 || i + 1 === e.length ? (r5[t++] = 239, r5[t++] = 191, r5[t++] = 189) : o4 = n4;
        continue;
      }
      else o4 && (r5[t++] = 239, r5[t++] = 191, r5[t++] = 189, o4 = null);
      n4 < 128 ? r5[t++] = n4 : (n4 < 2048 ? r5[t++] = n4 >> 6 | 192 : (n4 < 65536 ? r5[t++] = n4 >> 12 | 224 : (r5[t++] = n4 >> 18 | 240, r5[t++] = n4 >> 12 & 63 | 128), r5[t++] = n4 >> 6 & 63 | 128), r5[t++] = n4 & 63 | 128);
    }
    return t;
  }
  H$3(kk, "writeUtf8");
});
a();
var ts = { version: "6.0.1-beta.51" };
a();
a();
var Wx$1 = N$2(ge(), 1), Xx$1 = N$2(Zx$1(), 1);
a();
a();
var bp;
function rs() {
  return bp == null && (bp = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), bp;
}
H$3(rs, "offscreenCanvasSupported");
var is;
function _p$1() {
  if (is == null && (is = false, rs())) {
    let t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
    if (t) {
      for (let n4 = 0; n4 < 5 * 5; n4++) {
        let o4 = n4 * 4;
        t.fillStyle = "rgb(".concat(o4, ",").concat(o4 + 1, ",").concat(o4 + 2, ")"), t.fillRect(n4 % 5, Math.floor(n4 / 5), 1, 1);
      }
      let i = t.getImageData(0, 0, 5, 5).data;
      for (let n4 = 0; n4 < 5 * 5 * 4; n4++) if (n4 % 4 !== 3 && i[n4] !== n4) {
        is = true;
        break;
      }
    }
  }
  return is || false;
}
H$3(_p$1, "isOffscreenCanvasDistorted");
function Kx$1(r5) {
  if (r5 <= 0) return 0;
  if (r5 >= 1) return 1;
  let e = r5 * r5, t = e * r5;
  return 4 * (r5 < 0.5 ? t : 3 * (r5 - e) + t - 0.75);
}
H$3(Kx$1, "easeCubicInOut");
function kn(r5, e, t, i) {
  let n4 = new Xx$1.default(r5, e, t, i);
  return function(o4) {
    return n4.solve(o4);
  };
}
H$3(kn, "bezier");
var Ln$1 = kn(0.25, 0.1, 0.25, 1);
function Ae$2(r5, e, t) {
  return Math.min(t, Math.max(e, r5));
}
H$3(Ae$2, "clamp");
function er$1(r5, e, t) {
  let i = t - e, n4 = ((r5 - e) % i + i) % i + e;
  return n4 === e ? t : n4;
}
H$3(er$1, "wrap");
function Jx$1(r5, e) {
  let t = [];
  for (let i in r5) i in e || t.push(i);
  return t;
}
H$3(Jx$1, "keysDifference");
function V$1(r5, ...e) {
  for (let t of e) for (let i in t) r5[i] = t[i];
  return r5;
}
H$3(V$1, "extend");
function yr$1(r5, e) {
  let t = {};
  for (let i = 0; i < e.length; i++) {
    let n4 = e[i];
    n4 in r5 && (t[n4] = r5[n4]);
  }
  return t;
}
H$3(yr$1, "pick");
var w2$1 = 1;
function ns() {
  return w2$1++;
}
H$3(ns, "uniqueId");
function Yx$1(r5) {
  return Math.log(r5) / Math.LN2 % 1 === 0;
}
H$3(Yx$1, "isPowerOfTwo");
function Qx$1(r5) {
  return r5 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r5) / Math.LN2));
}
H$3(Qx$1, "nextPowerOfTwo");
function Dn(r5, e, t) {
  let i = {};
  for (let n4 in r5) i[n4] = e.call(t || this, r5[n4], n4, r5);
  return i;
}
H$3(Dn, "mapObject");
function os$1(r5, e, t) {
  let i = {};
  for (let n4 in r5) e.call(t || this, r5[n4], n4, r5) && (i[n4] = r5[n4]);
  return i;
}
H$3(os$1, "filterObject");
function Qt$1(r5, e) {
  if (Array.isArray(r5)) {
    if (!Array.isArray(e) || r5.length !== e.length) return false;
    for (let t = 0; t < r5.length; t++) if (!Qt$1(r5[t], e[t])) return false;
    return true;
  }
  if (typeof r5 == "object" && r5 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(r5).length !== Object.keys(e).length) return false;
    for (let i in r5) if (!Qt$1(r5[i], e[i])) return false;
    return true;
  }
  return r5 === e;
}
H$3(Qt$1, "deepEqual");
function pt$1(r5) {
  return Array.isArray(r5) ? r5.map(pt$1) : typeof r5 == "object" && r5 ? Dn(r5, pt$1) : r5;
}
H$3(pt$1, "clone");
function eb$1(r5, e) {
  for (let t = 0; t < r5.length; t++) if (e.indexOf(r5[t]) >= 0) return true;
  return false;
}
H$3(eb$1, "arraysIntersect");
var Hx$1 = {};
function Le$1(r5) {
  Hx$1[r5] || (typeof console < "u" && console.warn(r5), Hx$1[r5] = true);
}
H$3(Le$1, "warnOnce");
function tr$2(r5, e, t) {
  return (t.y - r5.y) * (e.x - r5.x) > (e.y - r5.y) * (t.x - r5.x);
}
H$3(tr$2, "isCounterClockwise");
function tb$1(r5, e, t, i) {
  let n4 = e.y - r5.y, o4 = e.x - r5.x, a4 = i.y - t.y, s5 = i.x - t.x, u5 = a4 * o4 - s5 * n4;
  if (u5 === 0) return null;
  let c = r5.y - t.y, p4 = r5.x - t.x, h = (s5 * c - a4 * p4) / u5;
  return new Wx$1.default(r5.x + h * o4, r5.y + h * n4);
}
H$3(tb$1, "findLineIntersection");
function rb$1(r5) {
  let e = 0;
  for (let t = 0, i = r5.length, n4 = i - 1, o4, a4; t < i; n4 = t++) o4 = r5[t], a4 = r5[n4], e += (a4.x - o4.x) * (o4.y + a4.y);
  return e;
}
H$3(rb$1, "calculateSignedArea");
function ib$1([r5, e, t]) {
  return e += 90, e *= Math.PI / 180, t *= Math.PI / 180, { x: r5 * Math.cos(e) * Math.sin(t), y: r5 * Math.sin(e) * Math.sin(t), z: r5 * Math.cos(t) };
}
H$3(ib$1, "sphericalToCartesian");
function rr$1(r5) {
  return typeof WorkerGlobalScope < "u" && typeof r5 < "u" && r5 instanceof WorkerGlobalScope;
}
H$3(rr$1, "isWorker");
function nb$1(r5) {
  let e = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, t = {};
  if (r5.replace(e, (i, n4, o4, a4) => {
    let s5 = o4 || a4;
    return t[n4] = s5 ? s5.toLowerCase() : true, "";
  }), t["max-age"]) {
    let i = parseInt(t["max-age"], 10);
    isNaN(i) ? delete t["max-age"] : t["max-age"] = i;
  }
  return t;
}
H$3(nb$1, "parseCacheControl");
var vp$1 = null;
function ob$1(r5) {
  if (vp$1 == null) {
    let e = r5.navigator ? r5.navigator.userAgent : null;
    vp$1 = !!r5.safari || !!(e && (/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
  }
  return vp$1;
}
H$3(ob$1, "isSafari");
function ht$1(r5) {
  return typeof ImageBitmap < "u" && r5 instanceof ImageBitmap;
}
H$3(ht$1, "isImageBitmap");
var ab$1 = H$3(async (r5) => {
  if (r5.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
  let e = new Blob([new Uint8Array(r5)], { type: "image/png" });
  try {
    return createImageBitmap(e);
  } catch (t) {
    throw new Error("Could not load image because of ".concat(t.message, ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
  }
}, "arrayBufferToImageBitmap"), $x$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=", sb$1 = H$3((r5) => new Promise((e, t) => {
  let i = new Image();
  i.onload = () => {
    e(i), URL.revokeObjectURL(i.src), i.onload = null, window.requestAnimationFrame(() => {
      i.src = $x$1;
    });
  }, i.onerror = () => t(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
  let n4 = new Blob([new Uint8Array(r5)], { type: "image/png" });
  i.src = r5.byteLength ? URL.createObjectURL(n4) : $x$1;
}), "arrayBufferToImage");
function S2$1(r5, e, t, i, n4) {
  let o4 = Math.max(-e, 0) * 4, u5 = (Math.max(0, t) - t) * i * 4 + o4, c = i * 4, p4 = Math.max(0, e), h = Math.max(0, t), f = Math.min(r5.width, e + i), m5 = Math.min(r5.height, t + n4);
  return { rect: { x: p4, y: h, width: f - p4, height: m5 - h }, layout: [{ offset: u5, stride: c }] };
}
H$3(S2$1, "computeVideoFrameParameters");
async function lb$1(r5, e, t, i, n4) {
  if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
  let o4 = new VideoFrame(r5, { timestamp: 0 });
  try {
    let a4 = o4 == null ? void 0 : o4.format;
    if (!a4 || !(a4.startsWith("BGR") || a4.startsWith("RGB"))) throw new Error("Unrecognized format ".concat(a4));
    let s5 = a4.startsWith("BGR"), u5 = new Uint8ClampedArray(i * n4 * 4);
    if (await o4.copyTo(u5, S2$1(r5, e, t, i, n4)), s5) for (let c = 0; c < u5.length; c += 4) {
      let p4 = u5[c];
      u5[c] = u5[c + 2], u5[c + 2] = p4;
    }
    return u5;
  } finally {
    o4.close();
  }
}
H$3(lb$1, "readImageUsingVideoFrame");
function ub$1(r5, e, t, i) {
  return r5.addEventListener(e, t, i), { unsubscribe: H$3(() => {
    r5.removeEventListener(e, t, i);
  }, "unsubscribe") };
}
H$3(ub$1, "subscribe");
function wp$1(r5) {
  return r5 * Math.PI / 180;
}
H$3(wp$1, "degreesToRadians");
a();
a();
var P2$1 = "AbortError";
function Hr$1() {
  return new Error(P2$1);
}
H$3(Hr$1, "createAbortError");
var T2$1 = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), as$1, Sp$1, Y$1 = { now: T2$1, frameAsync(r5) {
  return new Promise((e, t) => {
    let i = requestAnimationFrame(e);
    r5.signal.addEventListener("abort", () => {
      cancelAnimationFrame(i), t(Hr$1());
    });
  });
}, getImageData(r5, e = 0) {
  return this.getImageCanvasContext(r5).getImageData(-e, -e, r5.width + 2 * e, r5.height + 2 * e);
}, getImageCanvasContext(r5) {
  let e = window.document.createElement("canvas"), t = e.getContext("2d", { willReadFrequently: true });
  if (!t) throw new Error("failed to create canvas 2d context");
  return e.width = r5.width, e.height = r5.height, t.drawImage(r5, 0, 0, r5.width, r5.height), t;
}, resolveURL(r5) {
  return as$1 || (as$1 = document.createElement("a")), as$1.href = r5, as$1.href;
}, hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
  return matchMedia ? (Sp$1 == null && (Sp$1 = matchMedia("(prefers-reduced-motion: reduce)")), Sp$1.matches) : false;
} };
a();
var cb$1 = N$2(ge(), 1);
var Ie$1 = class Ie {
  static testProp(e) {
    if (!Ie.docStyle) return e[0];
    for (let t = 0; t < e.length; t++) if (e[t] in Ie.docStyle) return e[t];
    return e[0];
  }
  static create(e, t, i) {
    let n4 = window.document.createElement(e);
    return t !== void 0 && (n4.className = t), i && i.appendChild(n4), n4;
  }
  static createNS(e, t) {
    return window.document.createElementNS(e, t);
  }
  static disableDrag() {
    Ie.docStyle && Ie.selectProp && (Ie.userSelect = Ie.docStyle[Ie.selectProp], Ie.docStyle[Ie.selectProp] = "none");
  }
  static enableDrag() {
    Ie.docStyle && Ie.selectProp && (Ie.docStyle[Ie.selectProp] = Ie.userSelect);
  }
  static setTransform(e, t) {
    e.style[Ie.transformProp] = t;
  }
  static addEventListener(e, t, i, n4 = {}) {
    "passive" in n4 ? e.addEventListener(t, i, n4) : e.addEventListener(t, i, n4.capture);
  }
  static removeEventListener(e, t, i, n4 = {}) {
    "passive" in n4 ? e.removeEventListener(t, i, n4) : e.removeEventListener(t, i, n4.capture);
  }
  static suppressClickInternal(e) {
    e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", Ie.suppressClickInternal, true);
  }
  static suppressClick() {
    window.addEventListener("click", Ie.suppressClickInternal, true), window.setTimeout(() => {
      window.removeEventListener("click", Ie.suppressClickInternal, true);
    }, 0);
  }
  static getScale(e) {
    let t = e.getBoundingClientRect();
    return { x: t.width / e.offsetWidth || 1, y: t.height / e.offsetHeight || 1, boundingClientRect: t };
  }
  static getPoint(e, t, i) {
    let n4 = t.boundingClientRect;
    return new cb$1.default((i.clientX - n4.left) / t.x - e.clientLeft, (i.clientY - n4.top) / t.y - e.clientTop);
  }
  static mousePos(e, t) {
    let i = Ie.getScale(e);
    return Ie.getPoint(e, i, t);
  }
  static touchPos(e, t) {
    let i = [], n4 = Ie.getScale(e);
    for (let o4 = 0; o4 < t.length; o4++) i.push(Ie.getPoint(e, n4, t[o4]));
    return i;
  }
  static mouseButton(e) {
    return e.button;
  }
  static remove(e) {
    e.parentNode && e.parentNode.removeChild(e);
  }
};
H$3(Ie$1, "DOM"), Ie$1.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Ie$1.selectProp = Ie$1.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Ie$1.transformProp = Ie$1.testProp(["transform", "WebkitTransform"]);
var D$1 = Ie$1;
a();
a();
a();
var Ke = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
function ss$1(r5) {
  return Ke.REGISTERED_PROTOCOLS[r5.substring(0, r5.indexOf("://"))];
}
H$3(ss$1, "getProtocol");
function M2$1(r5, e) {
  Ke.REGISTERED_PROTOCOLS[r5] = e;
}
H$3(M2$1, "addProtocol");
function A2$1(r5) {
  delete Ke.REGISTERED_PROTOCOLS[r5];
}
H$3(A2$1, "removeProtocol");
a();
var ls$1 = "global-dispatcher", Tp$1 = class Tp extends Error {
  constructor(e, t, i, n4) {
    super("AJAXError: ".concat(t, " (").concat(e, "): ").concat(i)), this.status = e, this.statusText = t, this.url = i, this.body = n4;
  }
};
H$3(Tp$1, "AJAXError");
var $r = Tp$1, us$1 = H$3(() => rr$1(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, "getReferrer"), I2$1 = H$3((r5) => /^file:/.test(r5) || /^file:/.test(us$1()) && !/^\w+:/.test(r5), "isFileURL");
async function C2$1(r5, e) {
  let t = new Request(r5.url, { method: r5.method || "GET", body: r5.body, credentials: r5.credentials, headers: r5.headers, cache: r5.cache, referrer: us$1(), signal: e.signal });
  r5.type === "json" && t.headers.set("Accept", "application/json");
  let i = await fetch(t);
  if (!i.ok) {
    let a4 = await i.blob();
    throw new $r(i.status, i.statusText, r5.url, a4);
  }
  let n4;
  r5.type === "arrayBuffer" || r5.type === "image" ? n4 = i.arrayBuffer() : r5.type === "json" ? n4 = i.json() : n4 = i.text();
  let o4 = await n4;
  if (e.signal.aborted) throw Hr$1();
  return { data: o4, cacheControl: i.headers.get("Cache-Control"), expires: i.headers.get("Expires") };
}
H$3(C2$1, "makeFetchRequest");
function E2$1(r5, e) {
  return new Promise((t, i) => {
    let n4 = new XMLHttpRequest();
    n4.open(r5.method || "GET", r5.url, true), (r5.type === "arrayBuffer" || r5.type === "image") && (n4.responseType = "arraybuffer");
    for (let o4 in r5.headers) n4.setRequestHeader(o4, r5.headers[o4]);
    r5.type === "json" && (n4.responseType = "text", n4.setRequestHeader("Accept", "application/json")), n4.withCredentials = r5.credentials === "include", n4.onerror = () => {
      i(new Error(n4.statusText));
    }, n4.onload = () => {
      if (!e.signal.aborted) if ((n4.status >= 200 && n4.status < 300 || n4.status === 0) && n4.response !== null) {
        let o4 = n4.response;
        if (r5.type === "json") try {
          o4 = JSON.parse(n4.response);
        } catch (a4) {
          i(a4);
          return;
        }
        t({ data: o4, cacheControl: n4.getResponseHeader("Cache-Control"), expires: n4.getResponseHeader("Expires") });
      } else {
        let o4 = new Blob([n4.response], { type: n4.getResponseHeader("Content-Type") });
        i(new $r(n4.status, n4.statusText, r5.url, o4));
      }
    }, e.signal.addEventListener("abort", () => {
      n4.abort(), i(Hr$1());
    }), n4.send(r5.body);
  });
}
H$3(E2$1, "makeXMLHttpRequest");
var ki$1 = H$3(function(r5, e) {
  if (/:\/\//.test(r5.url) && !/^https?:|^file:/.test(r5.url)) {
    let t = ss$1(r5.url);
    if (t) return t(r5, e);
    if (rr$1(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r5, targetMapId: ls$1 }, e);
  }
  if (!I2$1(r5.url)) {
    if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return C2$1(r5, e);
    if (rr$1(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r5, mustQueue: true, targetMapId: ls$1 }, e);
  }
  return E2$1(r5, e);
}, "makeRequest"), gr$1 = H$3((r5, e) => ki$1(V$1(r5, { type: "json" }), e), "getJSON"), pb$1 = H$3((r5, e) => ki$1(V$1(r5, { type: "arrayBuffer" }), e), "getArrayBuffer");
function Pp$1(r5) {
  if (!r5 || r5.indexOf("://") <= 0 || r5.indexOf("data:image/") === 0 || r5.indexOf("blob:") === 0) return true;
  let e = new URL(r5), t = window.location;
  return e.protocol === t.protocol && e.host === t.host;
}
H$3(Pp$1, "sameOrigin");
var hb$1 = H$3((r5) => {
  let e = window.document.createElement("video");
  return e.muted = true, new Promise((t) => {
    e.onloadstart = () => {
      t(e);
    };
    for (let i of r5) {
      let n4 = window.document.createElement("source");
      Pp$1(i) || (e.crossOrigin = "Anonymous"), n4.src = i, e.appendChild(n4);
    }
  });
}, "getVideo");
a();
a();
var Fn = { supported: false, testSupport: k2$1 }, zn$1, Mp = false, Li$2, fb$1 = false;
typeof document < "u" && (Li$2 = document.createElement("img"), Li$2.onload = function() {
  zn$1 && mb$1(zn$1), zn$1 = null, fb$1 = true;
}, Li$2.onerror = function() {
  Mp = true, zn$1 = null;
}, Li$2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
function k2$1(r5) {
  Mp || !Li$2 || (fb$1 ? mb$1(r5) : zn$1 = r5);
}
H$3(k2$1, "testSupport");
function mb$1(r5) {
  let e = r5.createTexture();
  r5.bindTexture(r5.TEXTURE_2D, e);
  try {
    if (r5.texImage2D(r5.TEXTURE_2D, 0, r5.RGBA, r5.RGBA, r5.UNSIGNED_BYTE, Li$2), r5.isContextLost()) return;
    Fn.supported = true;
  } catch (t) {
  }
  r5.deleteTexture(e), Mp = true;
}
H$3(mb$1, "testWebpTextureUpload");
var st$1;
((m5) => {
  let r5, e, t, i;
  m5.resetRequestQueue = H$3(() => {
    r5 = [], e = 0, t = 0, i = {};
  }, "resetRequestQueue"), m5.addThrottleControl = H$3((y4) => {
    let g = t++;
    return i[g] = y4, g;
  }, "addThrottleControl"), m5.removeThrottleControl = H$3((y4) => {
    delete i[y4], h();
  }, "removeThrottleControl");
  let s5 = H$3(() => {
    for (let y4 of Object.keys(i)) if (i[y4]()) return true;
    return false;
  }, "isThrottled");
  m5.getImage = H$3((y4, g, x2 = true) => new Promise((b, w3) => {
    Fn.supported && (y4.headers || (y4.headers = {}), y4.headers.accept = "image/webp,*/*"), V$1(y4, { type: "image" });
    let _ = { abortController: g, requestParameters: y4, supportImageRefresh: x2, state: "queued", onError: H$3((S4) => {
      w3(S4);
    }, "onError"), onSuccess: H$3((S4) => {
      b(S4);
    }, "onSuccess") };
    r5.push(_), h();
  }), "getImage");
  let c = H$3((y4) => typeof createImageBitmap == "function" ? ab$1(y4) : sb$1(y4), "arrayBufferToCanvasImageSource"), p4 = H$3(async (y4) => {
    y4.state = "running";
    let { requestParameters: g, supportImageRefresh: x2, onError: b, onSuccess: w3, abortController: _ } = y4, S4 = x2 === false && !rr$1(self) && !ss$1(g.url) && (!g.headers || Object.keys(g.headers).reduce((T3, L3) => T3 && L3 === "accept", true));
    e++;
    let P4 = S4 ? f(g, _) : ki$1(g, _);
    try {
      let T3 = await P4;
      if (delete y4.abortController, y4.state = "completed", T3.data instanceof HTMLImageElement || ht$1(T3.data)) w3(T3);
      else if (T3.data) {
        let L3 = await c(T3.data);
        w3({ data: L3, cacheControl: T3.cacheControl, expires: T3.expires });
      }
    } catch (T3) {
      delete y4.abortController, b(T3);
    } finally {
      e--, h();
    }
  }, "doImageRequest"), h = H$3(() => {
    let y4 = s5() ? Ke.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : Ke.MAX_PARALLEL_IMAGE_REQUESTS;
    for (let g = e; g < y4 && r5.length > 0; g++) {
      let x2 = r5.shift();
      if (x2.abortController.signal.aborted) {
        g--;
        continue;
      }
      p4(x2);
    }
  }, "processQueue"), f = H$3((y4, g) => new Promise((x2, b) => {
    let w3 = new Image(), _ = y4.url, S4 = y4.credentials;
    S4 && S4 === "include" ? w3.crossOrigin = "use-credentials" : (S4 && S4 === "same-origin" || !Pp$1(_)) && (w3.crossOrigin = "anonymous"), g.signal.addEventListener("abort", () => {
      w3.src = "", b(Hr$1());
    }), w3.fetchPriority = "high", w3.onload = () => {
      w3.onerror = w3.onload = null, x2({ data: w3 });
    }, w3.onerror = () => {
      w3.onerror = w3.onload = null, !g.signal.aborted && b(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
    }, w3.src = _;
  }), "getImageUsingHtmlImage");
})(st$1 || (st$1 = {}));
st$1.resetRequestQueue();
a();
var Ap$1 = class Ap {
  constructor(e) {
    this._transformRequestFn = e;
  }
  transformRequest(e, t) {
    return this._transformRequestFn ? this._transformRequestFn(e, t) || { url: e } : { url: e };
  }
  normalizeSpriteURL(e, t, i) {
    let n4 = D2$1(e);
    return n4.path += "".concat(t).concat(i), z2(n4);
  }
  setTransformRequest(e) {
    this._transformRequestFn = e;
  }
};
H$3(Ap$1, "RequestManager");
var cs$1 = Ap$1, L2$1 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
function D2$1(r5) {
  let e = r5.match(L2$1);
  if (!e) throw new Error('Unable to parse URL "'.concat(r5, '"'));
  return { protocol: e[1], authority: e[2], path: e[3] || "/", params: e[4] ? e[4].split("&") : [] };
}
H$3(D2$1, "parseUrl");
function z2(r5) {
  let e = r5.params.length ? "?".concat(r5.params.join("&")) : "";
  return "".concat(r5.protocol, "://").concat(r5.authority).concat(r5.path).concat(e);
}
H$3(z2, "formatUrl");
a();
a();
function db$1(r5, e, t) {
  t[r5] && t[r5].indexOf(e) !== -1 || (t[r5] = t[r5] || [], t[r5].push(e));
}
H$3(db$1, "_addEventListener");
function Ip$1(r5, e, t) {
  if (t && t[r5]) {
    let i = t[r5].indexOf(e);
    i !== -1 && t[r5].splice(i, 1);
  }
}
H$3(Ip$1, "_removeEventListener");
var Cp$1 = class Cp {
  constructor(e, t = {}) {
    V$1(this, t), this.type = e;
  }
};
H$3(Cp$1, "Event");
var F = Cp$1, Ep = class Ep2 extends F {
  constructor(e, t = {}) {
    super("error", V$1({ error: e }, t));
  }
};
H$3(Ep, "ErrorEvent");
var H$2 = Ep, kp$1 = class kp {
  on(e, t) {
    return this._listeners = this._listeners || {}, db$1(e, t, this._listeners), this;
  }
  off(e, t) {
    return Ip$1(e, t, this._listeners), Ip$1(e, t, this._oneTimeListeners), this;
  }
  once(e, t) {
    return t ? (this._oneTimeListeners = this._oneTimeListeners || {}, db$1(e, t, this._oneTimeListeners), this) : new Promise((i) => this.once(e, i));
  }
  fire(e, t) {
    typeof e == "string" && (e = new F(e, t || {}));
    let i = e.type;
    if (this.listens(i)) {
      e.target = this;
      let n4 = this._listeners && this._listeners[i] ? this._listeners[i].slice() : [];
      for (let s5 of n4) s5.call(this, e);
      let o4 = this._oneTimeListeners && this._oneTimeListeners[i] ? this._oneTimeListeners[i].slice() : [];
      for (let s5 of o4) Ip$1(i, s5, this._oneTimeListeners), s5.call(this, e);
      let a4 = this._eventedParent;
      a4 && (V$1(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), a4.fire(e));
    } else e instanceof H$2 && console.error(e.error);
    return this;
  }
  listens(e) {
    return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
  }
  setEventedParent(e, t) {
    return this._eventedParent = e, this._eventedParentData = t, this;
  }
};
H$3(kp$1, "Evented");
var de$1 = kp$1;
a();
a();
a();
a();
var F2$1 = 8, R2$1 = { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, B2 = { "*": { type: "source" } }, O2$1 = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], V2 = { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, U2 = { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, N2$1 = { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, G2 = { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, q2 = { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, j2 = { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, Z2 = { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, H2 = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], $2 = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, W2 = { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, X2 = { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, K2 = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, J2 = { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, Y2 = { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, Q2 = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, eP = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, tP = { type: "array", value: "*" }, rP = { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, iP = { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, nP = { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, oP = { type: "array", value: "*", minimum: 1 }, aP = { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sP = { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, lP = { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, uP = { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, cP = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], pP = { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, hP = { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, fP = { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, mP = { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, dP = { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, yP = { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, gP = { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, xP = { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, bP = { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, _P = { "*": { type: "string" } }, A$1 = { $version: F2$1, $root: R2$1, sources: B2, source: O2$1, source_vector: V2, source_raster: U2, source_raster_dem: N2$1, source_geojson: G2, source_video: q2, source_image: j2, layer: Z2, layout: H2, layout_background: $2, layout_fill: W2, layout_circle: X2, layout_heatmap: K2, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: J2, layout_symbol: Y2, layout_raster: Q2, layout_hillshade: eP, filter: tP, filter_operator: rP, geometry_type: iP, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: nP, expression: oP, light: aP, sky: sP, terrain: lP, projection: uP, paint: cP, paint_fill: pP, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: hP, paint_circle: fP, paint_heatmap: mP, paint_symbol: dP, paint_raster: yP, paint_hillshade: gP, paint_background: xP, transition: bP, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: _P }, vP = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function wP$1(r5, e) {
  let t = {};
  for (let i in r5) i !== "ref" && (t[i] = r5[i]);
  return vP.forEach((i) => {
    i in e && (t[i] = e[i]);
  }), t;
}
H$3(wP$1, "deref");
function ih$1(r5) {
  r5 = r5.slice();
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < r5.length; t++) e[r5[t].id] = r5[t];
  for (let t = 0; t < r5.length; t++) "ref" in r5[t] && (r5[t] = wP$1(r5[t], e[r5[t].ref]));
  return r5;
}
H$3(ih$1, "derefLayers");
function Ce$2(r5, e) {
  if (Array.isArray(r5)) {
    if (!Array.isArray(e) || r5.length !== e.length) return false;
    for (let t = 0; t < r5.length; t++) if (!Ce$2(r5[t], e[t])) return false;
    return true;
  }
  if (typeof r5 == "object" && r5 !== null && e !== null) {
    if (typeof e != "object" || Object.keys(r5).length !== Object.keys(e).length) return false;
    for (let i in r5) if (!Ce$2(r5[i], e[i])) return false;
    return true;
  }
  return r5 === e;
}
H$3(Ce$2, "deepEqual");
function Mt$1(r5, e) {
  r5.push(e);
}
H$3(Mt$1, "addCommand");
function Vb$1(r5, e, t) {
  Mt$1(t, { command: "addSource", args: [r5, e[r5]] });
}
H$3(Vb$1, "addSource");
function Ub(r5, e, t) {
  Mt$1(e, { command: "removeSource", args: [r5] }), t[r5] = true;
}
H$3(Ub, "removeSource");
function SP(r5, e, t, i) {
  Ub(r5, t, i), Vb$1(r5, e, t);
}
H$3(SP, "updateSource");
function PP(r5, e, t) {
  let i;
  for (i in r5[t]) if (Object.prototype.hasOwnProperty.call(r5[t], i) && i !== "data" && !Ce$2(r5[t][i], e[t][i])) return false;
  for (i in e[t]) if (Object.prototype.hasOwnProperty.call(e[t], i) && i !== "data" && !Ce$2(r5[t][i], e[t][i])) return false;
  return true;
}
H$3(PP, "canUpdateGeoJSON");
function TP(r5, e, t, i) {
  r5 = r5 || {}, e = e || {};
  let n4;
  for (n4 in r5) Object.prototype.hasOwnProperty.call(r5, n4) && (Object.prototype.hasOwnProperty.call(e, n4) || Ub(n4, t, i));
  for (n4 in e) Object.prototype.hasOwnProperty.call(e, n4) && (Object.prototype.hasOwnProperty.call(r5, n4) ? Ce$2(r5[n4], e[n4]) || (r5[n4].type === "geojson" && e[n4].type === "geojson" && PP(r5, e, n4) ? Mt$1(t, { command: "setGeoJSONSourceData", args: [n4, e[n4].data] }) : SP(n4, e, t, i)) : Vb$1(n4, e, t));
}
H$3(TP, "diffSources");
function ps$1(r5, e, t, i, n4, o4) {
  r5 = r5 || {}, e = e || {};
  for (let a4 in r5) Object.prototype.hasOwnProperty.call(r5, a4) && (Ce$2(r5[a4], e[a4]) || t.push({ command: o4, args: [i, a4, e[a4], n4] }));
  for (let a4 in e) !Object.prototype.hasOwnProperty.call(e, a4) || Object.prototype.hasOwnProperty.call(r5, a4) || Ce$2(r5[a4], e[a4]) || t.push({ command: o4, args: [i, a4, e[a4], n4] });
}
H$3(ps$1, "diffLayerPropertyChanges");
function yb$1(r5) {
  return r5.id;
}
H$3(yb$1, "pluckId");
function gb$1(r5, e) {
  return r5[e.id] = e, r5;
}
H$3(gb$1, "indexById");
function MP$1(r5, e, t) {
  r5 = r5 || [], e = e || [];
  let i = r5.map(yb$1), n4 = e.map(yb$1), o4 = r5.reduce(gb$1, {}), a4 = e.reduce(gb$1, {}), s5 = i.slice(), u5 = /* @__PURE__ */ Object.create(null), c, p4, h, f, m5;
  for (let y4 = 0, g = 0; y4 < i.length; y4++) c = i[y4], Object.prototype.hasOwnProperty.call(a4, c) ? g++ : (Mt$1(t, { command: "removeLayer", args: [c] }), s5.splice(s5.indexOf(c, g), 1));
  for (let y4 = 0, g = 0; y4 < n4.length; y4++) c = n4[n4.length - 1 - y4], s5[s5.length - 1 - y4] !== c && (Object.prototype.hasOwnProperty.call(o4, c) ? (Mt$1(t, { command: "removeLayer", args: [c] }), s5.splice(s5.lastIndexOf(c, s5.length - g), 1)) : g++, f = s5[s5.length - y4], Mt$1(t, { command: "addLayer", args: [a4[c], f] }), s5.splice(s5.length - y4, 0, c), u5[c] = true);
  for (let y4 = 0; y4 < n4.length; y4++) if (c = n4[y4], p4 = o4[c], h = a4[c], !(u5[c] || Ce$2(p4, h))) {
    if (!Ce$2(p4.source, h.source) || !Ce$2(p4["source-layer"], h["source-layer"]) || !Ce$2(p4.type, h.type)) {
      Mt$1(t, { command: "removeLayer", args: [c] }), f = s5[s5.lastIndexOf(c) + 1], Mt$1(t, { command: "addLayer", args: [h, f] });
      continue;
    }
    ps$1(p4.layout, h.layout, t, c, null, "setLayoutProperty"), ps$1(p4.paint, h.paint, t, c, null, "setPaintProperty"), Ce$2(p4.filter, h.filter) || Mt$1(t, { command: "setFilter", args: [c, h.filter] }), (!Ce$2(p4.minzoom, h.minzoom) || !Ce$2(p4.maxzoom, h.maxzoom)) && Mt$1(t, { command: "setLayerZoomRange", args: [c, h.minzoom, h.maxzoom] });
    for (m5 in p4) Object.prototype.hasOwnProperty.call(p4, m5) && (m5 === "layout" || m5 === "paint" || m5 === "filter" || m5 === "metadata" || m5 === "minzoom" || m5 === "maxzoom" || (m5.indexOf("paint.") === 0 ? ps$1(p4[m5], h[m5], t, c, m5.slice(6), "setPaintProperty") : Ce$2(p4[m5], h[m5]) || Mt$1(t, { command: "setLayerProperty", args: [c, m5, h[m5]] })));
    for (m5 in h) !Object.prototype.hasOwnProperty.call(h, m5) || Object.prototype.hasOwnProperty.call(p4, m5) || m5 === "layout" || m5 === "paint" || m5 === "filter" || m5 === "metadata" || m5 === "minzoom" || m5 === "maxzoom" || (m5.indexOf("paint.") === 0 ? ps$1(p4[m5], h[m5], t, c, m5.slice(6), "setPaintProperty") : Ce$2(p4[m5], h[m5]) || Mt$1(t, { command: "setLayerProperty", args: [c, m5, h[m5]] }));
  }
}
H$3(MP$1, "diffLayers");
function Nb(r5, e) {
  if (!r5) return [{ command: "setStyle", args: [e] }];
  let t = [];
  try {
    if (!Ce$2(r5.version, e.version)) return [{ command: "setStyle", args: [e] }];
    Ce$2(r5.center, e.center) || t.push({ command: "setCenter", args: [e.center] }), Ce$2(r5.zoom, e.zoom) || t.push({ command: "setZoom", args: [e.zoom] }), Ce$2(r5.bearing, e.bearing) || t.push({ command: "setBearing", args: [e.bearing] }), Ce$2(r5.pitch, e.pitch) || t.push({ command: "setPitch", args: [e.pitch] }), Ce$2(r5.roll, e.roll) || t.push({ command: "setRoll", args: [e.roll] }), Ce$2(r5.sprite, e.sprite) || t.push({ command: "setSprite", args: [e.sprite] }), Ce$2(r5.glyphs, e.glyphs) || t.push({ command: "setGlyphs", args: [e.glyphs] }), Ce$2(r5.transition, e.transition) || t.push({ command: "setTransition", args: [e.transition] }), Ce$2(r5.light, e.light) || t.push({ command: "setLight", args: [e.light] }), Ce$2(r5.terrain, e.terrain) || t.push({ command: "setTerrain", args: [e.terrain] }), Ce$2(r5.sky, e.sky) || t.push({ command: "setSky", args: [e.sky] }), Ce$2(r5.projection, e.projection) || t.push({ command: "setProjection", args: [e.projection] });
    let i = {}, n4 = [];
    TP(r5.sources, e.sources, n4, i);
    let o4 = [];
    r5.layers && r5.layers.forEach((a4) => {
      "source" in a4 && i[a4.source] ? t.push({ command: "removeLayer", args: [a4.id] }) : o4.push(a4);
    }), t = t.concat(n4), MP$1(o4, e.layers, t);
  } catch (i) {
    console.warn("Unable to compute style diff:", i), t = [{ command: "setStyle", args: [e] }];
  }
  return t;
}
H$3(Nb, "diffStyles");
var dh$1 = class dh2 {
  constructor(e, t, i, n4) {
    this.message = (e ? "".concat(e, ": ") : "") + i, n4 && (this.identifier = n4), t != null && t.__line__ && (this.line = t.__line__);
  }
};
H$3(dh$1, "ValidationError");
var B$1 = dh$1;
function Ni$1(r5, ...e) {
  for (let t of e) for (let i in t) r5[i] = t[i];
  return r5;
}
H$3(Ni$1, "extendBy");
var yh$1 = class yh2 extends Error {
  constructor(e, t) {
    super(t), this.message = t, this.key = e;
  }
};
H$3(yh$1, "ExpressionParsingError");
var At$1 = yh$1, Es$1 = class Es {
  constructor(e, t = []) {
    this.parent = e, this.bindings = {};
    for (let [i, n4] of t) this.bindings[i] = n4;
  }
  concat(e) {
    return new Es(this, e);
  }
  get(e) {
    if (this.bindings[e]) return this.bindings[e];
    if (this.parent) return this.parent.get(e);
    throw new Error("".concat(e, " not found in scope."));
  }
  has(e) {
    return this.bindings[e] ? true : this.parent ? this.parent.has(e) : false;
  }
};
H$3(Es$1, "Scope");
var Np$1 = Es$1, ji = { kind: "null" }, j$1 = { kind: "number" }, pe$2 = { kind: "string" }, se$1 = { kind: "boolean" }, Ct$1 = { kind: "color" }, Vi = { kind: "object" }, le$1 = { kind: "value" }, AP = { kind: "error" }, Xs = { kind: "collator" }, Zi$1 = { kind: "formatted" }, Ks = { kind: "padding" }, no = { kind: "resolvedImage" }, Js = { kind: "variableAnchorOffsetCollection" };
function _t$1(r5, e) {
  return { kind: "array", itemType: r5, N: e };
}
H$3(_t$1, "array$1");
function Re$1(r5) {
  if (r5.kind === "array") {
    let e = Re$1(r5.itemType);
    return typeof r5.N == "number" ? "array<".concat(e, ", ").concat(r5.N, ">") : r5.itemType.kind === "value" ? "array" : "array<".concat(e, ">");
  } else return r5.kind;
}
H$3(Re$1, "toString$1");
var IP = [ji, j$1, pe$2, se$1, Ct$1, Zi$1, Vi, _t$1(le$1), Ks, no, Js];
function Hn(r5, e) {
  if (e.kind === "error") return null;
  if (r5.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Hn(r5.itemType, e.itemType)) && (typeof r5.N != "number" || r5.N === e.N)) return null;
  } else {
    if (r5.kind === e.kind) return null;
    if (r5.kind === "value") {
      for (let t of IP) if (!Hn(t, e)) return null;
    }
  }
  return "Expected ".concat(Re$1(r5), " but found ").concat(Re$1(e), " instead.");
}
H$3(Hn, "checkSubtype");
function nh$1(r5, e) {
  return e.some((t) => t.kind === r5.kind);
}
H$3(nh$1, "isValidType");
function Yr$1(r5, e) {
  return e.some((t) => t === "null" ? r5 === null : t === "array" ? Array.isArray(r5) : t === "object" ? r5 && !Array.isArray(r5) && typeof r5 == "object" : t === typeof r5);
}
H$3(Yr$1, "isValidNativeType");
function Rn(r5, e) {
  return r5.kind === "array" && e.kind === "array" ? r5.itemType.kind === e.itemType.kind && typeof r5.N == "number" : r5.kind === e.kind;
}
H$3(Rn, "verifyType");
var Gb = 0.96422, qb = 1, jb$1 = 0.82521, Zb = 4 / 29, Ui = 6 / 29, Hb = 3 * Ui * Ui, CP = Ui * Ui * Ui, EP = Math.PI / 180, kP = 180 / Math.PI;
function $b$1(r5) {
  return r5 = r5 % 360, r5 < 0 && (r5 += 360), r5;
}
H$3($b$1, "constrainAngle");
function Wb([r5, e, t, i]) {
  r5 = Lp$1(r5), e = Lp$1(e), t = Lp$1(t);
  let n4, o4, a4 = Dp$1((0.2225045 * r5 + 0.7168786 * e + 0.0606169 * t) / qb);
  r5 === e && e === t ? n4 = o4 = a4 : (n4 = Dp$1((0.4360747 * r5 + 0.3850649 * e + 0.1430804 * t) / Gb), o4 = Dp$1((0.0139322 * r5 + 0.0971045 * e + 0.7141733 * t) / jb$1));
  let s5 = 116 * a4 - 16;
  return [s5 < 0 ? 0 : s5, 500 * (n4 - a4), 200 * (a4 - o4), i];
}
H$3(Wb, "rgbToLab");
function Lp$1(r5) {
  return r5 <= 0.04045 ? r5 / 12.92 : Math.pow((r5 + 0.055) / 1.055, 2.4);
}
H$3(Lp$1, "rgb2xyz");
function Dp$1(r5) {
  return r5 > CP ? Math.pow(r5, 1 / 3) : r5 / Hb + Zb;
}
H$3(Dp$1, "xyz2lab");
function Xb([r5, e, t, i]) {
  let n4 = (r5 + 16) / 116, o4 = isNaN(e) ? n4 : n4 + e / 500, a4 = isNaN(t) ? n4 : n4 - t / 200;
  return n4 = qb * Fp$1(n4), o4 = Gb * Fp$1(o4), a4 = jb$1 * Fp$1(a4), [zp$1(3.1338561 * o4 - 1.6168667 * n4 - 0.4906146 * a4), zp$1(-0.9787684 * o4 + 1.9161415 * n4 + 0.033454 * a4), zp$1(0.0719453 * o4 - 0.2289914 * n4 + 1.4052427 * a4), i];
}
H$3(Xb, "labToRgb");
function zp$1(r5) {
  return r5 = r5 <= 304e-5 ? 12.92 * r5 : 1.055 * Math.pow(r5, 1 / 2.4) - 0.055, r5 < 0 ? 0 : r5 > 1 ? 1 : r5;
}
H$3(zp$1, "xyz2rgb");
function Fp$1(r5) {
  return r5 > Ui ? r5 * r5 * r5 : Hb * (r5 - Zb);
}
H$3(Fp$1, "lab2xyz");
function LP$1(r5) {
  let [e, t, i, n4] = Wb(r5), o4 = Math.sqrt(t * t + i * i);
  return [Math.round(o4 * 1e4) ? $b$1(Math.atan2(i, t) * kP) : NaN, o4, e, n4];
}
H$3(LP$1, "rgbToHcl");
function DP([r5, e, t, i]) {
  return r5 = isNaN(r5) ? 0 : r5 * EP, Xb([t, Math.cos(r5) * e, Math.sin(r5) * e, i]);
}
H$3(DP, "hclToRgb");
function zP$1([r5, e, t, i]) {
  r5 = $b$1(r5), e /= 100, t /= 100;
  function n4(o4) {
    let a4 = (o4 + r5 / 30) % 12, s5 = e * Math.min(t, 1 - t);
    return t - s5 * Math.max(-1, Math.min(a4 - 3, 9 - a4, 1));
  }
  return H$3(n4, "f"), [n4(0), n4(8), n4(4), i];
}
H$3(zP$1, "hslToRgb");
function FP(r5) {
  if (r5 = r5.toLowerCase().trim(), r5 === "transparent") return [0, 0, 0, 0];
  let e = RP[r5];
  if (e) {
    let [n4, o4, a4] = e;
    return [n4 / 255, o4 / 255, a4 / 255, 1];
  }
  if (r5.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r5)) {
    let o4 = r5.length < 6 ? 1 : 2, a4 = 1;
    return [hs$1(r5.slice(a4, a4 += o4)), hs$1(r5.slice(a4, a4 += o4)), hs$1(r5.slice(a4, a4 += o4)), hs$1(r5.slice(a4, a4 + o4) || "ff")];
  }
  if (r5.startsWith("rgb")) {
    let n4 = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, o4 = r5.match(n4);
    if (o4) {
      let [a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b] = o4, w3 = [c || " ", f || " ", g].join("");
      if (w3 === "  " || w3 === "  /" || w3 === ",," || w3 === ",,,") {
        let _ = [u5, h, y4].join(""), S4 = _ === "%%%" ? 100 : _ === "" ? 255 : 0;
        if (S4) {
          let P4 = [Di$1(+s5 / S4, 0, 1), Di$1(+p4 / S4, 0, 1), Di$1(+m5 / S4, 0, 1), x2 ? xb(+x2, b) : 1];
          if (bb$1(P4)) return P4;
        }
      }
      return;
    }
  }
  let t = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, i = r5.match(t);
  if (i) {
    let [n4, o4, a4, s5, u5, c, p4, h, f] = i, m5 = [a4 || " ", u5 || " ", p4].join("");
    if (m5 === "  " || m5 === "  /" || m5 === ",," || m5 === ",,,") {
      let y4 = [+o4, Di$1(+s5, 0, 100), Di$1(+c, 0, 100), h ? xb(+h, f) : 1];
      if (bb$1(y4)) return zP$1(y4);
    }
  }
}
H$3(FP, "parseCssColor");
function hs$1(r5) {
  return parseInt(r5.padEnd(2, r5), 16) / 255;
}
H$3(hs$1, "parseHex");
function xb(r5, e) {
  return Di$1(e ? r5 / 100 : r5, 0, 1);
}
H$3(xb, "parseAlpha");
function Di$1(r5, e, t) {
  return Math.min(Math.max(e, r5), t);
}
H$3(Di$1, "clamp");
function bb$1(r5) {
  return !r5.some(Number.isNaN);
}
H$3(bb$1, "validateNumbers");
var RP = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Un$1 = class Un {
  constructor(e, t, i, n4 = 1, o4 = true) {
    this.r = e, this.g = t, this.b = i, this.a = n4, o4 || (this.r *= n4, this.g *= n4, this.b *= n4, n4 || this.overwriteGetter("rgb", [e, t, i, n4]));
  }
  static parse(e) {
    if (e instanceof Un) return e;
    if (typeof e != "string") return;
    let t = FP(e);
    if (t) return new Un(...t, false);
  }
  get rgb() {
    let { r: e, g: t, b: i, a: n4 } = this, o4 = n4 || 1 / 0;
    return this.overwriteGetter("rgb", [e / o4, t / o4, i / o4, n4]);
  }
  get hcl() {
    return this.overwriteGetter("hcl", LP$1(this.rgb));
  }
  get lab() {
    return this.overwriteGetter("lab", Wb(this.rgb));
  }
  overwriteGetter(e, t) {
    return Object.defineProperty(this, e, { value: t }), t;
  }
  toString() {
    let [e, t, i, n4] = this.rgb;
    return "rgba(".concat([e, t, i].map((o4) => Math.round(o4 * 255)).join(","), ",").concat(n4, ")");
  }
};
H$3(Un$1, "Color");
var X$1 = Un$1;
X$1.black = new X$1(0, 0, 0, 1);
X$1.white = new X$1(1, 1, 1, 1);
X$1.transparent = new X$1(0, 0, 0, 0);
X$1.red = new X$1(1, 0, 0, 1);
var gh$1 = class gh2 {
  constructor(e, t, i) {
    e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = i, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(e, t) {
    return this.collator.compare(e, t);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
H$3(gh$1, "Collator");
var $n = gh$1, xh$1 = class xh2 {
  constructor(e, t, i, n4, o4) {
    this.text = e, this.image = t, this.scale = i, this.fontStack = n4, this.textColor = o4;
  }
};
H$3(xh$1, "FormattedSection");
var Wn = xh$1, Fi = class Fi2 {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new Fi2([new Wn(e, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? true : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof Fi2 ? e : Fi2.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
};
H$3(Fi, "Formatted");
var wt$1 = Fi, Ri = class Ri2 {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof Ri2) return e;
    if (typeof e == "number") return new Ri2([e, e, e, e]);
    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
      for (let t of e) if (typeof t != "number") return;
      switch (e.length) {
        case 1:
          e = [e[0], e[0], e[0], e[0]];
          break;
        case 2:
          e = [e[0], e[1], e[0], e[1]];
          break;
        case 3:
          e = [e[0], e[1], e[2], e[1]];
          break;
      }
      return new Ri2(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
H$3(Ri, "Padding");
var Rt$1 = Ri, BP$1 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]), Nn$1 = class Nn {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof Nn) return e;
    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
      for (let t = 0; t < e.length; t += 2) {
        let i = e[t], n4 = e[t + 1];
        if (typeof i != "string" || !BP$1.has(i) || !Array.isArray(n4) || n4.length !== 2 || typeof n4[0] != "number" || typeof n4[1] != "number") return;
      }
      return new Nn(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
H$3(Nn$1, "VariableAnchorOffsetCollection");
var ir$1 = Nn$1, ks$1 = class ks {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new ks({ name: e, available: false }) : null;
  }
};
H$3(ks$1, "ResolvedImage");
var ft$1 = ks$1;
function Kb$1(r5, e, t, i) {
  if (!(typeof r5 == "number" && r5 >= 0 && r5 <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255)) {
    let n4 = typeof i == "number" ? [r5, e, t, i] : [r5, e, t];
    return "Invalid rgba value [".concat(n4.join(", "), "]: 'r', 'g', and 'b' must be between 0 and 255.");
  }
  return typeof i > "u" || typeof i == "number" && i >= 0 && i <= 1 ? null : "Invalid rgba value [".concat([r5, e, t, i].join(", "), "]: 'a' must be between 0 and 1.");
}
H$3(Kb$1, "validateRGBA");
function Xn(r5) {
  if (r5 === null || typeof r5 == "string" || typeof r5 == "boolean" || typeof r5 == "number" || r5 instanceof X$1 || r5 instanceof $n || r5 instanceof wt$1 || r5 instanceof Rt$1 || r5 instanceof ir$1 || r5 instanceof ft$1) return true;
  if (Array.isArray(r5)) {
    for (let e of r5) if (!Xn(e)) return false;
    return true;
  } else if (typeof r5 == "object") {
    for (let e in r5) if (!Xn(r5[e])) return false;
    return true;
  } else return false;
}
H$3(Xn, "isValue");
function He(r5) {
  if (r5 === null) return ji;
  if (typeof r5 == "string") return pe$2;
  if (typeof r5 == "boolean") return se$1;
  if (typeof r5 == "number") return j$1;
  if (r5 instanceof X$1) return Ct$1;
  if (r5 instanceof $n) return Xs;
  if (r5 instanceof wt$1) return Zi$1;
  if (r5 instanceof Rt$1) return Ks;
  if (r5 instanceof ir$1) return Js;
  if (r5 instanceof ft$1) return no;
  if (Array.isArray(r5)) {
    let e = r5.length, t;
    for (let i of r5) {
      let n4 = He(i);
      if (!t) t = n4;
      else {
        if (t === n4) continue;
        t = le$1;
        break;
      }
    }
    return _t$1(t || le$1, e);
  } else return Vi;
}
H$3(He, "typeOf");
function On$1(r5) {
  let e = typeof r5;
  return r5 === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r5) : r5 instanceof X$1 || r5 instanceof wt$1 || r5 instanceof Rt$1 || r5 instanceof ir$1 || r5 instanceof ft$1 ? r5.toString() : JSON.stringify(r5);
}
H$3(On$1, "toString");
var Ls$1 = class Ls {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("'literal' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (!Xn(e[1])) return t.error("invalid value");
    let i = e[1], n4 = He(i), o4 = t.expectedType;
    return n4.kind === "array" && n4.N === 0 && o4 && o4.kind === "array" && (typeof o4.N != "number" || o4.N === 0) && (n4 = o4), new Ls(n4, i);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
H$3(Ls$1, "Literal");
var br = Ls$1, bh$1 = class bh2 {
  constructor(e) {
    this.name = "ExpressionEvaluationError", this.message = e;
  }
  toJSON() {
    return this.message;
  }
};
H$3(bh$1, "RuntimeError");
var Be$1 = bh$1, fs$1 = { string: pe$2, number: j$1, boolean: se$1, object: Vi }, Ds$1 = class Ds {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expected at least one argument.");
    let i = 1, n4, o4 = e[0];
    if (o4 === "array") {
      let s5;
      if (e.length > 2) {
        let c = e[1];
        if (typeof c != "string" || !(c in fs$1) || c === "object") return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
        s5 = fs$1[c], i++;
      } else s5 = le$1;
      let u5;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error('The length argument to "array" must be a positive integer literal', 2);
        u5 = e[2], i++;
      }
      n4 = _t$1(s5, u5);
    } else {
      if (!fs$1[o4]) throw new Error("Types doesn't contain name = ".concat(o4));
      n4 = fs$1[o4];
    }
    let a4 = [];
    for (; i < e.length; i++) {
      let s5 = t.parse(e[i], i, le$1);
      if (!s5) return null;
      a4.push(s5);
    }
    return new Ds(n4, a4);
  }
  evaluate(e) {
    for (let t = 0; t < this.args.length; t++) {
      let i = this.args[t].evaluate(e);
      if (Hn(this.type, He(i))) {
        if (t === this.args.length - 1) throw new Be$1("Expected value to be of type ".concat(Re$1(this.type), ", but found ").concat(Re$1(He(i)), " instead."));
      } else return i;
    }
    throw new Error();
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
H$3(Ds$1, "Assertion");
var Ft$2 = Ds$1, _b$1 = { "to-boolean": se$1, "to-color": Ct$1, "to-number": j$1, "to-string": pe$2 }, zs$1 = class zs {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expected at least one argument.");
    let i = e[0];
    if (!_b$1[i]) throw new Error("Can't parse ".concat(i, " as it is not part of the known types"));
    if ((i === "to-boolean" || i === "to-string") && e.length !== 2) return t.error("Expected one argument.");
    let n4 = _b$1[i], o4 = [];
    for (let a4 = 1; a4 < e.length; a4++) {
      let s5 = t.parse(e[a4], a4, le$1);
      if (!s5) return null;
      o4.push(s5);
    }
    return new zs(n4, o4);
  }
  evaluate(e) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e);
      case "color": {
        let t, i;
        for (let n4 of this.args) {
          if (t = n4.evaluate(e), i = null, t instanceof X$1) return t;
          if (typeof t == "string") {
            let o4 = e.parseColor(t);
            if (o4) return o4;
          } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? i = "Invalid rgba value ".concat(JSON.stringify(t), ": expected an array containing either three or four numeric values.") : i = Kb$1(t[0], t[1], t[2], t[3]), !i)) return new X$1(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
        }
        throw new Be$1(i || "Could not parse color from value '".concat(typeof t == "string" ? t : JSON.stringify(t), "'"));
      }
      case "padding": {
        let t;
        for (let i of this.args) {
          t = i.evaluate(e);
          let n4 = Rt$1.parse(t);
          if (n4) return n4;
        }
        throw new Be$1("Could not parse padding from value '".concat(typeof t == "string" ? t : JSON.stringify(t), "'"));
      }
      case "variableAnchorOffsetCollection": {
        let t;
        for (let i of this.args) {
          t = i.evaluate(e);
          let n4 = ir$1.parse(t);
          if (n4) return n4;
        }
        throw new Be$1("Could not parse variableAnchorOffsetCollection from value '".concat(typeof t == "string" ? t : JSON.stringify(t), "'"));
      }
      case "number": {
        let t = null;
        for (let i of this.args) {
          if (t = i.evaluate(e), t === null) return 0;
          let n4 = Number(t);
          if (!isNaN(n4)) return n4;
        }
        throw new Be$1("Could not convert ".concat(JSON.stringify(t), " to number."));
      }
      case "formatted":
        return wt$1.fromString(On$1(this.args[0].evaluate(e)));
      case "resolvedImage":
        return ft$1.fromString(On$1(this.args[0].evaluate(e)));
      default:
        return On$1(this.args[0].evaluate(e));
    }
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
H$3(zs$1, "Coercion");
var xr = zs$1, OP$1 = ["Unknown", "Point", "LineString", "Polygon"], _h$1 = class _h2 {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? OP$1[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e) {
    let t = this._parseColorCache[e];
    return t || (t = this._parseColorCache[e] = X$1.parse(e)), t;
  }
};
H$3(_h$1, "EvaluationContext");
var gs = _h$1, Fs$1 = class Fs {
  constructor(e, t, i = [], n4, o4 = new Np$1(), a4 = []) {
    this.registry = e, this.path = i, this.key = i.map((s5) => "[".concat(s5, "]")).join(""), this.scope = o4, this.errors = a4, this.expectedType = n4, this._isConstant = t;
  }
  parse(e, t, i, n4, o4 = {}) {
    return t ? this.concat(t, i, n4)._parse(e, o4) : this._parse(e, o4);
  }
  _parse(e, t) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
    function i(n4, o4, a4) {
      return a4 === "assert" ? new Ft$2(o4, [n4]) : a4 === "coerce" ? new xr(o4, [n4]) : n4;
    }
    if (H$3(i, "annotate"), Array.isArray(e)) {
      if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      let n4 = e[0];
      if (typeof n4 != "string") return this.error("Expression name must be a string, but found ".concat(typeof n4, ' instead. If you wanted a literal array, use ["literal", [...]].'), 0), null;
      let o4 = this.registry[n4];
      if (o4) {
        let a4 = o4.parse(e, this);
        if (!a4) return null;
        if (this.expectedType) {
          let s5 = this.expectedType, u5 = a4.type;
          if ((s5.kind === "string" || s5.kind === "number" || s5.kind === "boolean" || s5.kind === "object" || s5.kind === "array") && u5.kind === "value") a4 = i(a4, s5, t.typeAnnotation || "assert");
          else if ((s5.kind === "color" || s5.kind === "formatted" || s5.kind === "resolvedImage") && (u5.kind === "value" || u5.kind === "string")) a4 = i(a4, s5, t.typeAnnotation || "coerce");
          else if (s5.kind === "padding" && (u5.kind === "value" || u5.kind === "number" || u5.kind === "array")) a4 = i(a4, s5, t.typeAnnotation || "coerce");
          else if (s5.kind === "variableAnchorOffsetCollection" && (u5.kind === "value" || u5.kind === "array")) a4 = i(a4, s5, t.typeAnnotation || "coerce");
          else if (this.checkSubtype(s5, u5)) return null;
        }
        if (!(a4 instanceof br) && a4.type.kind !== "resolvedImage" && this._isConstant(a4)) {
          let s5 = new gs();
          try {
            a4 = new br(a4.type, a4.evaluate(s5));
          } catch (u5) {
            return this.error(u5.message), null;
          }
        }
        return a4;
      }
      return this.error('Unknown expression "'.concat(n4, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found ".concat(typeof e, " instead."));
  }
  concat(e, t, i) {
    let n4 = typeof e == "number" ? this.path.concat(e) : this.path, o4 = i ? this.scope.concat(i) : this.scope;
    return new Fs(this.registry, this._isConstant, n4, t || null, o4, this.errors);
  }
  error(e, ...t) {
    let i = "".concat(this.key).concat(t.map((n4) => "[".concat(n4, "]")).join(""));
    this.errors.push(new At$1(i, e));
  }
  checkSubtype(e, t) {
    let i = Hn(e, t);
    return i && this.error(i), i;
  }
};
H$3(Fs$1, "ParsingContext");
var xs = Fs$1, Rs = class Rs2 {
  constructor(e, t) {
    this.type = t.type, this.bindings = [].concat(e), this.result = t;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (let t of this.bindings) e(t[1]);
    e(this.result);
  }
  static parse(e, t) {
    if (e.length < 4) return t.error("Expected at least 3 arguments, but found ".concat(e.length - 1, " instead."));
    let i = [];
    for (let o4 = 1; o4 < e.length - 1; o4 += 2) {
      let a4 = e[o4];
      if (typeof a4 != "string") return t.error("Expected string, but found ".concat(typeof a4, " instead."), o4);
      if (/[^a-zA-Z0-9_]/.test(a4)) return t.error("Variable names must contain only alphanumeric characters or '_'.", o4);
      let s5 = t.parse(e[o4 + 1], o4 + 1);
      if (!s5) return null;
      i.push([a4, s5]);
    }
    let n4 = t.parse(e[e.length - 1], e.length - 1, t.expectedType, i);
    return n4 ? new Rs2(i, n4) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
};
H$3(Rs, "Let");
var bs = Rs, Bs$1 = class Bs {
  constructor(e, t) {
    this.type = t.type, this.name = e, this.boundExpression = t;
  }
  static parse(e, t) {
    if (e.length !== 2 || typeof e[1] != "string") return t.error("'var' expression requires exactly one string literal argument.");
    let i = e[1];
    return t.scope.has(i) ? new Bs(i, t.scope.get(i)) : t.error('Unknown variable "'.concat(i, '". Make sure "').concat(i, '" has been bound in an enclosing "let" expression before using it.'), 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
H$3(Bs$1, "Var");
var _s = Bs$1, Os$1 = class Os {
  constructor(e, t, i) {
    this.type = e, this.index = t, this.input = i;
  }
  static parse(e, t) {
    if (e.length !== 3) return t.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, j$1), n4 = t.parse(e[2], 2, _t$1(t.expectedType || le$1));
    if (!i || !n4) return null;
    let o4 = n4.type;
    return new Os(o4.itemType, i, n4);
  }
  evaluate(e) {
    let t = this.index.evaluate(e), i = this.input.evaluate(e);
    if (t < 0) throw new Be$1("Array index out of bounds: ".concat(t, " < 0."));
    if (t >= i.length) throw new Be$1("Array index out of bounds: ".concat(t, " > ").concat(i.length - 1, "."));
    if (t !== Math.floor(t)) throw new Be$1("Array index must be an integer, but found ".concat(t, " instead."));
    return i[t];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return false;
  }
};
H$3(Os$1, "At");
var Gp$1 = Os$1, Vs$1 = class Vs {
  constructor(e, t) {
    this.type = se$1, this.needle = e, this.haystack = t;
  }
  static parse(e, t) {
    if (e.length !== 3) return t.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, le$1), n4 = t.parse(e[2], 2, le$1);
    return !i || !n4 ? null : nh$1(i.type, [se$1, pe$2, j$1, ji, le$1]) ? new Vs(i, n4) : t.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Re$1(i.type), " instead"));
  }
  evaluate(e) {
    let t = this.needle.evaluate(e), i = this.haystack.evaluate(e);
    if (!i) return false;
    if (!Yr$1(t, ["boolean", "string", "number", "null"])) throw new Be$1("Expected first argument to be of type boolean, string, number or null, but found ".concat(Re$1(He(t)), " instead."));
    if (!Yr$1(i, ["string", "array"])) throw new Be$1("Expected second argument to be of type array or string, but found ".concat(Re$1(He(i)), " instead."));
    return i.indexOf(t) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return true;
  }
};
H$3(Vs$1, "In");
var qp$1 = Vs$1, Gn$1 = class Gn {
  constructor(e, t, i) {
    this.type = j$1, this.needle = e, this.haystack = t, this.fromIndex = i;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5) return t.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, le$1), n4 = t.parse(e[2], 2, le$1);
    if (!i || !n4) return null;
    if (!nh$1(i.type, [se$1, pe$2, j$1, ji, le$1])) return t.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Re$1(i.type), " instead"));
    if (e.length === 4) {
      let o4 = t.parse(e[3], 3, j$1);
      return o4 ? new Gn(i, n4, o4) : null;
    } else return new Gn(i, n4);
  }
  evaluate(e) {
    let t = this.needle.evaluate(e), i = this.haystack.evaluate(e);
    if (!Yr$1(t, ["boolean", "string", "number", "null"])) throw new Be$1("Expected first argument to be of type boolean, string, number or null, but found ".concat(Re$1(He(t)), " instead."));
    let n4;
    if (this.fromIndex && (n4 = this.fromIndex.evaluate(e)), Yr$1(i, ["string"])) {
      let o4 = i.indexOf(t, n4);
      return o4 === -1 ? -1 : [...i.slice(0, o4)].length;
    } else {
      if (Yr$1(i, ["array"])) return i.indexOf(t, n4);
      throw new Be$1("Expected second argument to be of type array or string, but found ".concat(Re$1(He(i)), " instead."));
    }
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return false;
  }
};
H$3(Gn$1, "IndexOf");
var jp$1 = Gn$1, Us$1 = class Us {
  constructor(e, t, i, n4, o4, a4) {
    this.inputType = e, this.type = t, this.input = i, this.cases = n4, this.outputs = o4, this.otherwise = a4;
  }
  static parse(e, t) {
    if (e.length < 5) return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if (e.length % 2 !== 1) return t.error("Expected an even number of arguments.");
    let i, n4;
    t.expectedType && t.expectedType.kind !== "value" && (n4 = t.expectedType);
    let o4 = {}, a4 = [];
    for (let c = 2; c < e.length - 1; c += 2) {
      let p4 = e[c], h = e[c + 1];
      Array.isArray(p4) || (p4 = [p4]);
      let f = t.concat(c);
      if (p4.length === 0) return f.error("Expected at least one branch label.");
      for (let y4 of p4) {
        if (typeof y4 != "number" && typeof y4 != "string") return f.error("Branch labels must be numbers or strings.");
        if (typeof y4 == "number" && Math.abs(y4) > Number.MAX_SAFE_INTEGER) return f.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
        if (typeof y4 == "number" && Math.floor(y4) !== y4) return f.error("Numeric branch labels must be integer values.");
        if (!i) i = He(y4);
        else if (f.checkSubtype(i, He(y4))) return null;
        if (typeof o4[String(y4)] < "u") return f.error("Branch labels must be unique.");
        o4[String(y4)] = a4.length;
      }
      let m5 = t.parse(h, c, n4);
      if (!m5) return null;
      n4 = n4 || m5.type, a4.push(m5);
    }
    let s5 = t.parse(e[1], 1, le$1);
    if (!s5) return null;
    let u5 = t.parse(e[e.length - 1], e.length - 1, n4);
    return !u5 || s5.type.kind !== "value" && t.concat(1).checkSubtype(i, s5.type) ? null : new Us(i, n4, s5, o4, a4, u5);
  }
  evaluate(e) {
    let t = this.input.evaluate(e);
    return (He(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
};
H$3(Us$1, "Match");
var Zp$1 = Us$1, Ns$1 = class Ns {
  constructor(e, t, i) {
    this.type = e, this.branches = t, this.otherwise = i;
  }
  static parse(e, t) {
    if (e.length < 4) return t.error("Expected at least 3 arguments, but found only ".concat(e.length - 1, "."));
    if (e.length % 2 !== 0) return t.error("Expected an odd number of arguments.");
    let i;
    t.expectedType && t.expectedType.kind !== "value" && (i = t.expectedType);
    let n4 = [];
    for (let a4 = 1; a4 < e.length - 1; a4 += 2) {
      let s5 = t.parse(e[a4], a4, se$1);
      if (!s5) return null;
      let u5 = t.parse(e[a4 + 1], a4 + 1, i);
      if (!u5) return null;
      n4.push([s5, u5]), i = i || u5.type;
    }
    let o4 = t.parse(e[e.length - 1], e.length - 1, i);
    if (!o4) return null;
    if (!i) throw new Error("Can't infer output type");
    return new Ns(i, n4, o4);
  }
  evaluate(e) {
    for (let [t, i] of this.branches) if (t.evaluate(e)) return i.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (let [t, i] of this.branches) e(t), e(i);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
  }
};
H$3(Ns$1, "Case");
var Hp$1 = Ns$1, qn = class qn2 {
  constructor(e, t, i, n4) {
    this.type = e, this.input = t, this.beginIndex = i, this.endIndex = n4;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5) return t.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1, le$1), n4 = t.parse(e[2], 2, j$1);
    if (!i || !n4) return null;
    if (!nh$1(i.type, [_t$1(le$1), pe$2, le$1])) return t.error("Expected first argument to be of type array or string, but found ".concat(Re$1(i.type), " instead"));
    if (e.length === 4) {
      let o4 = t.parse(e[3], 3, j$1);
      return o4 ? new qn2(i.type, i, n4, o4) : null;
    } else return new qn2(i.type, i, n4);
  }
  evaluate(e) {
    let t = this.input.evaluate(e), i = this.beginIndex.evaluate(e), n4;
    if (this.endIndex && (n4 = this.endIndex.evaluate(e)), Yr$1(t, ["string"])) return [...t].slice(i, n4).join("");
    if (Yr$1(t, ["array"])) return t.slice(i, n4);
    throw new Be$1("Expected first argument to be of type array or string, but found ".concat(Re$1(He(t)), " instead."));
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return false;
  }
};
H$3(qn, "Slice");
var $p$1 = qn;
function Ys(r5, e) {
  let t = r5.length - 1, i = 0, n4 = t, o4 = 0, a4, s5;
  for (; i <= n4; ) if (o4 = Math.floor((i + n4) / 2), a4 = r5[o4], s5 = r5[o4 + 1], a4 <= e) {
    if (o4 === t || e < s5) return o4;
    i = o4 + 1;
  } else if (a4 > e) n4 = o4 - 1;
  else throw new Be$1("Input is not a number.");
  return 0;
}
H$3(Ys, "findStopLessThanOrEqualTo");
var Gs$1 = class Gs {
  constructor(e, t, i) {
    this.type = e, this.input = t, this.labels = [], this.outputs = [];
    for (let [n4, o4] of i) this.labels.push(n4), this.outputs.push(o4);
  }
  static parse(e, t) {
    if (e.length - 1 < 4) return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
    let i = t.parse(e[1], 1, j$1);
    if (!i) return null;
    let n4 = [], o4 = null;
    t.expectedType && t.expectedType.kind !== "value" && (o4 = t.expectedType);
    for (let a4 = 1; a4 < e.length; a4 += 2) {
      let s5 = a4 === 1 ? -1 / 0 : e[a4], u5 = e[a4 + 1], c = a4, p4 = a4 + 1;
      if (typeof s5 != "number") return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', c);
      if (n4.length && n4[n4.length - 1][0] >= s5) return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', c);
      let h = t.parse(u5, p4, o4);
      if (!h) return null;
      o4 = o4 || h.type, n4.push([s5, h]);
    }
    return new Gs(o4, i, n4);
  }
  evaluate(e) {
    let t = this.labels, i = this.outputs;
    if (t.length === 1) return i[0].evaluate(e);
    let n4 = this.input.evaluate(e);
    if (n4 <= t[0]) return i[0].evaluate(e);
    let o4 = t.length;
    if (n4 >= t[o4 - 1]) return i[o4 - 1].evaluate(e);
    let a4 = Ys(t, n4);
    return i[a4].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (let t of this.outputs) e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
H$3(Gs$1, "Step");
var Gi$1 = Gs$1;
function VP(r5) {
  return r5 && r5.__esModule && Object.prototype.hasOwnProperty.call(r5, "default") ? r5.default : r5;
}
H$3(VP, "getDefaultExportFromCjs");
var Rp$1, vb$1;
function UP() {
  if (vb$1) return Rp$1;
  vb$1 = 1, Rp$1 = r5;
  function r5(e, t, i, n4) {
    this.cx = 3 * e, this.bx = 3 * (i - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (n4 - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = i, this.p2y = n4;
  }
  return H$3(r5, "UnitBezier"), r5.prototype = { sampleCurveX: H$3(function(e) {
    return ((this.ax * e + this.bx) * e + this.cx) * e;
  }, "sampleCurveX"), sampleCurveY: H$3(function(e) {
    return ((this.ay * e + this.by) * e + this.cy) * e;
  }, "sampleCurveY"), sampleCurveDerivativeX: H$3(function(e) {
    return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
  }, "sampleCurveDerivativeX"), solveCurveX: H$3(function(e, t) {
    if (t === void 0 && (t = 1e-6), e < 0) return 0;
    if (e > 1) return 1;
    for (var i = e, n4 = 0; n4 < 8; n4++) {
      var o4 = this.sampleCurveX(i) - e;
      if (Math.abs(o4) < t) return i;
      var a4 = this.sampleCurveDerivativeX(i);
      if (Math.abs(a4) < 1e-6) break;
      i = i - o4 / a4;
    }
    var s5 = 0, u5 = 1;
    for (i = e, n4 = 0; n4 < 20 && (o4 = this.sampleCurveX(i), !(Math.abs(o4 - e) < t)); n4++) e > o4 ? s5 = i : u5 = i, i = (u5 - s5) * 0.5 + s5;
    return i;
  }, "solveCurveX"), solve: H$3(function(e, t) {
    return this.sampleCurveY(this.solveCurveX(e, t));
  }, "solve") }, Rp$1;
}
H$3(UP, "requireUnitbezier");
var NP = UP(), GP$1 = VP(NP);
function qP(r5) {
  return r5 === "rgb" || r5 === "hcl" || r5 === "lab";
}
H$3(qP, "isSupportedInterpolationColorSpace");
function Qr$1(r5, e, t) {
  return r5 + t * (e - r5);
}
H$3(Qr$1, "number");
function jP(r5, e, t, i = "rgb") {
  switch (i) {
    case "rgb": {
      let [n4, o4, a4, s5] = vs(r5.rgb, e.rgb, t);
      return new X$1(n4, o4, a4, s5, false);
    }
    case "hcl": {
      let [n4, o4, a4, s5] = r5.hcl, [u5, c, p4, h] = e.hcl, f, m5;
      if (!isNaN(n4) && !isNaN(u5)) {
        let w3 = u5 - n4;
        u5 > n4 && w3 > 180 ? w3 -= 360 : u5 < n4 && n4 - u5 > 180 && (w3 += 360), f = n4 + t * w3;
      } else isNaN(n4) ? isNaN(u5) ? f = NaN : (f = u5, (a4 === 1 || a4 === 0) && (m5 = c)) : (f = n4, (p4 === 1 || p4 === 0) && (m5 = o4));
      let [y4, g, x2, b] = DP([f, m5 != null ? m5 : Qr$1(o4, c, t), Qr$1(a4, p4, t), Qr$1(s5, h, t)]);
      return new X$1(y4, g, x2, b, false);
    }
    case "lab": {
      let [n4, o4, a4, s5] = Xb(vs(r5.lab, e.lab, t));
      return new X$1(n4, o4, a4, s5, false);
    }
  }
}
H$3(jP, "color");
function vs(r5, e, t) {
  return r5.map((i, n4) => Qr$1(i, e[n4], t));
}
H$3(vs, "array");
function ZP(r5, e, t) {
  return new Rt$1(vs(r5.values, e.values, t));
}
H$3(ZP, "padding");
function HP(r5, e, t) {
  let i = r5.values, n4 = e.values;
  if (i.length !== n4.length) throw new Be$1("Cannot interpolate values of different length. from: ".concat(r5.toString(), ", to: ").concat(e.toString()));
  let o4 = [];
  for (let a4 = 0; a4 < i.length; a4 += 2) {
    if (i[a4] !== n4[a4]) throw new Be$1("Cannot interpolate values containing mismatched anchors. from[".concat(a4, "]: ").concat(i[a4], ", to[").concat(a4, "]: ").concat(n4[a4]));
    o4.push(i[a4]);
    let [s5, u5] = i[a4 + 1], [c, p4] = n4[a4 + 1];
    o4.push([Qr$1(s5, c, t), Qr$1(u5, p4, t)]);
  }
  return new ir$1(o4);
}
H$3(HP, "variableAnchorOffsetCollection");
var Pe$2 = { number: Qr$1, color: jP, array: vs, padding: ZP, variableAnchorOffsetCollection: HP }, jn$2 = class jn {
  constructor(e, t, i, n4, o4) {
    this.type = e, this.operator = t, this.interpolation = i, this.input = n4, this.labels = [], this.outputs = [];
    for (let [a4, s5] of o4) this.labels.push(a4), this.outputs.push(s5);
  }
  static interpolationFactor(e, t, i, n4) {
    let o4 = 0;
    if (e.name === "exponential") o4 = Bp$1(t, e.base, i, n4);
    else if (e.name === "linear") o4 = Bp$1(t, 1, i, n4);
    else if (e.name === "cubic-bezier") {
      let a4 = e.controlPoints;
      o4 = new GP$1(a4[0], a4[1], a4[2], a4[3]).solve(Bp$1(t, 1, i, n4));
    }
    return o4;
  }
  static parse(e, t) {
    let [i, n4, o4, ...a4] = e;
    if (!Array.isArray(n4) || n4.length === 0) return t.error("Expected an interpolation type expression.", 1);
    if (n4[0] === "linear") n4 = { name: "linear" };
    else if (n4[0] === "exponential") {
      let c = n4[1];
      if (typeof c != "number") return t.error("Exponential interpolation requires a numeric base.", 1, 1);
      n4 = { name: "exponential", base: c };
    } else if (n4[0] === "cubic-bezier") {
      let c = n4.slice(1);
      if (c.length !== 4 || c.some((p4) => typeof p4 != "number" || p4 < 0 || p4 > 1)) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      n4 = { name: "cubic-bezier", controlPoints: c };
    } else return t.error("Unknown interpolation type ".concat(String(n4[0])), 1, 0);
    if (e.length - 1 < 4) return t.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
    if ((e.length - 1) % 2 !== 0) return t.error("Expected an even number of arguments.");
    if (o4 = t.parse(o4, 2, j$1), !o4) return null;
    let s5 = [], u5 = null;
    i === "interpolate-hcl" || i === "interpolate-lab" ? u5 = Ct$1 : t.expectedType && t.expectedType.kind !== "value" && (u5 = t.expectedType);
    for (let c = 0; c < a4.length; c += 2) {
      let p4 = a4[c], h = a4[c + 1], f = c + 3, m5 = c + 4;
      if (typeof p4 != "number") return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f);
      if (s5.length && s5[s5.length - 1][0] >= p4) return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f);
      let y4 = t.parse(h, m5, u5);
      if (!y4) return null;
      u5 = u5 || y4.type, s5.push([p4, y4]);
    }
    return !Rn(u5, j$1) && !Rn(u5, Ct$1) && !Rn(u5, Ks) && !Rn(u5, Js) && !Rn(u5, _t$1(j$1)) ? t.error("Type ".concat(Re$1(u5), " is not interpolatable.")) : new jn(u5, i, n4, o4, s5);
  }
  evaluate(e) {
    let t = this.labels, i = this.outputs;
    if (t.length === 1) return i[0].evaluate(e);
    let n4 = this.input.evaluate(e);
    if (n4 <= t[0]) return i[0].evaluate(e);
    let o4 = t.length;
    if (n4 >= t[o4 - 1]) return i[o4 - 1].evaluate(e);
    let a4 = Ys(t, n4), s5 = t[a4], u5 = t[a4 + 1], c = jn.interpolationFactor(this.interpolation, n4, s5, u5), p4 = i[a4].evaluate(e), h = i[a4 + 1].evaluate(e);
    switch (this.operator) {
      case "interpolate":
        return Pe$2[this.type.kind](p4, h, c);
      case "interpolate-hcl":
        return Pe$2.color(p4, h, c, "hcl");
      case "interpolate-lab":
        return Pe$2.color(p4, h, c, "lab");
    }
  }
  eachChild(e) {
    e(this.input);
    for (let t of this.outputs) e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
};
H$3(jn$2, "Interpolate");
var vt$1 = jn$2;
function Bp$1(r5, e, t, i) {
  let n4 = i - t, o4 = r5 - t;
  return n4 === 0 ? 0 : e === 1 ? o4 / n4 : (Math.pow(e, o4) - 1) / (Math.pow(e, n4) - 1);
}
H$3(Bp$1, "exponentialInterpolation");
var Zn = class Zn2 {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expected at least one argument.");
    let i = null, n4 = t.expectedType;
    n4 && n4.kind !== "value" && (i = n4);
    let o4 = [];
    for (let s5 of e.slice(1)) {
      let u5 = t.parse(s5, 1 + o4.length, i, void 0, { typeAnnotation: "omit" });
      if (!u5) return null;
      i = i || u5.type, o4.push(u5);
    }
    if (!i) throw new Error("No output type");
    return n4 && o4.some((s5) => Hn(n4, s5.type)) ? new Zn2(le$1, o4) : new Zn2(i, o4);
  }
  evaluate(e) {
    let t = null, i = 0, n4;
    for (let o4 of this.args) if (i++, t = o4.evaluate(e), t && t instanceof ft$1 && !t.available && (n4 || (n4 = t.name), t = null, i === this.args.length && (t = n4)), t !== null) break;
    return t;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
};
H$3(Zn, "Coalesce");
var ws$1 = Zn;
function wb$1(r5, e) {
  return r5 === "==" || r5 === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
H$3(wb$1, "isComparableType");
function $P(r5, e, t) {
  return e === t;
}
H$3($P, "eq");
function WP(r5, e, t) {
  return e !== t;
}
H$3(WP, "neq");
function XP(r5, e, t) {
  return e < t;
}
H$3(XP, "lt");
function KP(r5, e, t) {
  return e > t;
}
H$3(KP, "gt");
function JP(r5, e, t) {
  return e <= t;
}
H$3(JP, "lteq");
function YP(r5, e, t) {
  return e >= t;
}
H$3(YP, "gteq");
function Jb$1(r5, e, t, i) {
  return i.compare(e, t) === 0;
}
H$3(Jb$1, "eqCollate");
function QP(r5, e, t, i) {
  return !Jb$1(r5, e, t, i);
}
H$3(QP, "neqCollate");
function eT$1(r5, e, t, i) {
  return i.compare(e, t) < 0;
}
H$3(eT$1, "ltCollate");
function tT$1(r5, e, t, i) {
  return i.compare(e, t) > 0;
}
H$3(tT$1, "gtCollate");
function rT$1(r5, e, t, i) {
  return i.compare(e, t) <= 0;
}
H$3(rT$1, "lteqCollate");
function iT$1(r5, e, t, i) {
  return i.compare(e, t) >= 0;
}
H$3(iT$1, "gteqCollate");
function Hi$1(r5, e, t) {
  var n4;
  let i = r5 !== "==" && r5 !== "!=";
  return n4 = class {
    constructor(a4, s5, u5) {
      this.type = se$1, this.lhs = a4, this.rhs = s5, this.collator = u5, this.hasUntypedArgument = a4.type.kind === "value" || s5.type.kind === "value";
    }
    static parse(a4, s5) {
      if (a4.length !== 3 && a4.length !== 4) return s5.error("Expected two or three arguments.");
      let u5 = a4[0], c = s5.parse(a4[1], 1, le$1);
      if (!c) return null;
      if (!wb$1(u5, c.type)) return s5.concat(1).error('"'.concat(u5, `" comparisons are not supported for type '`).concat(Re$1(c.type), "'."));
      let p4 = s5.parse(a4[2], 2, le$1);
      if (!p4) return null;
      if (!wb$1(u5, p4.type)) return s5.concat(2).error('"'.concat(u5, `" comparisons are not supported for type '`).concat(Re$1(p4.type), "'."));
      if (c.type.kind !== p4.type.kind && c.type.kind !== "value" && p4.type.kind !== "value") return s5.error("Cannot compare types '".concat(Re$1(c.type), "' and '").concat(Re$1(p4.type), "'."));
      i && (c.type.kind === "value" && p4.type.kind !== "value" ? c = new Ft$2(p4.type, [c]) : c.type.kind !== "value" && p4.type.kind === "value" && (p4 = new Ft$2(c.type, [p4])));
      let h = null;
      if (a4.length === 4) {
        if (c.type.kind !== "string" && p4.type.kind !== "string" && c.type.kind !== "value" && p4.type.kind !== "value") return s5.error("Cannot use collator to compare non-string types.");
        if (h = s5.parse(a4[3], 3, Xs), !h) return null;
      }
      return new n4(c, p4, h);
    }
    evaluate(a4) {
      let s5 = this.lhs.evaluate(a4), u5 = this.rhs.evaluate(a4);
      if (i && this.hasUntypedArgument) {
        let c = He(s5), p4 = He(u5);
        if (c.kind !== p4.kind || !(c.kind === "string" || c.kind === "number")) throw new Be$1('Expected arguments for "'.concat(r5, '" to be (string, string) or (number, number), but found (').concat(c.kind, ", ").concat(p4.kind, ") instead."));
      }
      if (this.collator && !i && this.hasUntypedArgument) {
        let c = He(s5), p4 = He(u5);
        if (c.kind !== "string" || p4.kind !== "string") return e(a4, s5, u5);
      }
      return this.collator ? t(a4, s5, u5, this.collator.evaluate(a4)) : e(a4, s5, u5);
    }
    eachChild(a4) {
      a4(this.lhs), a4(this.rhs), this.collator && a4(this.collator);
    }
    outputDefined() {
      return true;
    }
  }, H$3(n4, "Comparison"), n4;
}
H$3(Hi$1, "makeComparison");
var nT$1 = Hi$1("==", $P, Jb$1), oT$1 = Hi$1("!=", WP, QP), aT$1 = Hi$1("<", XP, eT$1), sT$1 = Hi$1(">", KP, tT$1), lT$1 = Hi$1("<=", JP, rT$1), uT$1 = Hi$1(">=", YP, iT$1), qs = class qs2 {
  constructor(e, t, i) {
    this.type = Xs, this.locale = i, this.caseSensitive = e, this.diacriticSensitive = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("Expected one argument.");
    let i = e[1];
    if (typeof i != "object" || Array.isArray(i)) return t.error("Collator options argument must be an object.");
    let n4 = t.parse(i["case-sensitive"] === void 0 ? false : i["case-sensitive"], 1, se$1);
    if (!n4) return null;
    let o4 = t.parse(i["diacritic-sensitive"] === void 0 ? false : i["diacritic-sensitive"], 1, se$1);
    if (!o4) return null;
    let a4 = null;
    return i.locale && (a4 = t.parse(i.locale, 1, pe$2), !a4) ? null : new qs2(n4, o4, a4);
  }
  evaluate(e) {
    return new $n(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return false;
  }
};
H$3(qs, "CollatorExpression");
var Ss = qs, js$1 = class js {
  constructor(e, t, i, n4, o4) {
    this.type = pe$2, this.number = e, this.locale = t, this.currency = i, this.minFractionDigits = n4, this.maxFractionDigits = o4;
  }
  static parse(e, t) {
    if (e.length !== 3) return t.error("Expected two arguments.");
    let i = t.parse(e[1], 1, j$1);
    if (!i) return null;
    let n4 = e[2];
    if (typeof n4 != "object" || Array.isArray(n4)) return t.error("NumberFormat options argument must be an object.");
    let o4 = null;
    if (n4.locale && (o4 = t.parse(n4.locale, 1, pe$2), !o4)) return null;
    let a4 = null;
    if (n4.currency && (a4 = t.parse(n4.currency, 1, pe$2), !a4)) return null;
    let s5 = null;
    if (n4["min-fraction-digits"] && (s5 = t.parse(n4["min-fraction-digits"], 1, j$1), !s5)) return null;
    let u5 = null;
    return n4["max-fraction-digits"] && (u5 = t.parse(n4["max-fraction-digits"], 1, j$1), !u5) ? null : new js(i, o4, a4, s5, u5);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return false;
  }
};
H$3(js$1, "NumberFormat");
var Wp$1 = js$1, Zs = class Zs2 {
  constructor(e) {
    this.type = Zi$1, this.sections = e;
  }
  static parse(e, t) {
    if (e.length < 2) return t.error("Expected at least one argument.");
    let i = e[1];
    if (!Array.isArray(i) && typeof i == "object") return t.error("First argument must be an image or text section.");
    let n4 = [], o4 = false;
    for (let a4 = 1; a4 <= e.length - 1; ++a4) {
      let s5 = e[a4];
      if (o4 && typeof s5 == "object" && !Array.isArray(s5)) {
        o4 = false;
        let u5 = null;
        if (s5["font-scale"] && (u5 = t.parse(s5["font-scale"], 1, j$1), !u5)) return null;
        let c = null;
        if (s5["text-font"] && (c = t.parse(s5["text-font"], 1, _t$1(pe$2)), !c)) return null;
        let p4 = null;
        if (s5["text-color"] && (p4 = t.parse(s5["text-color"], 1, Ct$1), !p4)) return null;
        let h = n4[n4.length - 1];
        h.scale = u5, h.font = c, h.textColor = p4;
      } else {
        let u5 = t.parse(e[a4], 1, le$1);
        if (!u5) return null;
        let c = u5.type.kind;
        if (c !== "string" && c !== "value" && c !== "null" && c !== "resolvedImage") return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        o4 = true, n4.push({ content: u5, scale: null, font: null, textColor: null });
      }
    }
    return new Zs2(n4);
  }
  evaluate(e) {
    let t = H$3((i) => {
      let n4 = i.content.evaluate(e);
      return He(n4) === no ? new Wn("", n4, null, null, null) : new Wn(On$1(n4), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null);
    }, "evaluateSection");
    return new wt$1(this.sections.map(t));
  }
  eachChild(e) {
    for (let t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor);
  }
  outputDefined() {
    return false;
  }
};
H$3(Zs, "FormatExpression");
var Kn = Zs, Hs = class Hs2 {
  constructor(e) {
    this.type = no, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("Expected two arguments.");
    let i = t.parse(e[1], 1, pe$2);
    return i ? new Hs2(i) : t.error("No image name provided.");
  }
  evaluate(e) {
    let t = this.input.evaluate(e), i = ft$1.fromString(t);
    return i && e.availableImages && (i.available = e.availableImages.indexOf(t) > -1), i;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
H$3(Hs, "ImageExpression");
var Xp$1 = Hs, $s = class $s2 {
  constructor(e) {
    this.type = j$1, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("Expected 1 argument, but found ".concat(e.length - 1, " instead."));
    let i = t.parse(e[1], 1);
    return i ? i.type.kind !== "array" && i.type.kind !== "string" && i.type.kind !== "value" ? t.error("Expected argument of type string or array, but found ".concat(Re$1(i.type), " instead.")) : new $s2(i) : null;
  }
  evaluate(e) {
    let t = this.input.evaluate(e);
    if (typeof t == "string") return [...t].length;
    if (Array.isArray(t)) return t.length;
    throw new Be$1("Expected value to be of type string or array, but found ".concat(Re$1(He(t)), " instead."));
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return false;
  }
};
H$3($s, "Length");
var Kp$1 = $s, Ut$1 = 8192;
function cT$1(r5, e) {
  let t = pT$1(r5[0]), i = fT$1(r5[1]), n4 = Math.pow(2, e.z);
  return [Math.round(t * n4 * Ut$1), Math.round(i * n4 * Ut$1)];
}
H$3(cT$1, "getTileCoordinates");
function oh$1(r5, e) {
  let t = Math.pow(2, e.z), i = (r5[0] / Ut$1 + e.x) / t, n4 = (r5[1] / Ut$1 + e.y) / t;
  return [hT$1(i), mT$1(n4)];
}
H$3(oh$1, "getLngLatFromTileCoord");
function pT$1(r5) {
  return (180 + r5) / 360;
}
H$3(pT$1, "mercatorXfromLng");
function hT$1(r5) {
  return r5 * 360 - 180;
}
H$3(hT$1, "lngFromMercatorXfromLng");
function fT$1(r5) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r5 * Math.PI / 360))) / 360;
}
H$3(fT$1, "mercatorYfromLat");
function mT$1(r5) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - r5 * 360) * Math.PI / 180)) - 90;
}
H$3(mT$1, "latFromMercatorY");
function oo(r5, e) {
  r5[0] = Math.min(r5[0], e[0]), r5[1] = Math.min(r5[1], e[1]), r5[2] = Math.max(r5[2], e[0]), r5[3] = Math.max(r5[3], e[1]);
}
H$3(oo, "updateBBox");
function Jn(r5, e) {
  return !(r5[0] <= e[0] || r5[2] >= e[2] || r5[1] <= e[1] || r5[3] >= e[3]);
}
H$3(Jn, "boxWithinBox");
function dT$1(r5, e, t) {
  return e[1] > r5[1] != t[1] > r5[1] && r5[0] < (t[0] - e[0]) * (r5[1] - e[1]) / (t[1] - e[1]) + e[0];
}
H$3(dT$1, "rayIntersect");
function yT$1(r5, e, t) {
  let i = r5[0] - e[0], n4 = r5[1] - e[1], o4 = r5[0] - t[0], a4 = r5[1] - t[1];
  return i * a4 - o4 * n4 === 0 && i * o4 <= 0 && n4 * a4 <= 0;
}
H$3(yT$1, "pointOnBoundary");
function Qs(r5, e, t, i) {
  let n4 = [e[0] - r5[0], e[1] - r5[1]], o4 = [i[0] - t[0], i[1] - t[1]];
  return _T$1(o4, n4) === 0 ? false : !!(Sb$1(r5, e, t, i) && Sb$1(t, i, r5, e));
}
H$3(Qs, "segmentIntersectSegment");
function gT$1(r5, e, t) {
  for (let i of t) for (let n4 = 0; n4 < i.length - 1; ++n4) if (Qs(r5, e, i[n4], i[n4 + 1])) return true;
  return false;
}
H$3(gT$1, "lineIntersectPolygon");
function $i(r5, e, t = false) {
  let i = false;
  for (let n4 of e) for (let o4 = 0; o4 < n4.length - 1; o4++) {
    if (yT$1(r5, n4[o4], n4[o4 + 1])) return t;
    dT$1(r5, n4[o4], n4[o4 + 1]) && (i = !i);
  }
  return i;
}
H$3($i, "pointWithinPolygon");
function xT$1(r5, e) {
  for (let t of e) if ($i(r5, t)) return true;
  return false;
}
H$3(xT$1, "pointWithinPolygons");
function Yb(r5, e) {
  for (let t of r5) if (!$i(t, e)) return false;
  for (let t = 0; t < r5.length - 1; ++t) if (gT$1(r5[t], r5[t + 1], e)) return false;
  return true;
}
H$3(Yb, "lineStringWithinPolygon");
function bT$1(r5, e) {
  for (let t of e) if (Yb(r5, t)) return true;
  return false;
}
H$3(bT$1, "lineStringWithinPolygons");
function _T$1(r5, e) {
  return r5[0] * e[1] - r5[1] * e[0];
}
H$3(_T$1, "perp");
function Sb$1(r5, e, t, i) {
  let n4 = r5[0] - t[0], o4 = r5[1] - t[1], a4 = e[0] - t[0], s5 = e[1] - t[1], u5 = i[0] - t[0], c = i[1] - t[1], p4 = n4 * c - u5 * o4, h = a4 * c - u5 * s5;
  return p4 > 0 && h < 0 || p4 < 0 && h > 0;
}
H$3(Sb$1, "twoSided");
function ah$1(r5, e, t) {
  let i = [];
  for (let n4 = 0; n4 < r5.length; n4++) {
    let o4 = [];
    for (let a4 = 0; a4 < r5[n4].length; a4++) {
      let s5 = cT$1(r5[n4][a4], t);
      oo(e, s5), o4.push(s5);
    }
    i.push(o4);
  }
  return i;
}
H$3(ah$1, "getTilePolygon");
function Qb$1(r5, e, t) {
  let i = [];
  for (let n4 = 0; n4 < r5.length; n4++) {
    let o4 = ah$1(r5[n4], e, t);
    i.push(o4);
  }
  return i;
}
H$3(Qb$1, "getTilePolygons");
function e_(r5, e, t, i) {
  if (r5[0] < t[0] || r5[0] > t[2]) {
    let n4 = i * 0.5, o4 = r5[0] - t[0] > n4 ? -i : t[0] - r5[0] > n4 ? i : 0;
    o4 === 0 && (o4 = r5[0] - t[2] > n4 ? -i : t[2] - r5[0] > n4 ? i : 0), r5[0] += o4;
  }
  oo(e, r5);
}
H$3(e_, "updatePoint");
function vT$1(r5) {
  r5[0] = r5[1] = 1 / 0, r5[2] = r5[3] = -1 / 0;
}
H$3(vT$1, "resetBBox");
function Pb$1(r5, e, t, i) {
  let n4 = Math.pow(2, i.z) * Ut$1, o4 = [i.x * Ut$1, i.y * Ut$1], a4 = [];
  for (let s5 of r5) for (let u5 of s5) {
    let c = [u5.x + o4[0], u5.y + o4[1]];
    e_(c, e, t, n4), a4.push(c);
  }
  return a4;
}
H$3(Pb$1, "getTilePoints");
function Tb$1(r5, e, t, i) {
  let n4 = Math.pow(2, i.z) * Ut$1, o4 = [i.x * Ut$1, i.y * Ut$1], a4 = [];
  for (let s5 of r5) {
    let u5 = [];
    for (let c of s5) {
      let p4 = [c.x + o4[0], c.y + o4[1]];
      oo(e, p4), u5.push(p4);
    }
    a4.push(u5);
  }
  if (e[2] - e[0] <= n4 / 2) {
    vT$1(e);
    for (let s5 of a4) for (let u5 of s5) e_(u5, e, t, n4);
  }
  return a4;
}
H$3(Tb$1, "getTileLines");
function wT$1(r5, e) {
  let t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n4 = r5.canonicalID();
  if (e.type === "Polygon") {
    let o4 = ah$1(e.coordinates, i, n4), a4 = Pb$1(r5.geometry(), t, i, n4);
    if (!Jn(t, i)) return false;
    for (let s5 of a4) if (!$i(s5, o4)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o4 = Qb$1(e.coordinates, i, n4), a4 = Pb$1(r5.geometry(), t, i, n4);
    if (!Jn(t, i)) return false;
    for (let s5 of a4) if (!xT$1(s5, o4)) return false;
  }
  return true;
}
H$3(wT$1, "pointsWithinPolygons");
function ST$1(r5, e) {
  let t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n4 = r5.canonicalID();
  if (e.type === "Polygon") {
    let o4 = ah$1(e.coordinates, i, n4), a4 = Tb$1(r5.geometry(), t, i, n4);
    if (!Jn(t, i)) return false;
    for (let s5 of a4) if (!Yb(s5, o4)) return false;
  }
  if (e.type === "MultiPolygon") {
    let o4 = Qb$1(e.coordinates, i, n4), a4 = Tb$1(r5.geometry(), t, i, n4);
    if (!Jn(t, i)) return false;
    for (let s5 of a4) if (!bT$1(s5, o4)) return false;
  }
  return true;
}
H$3(ST$1, "linesWithinPolygons");
var Bi2 = class Bi3 {
  constructor(e, t) {
    this.type = se$1, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("'within' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (Xn(e[1])) {
      let i = e[1];
      if (i.type === "FeatureCollection") {
        let n4 = [];
        for (let o4 of i.features) {
          let { type: a4, coordinates: s5 } = o4.geometry;
          a4 === "Polygon" && n4.push(s5), a4 === "MultiPolygon" && n4.push(...s5);
        }
        if (n4.length) {
          let o4 = { type: "MultiPolygon", coordinates: n4 };
          return new Bi3(i, o4);
        }
      } else if (i.type === "Feature") {
        let n4 = i.geometry.type;
        if (n4 === "Polygon" || n4 === "MultiPolygon") return new Bi3(i, i.geometry);
      } else if (i.type === "Polygon" || i.type === "MultiPolygon") return new Bi3(i, i);
    }
    return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return wT$1(e, this.geometries);
      if (e.geometryType() === "LineString") return ST$1(e, this.geometries);
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
H$3(Bi2, "Within");
var Yn = Bi2, vh$1 = class vh2 {
  constructor(e = [], t = (i, n4) => i < n4 ? -1 : i > n4 ? 1 : 0) {
    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
  }
  push(e) {
    this.data.push(e), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    let e = this.data[0], t = this.data.pop();
    return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    let { data: t, compare: i } = this, n4 = t[e];
    for (; e > 0; ) {
      let o4 = e - 1 >> 1, a4 = t[o4];
      if (i(n4, a4) >= 0) break;
      t[e] = a4, e = o4;
    }
    t[e] = n4;
  }
  _down(e) {
    let { data: t, compare: i } = this, n4 = this.length >> 1, o4 = t[e];
    for (; e < n4; ) {
      let a4 = (e << 1) + 1, s5 = a4 + 1;
      if (s5 < this.length && i(t[s5], t[a4]) < 0 && (a4 = s5), i(t[a4], o4) >= 0) break;
      t[e] = t[a4], e = a4;
    }
    t[e] = o4;
  }
};
H$3(vh$1, "TinyQueue");
var Ps$1 = vh$1;
function PT$1(r5, e, t, i, n4) {
  t_(r5, e, t, i || r5.length - 1, n4 || TT$1);
}
H$3(PT$1, "quickselect");
function t_(r5, e, t, i, n4) {
  for (; i > t; ) {
    if (i - t > 600) {
      var o4 = i - t + 1, a4 = e - t + 1, s5 = Math.log(o4), u5 = 0.5 * Math.exp(2 * s5 / 3), c = 0.5 * Math.sqrt(s5 * u5 * (o4 - u5) / o4) * (a4 - o4 / 2 < 0 ? -1 : 1), p4 = Math.max(t, Math.floor(e - a4 * u5 / o4 + c)), h = Math.min(i, Math.floor(e + (o4 - a4) * u5 / o4 + c));
      t_(r5, e, p4, h, n4);
    }
    var f = r5[e], m5 = t, y4 = i;
    for (Bn$1(r5, t, e), n4(r5[i], f) > 0 && Bn$1(r5, t, i); m5 < y4; ) {
      for (Bn$1(r5, m5, y4), m5++, y4--; n4(r5[m5], f) < 0; ) m5++;
      for (; n4(r5[y4], f) > 0; ) y4--;
    }
    n4(r5[t], f) === 0 ? Bn$1(r5, t, y4) : (y4++, Bn$1(r5, y4, i)), y4 <= e && (t = y4 + 1), e <= y4 && (i = y4 - 1);
  }
}
H$3(t_, "quickselectStep");
function Bn$1(r5, e, t) {
  var i = r5[e];
  r5[e] = r5[t], r5[t] = i;
}
H$3(Bn$1, "swap");
function TT$1(r5, e) {
  return r5 < e ? -1 : r5 > e ? 1 : 0;
}
H$3(TT$1, "defaultCompare");
function MT$1(r5, e) {
  if (r5.length <= 1) return [r5];
  let i = [], n4, o4;
  for (let a4 of r5) {
    let s5 = IT$1(a4);
    s5 !== 0 && (a4.area = Math.abs(s5), o4 === void 0 && (o4 = s5 < 0), o4 === s5 < 0 ? (n4 && i.push(n4), n4 = [a4]) : n4.push(a4));
  }
  if (n4 && i.push(n4), e > 1) for (let a4 = 0; a4 < i.length; a4++) i[a4].length <= e || (PT$1(i[a4], e, 1, i[a4].length - 1, AT$1), i[a4] = i[a4].slice(0, e));
  return i;
}
H$3(MT$1, "classifyRings");
function AT$1(r5, e) {
  return e.area - r5.area;
}
H$3(AT$1, "compareAreas");
function IT$1(r5) {
  let e = 0;
  for (let t = 0, i = r5.length, n4 = i - 1, o4, a4; t < i; n4 = t++) o4 = r5[t], a4 = r5[n4], e += (a4.x - o4.x) * (o4.y + a4.y);
  return e;
}
H$3(IT$1, "calculateSignedArea");
var CT$1 = 6378.137, Mb$1 = 1 / 298.257223563, Ab = Mb$1 * (2 - Mb$1), Ib$1 = Math.PI / 180, wh$1 = class wh2 {
  constructor(e) {
    let t = Ib$1 * CT$1 * 1e3, i = Math.cos(e * Ib$1), n4 = 1 / (1 - Ab * (1 - i * i)), o4 = Math.sqrt(n4);
    this.kx = t * o4 * i, this.ky = t * o4 * n4 * (1 - Ab);
  }
  distance(e, t) {
    let i = this.wrap(e[0] - t[0]) * this.kx, n4 = (e[1] - t[1]) * this.ky;
    return Math.sqrt(i * i + n4 * n4);
  }
  pointOnLine(e, t) {
    let i = 1 / 0, n4, o4, a4, s5;
    for (let u5 = 0; u5 < e.length - 1; u5++) {
      let c = e[u5][0], p4 = e[u5][1], h = this.wrap(e[u5 + 1][0] - c) * this.kx, f = (e[u5 + 1][1] - p4) * this.ky, m5 = 0;
      (h !== 0 || f !== 0) && (m5 = (this.wrap(t[0] - c) * this.kx * h + (t[1] - p4) * this.ky * f) / (h * h + f * f), m5 > 1 ? (c = e[u5 + 1][0], p4 = e[u5 + 1][1]) : m5 > 0 && (c += h / this.kx * m5, p4 += f / this.ky * m5)), h = this.wrap(t[0] - c) * this.kx, f = (t[1] - p4) * this.ky;
      let y4 = h * h + f * f;
      y4 < i && (i = y4, n4 = c, o4 = p4, a4 = u5, s5 = m5);
    }
    return { point: [n4, o4], index: a4, t: Math.max(0, Math.min(1, s5)) };
  }
  wrap(e) {
    for (; e < -180; ) e += 360;
    for (; e > 180; ) e -= 360;
    return e;
  }
};
H$3(wh$1, "CheapRuler");
var Qn$1 = wh$1, Jp$1 = 100, Yp$1 = 50;
function r_(r5, e) {
  return e[0] - r5[0];
}
H$3(r_, "compareDistPair");
function Ts$1(r5) {
  return r5[1] - r5[0] + 1;
}
H$3(Ts$1, "getRangeSize");
function nr$1(r5, e) {
  return r5[1] >= r5[0] && r5[1] < e;
}
H$3(nr$1, "isRangeSafe");
function Qp$1(r5, e) {
  if (r5[0] > r5[1]) return [null, null];
  let t = Ts$1(r5);
  if (e) {
    if (t === 2) return [r5, null];
    let n4 = Math.floor(t / 2);
    return [[r5[0], r5[0] + n4], [r5[0] + n4, r5[1]]];
  }
  if (t === 1) return [r5, null];
  let i = Math.floor(t / 2) - 1;
  return [[r5[0], r5[0] + i], [r5[0] + i + 1, r5[1]]];
}
H$3(Qp$1, "splitRange");
function eh$1(r5, e) {
  if (!nr$1(e, r5.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  let t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let i = e[0]; i <= e[1]; ++i) oo(t, r5[i]);
  return t;
}
H$3(eh$1, "getBBox");
function th$1(r5) {
  let e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let t of r5) for (let i of t) oo(e, i);
  return e;
}
H$3(th$1, "getPolygonBBox");
function Cb$1(r5) {
  return r5[0] !== -1 / 0 && r5[1] !== -1 / 0 && r5[2] !== 1 / 0 && r5[3] !== 1 / 0;
}
H$3(Cb$1, "isValidBBox");
function sh$1(r5, e, t) {
  if (!Cb$1(r5) || !Cb$1(e)) return NaN;
  let i = 0, n4 = 0;
  return r5[2] < e[0] && (i = e[0] - r5[2]), r5[0] > e[2] && (i = r5[0] - e[2]), r5[1] > e[3] && (n4 = r5[1] - e[3]), r5[3] < e[1] && (n4 = e[1] - r5[3]), t.distance([0, 0], [i, n4]);
}
H$3(sh$1, "bboxToBBoxDistance");
function Jr$1(r5, e, t) {
  let i = t.pointOnLine(e, r5);
  return t.distance(r5, i.point);
}
H$3(Jr$1, "pointToLineDistance");
function lh$1(r5, e, t, i, n4) {
  let o4 = Math.min(Jr$1(r5, [t, i], n4), Jr$1(e, [t, i], n4)), a4 = Math.min(Jr$1(t, [r5, e], n4), Jr$1(i, [r5, e], n4));
  return Math.min(o4, a4);
}
H$3(lh$1, "segmentToSegmentDistance");
function ET$1(r5, e, t, i, n4) {
  if (!(nr$1(e, r5.length) && nr$1(i, t.length))) return 1 / 0;
  let a4 = 1 / 0;
  for (let s5 = e[0]; s5 < e[1]; ++s5) {
    let u5 = r5[s5], c = r5[s5 + 1];
    for (let p4 = i[0]; p4 < i[1]; ++p4) {
      let h = t[p4], f = t[p4 + 1];
      if (Qs(u5, c, h, f)) return 0;
      a4 = Math.min(a4, lh$1(u5, c, h, f, n4));
    }
  }
  return a4;
}
H$3(ET$1, "lineToLineDistance");
function kT$1(r5, e, t, i, n4) {
  if (!(nr$1(e, r5.length) && nr$1(i, t.length))) return NaN;
  let a4 = 1 / 0;
  for (let s5 = e[0]; s5 <= e[1]; ++s5) for (let u5 = i[0]; u5 <= i[1]; ++u5) if (a4 = Math.min(a4, n4.distance(r5[s5], t[u5])), a4 === 0) return a4;
  return a4;
}
H$3(kT$1, "pointsToPointsDistance");
function LT$1(r5, e, t) {
  if ($i(r5, e, true)) return 0;
  let i = 1 / 0;
  for (let n4 of e) {
    let o4 = n4[0], a4 = n4[n4.length - 1];
    if (o4 !== a4 && (i = Math.min(i, Jr$1(r5, [a4, o4], t)), i === 0)) return i;
    let s5 = t.pointOnLine(n4, r5);
    if (i = Math.min(i, t.distance(r5, s5.point)), i === 0) return i;
  }
  return i;
}
H$3(LT$1, "pointToPolygonDistance");
function DT$1(r5, e, t, i) {
  if (!nr$1(e, r5.length)) return NaN;
  for (let o4 = e[0]; o4 <= e[1]; ++o4) if ($i(r5[o4], t, true)) return 0;
  let n4 = 1 / 0;
  for (let o4 = e[0]; o4 < e[1]; ++o4) {
    let a4 = r5[o4], s5 = r5[o4 + 1];
    for (let u5 of t) for (let c = 0, p4 = u5.length, h = p4 - 1; c < p4; h = c++) {
      let f = u5[h], m5 = u5[c];
      if (Qs(a4, s5, f, m5)) return 0;
      n4 = Math.min(n4, lh$1(a4, s5, f, m5, i));
    }
  }
  return n4;
}
H$3(DT$1, "lineToPolygonDistance");
function Eb$1(r5, e) {
  for (let t of r5) for (let i of t) if ($i(i, e, true)) return true;
  return false;
}
H$3(Eb$1, "polygonIntersect");
function zT$1(r5, e, t, i = 1 / 0) {
  let n4 = th$1(r5), o4 = th$1(e);
  if (i !== 1 / 0 && sh$1(n4, o4, t) >= i) return i;
  if (Jn(n4, o4)) {
    if (Eb$1(r5, e)) return 0;
  } else if (Eb$1(e, r5)) return 0;
  let a4 = 1 / 0;
  for (let s5 of r5) for (let u5 = 0, c = s5.length, p4 = c - 1; u5 < c; p4 = u5++) {
    let h = s5[p4], f = s5[u5];
    for (let m5 of e) for (let y4 = 0, g = m5.length, x2 = g - 1; y4 < g; x2 = y4++) {
      let b = m5[x2], w3 = m5[y4];
      if (Qs(h, f, b, w3)) return 0;
      a4 = Math.min(a4, lh$1(h, f, b, w3, t));
    }
  }
  return a4;
}
H$3(zT$1, "polygonToPolygonDistance");
function kb(r5, e, t, i, n4, o4) {
  if (!o4) return;
  let a4 = sh$1(eh$1(i, o4), n4, t);
  a4 < e && r5.push([a4, o4, [0, 0]]);
}
H$3(kb, "updateQueue");
function ms(r5, e, t, i, n4, o4, a4) {
  if (!o4 || !a4) return;
  let s5 = sh$1(eh$1(i, o4), eh$1(n4, a4), t);
  s5 < e && r5.push([s5, o4, a4]);
}
H$3(ms, "updateQueueTwoSets");
function Ms(r5, e, t, i, n4 = 1 / 0) {
  let o4 = Math.min(i.distance(r5[0], t[0][0]), n4);
  if (o4 === 0) return o4;
  let a4 = new Ps$1([[0, [0, r5.length - 1], [0, 0]]], r_), s5 = th$1(t);
  for (; a4.length > 0; ) {
    let u5 = a4.pop();
    if (u5[0] >= o4) continue;
    let c = u5[1], p4 = e ? Yp$1 : Jp$1;
    if (Ts$1(c) <= p4) {
      if (!nr$1(c, r5.length)) return NaN;
      if (e) {
        let h = DT$1(r5, c, t, i);
        if (isNaN(h) || h === 0) return h;
        o4 = Math.min(o4, h);
      } else for (let h = c[0]; h <= c[1]; ++h) {
        let f = LT$1(r5[h], t, i);
        if (o4 = Math.min(o4, f), o4 === 0) return 0;
      }
    } else {
      let h = Qp$1(c, e);
      kb(a4, o4, i, r5, s5, h[0]), kb(a4, o4, i, r5, s5, h[1]);
    }
  }
  return o4;
}
H$3(Ms, "pointsToPolygonDistance");
function As$1(r5, e, t, i, n4, o4 = 1 / 0) {
  let a4 = Math.min(o4, n4.distance(r5[0], t[0]));
  if (a4 === 0) return a4;
  let s5 = new Ps$1([[0, [0, r5.length - 1], [0, t.length - 1]]], r_);
  for (; s5.length > 0; ) {
    let u5 = s5.pop();
    if (u5[0] >= a4) continue;
    let c = u5[1], p4 = u5[2], h = e ? Yp$1 : Jp$1, f = i ? Yp$1 : Jp$1;
    if (Ts$1(c) <= h && Ts$1(p4) <= f) {
      if (!nr$1(c, r5.length) && nr$1(p4, t.length)) return NaN;
      let m5;
      if (e && i) m5 = ET$1(r5, c, t, p4, n4), a4 = Math.min(a4, m5);
      else if (e && !i) {
        let y4 = r5.slice(c[0], c[1] + 1);
        for (let g = p4[0]; g <= p4[1]; ++g) if (m5 = Jr$1(t[g], y4, n4), a4 = Math.min(a4, m5), a4 === 0) return a4;
      } else if (!e && i) {
        let y4 = t.slice(p4[0], p4[1] + 1);
        for (let g = c[0]; g <= c[1]; ++g) if (m5 = Jr$1(r5[g], y4, n4), a4 = Math.min(a4, m5), a4 === 0) return a4;
      } else m5 = kT$1(r5, c, t, p4, n4), a4 = Math.min(a4, m5);
    } else {
      let m5 = Qp$1(c, e), y4 = Qp$1(p4, i);
      ms(s5, a4, n4, r5, t, m5[0], y4[0]), ms(s5, a4, n4, r5, t, m5[0], y4[1]), ms(s5, a4, n4, r5, t, m5[1], y4[0]), ms(s5, a4, n4, r5, t, m5[1], y4[1]);
    }
  }
  return a4;
}
H$3(As$1, "pointSetToPointSetDistance");
function FT$1(r5, e) {
  let t = r5.geometry(), i = t.flat().map((a4) => oh$1([a4.x, a4.y], r5.canonical));
  if (t.length === 0) return NaN;
  let n4 = new Qn$1(i[0][1]), o4 = 1 / 0;
  for (let a4 of e) {
    switch (a4.type) {
      case "Point":
        o4 = Math.min(o4, As$1(i, false, [a4.coordinates], false, n4, o4));
        break;
      case "LineString":
        o4 = Math.min(o4, As$1(i, false, a4.coordinates, true, n4, o4));
        break;
      case "Polygon":
        o4 = Math.min(o4, Ms(i, false, a4.coordinates, n4, o4));
        break;
    }
    if (o4 === 0) return o4;
  }
  return o4;
}
H$3(FT$1, "pointToGeometryDistance");
function RT$1(r5, e) {
  let t = r5.geometry(), i = t.flat().map((a4) => oh$1([a4.x, a4.y], r5.canonical));
  if (t.length === 0) return NaN;
  let n4 = new Qn$1(i[0][1]), o4 = 1 / 0;
  for (let a4 of e) {
    switch (a4.type) {
      case "Point":
        o4 = Math.min(o4, As$1(i, true, [a4.coordinates], false, n4, o4));
        break;
      case "LineString":
        o4 = Math.min(o4, As$1(i, true, a4.coordinates, true, n4, o4));
        break;
      case "Polygon":
        o4 = Math.min(o4, Ms(i, true, a4.coordinates, n4, o4));
        break;
    }
    if (o4 === 0) return o4;
  }
  return o4;
}
H$3(RT$1, "lineStringToGeometryDistance");
function BT$1(r5, e) {
  let t = r5.geometry();
  if (t.length === 0 || t[0].length === 0) return NaN;
  let i = MT$1(t, 0).map((a4) => a4.map((s5) => s5.map((u5) => oh$1([u5.x, u5.y], r5.canonical)))), n4 = new Qn$1(i[0][0][0][1]), o4 = 1 / 0;
  for (let a4 of e) for (let s5 of i) {
    switch (a4.type) {
      case "Point":
        o4 = Math.min(o4, Ms([a4.coordinates], false, s5, n4, o4));
        break;
      case "LineString":
        o4 = Math.min(o4, Ms(a4.coordinates, true, s5, n4, o4));
        break;
      case "Polygon":
        o4 = Math.min(o4, zT$1(s5, a4.coordinates, n4, o4));
        break;
    }
    if (o4 === 0) return o4;
  }
  return o4;
}
H$3(BT$1, "polygonToGeometryDistance");
function Op$1(r5) {
  return r5.type === "MultiPolygon" ? r5.coordinates.map((e) => ({ type: "Polygon", coordinates: e })) : r5.type === "MultiLineString" ? r5.coordinates.map((e) => ({ type: "LineString", coordinates: e })) : r5.type === "MultiPoint" ? r5.coordinates.map((e) => ({ type: "Point", coordinates: e })) : [r5];
}
H$3(Op$1, "toSimpleGeometry");
var Oi$2 = class Oi {
  constructor(e, t) {
    this.type = j$1, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2) return t.error("'distance' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
    if (Xn(e[1])) {
      let i = e[1];
      if (i.type === "FeatureCollection") return new Oi(i, i.features.map((n4) => Op$1(n4.geometry)).flat());
      if (i.type === "Feature") return new Oi(i, Op$1(i.geometry));
      if ("type" in i && "coordinates" in i) return new Oi(i, Op$1(i));
    }
    return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point") return FT$1(e, this.geometries);
      if (e.geometryType() === "LineString") return RT$1(e, this.geometries);
      if (e.geometryType() === "Polygon") return BT$1(e, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
H$3(Oi$2, "Distance");
var eo = Oi$2, ii = { "==": nT$1, "!=": oT$1, ">": sT$1, "<": aT$1, ">=": uT$1, "<=": lT$1, array: Ft$2, at: Gp$1, boolean: Ft$2, case: Hp$1, coalesce: ws$1, collator: Ss, format: Kn, image: Xp$1, in: qp$1, "index-of": jp$1, interpolate: vt$1, "interpolate-hcl": vt$1, "interpolate-lab": vt$1, length: Kp$1, let: bs, literal: br, match: Zp$1, number: Ft$2, "number-format": Wp$1, object: Ft$2, slice: $p$1, step: Gi$1, string: Ft$2, "to-boolean": xr, "to-color": xr, "to-number": xr, "to-string": xr, var: _s, within: Yn, distance: eo }, Kr$1 = class Kr {
  constructor(e, t, i, n4) {
    this.name = e, this.type = t, this._evaluate = i, this.args = n4;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return false;
  }
  static parse(e, t) {
    let i = e[0], n4 = Kr.definitions[i];
    if (!n4) return t.error('Unknown expression "'.concat(i, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    let o4 = Array.isArray(n4) ? n4[0] : n4.type, a4 = Array.isArray(n4) ? [[n4[1], n4[2]]] : n4.overloads, s5 = a4.filter(([c]) => !Array.isArray(c) || c.length === e.length - 1), u5 = null;
    for (let [c, p4] of s5) {
      u5 = new xs(t.registry, Is, t.path, null, t.scope);
      let h = [], f = false;
      for (let m5 = 1; m5 < e.length; m5++) {
        let y4 = e[m5], g = Array.isArray(c) ? c[m5 - 1] : c.type, x2 = u5.parse(y4, 1 + h.length, g);
        if (!x2) {
          f = true;
          break;
        }
        h.push(x2);
      }
      if (!f) {
        if (Array.isArray(c) && c.length !== h.length) {
          u5.error("Expected ".concat(c.length, " arguments, but found ").concat(h.length, " instead."));
          continue;
        }
        for (let m5 = 0; m5 < h.length; m5++) {
          let y4 = Array.isArray(c) ? c[m5] : c.type, g = h[m5];
          u5.concat(m5 + 1).checkSubtype(y4, g.type);
        }
        if (u5.errors.length === 0) return new Kr(i, o4, p4, h);
      }
    }
    if (s5.length === 1) t.errors.push(...u5.errors);
    else {
      let p4 = (s5.length ? s5 : a4).map(([f]) => VT$1(f)).join(" | "), h = [];
      for (let f = 1; f < e.length; f++) {
        let m5 = t.parse(e[f], 1 + h.length);
        if (!m5) return null;
        h.push(Re$1(m5.type));
      }
      t.error("Expected arguments of type ".concat(p4, ", but found (").concat(h.join(", "), ") instead."));
    }
    return null;
  }
  static register(e, t) {
    Kr.definitions = t;
    for (let i in t) e[i] = Kr;
  }
};
H$3(Kr$1, "CompoundExpression");
var Nt$1 = Kr$1;
function Lb(r5, [e, t, i, n4]) {
  e = e.evaluate(r5), t = t.evaluate(r5), i = i.evaluate(r5);
  let o4 = n4 ? n4.evaluate(r5) : 1, a4 = Kb$1(e, t, i, o4);
  if (a4) throw new Be$1(a4);
  return new X$1(e / 255, t / 255, i / 255, o4, false);
}
H$3(Lb, "rgba");
function Db$1(r5, e) {
  return r5 in e;
}
H$3(Db$1, "has");
function Vp$1(r5, e) {
  let t = e[r5];
  return typeof t > "u" ? null : t;
}
H$3(Vp$1, "get");
function OT$1(r5, e, t, i) {
  for (; t <= i; ) {
    let n4 = t + i >> 1;
    if (e[n4] === r5) return true;
    e[n4] > r5 ? i = n4 - 1 : t = n4 + 1;
  }
  return false;
}
H$3(OT$1, "binarySearch");
function Xr$2(r5) {
  return { type: r5 };
}
H$3(Xr$2, "varargs");
Nt$1.register(ii, { error: [AP, [pe$2], (r5, [e]) => {
  throw new Be$1(e.evaluate(r5));
}], typeof: [pe$2, [le$1], (r5, [e]) => Re$1(He(e.evaluate(r5)))], "to-rgba": [_t$1(j$1, 4), [Ct$1], (r5, [e]) => {
  let [t, i, n4, o4] = e.evaluate(r5).rgb;
  return [t * 255, i * 255, n4 * 255, o4];
}], rgb: [Ct$1, [j$1, j$1, j$1], Lb], rgba: [Ct$1, [j$1, j$1, j$1, j$1], Lb], has: { type: se$1, overloads: [[[pe$2], (r5, [e]) => Db$1(e.evaluate(r5), r5.properties())], [[pe$2, Vi], (r5, [e, t]) => Db$1(e.evaluate(r5), t.evaluate(r5))]] }, get: { type: le$1, overloads: [[[pe$2], (r5, [e]) => Vp$1(e.evaluate(r5), r5.properties())], [[pe$2, Vi], (r5, [e, t]) => Vp$1(e.evaluate(r5), t.evaluate(r5))]] }, "feature-state": [le$1, [pe$2], (r5, [e]) => Vp$1(e.evaluate(r5), r5.featureState || {})], properties: [Vi, [], (r5) => r5.properties()], "geometry-type": [pe$2, [], (r5) => r5.geometryType()], id: [le$1, [], (r5) => r5.id()], zoom: [j$1, [], (r5) => r5.globals.zoom], "heatmap-density": [j$1, [], (r5) => r5.globals.heatmapDensity || 0], "line-progress": [j$1, [], (r5) => r5.globals.lineProgress || 0], accumulated: [le$1, [], (r5) => r5.globals.accumulated === void 0 ? null : r5.globals.accumulated], "+": [j$1, Xr$2(j$1), (r5, e) => {
  let t = 0;
  for (let i of e) t += i.evaluate(r5);
  return t;
}], "*": [j$1, Xr$2(j$1), (r5, e) => {
  let t = 1;
  for (let i of e) t *= i.evaluate(r5);
  return t;
}], "-": { type: j$1, overloads: [[[j$1, j$1], (r5, [e, t]) => e.evaluate(r5) - t.evaluate(r5)], [[j$1], (r5, [e]) => -e.evaluate(r5)]] }, "/": [j$1, [j$1, j$1], (r5, [e, t]) => e.evaluate(r5) / t.evaluate(r5)], "%": [j$1, [j$1, j$1], (r5, [e, t]) => e.evaluate(r5) % t.evaluate(r5)], ln2: [j$1, [], () => Math.LN2], pi: [j$1, [], () => Math.PI], e: [j$1, [], () => Math.E], "^": [j$1, [j$1, j$1], (r5, [e, t]) => Math.pow(e.evaluate(r5), t.evaluate(r5))], sqrt: [j$1, [j$1], (r5, [e]) => Math.sqrt(e.evaluate(r5))], log10: [j$1, [j$1], (r5, [e]) => Math.log(e.evaluate(r5)) / Math.LN10], ln: [j$1, [j$1], (r5, [e]) => Math.log(e.evaluate(r5))], log2: [j$1, [j$1], (r5, [e]) => Math.log(e.evaluate(r5)) / Math.LN2], sin: [j$1, [j$1], (r5, [e]) => Math.sin(e.evaluate(r5))], cos: [j$1, [j$1], (r5, [e]) => Math.cos(e.evaluate(r5))], tan: [j$1, [j$1], (r5, [e]) => Math.tan(e.evaluate(r5))], asin: [j$1, [j$1], (r5, [e]) => Math.asin(e.evaluate(r5))], acos: [j$1, [j$1], (r5, [e]) => Math.acos(e.evaluate(r5))], atan: [j$1, [j$1], (r5, [e]) => Math.atan(e.evaluate(r5))], min: [j$1, Xr$2(j$1), (r5, e) => Math.min(...e.map((t) => t.evaluate(r5)))], max: [j$1, Xr$2(j$1), (r5, e) => Math.max(...e.map((t) => t.evaluate(r5)))], abs: [j$1, [j$1], (r5, [e]) => Math.abs(e.evaluate(r5))], round: [j$1, [j$1], (r5, [e]) => {
  let t = e.evaluate(r5);
  return t < 0 ? -Math.round(-t) : Math.round(t);
}], floor: [j$1, [j$1], (r5, [e]) => Math.floor(e.evaluate(r5))], ceil: [j$1, [j$1], (r5, [e]) => Math.ceil(e.evaluate(r5))], "filter-==": [se$1, [pe$2, le$1], (r5, [e, t]) => r5.properties()[e.value] === t.value], "filter-id-==": [se$1, [le$1], (r5, [e]) => r5.id() === e.value], "filter-type-==": [se$1, [pe$2], (r5, [e]) => r5.geometryType() === e.value], "filter-<": [se$1, [pe$2, le$1], (r5, [e, t]) => {
  let i = r5.properties()[e.value], n4 = t.value;
  return typeof i == typeof n4 && i < n4;
}], "filter-id-<": [se$1, [le$1], (r5, [e]) => {
  let t = r5.id(), i = e.value;
  return typeof t == typeof i && t < i;
}], "filter->": [se$1, [pe$2, le$1], (r5, [e, t]) => {
  let i = r5.properties()[e.value], n4 = t.value;
  return typeof i == typeof n4 && i > n4;
}], "filter-id->": [se$1, [le$1], (r5, [e]) => {
  let t = r5.id(), i = e.value;
  return typeof t == typeof i && t > i;
}], "filter-<=": [se$1, [pe$2, le$1], (r5, [e, t]) => {
  let i = r5.properties()[e.value], n4 = t.value;
  return typeof i == typeof n4 && i <= n4;
}], "filter-id-<=": [se$1, [le$1], (r5, [e]) => {
  let t = r5.id(), i = e.value;
  return typeof t == typeof i && t <= i;
}], "filter->=": [se$1, [pe$2, le$1], (r5, [e, t]) => {
  let i = r5.properties()[e.value], n4 = t.value;
  return typeof i == typeof n4 && i >= n4;
}], "filter-id->=": [se$1, [le$1], (r5, [e]) => {
  let t = r5.id(), i = e.value;
  return typeof t == typeof i && t >= i;
}], "filter-has": [se$1, [le$1], (r5, [e]) => e.value in r5.properties()], "filter-has-id": [se$1, [], (r5) => r5.id() !== null && r5.id() !== void 0], "filter-type-in": [se$1, [_t$1(pe$2)], (r5, [e]) => e.value.indexOf(r5.geometryType()) >= 0], "filter-id-in": [se$1, [_t$1(le$1)], (r5, [e]) => e.value.indexOf(r5.id()) >= 0], "filter-in-small": [se$1, [pe$2, _t$1(le$1)], (r5, [e, t]) => t.value.indexOf(r5.properties()[e.value]) >= 0], "filter-in-large": [se$1, [pe$2, _t$1(le$1)], (r5, [e, t]) => OT$1(r5.properties()[e.value], t.value, 0, t.value.length - 1)], all: { type: se$1, overloads: [[[se$1, se$1], (r5, [e, t]) => e.evaluate(r5) && t.evaluate(r5)], [Xr$2(se$1), (r5, e) => {
  for (let t of e) if (!t.evaluate(r5)) return false;
  return true;
}]] }, any: { type: se$1, overloads: [[[se$1, se$1], (r5, [e, t]) => e.evaluate(r5) || t.evaluate(r5)], [Xr$2(se$1), (r5, e) => {
  for (let t of e) if (t.evaluate(r5)) return true;
  return false;
}]] }, "!": [se$1, [se$1], (r5, [e]) => !e.evaluate(r5)], "is-supported-script": [se$1, [pe$2], (r5, [e]) => {
  let t = r5.globals && r5.globals.isSupportedScript;
  return t ? t(e.evaluate(r5)) : true;
}], upcase: [pe$2, [pe$2], (r5, [e]) => e.evaluate(r5).toUpperCase()], downcase: [pe$2, [pe$2], (r5, [e]) => e.evaluate(r5).toLowerCase()], concat: [pe$2, Xr$2(le$1), (r5, e) => e.map((t) => On$1(t.evaluate(r5))).join("")], "resolved-locale": [pe$2, [Xs], (r5, [e]) => e.evaluate(r5).resolvedLocale()] });
function VT$1(r5) {
  return Array.isArray(r5) ? "(".concat(r5.map(Re$1).join(", "), ")") : "(".concat(Re$1(r5.type), "...)");
}
H$3(VT$1, "stringifySignature");
function Is(r5) {
  if (r5 instanceof _s) return Is(r5.boundExpression);
  if (r5 instanceof Nt$1 && r5.name === "error") return false;
  if (r5 instanceof Ss) return false;
  if (r5 instanceof Yn) return false;
  if (r5 instanceof eo) return false;
  let e = r5 instanceof xr || r5 instanceof Ft$2, t = true;
  return r5.eachChild((i) => {
    e ? t = t && Is(i) : t = t && i instanceof br;
  }), t ? el$1(r5) && tl$1(r5, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) : false;
}
H$3(Is, "isExpressionConstant");
function el$1(r5) {
  if (r5 instanceof Nt$1) {
    if (r5.name === "get" && r5.args.length === 1) return false;
    if (r5.name === "feature-state") return false;
    if (r5.name === "has" && r5.args.length === 1) return false;
    if (r5.name === "properties" || r5.name === "geometry-type" || r5.name === "id") return false;
    if (/^filter-/.test(r5.name)) return false;
  }
  if (r5 instanceof Yn || r5 instanceof eo) return false;
  let e = true;
  return r5.eachChild((t) => {
    e && !el$1(t) && (e = false);
  }), e;
}
H$3(el$1, "isFeatureConstant");
function to(r5) {
  if (r5 instanceof Nt$1 && r5.name === "feature-state") return false;
  let e = true;
  return r5.eachChild((t) => {
    e && !to(t) && (e = false);
  }), e;
}
H$3(to, "isStateConstant");
function tl$1(r5, e) {
  if (r5 instanceof Nt$1 && e.indexOf(r5.name) >= 0) return false;
  let t = true;
  return r5.eachChild((i) => {
    t && !tl$1(i, e) && (t = false);
  }), t;
}
H$3(tl$1, "isGlobalPropertyConstant");
function rh$1(r5) {
  return { result: "success", value: r5 };
}
H$3(rh$1, "success");
function zi$1(r5) {
  return { result: "error", value: r5 };
}
H$3(zi$1, "error");
function _r$1(r5) {
  return r5["property-type"] === "data-driven" || r5["property-type"] === "cross-faded-data-driven";
}
H$3(_r$1, "supportsPropertyExpression");
function i_(r5) {
  return !!r5.expression && r5.expression.parameters.indexOf("zoom") > -1;
}
H$3(i_, "supportsZoomExpression");
function uh$1(r5) {
  return !!r5.expression && r5.expression.interpolated;
}
H$3(uh$1, "supportsInterpolation");
function xe$1(r5) {
  return r5 instanceof Number ? "number" : r5 instanceof String ? "string" : r5 instanceof Boolean ? "boolean" : Array.isArray(r5) ? "array" : r5 === null ? "null" : typeof r5;
}
H$3(xe$1, "getType");
function rl$1(r5) {
  return typeof r5 == "object" && r5 !== null && !Array.isArray(r5);
}
H$3(rl$1, "isFunction$1");
function UT$1(r5) {
  return r5;
}
H$3(UT$1, "identityFunction");
function n_(r5, e) {
  let t = e.type === "color", i = r5.stops && typeof r5.stops[0][0] == "object", n4 = i || r5.property !== void 0, o4 = i || !n4, a4 = r5.type || (uh$1(e) ? "exponential" : "interval");
  if (t || e.type === "padding") {
    let p4 = t ? X$1.parse : Rt$1.parse;
    r5 = Ni$1({}, r5), r5.stops && (r5.stops = r5.stops.map((h) => [h[0], p4(h[1])])), r5.default ? r5.default = p4(r5.default) : r5.default = p4(e.default);
  }
  if (r5.colorSpace && !qP(r5.colorSpace)) throw new Error('Unknown color space: "'.concat(r5.colorSpace, '"'));
  let s5, u5, c;
  if (a4 === "exponential") s5 = zb;
  else if (a4 === "interval") s5 = GT$1;
  else if (a4 === "categorical") {
    s5 = NT$1, u5 = /* @__PURE__ */ Object.create(null);
    for (let p4 of r5.stops) u5[p4[0]] = p4[1];
    c = typeof r5.stops[0][0];
  } else if (a4 === "identity") s5 = qT$1;
  else throw new Error('Unknown function type "'.concat(a4, '"'));
  if (i) {
    let p4 = {}, h = [];
    for (let y4 = 0; y4 < r5.stops.length; y4++) {
      let g = r5.stops[y4], x2 = g[0].zoom;
      p4[x2] === void 0 && (p4[x2] = { zoom: x2, type: r5.type, property: r5.property, default: r5.default, stops: [] }, h.push(x2)), p4[x2].stops.push([g[0].value, g[1]]);
    }
    let f = [];
    for (let y4 of h) f.push([p4[y4].zoom, n_(p4[y4], e)]);
    let m5 = { name: "linear" };
    return { kind: "composite", interpolationType: m5, interpolationFactor: vt$1.interpolationFactor.bind(void 0, m5), zoomStops: f.map((y4) => y4[0]), evaluate({ zoom: y4 }, g) {
      return zb({ stops: f, base: r5.base }, e, y4).evaluate(y4, g);
    } };
  } else if (o4) {
    let p4 = a4 === "exponential" ? { name: "exponential", base: r5.base !== void 0 ? r5.base : 1 } : null;
    return { kind: "camera", interpolationType: p4, interpolationFactor: vt$1.interpolationFactor.bind(void 0, p4), zoomStops: r5.stops.map((h) => h[0]), evaluate: H$3(({ zoom: h }) => s5(r5, e, h, u5, c), "evaluate") };
  } else return { kind: "source", evaluate(p4, h) {
    let f = h && h.properties ? h.properties[r5.property] : void 0;
    return f === void 0 ? ao$1(r5.default, e.default) : s5(r5, e, f, u5, c);
  } };
}
H$3(n_, "createFunction");
function ao$1(r5, e, t) {
  if (r5 !== void 0) return r5;
  if (e !== void 0) return e;
  if (t !== void 0) return t;
}
H$3(ao$1, "coalesce$1");
function NT$1(r5, e, t, i, n4) {
  let o4 = typeof t === n4 ? i[t] : void 0;
  return ao$1(o4, r5.default, e.default);
}
H$3(NT$1, "evaluateCategoricalFunction");
function GT$1(r5, e, t) {
  if (xe$1(t) !== "number") return ao$1(r5.default, e.default);
  let i = r5.stops.length;
  if (i === 1 || t <= r5.stops[0][0]) return r5.stops[0][1];
  if (t >= r5.stops[i - 1][0]) return r5.stops[i - 1][1];
  let n4 = Ys(r5.stops.map((o4) => o4[0]), t);
  return r5.stops[n4][1];
}
H$3(GT$1, "evaluateIntervalFunction");
function zb(r5, e, t) {
  let i = r5.base !== void 0 ? r5.base : 1;
  if (xe$1(t) !== "number") return ao$1(r5.default, e.default);
  let n4 = r5.stops.length;
  if (n4 === 1 || t <= r5.stops[0][0]) return r5.stops[0][1];
  if (t >= r5.stops[n4 - 1][0]) return r5.stops[n4 - 1][1];
  let o4 = Ys(r5.stops.map((p4) => p4[0]), t), a4 = jT$1(t, i, r5.stops[o4][0], r5.stops[o4 + 1][0]), s5 = r5.stops[o4][1], u5 = r5.stops[o4 + 1][1], c = Pe$2[e.type] || UT$1;
  return typeof s5.evaluate == "function" ? { evaluate(...p4) {
    let h = s5.evaluate.apply(void 0, p4), f = u5.evaluate.apply(void 0, p4);
    if (!(h === void 0 || f === void 0)) return c(h, f, a4, r5.colorSpace);
  } } : c(s5, u5, a4, r5.colorSpace);
}
H$3(zb, "evaluateExponentialFunction");
function qT$1(r5, e, t) {
  switch (e.type) {
    case "color":
      t = X$1.parse(t);
      break;
    case "formatted":
      t = wt$1.fromString(t.toString());
      break;
    case "resolvedImage":
      t = ft$1.fromString(t.toString());
      break;
    case "padding":
      t = Rt$1.parse(t);
      break;
    default:
      xe$1(t) !== e.type && (e.type !== "enum" || !e.values[t]) && (t = void 0);
  }
  return ao$1(t, r5.default, e.default);
}
H$3(qT$1, "evaluateIdentityFunction");
function jT$1(r5, e, t, i) {
  let n4 = i - t, o4 = r5 - t;
  return n4 === 0 ? 0 : e === 1 ? o4 / n4 : (Math.pow(e, o4) - 1) / (Math.pow(e, n4) - 1);
}
H$3(jT$1, "interpolationFactor");
var Sh$1 = class Sh2 {
  constructor(e, t) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new gs(), this._defaultValue = t ? HT$1(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null;
  }
  evaluateWithoutErrorHandling(e, t, i, n4, o4, a4) {
    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = i, this._evaluator.canonical = n4, this._evaluator.availableImages = o4 || null, this._evaluator.formattedSection = a4, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, t, i, n4, o4, a4) {
    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = i || null, this._evaluator.canonical = n4, this._evaluator.availableImages = o4 || null, this._evaluator.formattedSection = a4 || null;
    try {
      let s5 = this.expression.evaluate(this._evaluator);
      if (s5 == null || typeof s5 == "number" && s5 !== s5) return this._defaultValue;
      if (this._enumValues && !(s5 in this._enumValues)) throw new Be$1("Expected value to be one of ".concat(Object.keys(this._enumValues).map((u5) => JSON.stringify(u5)).join(", "), ", but found ").concat(JSON.stringify(s5), " instead."));
      return s5;
    } catch (s5) {
      return this._warningHistory[s5.message] || (this._warningHistory[s5.message] = true, typeof console < "u" && console.warn(s5.message)), this._defaultValue;
    }
  }
};
H$3(Sh$1, "StyleExpression");
var ei$1 = Sh$1;
function ni(r5) {
  return Array.isArray(r5) && r5.length > 0 && typeof r5[0] == "string" && r5[0] in ii;
}
H$3(ni, "isExpression");
function ch$1(r5, e) {
  let t = new xs(ii, Is, [], e ? ZT$1(e) : void 0), i = t.parse(r5, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return i ? rh$1(new ei$1(i, e)) : zi$1(t.errors);
}
H$3(ch$1, "createExpression");
var Ph$1 = class Ph2 {
  constructor(e, t) {
    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !to(t.expression);
  }
  evaluateWithoutErrorHandling(e, t, i, n4, o4, a4) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, i, n4, o4, a4);
  }
  evaluate(e, t, i, n4, o4, a4) {
    return this._styleExpression.evaluate(e, t, i, n4, o4, a4);
  }
};
H$3(Ph$1, "ZoomConstantExpression");
var vr = Ph$1, Th$1 = class Th2 {
  constructor(e, t, i, n4) {
    this.kind = e, this.zoomStops = i, this._styleExpression = t, this.isStateDependent = e !== "camera" && !to(t.expression), this.interpolationType = n4;
  }
  evaluateWithoutErrorHandling(e, t, i, n4, o4, a4) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, i, n4, o4, a4);
  }
  evaluate(e, t, i, n4, o4, a4) {
    return this._styleExpression.evaluate(e, t, i, n4, o4, a4);
  }
  interpolationFactor(e, t, i) {
    return this.interpolationType ? vt$1.interpolationFactor(this.interpolationType, e, t, i) : 0;
  }
};
H$3(Th$1, "ZoomDependentExpression");
var wr$1 = Th$1;
function o_(r5, e) {
  let t = ch$1(r5, e);
  if (t.result === "error") return t;
  let i = t.value.expression, n4 = el$1(i);
  if (!n4 && !_r$1(e)) return zi$1([new At$1("", "data expressions not supported")]);
  let o4 = tl$1(i, ["zoom"]);
  if (!o4 && !i_(e)) return zi$1([new At$1("", "zoom expressions not supported")]);
  let a4 = ys(i);
  if (!a4 && !o4) return zi$1([new At$1("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (a4 instanceof At$1) return zi$1([a4]);
  if (a4 instanceof vt$1 && !uh$1(e)) return zi$1([new At$1("", '"interpolate" expressions cannot be used with this property')]);
  if (!a4) return rh$1(n4 ? new vr("constant", t.value) : new vr("source", t.value));
  let s5 = a4 instanceof vt$1 ? a4.interpolation : void 0;
  return rh$1(n4 ? new wr$1("camera", t.value, a4.labels, s5) : new wr$1("composite", t.value, a4.labels, s5));
}
H$3(o_, "createPropertyExpression");
var Ws = class Ws2 {
  constructor(e, t) {
    this._parameters = e, this._specification = t, Ni$1(this, n_(this._parameters, this._specification));
  }
  static deserialize(e) {
    return new Ws2(e._parameters, e._specification);
  }
  static serialize(e) {
    return { _parameters: e._parameters, _specification: e._specification };
  }
};
H$3(Ws, "StylePropertyFunction");
var ro = Ws;
function a_(r5, e) {
  if (rl$1(r5)) return new ro(r5, e);
  if (ni(r5)) {
    let t = o_(r5, e);
    if (t.result === "error") throw new Error(t.value.map((i) => "".concat(i.key, ": ").concat(i.message)).join(", "));
    return t.value;
  } else {
    let t = r5;
    return e.type === "color" && typeof r5 == "string" ? t = X$1.parse(r5) : e.type === "padding" && (typeof r5 == "number" || Array.isArray(r5)) ? t = Rt$1.parse(r5) : e.type === "variableAnchorOffsetCollection" && Array.isArray(r5) && (t = ir$1.parse(r5)), { kind: "constant", evaluate: H$3(() => t, "evaluate") };
  }
}
H$3(a_, "normalizePropertyExpression");
function ys(r5) {
  let e = null;
  if (r5 instanceof bs) e = ys(r5.result);
  else if (r5 instanceof ws$1) {
    for (let t of r5.args) if (e = ys(t), e) break;
  } else (r5 instanceof Gi$1 || r5 instanceof vt$1) && r5.input instanceof Nt$1 && r5.input.name === "zoom" && (e = r5);
  return e instanceof At$1 || r5.eachChild((t) => {
    let i = ys(t);
    i instanceof At$1 ? e = i : !e && i ? e = new At$1("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && i && e !== i && (e = new At$1("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
H$3(ys, "findZoomCurve");
function ZT$1(r5) {
  let e = { color: Ct$1, string: pe$2, number: j$1, enum: pe$2, boolean: se$1, formatted: Zi$1, padding: Ks, resolvedImage: no, variableAnchorOffsetCollection: Js };
  return r5.type === "array" ? _t$1(e[r5.value] || le$1, r5.length) : e[r5.type];
}
H$3(ZT$1, "getExpectedType");
function HT$1(r5) {
  return r5.type === "color" && rl$1(r5.default) ? new X$1(0, 0, 0, 0) : r5.type === "color" ? X$1.parse(r5.default) || null : r5.type === "padding" ? Rt$1.parse(r5.default) || null : r5.type === "variableAnchorOffsetCollection" ? ir$1.parse(r5.default) || null : r5.default === void 0 ? null : r5.default;
}
H$3(HT$1, "getDefaultValue");
function ph$1(r5) {
  if (r5 === true || r5 === false) return true;
  if (!Array.isArray(r5) || r5.length === 0) return false;
  switch (r5[0]) {
    case "has":
      return r5.length >= 2 && r5[1] !== "$id" && r5[1] !== "$type";
    case "in":
      return r5.length >= 3 && (typeof r5[1] != "string" || Array.isArray(r5[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return r5.length !== 3 || Array.isArray(r5[1]) || Array.isArray(r5[2]);
    case "any":
    case "all":
      for (let e of r5.slice(1)) if (!ph$1(e) && typeof e != "boolean") return false;
      return true;
    default:
      return true;
  }
}
H$3(ph$1, "isExpressionFilter");
var $T$1 = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
function so(r5) {
  if (r5 == null) return { filter: H$3(() => true, "filter"), needGeometry: false };
  ph$1(r5) || (r5 = Cs(r5));
  let e = ch$1(r5, $T$1);
  if (e.result === "error") throw new Error(e.value.map((t) => "".concat(t.key, ": ").concat(t.message)).join(", "));
  {
    let t = s_(r5);
    return { filter: H$3((i, n4, o4) => e.value.evaluate(i, n4, {}, o4), "filter"), needGeometry: t };
  }
}
H$3(so, "createFilter");
function WT$1(r5, e) {
  return r5 < e ? -1 : r5 > e ? 1 : 0;
}
H$3(WT$1, "compare");
function s_(r5) {
  if (!Array.isArray(r5)) return false;
  if (r5[0] === "within" || r5[0] === "distance") return true;
  for (let e = 1; e < r5.length; e++) if (s_(r5[e])) return true;
  return false;
}
H$3(s_, "geometryNeeded");
function Cs(r5) {
  if (!r5) return true;
  let e = r5[0];
  return r5.length <= 1 ? e !== "any" : e === "==" ? Up$1(r5[1], r5[2], "==") : e === "!=" ? ds(Up$1(r5[1], r5[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? Up$1(r5[1], r5[2], e) : e === "any" ? XT$1(r5.slice(1)) : e === "all" ? ["all"].concat(r5.slice(1).map(Cs)) : e === "none" ? ["all"].concat(r5.slice(1).map(Cs).map(ds)) : e === "in" ? Fb(r5[1], r5.slice(2)) : e === "!in" ? ds(Fb(r5[1], r5.slice(2))) : e === "has" ? Rb(r5[1]) : e === "!has" ? ds(Rb(r5[1])) : true;
}
H$3(Cs, "convertFilter$1");
function Up$1(r5, e, t) {
  switch (r5) {
    case "$type":
      return ["filter-type-".concat(t), e];
    case "$id":
      return ["filter-id-".concat(t), e];
    default:
      return ["filter-".concat(t), r5, e];
  }
}
H$3(Up$1, "convertComparisonOp$1");
function XT$1(r5) {
  return ["any"].concat(r5.map(Cs));
}
H$3(XT$1, "convertDisjunctionOp");
function Fb(r5, e) {
  if (e.length === 0) return false;
  switch (r5) {
    case "$type":
      return ["filter-type-in", ["literal", e]];
    case "$id":
      return ["filter-id-in", ["literal", e]];
    default:
      return e.length > 200 && !e.some((t) => typeof t != typeof e[0]) ? ["filter-in-large", r5, ["literal", e.sort(WT$1)]] : ["filter-in-small", r5, ["literal", e]];
  }
}
H$3(Fb, "convertInOp$1");
function Rb(r5) {
  switch (r5) {
    case "$type":
      return true;
    case "$id":
      return ["filter-has-id"];
    default:
      return ["filter-has", r5];
  }
}
H$3(Rb, "convertHasOp$1");
function ds(r5) {
  return ["!", r5];
}
H$3(ds, "convertNegation");
function l_() {
  let r5 = {}, e = A$1.$version;
  for (let t in A$1.$root) {
    let i = A$1.$root[t];
    if (i.required) {
      let n4 = null;
      t === "version" ? n4 = e : i.type === "array" ? n4 = [] : n4 = {}, n4 != null && (r5[t] = n4);
    }
  }
  return r5;
}
H$3(l_, "emptyStyle");
function u_(r5) {
  let e = r5.key, t = r5.value;
  return t ? [new B$1(e, t, "constants have been deprecated as of v8")] : [];
}
H$3(u_, "validateConstants");
function Ue$1(r5) {
  return r5 instanceof Number || r5 instanceof String || r5 instanceof Boolean ? r5.valueOf() : r5;
}
H$3(Ue$1, "unbundle");
function ti$1(r5) {
  if (Array.isArray(r5)) return r5.map(ti$1);
  if (r5 instanceof Object && !(r5 instanceof Number || r5 instanceof String || r5 instanceof Boolean)) {
    let e = {};
    for (let t in r5) e[t] = ti$1(r5[t]);
    return e;
  }
  return Ue$1(r5);
}
H$3(ti$1, "deepUnbundle");
function It$1(r5) {
  let e = r5.key, t = r5.value, i = r5.valueSpec || {}, n4 = r5.objectElementValidators || {}, o4 = r5.style, a4 = r5.styleSpec, s5 = r5.validateSpec, u5 = [], c = xe$1(t);
  if (c !== "object") return [new B$1(e, t, "object expected, ".concat(c, " found"))];
  for (let p4 in t) {
    let h = p4.split(".")[0], f = i[h] || i["*"], m5;
    if (n4[h]) m5 = n4[h];
    else if (i[h]) m5 = s5;
    else if (n4["*"]) m5 = n4["*"];
    else if (i["*"]) m5 = s5;
    else {
      u5.push(new B$1(e, t[p4], 'unknown property "'.concat(p4, '"')));
      continue;
    }
    u5 = u5.concat(m5({ key: (e && "".concat(e, ".")) + p4, value: t[p4], valueSpec: f, style: o4, styleSpec: a4, object: t, objectKey: p4, validateSpec: s5 }, t));
  }
  for (let p4 in i) n4[p4] || i[p4].required && i[p4].default === void 0 && t[p4] === void 0 && u5.push(new B$1(e, t, 'missing required property "'.concat(p4, '"')));
  return u5;
}
H$3(It$1, "validateObject");
function hh$1(r5) {
  let e = r5.value, t = r5.valueSpec, i = r5.validateSpec, n4 = r5.style, o4 = r5.styleSpec, a4 = r5.key, s5 = r5.arrayElementValidator || i;
  if (xe$1(e) !== "array") return [new B$1(a4, e, "array expected, ".concat(xe$1(e), " found"))];
  if (t.length && e.length !== t.length) return [new B$1(a4, e, "array length ".concat(t.length, " expected, length ").concat(e.length, " found"))];
  if (t["min-length"] && e.length < t["min-length"]) return [new B$1(a4, e, "array length at least ".concat(t["min-length"], " expected, length ").concat(e.length, " found"))];
  let u5 = { type: t.value, values: t.values };
  o4.$version < 7 && (u5.function = t.function), xe$1(t.value) === "object" && (u5 = t.value);
  let c = [];
  for (let p4 = 0; p4 < e.length; p4++) c = c.concat(s5({ array: e, arrayIndex: p4, value: e[p4], valueSpec: u5, validateSpec: r5.validateSpec, style: n4, styleSpec: o4, key: "".concat(a4, "[").concat(p4, "]") }));
  return c;
}
H$3(hh$1, "validateArray");
function fh$1(r5) {
  let e = r5.key, t = r5.value, i = r5.valueSpec, n4 = xe$1(t);
  return n4 === "number" && t !== t && (n4 = "NaN"), n4 !== "number" ? [new B$1(e, t, "number expected, ".concat(n4, " found"))] : "minimum" in i && t < i.minimum ? [new B$1(e, t, "".concat(t, " is less than the minimum value ").concat(i.minimum))] : "maximum" in i && t > i.maximum ? [new B$1(e, t, "".concat(t, " is greater than the maximum value ").concat(i.maximum))] : [];
}
H$3(fh$1, "validateNumber");
function c_(r5) {
  let e = r5.valueSpec, t = Ue$1(r5.value.type), i, n4 = {}, o4, a4, s5 = t !== "categorical" && r5.value.property === void 0, u5 = !s5, c = xe$1(r5.value.stops) === "array" && xe$1(r5.value.stops[0]) === "array" && xe$1(r5.value.stops[0][0]) === "object", p4 = It$1({ key: r5.key, value: r5.value, valueSpec: r5.styleSpec.function, validateSpec: r5.validateSpec, style: r5.style, styleSpec: r5.styleSpec, objectElementValidators: { stops: h, default: y4 } });
  return t === "identity" && s5 && p4.push(new B$1(r5.key, r5.value, 'missing required property "property"')), t !== "identity" && !r5.value.stops && p4.push(new B$1(r5.key, r5.value, 'missing required property "stops"')), t === "exponential" && r5.valueSpec.expression && !uh$1(r5.valueSpec) && p4.push(new B$1(r5.key, r5.value, "exponential functions not supported")), r5.styleSpec.$version >= 8 && (u5 && !_r$1(r5.valueSpec) ? p4.push(new B$1(r5.key, r5.value, "property functions not supported")) : s5 && !i_(r5.valueSpec) && p4.push(new B$1(r5.key, r5.value, "zoom functions not supported"))), (t === "categorical" || c) && r5.value.property === void 0 && p4.push(new B$1(r5.key, r5.value, '"property" property is required')), p4;
  function h(g) {
    if (t === "identity") return [new B$1(g.key, g.value, 'identity function may not have a "stops" property')];
    let x2 = [], b = g.value;
    return x2 = x2.concat(hh$1({ key: g.key, value: b, valueSpec: g.valueSpec, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec, arrayElementValidator: f })), xe$1(b) === "array" && b.length === 0 && x2.push(new B$1(g.key, b, "array must have at least one stop")), x2;
  }
  function f(g) {
    let x2 = [], b = g.value, w3 = g.key;
    if (xe$1(b) !== "array") return [new B$1(w3, b, "array expected, ".concat(xe$1(b), " found"))];
    if (b.length !== 2) return [new B$1(w3, b, "array length 2 expected, length ".concat(b.length, " found"))];
    if (c) {
      if (xe$1(b[0]) !== "object") return [new B$1(w3, b, "object expected, ".concat(xe$1(b[0]), " found"))];
      if (b[0].zoom === void 0) return [new B$1(w3, b, "object stop key must have zoom")];
      if (b[0].value === void 0) return [new B$1(w3, b, "object stop key must have value")];
      if (a4 && a4 > Ue$1(b[0].zoom)) return [new B$1(w3, b[0].zoom, "stop zoom values must appear in ascending order")];
      Ue$1(b[0].zoom) !== a4 && (a4 = Ue$1(b[0].zoom), o4 = void 0, n4 = {}), x2 = x2.concat(It$1({ key: "".concat(w3, "[0]"), value: b[0], valueSpec: { zoom: {} }, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec, objectElementValidators: { zoom: fh$1, value: m5 } }));
    } else x2 = x2.concat(m5({ key: "".concat(w3, "[0]"), value: b[0], validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec }, b));
    return ni(ti$1(b[1])) ? x2.concat([new B$1("".concat(w3, "[1]"), b[1], "expressions are not allowed in function stops.")]) : x2.concat(g.validateSpec({ key: "".concat(w3, "[1]"), value: b[1], valueSpec: e, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec }));
  }
  function m5(g, x2) {
    let b = xe$1(g.value), w3 = Ue$1(g.value), _ = g.value !== null ? g.value : x2;
    if (!i) i = b;
    else if (b !== i) return [new B$1(g.key, _, "".concat(b, " stop domain type must match previous stop domain type ").concat(i))];
    if (b !== "number" && b !== "string" && b !== "boolean") return [new B$1(g.key, _, "stop domain value must be a number, string, or boolean")];
    if (b !== "number" && t !== "categorical") {
      let S4 = "number expected, ".concat(b, " found");
      return _r$1(e) && t === void 0 && (S4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new B$1(g.key, _, S4)];
    }
    return t === "categorical" && b === "number" && (!isFinite(w3) || Math.floor(w3) !== w3) ? [new B$1(g.key, _, "integer expected, found ".concat(w3))] : t !== "categorical" && b === "number" && o4 !== void 0 && w3 < o4 ? [new B$1(g.key, _, "stop domain values must appear in ascending order")] : (o4 = w3, t === "categorical" && w3 in n4 ? [new B$1(g.key, _, "stop domain values must be unique")] : (n4[w3] = true, []));
  }
  function y4(g) {
    return g.validateSpec({ key: g.key, value: g.value, valueSpec: e, validateSpec: g.validateSpec, style: g.style, styleSpec: g.styleSpec });
  }
}
H$3(c_, "validateFunction");
function qi$1(r5) {
  let e = (r5.expressionContext === "property" ? o_ : ch$1)(ti$1(r5.value), r5.valueSpec);
  if (e.result === "error") return e.value.map((i) => new B$1("".concat(r5.key).concat(i.key), r5.value, i.message));
  let t = e.value.expression || e.value._styleExpression.expression;
  if (r5.expressionContext === "property" && r5.propertyKey === "text-font" && !t.outputDefined()) return [new B$1(r5.key, r5.value, 'Invalid data expression for "'.concat(r5.propertyKey, '". Output values must be contained as literals within the expression.'))];
  if (r5.expressionContext === "property" && r5.propertyType === "layout" && !to(t)) return [new B$1(r5.key, r5.value, '"feature-state" data expressions are not supported with layout properties.')];
  if (r5.expressionContext === "filter" && !to(t)) return [new B$1(r5.key, r5.value, '"feature-state" data expressions are not supported with filters.')];
  if (r5.expressionContext && r5.expressionContext.indexOf("cluster") === 0) {
    if (!tl$1(t, ["zoom", "feature-state"])) return [new B$1(r5.key, r5.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    if (r5.expressionContext === "cluster-initial" && !el$1(t)) return [new B$1(r5.key, r5.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
  }
  return [];
}
H$3(qi$1, "validateExpression");
function KT$1(r5) {
  let e = r5.value, t = r5.key, i = xe$1(e);
  return i !== "boolean" ? [new B$1(t, e, "boolean expected, ".concat(i, " found"))] : [];
}
H$3(KT$1, "validateBoolean");
function JT$1(r5) {
  let e = r5.key, t = r5.value, i = xe$1(t);
  return i !== "string" ? [new B$1(e, t, "color expected, ".concat(i, " found"))] : X$1.parse(String(t)) ? [] : [new B$1(e, t, 'color expected, "'.concat(t, '" found'))];
}
H$3(JT$1, "validateColor");
function io(r5) {
  let e = r5.key, t = r5.value, i = r5.valueSpec, n4 = [];
  return Array.isArray(i.values) ? i.values.indexOf(Ue$1(t)) === -1 && n4.push(new B$1(e, t, "expected one of [".concat(i.values.join(", "), "], ").concat(JSON.stringify(t), " found"))) : Object.keys(i.values).indexOf(Ue$1(t)) === -1 && n4.push(new B$1(e, t, "expected one of [".concat(Object.keys(i.values).join(", "), "], ").concat(JSON.stringify(t), " found"))), n4;
}
H$3(io, "validateEnum");
function mh$1(r5) {
  return ph$1(ti$1(r5.value)) ? qi$1(Ni$1({}, r5, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : p_(r5);
}
H$3(mh$1, "validateFilter");
function p_(r5) {
  let e = r5.value, t = r5.key;
  if (xe$1(e) !== "array") return [new B$1(t, e, "array expected, ".concat(xe$1(e), " found"))];
  let i = r5.styleSpec, n4, o4 = [];
  if (e.length < 1) return [new B$1(t, e, "filter array must have at least 1 element")];
  switch (o4 = o4.concat(io({ key: "".concat(t, "[0]"), value: e[0], valueSpec: i.filter_operator, style: r5.style, styleSpec: r5.styleSpec })), Ue$1(e[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      e.length >= 2 && Ue$1(e[1]) === "$type" && o4.push(new B$1(t, e, '"$type" cannot be use with operator "'.concat(e[0], '"')));
    case "==":
    case "!=":
      e.length !== 3 && o4.push(new B$1(t, e, 'filter array for operator "'.concat(e[0], '" must have 3 elements')));
    case "in":
    case "!in":
      e.length >= 2 && (n4 = xe$1(e[1]), n4 !== "string" && o4.push(new B$1("".concat(t, "[1]"), e[1], "string expected, ".concat(n4, " found"))));
      for (let a4 = 2; a4 < e.length; a4++) n4 = xe$1(e[a4]), Ue$1(e[1]) === "$type" ? o4 = o4.concat(io({ key: "".concat(t, "[").concat(a4, "]"), value: e[a4], valueSpec: i.geometry_type, style: r5.style, styleSpec: r5.styleSpec })) : n4 !== "string" && n4 !== "number" && n4 !== "boolean" && o4.push(new B$1("".concat(t, "[").concat(a4, "]"), e[a4], "string, number, or boolean expected, ".concat(n4, " found")));
      break;
    case "any":
    case "all":
    case "none":
      for (let a4 = 1; a4 < e.length; a4++) o4 = o4.concat(p_({ key: "".concat(t, "[").concat(a4, "]"), value: e[a4], style: r5.style, styleSpec: r5.styleSpec }));
      break;
    case "has":
    case "!has":
      n4 = xe$1(e[1]), e.length !== 2 ? o4.push(new B$1(t, e, 'filter array for "'.concat(e[0], '" operator must have 2 elements'))) : n4 !== "string" && o4.push(new B$1("".concat(t, "[1]"), e[1], "string expected, ".concat(n4, " found")));
      break;
  }
  return o4;
}
H$3(p_, "validateNonExpressionFilter");
function h_(r5, e) {
  let t = r5.key, i = r5.validateSpec, n4 = r5.style, o4 = r5.styleSpec, a4 = r5.value, s5 = r5.objectKey, u5 = o4["".concat(e, "_").concat(r5.layerType)];
  if (!u5) return [];
  let c = s5.match(/^(.*)-transition$/);
  if (e === "paint" && c && u5[c[1]] && u5[c[1]].transition) return i({ key: t, value: a4, valueSpec: o4.transition, style: n4, styleSpec: o4 });
  let p4 = r5.valueSpec || u5[s5];
  if (!p4) return [new B$1(t, a4, 'unknown property "'.concat(s5, '"'))];
  let h;
  if (xe$1(a4) === "string" && _r$1(p4) && !p4.tokens && (h = /^{([^}]+)}$/.exec(a4))) return [new B$1(t, a4, '"'.concat(s5, '" does not support interpolation syntax\n') + 'Use an identity property function instead: `{ "type": "identity", "property": '.concat(JSON.stringify(h[1]), " }`."))];
  let f = [];
  return r5.layerType === "symbol" && (s5 === "text-field" && n4 && !n4.glyphs && f.push(new B$1(t, a4, 'use of "text-field" requires a style "glyphs" property')), s5 === "text-font" && rl$1(ti$1(a4)) && Ue$1(a4.type) === "identity" && f.push(new B$1(t, a4, '"text-font" does not support identity functions'))), f.concat(i({ key: r5.key, value: a4, valueSpec: p4, style: n4, styleSpec: o4, expressionContext: "property", propertyType: e, propertyKey: s5 }));
}
H$3(h_, "validateProperty");
function f_(r5) {
  return h_(r5, "paint");
}
H$3(f_, "validatePaintProperty");
function m_$1(r5) {
  return h_(r5, "layout");
}
H$3(m_$1, "validateLayoutProperty");
function d_$1(r5) {
  let e = [], t = r5.value, i = r5.key, n4 = r5.style, o4 = r5.styleSpec;
  !t.type && !t.ref && e.push(new B$1(i, t, 'either "type" or "ref" is required'));
  let a4 = Ue$1(t.type), s5 = Ue$1(t.ref);
  if (t.id) {
    let u5 = Ue$1(t.id);
    for (let c = 0; c < r5.arrayIndex; c++) {
      let p4 = n4.layers[c];
      Ue$1(p4.id) === u5 && e.push(new B$1(i, t.id, 'duplicate layer id "'.concat(t.id, '", previously used at line ').concat(p4.id.__line__)));
    }
  }
  if ("ref" in t) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((c) => {
      c in t && e.push(new B$1(i, t[c], '"'.concat(c, '" is prohibited for ref layers')));
    });
    let u5;
    n4.layers.forEach((c) => {
      Ue$1(c.id) === s5 && (u5 = c);
    }), u5 ? u5.ref ? e.push(new B$1(i, t.ref, "ref cannot reference another ref layer")) : a4 = Ue$1(u5.type) : e.push(new B$1(i, t.ref, 'ref layer "'.concat(s5, '" not found')));
  } else if (a4 !== "background") if (!t.source) e.push(new B$1(i, t, 'missing required property "source"'));
  else {
    let u5 = n4.sources && n4.sources[t.source], c = u5 && Ue$1(u5.type);
    u5 ? c === "vector" && a4 === "raster" ? e.push(new B$1(i, t.source, 'layer "'.concat(t.id, '" requires a raster source'))) : c !== "raster-dem" && a4 === "hillshade" ? e.push(new B$1(i, t.source, 'layer "'.concat(t.id, '" requires a raster-dem source'))) : c === "raster" && a4 !== "raster" ? e.push(new B$1(i, t.source, 'layer "'.concat(t.id, '" requires a vector source'))) : c === "vector" && !t["source-layer"] ? e.push(new B$1(i, t, 'layer "'.concat(t.id, '" must specify a "source-layer"'))) : c === "raster-dem" && a4 !== "hillshade" ? e.push(new B$1(i, t.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a4 === "line" && t.paint && t.paint["line-gradient"] && (c !== "geojson" || !u5.lineMetrics) && e.push(new B$1(i, t, 'layer "'.concat(t.id, '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'))) : e.push(new B$1(i, t.source, 'source "'.concat(t.source, '" not found')));
  }
  return e = e.concat(It$1({ key: i, value: t, valueSpec: o4.layer, style: r5.style, styleSpec: r5.styleSpec, validateSpec: r5.validateSpec, objectElementValidators: { "*"() {
    return [];
  }, type() {
    return r5.validateSpec({ key: "".concat(i, ".type"), value: t.type, valueSpec: o4.layer.type, style: r5.style, styleSpec: r5.styleSpec, validateSpec: r5.validateSpec, object: t, objectKey: "type" });
  }, filter: mh$1, layout(u5) {
    return It$1({ layer: t, key: u5.key, value: u5.value, style: u5.style, styleSpec: u5.styleSpec, validateSpec: u5.validateSpec, objectElementValidators: { "*"(c) {
      return m_$1(Ni$1({ layerType: a4 }, c));
    } } });
  }, paint(u5) {
    return It$1({ layer: t, key: u5.key, value: u5.value, style: u5.style, styleSpec: u5.styleSpec, validateSpec: u5.validateSpec, objectElementValidators: { "*"(c) {
      return f_(Ni$1({ layerType: a4 }, c));
    } } });
  } } })), e;
}
H$3(d_$1, "validateLayer");
function ri(r5) {
  let e = r5.value, t = r5.key, i = xe$1(e);
  return i !== "string" ? [new B$1(t, e, "string expected, ".concat(i, " found"))] : [];
}
H$3(ri, "validateString");
function YT$1(r5) {
  var e;
  let t = (e = r5.sourceName) !== null && e !== void 0 ? e : "", i = r5.value, n4 = r5.styleSpec, o4 = n4.source_raster_dem, a4 = r5.style, s5 = [], u5 = xe$1(i);
  if (i === void 0) return s5;
  if (u5 !== "object") return s5.push(new B$1("source_raster_dem", i, "object expected, ".concat(u5, " found"))), s5;
  let p4 = Ue$1(i.encoding) === "custom", h = ["redFactor", "greenFactor", "blueFactor", "baseShift"], f = r5.value.encoding ? '"'.concat(r5.value.encoding, '"') : "Default";
  for (let m5 in i) !p4 && h.includes(m5) ? s5.push(new B$1(m5, i[m5], 'In "'.concat(t, '": "').concat(m5, '" is only valid when "encoding" is set to "custom". ').concat(f, " encoding found"))) : o4[m5] ? s5 = s5.concat(r5.validateSpec({ key: m5, value: i[m5], valueSpec: o4[m5], validateSpec: r5.validateSpec, style: a4, styleSpec: n4 })) : s5.push(new B$1(m5, i[m5], 'unknown property "'.concat(m5, '"')));
  return s5;
}
H$3(YT$1, "validateRasterDEMSource");
var Bb = { promoteId: QT$1 };
function y_(r5) {
  let e = r5.value, t = r5.key, i = r5.styleSpec, n4 = r5.style, o4 = r5.validateSpec;
  if (!e.type) return [new B$1(t, e, '"type" is required')];
  let a4 = Ue$1(e.type), s5;
  switch (a4) {
    case "vector":
    case "raster":
      return s5 = It$1({ key: t, value: e, valueSpec: i["source_".concat(a4.replace("-", "_"))], style: r5.style, styleSpec: i, objectElementValidators: Bb, validateSpec: o4 }), s5;
    case "raster-dem":
      return s5 = YT$1({ sourceName: t, value: e, style: r5.style, styleSpec: i, validateSpec: o4 }), s5;
    case "geojson":
      if (s5 = It$1({ key: t, value: e, valueSpec: i.source_geojson, style: n4, styleSpec: i, validateSpec: o4, objectElementValidators: Bb }), e.cluster) for (let u5 in e.clusterProperties) {
        let [c, p4] = e.clusterProperties[u5], h = typeof c == "string" ? [c, ["accumulated"], ["get", u5]] : c;
        s5.push(...qi$1({ key: "".concat(t, ".").concat(u5, ".map"), value: p4, expressionContext: "cluster-map" })), s5.push(...qi$1({ key: "".concat(t, ".").concat(u5, ".reduce"), value: h, expressionContext: "cluster-reduce" }));
      }
      return s5;
    case "video":
      return It$1({ key: t, value: e, valueSpec: i.source_video, style: n4, validateSpec: o4, styleSpec: i });
    case "image":
      return It$1({ key: t, value: e, valueSpec: i.source_image, style: n4, validateSpec: o4, styleSpec: i });
    case "canvas":
      return [new B$1(t, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return io({ key: "".concat(t, ".type"), value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
  }
}
H$3(y_, "validateSource");
function QT$1({ key: r5, value: e }) {
  if (xe$1(e) === "string") return ri({ key: r5, value: e });
  {
    let t = [];
    for (let i in e) t.push(...ri({ key: "".concat(r5, ".").concat(i), value: e[i] }));
    return t;
  }
}
H$3(QT$1, "validatePromoteId");
function g_$1(r5) {
  let e = r5.value, t = r5.styleSpec, i = t.light, n4 = r5.style, o4 = [], a4 = xe$1(e);
  if (e === void 0) return o4;
  if (a4 !== "object") return o4 = o4.concat([new B$1("light", e, "object expected, ".concat(a4, " found"))]), o4;
  for (let s5 in e) {
    let u5 = s5.match(/^(.*)-transition$/);
    u5 && i[u5[1]] && i[u5[1]].transition ? o4 = o4.concat(r5.validateSpec({ key: s5, value: e[s5], valueSpec: t.transition, validateSpec: r5.validateSpec, style: n4, styleSpec: t })) : i[s5] ? o4 = o4.concat(r5.validateSpec({ key: s5, value: e[s5], valueSpec: i[s5], validateSpec: r5.validateSpec, style: n4, styleSpec: t })) : o4 = o4.concat([new B$1(s5, e[s5], 'unknown property "'.concat(s5, '"'))]);
  }
  return o4;
}
H$3(g_$1, "validateLight");
function x_(r5) {
  let e = r5.value, t = r5.styleSpec, i = t.sky, n4 = r5.style, o4 = xe$1(e);
  if (e === void 0) return [];
  if (o4 !== "object") return [new B$1("sky", e, "object expected, ".concat(o4, " found"))];
  let a4 = [];
  for (let s5 in e) i[s5] ? a4 = a4.concat(r5.validateSpec({ key: s5, value: e[s5], valueSpec: i[s5], style: n4, styleSpec: t })) : a4 = a4.concat([new B$1(s5, e[s5], 'unknown property "'.concat(s5, '"'))]);
  return a4;
}
H$3(x_, "validateSky");
function b_$1(r5) {
  let e = r5.value, t = r5.styleSpec, i = t.terrain, n4 = r5.style, o4 = [], a4 = xe$1(e);
  if (e === void 0) return o4;
  if (a4 !== "object") return o4 = o4.concat([new B$1("terrain", e, "object expected, ".concat(a4, " found"))]), o4;
  for (let s5 in e) i[s5] ? o4 = o4.concat(r5.validateSpec({ key: s5, value: e[s5], valueSpec: i[s5], validateSpec: r5.validateSpec, style: n4, styleSpec: t })) : o4 = o4.concat([new B$1(s5, e[s5], 'unknown property "'.concat(s5, '"'))]);
  return o4;
}
H$3(b_$1, "validateTerrain");
function eM$1(r5) {
  return ri(r5).length === 0 ? [] : qi$1(r5);
}
H$3(eM$1, "validateFormatted");
function tM$1(r5) {
  return ri(r5).length === 0 ? [] : qi$1(r5);
}
H$3(tM$1, "validateImage");
function rM$1(r5) {
  let e = r5.key, t = r5.value;
  if (xe$1(t) === "array") {
    if (t.length < 1 || t.length > 4) return [new B$1(e, t, "padding requires 1 to 4 values; ".concat(t.length, " values found"))];
    let n4 = { type: "number" }, o4 = [];
    for (let a4 = 0; a4 < t.length; a4++) o4 = o4.concat(r5.validateSpec({ key: "".concat(e, "[").concat(a4, "]"), value: t[a4], validateSpec: r5.validateSpec, valueSpec: n4 }));
    return o4;
  } else return fh$1({ key: e, value: t, valueSpec: {} });
}
H$3(rM$1, "validatePadding");
function iM$1(r5) {
  let e = r5.key, t = r5.value, i = xe$1(t), n4 = r5.styleSpec;
  if (i !== "array" || t.length < 1 || t.length % 2 !== 0) return [new B$1(e, t, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  let o4 = [];
  for (let a4 = 0; a4 < t.length; a4 += 2) o4 = o4.concat(io({ key: "".concat(e, "[").concat(a4, "]"), value: t[a4], valueSpec: n4.layout_symbol["text-anchor"] })), o4 = o4.concat(hh$1({ key: "".concat(e, "[").concat(a4 + 1, "]"), value: t[a4 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: r5.validateSpec, style: r5.style, styleSpec: n4 }));
  return o4;
}
H$3(iM$1, "validateVariableAnchorOffsetCollection");
function __(r5) {
  let e = [], t = r5.value, i = r5.key;
  if (Array.isArray(t)) {
    let n4 = [], o4 = [];
    for (let a4 in t) {
      t[a4].id && n4.includes(t[a4].id) && e.push(new B$1(i, t, "all the sprites' ids must be unique, but ".concat(t[a4].id, " is duplicated"))), n4.push(t[a4].id), t[a4].url && o4.includes(t[a4].url) && e.push(new B$1(i, t, "all the sprites' URLs must be unique, but ".concat(t[a4].url, " is duplicated"))), o4.push(t[a4].url);
      let s5 = { id: { type: "string", required: true }, url: { type: "string", required: true } };
      e = e.concat(It$1({ key: "".concat(i, "[").concat(a4, "]"), value: t[a4], valueSpec: s5, validateSpec: r5.validateSpec }));
    }
    return e;
  } else return ri({ key: i, value: t });
}
H$3(__, "validateSprite");
function nM$1(r5) {
  let e = r5.value, t = r5.styleSpec, i = t.projection, n4 = r5.style, o4 = xe$1(e);
  if (e === void 0) return [];
  if (o4 !== "object") return [new B$1("projection", e, "object expected, ".concat(o4, " found"))];
  let a4 = [];
  for (let s5 in e) i[s5] ? a4 = a4.concat(r5.validateSpec({ key: s5, value: e[s5], valueSpec: i[s5], style: n4, styleSpec: t })) : a4 = a4.concat([new B$1(s5, e[s5], 'unknown property "'.concat(s5, '"'))]);
  return a4;
}
H$3(nM$1, "validateProjection");
var Ob$1 = { "*"() {
  return [];
}, array: hh$1, boolean: KT$1, number: fh$1, color: JT$1, constants: u_, enum: io, filter: mh$1, function: c_, layer: d_$1, object: It$1, source: y_, light: g_$1, sky: x_, terrain: b_$1, projection: nM$1, string: ri, formatted: eM$1, resolvedImage: tM$1, padding: rM$1, variableAnchorOffsetCollection: iM$1, sprite: __ };
function Vn$2(r5) {
  let e = r5.value, t = r5.valueSpec, i = r5.styleSpec;
  return r5.validateSpec = Vn$2, t.expression && rl$1(Ue$1(e)) ? c_(r5) : t.expression && ni(ti$1(e)) ? qi$1(r5) : t.type && Ob$1[t.type] ? Ob$1[t.type](r5) : It$1(Ni$1({}, r5, { valueSpec: t.type ? i[t.type] : t }));
}
H$3(Vn$2, "validate");
function v_(r5) {
  let e = r5.value, t = r5.key, i = ri(r5);
  return i.length || (e.indexOf("{fontstack}") === -1 && i.push(new B$1(t, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && i.push(new B$1(t, e, '"glyphs" url must include a "{range}" token'))), i;
}
H$3(v_, "validateGlyphsUrl");
function Et$1(r5, e = A$1) {
  let t = [];
  return t = t.concat(Vn$2({ key: "", value: r5, valueSpec: e.$root, styleSpec: e, style: r5, validateSpec: Vn$2, objectElementValidators: { glyphs: v_, "*"() {
    return [];
  } } })), r5.constants && (t = t.concat(u_({ key: "constants", value: r5.constants }))), w_(t);
}
H$3(Et$1, "validateStyleMin");
Et$1.source = qt$1(Gt$1(y_));
Et$1.sprite = qt$1(Gt$1(__));
Et$1.glyphs = qt$1(Gt$1(v_));
Et$1.light = qt$1(Gt$1(g_$1));
Et$1.sky = qt$1(Gt$1(x_));
Et$1.terrain = qt$1(Gt$1(b_$1));
Et$1.layer = qt$1(Gt$1(d_$1));
Et$1.filter = qt$1(Gt$1(mh$1));
Et$1.paintProperty = qt$1(Gt$1(f_));
Et$1.layoutProperty = qt$1(Gt$1(m_$1));
function Gt$1(r5) {
  return function(e) {
    return r5(G$1(F$1({}, e), { validateSpec: Vn$2 }));
  };
}
H$3(Gt$1, "injectValidateSpec");
function w_(r5) {
  return [].concat(r5).sort((e, t) => e.line - t.line);
}
H$3(w_, "sortErrors");
function qt$1(r5) {
  return function(...e) {
    return w_(r5.apply(this, e));
  };
}
H$3(qt$1, "wrapCleanErrors");
a();
var Ne$1 = Et$1;
Ne$1.source;
var S_ = Ne$1.light;
Ne$1.terrain;
Ne$1.filter;
var P_ = Ne$1.paintProperty, T_ = Ne$1.layoutProperty;
function Wi$1(r5, e) {
  let t = false;
  if (e && e.length) for (let i of e) r5.fire(new H$2(new Error(i.message))), t = true;
  return t;
}
H$3(Wi$1, "emitValidationErrors");
a();
a();
a();
var il$1 = class il {
  constructor(e, t, i) {
    let n4 = this.cells = [];
    if (e instanceof ArrayBuffer) {
      this.arrayBuffer = e;
      let a4 = new Int32Array(this.arrayBuffer);
      e = a4[0], t = a4[1], i = a4[2], this.d = t + 2 * i;
      for (let c = 0; c < this.d * this.d; c++) {
        let p4 = a4[3 + c], h = a4[3 + c + 1];
        n4.push(p4 === h ? null : a4.subarray(p4, h));
      }
      let s5 = a4[3 + n4.length], u5 = a4[3 + n4.length + 1];
      this.keys = a4.subarray(s5, u5), this.bboxes = a4.subarray(u5), this.insert = this._insertReadonly;
    } else {
      this.d = t + 2 * i;
      for (let a4 = 0; a4 < this.d * this.d; a4++) n4.push([]);
      this.keys = [], this.bboxes = [];
    }
    this.n = t, this.extent = e, this.padding = i, this.scale = t / e, this.uid = 0;
    let o4 = i / t * e;
    this.min = -o4, this.max = e + o4;
  }
  insert(e, t, i, n4, o4) {
    this._forEachCell(t, i, n4, o4, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(n4), this.bboxes.push(o4);
  }
  _insertReadonly() {
    throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
  }
  _insertCell(e, t, i, n4, o4, a4) {
    this.cells[o4].push(a4);
  }
  query(e, t, i, n4, o4) {
    let a4 = this.min, s5 = this.max;
    if (e <= a4 && t <= a4 && s5 <= i && s5 <= n4 && !o4) return Array.prototype.slice.call(this.keys);
    {
      let u5 = [], c = {};
      return this._forEachCell(e, t, i, n4, this._queryCell, u5, c, o4), u5;
    }
  }
  _queryCell(e, t, i, n4, o4, a4, s5, u5) {
    let c = this.cells[o4];
    if (c !== null) {
      let p4 = this.keys, h = this.bboxes;
      for (let f = 0; f < c.length; f++) {
        let m5 = c[f];
        if (s5[m5] === void 0) {
          let y4 = m5 * 4;
          (u5 ? u5(h[y4 + 0], h[y4 + 1], h[y4 + 2], h[y4 + 3]) : e <= h[y4 + 2] && t <= h[y4 + 3] && i >= h[y4 + 0] && n4 >= h[y4 + 1]) ? (s5[m5] = true, a4.push(p4[m5])) : s5[m5] = false;
        }
      }
    }
  }
  _forEachCell(e, t, i, n4, o4, a4, s5, u5) {
    let c = this._convertToCellCoord(e), p4 = this._convertToCellCoord(t), h = this._convertToCellCoord(i), f = this._convertToCellCoord(n4);
    for (let m5 = c; m5 <= h; m5++) for (let y4 = p4; y4 <= f; y4++) {
      let g = this.d * y4 + m5;
      if (!(u5 && !u5(this._convertFromCellCoord(m5), this._convertFromCellCoord(y4), this._convertFromCellCoord(m5 + 1), this._convertFromCellCoord(y4 + 1))) && o4.call(this, e, t, i, n4, g, a4, s5, u5)) return;
    }
  }
  _convertFromCellCoord(e) {
    return (e - this.padding) / this.scale;
  }
  _convertToCellCoord(e) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
  }
  toArrayBuffer() {
    if (this.arrayBuffer) return this.arrayBuffer;
    let e = this.cells, t = 3 + this.cells.length + 1 + 1, i = 0;
    for (let a4 = 0; a4 < this.cells.length; a4++) i += this.cells[a4].length;
    let n4 = new Int32Array(t + i + this.keys.length + this.bboxes.length);
    n4[0] = this.extent, n4[1] = this.n, n4[2] = this.padding;
    let o4 = t;
    for (let a4 = 0; a4 < e.length; a4++) {
      let s5 = e[a4];
      n4[3 + a4] = o4, n4.set(s5, o4), o4 += s5.length;
    }
    return n4[3 + e.length] = o4, n4.set(this.keys, o4), o4 += this.keys.length, n4[3 + e.length + 1] = o4, n4.set(this.bboxes, o4), o4 += this.bboxes.length, n4.buffer;
  }
  static serialize(e, t) {
    let i = e.toArrayBuffer();
    return t && t.push(i), { buffer: i };
  }
  static deserialize(e) {
    return new il(e.buffer);
  }
};
H$3(il$1, "TransferableGridIndex");
var oi = il$1;
var Sr$1 = {};
function N$1(r5, e, t = {}) {
  if (Sr$1[r5]) throw new Error("".concat(r5, " is already registered."));
  Object.defineProperty(e, "_classRegistryKey", { value: r5, writeable: false }), Sr$1[r5] = { klass: e, omit: t.omit || [], shallow: t.shallow || [] };
}
H$3(N$1, "register");
N$1("Object", Object);
N$1("TransferableGridIndex", oi);
N$1("Color", X$1);
N$1("Error", Error);
N$1("AJAXError", $r);
N$1("ResolvedImage", ft$1);
N$1("StylePropertyFunction", ro);
N$1("StyleExpression", ei$1, { omit: ["_evaluator"] });
N$1("ZoomDependentExpression", wr$1);
N$1("ZoomConstantExpression", vr);
N$1("CompoundExpression", Nt$1, { omit: ["_evaluate"] });
for (let r5 in ii) ii[r5]._classRegistryKey || N$1("Expression_".concat(r5), ii[r5]);
function M_(r5) {
  return r5 && typeof ArrayBuffer < "u" && (r5 instanceof ArrayBuffer || r5.constructor && r5.constructor.name === "ArrayBuffer");
}
H$3(M_, "isArrayBuffer");
function Xi$1(r5, e) {
  if (r5 == null || typeof r5 == "boolean" || typeof r5 == "number" || typeof r5 == "string" || r5 instanceof Boolean || r5 instanceof Number || r5 instanceof String || r5 instanceof Date || r5 instanceof RegExp || r5 instanceof Blob || r5 instanceof Error) return r5;
  if (M_(r5) || ht$1(r5)) return e && e.push(r5), r5;
  if (ArrayBuffer.isView(r5)) {
    let t = r5;
    return e && e.push(t.buffer), t;
  }
  if (r5 instanceof ImageData) return e && e.push(r5.data.buffer), r5;
  if (Array.isArray(r5)) {
    let t = [];
    for (let i of r5) t.push(Xi$1(i, e));
    return t;
  }
  if (typeof r5 == "object") {
    let t = r5.constructor, i = t._classRegistryKey;
    if (!i) throw new Error("can't serialize object of unregistered class ".concat(t.name));
    if (!Sr$1[i]) throw new Error("".concat(i, " is not registered."));
    let n4 = t.serialize ? t.serialize(r5, e) : {};
    if (t.serialize) {
      if (e && n4 === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
    } else {
      for (let o4 in r5) {
        if (!r5.hasOwnProperty(o4) || Sr$1[i].omit.indexOf(o4) >= 0) continue;
        let a4 = r5[o4];
        n4[o4] = Sr$1[i].shallow.indexOf(o4) >= 0 ? a4 : Xi$1(a4, e);
      }
      r5 instanceof Error && (n4.message = r5.message);
    }
    if (n4.$name) throw new Error("$name property is reserved for worker serialization logic.");
    return i !== "Object" && (n4.$name = i), n4;
  }
  throw new Error("can't serialize object of type ".concat(typeof r5));
}
H$3(Xi$1, "serialize");
function Ki(r5) {
  if (r5 == null || typeof r5 == "boolean" || typeof r5 == "number" || typeof r5 == "string" || r5 instanceof Boolean || r5 instanceof Number || r5 instanceof String || r5 instanceof Date || r5 instanceof RegExp || r5 instanceof Blob || r5 instanceof Error || M_(r5) || ht$1(r5) || ArrayBuffer.isView(r5) || r5 instanceof ImageData) return r5;
  if (Array.isArray(r5)) return r5.map(Ki);
  if (typeof r5 == "object") {
    let e = r5.$name || "Object";
    if (!Sr$1[e]) throw new Error("can't deserialize unregistered class ".concat(e));
    let { klass: t } = Sr$1[e];
    if (!t) throw new Error("can't deserialize unregistered class ".concat(e));
    if (t.deserialize) return t.deserialize(r5);
    let i = Object.create(t.prototype);
    for (let n4 of Object.keys(r5)) {
      if (n4 === "$name") continue;
      let o4 = r5[n4];
      i[n4] = Sr$1[e].shallow.indexOf(n4) >= 0 ? o4 : Ki(o4);
    }
    return i;
  }
  throw new Error("can't deserialize object of type ".concat(typeof r5));
}
H$3(Ki, "deserialize");
a();
a();
var Mh$1 = class Mh2 {
  constructor() {
    this.first = true;
  }
  update(e, t) {
    let i = Math.floor(e);
    return this.first ? (this.first = false, this.lastIntegerZoom = i, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = i, true) : (this.lastFloorZoom > i ? (this.lastIntegerZoom = i + 1, this.lastIntegerZoomTime = t) : this.lastFloorZoom < i && (this.lastIntegerZoom = i, this.lastIntegerZoomTime = t), e !== this.lastZoom ? (this.lastZoom = e, this.lastFloorZoom = i, true) : false);
  }
};
H$3(Mh$1, "ZoomHistory");
var Ji = Mh$1;
a();
a();
var he$1 = { "Latin-1 Supplement": H$3((r5) => r5 >= 128 && r5 <= 255, "Latin-1 Supplement"), Arabic: H$3((r5) => r5 >= 1536 && r5 <= 1791, "Arabic"), "Arabic Supplement": H$3((r5) => r5 >= 1872 && r5 <= 1919, "Arabic Supplement"), "Arabic Extended-A": H$3((r5) => r5 >= 2208 && r5 <= 2303, "Arabic Extended-A"), "Hangul Jamo": H$3((r5) => r5 >= 4352 && r5 <= 4607, "Hangul Jamo"), "Unified Canadian Aboriginal Syllabics": H$3((r5) => r5 >= 5120 && r5 <= 5759, "Unified Canadian Aboriginal Syllabics"), Khmer: H$3((r5) => r5 >= 6016 && r5 <= 6143, "Khmer"), "Unified Canadian Aboriginal Syllabics Extended": H$3((r5) => r5 >= 6320 && r5 <= 6399, "Unified Canadian Aboriginal Syllabics Extended"), "General Punctuation": H$3((r5) => r5 >= 8192 && r5 <= 8303, "General Punctuation"), "Letterlike Symbols": H$3((r5) => r5 >= 8448 && r5 <= 8527, "Letterlike Symbols"), "Number Forms": H$3((r5) => r5 >= 8528 && r5 <= 8591, "Number Forms"), "Miscellaneous Technical": H$3((r5) => r5 >= 8960 && r5 <= 9215, "Miscellaneous Technical"), "Control Pictures": H$3((r5) => r5 >= 9216 && r5 <= 9279, "Control Pictures"), "Optical Character Recognition": H$3((r5) => r5 >= 9280 && r5 <= 9311, "Optical Character Recognition"), "Enclosed Alphanumerics": H$3((r5) => r5 >= 9312 && r5 <= 9471, "Enclosed Alphanumerics"), "Geometric Shapes": H$3((r5) => r5 >= 9632 && r5 <= 9727, "Geometric Shapes"), "Miscellaneous Symbols": H$3((r5) => r5 >= 9728 && r5 <= 9983, "Miscellaneous Symbols"), "Miscellaneous Symbols and Arrows": H$3((r5) => r5 >= 11008 && r5 <= 11263, "Miscellaneous Symbols and Arrows"), "CJK Radicals Supplement": H$3((r5) => r5 >= 11904 && r5 <= 12031, "CJK Radicals Supplement"), "Kangxi Radicals": H$3((r5) => r5 >= 12032 && r5 <= 12255, "Kangxi Radicals"), "Ideographic Description Characters": H$3((r5) => r5 >= 12272 && r5 <= 12287, "Ideographic Description Characters"), "CJK Symbols and Punctuation": H$3((r5) => r5 >= 12288 && r5 <= 12351, "CJK Symbols and Punctuation"), Hiragana: H$3((r5) => r5 >= 12352 && r5 <= 12447, "Hiragana"), Katakana: H$3((r5) => r5 >= 12448 && r5 <= 12543, "Katakana"), Bopomofo: H$3((r5) => r5 >= 12544 && r5 <= 12591, "Bopomofo"), "Hangul Compatibility Jamo": H$3((r5) => r5 >= 12592 && r5 <= 12687, "Hangul Compatibility Jamo"), Kanbun: H$3((r5) => r5 >= 12688 && r5 <= 12703, "Kanbun"), "Bopomofo Extended": H$3((r5) => r5 >= 12704 && r5 <= 12735, "Bopomofo Extended"), "CJK Strokes": H$3((r5) => r5 >= 12736 && r5 <= 12783, "CJK Strokes"), "Katakana Phonetic Extensions": H$3((r5) => r5 >= 12784 && r5 <= 12799, "Katakana Phonetic Extensions"), "Enclosed CJK Letters and Months": H$3((r5) => r5 >= 12800 && r5 <= 13055, "Enclosed CJK Letters and Months"), "CJK Compatibility": H$3((r5) => r5 >= 13056 && r5 <= 13311, "CJK Compatibility"), "CJK Unified Ideographs Extension A": H$3((r5) => r5 >= 13312 && r5 <= 19903, "CJK Unified Ideographs Extension A"), "Yijing Hexagram Symbols": H$3((r5) => r5 >= 19904 && r5 <= 19967, "Yijing Hexagram Symbols"), "CJK Unified Ideographs": H$3((r5) => r5 >= 19968 && r5 <= 40959, "CJK Unified Ideographs"), "Yi Syllables": H$3((r5) => r5 >= 40960 && r5 <= 42127, "Yi Syllables"), "Yi Radicals": H$3((r5) => r5 >= 42128 && r5 <= 42191, "Yi Radicals"), "Hangul Jamo Extended-A": H$3((r5) => r5 >= 43360 && r5 <= 43391, "Hangul Jamo Extended-A"), "Hangul Syllables": H$3((r5) => r5 >= 44032 && r5 <= 55215, "Hangul Syllables"), "Hangul Jamo Extended-B": H$3((r5) => r5 >= 55216 && r5 <= 55295, "Hangul Jamo Extended-B"), "Private Use Area": H$3((r5) => r5 >= 57344 && r5 <= 63743, "Private Use Area"), "CJK Compatibility Ideographs": H$3((r5) => r5 >= 63744 && r5 <= 64255, "CJK Compatibility Ideographs"), "Arabic Presentation Forms-A": H$3((r5) => r5 >= 64336 && r5 <= 65023, "Arabic Presentation Forms-A"), "Vertical Forms": H$3((r5) => r5 >= 65040 && r5 <= 65055, "Vertical Forms"), "CJK Compatibility Forms": H$3((r5) => r5 >= 65072 && r5 <= 65103, "CJK Compatibility Forms"), "Small Form Variants": H$3((r5) => r5 >= 65104 && r5 <= 65135, "Small Form Variants"), "Arabic Presentation Forms-B": H$3((r5) => r5 >= 65136 && r5 <= 65279, "Arabic Presentation Forms-B"), "Halfwidth and Fullwidth Forms": H$3((r5) => r5 >= 65280 && r5 <= 65519, "Halfwidth and Fullwidth Forms") };
function Ah$1(r5) {
  for (let e of r5) if (A_(e.charCodeAt(0))) return true;
  return false;
}
H$3(Ah$1, "allowsVerticalWritingMode");
function A_(r5) {
  return r5 === 746 || r5 === 747 ? true : r5 < 4352 ? false : !!(he$1["Bopomofo Extended"](r5) || he$1.Bopomofo(r5) || he$1["CJK Compatibility Forms"](r5) && !(r5 >= 65097 && r5 <= 65103) || he$1["CJK Compatibility Ideographs"](r5) || he$1["CJK Compatibility"](r5) || he$1["CJK Radicals Supplement"](r5) || he$1["CJK Strokes"](r5) || he$1["CJK Symbols and Punctuation"](r5) && !(r5 >= 12296 && r5 <= 12305) && !(r5 >= 12308 && r5 <= 12319) && r5 !== 12336 || he$1["CJK Unified Ideographs Extension A"](r5) || he$1["CJK Unified Ideographs"](r5) || he$1["Enclosed CJK Letters and Months"](r5) || he$1["Hangul Compatibility Jamo"](r5) || he$1["Hangul Jamo Extended-A"](r5) || he$1["Hangul Jamo Extended-B"](r5) || he$1["Hangul Jamo"](r5) || he$1["Hangul Syllables"](r5) || he$1.Hiragana(r5) || he$1["Ideographic Description Characters"](r5) || he$1.Kanbun(r5) || he$1["Kangxi Radicals"](r5) || he$1["Katakana Phonetic Extensions"](r5) || he$1.Katakana(r5) && r5 !== 12540 || he$1["Halfwidth and Fullwidth Forms"](r5) && r5 !== 65288 && r5 !== 65289 && r5 !== 65293 && !(r5 >= 65306 && r5 <= 65310) && r5 !== 65339 && r5 !== 65341 && r5 !== 65343 && !(r5 >= 65371 && r5 <= 65503) && r5 !== 65507 && !(r5 >= 65512 && r5 <= 65519) || he$1["Small Form Variants"](r5) && !(r5 >= 65112 && r5 <= 65118) && !(r5 >= 65123 && r5 <= 65126) || he$1["Unified Canadian Aboriginal Syllabics"](r5) || he$1["Unified Canadian Aboriginal Syllabics Extended"](r5) || he$1["Vertical Forms"](r5) || he$1["Yijing Hexagram Symbols"](r5) || he$1["Yi Syllables"](r5) || he$1["Yi Radicals"](r5));
}
H$3(A_, "charHasUprightVerticalOrientation");
function I_(r5) {
  return r5 >= 1424 && r5 <= 2303 || he$1["Arabic Presentation Forms-A"](r5) || he$1["Arabic Presentation Forms-B"](r5);
}
H$3(I_, "charInRTLScript");
function oM$1(r5, e) {
  return !(!e && I_(r5) || r5 >= 2304 && r5 <= 3583 || r5 >= 3840 && r5 <= 4255 || he$1.Khmer(r5));
}
H$3(oM$1, "charInSupportedScript");
function C_(r5) {
  for (let e of r5) if (I_(e.charCodeAt(0))) return true;
  return false;
}
H$3(C_, "stringContainsRTLText");
function E_(r5, e) {
  for (let t of r5) if (!oM$1(t.charCodeAt(0), e)) return false;
  return true;
}
H$3(E_, "isStringInSupportedScript");
a();
var Ch$1 = class Ch2 {
  constructor() {
    this.applyArabicShaping = null;
    this.processBidirectionalText = null;
    this.processStyledBidirectionalText = null;
    this.pluginStatus = "unavailable";
    this.pluginURL = null;
  }
  setState(e) {
    this.pluginStatus = e.pluginStatus, this.pluginURL = e.pluginURL;
  }
  getState() {
    return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
  }
  setMethods(e) {
    this.applyArabicShaping = e.applyArabicShaping, this.processBidirectionalText = e.processBidirectionalText, this.processStyledBidirectionalText = e.processStyledBidirectionalText;
  }
  isParsed() {
    return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
  }
  getPluginURL() {
    return this.pluginURL;
  }
  getRTLTextPluginStatus() {
    return this.pluginStatus;
  }
};
H$3(Ch$1, "RTLWorkerPlugin");
var Ih$1 = Ch$1, or$1 = new Ih$1();
var Eh$1 = class Eh2 {
  constructor(e, t) {
    this.zoom = e, t ? (this.now = t.now, this.fadeDuration = t.fadeDuration, this.zoomHistory = t.zoomHistory, this.transition = t.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ji(), this.transition = {});
  }
  isSupportedScript(e) {
    return E_(e, or$1.getRTLTextPluginStatus() === "loaded");
  }
  crossFadingFactor() {
    return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
  }
  getCrossfadeParameters() {
    let e = this.zoom, t = e - Math.floor(e), i = this.crossFadingFactor();
    return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: t + (1 - t) * i } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - i) * t };
  }
};
H$3(Eh$1, "EvaluationParameters");
var ye = Eh$1;
var kh2 = class kh3 {
  constructor(e, t) {
    this.property = e, this.value = t, this.expression = a_(t === void 0 ? e.specification.default : t, e.specification);
  }
  isDataDriven() {
    return this.expression.kind === "source" || this.expression.kind === "composite";
  }
  possiblyEvaluate(e, t, i) {
    return this.property.possiblyEvaluate(this, e, t, i);
  }
};
H$3(kh2, "PropertyValue");
var Yi$1 = kh2, Lh2 = class Lh3 {
  constructor(e) {
    this.property = e, this.value = new Yi$1(e, void 0);
  }
  transitioned(e, t) {
    return new nl$1(this.property, this.value, t, V$1({}, e.transition, this.transition), e.now);
  }
  untransitioned() {
    return new nl$1(this.property, this.value, null, {}, 0);
  }
};
H$3(Lh2, "TransitionablePropertyValue");
var lo$1 = Lh2, Dh2 = class Dh3 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
  }
  getValue(e) {
    return pt$1(this._values[e].value.value);
  }
  setValue(e, t) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new lo$1(this._values[e].property)), this._values[e].value = new Yi$1(this._values[e].property, t === null ? void 0 : pt$1(t));
  }
  getTransition(e) {
    return pt$1(this._values[e].transition);
  }
  setTransition(e, t) {
    Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new lo$1(this._values[e].property)), this._values[e].transition = pt$1(t) || void 0;
  }
  serialize() {
    let e = {};
    for (let t of Object.keys(this._values)) {
      let i = this.getValue(t);
      i !== void 0 && (e[t] = i);
      let n4 = this.getTransition(t);
      n4 !== void 0 && (e["".concat(t, "-transition")] = n4);
    }
    return e;
  }
  transitioned(e, t) {
    let i = new ol$1(this._properties);
    for (let n4 of Object.keys(this._values)) i._values[n4] = this._values[n4].transitioned(e, t._values[n4]);
    return i;
  }
  untransitioned() {
    let e = new ol$1(this._properties);
    for (let t of Object.keys(this._values)) e._values[t] = this._values[t].untransitioned();
    return e;
  }
};
H$3(Dh2, "Transitionable");
var Qi = Dh2, zh$1 = class zh2 {
  constructor(e, t, i, n4, o4) {
    this.property = e, this.value = t, this.begin = o4 + n4.delay || 0, this.end = this.begin + n4.duration || 0, e.specification.transition && (n4.delay || n4.duration) && (this.prior = i);
  }
  possiblyEvaluate(e, t, i) {
    let n4 = e.now || 0, o4 = this.value.possiblyEvaluate(e, t, i), a4 = this.prior;
    if (a4) {
      if (n4 > this.end) return this.prior = null, o4;
      if (this.value.isDataDriven()) return this.prior = null, o4;
      if (n4 < this.begin) return a4.possiblyEvaluate(e, t, i);
      {
        let s5 = (n4 - this.begin) / (this.end - this.begin);
        return this.property.interpolate(a4.possiblyEvaluate(e, t, i), o4, Kx$1(s5));
      }
    } else return o4;
  }
};
H$3(zh$1, "TransitioningPropertyValue");
var nl$1 = zh$1, Fh$1 = class Fh2 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
  }
  possiblyEvaluate(e, t, i) {
    let n4 = new Pr$2(this._properties);
    for (let o4 of Object.keys(this._values)) n4._values[o4] = this._values[o4].possiblyEvaluate(e, t, i);
    return n4;
  }
  hasTransition() {
    for (let e of Object.keys(this._values)) if (this._values[e].prior) return true;
    return false;
  }
};
H$3(Fh$1, "Transitioning");
var ol$1 = Fh$1, Rh$1 = class Rh2 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPropertyValues);
  }
  hasValue(e) {
    return this._values[e].value !== void 0;
  }
  getValue(e) {
    return pt$1(this._values[e].value);
  }
  setValue(e, t) {
    this._values[e] = new Yi$1(this._values[e].property, t === null ? void 0 : pt$1(t));
  }
  serialize() {
    let e = {};
    for (let t of Object.keys(this._values)) {
      let i = this.getValue(t);
      i !== void 0 && (e[t] = i);
    }
    return e;
  }
  possiblyEvaluate(e, t, i) {
    let n4 = new Pr$2(this._properties);
    for (let o4 of Object.keys(this._values)) n4._values[o4] = this._values[o4].possiblyEvaluate(e, t, i);
    return n4;
  }
};
H$3(Rh$1, "Layout");
var al$1 = Rh$1, Bh$1 = class Bh2 {
  constructor(e, t, i) {
    this.property = e, this.value = t, this.parameters = i;
  }
  isConstant() {
    return this.value.kind === "constant";
  }
  constantOr(e) {
    return this.value.kind === "constant" ? this.value.value : e;
  }
  evaluate(e, t, i, n4) {
    return this.property.evaluate(this.value, this.parameters, e, t, i, n4);
  }
};
H$3(Bh$1, "PossiblyEvaluatedPropertyValue");
var at$1 = Bh$1, Oh2 = class Oh3 {
  constructor(e) {
    this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
  }
  get(e) {
    return this._values[e];
  }
};
H$3(Oh2, "PossiblyEvaluated");
var Pr$2 = Oh2, Vh2 = class Vh3 {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t) {
    if (e.isDataDriven()) throw new Error("Value should not be data driven");
    return e.expression.evaluate(t);
  }
  interpolate(e, t, i) {
    let n4 = this.specification.type, o4 = Pe$2[n4];
    return o4 ? o4(e, t, i) : e;
  }
};
H$3(Vh2, "DataConstantProperty");
var Z$2 = Vh2, Uh$1 = class Uh2 {
  constructor(e, t) {
    this.specification = e, this.overrides = t;
  }
  possiblyEvaluate(e, t, i, n4) {
    return e.expression.kind === "constant" || e.expression.kind === "camera" ? new at$1(this, { kind: "constant", value: e.expression.evaluate(t, null, {}, i, n4) }, t) : new at$1(this, e.expression, t);
  }
  interpolate(e, t, i) {
    if (e.value.kind !== "constant" || t.value.kind !== "constant") return e;
    if (e.value.value === void 0 || t.value.value === void 0) return new at$1(this, { kind: "constant", value: void 0 }, e.parameters);
    let n4 = this.specification.type, o4 = Pe$2[n4];
    if (o4) {
      let a4 = o4(e.value.value, t.value.value, i);
      return new at$1(this, { kind: "constant", value: a4 }, e.parameters);
    } else return e;
  }
  evaluate(e, t, i, n4, o4, a4) {
    return e.kind === "constant" ? e.value : e.evaluate(t, i, n4, o4, a4);
  }
};
H$3(Uh$1, "DataDrivenProperty");
var $ = Uh$1, Nh2 = class Nh3 extends $ {
  possiblyEvaluate(e, t, i, n4) {
    if (e.value === void 0) return new at$1(this, { kind: "constant", value: void 0 }, t);
    if (e.expression.kind === "constant") {
      let o4 = e.expression.evaluate(t, null, {}, i, n4), s5 = e.property.specification.type === "resolvedImage" && typeof o4 != "string" ? o4.name : o4, u5 = this._calculate(s5, s5, s5, t);
      return new at$1(this, { kind: "constant", value: u5 }, t);
    } else if (e.expression.kind === "camera") {
      let o4 = this._calculate(e.expression.evaluate({ zoom: t.zoom - 1 }), e.expression.evaluate({ zoom: t.zoom }), e.expression.evaluate({ zoom: t.zoom + 1 }), t);
      return new at$1(this, { kind: "constant", value: o4 }, t);
    } else return new at$1(this, e.expression, t);
  }
  evaluate(e, t, i, n4, o4, a4) {
    if (e.kind === "source") {
      let s5 = e.evaluate(t, i, n4, o4, a4);
      return this._calculate(s5, s5, s5, t);
    } else return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(t.zoom) - 1 }, i, n4), e.evaluate({ zoom: Math.floor(t.zoom) }, i, n4), e.evaluate({ zoom: Math.floor(t.zoom) + 1 }, i, n4), t) : e.value;
  }
  _calculate(e, t, i, n4) {
    return n4.zoom > n4.zoomHistory.lastIntegerZoom ? { from: e, to: t } : { from: i, to: t };
  }
  interpolate(e) {
    return e;
  }
};
H$3(Nh2, "CrossFadedDataDrivenProperty");
var ar = Nh2, Gh2 = class Gh3 {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t, i, n4) {
    if (e.value !== void 0) if (e.expression.kind === "constant") {
      let o4 = e.expression.evaluate(t, null, {}, i, n4);
      return this._calculate(o4, o4, o4, t);
    } else return this._calculate(e.expression.evaluate(new ye(Math.floor(t.zoom - 1), t)), e.expression.evaluate(new ye(Math.floor(t.zoom), t)), e.expression.evaluate(new ye(Math.floor(t.zoom + 1), t)), t);
  }
  _calculate(e, t, i, n4) {
    return n4.zoom > n4.zoomHistory.lastIntegerZoom ? { from: e, to: t } : { from: i, to: t };
  }
  interpolate(e) {
    return e;
  }
};
H$3(Gh2, "CrossFadedProperty");
var ai = Gh2, qh$1 = class qh2 {
  constructor(e) {
    this.specification = e;
  }
  possiblyEvaluate(e, t, i, n4) {
    return !!e.expression.evaluate(t, null, {}, i, n4);
  }
  interpolate() {
    return false;
  }
};
H$3(qh$1, "ColorRampProperty");
var si$1 = qh$1, jh2 = class jh3 {
  constructor(e) {
    this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
    for (let t in e) {
      let i = e[t];
      i.specification.overridable && this.overridableProperties.push(t);
      let n4 = this.defaultPropertyValues[t] = new Yi$1(i, void 0), o4 = this.defaultTransitionablePropertyValues[t] = new lo$1(i);
      this.defaultTransitioningPropertyValues[t] = o4.untransitioned(), this.defaultPossiblyEvaluatedValues[t] = n4.possiblyEvaluate({});
    }
  }
};
H$3(jh2, "Properties");
var De$2 = jh2;
N$1("DataDrivenProperty", $);
N$1("DataConstantProperty", Z$2);
N$1("CrossFadedDataDrivenProperty", ar);
N$1("CrossFadedProperty", ai);
N$1("ColorRampProperty", si$1);
var sl$1 = "-transition", Zh$1 = class Zh2 extends de$1 {
  constructor(e, t) {
    if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: H$3(() => true, "filter"), needGeometry: false }, e.type !== "custom" && (e = e, this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), t.layout && (this._unevaluatedLayout = new al$1(t.layout)), t.paint)) {
      this._transitionablePaint = new Qi(t.paint);
      for (let i in e.paint) this.setPaintProperty(i, e.paint[i], { validate: false });
      for (let i in e.layout) this.setLayoutProperty(i, e.layout[i], { validate: false });
      this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Pr$2(t.paint);
    }
  }
  getCrossfadeParameters() {
    return this._crossfadeParameters;
  }
  getLayoutProperty(e) {
    return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
  }
  setLayoutProperty(e, t, i = {}) {
    if (t != null) {
      let n4 = "layers.".concat(this.id, ".layout.").concat(e);
      if (this._validate(T_, n4, e, t, i)) return;
    }
    if (e === "visibility") {
      this.visibility = t;
      return;
    }
    this._unevaluatedLayout.setValue(e, t);
  }
  getPaintProperty(e) {
    return e.endsWith(sl$1) ? this._transitionablePaint.getTransition(e.slice(0, -sl$1.length)) : this._transitionablePaint.getValue(e);
  }
  setPaintProperty(e, t, i = {}) {
    if (t != null) {
      let n4 = "layers.".concat(this.id, ".paint.").concat(e);
      if (this._validate(P_, n4, e, t, i)) return false;
    }
    if (e.endsWith(sl$1)) return this._transitionablePaint.setTransition(e.slice(0, -sl$1.length), t || void 0), false;
    {
      let n4 = this._transitionablePaint._values[e], o4 = n4.property.specification["property-type"] === "cross-faded-data-driven", a4 = n4.value.isDataDriven(), s5 = n4.value;
      this._transitionablePaint.setValue(e, t), this._handleSpecialPaintPropertyUpdate(e);
      let u5 = this._transitionablePaint._values[e].value;
      return u5.isDataDriven() || a4 || o4 || this._handleOverridablePaintPropertyUpdate(e, s5, u5);
    }
  }
  _handleSpecialPaintPropertyUpdate(e) {
  }
  _handleOverridablePaintPropertyUpdate(e, t, i) {
    return false;
  }
  isHidden(e) {
    return this.minzoom && e < this.minzoom || this.maxzoom && e >= this.maxzoom ? true : this.visibility === "none";
  }
  updateTransitions(e) {
    this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
  }
  hasTransition() {
    return this._transitioningPaint.hasTransition();
  }
  recalculate(e, t) {
    e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t);
  }
  serialize() {
    let e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
    return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), os$1(e, (t, i) => t !== void 0 && !(i === "layout" && !Object.keys(t).length) && !(i === "paint" && !Object.keys(t).length));
  }
  _validate(e, t, i, n4, o4 = {}) {
    return o4 && o4.validate === false ? false : Wi$1(this, e.call(Ne$1, { key: t, layerType: this.type, objectKey: i, value: n4, styleSpec: A$1, style: { glyphs: true, sprite: true } }));
  }
  is3D() {
    return false;
  }
  isTileClipped() {
    return false;
  }
  hasOffscreenPass() {
    return false;
  }
  resize() {
  }
  isStateDependent() {
    for (let e in this.paint._values) {
      let t = this.paint.get(e);
      if (!(!(t instanceof at$1) || !_r$1(t.property.specification)) && (t.value.kind === "source" || t.value.kind === "composite") && t.value.isStateDependent) return true;
    }
    return false;
  }
};
H$3(Zh$1, "StyleLayer");
var Ge$1 = Zh$1;
a();
a();
a();
var aM$1 = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Hh$1 = class Hh2 {
  constructor(e, t) {
    this._structArray = e, this._pos1 = t * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
  }
};
H$3(Hh$1, "Struct");
var Tr = Hh$1, sM$1 = 128, lM$1 = 5, $h$1 = class $h2 {
  constructor() {
    this.isTransferred = false, this.capacity = -1, this.resize(0);
  }
  static serialize(e, t) {
    return e._trim(), t && (e.isTransferred = true, t.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
  }
  static deserialize(e) {
    let t = Object.create(this.prototype);
    return t.arrayBuffer = e.arrayBuffer, t.length = e.length, t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement, t._refreshViews(), t;
  }
  _trim() {
    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
  }
  clear() {
    this.length = 0;
  }
  resize(e) {
    this.reserve(e), this.length = e;
  }
  reserve(e) {
    if (e > this.capacity) {
      this.capacity = Math.max(e, Math.floor(this.capacity * lM$1), sM$1), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
      let t = this.uint8;
      this._refreshViews(), t && this.uint8.set(t);
    }
  }
  _refreshViews() {
    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
  }
};
H$3($h$1, "StructArray");
var ze = $h$1;
function _e$1(r5, e = 1) {
  let t = 0, i = 0, n4 = r5.map((a4) => {
    let s5 = uM$1(a4.type), u5 = t = k_(t, Math.max(e, s5)), c = a4.components || 1;
    return i = Math.max(i, s5), t += s5 * c, { name: a4.name, type: a4.type, components: c, offset: u5 };
  }), o4 = k_(t, Math.max(i, e));
  return { members: n4, size: o4, alignment: e };
}
H$3(_e$1, "createLayout");
function uM$1(r5) {
  return aM$1[r5].BYTES_PER_ELEMENT;
}
H$3(uM$1, "sizeOf");
function k_(r5, e) {
  return Math.ceil(r5 / e) * e;
}
H$3(k_, "align");
var L_ = N$2(ge(), 1);
var Wh$1 = class Wh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t);
  }
  emplace(e, t, i) {
    let n4 = e * 2;
    return this.int16[n4 + 0] = t, this.int16[n4 + 1] = i, e;
  }
};
H$3(Wh$1, "StructArrayLayout2i4");
var li$1 = Wh$1;
li$1.prototype.bytesPerElement = 4;
N$1("StructArrayLayout2i4", li$1);
var Xh$1 = class Xh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n4 = this.length;
    return this.resize(n4 + 1), this.emplace(n4, e, t, i);
  }
  emplace(e, t, i, n4) {
    let o4 = e * 3;
    return this.int16[o4 + 0] = t, this.int16[o4 + 1] = i, this.int16[o4 + 2] = n4, e;
  }
};
H$3(Xh$1, "StructArrayLayout3i6");
var en = Xh$1;
en.prototype.bytesPerElement = 6;
N$1("StructArrayLayout3i6", en);
var Kh$1 = class Kh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4) {
    let o4 = this.length;
    return this.resize(o4 + 1), this.emplace(o4, e, t, i, n4);
  }
  emplace(e, t, i, n4, o4) {
    let a4 = e * 4;
    return this.int16[a4 + 0] = t, this.int16[a4 + 1] = i, this.int16[a4 + 2] = n4, this.int16[a4 + 3] = o4, e;
  }
};
H$3(Kh$1, "StructArrayLayout4i8");
var uo$1 = Kh$1;
uo$1.prototype.bytesPerElement = 8;
N$1("StructArrayLayout4i8", uo$1);
var Jh$1 = class Jh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4) {
    let s5 = this.length;
    return this.resize(s5 + 1), this.emplace(s5, e, t, i, n4, o4, a4);
  }
  emplace(e, t, i, n4, o4, a4, s5) {
    let u5 = e * 6;
    return this.int16[u5 + 0] = t, this.int16[u5 + 1] = i, this.int16[u5 + 2] = n4, this.int16[u5 + 3] = o4, this.int16[u5 + 4] = a4, this.int16[u5 + 5] = s5, e;
  }
};
H$3(Jh$1, "StructArrayLayout2i4i12");
var co = Jh$1;
co.prototype.bytesPerElement = 12;
N$1("StructArrayLayout2i4i12", co);
var Yh$1 = class Yh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4) {
    let s5 = this.length;
    return this.resize(s5 + 1), this.emplace(s5, e, t, i, n4, o4, a4);
  }
  emplace(e, t, i, n4, o4, a4, s5) {
    let u5 = e * 4, c = e * 8;
    return this.int16[u5 + 0] = t, this.int16[u5 + 1] = i, this.uint8[c + 4] = n4, this.uint8[c + 5] = o4, this.uint8[c + 6] = a4, this.uint8[c + 7] = s5, e;
  }
};
H$3(Yh$1, "StructArrayLayout2i4ub8");
var po = Yh$1;
po.prototype.bytesPerElement = 8;
N$1("StructArrayLayout2i4ub8", po);
var Qh$1 = class Qh2 extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t);
  }
  emplace(e, t, i) {
    let n4 = e * 2;
    return this.float32[n4 + 0] = t, this.float32[n4 + 1] = i, e;
  }
};
H$3(Qh$1, "StructArrayLayout2f8");
var Mr = Qh$1;
Mr.prototype.bytesPerElement = 8;
N$1("StructArrayLayout2f8", Mr);
var ef$1 = class ef extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4, s5, u5, c, p4) {
    let h = this.length;
    return this.resize(h + 1), this.emplace(h, e, t, i, n4, o4, a4, s5, u5, c, p4);
  }
  emplace(e, t, i, n4, o4, a4, s5, u5, c, p4, h) {
    let f = e * 10;
    return this.uint16[f + 0] = t, this.uint16[f + 1] = i, this.uint16[f + 2] = n4, this.uint16[f + 3] = o4, this.uint16[f + 4] = a4, this.uint16[f + 5] = s5, this.uint16[f + 6] = u5, this.uint16[f + 7] = c, this.uint16[f + 8] = p4, this.uint16[f + 9] = h, e;
  }
};
H$3(ef$1, "StructArrayLayout10ui20");
var ho = ef$1;
ho.prototype.bytesPerElement = 20;
N$1("StructArrayLayout10ui20", ho);
var tf$1 = class tf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f) {
    let m5 = this.length;
    return this.resize(m5 + 1), this.emplace(m5, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f);
  }
  emplace(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5) {
    let y4 = e * 12;
    return this.int16[y4 + 0] = t, this.int16[y4 + 1] = i, this.int16[y4 + 2] = n4, this.int16[y4 + 3] = o4, this.uint16[y4 + 4] = a4, this.uint16[y4 + 5] = s5, this.uint16[y4 + 6] = u5, this.uint16[y4 + 7] = c, this.int16[y4 + 8] = p4, this.int16[y4 + 9] = h, this.int16[y4 + 10] = f, this.int16[y4 + 11] = m5, e;
  }
};
H$3(tf$1, "StructArrayLayout4i4ui4i24");
var fo = tf$1;
fo.prototype.bytesPerElement = 24;
N$1("StructArrayLayout4i4ui4i24", fo);
var rf$1 = class rf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n4 = this.length;
    return this.resize(n4 + 1), this.emplace(n4, e, t, i);
  }
  emplace(e, t, i, n4) {
    let o4 = e * 3;
    return this.float32[o4 + 0] = t, this.float32[o4 + 1] = i, this.float32[o4 + 2] = n4, e;
  }
};
H$3(rf$1, "StructArrayLayout3f12");
var mo = rf$1;
mo.prototype.bytesPerElement = 12;
N$1("StructArrayLayout3f12", mo);
var nf$1 = class nf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t = this.length;
    return this.resize(t + 1), this.emplace(t, e);
  }
  emplace(e, t) {
    let i = e * 1;
    return this.uint32[i + 0] = t, e;
  }
};
H$3(nf$1, "StructArrayLayout1ul4");
var yo = nf$1;
yo.prototype.bytesPerElement = 4;
N$1("StructArrayLayout1ul4", yo);
var of$1 = class of extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4, s5, u5, c) {
    let p4 = this.length;
    return this.resize(p4 + 1), this.emplace(p4, e, t, i, n4, o4, a4, s5, u5, c);
  }
  emplace(e, t, i, n4, o4, a4, s5, u5, c, p4) {
    let h = e * 10, f = e * 5;
    return this.int16[h + 0] = t, this.int16[h + 1] = i, this.int16[h + 2] = n4, this.int16[h + 3] = o4, this.int16[h + 4] = a4, this.int16[h + 5] = s5, this.uint32[f + 3] = u5, this.uint16[h + 8] = c, this.uint16[h + 9] = p4, e;
  }
};
H$3(of$1, "StructArrayLayout6i1ul2ui20");
var go = of$1;
go.prototype.bytesPerElement = 20;
N$1("StructArrayLayout6i1ul2ui20", go);
var af$1 = class af extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4) {
    let s5 = this.length;
    return this.resize(s5 + 1), this.emplace(s5, e, t, i, n4, o4, a4);
  }
  emplace(e, t, i, n4, o4, a4, s5) {
    let u5 = e * 6;
    return this.int16[u5 + 0] = t, this.int16[u5 + 1] = i, this.int16[u5 + 2] = n4, this.int16[u5 + 3] = o4, this.int16[u5 + 4] = a4, this.int16[u5 + 5] = s5, e;
  }
};
H$3(af$1, "StructArrayLayout2i2i2i12");
var xo$1 = af$1;
xo$1.prototype.bytesPerElement = 12;
N$1("StructArrayLayout2i2i2i12", xo$1);
var sf$1 = class sf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4) {
    let a4 = this.length;
    return this.resize(a4 + 1), this.emplace(a4, e, t, i, n4, o4);
  }
  emplace(e, t, i, n4, o4, a4) {
    let s5 = e * 4, u5 = e * 8;
    return this.float32[s5 + 0] = t, this.float32[s5 + 1] = i, this.float32[s5 + 2] = n4, this.int16[u5 + 6] = o4, this.int16[u5 + 7] = a4, e;
  }
};
H$3(sf$1, "StructArrayLayout2f1f2i16");
var bo = sf$1;
bo.prototype.bytesPerElement = 16;
N$1("StructArrayLayout2f1f2i16", bo);
var lf$1 = class lf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4) {
    let o4 = this.length;
    return this.resize(o4 + 1), this.emplace(o4, e, t, i, n4);
  }
  emplace(e, t, i, n4, o4) {
    let a4 = e * 12, s5 = e * 3;
    return this.uint8[a4 + 0] = t, this.uint8[a4 + 1] = i, this.float32[s5 + 1] = n4, this.float32[s5 + 2] = o4, e;
  }
};
H$3(lf$1, "StructArrayLayout2ub2f12");
var _o$1 = lf$1;
_o$1.prototype.bytesPerElement = 12;
N$1("StructArrayLayout2ub2f12", _o$1);
var uf$1 = class uf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n4 = this.length;
    return this.resize(n4 + 1), this.emplace(n4, e, t, i);
  }
  emplace(e, t, i, n4) {
    let o4 = e * 3;
    return this.uint16[o4 + 0] = t, this.uint16[o4 + 1] = i, this.uint16[o4 + 2] = n4, e;
  }
};
H$3(uf$1, "StructArrayLayout3ui6");
var tn$1 = uf$1;
tn$1.prototype.bytesPerElement = 6;
N$1("StructArrayLayout3ui6", tn$1);
var cf$1 = class cf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b) {
    let w3 = this.length;
    return this.resize(w3 + 1), this.emplace(w3, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b);
  }
  emplace(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b, w3) {
    let _ = e * 24, S4 = e * 12, P4 = e * 48;
    return this.int16[_ + 0] = t, this.int16[_ + 1] = i, this.uint16[_ + 2] = n4, this.uint16[_ + 3] = o4, this.uint32[S4 + 2] = a4, this.uint32[S4 + 3] = s5, this.uint32[S4 + 4] = u5, this.uint16[_ + 10] = c, this.uint16[_ + 11] = p4, this.uint16[_ + 12] = h, this.float32[S4 + 7] = f, this.float32[S4 + 8] = m5, this.uint8[P4 + 36] = y4, this.uint8[P4 + 37] = g, this.uint8[P4 + 38] = x2, this.uint32[S4 + 10] = b, this.int16[_ + 22] = w3, e;
  }
};
H$3(cf$1, "StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48");
var vo = cf$1;
vo.prototype.bytesPerElement = 48;
N$1("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", vo);
var pf$1 = class pf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b, w3, _, S4, P4, T3, L3, C3, E4, I3, R3, z4) {
    let k3 = this.length;
    return this.resize(k3 + 1), this.emplace(k3, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b, w3, _, S4, P4, T3, L3, C3, E4, I3, R3, z4);
  }
  emplace(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b, w3, _, S4, P4, T3, L3, C3, E4, I3, R3, z4, k3) {
    let M3 = e * 32, G3 = e * 16;
    return this.int16[M3 + 0] = t, this.int16[M3 + 1] = i, this.int16[M3 + 2] = n4, this.int16[M3 + 3] = o4, this.int16[M3 + 4] = a4, this.int16[M3 + 5] = s5, this.int16[M3 + 6] = u5, this.int16[M3 + 7] = c, this.uint16[M3 + 8] = p4, this.uint16[M3 + 9] = h, this.uint16[M3 + 10] = f, this.uint16[M3 + 11] = m5, this.uint16[M3 + 12] = y4, this.uint16[M3 + 13] = g, this.uint16[M3 + 14] = x2, this.uint16[M3 + 15] = b, this.uint16[M3 + 16] = w3, this.uint16[M3 + 17] = _, this.uint16[M3 + 18] = S4, this.uint16[M3 + 19] = P4, this.uint16[M3 + 20] = T3, this.uint16[M3 + 21] = L3, this.uint16[M3 + 22] = C3, this.uint32[G3 + 12] = E4, this.float32[G3 + 13] = I3, this.float32[G3 + 14] = R3, this.uint16[M3 + 30] = z4, this.uint16[M3 + 31] = k3, e;
  }
};
H$3(pf$1, "StructArrayLayout8i15ui1ul2f2ui64");
var wo$1 = pf$1;
wo$1.prototype.bytesPerElement = 64;
N$1("StructArrayLayout8i15ui1ul2f2ui64", wo$1);
var hf$1 = class hf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t = this.length;
    return this.resize(t + 1), this.emplace(t, e);
  }
  emplace(e, t) {
    let i = e * 1;
    return this.float32[i + 0] = t, e;
  }
};
H$3(hf$1, "StructArrayLayout1f4");
var ui$1 = hf$1;
ui$1.prototype.bytesPerElement = 4;
N$1("StructArrayLayout1f4", ui$1);
var ff$1 = class ff extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n4 = this.length;
    return this.resize(n4 + 1), this.emplace(n4, e, t, i);
  }
  emplace(e, t, i, n4) {
    let o4 = e * 6, a4 = e * 3;
    return this.uint16[o4 + 0] = t, this.float32[a4 + 1] = i, this.float32[a4 + 2] = n4, e;
  }
};
H$3(ff$1, "StructArrayLayout1ui2f12");
var So$1 = ff$1;
So$1.prototype.bytesPerElement = 12;
N$1("StructArrayLayout1ui2f12", So$1);
var mf$1 = class mf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i) {
    let n4 = this.length;
    return this.resize(n4 + 1), this.emplace(n4, e, t, i);
  }
  emplace(e, t, i, n4) {
    let o4 = e * 2, a4 = e * 4;
    return this.uint32[o4 + 0] = t, this.uint16[a4 + 2] = i, this.uint16[a4 + 3] = n4, e;
  }
};
H$3(mf$1, "StructArrayLayout1ul2ui8");
var Po$1 = mf$1;
Po$1.prototype.bytesPerElement = 8;
N$1("StructArrayLayout1ul2ui8", Po$1);
var df$1 = class df extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e, t) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e, t);
  }
  emplace(e, t, i) {
    let n4 = e * 2;
    return this.uint16[n4 + 0] = t, this.uint16[n4 + 1] = i, e;
  }
};
H$3(df$1, "StructArrayLayout2ui4");
var To = df$1;
To.prototype.bytesPerElement = 4;
N$1("StructArrayLayout2ui4", To);
var yf$1 = class yf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e) {
    let t = this.length;
    return this.resize(t + 1), this.emplace(t, e);
  }
  emplace(e, t) {
    let i = e * 1;
    return this.uint16[i + 0] = t, e;
  }
};
H$3(yf$1, "StructArrayLayout1ui2");
var Mo$1 = yf$1;
Mo$1.prototype.bytesPerElement = 2;
N$1("StructArrayLayout1ui2", Mo$1);
var gf$1 = class gf extends ze {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e, t, i, n4) {
    let o4 = this.length;
    return this.resize(o4 + 1), this.emplace(o4, e, t, i, n4);
  }
  emplace(e, t, i, n4, o4) {
    let a4 = e * 4;
    return this.float32[a4 + 0] = t, this.float32[a4 + 1] = i, this.float32[a4 + 2] = n4, this.float32[a4 + 3] = o4, e;
  }
};
H$3(gf$1, "StructArrayLayout4f16");
var rn = gf$1;
rn.prototype.bytesPerElement = 16;
N$1("StructArrayLayout4f16", rn);
var xf$1 = class xf extends Tr {
  get anchorPointX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorPointY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get x1() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get y1() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get x2() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get y2() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get anchorPoint() {
    return new L_.default(this.anchorPointX, this.anchorPointY);
  }
};
H$3(xf$1, "CollisionBoxStruct");
var ll$1 = xf$1;
ll$1.prototype.size = 20;
var bf$1 = class bf extends go {
  get(e) {
    return new ll$1(this, e);
  }
};
H$3(bf$1, "CollisionBoxArray");
var Ao$1 = bf$1;
N$1("CollisionBoxArray", Ao$1);
var _f$1 = class _f extends Tr {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get glyphStartIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get numGlyphs() {
    return this._structArray.uint16[this._pos2 + 3];
  }
  get vertexStartIndex() {
    return this._structArray.uint32[this._pos4 + 2];
  }
  get lineStartIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get lineLength() {
    return this._structArray.uint32[this._pos4 + 4];
  }
  get segment() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get lowerSize() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get upperSize() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get lineOffsetX() {
    return this._structArray.float32[this._pos4 + 7];
  }
  get lineOffsetY() {
    return this._structArray.float32[this._pos4 + 8];
  }
  get writingMode() {
    return this._structArray.uint8[this._pos1 + 36];
  }
  get placedOrientation() {
    return this._structArray.uint8[this._pos1 + 37];
  }
  set placedOrientation(e) {
    this._structArray.uint8[this._pos1 + 37] = e;
  }
  get hidden() {
    return this._structArray.uint8[this._pos1 + 38];
  }
  set hidden(e) {
    this._structArray.uint8[this._pos1 + 38] = e;
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 10];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 10] = e;
  }
  get associatedIconIndex() {
    return this._structArray.int16[this._pos2 + 22];
  }
};
H$3(_f$1, "PlacedSymbolStruct");
var ul = _f$1;
ul.prototype.size = 48;
var vf$1 = class vf extends vo {
  get(e) {
    return new ul(this, e);
  }
};
H$3(vf$1, "PlacedSymbolArray");
var Io$1 = vf$1;
N$1("PlacedSymbolArray", Io$1);
var wf$1 = class wf extends Tr {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get rightJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get centerJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get leftJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get verticalPlacedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get placedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 6];
  }
  get verticalPlacedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 7];
  }
  get key() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get textBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get textBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get verticalTextBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get verticalTextBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get iconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 13];
  }
  get iconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 14];
  }
  get verticalIconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 15];
  }
  get verticalIconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 16];
  }
  get featureIndex() {
    return this._structArray.uint16[this._pos2 + 17];
  }
  get numHorizontalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 18];
  }
  get numVerticalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 19];
  }
  get numIconVertices() {
    return this._structArray.uint16[this._pos2 + 20];
  }
  get numVerticalIconVertices() {
    return this._structArray.uint16[this._pos2 + 21];
  }
  get useRuntimeCollisionCircles() {
    return this._structArray.uint16[this._pos2 + 22];
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 12];
  }
  set crossTileID(e) {
    this._structArray.uint32[this._pos4 + 12] = e;
  }
  get textBoxScale() {
    return this._structArray.float32[this._pos4 + 13];
  }
  get collisionCircleDiameter() {
    return this._structArray.float32[this._pos4 + 14];
  }
  get textAnchorOffsetStartIndex() {
    return this._structArray.uint16[this._pos2 + 30];
  }
  get textAnchorOffsetEndIndex() {
    return this._structArray.uint16[this._pos2 + 31];
  }
};
H$3(wf$1, "SymbolInstanceStruct");
var cl$1 = wf$1;
cl$1.prototype.size = 64;
var Sf$1 = class Sf extends wo$1 {
  get(e) {
    return new cl$1(this, e);
  }
};
H$3(Sf$1, "SymbolInstanceArray");
var Co$1 = Sf$1;
N$1("SymbolInstanceArray", Co$1);
var Pf = class Pf2 extends ui$1 {
  getoffsetX(e) {
    return this.float32[e * 1 + 0];
  }
};
H$3(Pf, "GlyphOffsetArray");
var Eo$1 = Pf;
N$1("GlyphOffsetArray", Eo$1);
var Tf$1 = class Tf extends en {
  getx(e) {
    return this.int16[e * 3 + 0];
  }
  gety(e) {
    return this.int16[e * 3 + 1];
  }
  gettileUnitDistanceFromAnchor(e) {
    return this.int16[e * 3 + 2];
  }
};
H$3(Tf$1, "SymbolLineVertexArray");
var ko = Tf$1;
N$1("SymbolLineVertexArray", ko);
var Mf$1 = class Mf extends Tr {
  get textAnchor() {
    return this._structArray.uint16[this._pos2 + 0];
  }
  get textOffset0() {
    return this._structArray.float32[this._pos4 + 1];
  }
  get textOffset1() {
    return this._structArray.float32[this._pos4 + 2];
  }
};
H$3(Mf$1, "TextAnchorOffsetStruct");
var pl$1 = Mf$1;
pl$1.prototype.size = 12;
var Af = class Af2 extends So$1 {
  get(e) {
    return new pl$1(this, e);
  }
};
H$3(Af, "TextAnchorOffsetArray");
var Lo$1 = Af;
N$1("TextAnchorOffsetArray", Lo$1);
var If$1 = class If extends Tr {
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 0];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 3];
  }
};
H$3(If$1, "FeatureIndexStruct");
var hl$1 = If$1;
hl$1.prototype.size = 8;
var Cf$1 = class Cf extends Po$1 {
  get(e) {
    return new hl$1(this, e);
  }
};
H$3(Cf$1, "FeatureIndexArray");
var Do$1 = Cf$1;
N$1("FeatureIndexArray", Do$1);
var Ef = class Ef2 extends li$1 {
};
H$3(Ef, "PosArray");
var Ar$1 = Ef, kf = class kf2 extends en {
};
H$3(kf, "Pos3dArray");
var fl$1 = kf, Lf = class Lf2 extends uo$1 {
};
H$3(Lf, "RasterBoundsArray");
var nn$1 = Lf, Df = class Df2 extends li$1 {
};
H$3(Df, "CircleLayoutArray");
var ml$1 = Df, zf = class zf2 extends li$1 {
};
H$3(zf, "FillLayoutArray");
var dl$1 = zf, Ff = class Ff2 extends co {
};
H$3(Ff, "FillExtrusionLayoutArray");
var yl$1 = Ff;
var Rf = class Rf2 extends po {
};
H$3(Rf, "LineLayoutArray");
var gl$1 = Rf, Bf = class Bf2 extends Mr {
};
H$3(Bf, "LineExtLayoutArray");
var xl$1 = Bf, Of = class Of2 extends ho {
};
H$3(Of, "PatternLayoutArray");
var sr = Of, Vf = class Vf2 extends fo {
};
H$3(Vf, "SymbolLayoutArray");
var bl$1 = Vf, Uf = class Uf2 extends mo {
};
H$3(Uf, "SymbolDynamicLayoutArray");
var _l$1 = Uf, Nf = class Nf2 extends yo {
};
H$3(Nf, "SymbolOpacityArray");
var vl$1 = Nf, Gf = class Gf2 extends xo$1 {
};
H$3(Gf, "CollisionBoxLayoutArray");
var zo$1 = Gf, qf = class qf2 extends bo {
};
H$3(qf, "CollisionCircleLayoutArray");
var wl$1 = qf, jf = class jf2 extends _o$1 {
};
H$3(jf, "CollisionVertexArray");
var Sl$1 = jf, Zf = class Zf2 extends tn$1 {
};
H$3(Zf, "QuadTriangleArray");
var Pl$1 = Zf, Hf = class Hf2 extends tn$1 {
};
H$3(Hf, "TriangleIndexArray");
var it$2 = Hf, $f = class $f2 extends To {
};
H$3($f, "LineIndexArray");
var Ir$1 = $f, Wf = class Wf2 extends Mo$1 {
};
H$3(Wf, "LineStripIndexArray");
var Fo$1 = Wf;
a();
var cM$1 = _e$1([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: D_$1, size: nR, alignment: oR } = cM$1;
a();
var ci = class ci2 {
  constructor(e = []) {
    this.segments = e;
  }
  prepareSegment(e, t, i, n4) {
    let o4 = this.segments[this.segments.length - 1];
    return e > ci2.MAX_VERTEX_ARRAY_LENGTH && Le$1("Max vertices per segment is ".concat(ci2.MAX_VERTEX_ARRAY_LENGTH, ": bucket requested ").concat(e)), (!o4 || o4.vertexLength + e > ci2.MAX_VERTEX_ARRAY_LENGTH || o4.sortKey !== n4) && (o4 = { vertexOffset: t.length, primitiveOffset: i.length, vertexLength: 0, primitiveLength: 0 }, n4 !== void 0 && (o4.sortKey = n4), this.segments.push(o4)), o4;
  }
  get() {
    return this.segments;
  }
  destroy() {
    for (let e of this.segments) for (let t in e.vaos) e.vaos[t].destroy();
  }
  static simpleSegment(e, t, i, n4) {
    return new ci2([{ vertexOffset: e, primitiveOffset: t, vertexLength: i, primitiveLength: n4, vaos: {}, sortKey: 0 }]);
  }
};
H$3(ci, "SegmentVector");
var me$1 = ci;
me$1.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;
N$1("SegmentVector", me$1);
a();
a();
function Xf(r5, e) {
  return r5 = Ae$2(Math.floor(r5), 0, 255), e = Ae$2(Math.floor(e), 0, 255), 256 * r5 + e;
}
H$3(Xf, "packUint8ToFloat");
a();
var Ro$1 = _e$1([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
a();
var O_$1 = N$2(Yf(), 1);
var Al = class Al2 {
  constructor() {
    this.ids = [], this.positions = [], this.indexed = false;
  }
  add(e, t, i, n4) {
    this.ids.push(B_$1(e)), this.positions.push(t, i, n4);
  }
  getPositions(e) {
    if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
    let t = B_$1(e), i = 0, n4 = this.ids.length - 1;
    for (; i < n4; ) {
      let a4 = i + n4 >> 1;
      this.ids[a4] >= t ? n4 = a4 : i = a4 + 1;
    }
    let o4 = [];
    for (; this.ids[i] === t; ) {
      let a4 = this.positions[3 * i], s5 = this.positions[3 * i + 1], u5 = this.positions[3 * i + 2];
      o4.push({ index: a4, start: s5, end: u5 }), i++;
    }
    return o4;
  }
  static serialize(e, t) {
    let i = new Float64Array(e.ids), n4 = new Uint32Array(e.positions);
    return Qf(i, n4, 0, i.length - 1), t && t.push(i.buffer, n4.buffer), { ids: i, positions: n4 };
  }
  static deserialize(e) {
    let t = new Al2();
    return t.ids = e.ids, t.positions = e.positions, t.indexed = true, t;
  }
};
H$3(Al, "FeaturePositionMap");
var Bo$2 = Al;
function B_$1(r5) {
  let e = +r5;
  return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : (0, O_$1.default)(String(r5));
}
H$3(B_$1, "getNumericId");
function Qf(r5, e, t, i) {
  for (; t < i; ) {
    let n4 = r5[t + i >> 1], o4 = t - 1, a4 = i + 1;
    for (; ; ) {
      do
        o4++;
      while (r5[o4] < n4);
      do
        a4--;
      while (r5[a4] > n4);
      if (o4 >= a4) break;
      Ml$1(r5, o4, a4), Ml$1(e, 3 * o4, 3 * a4), Ml$1(e, 3 * o4 + 1, 3 * a4 + 1), Ml$1(e, 3 * o4 + 2, 3 * a4 + 2);
    }
    a4 - t < i - a4 ? (Qf(r5, e, t, a4), t = a4 + 1) : (Qf(r5, e, a4 + 1, i), i = a4);
  }
}
H$3(Qf, "sort");
function Ml$1(r5, e, t) {
  let i = r5[e];
  r5[e] = r5[t], r5[t] = i;
}
H$3(Ml$1, "swap");
N$1("FeaturePositionMap", Bo$2);
a();
var em = class em2 {
  constructor(e, t) {
    this.gl = e.gl, this.location = t;
  }
};
H$3(em, "Uniform");
var lr = em, tm$1 = class tm extends lr {
  constructor(e, t) {
    super(e, t), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1i(this.location, e));
  }
};
H$3(tm$1, "Uniform1i");
var Q$2 = tm$1, rm = class rm2 extends lr {
  constructor(e, t) {
    super(e, t), this.current = 0;
  }
  set(e) {
    this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
  }
};
H$3(rm, "Uniform1f");
var U$1 = rm, im$1 = class im extends lr {
  constructor(e, t) {
    super(e, t), this.current = [0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1]) && (this.current = e, this.gl.uniform2f(this.location, e[0], e[1]));
  }
};
H$3(im$1, "Uniform2f");
var te$1 = im$1, nm$1 = class nm extends lr {
  constructor(e, t) {
    super(e, t), this.current = [0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2]) && (this.current = e, this.gl.uniform3f(this.location, e[0], e[1], e[2]));
  }
};
H$3(nm$1, "Uniform3f");
var lt$1 = nm$1, om$1 = class om extends lr {
  constructor(e, t) {
    super(e, t), this.current = [0, 0, 0, 0];
  }
  set(e) {
    (e[0] !== this.current[0] || e[1] !== this.current[1] || e[2] !== this.current[2] || e[3] !== this.current[3]) && (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
  }
};
H$3(om$1, "Uniform4f");
var Cr$1 = om$1, am$1 = class am extends lr {
  constructor(e, t) {
    super(e, t), this.current = X$1.transparent;
  }
  set(e) {
    (e.r !== this.current.r || e.g !== this.current.g || e.b !== this.current.b || e.a !== this.current.a) && (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
  }
};
H$3(am$1, "UniformColor");
var kt$1 = am$1, mM$1 = new Float32Array(16), sm$1 = class sm extends lr {
  constructor(e, t) {
    super(e, t), this.current = mM$1;
  }
  set(e) {
    if (e[12] !== this.current[12] || e[0] !== this.current[0]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      return;
    }
    for (let t = 1; t < 16; t++) if (e[t] !== this.current[t]) {
      this.current = e, this.gl.uniformMatrix4fv(this.location, false, e);
      break;
    }
  }
};
H$3(sm$1, "UniformMatrix4f");
var re$3 = sm$1;
function lm$1(r5) {
  return [Xf(255 * r5.r, 255 * r5.g), Xf(255 * r5.b, 255 * r5.a)];
}
H$3(lm$1, "packColor");
var um$1 = class um {
  constructor(e, t, i) {
    this.value = e, this.uniformNames = t.map((n4) => "u_".concat(n4)), this.type = i;
  }
  setUniform(e, t, i) {
    e.set(i.constantOr(this.value));
  }
  getBinding(e, t, i) {
    return this.type === "color" ? new kt$1(e, t) : new U$1(e, t);
  }
};
H$3(um$1, "ConstantBinder");
var pi$1 = um$1, cm$1 = class cm {
  constructor(e, t) {
    this.uniformNames = t.map((i) => "u_".concat(i)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
  }
  setConstantPatternPositions(e, t) {
    this.pixelRatioFrom = t.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = t.tlbr, this.patternTo = e.tlbr;
  }
  setUniform(e, t, i, n4) {
    let o4 = n4 === "u_pattern_to" ? this.patternTo : n4 === "u_pattern_from" ? this.patternFrom : n4 === "u_pixel_ratio_to" ? this.pixelRatioTo : n4 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
    o4 && e.set(o4);
  }
  getBinding(e, t, i) {
    return i.substr(0, 9) === "u_pattern" ? new Cr$1(e, t) : new U$1(e, t);
  }
};
H$3(cm$1, "CrossFadedConstantBinder");
var Er = cm$1, pm$1 = class pm {
  constructor(e, t, i, n4) {
    this.expression = e, this.type = i, this.maxValue = 0, this.paintVertexAttributes = t.map((o4) => ({ name: "a_".concat(o4), type: "Float32", components: i === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n4();
  }
  populatePaintArray(e, t, i, n4, o4) {
    let a4 = this.paintVertexArray.length, s5 = this.expression.evaluate(new ye(0), t, {}, n4, [], o4);
    this.paintVertexArray.resize(e), this._setPaintValue(a4, e, s5);
  }
  updatePaintArray(e, t, i, n4) {
    let o4 = this.expression.evaluate({ zoom: 0 }, i, n4);
    this._setPaintValue(e, t, o4);
  }
  _setPaintValue(e, t, i) {
    if (this.type === "color") {
      let n4 = lm$1(i);
      for (let o4 = e; o4 < t; o4++) this.paintVertexArray.emplace(o4, n4[0], n4[1]);
    } else {
      for (let n4 = e; n4 < t; n4++) this.paintVertexArray.emplace(n4, i);
      this.maxValue = Math.max(this.maxValue, Math.abs(i));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
};
H$3(pm$1, "SourceExpressionBinder");
var Bt$1 = pm$1, hm$1 = class hm {
  constructor(e, t, i, n4, o4, a4) {
    this.expression = e, this.uniformNames = t.map((s5) => "u_".concat(s5, "_t")), this.type = i, this.useIntegerZoom = n4, this.zoom = o4, this.maxValue = 0, this.paintVertexAttributes = t.map((s5) => ({ name: "a_".concat(s5), type: "Float32", components: i === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new a4();
  }
  populatePaintArray(e, t, i, n4, o4) {
    let a4 = this.expression.evaluate(new ye(this.zoom), t, {}, n4, [], o4), s5 = this.expression.evaluate(new ye(this.zoom + 1), t, {}, n4, [], o4), u5 = this.paintVertexArray.length;
    this.paintVertexArray.resize(e), this._setPaintValue(u5, e, a4, s5);
  }
  updatePaintArray(e, t, i, n4) {
    let o4 = this.expression.evaluate({ zoom: this.zoom }, i, n4), a4 = this.expression.evaluate({ zoom: this.zoom + 1 }, i, n4);
    this._setPaintValue(e, t, o4, a4);
  }
  _setPaintValue(e, t, i, n4) {
    if (this.type === "color") {
      let o4 = lm$1(i), a4 = lm$1(n4);
      for (let s5 = e; s5 < t; s5++) this.paintVertexArray.emplace(s5, o4[0], o4[1], a4[0], a4[1]);
    } else {
      for (let o4 = e; o4 < t; o4++) this.paintVertexArray.emplace(o4, i, n4);
      this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(n4));
    }
  }
  upload(e) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
  setUniform(e, t) {
    let i = this.useIntegerZoom ? Math.floor(t.zoom) : t.zoom, n4 = Ae$2(this.expression.interpolationFactor(i, this.zoom, this.zoom + 1), 0, 1);
    e.set(n4);
  }
  getBinding(e, t, i) {
    return new U$1(e, t);
  }
};
H$3(hm$1, "CompositeExpressionBinder");
var St$1 = hm$1, fm$1 = class fm {
  constructor(e, t, i, n4, o4, a4) {
    this.expression = e, this.type = t, this.useIntegerZoom = i, this.zoom = n4, this.layerId = a4, this.zoomInPaintVertexArray = new o4(), this.zoomOutPaintVertexArray = new o4();
  }
  populatePaintArray(e, t, i) {
    let n4 = this.zoomInPaintVertexArray.length;
    this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(n4, e, t.patterns && t.patterns[this.layerId], i);
  }
  updatePaintArray(e, t, i, n4, o4) {
    this._setPaintValues(e, t, i.patterns && i.patterns[this.layerId], o4);
  }
  _setPaintValues(e, t, i, n4) {
    if (!n4 || !i) return;
    let { min: o4, mid: a4, max: s5 } = i, u5 = n4[o4], c = n4[a4], p4 = n4[s5];
    if (!(!u5 || !c || !p4)) for (let h = e; h < t; h++) this.zoomInPaintVertexArray.emplace(h, c.tl[0], c.tl[1], c.br[0], c.br[1], u5.tl[0], u5.tl[1], u5.br[0], u5.br[1], c.pixelRatio, u5.pixelRatio), this.zoomOutPaintVertexArray.emplace(h, c.tl[0], c.tl[1], c.br[0], c.br[1], p4.tl[0], p4.tl[1], p4.br[0], p4.br[1], c.pixelRatio, p4.pixelRatio);
  }
  upload(e) {
    this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, Ro$1.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, Ro$1.members, this.expression.isStateDependent));
  }
  destroy() {
    this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
  }
};
H$3(fm$1, "CrossFadedCompositeBinder");
var jt$2 = fm$1, mm$1 = class mm {
  constructor(e, t, i) {
    this.binders = {}, this._buffers = [];
    let n4 = [];
    for (let o4 in e.paint._values) {
      if (!i(o4)) continue;
      let a4 = e.paint.get(o4);
      if (!(a4 instanceof at$1) || !_r$1(a4.property.specification)) continue;
      let s5 = dM$1(o4, e.type), u5 = a4.value, c = a4.property.specification.type, p4 = a4.property.useIntegerZoom, h = a4.property.specification["property-type"], f = h === "cross-faded" || h === "cross-faded-data-driven";
      if (u5.kind === "constant") this.binders[o4] = f ? new Er(u5.value, s5) : new pi$1(u5.value, s5, c), n4.push("/u_".concat(o4));
      else if (u5.kind === "source" || f) {
        let m5 = V_(o4, c, "source");
        this.binders[o4] = f ? new jt$2(u5, c, p4, t, m5, e.id) : new Bt$1(u5, s5, c, m5), n4.push("/a_".concat(o4));
      } else {
        let m5 = V_(o4, c, "composite");
        this.binders[o4] = new St$1(u5, s5, c, p4, t, m5), n4.push("/z_".concat(o4));
      }
    }
    this.cacheKey = n4.sort().join("");
  }
  getMaxValue(e) {
    let t = this.binders[e];
    return t instanceof Bt$1 || t instanceof St$1 ? t.maxValue : 0;
  }
  populatePaintArrays(e, t, i, n4, o4) {
    for (let a4 in this.binders) {
      let s5 = this.binders[a4];
      (s5 instanceof Bt$1 || s5 instanceof St$1 || s5 instanceof jt$2) && s5.populatePaintArray(e, t, i, n4, o4);
    }
  }
  setConstantPatternPositions(e, t) {
    for (let i in this.binders) {
      let n4 = this.binders[i];
      n4 instanceof Er && n4.setConstantPatternPositions(e, t);
    }
  }
  updatePaintArrays(e, t, i, n4, o4) {
    let a4 = false;
    for (let s5 in e) {
      let u5 = t.getPositions(s5);
      for (let c of u5) {
        let p4 = i.feature(c.index);
        for (let h in this.binders) {
          let f = this.binders[h];
          if ((f instanceof Bt$1 || f instanceof St$1 || f instanceof jt$2) && f.expression.isStateDependent === true) {
            let m5 = n4.paint.get(h);
            f.expression = m5.value, f.updatePaintArray(c.start, c.end, p4, e[s5], o4), a4 = true;
          }
        }
      }
    }
    return a4;
  }
  defines() {
    let e = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      (i instanceof pi$1 || i instanceof Er) && e.push(...i.uniformNames.map((n4) => "#define HAS_UNIFORM_".concat(n4)));
    }
    return e;
  }
  getBinderAttributes() {
    let e = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      if (i instanceof Bt$1 || i instanceof St$1) for (let n4 = 0; n4 < i.paintVertexAttributes.length; n4++) e.push(i.paintVertexAttributes[n4].name);
      else if (i instanceof jt$2) for (let n4 = 0; n4 < Ro$1.members.length; n4++) e.push(Ro$1.members[n4].name);
    }
    return e;
  }
  getBinderUniforms() {
    let e = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      if (i instanceof pi$1 || i instanceof Er || i instanceof St$1) for (let n4 of i.uniformNames) e.push(n4);
    }
    return e;
  }
  getPaintVertexBuffers() {
    return this._buffers;
  }
  getUniforms(e, t) {
    let i = [];
    for (let n4 in this.binders) {
      let o4 = this.binders[n4];
      if (o4 instanceof pi$1 || o4 instanceof Er || o4 instanceof St$1) {
        for (let a4 of o4.uniformNames) if (t[a4]) {
          let s5 = o4.getBinding(e, t[a4], a4);
          i.push({ name: a4, property: n4, binding: s5 });
        }
      }
    }
    return i;
  }
  setUniforms(e, t, i, n4) {
    for (let { name: o4, property: a4, binding: s5 } of t) this.binders[a4].setUniform(s5, n4, i.get(a4), o4);
  }
  updatePaintBuffers(e) {
    this._buffers = [];
    for (let t in this.binders) {
      let i = this.binders[t];
      if (e && i instanceof jt$2) {
        let n4 = e.fromScale === 2 ? i.zoomInPaintVertexBuffer : i.zoomOutPaintVertexBuffer;
        n4 && this._buffers.push(n4);
      } else (i instanceof Bt$1 || i instanceof St$1) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer);
    }
  }
  upload(e) {
    for (let t in this.binders) {
      let i = this.binders[t];
      (i instanceof Bt$1 || i instanceof St$1 || i instanceof jt$2) && i.upload(e);
    }
    this.updatePaintBuffers();
  }
  destroy() {
    for (let e in this.binders) {
      let t = this.binders[e];
      (t instanceof Bt$1 || t instanceof St$1 || t instanceof jt$2) && t.destroy();
    }
  }
};
H$3(mm$1, "ProgramConfiguration");
var Il$1 = mm$1, dm$1 = class dm {
  constructor(e, t, i = () => true) {
    this.programConfigurations = {};
    for (let n4 of e) this.programConfigurations[n4.id] = new Il$1(n4, t, i);
    this.needsUpload = false, this._featureMap = new Bo$2(), this._bufferOffset = 0;
  }
  populatePaintArrays(e, t, i, n4, o4, a4) {
    for (let s5 in this.programConfigurations) this.programConfigurations[s5].populatePaintArrays(e, t, n4, o4, a4);
    t.id !== void 0 && this._featureMap.add(t.id, i, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = true;
  }
  updatePaintArrays(e, t, i, n4) {
    for (let o4 of i) this.needsUpload = this.programConfigurations[o4.id].updatePaintArrays(e, this._featureMap, t, o4, n4) || this.needsUpload;
  }
  get(e) {
    return this.programConfigurations[e];
  }
  upload(e) {
    if (this.needsUpload) {
      for (let t in this.programConfigurations) this.programConfigurations[t].upload(e);
      this.needsUpload = false;
    }
  }
  destroy() {
    for (let e in this.programConfigurations) this.programConfigurations[e].destroy();
  }
};
H$3(dm$1, "ProgramConfigurationSet");
var mt$1 = dm$1;
function dM$1(r5, e) {
  return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r5] || [r5.replace("".concat(e, "-"), "").replace(/-/g, "_")];
}
H$3(dM$1, "paintAttributeNames");
function yM$1(r5) {
  return { "line-pattern": { source: sr, composite: sr }, "fill-pattern": { source: sr, composite: sr }, "fill-extrusion-pattern": { source: sr, composite: sr } }[r5];
}
H$3(yM$1, "getLayoutException");
function V_(r5, e, t) {
  let i = { color: { source: Mr, composite: rn }, number: { source: ui$1, composite: Mr } }, n4 = yM$1(r5);
  return n4 && n4[t] || i[e][t];
}
H$3(V_, "layoutType");
N$1("ConstantBinder", pi$1);
N$1("CrossFadedConstantBinder", Er);
N$1("SourceExpressionBinder", Bt$1);
N$1("CrossFadedCompositeBinder", jt$2);
N$1("CompositeExpressionBinder", St$1);
N$1("ProgramConfiguration", Il$1, { omit: ["_buffers"] });
N$1("ProgramConfigurationSet", mt$1);
a();
a();
a();
var gM$1 = 15, ym$1 = Math.pow(2, gM$1 - 1) - 1, U_ = -ym$1 - 1;
function dt$1(r5) {
  let e = 8192 / r5.extent, t = r5.loadGeometry();
  for (let i = 0; i < t.length; i++) {
    let n4 = t[i];
    for (let o4 = 0; o4 < n4.length; o4++) {
      let a4 = n4[o4], s5 = Math.round(a4.x * e), u5 = Math.round(a4.y * e);
      a4.x = Ae$2(s5, U_, ym$1), a4.y = Ae$2(u5, U_, ym$1), (s5 < a4.x || s5 > a4.x + 1 || u5 < a4.y || u5 > a4.y + 1) && Le$1("Geometry exceeds allowed extent, reduce your vector tile buffer size");
    }
  }
  return t;
}
H$3(dt$1, "loadGeometry");
a();
function yt$1(r5, e) {
  return { type: r5.type, id: r5.id, properties: r5.properties, geometry: e ? dt$1(r5) : [] };
}
H$3(yt$1, "toEvaluationFeature");
function Cl$1(r5, e, t, i, n4) {
  r5.emplaceBack(e * 2 + (i + 1) / 2, t * 2 + (n4 + 1) / 2);
}
H$3(Cl$1, "addCircleVertex");
var gm$1 = class gm {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new ml$1(), this.indexArray = new it$2(), this.segments = new me$1(), this.programConfigurations = new mt$1(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    let n4 = this.layers[0], o4 = [], a4 = null, s5 = false;
    n4.type === "circle" && (a4 = n4.layout.get("circle-sort-key"), s5 = !a4.isConstant());
    for (let { feature: u5, id: c, index: p4, sourceLayerIndex: h } of e) {
      let f = this.layers[0]._featureFilter.needGeometry, m5 = yt$1(u5, f);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), m5, i)) continue;
      let y4 = s5 ? a4.evaluate(m5, {}, i) : void 0, g = { id: c, properties: u5.properties, type: u5.type, sourceLayerIndex: h, index: p4, geometry: f ? m5.geometry : dt$1(u5), patterns: {}, sortKey: y4 };
      o4.push(g);
    }
    s5 && o4.sort((u5, c) => u5.sortKey - c.sortKey);
    for (let u5 of o4) {
      let { geometry: c, index: p4, sourceLayerIndex: h } = u5, f = e[p4].feature;
      this.addFeature(u5, c, p4, i), t.featureIndex.insert(f, c, p4, h, this.index);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, D_$1), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  addFeature(e, t, i, n4) {
    for (let o4 of t) for (let a4 of o4) {
      let s5 = a4.x, u5 = a4.y;
      if (s5 < 0 || s5 >= 8192 || u5 < 0 || u5 >= 8192) continue;
      let c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), p4 = c.vertexLength;
      Cl$1(this.layoutVertexArray, s5, u5, -1, -1), Cl$1(this.layoutVertexArray, s5, u5, 1, -1), Cl$1(this.layoutVertexArray, s5, u5, 1, 1), Cl$1(this.layoutVertexArray, s5, u5, -1, 1), this.indexArray.emplaceBack(p4, p4 + 1, p4 + 2), this.indexArray.emplaceBack(p4, p4 + 3, p4 + 2), c.vertexLength += 4, c.primitiveLength += 2;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, {}, n4);
  }
};
H$3(gm$1, "CircleBucket");
var hi$1 = gm$1;
N$1("CircleBucket", hi$1, { omit: ["layers"] });
a();
var Oo$1 = N$2(ge(), 1);
function El$1(r5, e) {
  for (let t = 0; t < r5.length; t++) if (on$2(e, r5[t])) return true;
  for (let t = 0; t < e.length; t++) if (on$2(r5, e[t])) return true;
  return !!bm$1(r5, e);
}
H$3(El$1, "polygonIntersectsPolygon");
function G_(r5, e, t) {
  return !!(on$2(r5, e) || xm$1(e, r5, t));
}
H$3(G_, "polygonIntersectsBufferedPoint");
function kl(r5, e) {
  if (r5.length === 1) return N_(e, r5[0]);
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    for (let n4 = 0; n4 < i.length; n4++) if (on$2(r5, i[n4])) return true;
  }
  for (let t = 0; t < r5.length; t++) if (N_(e, r5[t])) return true;
  for (let t = 0; t < e.length; t++) if (bm$1(r5, e[t])) return true;
  return false;
}
H$3(kl, "polygonIntersectsMultiPolygon");
function q_(r5, e, t) {
  for (let i = 0; i < e.length; i++) {
    let n4 = e[i];
    if (r5.length >= 3) {
      for (let o4 = 0; o4 < n4.length; o4++) if (on$2(r5, n4[o4])) return true;
    }
    if (xM$1(r5, n4, t)) return true;
  }
  return false;
}
H$3(q_, "polygonIntersectsBufferedMultiLine");
function xM$1(r5, e, t) {
  if (r5.length > 1) {
    if (bm$1(r5, e)) return true;
    for (let i = 0; i < e.length; i++) if (xm$1(e[i], r5, t)) return true;
  }
  for (let i = 0; i < r5.length; i++) if (xm$1(r5[i], e, t)) return true;
  return false;
}
H$3(xM$1, "lineIntersectsBufferedLine");
function bm$1(r5, e) {
  if (r5.length === 0 || e.length === 0) return false;
  for (let t = 0; t < r5.length - 1; t++) {
    let i = r5[t], n4 = r5[t + 1];
    for (let o4 = 0; o4 < e.length - 1; o4++) {
      let a4 = e[o4], s5 = e[o4 + 1];
      if (bM$1(i, n4, a4, s5)) return true;
    }
  }
  return false;
}
H$3(bm$1, "lineIntersectsLine");
function bM$1(r5, e, t, i) {
  return tr$2(r5, t, i) !== tr$2(e, t, i) && tr$2(r5, e, t) !== tr$2(r5, e, i);
}
H$3(bM$1, "lineSegmentIntersectsLineSegment");
function xm$1(r5, e, t) {
  let i = t * t;
  if (e.length === 1) return r5.distSqr(e[0]) < i;
  for (let n4 = 1; n4 < e.length; n4++) {
    let o4 = e[n4 - 1], a4 = e[n4];
    if (j_(r5, o4, a4) < i) return true;
  }
  return false;
}
H$3(xm$1, "pointIntersectsBufferedLine");
function j_(r5, e, t) {
  let i = e.distSqr(t);
  if (i === 0) return r5.distSqr(e);
  let n4 = ((r5.x - e.x) * (t.x - e.x) + (r5.y - e.y) * (t.y - e.y)) / i;
  return n4 < 0 ? r5.distSqr(e) : n4 > 1 ? r5.distSqr(t) : r5.distSqr(t.sub(e)._mult(n4)._add(e));
}
H$3(j_, "distToSegmentSquared");
function N_(r5, e) {
  let t = false, i, n4, o4;
  for (let a4 = 0; a4 < r5.length; a4++) {
    i = r5[a4];
    for (let s5 = 0, u5 = i.length - 1; s5 < i.length; u5 = s5++) n4 = i[s5], o4 = i[u5], n4.y > e.y != o4.y > e.y && e.x < (o4.x - n4.x) * (e.y - n4.y) / (o4.y - n4.y) + n4.x && (t = !t);
  }
  return t;
}
H$3(N_, "multiPolygonContainsPoint");
function on$2(r5, e) {
  let t = false;
  for (let i = 0, n4 = r5.length - 1; i < r5.length; n4 = i++) {
    let o4 = r5[i], a4 = r5[n4];
    o4.y > e.y != a4.y > e.y && e.x < (a4.x - o4.x) * (e.y - o4.y) / (a4.y - o4.y) + o4.x && (t = !t);
  }
  return t;
}
H$3(on$2, "polygonContainsPoint");
function Z_$1(r5, e, t, i, n4) {
  for (let a4 of r5) if (e <= a4.x && t <= a4.y && i >= a4.x && n4 >= a4.y) return true;
  let o4 = [new Oo$1.default(e, t), new Oo$1.default(e, n4), new Oo$1.default(i, n4), new Oo$1.default(i, t)];
  if (r5.length > 2) {
    for (let a4 of o4) if (on$2(r5, a4)) return true;
  }
  for (let a4 = 0; a4 < r5.length - 1; a4++) {
    let s5 = r5[a4], u5 = r5[a4 + 1];
    if (_M$1(s5, u5, o4)) return true;
  }
  return false;
}
H$3(Z_$1, "polygonIntersectsBox");
function _M$1(r5, e, t) {
  let i = t[0], n4 = t[2];
  if (r5.x < i.x && e.x < i.x || r5.x > n4.x && e.x > n4.x || r5.y < i.y && e.y < i.y || r5.y > n4.y && e.y > n4.y) return false;
  let o4 = tr$2(r5, e, t[0]);
  return o4 !== tr$2(r5, e, t[1]) || o4 !== tr$2(r5, e, t[2]) || o4 !== tr$2(r5, e, t[3]);
}
H$3(_M$1, "edgeIntersectsBox");
a();
var Ll = N$2(ge(), 1);
function fi$1(r5, e, t) {
  let i = e.paint.get(r5).value;
  return i.kind === "constant" ? i.value : t.programConfigurations.get(e.id).getMaxValue(r5);
}
H$3(fi$1, "getMaximumPaintValue");
function kr(r5) {
  return Math.sqrt(r5[0] * r5[0] + r5[1] * r5[1]);
}
H$3(kr, "translateDistance");
function Lr$1(r5, e, t, i, n4) {
  if (!e[0] && !e[1]) return r5;
  let o4 = Ll.default.convert(e)._mult(n4);
  t === "viewport" && o4._rotate(-i);
  let a4 = [];
  for (let s5 = 0; s5 < r5.length; s5++) {
    let u5 = r5[s5];
    a4.push(u5.sub(o4));
  }
  return a4;
}
H$3(Lr$1, "translate");
function H_(r5, e) {
  let t = [];
  for (let i = 0; i < r5.length; i++) {
    let n4 = r5[i], o4 = [];
    for (let a4 = 0; a4 < n4.length; a4++) {
      let s5 = n4[a4 - 1], u5 = n4[a4], c = n4[a4 + 1], p4 = a4 === 0 ? new Ll.default(0, 0) : u5.sub(s5)._unit()._perp(), h = a4 === n4.length - 1 ? new Ll.default(0, 0) : c.sub(u5)._unit()._perp(), f = p4._add(h)._unit(), m5 = f.x * h.x + f.y * h.y;
      m5 !== 0 && f._mult(1 / m5), o4.push(f._mult(e)._add(u5));
    }
    t.push(o4);
  }
  return t;
}
H$3(H_, "offsetLine");
a();
var $_$1, wM$1 = H$3(() => $_$1 = $_$1 || new De$2({ "circle-sort-key": new $(A$1.layout_circle["circle-sort-key"]) }), "getLayout"), W_, SM$1 = H$3(() => W_ = W_ || new De$2({ "circle-radius": new $(A$1.paint_circle["circle-radius"]), "circle-color": new $(A$1.paint_circle["circle-color"]), "circle-blur": new $(A$1.paint_circle["circle-blur"]), "circle-opacity": new $(A$1.paint_circle["circle-opacity"]), "circle-translate": new Z$2(A$1.paint_circle["circle-translate"]), "circle-translate-anchor": new Z$2(A$1.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Z$2(A$1.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Z$2(A$1.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new $(A$1.paint_circle["circle-stroke-width"]), "circle-stroke-color": new $(A$1.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new $(A$1.paint_circle["circle-stroke-opacity"]) }), "getPaint"), X_$1 = { get paint() {
  return SM$1();
}, get layout() {
  return wM$1();
} };
a();
a();
var oe$1 = 1e-6, we$1 = typeof Float32Array < "u" ? Float32Array : Array, Zt$2 = Math.random;
Math.hypot || (Math.hypot = function() {
  for (var r5 = 0, e = arguments.length; e--; ) r5 += arguments[e] * arguments[e];
  return Math.sqrt(r5);
});
var Vo$2 = {};
M$1(Vo$2, { LDU: () => UM$1, add: () => NM$1, adjoint: () => LM$1, clone: () => TM$1, copy: () => MM$1, create: () => PM$1, determinant: () => DM$1, equals: () => qM$1, exactEquals: () => GM$1, frob: () => VM$1, fromRotation: () => RM$1, fromScaling: () => BM$1, fromValues: () => IM$1, identity: () => AM$1, invert: () => kM$1, mul: () => HM$1, multiply: () => K_$1, multiplyScalar: () => jM$1, multiplyScalarAndAdd: () => ZM$1, rotate: () => zM$1, scale: () => FM$1, set: () => CM$1, str: () => OM$1, sub: () => $M$1, subtract: () => J_$1, transpose: () => EM$1 });
a();
function PM$1() {
  var r5 = new we$1(4);
  return we$1 != Float32Array && (r5[1] = 0, r5[2] = 0), r5[0] = 1, r5[3] = 1, r5;
}
H$3(PM$1, "create");
function TM$1(r5) {
  var e = new we$1(4);
  return e[0] = r5[0], e[1] = r5[1], e[2] = r5[2], e[3] = r5[3], e;
}
H$3(TM$1, "clone");
function MM$1(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5[2] = e[2], r5[3] = e[3], r5;
}
H$3(MM$1, "copy");
function AM$1(r5) {
  return r5[0] = 1, r5[1] = 0, r5[2] = 0, r5[3] = 1, r5;
}
H$3(AM$1, "identity");
function IM$1(r5, e, t, i) {
  var n4 = new we$1(4);
  return n4[0] = r5, n4[1] = e, n4[2] = t, n4[3] = i, n4;
}
H$3(IM$1, "fromValues");
function CM$1(r5, e, t, i, n4) {
  return r5[0] = e, r5[1] = t, r5[2] = i, r5[3] = n4, r5;
}
H$3(CM$1, "set");
function EM$1(r5, e) {
  if (r5 === e) {
    var t = e[1];
    r5[1] = e[2], r5[2] = t;
  } else r5[0] = e[0], r5[1] = e[2], r5[2] = e[1], r5[3] = e[3];
  return r5;
}
H$3(EM$1, "transpose");
function kM$1(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = t * o4 - n4 * i;
  return a4 ? (a4 = 1 / a4, r5[0] = o4 * a4, r5[1] = -i * a4, r5[2] = -n4 * a4, r5[3] = t * a4, r5) : null;
}
H$3(kM$1, "invert");
function LM$1(r5, e) {
  var t = e[0];
  return r5[0] = e[3], r5[1] = -e[1], r5[2] = -e[2], r5[3] = t, r5;
}
H$3(LM$1, "adjoint");
function DM$1(r5) {
  return r5[0] * r5[3] - r5[2] * r5[1];
}
H$3(DM$1, "determinant");
function K_$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = t[0], u5 = t[1], c = t[2], p4 = t[3];
  return r5[0] = i * s5 + o4 * u5, r5[1] = n4 * s5 + a4 * u5, r5[2] = i * c + o4 * p4, r5[3] = n4 * c + a4 * p4, r5;
}
H$3(K_$1, "multiply");
function zM$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = Math.sin(t), u5 = Math.cos(t);
  return r5[0] = i * u5 + o4 * s5, r5[1] = n4 * u5 + a4 * s5, r5[2] = i * -s5 + o4 * u5, r5[3] = n4 * -s5 + a4 * u5, r5;
}
H$3(zM$1, "rotate");
function FM$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = t[0], u5 = t[1];
  return r5[0] = i * s5, r5[1] = n4 * s5, r5[2] = o4 * u5, r5[3] = a4 * u5, r5;
}
H$3(FM$1, "scale");
function RM$1(r5, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r5[0] = i, r5[1] = t, r5[2] = -t, r5[3] = i, r5;
}
H$3(RM$1, "fromRotation");
function BM$1(r5, e) {
  return r5[0] = e[0], r5[1] = 0, r5[2] = 0, r5[3] = e[1], r5;
}
H$3(BM$1, "fromScaling");
function OM$1(r5) {
  return "mat2(" + r5[0] + ", " + r5[1] + ", " + r5[2] + ", " + r5[3] + ")";
}
H$3(OM$1, "str");
function VM$1(r5) {
  return Math.hypot(r5[0], r5[1], r5[2], r5[3]);
}
H$3(VM$1, "frob");
function UM$1(r5, e, t, i) {
  return r5[2] = i[2] / i[0], t[0] = i[0], t[1] = i[1], t[3] = i[3] - r5[2] * t[1], [r5, e, t];
}
H$3(UM$1, "LDU");
function NM$1(r5, e, t) {
  return r5[0] = e[0] + t[0], r5[1] = e[1] + t[1], r5[2] = e[2] + t[2], r5[3] = e[3] + t[3], r5;
}
H$3(NM$1, "add");
function J_$1(r5, e, t) {
  return r5[0] = e[0] - t[0], r5[1] = e[1] - t[1], r5[2] = e[2] - t[2], r5[3] = e[3] - t[3], r5;
}
H$3(J_$1, "subtract");
function GM$1(r5, e) {
  return r5[0] === e[0] && r5[1] === e[1] && r5[2] === e[2] && r5[3] === e[3];
}
H$3(GM$1, "exactEquals");
function qM$1(r5, e) {
  var t = r5[0], i = r5[1], n4 = r5[2], o4 = r5[3], a4 = e[0], s5 = e[1], u5 = e[2], c = e[3];
  return Math.abs(t - a4) <= oe$1 * Math.max(1, Math.abs(t), Math.abs(a4)) && Math.abs(i - s5) <= oe$1 * Math.max(1, Math.abs(i), Math.abs(s5)) && Math.abs(n4 - u5) <= oe$1 * Math.max(1, Math.abs(n4), Math.abs(u5)) && Math.abs(o4 - c) <= oe$1 * Math.max(1, Math.abs(o4), Math.abs(c));
}
H$3(qM$1, "equals");
function jM$1(r5, e, t) {
  return r5[0] = e[0] * t, r5[1] = e[1] * t, r5[2] = e[2] * t, r5[3] = e[3] * t, r5;
}
H$3(jM$1, "multiplyScalar");
function ZM$1(r5, e, t, i) {
  return r5[0] = e[0] + t[0] * i, r5[1] = e[1] + t[1] * i, r5[2] = e[2] + t[2] * i, r5[3] = e[3] + t[3] * i, r5;
}
H$3(ZM$1, "multiplyScalarAndAdd");
var HM$1 = K_$1, $M$1 = J_$1;
var Uo$1 = {};
M$1(Uo$1, { add: () => gA, adjoint: () => iA, clone: () => KM$1, copy: () => JM, create: () => WM$1, determinant: () => nA, equals: () => vA, exactEquals: () => _A$1, frob: () => yA, fromMat2d: () => pA, fromMat4: () => XM$1, fromQuat: () => hA, fromRotation: () => uA, fromScaling: () => cA, fromTranslation: () => lA, fromValues: () => YM$1, identity: () => eA, invert: () => rA, mul: () => wA, multiply: () => Y_$1, multiplyScalar: () => xA, multiplyScalarAndAdd: () => bA, normalFromMat4: () => fA, projection: () => mA, rotate: () => aA, scale: () => sA, set: () => QM$1, str: () => dA, sub: () => SA, subtract: () => Q_$1, translate: () => oA, transpose: () => tA });
a();
function WM$1() {
  var r5 = new we$1(9);
  return we$1 != Float32Array && (r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[5] = 0, r5[6] = 0, r5[7] = 0), r5[0] = 1, r5[4] = 1, r5[8] = 1, r5;
}
H$3(WM$1, "create");
function XM$1(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5[2] = e[2], r5[3] = e[4], r5[4] = e[5], r5[5] = e[6], r5[6] = e[8], r5[7] = e[9], r5[8] = e[10], r5;
}
H$3(XM$1, "fromMat4");
function KM$1(r5) {
  var e = new we$1(9);
  return e[0] = r5[0], e[1] = r5[1], e[2] = r5[2], e[3] = r5[3], e[4] = r5[4], e[5] = r5[5], e[6] = r5[6], e[7] = r5[7], e[8] = r5[8], e;
}
H$3(KM$1, "clone");
function JM(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5[2] = e[2], r5[3] = e[3], r5[4] = e[4], r5[5] = e[5], r5[6] = e[6], r5[7] = e[7], r5[8] = e[8], r5;
}
H$3(JM, "copy");
function YM$1(r5, e, t, i, n4, o4, a4, s5, u5) {
  var c = new we$1(9);
  return c[0] = r5, c[1] = e, c[2] = t, c[3] = i, c[4] = n4, c[5] = o4, c[6] = a4, c[7] = s5, c[8] = u5, c;
}
H$3(YM$1, "fromValues");
function QM$1(r5, e, t, i, n4, o4, a4, s5, u5, c) {
  return r5[0] = e, r5[1] = t, r5[2] = i, r5[3] = n4, r5[4] = o4, r5[5] = a4, r5[6] = s5, r5[7] = u5, r5[8] = c, r5;
}
H$3(QM$1, "set");
function eA(r5) {
  return r5[0] = 1, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 1, r5[5] = 0, r5[6] = 0, r5[7] = 0, r5[8] = 1, r5;
}
H$3(eA, "identity");
function tA(r5, e) {
  if (r5 === e) {
    var t = e[1], i = e[2], n4 = e[5];
    r5[1] = e[3], r5[2] = e[6], r5[3] = t, r5[5] = e[7], r5[6] = i, r5[7] = n4;
  } else r5[0] = e[0], r5[1] = e[3], r5[2] = e[6], r5[3] = e[1], r5[4] = e[4], r5[5] = e[7], r5[6] = e[2], r5[7] = e[5], r5[8] = e[8];
  return r5;
}
H$3(tA, "transpose");
function rA(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = e[4], s5 = e[5], u5 = e[6], c = e[7], p4 = e[8], h = p4 * a4 - s5 * c, f = -p4 * o4 + s5 * u5, m5 = c * o4 - a4 * u5, y4 = t * h + i * f + n4 * m5;
  return y4 ? (y4 = 1 / y4, r5[0] = h * y4, r5[1] = (-p4 * i + n4 * c) * y4, r5[2] = (s5 * i - n4 * a4) * y4, r5[3] = f * y4, r5[4] = (p4 * t - n4 * u5) * y4, r5[5] = (-s5 * t + n4 * o4) * y4, r5[6] = m5 * y4, r5[7] = (-c * t + i * u5) * y4, r5[8] = (a4 * t - i * o4) * y4, r5) : null;
}
H$3(rA, "invert");
function iA(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = e[4], s5 = e[5], u5 = e[6], c = e[7], p4 = e[8];
  return r5[0] = a4 * p4 - s5 * c, r5[1] = n4 * c - i * p4, r5[2] = i * s5 - n4 * a4, r5[3] = s5 * u5 - o4 * p4, r5[4] = t * p4 - n4 * u5, r5[5] = n4 * o4 - t * s5, r5[6] = o4 * c - a4 * u5, r5[7] = i * u5 - t * c, r5[8] = t * a4 - i * o4, r5;
}
H$3(iA, "adjoint");
function nA(r5) {
  var e = r5[0], t = r5[1], i = r5[2], n4 = r5[3], o4 = r5[4], a4 = r5[5], s5 = r5[6], u5 = r5[7], c = r5[8];
  return e * (c * o4 - a4 * u5) + t * (-c * n4 + a4 * s5) + i * (u5 * n4 - o4 * s5);
}
H$3(nA, "determinant");
function Y_$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = e[4], u5 = e[5], c = e[6], p4 = e[7], h = e[8], f = t[0], m5 = t[1], y4 = t[2], g = t[3], x2 = t[4], b = t[5], w3 = t[6], _ = t[7], S4 = t[8];
  return r5[0] = f * i + m5 * a4 + y4 * c, r5[1] = f * n4 + m5 * s5 + y4 * p4, r5[2] = f * o4 + m5 * u5 + y4 * h, r5[3] = g * i + x2 * a4 + b * c, r5[4] = g * n4 + x2 * s5 + b * p4, r5[5] = g * o4 + x2 * u5 + b * h, r5[6] = w3 * i + _ * a4 + S4 * c, r5[7] = w3 * n4 + _ * s5 + S4 * p4, r5[8] = w3 * o4 + _ * u5 + S4 * h, r5;
}
H$3(Y_$1, "multiply");
function oA(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = e[4], u5 = e[5], c = e[6], p4 = e[7], h = e[8], f = t[0], m5 = t[1];
  return r5[0] = i, r5[1] = n4, r5[2] = o4, r5[3] = a4, r5[4] = s5, r5[5] = u5, r5[6] = f * i + m5 * a4 + c, r5[7] = f * n4 + m5 * s5 + p4, r5[8] = f * o4 + m5 * u5 + h, r5;
}
H$3(oA, "translate");
function aA(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = e[4], u5 = e[5], c = e[6], p4 = e[7], h = e[8], f = Math.sin(t), m5 = Math.cos(t);
  return r5[0] = m5 * i + f * a4, r5[1] = m5 * n4 + f * s5, r5[2] = m5 * o4 + f * u5, r5[3] = m5 * a4 - f * i, r5[4] = m5 * s5 - f * n4, r5[5] = m5 * u5 - f * o4, r5[6] = c, r5[7] = p4, r5[8] = h, r5;
}
H$3(aA, "rotate");
function sA(r5, e, t) {
  var i = t[0], n4 = t[1];
  return r5[0] = i * e[0], r5[1] = i * e[1], r5[2] = i * e[2], r5[3] = n4 * e[3], r5[4] = n4 * e[4], r5[5] = n4 * e[5], r5[6] = e[6], r5[7] = e[7], r5[8] = e[8], r5;
}
H$3(sA, "scale");
function lA(r5, e) {
  return r5[0] = 1, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 1, r5[5] = 0, r5[6] = e[0], r5[7] = e[1], r5[8] = 1, r5;
}
H$3(lA, "fromTranslation");
function uA(r5, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r5[0] = i, r5[1] = t, r5[2] = 0, r5[3] = -t, r5[4] = i, r5[5] = 0, r5[6] = 0, r5[7] = 0, r5[8] = 1, r5;
}
H$3(uA, "fromRotation");
function cA(r5, e) {
  return r5[0] = e[0], r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = e[1], r5[5] = 0, r5[6] = 0, r5[7] = 0, r5[8] = 1, r5;
}
H$3(cA, "fromScaling");
function pA(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5[2] = 0, r5[3] = e[2], r5[4] = e[3], r5[5] = 0, r5[6] = e[4], r5[7] = e[5], r5[8] = 1, r5;
}
H$3(pA, "fromMat2d");
function hA(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = t + t, s5 = i + i, u5 = n4 + n4, c = t * a4, p4 = i * a4, h = i * s5, f = n4 * a4, m5 = n4 * s5, y4 = n4 * u5, g = o4 * a4, x2 = o4 * s5, b = o4 * u5;
  return r5[0] = 1 - h - y4, r5[3] = p4 - b, r5[6] = f + x2, r5[1] = p4 + b, r5[4] = 1 - c - y4, r5[7] = m5 - g, r5[2] = f - x2, r5[5] = m5 + g, r5[8] = 1 - c - h, r5;
}
H$3(hA, "fromQuat");
function fA(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = e[4], s5 = e[5], u5 = e[6], c = e[7], p4 = e[8], h = e[9], f = e[10], m5 = e[11], y4 = e[12], g = e[13], x2 = e[14], b = e[15], w3 = t * s5 - i * a4, _ = t * u5 - n4 * a4, S4 = t * c - o4 * a4, P4 = i * u5 - n4 * s5, T3 = i * c - o4 * s5, L3 = n4 * c - o4 * u5, C3 = p4 * g - h * y4, E4 = p4 * x2 - f * y4, I3 = p4 * b - m5 * y4, R3 = h * x2 - f * g, z4 = h * b - m5 * g, k3 = f * b - m5 * x2, M3 = w3 * k3 - _ * z4 + S4 * R3 + P4 * I3 - T3 * E4 + L3 * C3;
  return M3 ? (M3 = 1 / M3, r5[0] = (s5 * k3 - u5 * z4 + c * R3) * M3, r5[1] = (u5 * I3 - a4 * k3 - c * E4) * M3, r5[2] = (a4 * z4 - s5 * I3 + c * C3) * M3, r5[3] = (n4 * z4 - i * k3 - o4 * R3) * M3, r5[4] = (t * k3 - n4 * I3 + o4 * E4) * M3, r5[5] = (i * I3 - t * z4 - o4 * C3) * M3, r5[6] = (g * L3 - x2 * T3 + b * P4) * M3, r5[7] = (x2 * S4 - y4 * L3 - b * _) * M3, r5[8] = (y4 * T3 - g * S4 + b * w3) * M3, r5) : null;
}
H$3(fA, "normalFromMat4");
function mA(r5, e, t) {
  return r5[0] = 2 / e, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = -2 / t, r5[5] = 0, r5[6] = -1, r5[7] = 1, r5[8] = 1, r5;
}
H$3(mA, "projection");
function dA(r5) {
  return "mat3(" + r5[0] + ", " + r5[1] + ", " + r5[2] + ", " + r5[3] + ", " + r5[4] + ", " + r5[5] + ", " + r5[6] + ", " + r5[7] + ", " + r5[8] + ")";
}
H$3(dA, "str");
function yA(r5) {
  return Math.hypot(r5[0], r5[1], r5[2], r5[3], r5[4], r5[5], r5[6], r5[7], r5[8]);
}
H$3(yA, "frob");
function gA(r5, e, t) {
  return r5[0] = e[0] + t[0], r5[1] = e[1] + t[1], r5[2] = e[2] + t[2], r5[3] = e[3] + t[3], r5[4] = e[4] + t[4], r5[5] = e[5] + t[5], r5[6] = e[6] + t[6], r5[7] = e[7] + t[7], r5[8] = e[8] + t[8], r5;
}
H$3(gA, "add");
function Q_$1(r5, e, t) {
  return r5[0] = e[0] - t[0], r5[1] = e[1] - t[1], r5[2] = e[2] - t[2], r5[3] = e[3] - t[3], r5[4] = e[4] - t[4], r5[5] = e[5] - t[5], r5[6] = e[6] - t[6], r5[7] = e[7] - t[7], r5[8] = e[8] - t[8], r5;
}
H$3(Q_$1, "subtract");
function xA(r5, e, t) {
  return r5[0] = e[0] * t, r5[1] = e[1] * t, r5[2] = e[2] * t, r5[3] = e[3] * t, r5[4] = e[4] * t, r5[5] = e[5] * t, r5[6] = e[6] * t, r5[7] = e[7] * t, r5[8] = e[8] * t, r5;
}
H$3(xA, "multiplyScalar");
function bA(r5, e, t, i) {
  return r5[0] = e[0] + t[0] * i, r5[1] = e[1] + t[1] * i, r5[2] = e[2] + t[2] * i, r5[3] = e[3] + t[3] * i, r5[4] = e[4] + t[4] * i, r5[5] = e[5] + t[5] * i, r5[6] = e[6] + t[6] * i, r5[7] = e[7] + t[7] * i, r5[8] = e[8] + t[8] * i, r5;
}
H$3(bA, "multiplyScalarAndAdd");
function _A$1(r5, e) {
  return r5[0] === e[0] && r5[1] === e[1] && r5[2] === e[2] && r5[3] === e[3] && r5[4] === e[4] && r5[5] === e[5] && r5[6] === e[6] && r5[7] === e[7] && r5[8] === e[8];
}
H$3(_A$1, "exactEquals");
function vA(r5, e) {
  var t = r5[0], i = r5[1], n4 = r5[2], o4 = r5[3], a4 = r5[4], s5 = r5[5], u5 = r5[6], c = r5[7], p4 = r5[8], h = e[0], f = e[1], m5 = e[2], y4 = e[3], g = e[4], x2 = e[5], b = e[6], w3 = e[7], _ = e[8];
  return Math.abs(t - h) <= oe$1 * Math.max(1, Math.abs(t), Math.abs(h)) && Math.abs(i - f) <= oe$1 * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(n4 - m5) <= oe$1 * Math.max(1, Math.abs(n4), Math.abs(m5)) && Math.abs(o4 - y4) <= oe$1 * Math.max(1, Math.abs(o4), Math.abs(y4)) && Math.abs(a4 - g) <= oe$1 * Math.max(1, Math.abs(a4), Math.abs(g)) && Math.abs(s5 - x2) <= oe$1 * Math.max(1, Math.abs(s5), Math.abs(x2)) && Math.abs(u5 - b) <= oe$1 * Math.max(1, Math.abs(u5), Math.abs(b)) && Math.abs(c - w3) <= oe$1 * Math.max(1, Math.abs(c), Math.abs(w3)) && Math.abs(p4 - _) <= oe$1 * Math.max(1, Math.abs(p4), Math.abs(_));
}
H$3(vA, "equals");
var wA = Y_$1, SA = Q_$1;
var q$2 = {};
M$1(q$2, { add: () => sI$1, adjoint: () => kA, clone: () => TA, copy: () => MA, create: () => PA, determinant: () => LA, equals: () => pI$1, exactEquals: () => cI$1, frob: () => aI$1, fromQuat: () => KA, fromQuat2: () => ZA, fromRotation: () => NA, fromRotationTranslation: () => rv, fromRotationTranslationScale: () => WA$1, fromRotationTranslationScaleOrigin: () => XA$1, fromScaling: () => UA$1, fromTranslation: () => VA$1, fromValues: () => AA, fromXRotation: () => GA$1, fromYRotation: () => qA$1, fromZRotation: () => jA$1, frustum: () => JA, getRotation: () => $A, getScaling: () => iv, getTranslation: () => HA, identity: () => ev, invert: () => EA, lookAt: () => iI, mul: () => hI$1, multiply: () => tv, multiplyScalar: () => lI$1, multiplyScalarAndAdd: () => uI$1, ortho: () => tI$1, orthoNO: () => ov, orthoZO: () => rI$1, perspective: () => YA$1, perspectiveFromFieldOfView: () => eI$1, perspectiveNO: () => nv$1, perspectiveZO: () => QA, rotate: () => FA, rotateX: () => RA, rotateY: () => BA$1, rotateZ: () => OA, scale: () => zA, set: () => IA, str: () => oI$1, sub: () => fI, subtract: () => av, targetTo: () => nI$1, translate: () => DA, transpose: () => CA$1 });
a();
function PA() {
  var r5 = new we$1(16);
  return we$1 != Float32Array && (r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0), r5[0] = 1, r5[5] = 1, r5[10] = 1, r5[15] = 1, r5;
}
H$3(PA, "create");
function TA(r5) {
  var e = new we$1(16);
  return e[0] = r5[0], e[1] = r5[1], e[2] = r5[2], e[3] = r5[3], e[4] = r5[4], e[5] = r5[5], e[6] = r5[6], e[7] = r5[7], e[8] = r5[8], e[9] = r5[9], e[10] = r5[10], e[11] = r5[11], e[12] = r5[12], e[13] = r5[13], e[14] = r5[14], e[15] = r5[15], e;
}
H$3(TA, "clone");
function MA(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5[2] = e[2], r5[3] = e[3], r5[4] = e[4], r5[5] = e[5], r5[6] = e[6], r5[7] = e[7], r5[8] = e[8], r5[9] = e[9], r5[10] = e[10], r5[11] = e[11], r5[12] = e[12], r5[13] = e[13], r5[14] = e[14], r5[15] = e[15], r5;
}
H$3(MA, "copy");
function AA(r5, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g) {
  var x2 = new we$1(16);
  return x2[0] = r5, x2[1] = e, x2[2] = t, x2[3] = i, x2[4] = n4, x2[5] = o4, x2[6] = a4, x2[7] = s5, x2[8] = u5, x2[9] = c, x2[10] = p4, x2[11] = h, x2[12] = f, x2[13] = m5, x2[14] = y4, x2[15] = g, x2;
}
H$3(AA, "fromValues");
function IA(r5, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2) {
  return r5[0] = e, r5[1] = t, r5[2] = i, r5[3] = n4, r5[4] = o4, r5[5] = a4, r5[6] = s5, r5[7] = u5, r5[8] = c, r5[9] = p4, r5[10] = h, r5[11] = f, r5[12] = m5, r5[13] = y4, r5[14] = g, r5[15] = x2, r5;
}
H$3(IA, "set");
function ev(r5) {
  return r5[0] = 1, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = 1, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[10] = 1, r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0, r5[15] = 1, r5;
}
H$3(ev, "identity");
function CA$1(r5, e) {
  if (r5 === e) {
    var t = e[1], i = e[2], n4 = e[3], o4 = e[6], a4 = e[7], s5 = e[11];
    r5[1] = e[4], r5[2] = e[8], r5[3] = e[12], r5[4] = t, r5[6] = e[9], r5[7] = e[13], r5[8] = i, r5[9] = o4, r5[11] = e[14], r5[12] = n4, r5[13] = a4, r5[14] = s5;
  } else r5[0] = e[0], r5[1] = e[4], r5[2] = e[8], r5[3] = e[12], r5[4] = e[1], r5[5] = e[5], r5[6] = e[9], r5[7] = e[13], r5[8] = e[2], r5[9] = e[6], r5[10] = e[10], r5[11] = e[14], r5[12] = e[3], r5[13] = e[7], r5[14] = e[11], r5[15] = e[15];
  return r5;
}
H$3(CA$1, "transpose");
function EA(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = e[4], s5 = e[5], u5 = e[6], c = e[7], p4 = e[8], h = e[9], f = e[10], m5 = e[11], y4 = e[12], g = e[13], x2 = e[14], b = e[15], w3 = t * s5 - i * a4, _ = t * u5 - n4 * a4, S4 = t * c - o4 * a4, P4 = i * u5 - n4 * s5, T3 = i * c - o4 * s5, L3 = n4 * c - o4 * u5, C3 = p4 * g - h * y4, E4 = p4 * x2 - f * y4, I3 = p4 * b - m5 * y4, R3 = h * x2 - f * g, z4 = h * b - m5 * g, k3 = f * b - m5 * x2, M3 = w3 * k3 - _ * z4 + S4 * R3 + P4 * I3 - T3 * E4 + L3 * C3;
  return M3 ? (M3 = 1 / M3, r5[0] = (s5 * k3 - u5 * z4 + c * R3) * M3, r5[1] = (n4 * z4 - i * k3 - o4 * R3) * M3, r5[2] = (g * L3 - x2 * T3 + b * P4) * M3, r5[3] = (f * T3 - h * L3 - m5 * P4) * M3, r5[4] = (u5 * I3 - a4 * k3 - c * E4) * M3, r5[5] = (t * k3 - n4 * I3 + o4 * E4) * M3, r5[6] = (x2 * S4 - y4 * L3 - b * _) * M3, r5[7] = (p4 * L3 - f * S4 + m5 * _) * M3, r5[8] = (a4 * z4 - s5 * I3 + c * C3) * M3, r5[9] = (i * I3 - t * z4 - o4 * C3) * M3, r5[10] = (y4 * T3 - g * S4 + b * w3) * M3, r5[11] = (h * S4 - p4 * T3 - m5 * w3) * M3, r5[12] = (s5 * E4 - a4 * R3 - u5 * C3) * M3, r5[13] = (t * R3 - i * E4 + n4 * C3) * M3, r5[14] = (g * _ - y4 * P4 - x2 * w3) * M3, r5[15] = (p4 * P4 - h * _ + f * w3) * M3, r5) : null;
}
H$3(EA, "invert");
function kA(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = e[4], s5 = e[5], u5 = e[6], c = e[7], p4 = e[8], h = e[9], f = e[10], m5 = e[11], y4 = e[12], g = e[13], x2 = e[14], b = e[15];
  return r5[0] = s5 * (f * b - m5 * x2) - h * (u5 * b - c * x2) + g * (u5 * m5 - c * f), r5[1] = -(i * (f * b - m5 * x2) - h * (n4 * b - o4 * x2) + g * (n4 * m5 - o4 * f)), r5[2] = i * (u5 * b - c * x2) - s5 * (n4 * b - o4 * x2) + g * (n4 * c - o4 * u5), r5[3] = -(i * (u5 * m5 - c * f) - s5 * (n4 * m5 - o4 * f) + h * (n4 * c - o4 * u5)), r5[4] = -(a4 * (f * b - m5 * x2) - p4 * (u5 * b - c * x2) + y4 * (u5 * m5 - c * f)), r5[5] = t * (f * b - m5 * x2) - p4 * (n4 * b - o4 * x2) + y4 * (n4 * m5 - o4 * f), r5[6] = -(t * (u5 * b - c * x2) - a4 * (n4 * b - o4 * x2) + y4 * (n4 * c - o4 * u5)), r5[7] = t * (u5 * m5 - c * f) - a4 * (n4 * m5 - o4 * f) + p4 * (n4 * c - o4 * u5), r5[8] = a4 * (h * b - m5 * g) - p4 * (s5 * b - c * g) + y4 * (s5 * m5 - c * h), r5[9] = -(t * (h * b - m5 * g) - p4 * (i * b - o4 * g) + y4 * (i * m5 - o4 * h)), r5[10] = t * (s5 * b - c * g) - a4 * (i * b - o4 * g) + y4 * (i * c - o4 * s5), r5[11] = -(t * (s5 * m5 - c * h) - a4 * (i * m5 - o4 * h) + p4 * (i * c - o4 * s5)), r5[12] = -(a4 * (h * x2 - f * g) - p4 * (s5 * x2 - u5 * g) + y4 * (s5 * f - u5 * h)), r5[13] = t * (h * x2 - f * g) - p4 * (i * x2 - n4 * g) + y4 * (i * f - n4 * h), r5[14] = -(t * (s5 * x2 - u5 * g) - a4 * (i * x2 - n4 * g) + y4 * (i * u5 - n4 * s5)), r5[15] = t * (s5 * f - u5 * h) - a4 * (i * f - n4 * h) + p4 * (i * u5 - n4 * s5), r5;
}
H$3(kA, "adjoint");
function LA(r5) {
  var e = r5[0], t = r5[1], i = r5[2], n4 = r5[3], o4 = r5[4], a4 = r5[5], s5 = r5[6], u5 = r5[7], c = r5[8], p4 = r5[9], h = r5[10], f = r5[11], m5 = r5[12], y4 = r5[13], g = r5[14], x2 = r5[15], b = e * a4 - t * o4, w3 = e * s5 - i * o4, _ = e * u5 - n4 * o4, S4 = t * s5 - i * a4, P4 = t * u5 - n4 * a4, T3 = i * u5 - n4 * s5, L3 = c * y4 - p4 * m5, C3 = c * g - h * m5, E4 = c * x2 - f * m5, I3 = p4 * g - h * y4, R3 = p4 * x2 - f * y4, z4 = h * x2 - f * g;
  return b * z4 - w3 * R3 + _ * I3 + S4 * E4 - P4 * C3 + T3 * L3;
}
H$3(LA, "determinant");
function tv(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = e[4], u5 = e[5], c = e[6], p4 = e[7], h = e[8], f = e[9], m5 = e[10], y4 = e[11], g = e[12], x2 = e[13], b = e[14], w3 = e[15], _ = t[0], S4 = t[1], P4 = t[2], T3 = t[3];
  return r5[0] = _ * i + S4 * s5 + P4 * h + T3 * g, r5[1] = _ * n4 + S4 * u5 + P4 * f + T3 * x2, r5[2] = _ * o4 + S4 * c + P4 * m5 + T3 * b, r5[3] = _ * a4 + S4 * p4 + P4 * y4 + T3 * w3, _ = t[4], S4 = t[5], P4 = t[6], T3 = t[7], r5[4] = _ * i + S4 * s5 + P4 * h + T3 * g, r5[5] = _ * n4 + S4 * u5 + P4 * f + T3 * x2, r5[6] = _ * o4 + S4 * c + P4 * m5 + T3 * b, r5[7] = _ * a4 + S4 * p4 + P4 * y4 + T3 * w3, _ = t[8], S4 = t[9], P4 = t[10], T3 = t[11], r5[8] = _ * i + S4 * s5 + P4 * h + T3 * g, r5[9] = _ * n4 + S4 * u5 + P4 * f + T3 * x2, r5[10] = _ * o4 + S4 * c + P4 * m5 + T3 * b, r5[11] = _ * a4 + S4 * p4 + P4 * y4 + T3 * w3, _ = t[12], S4 = t[13], P4 = t[14], T3 = t[15], r5[12] = _ * i + S4 * s5 + P4 * h + T3 * g, r5[13] = _ * n4 + S4 * u5 + P4 * f + T3 * x2, r5[14] = _ * o4 + S4 * c + P4 * m5 + T3 * b, r5[15] = _ * a4 + S4 * p4 + P4 * y4 + T3 * w3, r5;
}
H$3(tv, "multiply");
function DA(r5, e, t) {
  var i = t[0], n4 = t[1], o4 = t[2], a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b;
  return e === r5 ? (r5[12] = e[0] * i + e[4] * n4 + e[8] * o4 + e[12], r5[13] = e[1] * i + e[5] * n4 + e[9] * o4 + e[13], r5[14] = e[2] * i + e[6] * n4 + e[10] * o4 + e[14], r5[15] = e[3] * i + e[7] * n4 + e[11] * o4 + e[15]) : (a4 = e[0], s5 = e[1], u5 = e[2], c = e[3], p4 = e[4], h = e[5], f = e[6], m5 = e[7], y4 = e[8], g = e[9], x2 = e[10], b = e[11], r5[0] = a4, r5[1] = s5, r5[2] = u5, r5[3] = c, r5[4] = p4, r5[5] = h, r5[6] = f, r5[7] = m5, r5[8] = y4, r5[9] = g, r5[10] = x2, r5[11] = b, r5[12] = a4 * i + p4 * n4 + y4 * o4 + e[12], r5[13] = s5 * i + h * n4 + g * o4 + e[13], r5[14] = u5 * i + f * n4 + x2 * o4 + e[14], r5[15] = c * i + m5 * n4 + b * o4 + e[15]), r5;
}
H$3(DA, "translate");
function zA(r5, e, t) {
  var i = t[0], n4 = t[1], o4 = t[2];
  return r5[0] = e[0] * i, r5[1] = e[1] * i, r5[2] = e[2] * i, r5[3] = e[3] * i, r5[4] = e[4] * n4, r5[5] = e[5] * n4, r5[6] = e[6] * n4, r5[7] = e[7] * n4, r5[8] = e[8] * o4, r5[9] = e[9] * o4, r5[10] = e[10] * o4, r5[11] = e[11] * o4, r5[12] = e[12], r5[13] = e[13], r5[14] = e[14], r5[15] = e[15], r5;
}
H$3(zA, "scale");
function FA(r5, e, t, i) {
  var n4 = i[0], o4 = i[1], a4 = i[2], s5 = Math.hypot(n4, o4, a4), u5, c, p4, h, f, m5, y4, g, x2, b, w3, _, S4, P4, T3, L3, C3, E4, I3, R3, z4, k3, M3, G3;
  return s5 < oe$1 ? null : (s5 = 1 / s5, n4 *= s5, o4 *= s5, a4 *= s5, u5 = Math.sin(t), c = Math.cos(t), p4 = 1 - c, h = e[0], f = e[1], m5 = e[2], y4 = e[3], g = e[4], x2 = e[5], b = e[6], w3 = e[7], _ = e[8], S4 = e[9], P4 = e[10], T3 = e[11], L3 = n4 * n4 * p4 + c, C3 = o4 * n4 * p4 + a4 * u5, E4 = a4 * n4 * p4 - o4 * u5, I3 = n4 * o4 * p4 - a4 * u5, R3 = o4 * o4 * p4 + c, z4 = a4 * o4 * p4 + n4 * u5, k3 = n4 * a4 * p4 + o4 * u5, M3 = o4 * a4 * p4 - n4 * u5, G3 = a4 * a4 * p4 + c, r5[0] = h * L3 + g * C3 + _ * E4, r5[1] = f * L3 + x2 * C3 + S4 * E4, r5[2] = m5 * L3 + b * C3 + P4 * E4, r5[3] = y4 * L3 + w3 * C3 + T3 * E4, r5[4] = h * I3 + g * R3 + _ * z4, r5[5] = f * I3 + x2 * R3 + S4 * z4, r5[6] = m5 * I3 + b * R3 + P4 * z4, r5[7] = y4 * I3 + w3 * R3 + T3 * z4, r5[8] = h * k3 + g * M3 + _ * G3, r5[9] = f * k3 + x2 * M3 + S4 * G3, r5[10] = m5 * k3 + b * M3 + P4 * G3, r5[11] = y4 * k3 + w3 * M3 + T3 * G3, e !== r5 && (r5[12] = e[12], r5[13] = e[13], r5[14] = e[14], r5[15] = e[15]), r5);
}
H$3(FA, "rotate");
function RA(r5, e, t) {
  var i = Math.sin(t), n4 = Math.cos(t), o4 = e[4], a4 = e[5], s5 = e[6], u5 = e[7], c = e[8], p4 = e[9], h = e[10], f = e[11];
  return e !== r5 && (r5[0] = e[0], r5[1] = e[1], r5[2] = e[2], r5[3] = e[3], r5[12] = e[12], r5[13] = e[13], r5[14] = e[14], r5[15] = e[15]), r5[4] = o4 * n4 + c * i, r5[5] = a4 * n4 + p4 * i, r5[6] = s5 * n4 + h * i, r5[7] = u5 * n4 + f * i, r5[8] = c * n4 - o4 * i, r5[9] = p4 * n4 - a4 * i, r5[10] = h * n4 - s5 * i, r5[11] = f * n4 - u5 * i, r5;
}
H$3(RA, "rotateX");
function BA$1(r5, e, t) {
  var i = Math.sin(t), n4 = Math.cos(t), o4 = e[0], a4 = e[1], s5 = e[2], u5 = e[3], c = e[8], p4 = e[9], h = e[10], f = e[11];
  return e !== r5 && (r5[4] = e[4], r5[5] = e[5], r5[6] = e[6], r5[7] = e[7], r5[12] = e[12], r5[13] = e[13], r5[14] = e[14], r5[15] = e[15]), r5[0] = o4 * n4 - c * i, r5[1] = a4 * n4 - p4 * i, r5[2] = s5 * n4 - h * i, r5[3] = u5 * n4 - f * i, r5[8] = o4 * i + c * n4, r5[9] = a4 * i + p4 * n4, r5[10] = s5 * i + h * n4, r5[11] = u5 * i + f * n4, r5;
}
H$3(BA$1, "rotateY");
function OA(r5, e, t) {
  var i = Math.sin(t), n4 = Math.cos(t), o4 = e[0], a4 = e[1], s5 = e[2], u5 = e[3], c = e[4], p4 = e[5], h = e[6], f = e[7];
  return e !== r5 && (r5[8] = e[8], r5[9] = e[9], r5[10] = e[10], r5[11] = e[11], r5[12] = e[12], r5[13] = e[13], r5[14] = e[14], r5[15] = e[15]), r5[0] = o4 * n4 + c * i, r5[1] = a4 * n4 + p4 * i, r5[2] = s5 * n4 + h * i, r5[3] = u5 * n4 + f * i, r5[4] = c * n4 - o4 * i, r5[5] = p4 * n4 - a4 * i, r5[6] = h * n4 - s5 * i, r5[7] = f * n4 - u5 * i, r5;
}
H$3(OA, "rotateZ");
function VA$1(r5, e) {
  return r5[0] = 1, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = 1, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[10] = 1, r5[11] = 0, r5[12] = e[0], r5[13] = e[1], r5[14] = e[2], r5[15] = 1, r5;
}
H$3(VA$1, "fromTranslation");
function UA$1(r5, e) {
  return r5[0] = e[0], r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = e[1], r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[10] = e[2], r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0, r5[15] = 1, r5;
}
H$3(UA$1, "fromScaling");
function NA(r5, e, t) {
  var i = t[0], n4 = t[1], o4 = t[2], a4 = Math.hypot(i, n4, o4), s5, u5, c;
  return a4 < oe$1 ? null : (a4 = 1 / a4, i *= a4, n4 *= a4, o4 *= a4, s5 = Math.sin(e), u5 = Math.cos(e), c = 1 - u5, r5[0] = i * i * c + u5, r5[1] = n4 * i * c + o4 * s5, r5[2] = o4 * i * c - n4 * s5, r5[3] = 0, r5[4] = i * n4 * c - o4 * s5, r5[5] = n4 * n4 * c + u5, r5[6] = o4 * n4 * c + i * s5, r5[7] = 0, r5[8] = i * o4 * c + n4 * s5, r5[9] = n4 * o4 * c - i * s5, r5[10] = o4 * o4 * c + u5, r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0, r5[15] = 1, r5);
}
H$3(NA, "fromRotation");
function GA$1(r5, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r5[0] = 1, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = i, r5[6] = t, r5[7] = 0, r5[8] = 0, r5[9] = -t, r5[10] = i, r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0, r5[15] = 1, r5;
}
H$3(GA$1, "fromXRotation");
function qA$1(r5, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r5[0] = i, r5[1] = 0, r5[2] = -t, r5[3] = 0, r5[4] = 0, r5[5] = 1, r5[6] = 0, r5[7] = 0, r5[8] = t, r5[9] = 0, r5[10] = i, r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0, r5[15] = 1, r5;
}
H$3(qA$1, "fromYRotation");
function jA$1(r5, e) {
  var t = Math.sin(e), i = Math.cos(e);
  return r5[0] = i, r5[1] = t, r5[2] = 0, r5[3] = 0, r5[4] = -t, r5[5] = i, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[10] = 1, r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0, r5[15] = 1, r5;
}
H$3(jA$1, "fromZRotation");
function rv(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3], s5 = i + i, u5 = n4 + n4, c = o4 + o4, p4 = i * s5, h = i * u5, f = i * c, m5 = n4 * u5, y4 = n4 * c, g = o4 * c, x2 = a4 * s5, b = a4 * u5, w3 = a4 * c;
  return r5[0] = 1 - (m5 + g), r5[1] = h + w3, r5[2] = f - b, r5[3] = 0, r5[4] = h - w3, r5[5] = 1 - (p4 + g), r5[6] = y4 + x2, r5[7] = 0, r5[8] = f + b, r5[9] = y4 - x2, r5[10] = 1 - (p4 + m5), r5[11] = 0, r5[12] = t[0], r5[13] = t[1], r5[14] = t[2], r5[15] = 1, r5;
}
H$3(rv, "fromRotationTranslation");
function ZA(r5, e) {
  var t = new we$1(3), i = -e[0], n4 = -e[1], o4 = -e[2], a4 = e[3], s5 = e[4], u5 = e[5], c = e[6], p4 = e[7], h = i * i + n4 * n4 + o4 * o4 + a4 * a4;
  return h > 0 ? (t[0] = (s5 * a4 + p4 * i + u5 * o4 - c * n4) * 2 / h, t[1] = (u5 * a4 + p4 * n4 + c * i - s5 * o4) * 2 / h, t[2] = (c * a4 + p4 * o4 + s5 * n4 - u5 * i) * 2 / h) : (t[0] = (s5 * a4 + p4 * i + u5 * o4 - c * n4) * 2, t[1] = (u5 * a4 + p4 * n4 + c * i - s5 * o4) * 2, t[2] = (c * a4 + p4 * o4 + s5 * n4 - u5 * i) * 2), rv(r5, e, t), r5;
}
H$3(ZA, "fromQuat2");
function HA(r5, e) {
  return r5[0] = e[12], r5[1] = e[13], r5[2] = e[14], r5;
}
H$3(HA, "getTranslation");
function iv(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[4], a4 = e[5], s5 = e[6], u5 = e[8], c = e[9], p4 = e[10];
  return r5[0] = Math.hypot(t, i, n4), r5[1] = Math.hypot(o4, a4, s5), r5[2] = Math.hypot(u5, c, p4), r5;
}
H$3(iv, "getScaling");
function $A(r5, e) {
  var t = new we$1(3);
  iv(t, e);
  var i = 1 / t[0], n4 = 1 / t[1], o4 = 1 / t[2], a4 = e[0] * i, s5 = e[1] * n4, u5 = e[2] * o4, c = e[4] * i, p4 = e[5] * n4, h = e[6] * o4, f = e[8] * i, m5 = e[9] * n4, y4 = e[10] * o4, g = a4 + p4 + y4, x2 = 0;
  return g > 0 ? (x2 = Math.sqrt(g + 1) * 2, r5[3] = 0.25 * x2, r5[0] = (h - m5) / x2, r5[1] = (f - u5) / x2, r5[2] = (s5 - c) / x2) : a4 > p4 && a4 > y4 ? (x2 = Math.sqrt(1 + a4 - p4 - y4) * 2, r5[3] = (h - m5) / x2, r5[0] = 0.25 * x2, r5[1] = (s5 + c) / x2, r5[2] = (f + u5) / x2) : p4 > y4 ? (x2 = Math.sqrt(1 + p4 - a4 - y4) * 2, r5[3] = (f - u5) / x2, r5[0] = (s5 + c) / x2, r5[1] = 0.25 * x2, r5[2] = (h + m5) / x2) : (x2 = Math.sqrt(1 + y4 - a4 - p4) * 2, r5[3] = (s5 - c) / x2, r5[0] = (f + u5) / x2, r5[1] = (h + m5) / x2, r5[2] = 0.25 * x2), r5;
}
H$3($A, "getRotation");
function WA$1(r5, e, t, i) {
  var n4 = e[0], o4 = e[1], a4 = e[2], s5 = e[3], u5 = n4 + n4, c = o4 + o4, p4 = a4 + a4, h = n4 * u5, f = n4 * c, m5 = n4 * p4, y4 = o4 * c, g = o4 * p4, x2 = a4 * p4, b = s5 * u5, w3 = s5 * c, _ = s5 * p4, S4 = i[0], P4 = i[1], T3 = i[2];
  return r5[0] = (1 - (y4 + x2)) * S4, r5[1] = (f + _) * S4, r5[2] = (m5 - w3) * S4, r5[3] = 0, r5[4] = (f - _) * P4, r5[5] = (1 - (h + x2)) * P4, r5[6] = (g + b) * P4, r5[7] = 0, r5[8] = (m5 + w3) * T3, r5[9] = (g - b) * T3, r5[10] = (1 - (h + y4)) * T3, r5[11] = 0, r5[12] = t[0], r5[13] = t[1], r5[14] = t[2], r5[15] = 1, r5;
}
H$3(WA$1, "fromRotationTranslationScale");
function XA$1(r5, e, t, i, n4) {
  var o4 = e[0], a4 = e[1], s5 = e[2], u5 = e[3], c = o4 + o4, p4 = a4 + a4, h = s5 + s5, f = o4 * c, m5 = o4 * p4, y4 = o4 * h, g = a4 * p4, x2 = a4 * h, b = s5 * h, w3 = u5 * c, _ = u5 * p4, S4 = u5 * h, P4 = i[0], T3 = i[1], L3 = i[2], C3 = n4[0], E4 = n4[1], I3 = n4[2], R3 = (1 - (g + b)) * P4, z4 = (m5 + S4) * P4, k3 = (y4 - _) * P4, M3 = (m5 - S4) * T3, G3 = (1 - (f + b)) * T3, K4 = (x2 + w3) * T3, ne2 = (y4 + _) * L3, J4 = (x2 - w3) * L3, W4 = (1 - (f + g)) * L3;
  return r5[0] = R3, r5[1] = z4, r5[2] = k3, r5[3] = 0, r5[4] = M3, r5[5] = G3, r5[6] = K4, r5[7] = 0, r5[8] = ne2, r5[9] = J4, r5[10] = W4, r5[11] = 0, r5[12] = t[0] + C3 - (R3 * C3 + M3 * E4 + ne2 * I3), r5[13] = t[1] + E4 - (z4 * C3 + G3 * E4 + J4 * I3), r5[14] = t[2] + I3 - (k3 * C3 + K4 * E4 + W4 * I3), r5[15] = 1, r5;
}
H$3(XA$1, "fromRotationTranslationScaleOrigin");
function KA(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = t + t, s5 = i + i, u5 = n4 + n4, c = t * a4, p4 = i * a4, h = i * s5, f = n4 * a4, m5 = n4 * s5, y4 = n4 * u5, g = o4 * a4, x2 = o4 * s5, b = o4 * u5;
  return r5[0] = 1 - h - y4, r5[1] = p4 + b, r5[2] = f - x2, r5[3] = 0, r5[4] = p4 - b, r5[5] = 1 - c - y4, r5[6] = m5 + g, r5[7] = 0, r5[8] = f + x2, r5[9] = m5 - g, r5[10] = 1 - c - h, r5[11] = 0, r5[12] = 0, r5[13] = 0, r5[14] = 0, r5[15] = 1, r5;
}
H$3(KA, "fromQuat");
function JA(r5, e, t, i, n4, o4, a4) {
  var s5 = 1 / (t - e), u5 = 1 / (n4 - i), c = 1 / (o4 - a4);
  return r5[0] = o4 * 2 * s5, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = o4 * 2 * u5, r5[6] = 0, r5[7] = 0, r5[8] = (t + e) * s5, r5[9] = (n4 + i) * u5, r5[10] = (a4 + o4) * c, r5[11] = -1, r5[12] = 0, r5[13] = 0, r5[14] = a4 * o4 * 2 * c, r5[15] = 0, r5;
}
H$3(JA, "frustum");
function nv$1(r5, e, t, i, n4) {
  var o4 = 1 / Math.tan(e / 2), a4;
  return r5[0] = o4 / t, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = o4, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[11] = -1, r5[12] = 0, r5[13] = 0, r5[15] = 0, n4 != null && n4 !== 1 / 0 ? (a4 = 1 / (i - n4), r5[10] = (n4 + i) * a4, r5[14] = 2 * n4 * i * a4) : (r5[10] = -1, r5[14] = -2 * i), r5;
}
H$3(nv$1, "perspectiveNO");
var YA$1 = nv$1;
function QA(r5, e, t, i, n4) {
  var o4 = 1 / Math.tan(e / 2), a4;
  return r5[0] = o4 / t, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = o4, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[11] = -1, r5[12] = 0, r5[13] = 0, r5[15] = 0, n4 != null && n4 !== 1 / 0 ? (a4 = 1 / (i - n4), r5[10] = n4 * a4, r5[14] = n4 * i * a4) : (r5[10] = -1, r5[14] = -i), r5;
}
H$3(QA, "perspectiveZO");
function eI$1(r5, e, t, i) {
  var n4 = Math.tan(e.upDegrees * Math.PI / 180), o4 = Math.tan(e.downDegrees * Math.PI / 180), a4 = Math.tan(e.leftDegrees * Math.PI / 180), s5 = Math.tan(e.rightDegrees * Math.PI / 180), u5 = 2 / (a4 + s5), c = 2 / (n4 + o4);
  return r5[0] = u5, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = c, r5[6] = 0, r5[7] = 0, r5[8] = -((a4 - s5) * u5 * 0.5), r5[9] = (n4 - o4) * c * 0.5, r5[10] = i / (t - i), r5[11] = -1, r5[12] = 0, r5[13] = 0, r5[14] = i * t / (t - i), r5[15] = 0, r5;
}
H$3(eI$1, "perspectiveFromFieldOfView");
function ov(r5, e, t, i, n4, o4, a4) {
  var s5 = 1 / (e - t), u5 = 1 / (i - n4), c = 1 / (o4 - a4);
  return r5[0] = -2 * s5, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = -2 * u5, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[10] = 2 * c, r5[11] = 0, r5[12] = (e + t) * s5, r5[13] = (n4 + i) * u5, r5[14] = (a4 + o4) * c, r5[15] = 1, r5;
}
H$3(ov, "orthoNO");
var tI$1 = ov;
function rI$1(r5, e, t, i, n4, o4, a4) {
  var s5 = 1 / (e - t), u5 = 1 / (i - n4), c = 1 / (o4 - a4);
  return r5[0] = -2 * s5, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5[4] = 0, r5[5] = -2 * u5, r5[6] = 0, r5[7] = 0, r5[8] = 0, r5[9] = 0, r5[10] = c, r5[11] = 0, r5[12] = (e + t) * s5, r5[13] = (n4 + i) * u5, r5[14] = o4 * c, r5[15] = 1, r5;
}
H$3(rI$1, "orthoZO");
function iI(r5, e, t, i) {
  var n4, o4, a4, s5, u5, c, p4, h, f, m5, y4 = e[0], g = e[1], x2 = e[2], b = i[0], w3 = i[1], _ = i[2], S4 = t[0], P4 = t[1], T3 = t[2];
  return Math.abs(y4 - S4) < oe$1 && Math.abs(g - P4) < oe$1 && Math.abs(x2 - T3) < oe$1 ? ev(r5) : (p4 = y4 - S4, h = g - P4, f = x2 - T3, m5 = 1 / Math.hypot(p4, h, f), p4 *= m5, h *= m5, f *= m5, n4 = w3 * f - _ * h, o4 = _ * p4 - b * f, a4 = b * h - w3 * p4, m5 = Math.hypot(n4, o4, a4), m5 ? (m5 = 1 / m5, n4 *= m5, o4 *= m5, a4 *= m5) : (n4 = 0, o4 = 0, a4 = 0), s5 = h * a4 - f * o4, u5 = f * n4 - p4 * a4, c = p4 * o4 - h * n4, m5 = Math.hypot(s5, u5, c), m5 ? (m5 = 1 / m5, s5 *= m5, u5 *= m5, c *= m5) : (s5 = 0, u5 = 0, c = 0), r5[0] = n4, r5[1] = s5, r5[2] = p4, r5[3] = 0, r5[4] = o4, r5[5] = u5, r5[6] = h, r5[7] = 0, r5[8] = a4, r5[9] = c, r5[10] = f, r5[11] = 0, r5[12] = -(n4 * y4 + o4 * g + a4 * x2), r5[13] = -(s5 * y4 + u5 * g + c * x2), r5[14] = -(p4 * y4 + h * g + f * x2), r5[15] = 1, r5);
}
H$3(iI, "lookAt");
function nI$1(r5, e, t, i) {
  var n4 = e[0], o4 = e[1], a4 = e[2], s5 = i[0], u5 = i[1], c = i[2], p4 = n4 - t[0], h = o4 - t[1], f = a4 - t[2], m5 = p4 * p4 + h * h + f * f;
  m5 > 0 && (m5 = 1 / Math.sqrt(m5), p4 *= m5, h *= m5, f *= m5);
  var y4 = u5 * f - c * h, g = c * p4 - s5 * f, x2 = s5 * h - u5 * p4;
  return m5 = y4 * y4 + g * g + x2 * x2, m5 > 0 && (m5 = 1 / Math.sqrt(m5), y4 *= m5, g *= m5, x2 *= m5), r5[0] = y4, r5[1] = g, r5[2] = x2, r5[3] = 0, r5[4] = h * x2 - f * g, r5[5] = f * y4 - p4 * x2, r5[6] = p4 * g - h * y4, r5[7] = 0, r5[8] = p4, r5[9] = h, r5[10] = f, r5[11] = 0, r5[12] = n4, r5[13] = o4, r5[14] = a4, r5[15] = 1, r5;
}
H$3(nI$1, "targetTo");
function oI$1(r5) {
  return "mat4(" + r5[0] + ", " + r5[1] + ", " + r5[2] + ", " + r5[3] + ", " + r5[4] + ", " + r5[5] + ", " + r5[6] + ", " + r5[7] + ", " + r5[8] + ", " + r5[9] + ", " + r5[10] + ", " + r5[11] + ", " + r5[12] + ", " + r5[13] + ", " + r5[14] + ", " + r5[15] + ")";
}
H$3(oI$1, "str");
function aI$1(r5) {
  return Math.hypot(r5[0], r5[1], r5[2], r5[3], r5[4], r5[5], r5[6], r5[7], r5[8], r5[9], r5[10], r5[11], r5[12], r5[13], r5[14], r5[15]);
}
H$3(aI$1, "frob");
function sI$1(r5, e, t) {
  return r5[0] = e[0] + t[0], r5[1] = e[1] + t[1], r5[2] = e[2] + t[2], r5[3] = e[3] + t[3], r5[4] = e[4] + t[4], r5[5] = e[5] + t[5], r5[6] = e[6] + t[6], r5[7] = e[7] + t[7], r5[8] = e[8] + t[8], r5[9] = e[9] + t[9], r5[10] = e[10] + t[10], r5[11] = e[11] + t[11], r5[12] = e[12] + t[12], r5[13] = e[13] + t[13], r5[14] = e[14] + t[14], r5[15] = e[15] + t[15], r5;
}
H$3(sI$1, "add");
function av(r5, e, t) {
  return r5[0] = e[0] - t[0], r5[1] = e[1] - t[1], r5[2] = e[2] - t[2], r5[3] = e[3] - t[3], r5[4] = e[4] - t[4], r5[5] = e[5] - t[5], r5[6] = e[6] - t[6], r5[7] = e[7] - t[7], r5[8] = e[8] - t[8], r5[9] = e[9] - t[9], r5[10] = e[10] - t[10], r5[11] = e[11] - t[11], r5[12] = e[12] - t[12], r5[13] = e[13] - t[13], r5[14] = e[14] - t[14], r5[15] = e[15] - t[15], r5;
}
H$3(av, "subtract");
function lI$1(r5, e, t) {
  return r5[0] = e[0] * t, r5[1] = e[1] * t, r5[2] = e[2] * t, r5[3] = e[3] * t, r5[4] = e[4] * t, r5[5] = e[5] * t, r5[6] = e[6] * t, r5[7] = e[7] * t, r5[8] = e[8] * t, r5[9] = e[9] * t, r5[10] = e[10] * t, r5[11] = e[11] * t, r5[12] = e[12] * t, r5[13] = e[13] * t, r5[14] = e[14] * t, r5[15] = e[15] * t, r5;
}
H$3(lI$1, "multiplyScalar");
function uI$1(r5, e, t, i) {
  return r5[0] = e[0] + t[0] * i, r5[1] = e[1] + t[1] * i, r5[2] = e[2] + t[2] * i, r5[3] = e[3] + t[3] * i, r5[4] = e[4] + t[4] * i, r5[5] = e[5] + t[5] * i, r5[6] = e[6] + t[6] * i, r5[7] = e[7] + t[7] * i, r5[8] = e[8] + t[8] * i, r5[9] = e[9] + t[9] * i, r5[10] = e[10] + t[10] * i, r5[11] = e[11] + t[11] * i, r5[12] = e[12] + t[12] * i, r5[13] = e[13] + t[13] * i, r5[14] = e[14] + t[14] * i, r5[15] = e[15] + t[15] * i, r5;
}
H$3(uI$1, "multiplyScalarAndAdd");
function cI$1(r5, e) {
  return r5[0] === e[0] && r5[1] === e[1] && r5[2] === e[2] && r5[3] === e[3] && r5[4] === e[4] && r5[5] === e[5] && r5[6] === e[6] && r5[7] === e[7] && r5[8] === e[8] && r5[9] === e[9] && r5[10] === e[10] && r5[11] === e[11] && r5[12] === e[12] && r5[13] === e[13] && r5[14] === e[14] && r5[15] === e[15];
}
H$3(cI$1, "exactEquals");
function pI$1(r5, e) {
  var t = r5[0], i = r5[1], n4 = r5[2], o4 = r5[3], a4 = r5[4], s5 = r5[5], u5 = r5[6], c = r5[7], p4 = r5[8], h = r5[9], f = r5[10], m5 = r5[11], y4 = r5[12], g = r5[13], x2 = r5[14], b = r5[15], w3 = e[0], _ = e[1], S4 = e[2], P4 = e[3], T3 = e[4], L3 = e[5], C3 = e[6], E4 = e[7], I3 = e[8], R3 = e[9], z4 = e[10], k3 = e[11], M3 = e[12], G3 = e[13], K4 = e[14], ne2 = e[15];
  return Math.abs(t - w3) <= oe$1 * Math.max(1, Math.abs(t), Math.abs(w3)) && Math.abs(i - _) <= oe$1 * Math.max(1, Math.abs(i), Math.abs(_)) && Math.abs(n4 - S4) <= oe$1 * Math.max(1, Math.abs(n4), Math.abs(S4)) && Math.abs(o4 - P4) <= oe$1 * Math.max(1, Math.abs(o4), Math.abs(P4)) && Math.abs(a4 - T3) <= oe$1 * Math.max(1, Math.abs(a4), Math.abs(T3)) && Math.abs(s5 - L3) <= oe$1 * Math.max(1, Math.abs(s5), Math.abs(L3)) && Math.abs(u5 - C3) <= oe$1 * Math.max(1, Math.abs(u5), Math.abs(C3)) && Math.abs(c - E4) <= oe$1 * Math.max(1, Math.abs(c), Math.abs(E4)) && Math.abs(p4 - I3) <= oe$1 * Math.max(1, Math.abs(p4), Math.abs(I3)) && Math.abs(h - R3) <= oe$1 * Math.max(1, Math.abs(h), Math.abs(R3)) && Math.abs(f - z4) <= oe$1 * Math.max(1, Math.abs(f), Math.abs(z4)) && Math.abs(m5 - k3) <= oe$1 * Math.max(1, Math.abs(m5), Math.abs(k3)) && Math.abs(y4 - M3) <= oe$1 * Math.max(1, Math.abs(y4), Math.abs(M3)) && Math.abs(g - G3) <= oe$1 * Math.max(1, Math.abs(g), Math.abs(G3)) && Math.abs(x2 - K4) <= oe$1 * Math.max(1, Math.abs(x2), Math.abs(K4)) && Math.abs(b - ne2) <= oe$1 * Math.max(1, Math.abs(b), Math.abs(ne2));
}
H$3(pI$1, "equals");
var hI$1 = tv, fI = av;
var gt$1 = {};
M$1(gt$1, { add: () => xI$1, angle: () => UI$1, bezier: () => LI$1, ceil: () => bI$1, clone: () => mI$1, copy: () => yI$1, create: () => sv, cross: () => CI$1, dist: () => WI$1, distance: () => hv, div: () => $I$1, divide: () => pv, dot: () => dv, equals: () => jI$1, exactEquals: () => qI$1, floor: () => _I$1, forEach: () => YI$1, fromValues: () => dI, hermite: () => kI$1, inverse: () => AI$1, len: () => KI$1, length: () => lv, lerp: () => EI$1, max: () => wI$1, min: () => vI$1, mul: () => HI$1, multiply: () => cv, negate: () => MI$1, normalize: () => II$1, random: () => DI$1, rotateX: () => BI$1, rotateY: () => OI$1, rotateZ: () => VI$1, round: () => SI$1, scale: () => PI$1, scaleAndAdd: () => TI$1, set: () => gI$1, sqrDist: () => XI$1, sqrLen: () => JI$1, squaredDistance: () => fv, squaredLength: () => mv$1, str: () => GI$1, sub: () => ZI$1, subtract: () => uv, transformMat3: () => FI$1, transformMat4: () => zI$1, transformQuat: () => RI$1, zero: () => NI$1 });
a();
function sv() {
  var r5 = new we$1(3);
  return we$1 != Float32Array && (r5[0] = 0, r5[1] = 0, r5[2] = 0), r5;
}
H$3(sv, "create");
function mI$1(r5) {
  var e = new we$1(3);
  return e[0] = r5[0], e[1] = r5[1], e[2] = r5[2], e;
}
H$3(mI$1, "clone");
function lv(r5) {
  var e = r5[0], t = r5[1], i = r5[2];
  return Math.hypot(e, t, i);
}
H$3(lv, "length");
function dI(r5, e, t) {
  var i = new we$1(3);
  return i[0] = r5, i[1] = e, i[2] = t, i;
}
H$3(dI, "fromValues");
function yI$1(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5[2] = e[2], r5;
}
H$3(yI$1, "copy");
function gI$1(r5, e, t, i) {
  return r5[0] = e, r5[1] = t, r5[2] = i, r5;
}
H$3(gI$1, "set");
function xI$1(r5, e, t) {
  return r5[0] = e[0] + t[0], r5[1] = e[1] + t[1], r5[2] = e[2] + t[2], r5;
}
H$3(xI$1, "add");
function uv(r5, e, t) {
  return r5[0] = e[0] - t[0], r5[1] = e[1] - t[1], r5[2] = e[2] - t[2], r5;
}
H$3(uv, "subtract");
function cv(r5, e, t) {
  return r5[0] = e[0] * t[0], r5[1] = e[1] * t[1], r5[2] = e[2] * t[2], r5;
}
H$3(cv, "multiply");
function pv(r5, e, t) {
  return r5[0] = e[0] / t[0], r5[1] = e[1] / t[1], r5[2] = e[2] / t[2], r5;
}
H$3(pv, "divide");
function bI$1(r5, e) {
  return r5[0] = Math.ceil(e[0]), r5[1] = Math.ceil(e[1]), r5[2] = Math.ceil(e[2]), r5;
}
H$3(bI$1, "ceil");
function _I$1(r5, e) {
  return r5[0] = Math.floor(e[0]), r5[1] = Math.floor(e[1]), r5[2] = Math.floor(e[2]), r5;
}
H$3(_I$1, "floor");
function vI$1(r5, e, t) {
  return r5[0] = Math.min(e[0], t[0]), r5[1] = Math.min(e[1], t[1]), r5[2] = Math.min(e[2], t[2]), r5;
}
H$3(vI$1, "min");
function wI$1(r5, e, t) {
  return r5[0] = Math.max(e[0], t[0]), r5[1] = Math.max(e[1], t[1]), r5[2] = Math.max(e[2], t[2]), r5;
}
H$3(wI$1, "max");
function SI$1(r5, e) {
  return r5[0] = Math.round(e[0]), r5[1] = Math.round(e[1]), r5[2] = Math.round(e[2]), r5;
}
H$3(SI$1, "round");
function PI$1(r5, e, t) {
  return r5[0] = e[0] * t, r5[1] = e[1] * t, r5[2] = e[2] * t, r5;
}
H$3(PI$1, "scale");
function TI$1(r5, e, t, i) {
  return r5[0] = e[0] + t[0] * i, r5[1] = e[1] + t[1] * i, r5[2] = e[2] + t[2] * i, r5;
}
H$3(TI$1, "scaleAndAdd");
function hv(r5, e) {
  var t = e[0] - r5[0], i = e[1] - r5[1], n4 = e[2] - r5[2];
  return Math.hypot(t, i, n4);
}
H$3(hv, "distance");
function fv(r5, e) {
  var t = e[0] - r5[0], i = e[1] - r5[1], n4 = e[2] - r5[2];
  return t * t + i * i + n4 * n4;
}
H$3(fv, "squaredDistance");
function mv$1(r5) {
  var e = r5[0], t = r5[1], i = r5[2];
  return e * e + t * t + i * i;
}
H$3(mv$1, "squaredLength");
function MI$1(r5, e) {
  return r5[0] = -e[0], r5[1] = -e[1], r5[2] = -e[2], r5;
}
H$3(MI$1, "negate");
function AI$1(r5, e) {
  return r5[0] = 1 / e[0], r5[1] = 1 / e[1], r5[2] = 1 / e[2], r5;
}
H$3(AI$1, "inverse");
function II$1(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = t * t + i * i + n4 * n4;
  return o4 > 0 && (o4 = 1 / Math.sqrt(o4)), r5[0] = e[0] * o4, r5[1] = e[1] * o4, r5[2] = e[2] * o4, r5;
}
H$3(II$1, "normalize");
function dv(r5, e) {
  return r5[0] * e[0] + r5[1] * e[1] + r5[2] * e[2];
}
H$3(dv, "dot");
function CI$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = t[0], s5 = t[1], u5 = t[2];
  return r5[0] = n4 * u5 - o4 * s5, r5[1] = o4 * a4 - i * u5, r5[2] = i * s5 - n4 * a4, r5;
}
H$3(CI$1, "cross");
function EI$1(r5, e, t, i) {
  var n4 = e[0], o4 = e[1], a4 = e[2];
  return r5[0] = n4 + i * (t[0] - n4), r5[1] = o4 + i * (t[1] - o4), r5[2] = a4 + i * (t[2] - a4), r5;
}
H$3(EI$1, "lerp");
function kI$1(r5, e, t, i, n4, o4) {
  var a4 = o4 * o4, s5 = a4 * (2 * o4 - 3) + 1, u5 = a4 * (o4 - 2) + o4, c = a4 * (o4 - 1), p4 = a4 * (3 - 2 * o4);
  return r5[0] = e[0] * s5 + t[0] * u5 + i[0] * c + n4[0] * p4, r5[1] = e[1] * s5 + t[1] * u5 + i[1] * c + n4[1] * p4, r5[2] = e[2] * s5 + t[2] * u5 + i[2] * c + n4[2] * p4, r5;
}
H$3(kI$1, "hermite");
function LI$1(r5, e, t, i, n4, o4) {
  var a4 = 1 - o4, s5 = a4 * a4, u5 = o4 * o4, c = s5 * a4, p4 = 3 * o4 * s5, h = 3 * u5 * a4, f = u5 * o4;
  return r5[0] = e[0] * c + t[0] * p4 + i[0] * h + n4[0] * f, r5[1] = e[1] * c + t[1] * p4 + i[1] * h + n4[1] * f, r5[2] = e[2] * c + t[2] * p4 + i[2] * h + n4[2] * f, r5;
}
H$3(LI$1, "bezier");
function DI$1(r5, e) {
  e = e || 1;
  var t = Zt$2() * 2 * Math.PI, i = Zt$2() * 2 - 1, n4 = Math.sqrt(1 - i * i) * e;
  return r5[0] = Math.cos(t) * n4, r5[1] = Math.sin(t) * n4, r5[2] = i * e, r5;
}
H$3(DI$1, "random");
function zI$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = t[3] * i + t[7] * n4 + t[11] * o4 + t[15];
  return a4 = a4 || 1, r5[0] = (t[0] * i + t[4] * n4 + t[8] * o4 + t[12]) / a4, r5[1] = (t[1] * i + t[5] * n4 + t[9] * o4 + t[13]) / a4, r5[2] = (t[2] * i + t[6] * n4 + t[10] * o4 + t[14]) / a4, r5;
}
H$3(zI$1, "transformMat4");
function FI$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2];
  return r5[0] = i * t[0] + n4 * t[3] + o4 * t[6], r5[1] = i * t[1] + n4 * t[4] + o4 * t[7], r5[2] = i * t[2] + n4 * t[5] + o4 * t[8], r5;
}
H$3(FI$1, "transformMat3");
function RI$1(r5, e, t) {
  var i = t[0], n4 = t[1], o4 = t[2], a4 = t[3], s5 = e[0], u5 = e[1], c = e[2], p4 = n4 * c - o4 * u5, h = o4 * s5 - i * c, f = i * u5 - n4 * s5, m5 = n4 * f - o4 * h, y4 = o4 * p4 - i * f, g = i * h - n4 * p4, x2 = a4 * 2;
  return p4 *= x2, h *= x2, f *= x2, m5 *= 2, y4 *= 2, g *= 2, r5[0] = s5 + p4 + m5, r5[1] = u5 + h + y4, r5[2] = c + f + g, r5;
}
H$3(RI$1, "transformQuat");
function BI$1(r5, e, t, i) {
  var n4 = [], o4 = [];
  return n4[0] = e[0] - t[0], n4[1] = e[1] - t[1], n4[2] = e[2] - t[2], o4[0] = n4[0], o4[1] = n4[1] * Math.cos(i) - n4[2] * Math.sin(i), o4[2] = n4[1] * Math.sin(i) + n4[2] * Math.cos(i), r5[0] = o4[0] + t[0], r5[1] = o4[1] + t[1], r5[2] = o4[2] + t[2], r5;
}
H$3(BI$1, "rotateX");
function OI$1(r5, e, t, i) {
  var n4 = [], o4 = [];
  return n4[0] = e[0] - t[0], n4[1] = e[1] - t[1], n4[2] = e[2] - t[2], o4[0] = n4[2] * Math.sin(i) + n4[0] * Math.cos(i), o4[1] = n4[1], o4[2] = n4[2] * Math.cos(i) - n4[0] * Math.sin(i), r5[0] = o4[0] + t[0], r5[1] = o4[1] + t[1], r5[2] = o4[2] + t[2], r5;
}
H$3(OI$1, "rotateY");
function VI$1(r5, e, t, i) {
  var n4 = [], o4 = [];
  return n4[0] = e[0] - t[0], n4[1] = e[1] - t[1], n4[2] = e[2] - t[2], o4[0] = n4[0] * Math.cos(i) - n4[1] * Math.sin(i), o4[1] = n4[0] * Math.sin(i) + n4[1] * Math.cos(i), o4[2] = n4[2], r5[0] = o4[0] + t[0], r5[1] = o4[1] + t[1], r5[2] = o4[2] + t[2], r5;
}
H$3(VI$1, "rotateZ");
function UI$1(r5, e) {
  var t = r5[0], i = r5[1], n4 = r5[2], o4 = e[0], a4 = e[1], s5 = e[2], u5 = Math.sqrt(t * t + i * i + n4 * n4), c = Math.sqrt(o4 * o4 + a4 * a4 + s5 * s5), p4 = u5 * c, h = p4 && dv(r5, e) / p4;
  return Math.acos(Math.min(Math.max(h, -1), 1));
}
H$3(UI$1, "angle");
function NI$1(r5) {
  return r5[0] = 0, r5[1] = 0, r5[2] = 0, r5;
}
H$3(NI$1, "zero");
function GI$1(r5) {
  return "vec3(" + r5[0] + ", " + r5[1] + ", " + r5[2] + ")";
}
H$3(GI$1, "str");
function qI$1(r5, e) {
  return r5[0] === e[0] && r5[1] === e[1] && r5[2] === e[2];
}
H$3(qI$1, "exactEquals");
function jI$1(r5, e) {
  var t = r5[0], i = r5[1], n4 = r5[2], o4 = e[0], a4 = e[1], s5 = e[2];
  return Math.abs(t - o4) <= oe$1 * Math.max(1, Math.abs(t), Math.abs(o4)) && Math.abs(i - a4) <= oe$1 * Math.max(1, Math.abs(i), Math.abs(a4)) && Math.abs(n4 - s5) <= oe$1 * Math.max(1, Math.abs(n4), Math.abs(s5));
}
H$3(jI$1, "equals");
var ZI$1 = uv, HI$1 = cv, $I$1 = pv, WI$1 = hv, XI$1 = fv, KI$1 = lv, JI$1 = mv$1, YI$1 = (function() {
  var r5 = sv();
  return function(e, t, i, n4, o4, a4) {
    var s5, u5;
    for (t || (t = 3), i || (i = 0), n4 ? u5 = Math.min(n4 * t + i, e.length) : u5 = e.length, s5 = i; s5 < u5; s5 += t) r5[0] = e[s5], r5[1] = e[s5 + 1], r5[2] = e[s5 + 2], o4(r5, r5, a4), e[s5] = r5[0], e[s5 + 1] = r5[1], e[s5 + 2] = r5[2];
    return e;
  };
})();
var qe$1 = {};
M$1(qe$1, { add: () => iC$1, ceil: () => nC, clone: () => QI$1, copy: () => tC$1, create: () => yv$1, cross: () => dC, dist: () => AC$1, distance: () => _v, div: () => MC, divide: () => bv, dot: () => mC, equals: () => SC, exactEquals: () => wC, floor: () => oC$1, forEach: () => kC, fromValues: () => eC$1, inverse: () => hC$1, len: () => CC, length: () => wv, lerp: () => yC$1, max: () => sC, min: () => aC, mul: () => TC, multiply: () => xv$1, negate: () => pC$1, normalize: () => fC$1, random: () => gC, round: () => lC$1, scale: () => uC, scaleAndAdd: () => cC, set: () => rC$1, sqrDist: () => IC, sqrLen: () => EC$1, squaredDistance: () => vv, squaredLength: () => Sv$1, str: () => vC$1, sub: () => PC$1, subtract: () => gv, transformMat4: () => xC, transformQuat: () => bC$1, zero: () => _C });
a();
function yv$1() {
  var r5 = new we$1(4);
  return we$1 != Float32Array && (r5[0] = 0, r5[1] = 0, r5[2] = 0, r5[3] = 0), r5;
}
H$3(yv$1, "create");
function QI$1(r5) {
  var e = new we$1(4);
  return e[0] = r5[0], e[1] = r5[1], e[2] = r5[2], e[3] = r5[3], e;
}
H$3(QI$1, "clone");
function eC$1(r5, e, t, i) {
  var n4 = new we$1(4);
  return n4[0] = r5, n4[1] = e, n4[2] = t, n4[3] = i, n4;
}
H$3(eC$1, "fromValues");
function tC$1(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5[2] = e[2], r5[3] = e[3], r5;
}
H$3(tC$1, "copy");
function rC$1(r5, e, t, i, n4) {
  return r5[0] = e, r5[1] = t, r5[2] = i, r5[3] = n4, r5;
}
H$3(rC$1, "set");
function iC$1(r5, e, t) {
  return r5[0] = e[0] + t[0], r5[1] = e[1] + t[1], r5[2] = e[2] + t[2], r5[3] = e[3] + t[3], r5;
}
H$3(iC$1, "add");
function gv(r5, e, t) {
  return r5[0] = e[0] - t[0], r5[1] = e[1] - t[1], r5[2] = e[2] - t[2], r5[3] = e[3] - t[3], r5;
}
H$3(gv, "subtract");
function xv$1(r5, e, t) {
  return r5[0] = e[0] * t[0], r5[1] = e[1] * t[1], r5[2] = e[2] * t[2], r5[3] = e[3] * t[3], r5;
}
H$3(xv$1, "multiply");
function bv(r5, e, t) {
  return r5[0] = e[0] / t[0], r5[1] = e[1] / t[1], r5[2] = e[2] / t[2], r5[3] = e[3] / t[3], r5;
}
H$3(bv, "divide");
function nC(r5, e) {
  return r5[0] = Math.ceil(e[0]), r5[1] = Math.ceil(e[1]), r5[2] = Math.ceil(e[2]), r5[3] = Math.ceil(e[3]), r5;
}
H$3(nC, "ceil");
function oC$1(r5, e) {
  return r5[0] = Math.floor(e[0]), r5[1] = Math.floor(e[1]), r5[2] = Math.floor(e[2]), r5[3] = Math.floor(e[3]), r5;
}
H$3(oC$1, "floor");
function aC(r5, e, t) {
  return r5[0] = Math.min(e[0], t[0]), r5[1] = Math.min(e[1], t[1]), r5[2] = Math.min(e[2], t[2]), r5[3] = Math.min(e[3], t[3]), r5;
}
H$3(aC, "min");
function sC(r5, e, t) {
  return r5[0] = Math.max(e[0], t[0]), r5[1] = Math.max(e[1], t[1]), r5[2] = Math.max(e[2], t[2]), r5[3] = Math.max(e[3], t[3]), r5;
}
H$3(sC, "max");
function lC$1(r5, e) {
  return r5[0] = Math.round(e[0]), r5[1] = Math.round(e[1]), r5[2] = Math.round(e[2]), r5[3] = Math.round(e[3]), r5;
}
H$3(lC$1, "round");
function uC(r5, e, t) {
  return r5[0] = e[0] * t, r5[1] = e[1] * t, r5[2] = e[2] * t, r5[3] = e[3] * t, r5;
}
H$3(uC, "scale");
function cC(r5, e, t, i) {
  return r5[0] = e[0] + t[0] * i, r5[1] = e[1] + t[1] * i, r5[2] = e[2] + t[2] * i, r5[3] = e[3] + t[3] * i, r5;
}
H$3(cC, "scaleAndAdd");
function _v(r5, e) {
  var t = e[0] - r5[0], i = e[1] - r5[1], n4 = e[2] - r5[2], o4 = e[3] - r5[3];
  return Math.hypot(t, i, n4, o4);
}
H$3(_v, "distance");
function vv(r5, e) {
  var t = e[0] - r5[0], i = e[1] - r5[1], n4 = e[2] - r5[2], o4 = e[3] - r5[3];
  return t * t + i * i + n4 * n4 + o4 * o4;
}
H$3(vv, "squaredDistance");
function wv(r5) {
  var e = r5[0], t = r5[1], i = r5[2], n4 = r5[3];
  return Math.hypot(e, t, i, n4);
}
H$3(wv, "length");
function Sv$1(r5) {
  var e = r5[0], t = r5[1], i = r5[2], n4 = r5[3];
  return e * e + t * t + i * i + n4 * n4;
}
H$3(Sv$1, "squaredLength");
function pC$1(r5, e) {
  return r5[0] = -e[0], r5[1] = -e[1], r5[2] = -e[2], r5[3] = -e[3], r5;
}
H$3(pC$1, "negate");
function hC$1(r5, e) {
  return r5[0] = 1 / e[0], r5[1] = 1 / e[1], r5[2] = 1 / e[2], r5[3] = 1 / e[3], r5;
}
H$3(hC$1, "inverse");
function fC$1(r5, e) {
  var t = e[0], i = e[1], n4 = e[2], o4 = e[3], a4 = t * t + i * i + n4 * n4 + o4 * o4;
  return a4 > 0 && (a4 = 1 / Math.sqrt(a4)), r5[0] = t * a4, r5[1] = i * a4, r5[2] = n4 * a4, r5[3] = o4 * a4, r5;
}
H$3(fC$1, "normalize");
function mC(r5, e) {
  return r5[0] * e[0] + r5[1] * e[1] + r5[2] * e[2] + r5[3] * e[3];
}
H$3(mC, "dot");
function dC(r5, e, t, i) {
  var n4 = t[0] * i[1] - t[1] * i[0], o4 = t[0] * i[2] - t[2] * i[0], a4 = t[0] * i[3] - t[3] * i[0], s5 = t[1] * i[2] - t[2] * i[1], u5 = t[1] * i[3] - t[3] * i[1], c = t[2] * i[3] - t[3] * i[2], p4 = e[0], h = e[1], f = e[2], m5 = e[3];
  return r5[0] = h * c - f * u5 + m5 * s5, r5[1] = -(p4 * c) + f * a4 - m5 * o4, r5[2] = p4 * u5 - h * a4 + m5 * n4, r5[3] = -(p4 * s5) + h * o4 - f * n4, r5;
}
H$3(dC, "cross");
function yC$1(r5, e, t, i) {
  var n4 = e[0], o4 = e[1], a4 = e[2], s5 = e[3];
  return r5[0] = n4 + i * (t[0] - n4), r5[1] = o4 + i * (t[1] - o4), r5[2] = a4 + i * (t[2] - a4), r5[3] = s5 + i * (t[3] - s5), r5;
}
H$3(yC$1, "lerp");
function gC(r5, e) {
  e = e || 1;
  var t, i, n4, o4, a4, s5;
  do
    t = Zt$2() * 2 - 1, i = Zt$2() * 2 - 1, a4 = t * t + i * i;
  while (a4 >= 1);
  do
    n4 = Zt$2() * 2 - 1, o4 = Zt$2() * 2 - 1, s5 = n4 * n4 + o4 * o4;
  while (s5 >= 1);
  var u5 = Math.sqrt((1 - a4) / s5);
  return r5[0] = e * t, r5[1] = e * i, r5[2] = e * n4 * u5, r5[3] = e * o4 * u5, r5;
}
H$3(gC, "random");
function xC(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = e[3];
  return r5[0] = t[0] * i + t[4] * n4 + t[8] * o4 + t[12] * a4, r5[1] = t[1] * i + t[5] * n4 + t[9] * o4 + t[13] * a4, r5[2] = t[2] * i + t[6] * n4 + t[10] * o4 + t[14] * a4, r5[3] = t[3] * i + t[7] * n4 + t[11] * o4 + t[15] * a4, r5;
}
H$3(xC, "transformMat4");
function bC$1(r5, e, t) {
  var i = e[0], n4 = e[1], o4 = e[2], a4 = t[0], s5 = t[1], u5 = t[2], c = t[3], p4 = c * i + s5 * o4 - u5 * n4, h = c * n4 + u5 * i - a4 * o4, f = c * o4 + a4 * n4 - s5 * i, m5 = -a4 * i - s5 * n4 - u5 * o4;
  return r5[0] = p4 * c + m5 * -a4 + h * -u5 - f * -s5, r5[1] = h * c + m5 * -s5 + f * -a4 - p4 * -u5, r5[2] = f * c + m5 * -u5 + p4 * -s5 - h * -a4, r5[3] = e[3], r5;
}
H$3(bC$1, "transformQuat");
function _C(r5) {
  return r5[0] = 0, r5[1] = 0, r5[2] = 0, r5[3] = 0, r5;
}
H$3(_C, "zero");
function vC$1(r5) {
  return "vec4(" + r5[0] + ", " + r5[1] + ", " + r5[2] + ", " + r5[3] + ")";
}
H$3(vC$1, "str");
function wC(r5, e) {
  return r5[0] === e[0] && r5[1] === e[1] && r5[2] === e[2] && r5[3] === e[3];
}
H$3(wC, "exactEquals");
function SC(r5, e) {
  var t = r5[0], i = r5[1], n4 = r5[2], o4 = r5[3], a4 = e[0], s5 = e[1], u5 = e[2], c = e[3];
  return Math.abs(t - a4) <= oe$1 * Math.max(1, Math.abs(t), Math.abs(a4)) && Math.abs(i - s5) <= oe$1 * Math.max(1, Math.abs(i), Math.abs(s5)) && Math.abs(n4 - u5) <= oe$1 * Math.max(1, Math.abs(n4), Math.abs(u5)) && Math.abs(o4 - c) <= oe$1 * Math.max(1, Math.abs(o4), Math.abs(c));
}
H$3(SC, "equals");
var PC$1 = gv, TC = xv$1, MC = bv, AC$1 = _v, IC = vv, CC = wv, EC$1 = Sv$1, kC = (function() {
  var r5 = yv$1();
  return function(e, t, i, n4, o4, a4) {
    var s5, u5;
    for (t || (t = 4), i || (i = 0), n4 ? u5 = Math.min(n4 * t + i, e.length) : u5 = e.length, s5 = i; s5 < u5; s5 += t) r5[0] = e[s5], r5[1] = e[s5 + 1], r5[2] = e[s5 + 2], r5[3] = e[s5 + 3], o4(r5, r5, a4), e[s5] = r5[0], e[s5 + 1] = r5[1], e[s5 + 2] = r5[2], e[s5 + 3] = r5[3];
    return e;
  };
})();
var sn = {};
M$1(sn, { add: () => RC$1, angle: () => rE$1, ceil: () => BC$1, clone: () => LC$1, copy: () => zC$1, create: () => Pv$1, cross: () => WC$1, dist: () => pE, distance: () => Iv$1, div: () => cE, divide: () => Av, dot: () => $C$1, equals: () => aE$1, exactEquals: () => oE, floor: () => OC$1, forEach: () => mE$1, fromValues: () => DC$1, inverse: () => ZC, len: () => sE, length: () => Ev, lerp: () => XC$1, max: () => UC, min: () => VC$1, mul: () => uE, multiply: () => Mv$1, negate: () => jC, normalize: () => HC$1, random: () => KC$1, rotate: () => tE, round: () => NC$1, scale: () => GC$1, scaleAndAdd: () => qC$1, set: () => FC$1, sqrDist: () => hE$1, sqrLen: () => fE$1, squaredDistance: () => Cv, squaredLength: () => kv, str: () => nE, sub: () => lE$1, subtract: () => Tv, transformMat2: () => JC$1, transformMat2d: () => YC$1, transformMat3: () => QC$1, transformMat4: () => eE, zero: () => iE });
a();
function Pv$1() {
  var r5 = new we$1(2);
  return we$1 != Float32Array && (r5[0] = 0, r5[1] = 0), r5;
}
H$3(Pv$1, "create");
function LC$1(r5) {
  var e = new we$1(2);
  return e[0] = r5[0], e[1] = r5[1], e;
}
H$3(LC$1, "clone");
function DC$1(r5, e) {
  var t = new we$1(2);
  return t[0] = r5, t[1] = e, t;
}
H$3(DC$1, "fromValues");
function zC$1(r5, e) {
  return r5[0] = e[0], r5[1] = e[1], r5;
}
H$3(zC$1, "copy");
function FC$1(r5, e, t) {
  return r5[0] = e, r5[1] = t, r5;
}
H$3(FC$1, "set");
function RC$1(r5, e, t) {
  return r5[0] = e[0] + t[0], r5[1] = e[1] + t[1], r5;
}
H$3(RC$1, "add");
function Tv(r5, e, t) {
  return r5[0] = e[0] - t[0], r5[1] = e[1] - t[1], r5;
}
H$3(Tv, "subtract");
function Mv$1(r5, e, t) {
  return r5[0] = e[0] * t[0], r5[1] = e[1] * t[1], r5;
}
H$3(Mv$1, "multiply");
function Av(r5, e, t) {
  return r5[0] = e[0] / t[0], r5[1] = e[1] / t[1], r5;
}
H$3(Av, "divide");
function BC$1(r5, e) {
  return r5[0] = Math.ceil(e[0]), r5[1] = Math.ceil(e[1]), r5;
}
H$3(BC$1, "ceil");
function OC$1(r5, e) {
  return r5[0] = Math.floor(e[0]), r5[1] = Math.floor(e[1]), r5;
}
H$3(OC$1, "floor");
function VC$1(r5, e, t) {
  return r5[0] = Math.min(e[0], t[0]), r5[1] = Math.min(e[1], t[1]), r5;
}
H$3(VC$1, "min");
function UC(r5, e, t) {
  return r5[0] = Math.max(e[0], t[0]), r5[1] = Math.max(e[1], t[1]), r5;
}
H$3(UC, "max");
function NC$1(r5, e) {
  return r5[0] = Math.round(e[0]), r5[1] = Math.round(e[1]), r5;
}
H$3(NC$1, "round");
function GC$1(r5, e, t) {
  return r5[0] = e[0] * t, r5[1] = e[1] * t, r5;
}
H$3(GC$1, "scale");
function qC$1(r5, e, t, i) {
  return r5[0] = e[0] + t[0] * i, r5[1] = e[1] + t[1] * i, r5;
}
H$3(qC$1, "scaleAndAdd");
function Iv$1(r5, e) {
  var t = e[0] - r5[0], i = e[1] - r5[1];
  return Math.hypot(t, i);
}
H$3(Iv$1, "distance");
function Cv(r5, e) {
  var t = e[0] - r5[0], i = e[1] - r5[1];
  return t * t + i * i;
}
H$3(Cv, "squaredDistance");
function Ev(r5) {
  var e = r5[0], t = r5[1];
  return Math.hypot(e, t);
}
H$3(Ev, "length");
function kv(r5) {
  var e = r5[0], t = r5[1];
  return e * e + t * t;
}
H$3(kv, "squaredLength");
function jC(r5, e) {
  return r5[0] = -e[0], r5[1] = -e[1], r5;
}
H$3(jC, "negate");
function ZC(r5, e) {
  return r5[0] = 1 / e[0], r5[1] = 1 / e[1], r5;
}
H$3(ZC, "inverse");
function HC$1(r5, e) {
  var t = e[0], i = e[1], n4 = t * t + i * i;
  return n4 > 0 && (n4 = 1 / Math.sqrt(n4)), r5[0] = e[0] * n4, r5[1] = e[1] * n4, r5;
}
H$3(HC$1, "normalize");
function $C$1(r5, e) {
  return r5[0] * e[0] + r5[1] * e[1];
}
H$3($C$1, "dot");
function WC$1(r5, e, t) {
  var i = e[0] * t[1] - e[1] * t[0];
  return r5[0] = r5[1] = 0, r5[2] = i, r5;
}
H$3(WC$1, "cross");
function XC$1(r5, e, t, i) {
  var n4 = e[0], o4 = e[1];
  return r5[0] = n4 + i * (t[0] - n4), r5[1] = o4 + i * (t[1] - o4), r5;
}
H$3(XC$1, "lerp");
function KC$1(r5, e) {
  e = e || 1;
  var t = Zt$2() * 2 * Math.PI;
  return r5[0] = Math.cos(t) * e, r5[1] = Math.sin(t) * e, r5;
}
H$3(KC$1, "random");
function JC$1(r5, e, t) {
  var i = e[0], n4 = e[1];
  return r5[0] = t[0] * i + t[2] * n4, r5[1] = t[1] * i + t[3] * n4, r5;
}
H$3(JC$1, "transformMat2");
function YC$1(r5, e, t) {
  var i = e[0], n4 = e[1];
  return r5[0] = t[0] * i + t[2] * n4 + t[4], r5[1] = t[1] * i + t[3] * n4 + t[5], r5;
}
H$3(YC$1, "transformMat2d");
function QC$1(r5, e, t) {
  var i = e[0], n4 = e[1];
  return r5[0] = t[0] * i + t[3] * n4 + t[6], r5[1] = t[1] * i + t[4] * n4 + t[7], r5;
}
H$3(QC$1, "transformMat3");
function eE(r5, e, t) {
  var i = e[0], n4 = e[1];
  return r5[0] = t[0] * i + t[4] * n4 + t[12], r5[1] = t[1] * i + t[5] * n4 + t[13], r5;
}
H$3(eE, "transformMat4");
function tE(r5, e, t, i) {
  var n4 = e[0] - t[0], o4 = e[1] - t[1], a4 = Math.sin(i), s5 = Math.cos(i);
  return r5[0] = n4 * s5 - o4 * a4 + t[0], r5[1] = n4 * a4 + o4 * s5 + t[1], r5;
}
H$3(tE, "rotate");
function rE$1(r5, e) {
  var t = r5[0], i = r5[1], n4 = e[0], o4 = e[1], a4 = Math.sqrt(t * t + i * i) * Math.sqrt(n4 * n4 + o4 * o4), s5 = a4 && (t * n4 + i * o4) / a4;
  return Math.acos(Math.min(Math.max(s5, -1), 1));
}
H$3(rE$1, "angle");
function iE(r5) {
  return r5[0] = 0, r5[1] = 0, r5;
}
H$3(iE, "zero");
function nE(r5) {
  return "vec2(" + r5[0] + ", " + r5[1] + ")";
}
H$3(nE, "str");
function oE(r5, e) {
  return r5[0] === e[0] && r5[1] === e[1];
}
H$3(oE, "exactEquals");
function aE$1(r5, e) {
  var t = r5[0], i = r5[1], n4 = e[0], o4 = e[1];
  return Math.abs(t - n4) <= oe$1 * Math.max(1, Math.abs(t), Math.abs(n4)) && Math.abs(i - o4) <= oe$1 * Math.max(1, Math.abs(i), Math.abs(o4));
}
H$3(aE$1, "equals");
var sE = Ev, lE$1 = Tv, uE = Mv$1, cE = Av, pE = Iv$1, hE$1 = Cv, fE$1 = kv, mE$1 = (function() {
  var r5 = Pv$1();
  return function(e, t, i, n4, o4, a4) {
    var s5, u5;
    for (t || (t = 2), i || (i = 0), n4 ? u5 = Math.min(n4 * t + i, e.length) : u5 = e.length, s5 = i; s5 < u5; s5 += t) r5[0] = e[s5], r5[1] = e[s5 + 1], o4(r5, r5, a4), e[s5] = r5[0], e[s5 + 1] = r5[1];
    return e;
  };
})();
var Lv = N$2(ge(), 1);
var _m$1 = class _m extends Ge$1 {
  constructor(e) {
    super(e, X_$1);
  }
  createBucket(e) {
    return new hi$1(e);
  }
  queryRadius(e) {
    let t = e;
    return fi$1("circle-radius", this, t) + fi$1("circle-stroke-width", this, t) + kr(this.paint.get("circle-translate"));
  }
  queryIntersectsFeature(e, t, i, n4, o4, a4, s5, u5) {
    let c = Lr$1(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a4.angle, s5), p4 = this.paint.get("circle-radius").evaluate(t, i), h = this.paint.get("circle-stroke-width").evaluate(t, i), f = p4 + h, m5 = this.paint.get("circle-pitch-alignment") === "map", y4 = m5 ? c : dE$1(c, u5), g = m5 ? f * s5 : f;
    for (let x2 of n4) for (let b of x2) {
      let w3 = m5 ? b : Dv$1(b, u5), _ = g, S4 = qe$1.transformMat4([], [b.x, b.y, 0, 1], u5);
      if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? _ *= S4[3] / a4.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (_ *= a4.cameraToCenterDistance / S4[3]), G_(y4, w3, _)) return true;
    }
    return false;
  }
};
H$3(_m$1, "CircleStyleLayer");
var Dl = _m$1;
function Dv$1(r5, e) {
  let t = qe$1.transformMat4([], [r5.x, r5.y, 0, 1], e);
  return new Lv.default(t[0] / t[3], t[1] / t[3]);
}
H$3(Dv$1, "projectPoint");
function dE$1(r5, e) {
  return r5.map((t) => Dv$1(t, e));
}
H$3(dE$1, "projectQueryGeometry");
a();
a();
var vm$1 = class vm extends hi$1 {
};
H$3(vm$1, "HeatmapBucket");
var No = vm$1;
N$1("HeatmapBucket", No, { omit: ["layers"] });
a();
var zv, yE$1 = H$3(() => zv = zv || new De$2({ "heatmap-radius": new $(A$1.paint_heatmap["heatmap-radius"]), "heatmap-weight": new $(A$1.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Z$2(A$1.paint_heatmap["heatmap-intensity"]), "heatmap-color": new si$1(A$1.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Z$2(A$1.paint_heatmap["heatmap-opacity"]) }), "getPaint"), Fv = { get paint() {
  return yE$1();
} };
a();
a();
function wm$1(r5, { width: e, height: t }, i, n4) {
  if (!n4) n4 = new Uint8Array(e * t * i);
  else if (n4 instanceof Uint8ClampedArray) n4 = new Uint8Array(n4.buffer);
  else if (n4.length !== e * t * i) throw new RangeError("mismatched image size. expected: ".concat(n4.length, " but got: ").concat(e * t * i));
  return r5.width = e, r5.height = t, r5.data = n4, r5;
}
H$3(wm$1, "createImage");
function Rv(r5, { width: e, height: t }, i) {
  if (e === r5.width && t === r5.height) return;
  let n4 = wm$1({}, { width: e, height: t }, i);
  Sm$1(r5, n4, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r5.width, e), height: Math.min(r5.height, t) }, i), r5.width = e, r5.height = t, r5.data = n4.data;
}
H$3(Rv, "resizeImage");
function Sm$1(r5, e, t, i, n4, o4) {
  if (n4.width === 0 || n4.height === 0) return e;
  if (n4.width > r5.width || n4.height > r5.height || t.x > r5.width - n4.width || t.y > r5.height - n4.height) throw new RangeError("out of range source coordinates for image copy");
  if (n4.width > e.width || n4.height > e.height || i.x > e.width - n4.width || i.y > e.height - n4.height) throw new RangeError("out of range destination coordinates for image copy");
  let a4 = r5.data, s5 = e.data;
  if (a4 === s5) throw new Error("srcData equals dstData, so image is already copied");
  for (let u5 = 0; u5 < n4.height; u5++) {
    let c = ((t.y + u5) * r5.width + t.x) * o4, p4 = ((i.y + u5) * e.width + i.x) * o4;
    for (let h = 0; h < n4.width * o4; h++) s5[p4 + h] = a4[c + h];
  }
  return e;
}
H$3(Sm$1, "copyImage");
var zl = class zl2 {
  constructor(e, t) {
    wm$1(this, e, 1, t);
  }
  resize(e) {
    Rv(this, e, 1);
  }
  clone() {
    return new zl2({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, t, i, n4, o4) {
    Sm$1(e, t, i, n4, o4, 1);
  }
};
H$3(zl, "AlphaImage");
var mi = zl, Fl = class Fl2 {
  constructor(e, t) {
    wm$1(this, e, 4, t);
  }
  resize(e) {
    Rv(this, e, 4);
  }
  replace(e, t) {
    t ? this.data.set(e) : e instanceof Uint8ClampedArray ? this.data = new Uint8Array(e.buffer) : this.data = e;
  }
  clone() {
    return new Fl2({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e, t, i, n4, o4) {
    Sm$1(e, t, i, n4, o4, 4);
  }
};
H$3(Fl, "RGBAImage");
var Se$2 = Fl;
N$1("AlphaImage", mi);
N$1("RGBAImage", Se$2);
function Rl(r5) {
  let e = {}, t = r5.resolution || 256, i = r5.clips ? r5.clips.length : 1, n4 = r5.image || new Se$2({ width: t, height: i });
  if (!Yx$1(t)) throw new Error("width is not a power of 2 - ".concat(t));
  let o4 = H$3((a4, s5, u5) => {
    e[r5.evaluationKey] = u5;
    let c = r5.expression.evaluate(e);
    n4.data[a4 + s5 + 0] = Math.floor(c.r * 255 / c.a), n4.data[a4 + s5 + 1] = Math.floor(c.g * 255 / c.a), n4.data[a4 + s5 + 2] = Math.floor(c.b * 255 / c.a), n4.data[a4 + s5 + 3] = Math.floor(c.a * 255);
  }, "renderPixel");
  if (r5.clips) for (let a4 = 0, s5 = 0; a4 < i; ++a4, s5 += t * 4) for (let u5 = 0, c = 0; u5 < t; u5++, c += 4) {
    let p4 = u5 / (t - 1), { start: h, end: f } = r5.clips[a4], m5 = h * (1 - p4) + f * p4;
    o4(s5, c, m5);
  }
  else for (let a4 = 0, s5 = 0; a4 < t; a4++, s5 += 4) {
    let u5 = a4 / (t - 1);
    o4(0, s5, u5);
  }
  return n4;
}
H$3(Rl, "renderColorRamp");
var Pm$1 = class Pm extends Ge$1 {
  createBucket(e) {
    return new No(e);
  }
  constructor(e) {
    super(e, Fv), this._updateColorRamp();
  }
  _handleSpecialPaintPropertyUpdate(e) {
    e === "heatmap-color" && this._updateColorRamp();
  }
  _updateColorRamp() {
    let e = this._transitionablePaint._values["heatmap-color"].value.expression;
    this.colorRamp = Rl({ expression: e, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
  }
  resize() {
    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    return false;
  }
  hasOffscreenPass() {
    return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
  }
};
H$3(Pm$1, "HeatmapStyleLayer");
var Bl = Pm$1;
a();
a();
var Bv, gE = H$3(() => Bv = Bv || new De$2({ "hillshade-illumination-direction": new Z$2(A$1.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Z$2(A$1.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Z$2(A$1.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Z$2(A$1.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Z$2(A$1.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Z$2(A$1.paint_hillshade["hillshade-accent-color"]) }), "getPaint"), Ov$1 = { get paint() {
  return gE();
} };
var Tm$1 = class Tm extends Ge$1 {
  constructor(e) {
    super(e, Ov$1);
  }
  hasOffscreenPass() {
    return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
  }
};
H$3(Tm$1, "HillshadeStyleLayer");
var Ol = Tm$1;
a();
a();
a();
var xE = _e$1([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: Vv$1, size: cO$1, alignment: pO$1 } = xE;
var Zv$1 = N$2(Em$1(), 1);
a();
a();
function km$1(r5, e, t, i, n4) {
  jv$1(r5, e, t || 0, i || r5.length - 1, n4 || zE);
}
H$3(km$1, "quickselect");
function jv$1(r5, e, t, i, n4) {
  for (; i > t; ) {
    if (i - t > 600) {
      var o4 = i - t + 1, a4 = e - t + 1, s5 = Math.log(o4), u5 = 0.5 * Math.exp(2 * s5 / 3), c = 0.5 * Math.sqrt(s5 * u5 * (o4 - u5) / o4) * (a4 - o4 / 2 < 0 ? -1 : 1), p4 = Math.max(t, Math.floor(e - a4 * u5 / o4 + c)), h = Math.min(i, Math.floor(e + (o4 - a4) * u5 / o4 + c));
      jv$1(r5, e, p4, h, n4);
    }
    var f = r5[e], m5 = t, y4 = i;
    for (Zo(r5, t, e), n4(r5[i], f) > 0 && Zo(r5, t, i); m5 < y4; ) {
      for (Zo(r5, m5, y4), m5++, y4--; n4(r5[m5], f) < 0; ) m5++;
      for (; n4(r5[y4], f) > 0; ) y4--;
    }
    n4(r5[t], f) === 0 ? Zo(r5, t, y4) : (y4++, Zo(r5, y4, i)), y4 <= e && (t = y4 + 1), e <= y4 && (i = y4 - 1);
  }
}
H$3(jv$1, "quickselectStep");
function Zo(r5, e, t) {
  var i = r5[e];
  r5[e] = r5[t], r5[t] = i;
}
H$3(Zo, "swap");
function zE(r5, e) {
  return r5 < e ? -1 : r5 > e ? 1 : 0;
}
H$3(zE, "defaultCompare");
function Ho$1(r5, e) {
  let t = r5.length;
  if (t <= 1) return [r5];
  let i = [], n4, o4;
  for (let a4 = 0; a4 < t; a4++) {
    let s5 = rb$1(r5[a4]);
    s5 !== 0 && (r5[a4].area = Math.abs(s5), o4 === void 0 && (o4 = s5 < 0), o4 === s5 < 0 ? (n4 && i.push(n4), n4 = [r5[a4]]) : n4.push(r5[a4]));
  }
  if (n4 && i.push(n4), e > 1) for (let a4 = 0; a4 < i.length; a4++) i[a4].length <= e || (km$1(i[a4], e, 1, i[a4].length - 1, FE), i[a4] = i[a4].slice(0, e));
  return i;
}
H$3(Ho$1, "classifyRings");
function FE(r5, e) {
  return e.area - r5.area;
}
H$3(FE, "compareAreas");
a();
function un(r5, e, t) {
  let i = t.patternDependencies, n4 = false;
  for (let o4 of e) {
    let a4 = o4.paint.get("".concat(r5, "-pattern"));
    a4.isConstant() || (n4 = true);
    let s5 = a4.constantOr(null);
    s5 && (n4 = true, i[s5.to] = true, i[s5.from] = true);
  }
  return n4;
}
H$3(un, "hasPattern");
function cn$2(r5, e, t, i, n4) {
  let o4 = n4.patternDependencies;
  for (let a4 of e) {
    let u5 = a4.paint.get("".concat(r5, "-pattern")).value;
    if (u5.kind !== "constant") {
      let c = u5.evaluate({ zoom: i - 1 }, t, {}, n4.availableImages), p4 = u5.evaluate({ zoom: i }, t, {}, n4.availableImages), h = u5.evaluate({ zoom: i + 1 }, t, {}, n4.availableImages);
      c = c && c.name ? c.name : c, p4 = p4 && p4.name ? p4.name : p4, h = h && h.name ? h.name : h, o4[c] = true, o4[p4] = true, o4[h] = true, t.patterns[a4.id] = { min: c, mid: p4, max: h };
    }
  }
  return t;
}
H$3(cn$2, "addPatternDependencies");
var RE = 500, Lm$1 = class Lm {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new dl$1(), this.indexArray = new it$2(), this.indexArray2 = new Ir$1(), this.programConfigurations = new mt$1(e.layers, e.zoom), this.segments = new me$1(), this.segments2 = new me$1(), this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    this.hasPattern = un("fill", this.layers, t);
    let n4 = this.layers[0].layout.get("fill-sort-key"), o4 = !n4.isConstant(), a4 = [];
    for (let { feature: s5, id: u5, index: c, sourceLayerIndex: p4 } of e) {
      let h = this.layers[0]._featureFilter.needGeometry, f = yt$1(s5, h);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), f, i)) continue;
      let m5 = o4 ? n4.evaluate(f, {}, i, t.availableImages) : void 0, y4 = { id: u5, properties: s5.properties, type: s5.type, sourceLayerIndex: p4, index: c, geometry: h ? f.geometry : dt$1(s5), patterns: {}, sortKey: m5 };
      a4.push(y4);
    }
    o4 && a4.sort((s5, u5) => s5.sortKey - u5.sortKey);
    for (let s5 of a4) {
      let { geometry: u5, index: c, sourceLayerIndex: p4 } = s5;
      if (this.hasPattern) {
        let f = cn$2("fill", this.layers, s5, this.zoom, t);
        this.patternFeatures.push(f);
      } else this.addFeature(s5, u5, c, i, {});
      let h = e[c].feature;
      t.featureIndex.insert(h, u5, c, p4, this.index);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  addFeatures(e, t, i) {
    for (let n4 of this.patternFeatures) this.addFeature(n4, n4.geometry, n4.index, t, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Vv$1), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
  }
  addFeature(e, t, i, n4, o4) {
    for (let a4 of Ho$1(t, RE)) {
      let s5 = 0;
      for (let m5 of a4) s5 += m5.length;
      let u5 = this.segments.prepareSegment(s5, this.layoutVertexArray, this.indexArray), c = u5.vertexLength, p4 = [], h = [];
      for (let m5 of a4) {
        if (m5.length === 0) continue;
        m5 !== a4[0] && h.push(p4.length / 2);
        let y4 = this.segments2.prepareSegment(m5.length, this.layoutVertexArray, this.indexArray2), g = y4.vertexLength;
        this.layoutVertexArray.emplaceBack(m5[0].x, m5[0].y), this.indexArray2.emplaceBack(g + m5.length - 1, g), p4.push(m5[0].x), p4.push(m5[0].y);
        for (let x2 = 1; x2 < m5.length; x2++) this.layoutVertexArray.emplaceBack(m5[x2].x, m5[x2].y), this.indexArray2.emplaceBack(g + x2 - 1, g + x2), p4.push(m5[x2].x), p4.push(m5[x2].y);
        y4.vertexLength += m5.length, y4.primitiveLength += m5.length;
      }
      let f = (0, Zv$1.default)(p4, h);
      for (let m5 = 0; m5 < f.length; m5 += 3) this.indexArray.emplaceBack(c + f[m5], c + f[m5 + 1], c + f[m5 + 2]);
      u5.vertexLength += s5, u5.primitiveLength += f.length / 3;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o4, n4);
  }
};
H$3(Lm$1, "FillBucket");
var $o = Lm$1;
N$1("FillBucket", $o, { omit: ["layers", "patternFeatures"] });
a();
var Hv$1, BE$1 = H$3(() => Hv$1 = Hv$1 || new De$2({ "fill-sort-key": new $(A$1.layout_fill["fill-sort-key"]) }), "getLayout"), $v$1, OE = H$3(() => $v$1 = $v$1 || new De$2({ "fill-antialias": new Z$2(A$1.paint_fill["fill-antialias"]), "fill-opacity": new $(A$1.paint_fill["fill-opacity"]), "fill-color": new $(A$1.paint_fill["fill-color"]), "fill-outline-color": new $(A$1.paint_fill["fill-outline-color"]), "fill-translate": new Z$2(A$1.paint_fill["fill-translate"]), "fill-translate-anchor": new Z$2(A$1.paint_fill["fill-translate-anchor"]), "fill-pattern": new ar(A$1.paint_fill["fill-pattern"]) }), "getPaint"), Wv$1 = { get paint() {
  return OE();
}, get layout() {
  return BE$1();
} };
var Dm = class Dm2 extends Ge$1 {
  constructor(e) {
    super(e, Wv$1);
  }
  recalculate(e, t) {
    super.recalculate(e, t);
    let i = this.paint._values["fill-outline-color"];
    i.value.kind === "constant" && i.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
  }
  createBucket(e) {
    return new $o(e);
  }
  queryRadius() {
    return kr(this.paint.get("fill-translate"));
  }
  queryIntersectsFeature(e, t, i, n4, o4, a4, s5) {
    let u5 = Lr$1(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a4.angle, s5);
    return kl(u5, n4);
  }
  isTileClipped() {
    return true;
  }
};
H$3(Dm, "FillStyleLayer");
var ql$1 = Dm;
a();
a();
a();
var VE$1 = _e$1([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Xv$1 = _e$1([{ name: "a_centroid", components: 2, type: "Int16" }], 4);
var { members: Kv$1, size: l4$1, alignment: u4 } = VE$1;
var r0$1 = N$2(Em$1(), 1), i0$1 = N$2(Wo$1(), 1);
var JE = i0$1.default.VectorTileFeature.types, YE$1 = 500, Rm$1 = Math.pow(2, 13);
function Xo$1(r5, e, t, i, n4, o4, a4, s5) {
  r5.emplaceBack(e, t, Math.floor(i * Rm$1) * 2 + a4, n4 * Rm$1 * 2, o4 * Rm$1 * 2, Math.round(s5));
}
H$3(Xo$1, "addVertex");
var Bm$1 = class Bm {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.layoutVertexArray = new yl$1(), this.centroidVertexArray = new Ar$1(), this.indexArray = new it$2(), this.programConfigurations = new mt$1(e.layers, e.zoom), this.segments = new me$1(), this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    this.features = [], this.hasPattern = un("fill-extrusion", this.layers, t);
    for (let { feature: n4, id: o4, index: a4, sourceLayerIndex: s5 } of e) {
      let u5 = this.layers[0]._featureFilter.needGeometry, c = yt$1(n4, u5);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), c, i)) continue;
      let p4 = { id: o4, sourceLayerIndex: s5, index: a4, geometry: u5 ? c.geometry : dt$1(n4), properties: n4.properties, type: n4.type, patterns: {} };
      this.hasPattern ? this.features.push(cn$2("fill-extrusion", this.layers, p4, this.zoom, t)) : this.addFeature(p4, p4.geometry, a4, i, {}), t.featureIndex.insert(n4, p4.geometry, a4, s5, this.index, true);
    }
  }
  addFeatures(e, t, i) {
    for (let n4 of this.features) {
      let { geometry: o4 } = n4;
      this.addFeature(n4, o4, n4.index, t, i);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Kv$1), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Xv$1.members, true), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
  }
  addFeature(e, t, i, n4, o4) {
    let a4 = { x: 0, y: 0, vertexCount: 0 };
    for (let s5 of Ho$1(t, YE$1)) {
      let u5 = 0;
      for (let y4 of s5) u5 += y4.length;
      let c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
      for (let y4 of s5) {
        if (y4.length === 0 || ek(y4)) continue;
        let g = 0;
        for (let x2 = 0; x2 < y4.length; x2++) {
          let b = y4[x2];
          if (x2 >= 1) {
            let w3 = y4[x2 - 1];
            if (!QE(b, w3)) {
              c.vertexLength + 4 > me$1.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              let _ = b.sub(w3)._perp()._unit(), S4 = w3.dist(b);
              g + S4 > 32768 && (g = 0), Xo$1(this.layoutVertexArray, b.x, b.y, _.x, _.y, 0, 0, g), Xo$1(this.layoutVertexArray, b.x, b.y, _.x, _.y, 0, 1, g), a4.x += 2 * b.x, a4.y += 2 * b.y, a4.vertexCount += 2, g += S4, Xo$1(this.layoutVertexArray, w3.x, w3.y, _.x, _.y, 0, 0, g), Xo$1(this.layoutVertexArray, w3.x, w3.y, _.x, _.y, 0, 1, g), a4.x += 2 * w3.x, a4.y += 2 * w3.y, a4.vertexCount += 2;
              let P4 = c.vertexLength;
              this.indexArray.emplaceBack(P4, P4 + 2, P4 + 1), this.indexArray.emplaceBack(P4 + 1, P4 + 2, P4 + 3), c.vertexLength += 4, c.primitiveLength += 2;
            }
          }
        }
      }
      if (c.vertexLength + u5 > me$1.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(u5, this.layoutVertexArray, this.indexArray)), JE[e.type] !== "Polygon") continue;
      let p4 = [], h = [], f = c.vertexLength;
      for (let y4 of s5) if (y4.length !== 0) {
        y4 !== s5[0] && h.push(p4.length / 2);
        for (let g = 0; g < y4.length; g++) {
          let x2 = y4[g];
          Xo$1(this.layoutVertexArray, x2.x, x2.y, 0, 0, 1, 1, 0), a4.x += x2.x, a4.y += x2.y, a4.vertexCount += 1, p4.push(x2.x), p4.push(x2.y);
        }
      }
      let m5 = (0, r0$1.default)(p4, h);
      for (let y4 = 0; y4 < m5.length; y4 += 3) this.indexArray.emplaceBack(f + m5[y4], f + m5[y4 + 2], f + m5[y4 + 1]);
      c.primitiveLength += m5.length / 3, c.vertexLength += u5;
    }
    for (let s5 = 0; s5 < a4.vertexCount; s5++) this.centroidVertexArray.emplaceBack(Math.floor(a4.x / a4.vertexCount), Math.floor(a4.y / a4.vertexCount));
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o4, n4);
  }
};
H$3(Bm$1, "FillExtrusionBucket");
var Ko = Bm$1;
N$1("FillExtrusionBucket", Ko, { omit: ["layers", "features"] });
function QE(r5, e) {
  return r5.x === e.x && (r5.x < 0 || r5.x > 8192) || r5.y === e.y && (r5.y < 0 || r5.y > 8192);
}
H$3(QE, "isBoundaryEdge");
function ek(r5) {
  return r5.every((e) => e.x < 0) || r5.every((e) => e.x > 8192) || r5.every((e) => e.y < 0) || r5.every((e) => e.y > 8192);
}
H$3(ek, "isEntirelyOutside");
a();
var n0$1, tk = H$3(() => n0$1 = n0$1 || new De$2({ "fill-extrusion-opacity": new Z$2(A$1["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new $(A$1["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Z$2(A$1["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Z$2(A$1["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ar(A$1["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new $(A$1["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new $(A$1["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Z$2(A$1["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }), "getPaint"), o0$1 = { get paint() {
  return tk();
} };
var Zl$1 = N$2(ge(), 1);
var Om$1 = class Om extends Ge$1 {
  constructor(e) {
    super(e, o0$1);
  }
  createBucket(e) {
    return new Ko(e);
  }
  queryRadius() {
    return kr(this.paint.get("fill-extrusion-translate"));
  }
  is3D() {
    return true;
  }
  queryIntersectsFeature(e, t, i, n4, o4, a4, s5, u5) {
    let c = Lr$1(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a4.angle, s5), p4 = this.paint.get("fill-extrusion-height").evaluate(t, i), h = this.paint.get("fill-extrusion-base").evaluate(t, i), f = nk(c, u5, a4, 0), m5 = ik(n4, h, p4, u5), y4 = m5[0], g = m5[1];
    return rk(y4, g, f);
  }
};
H$3(Om$1, "FillExtrusionStyleLayer");
var Hl = Om$1;
function Jo$1(r5, e) {
  return r5.x * e.x + r5.y * e.y;
}
H$3(Jo$1, "dot");
function a0$1(r5, e) {
  if (r5.length === 1) {
    let t = 0, i = e[t++], n4;
    for (; !n4 || i.equals(n4); ) if (n4 = e[t++], !n4) return 1 / 0;
    for (; t < e.length; t++) {
      let o4 = e[t], a4 = r5[0], s5 = n4.sub(i), u5 = o4.sub(i), c = a4.sub(i), p4 = Jo$1(s5, s5), h = Jo$1(s5, u5), f = Jo$1(u5, u5), m5 = Jo$1(c, s5), y4 = Jo$1(c, u5), g = p4 * f - h * h, x2 = (f * m5 - h * y4) / g, b = (p4 * y4 - h * m5) / g, w3 = 1 - x2 - b, _ = i.z * w3 + n4.z * x2 + o4.z * b;
      if (isFinite(_)) return _;
    }
    return 1 / 0;
  } else {
    let t = 1 / 0;
    for (let i of e) t = Math.min(t, i.z);
    return t;
  }
}
H$3(a0$1, "getIntersectionDistance");
function rk(r5, e, t) {
  let i = 1 / 0;
  kl(t, e) && (i = a0$1(t, e[0]));
  for (let n4 = 0; n4 < e.length; n4++) {
    let o4 = e[n4], a4 = r5[n4];
    for (let s5 = 0; s5 < o4.length - 1; s5++) {
      let u5 = o4[s5], c = o4[s5 + 1], p4 = a4[s5], h = a4[s5 + 1], f = [u5, c, h, p4, u5];
      El$1(t, f) && (i = Math.min(i, a0$1(t, f)));
    }
  }
  return i === 1 / 0 ? false : i;
}
H$3(rk, "checkIntersection");
function ik(r5, e, t, i) {
  let n4 = [], o4 = [], a4 = i[8] * e, s5 = i[9] * e, u5 = i[10] * e, c = i[11] * e, p4 = i[8] * t, h = i[9] * t, f = i[10] * t, m5 = i[11] * t;
  for (let y4 of r5) {
    let g = [], x2 = [];
    for (let b of y4) {
      let w3 = b.x, _ = b.y, S4 = i[0] * w3 + i[4] * _ + i[12], P4 = i[1] * w3 + i[5] * _ + i[13], T3 = i[2] * w3 + i[6] * _ + i[14], L3 = i[3] * w3 + i[7] * _ + i[15], C3 = S4 + a4, E4 = P4 + s5, I3 = T3 + u5, R3 = L3 + c, z4 = S4 + p4, k3 = P4 + h, M3 = T3 + f, G3 = L3 + m5, K4 = new Zl$1.default(C3 / R3, E4 / R3);
      K4.z = I3 / R3, g.push(K4);
      let ne2 = new Zl$1.default(z4 / G3, k3 / G3);
      ne2.z = M3 / G3, x2.push(ne2);
    }
    n4.push(g), o4.push(x2);
  }
  return [n4, o4];
}
H$3(ik, "projectExtrusion");
function nk(r5, e, t, i) {
  let n4 = [];
  for (let o4 of r5) {
    let a4 = [o4.x, o4.y, i, 1];
    qe$1.transformMat4(a4, a4, e), n4.push(new Zl$1.default(a4[0] / a4[3], a4[1] / a4[3]));
  }
  return n4;
}
H$3(nk, "projectQueryGeometry");
a();
a();
a();
var ok = _e$1([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: s0$1, size: o5, alignment: a5 } = ok;
a();
var ak = _e$1([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: l0$1, size: c5$1, alignment: p5 } = ak;
var p0$1 = N$2(Wo$1(), 1);
var sk = p0$1.default.VectorTileFeature.types, u0$1 = 63, lk = Math.cos(75 / 2 * (Math.PI / 180)), uk = 15, ck = 20, pk = 15, h0$1 = 1 / 2, c0$1 = Math.pow(2, pk - 1) / h0$1, Vm$1 = class Vm {
  constructor(e) {
    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t) => t.id), this.index = e.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t) => {
      this.gradients[t.id] = {};
    }), this.layoutVertexArray = new gl$1(), this.layoutVertexArray2 = new xl$1(), this.indexArray = new it$2(), this.programConfigurations = new mt$1(e.layers, e.zoom), this.segments = new me$1(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t) => t.isStateDependent()).map((t) => t.id);
  }
  populate(e, t, i) {
    this.hasPattern = un("line", this.layers, t);
    let n4 = this.layers[0].layout.get("line-sort-key"), o4 = !n4.isConstant(), a4 = [];
    for (let { feature: s5, id: u5, index: c, sourceLayerIndex: p4 } of e) {
      let h = this.layers[0]._featureFilter.needGeometry, f = yt$1(s5, h);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), f, i)) continue;
      let m5 = o4 ? n4.evaluate(f, {}, i) : void 0, y4 = { id: u5, properties: s5.properties, type: s5.type, sourceLayerIndex: p4, index: c, geometry: h ? f.geometry : dt$1(s5), patterns: {}, sortKey: m5 };
      a4.push(y4);
    }
    o4 && a4.sort((s5, u5) => s5.sortKey - u5.sortKey);
    for (let s5 of a4) {
      let { geometry: u5, index: c, sourceLayerIndex: p4 } = s5;
      if (this.hasPattern) {
        let f = cn$2("line", this.layers, s5, this.zoom, t);
        this.patternFeatures.push(f);
      } else this.addFeature(s5, u5, c, i, {});
      let h = e[c].feature;
      t.featureIndex.insert(h, u5, c, p4, this.index);
    }
  }
  update(e, t, i) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, i);
  }
  addFeatures(e, t, i) {
    for (let n4 of this.patternFeatures) this.addFeature(n4, n4.geometry, n4.index, t, i);
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e) {
    this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, l0$1)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, s0$1), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  lineFeatureClips(e) {
    if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) {
      let t = +e.properties.mapbox_clip_start, i = +e.properties.mapbox_clip_end;
      return { start: t, end: i };
    }
  }
  addFeature(e, t, i, n4, o4) {
    let a4 = this.layers[0].layout, s5 = a4.get("line-join").evaluate(e, {}), u5 = a4.get("line-cap"), c = a4.get("line-miter-limit"), p4 = a4.get("line-round-limit");
    this.lineClips = this.lineFeatureClips(e);
    for (let h of t) this.addLine(h, e, s5, u5, c, p4);
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, o4, n4);
  }
  addLine(e, t, i, n4, o4, a4) {
    if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
      this.lineClipsArray.push(this.lineClips);
      for (let b = 0; b < e.length - 1; b++) this.totalDistance += e[b].dist(e[b + 1]);
      this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
    }
    let s5 = sk[t.type] === "Polygon", u5 = e.length;
    for (; u5 >= 2 && e[u5 - 1].equals(e[u5 - 2]); ) u5--;
    let c = 0;
    for (; c < u5 - 1 && e[c].equals(e[c + 1]); ) c++;
    if (u5 < (s5 ? 3 : 2)) return;
    i === "bevel" && (o4 = 1.05);
    let p4 = this.overscaling <= 16 ? uk * 8192 / (512 * this.overscaling) : 0, h = this.segments.prepareSegment(u5 * 10, this.layoutVertexArray, this.indexArray), f, m5, y4, g, x2;
    this.e1 = this.e2 = -1, s5 && (f = e[u5 - 2], x2 = e[c].sub(f)._unit()._perp());
    for (let b = c; b < u5; b++) {
      if (y4 = b === u5 - 1 ? s5 ? e[c + 1] : void 0 : e[b + 1], y4 && e[b].equals(y4)) continue;
      x2 && (g = x2), f && (m5 = f), f = e[b], x2 = y4 ? y4.sub(f)._unit()._perp() : g, g = g || x2;
      let w3 = g.add(x2);
      (w3.x !== 0 || w3.y !== 0) && w3._unit();
      let _ = g.x * x2.x + g.y * x2.y, S4 = w3.x * x2.x + w3.y * x2.y, P4 = S4 !== 0 ? 1 / S4 : 1 / 0, T3 = 2 * Math.sqrt(2 - 2 * S4), L3 = S4 < lk && m5 && y4, C3 = g.x * x2.y - g.y * x2.x > 0;
      if (L3 && b > c) {
        let R3 = f.dist(m5);
        if (R3 > 2 * p4) {
          let z4 = f.sub(f.sub(m5)._mult(p4 / R3)._round());
          this.updateDistance(m5, z4), this.addCurrentVertex(z4, g, 0, 0, h), m5 = z4;
        }
      }
      let E4 = m5 && y4, I3 = E4 ? i : s5 ? "butt" : n4;
      if (E4 && I3 === "round" && (P4 < a4 ? I3 = "miter" : P4 <= 2 && (I3 = "fakeround")), I3 === "miter" && P4 > o4 && (I3 = "bevel"), I3 === "bevel" && (P4 > 2 && (I3 = "flipbevel"), P4 < o4 && (I3 = "miter")), m5 && this.updateDistance(m5, f), I3 === "miter") w3._mult(P4), this.addCurrentVertex(f, w3, 0, 0, h);
      else if (I3 === "flipbevel") {
        if (P4 > 100) w3 = x2.mult(-1);
        else {
          let R3 = P4 * g.add(x2).mag() / g.sub(x2).mag();
          w3._perp()._mult(R3 * (C3 ? -1 : 1));
        }
        this.addCurrentVertex(f, w3, 0, 0, h), this.addCurrentVertex(f, w3.mult(-1), 0, 0, h);
      } else if (I3 === "bevel" || I3 === "fakeround") {
        let R3 = -Math.sqrt(P4 * P4 - 1), z4 = C3 ? R3 : 0, k3 = C3 ? 0 : R3;
        if (m5 && this.addCurrentVertex(f, g, z4, k3, h), I3 === "fakeround") {
          let M3 = Math.round(T3 * 180 / Math.PI / ck);
          for (let G3 = 1; G3 < M3; G3++) {
            let K4 = G3 / M3;
            if (K4 !== 0.5) {
              let J4 = K4 - 0.5, W4 = 1.0904 + _ * (-3.2452 + _ * (3.55645 - _ * 1.43519)), Ye2 = 0.848013 + _ * (-1.06021 + _ * 0.215638);
              K4 = K4 + K4 * J4 * (K4 - 1) * (W4 * J4 * J4 + Ye2);
            }
            let ne2 = x2.sub(g)._mult(K4)._add(g)._unit()._mult(C3 ? -1 : 1);
            this.addHalfVertex(f, ne2.x, ne2.y, false, C3, 0, h);
          }
        }
        y4 && this.addCurrentVertex(f, x2, -z4, -k3, h);
      } else if (I3 === "butt") this.addCurrentVertex(f, w3, 0, 0, h);
      else if (I3 === "square") {
        let R3 = m5 ? 1 : -1;
        this.addCurrentVertex(f, w3, R3, R3, h);
      } else I3 === "round" && (m5 && (this.addCurrentVertex(f, g, 0, 0, h), this.addCurrentVertex(f, g, 1, 1, h, true)), y4 && (this.addCurrentVertex(f, x2, -1, -1, h, true), this.addCurrentVertex(f, x2, 0, 0, h)));
      if (L3 && b < u5 - 1) {
        let R3 = f.dist(y4);
        if (R3 > 2 * p4) {
          let z4 = f.add(y4.sub(f)._mult(p4 / R3)._round());
          this.updateDistance(f, z4), this.addCurrentVertex(z4, x2, 0, 0, h), f = z4;
        }
      }
    }
  }
  addCurrentVertex(e, t, i, n4, o4, a4 = false) {
    let s5 = t.x + t.y * i, u5 = t.y - t.x * i, c = -t.x + t.y * n4, p4 = -t.y - t.x * n4;
    this.addHalfVertex(e, s5, u5, a4, false, i, o4), this.addHalfVertex(e, c, p4, a4, true, -n4, o4), this.distance > c0$1 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, t, i, n4, o4, a4));
  }
  addHalfVertex({ x: e, y: t }, i, n4, o4, a4, s5, u5) {
    let p4 = (this.lineClips ? this.scaledDistance * (c0$1 - 1) : this.scaledDistance) * h0$1;
    if (this.layoutVertexArray.emplaceBack((e << 1) + (o4 ? 1 : 0), (t << 1) + (a4 ? 1 : 0), Math.round(u0$1 * i) + 128, Math.round(u0$1 * n4) + 128, (s5 === 0 ? 0 : s5 < 0 ? -1 : 1) + 1 | (p4 & 63) << 2, p4 >> 6), this.lineClips) {
      let f = this.scaledDistance - this.lineClips.start, m5 = this.lineClips.end - this.lineClips.start, y4 = f / m5;
      this.layoutVertexArray2.emplaceBack(y4, this.lineClipsArray.length);
    }
    let h = u5.vertexLength++;
    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, h), u5.primitiveLength++), a4 ? this.e2 = h : this.e1 = h;
  }
  updateScaledDistance() {
    this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
  }
  updateDistance(e, t) {
    this.distance += e.dist(t), this.updateScaledDistance();
  }
};
H$3(Vm$1, "LineBucket");
var Yo$1 = Vm$1;
N$1("LineBucket", Yo$1, { omit: ["layers", "patternFeatures"] });
a();
var f0$1, hk = H$3(() => f0$1 = f0$1 || new De$2({ "line-cap": new Z$2(A$1.layout_line["line-cap"]), "line-join": new $(A$1.layout_line["line-join"]), "line-miter-limit": new Z$2(A$1.layout_line["line-miter-limit"]), "line-round-limit": new Z$2(A$1.layout_line["line-round-limit"]), "line-sort-key": new $(A$1.layout_line["line-sort-key"]) }), "getLayout"), m0$1, fk = H$3(() => m0$1 = m0$1 || new De$2({ "line-opacity": new $(A$1.paint_line["line-opacity"]), "line-color": new $(A$1.paint_line["line-color"]), "line-translate": new Z$2(A$1.paint_line["line-translate"]), "line-translate-anchor": new Z$2(A$1.paint_line["line-translate-anchor"]), "line-width": new $(A$1.paint_line["line-width"]), "line-gap-width": new $(A$1.paint_line["line-gap-width"]), "line-offset": new $(A$1.paint_line["line-offset"]), "line-blur": new $(A$1.paint_line["line-blur"]), "line-dasharray": new ai(A$1.paint_line["line-dasharray"]), "line-pattern": new ar(A$1.paint_line["line-pattern"]), "line-gradient": new si$1(A$1.paint_line["line-gradient"]) }), "getPaint"), Um$1 = { get paint() {
  return fk();
}, get layout() {
  return hk();
} };
var Gm$1 = class Gm extends $ {
  possiblyEvaluate(e, t) {
    return t = new ye(Math.floor(t.zoom), { now: t.now, fadeDuration: t.fadeDuration, zoomHistory: t.zoomHistory, transition: t.transition }), super.possiblyEvaluate(e, t);
  }
  evaluate(e, t, i, n4) {
    return t = V$1({}, t, { zoom: Math.floor(t.zoom) }), super.evaluate(e, t, i, n4);
  }
};
H$3(Gm$1, "LineFloorwidthProperty");
var Nm$1 = Gm$1, $l$1, qm$1 = class qm extends Ge$1 {
  constructor(e) {
    super(e, Um$1), this.gradientVersion = 0, $l$1 || ($l$1 = new Nm$1(Um$1.paint.properties["line-width"].specification), $l$1.useIntegerZoom = true);
  }
  _handleSpecialPaintPropertyUpdate(e) {
    if (e === "line-gradient") {
      let t = this.gradientExpression();
      ni(t) ? this.stepInterpolant = t._styleExpression.expression instanceof Gi$1 : this.stepInterpolant = false, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
    }
  }
  gradientExpression() {
    return this._transitionablePaint._values["line-gradient"].value.expression;
  }
  recalculate(e, t) {
    super.recalculate(e, t), this.paint._values["line-floorwidth"] = $l$1.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
  }
  createBucket(e) {
    return new Yo$1(e);
  }
  queryRadius(e) {
    let t = e, i = d0$1(fi$1("line-width", this, t), fi$1("line-gap-width", this, t)), n4 = fi$1("line-offset", this, t);
    return i / 2 + Math.abs(n4) + kr(this.paint.get("line-translate"));
  }
  queryIntersectsFeature(e, t, i, n4, o4, a4, s5) {
    let u5 = Lr$1(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a4.angle, s5), c = s5 / 2 * d0$1(this.paint.get("line-width").evaluate(t, i), this.paint.get("line-gap-width").evaluate(t, i)), p4 = this.paint.get("line-offset").evaluate(t, i);
    return p4 && (n4 = H_(n4, p4 * s5)), q_(u5, n4, c);
  }
  isTileClipped() {
    return true;
  }
};
H$3(qm$1, "LineStyleLayer");
var Wl = qm$1;
function d0$1(r5, e) {
  return e > 0 ? e + 2 * r5 : r5;
}
H$3(d0$1, "getLineWidth");
a();
a();
a();
var y0$1 = _e$1([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), g0$1 = _e$1([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
_e$1([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
var x0$1 = _e$1([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
_e$1([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
var jm$1 = _e$1([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), b0$1 = _e$1([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
_e$1([{ name: "triangle", components: 3, type: "Uint16" }]);
_e$1([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]);
_e$1([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]);
_e$1([{ type: "Float32", name: "offsetX" }]);
_e$1([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
_e$1([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
var ta = N$2(ge(), 1);
a();
function mk(r5, e, t) {
  let i = e.layout.get("text-transform").evaluate(t, {});
  return i === "uppercase" ? r5 = r5.toLocaleUpperCase() : i === "lowercase" && (r5 = r5.toLocaleLowerCase()), or$1.applyArabicShaping && (r5 = or$1.applyArabicShaping(r5)), r5;
}
H$3(mk, "transformTextInternal");
function _0$1(r5, e, t) {
  return r5.sections.forEach((i) => {
    i.text = mk(i.text, e, t);
  }), r5;
}
H$3(_0$1, "transformText");
a();
function v0$1(r5) {
  let e = {}, t = {}, i = [], n4 = 0;
  function o4(c) {
    i.push(r5[c]), n4++;
  }
  H$3(o4, "add");
  function a4(c, p4, h) {
    let f = t[c];
    return delete t[c], t[p4] = f, i[f].geometry[0].pop(), i[f].geometry[0] = i[f].geometry[0].concat(h[0]), f;
  }
  H$3(a4, "mergeFromRight");
  function s5(c, p4, h) {
    let f = e[p4];
    return delete e[p4], e[c] = f, i[f].geometry[0].shift(), i[f].geometry[0] = h[0].concat(i[f].geometry[0]), f;
  }
  H$3(s5, "mergeFromLeft");
  function u5(c, p4, h) {
    let f = h ? p4[0][p4[0].length - 1] : p4[0][0];
    return "".concat(c, ":").concat(f.x, ":").concat(f.y);
  }
  H$3(u5, "getKey");
  for (let c = 0; c < r5.length; c++) {
    let p4 = r5[c], h = p4.geometry, f = p4.text ? p4.text.toString() : null;
    if (!f) {
      o4(c);
      continue;
    }
    let m5 = u5(f, h), y4 = u5(f, h, true);
    if (m5 in t && y4 in e && t[m5] !== e[y4]) {
      let g = s5(m5, y4, h), x2 = a4(m5, y4, i[g].geometry);
      delete e[m5], delete t[y4], t[u5(f, i[x2].geometry, true)] = x2, i[g].geometry = null;
    } else m5 in t ? a4(m5, y4, h) : y4 in e ? s5(m5, y4, h) : (o4(c), e[m5] = n4 - 1, t[y4] = n4 - 1);
  }
  return i.filter((c) => c.geometry);
}
H$3(v0$1, "mergeLines");
a();
a();
var w0 = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
a();
var Dr = 24;
a();
var E0 = N$2($m(), 1);
var C0$1 = 3;
function Lk(r5, e, t) {
  r5 === 1 && t.readMessage(Dk, e);
}
H$3(Lk, "readFontstacks");
function Dk(r5, e, t) {
  if (r5 === 3) {
    let { id: i, bitmap: n4, width: o4, height: a4, left: s5, top: u5, advance: c } = t.readMessage(zk, {});
    e.push({ id: i, bitmap: new mi({ width: o4 + 2 * C0$1, height: a4 + 2 * C0$1 }, n4), metrics: { width: o4, height: a4, left: s5, top: u5, advance: c } });
  }
}
H$3(Dk, "readFontstack");
function zk(r5, e, t) {
  r5 === 1 ? e.id = t.readVarint() : r5 === 2 ? e.bitmap = t.readBytes() : r5 === 3 ? e.width = t.readVarint() : r5 === 4 ? e.height = t.readVarint() : r5 === 5 ? e.left = t.readSVarint() : r5 === 6 ? e.top = t.readSVarint() : r5 === 7 && (e.advance = t.readVarint());
}
H$3(zk, "readGlyph");
function k0(r5) {
  return new E0.default(r5).readFields(Lk, []);
}
H$3(k0, "parseGlyphPbf");
a();
a();
function Qo(r5) {
  let e = 0, t = 0;
  for (let s5 of r5) e += s5.w * s5.h, t = Math.max(t, s5.w);
  r5.sort((s5, u5) => u5.h - s5.h);
  let n4 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), t), h: 1 / 0 }], o4 = 0, a4 = 0;
  for (let s5 of r5) for (let u5 = n4.length - 1; u5 >= 0; u5--) {
    let c = n4[u5];
    if (!(s5.w > c.w || s5.h > c.h)) {
      if (s5.x = c.x, s5.y = c.y, a4 = Math.max(a4, s5.y + s5.h), o4 = Math.max(o4, s5.x + s5.w), s5.w === c.w && s5.h === c.h) {
        let p4 = n4.pop();
        u5 < n4.length && (n4[u5] = p4);
      } else s5.h === c.h ? (c.x += s5.w, c.w -= s5.w) : s5.w === c.w ? (c.y += s5.h, c.h -= s5.h) : (n4.push({ x: c.x + s5.w, y: c.y, w: c.w - s5.w, h: s5.h }), c.y += s5.h, c.h -= s5.h);
      break;
    }
  }
  return { w: o4, h: a4, fill: e / (o4 * a4) || 0 };
}
H$3(Qo, "potpack");
var xt$1 = 1;
var Xm$1 = class Xm {
  constructor(e, { pixelRatio: t, version: i, stretchX: n4, stretchY: o4, content: a4 }) {
    this.paddedRect = e, this.pixelRatio = t, this.stretchX = n4, this.stretchY = o4, this.content = a4, this.version = i;
  }
  get tl() {
    return [this.paddedRect.x + xt$1, this.paddedRect.y + xt$1];
  }
  get br() {
    return [this.paddedRect.x + this.paddedRect.w - xt$1, this.paddedRect.y + this.paddedRect.h - xt$1];
  }
  get tlbr() {
    return this.tl.concat(this.br);
  }
  get displaySize() {
    return [(this.paddedRect.w - xt$1 * 2) / this.pixelRatio, (this.paddedRect.h - xt$1 * 2) / this.pixelRatio];
  }
};
H$3(Xm$1, "ImagePosition");
var mn = Xm$1, Km = class Km2 {
  constructor(e, t) {
    let i = {}, n4 = {};
    this.haveRenderCallbacks = [];
    let o4 = [];
    this.addImages(e, i, o4), this.addImages(t, n4, o4);
    let { w: a4, h: s5 } = Qo(o4), u5 = new Se$2({ width: a4 || 1, height: s5 || 1 });
    for (let c in e) {
      let p4 = e[c], h = i[c].paddedRect;
      Se$2.copy(p4.data, u5, { x: 0, y: 0 }, { x: h.x + xt$1, y: h.y + xt$1 }, p4.data);
    }
    for (let c in t) {
      let p4 = t[c], h = n4[c].paddedRect, f = h.x + xt$1, m5 = h.y + xt$1, y4 = p4.data.width, g = p4.data.height;
      Se$2.copy(p4.data, u5, { x: 0, y: 0 }, { x: f, y: m5 }, p4.data), Se$2.copy(p4.data, u5, { x: 0, y: g - 1 }, { x: f, y: m5 - 1 }, { width: y4, height: 1 }), Se$2.copy(p4.data, u5, { x: 0, y: 0 }, { x: f, y: m5 + g }, { width: y4, height: 1 }), Se$2.copy(p4.data, u5, { x: y4 - 1, y: 0 }, { x: f - 1, y: m5 }, { width: 1, height: g }), Se$2.copy(p4.data, u5, { x: 0, y: 0 }, { x: f + y4, y: m5 }, { width: 1, height: g });
    }
    this.image = u5, this.iconPositions = i, this.patternPositions = n4;
  }
  addImages(e, t, i) {
    for (let n4 in e) {
      let o4 = e[n4], a4 = { x: 0, y: 0, w: o4.data.width + 2 * xt$1, h: o4.data.height + 2 * xt$1 };
      i.push(a4), t[n4] = new mn(a4, o4), o4.hasRenderCallback && this.haveRenderCallbacks.push(n4);
    }
  }
  patchUpdatedImages(e, t) {
    e.dispatchRenderCallbacks(this.haveRenderCallbacks);
    for (let i in e.updatedImages) this.patchUpdatedImage(this.iconPositions[i], e.getImage(i), t), this.patchUpdatedImage(this.patternPositions[i], e.getImage(i), t);
  }
  patchUpdatedImage(e, t, i) {
    if (!e || !t || e.version === t.version) return;
    e.version = t.version;
    let [n4, o4] = e.tl;
    i.update(t.data, void 0, { x: n4, y: o4 });
  }
};
H$3(Km, "ImageAtlas");
var Wm$1 = Km;
N$1("ImagePosition", mn);
N$1("ImageAtlas", Wm$1);
var yi = ((n4) => (n4[n4.none = 0] = "none", n4[n4.horizontal = 1] = "horizontal", n4[n4.vertical = 2] = "vertical", n4[n4.horizontalOnly = 3] = "horizontalOnly", n4))(yi || {});
function Jl$1(r5) {
  let e = 0.5, t = 0.5;
  switch (r5) {
    case "right":
    case "top-right":
    case "bottom-right":
      e = 1;
      break;
    case "left":
    case "top-left":
    case "bottom-left":
      e = 0;
      break;
  }
  switch (r5) {
    case "bottom":
    case "bottom-right":
    case "bottom-left":
      t = 1;
      break;
    case "top":
    case "top-right":
    case "top-left":
      t = 0;
      break;
  }
  return { horizontalAlign: e, verticalAlign: t };
}
H$3(Jl$1, "getAnchorAlignment");
var z0 = N$2(Wo$1(), 1);
a();
var L0 = 255, ea = 128, Yl$1 = L0 * ea;
function Jm(r5, e) {
  let { expression: t } = e;
  if (t.kind === "constant") return { kind: "constant", layoutSize: t.evaluate(new ye(r5 + 1)) };
  if (t.kind === "source") return { kind: "source" };
  {
    let { zoomStops: i, interpolationType: n4 } = t, o4 = 0;
    for (; o4 < i.length && i[o4] <= r5; ) o4++;
    o4 = Math.max(0, o4 - 1);
    let a4 = o4;
    for (; a4 < i.length && i[a4] < r5 + 1; ) a4++;
    a4 = Math.min(i.length - 1, a4);
    let s5 = i[o4], u5 = i[a4];
    if (t.kind === "composite") return { kind: "composite", minZoom: s5, maxZoom: u5, interpolationType: n4 };
    let c = t.evaluate(new ye(s5)), p4 = t.evaluate(new ye(u5));
    return { kind: "camera", minZoom: s5, maxZoom: u5, minSize: c, maxSize: p4, interpolationType: n4 };
  }
}
H$3(Jm, "getSizeData");
function dn$1(r5, { uSize: e, uSizeT: t }, { lowerSize: i, upperSize: n4 }) {
  return r5.kind === "source" ? i / ea : r5.kind === "composite" ? Pe$2.number(i / ea, n4 / ea, t) : e;
}
H$3(dn$1, "evaluateSizeForFeature");
function gi(r5, e) {
  let t = 0, i = 0;
  if (r5.kind === "constant") i = r5.layoutSize;
  else if (r5.kind !== "source") {
    let { interpolationType: n4, minZoom: o4, maxZoom: a4 } = r5, s5 = n4 ? Ae$2(vt$1.interpolationFactor(n4, e, o4, a4), 0, 1) : 0;
    r5.kind === "camera" ? i = Pe$2.number(r5.minSize, r5.maxSize, s5) : t = s5;
  }
  return { uSizeT: t, uSize: i };
}
H$3(gi, "evaluateSizeForZoom");
a();
function yn(r5, e, t) {
  let i = "never", n4 = r5.get(e);
  return n4 ? i = n4 : r5.get(t) && (i = "always"), i;
}
H$3(yn, "getOverlapMode");
var Rk = z0.default.VectorTileFeature.types, Bk = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
function Ql$1(r5, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f) {
  let m5 = s5 ? Math.min(Yl$1, Math.round(s5[0])) : 0, y4 = s5 ? Math.min(Yl$1, Math.round(s5[1])) : 0;
  r5.emplaceBack(e, t, Math.round(i * 32), Math.round(n4 * 32), o4, a4, (m5 << 1) + (u5 ? 1 : 0), y4, c * 16, p4 * 16, h * 256, f * 256);
}
H$3(Ql$1, "addVertex");
function xi(r5, e, t) {
  r5.emplaceBack(e.x, e.y, t), r5.emplaceBack(e.x, e.y, t), r5.emplaceBack(e.x, e.y, t), r5.emplaceBack(e.x, e.y, t);
}
H$3(xi, "addDynamicAttributes");
function Ok(r5) {
  for (let e of r5.sections) if (C_(e.text)) return true;
  return false;
}
H$3(Ok, "containsRTLText");
var Ym$1 = class Ym {
  constructor(e) {
    this.layoutVertexArray = new bl$1(), this.indexArray = new it$2(), this.programConfigurations = e, this.segments = new me$1(), this.dynamicLayoutVertexArray = new _l$1(), this.opacityVertexArray = new vl$1(), this.hasVisibleVertices = false, this.placedSymbolArray = new Io$1();
  }
  isEmpty() {
    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
  }
  upload(e, t, i, n4) {
    this.isEmpty() || (i && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, y0$1.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, g0$1.members, true), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Bk, true), this.opacityVertexBuffer.itemSize = 1), (i || n4) && this.programConfigurations.upload(e));
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
  }
};
H$3(Ym$1, "SymbolBuffers");
var ra = Ym$1;
N$1("SymbolBuffers", ra);
var Qm = class Qm2 {
  constructor(e, t, i) {
    this.layoutVertexArray = new e(), this.layoutAttributes = t, this.indexArray = new i(), this.segments = new me$1(), this.collisionVertexArray = new Sl$1();
  }
  upload(e) {
    this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, x0$1.members, true);
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
  }
};
H$3(Qm, "CollisionBuffers");
var ia = Qm;
N$1("CollisionBuffers", ia);
var ed$1 = class ed {
  constructor(e) {
    this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((u5) => u5.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = q$2.identity([]), this.placementViewportMatrix = q$2.identity([]);
    let i = this.layers[0]._unevaluatedLayout._values;
    this.textSizeData = Jm(this.zoom, i["text-size"]), this.iconSizeData = Jm(this.zoom, i["icon-size"]);
    let n4 = this.layers[0].layout, o4 = n4.get("symbol-sort-key"), a4 = n4.get("symbol-z-order");
    this.canOverlap = yn(n4, "text-overlap", "text-allow-overlap") !== "never" || yn(n4, "icon-overlap", "icon-allow-overlap") !== "never" || n4.get("text-ignore-placement") || n4.get("icon-ignore-placement"), this.sortFeaturesByKey = a4 !== "viewport-y" && !o4.isConstant();
    let s5 = a4 === "viewport-y" || a4 === "auto" && !this.sortFeaturesByKey;
    this.sortFeaturesByY = s5 && this.canOverlap, n4.get("symbol-placement") === "point" && (this.writingModes = n4.get("text-writing-mode").map((u5) => yi[u5])), this.stateDependentLayerIds = this.layers.filter((u5) => u5.isStateDependent()).map((u5) => u5.id), this.sourceID = e.sourceID;
  }
  createArrays() {
    this.text = new ra(new mt$1(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new ra(new mt$1(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new Eo$1(), this.lineVertexArray = new ko(), this.symbolInstances = new Co$1(), this.textAnchorOffsets = new Lo$1();
  }
  calculateGlyphDependencies(e, t, i, n4, o4) {
    for (let a4 = 0; a4 < e.length; a4++) if (t[e.charCodeAt(a4)] = true, (i || n4) && o4) {
      let s5 = w0[e.charAt(a4)];
      s5 && (t[s5.charCodeAt(0)] = true);
    }
  }
  populate(e, t, i) {
    let n4 = this.layers[0], o4 = n4.layout, a4 = o4.get("text-font"), s5 = o4.get("text-field"), u5 = o4.get("icon-image"), c = (s5.value.kind !== "constant" || s5.value.value instanceof wt$1 && !s5.value.value.isEmpty() || s5.value.value.toString().length > 0) && (a4.value.kind !== "constant" || a4.value.value.length > 0), p4 = u5.value.kind !== "constant" || !!u5.value.value || Object.keys(u5.parameters).length > 0, h = o4.get("symbol-sort-key");
    if (this.features = [], !c && !p4) return;
    let f = t.iconDependencies, m5 = t.glyphDependencies, y4 = t.availableImages, g = new ye(this.zoom);
    for (let { feature: x2, id: b, index: w3, sourceLayerIndex: _ } of e) {
      let S4 = n4._featureFilter.needGeometry, P4 = yt$1(x2, S4);
      if (!n4._featureFilter.filter(g, P4, i)) continue;
      S4 || (P4.geometry = dt$1(x2));
      let T3;
      if (c) {
        let I3 = n4.getValueAndResolveTokens("text-field", P4, i, y4), R3 = wt$1.factory(I3), z4 = this.hasRTLText = this.hasRTLText || Ok(R3);
        (!z4 || or$1.getRTLTextPluginStatus() === "unavailable" || z4 && or$1.isParsed()) && (T3 = _0$1(R3, n4, P4));
      }
      let L3;
      if (p4) {
        let I3 = n4.getValueAndResolveTokens("icon-image", P4, i, y4);
        I3 instanceof ft$1 ? L3 = I3 : L3 = ft$1.fromString(I3);
      }
      if (!T3 && !L3) continue;
      let C3 = this.sortFeaturesByKey ? h.evaluate(P4, {}, i) : void 0, E4 = { id: b, text: T3, icon: L3, index: w3, sourceLayerIndex: _, geometry: P4.geometry, properties: x2.properties, type: Rk[x2.type], sortKey: C3 };
      if (this.features.push(E4), L3 && (f[L3.name] = true), T3) {
        let I3 = a4.evaluate(P4, {}, i).join(","), R3 = o4.get("text-rotation-alignment") !== "viewport" && o4.get("symbol-placement") !== "point";
        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(2) >= 0;
        for (let z4 of T3.sections) if (z4.image) f[z4.image.name] = true;
        else {
          let k3 = Ah$1(T3.toString()), M3 = z4.fontStack || I3, G3 = m5[M3] = m5[M3] || {};
          this.calculateGlyphDependencies(z4.text, G3, R3, this.allowVerticalPlacement, k3);
        }
      }
    }
    o4.get("symbol-placement") === "line" && (this.features = v0$1(this.features)), this.sortFeaturesByKey && this.features.sort((x2, b) => x2.sortKey - b.sortKey);
  }
  update(e, t, i) {
    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, t, this.layers, i), this.icon.programConfigurations.updatePaintArrays(e, t, this.layers, i));
  }
  isEmpty() {
    return this.symbolInstances.length === 0 && !this.hasRTLText;
  }
  uploadPending() {
    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
  }
  upload(e) {
    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
  }
  destroyDebugData() {
    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
  }
  destroy() {
    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
  }
  addToLineVertexArray(e, t) {
    let i = this.lineVertexArray.length;
    if (e.segment !== void 0) {
      let n4 = e.dist(t[e.segment + 1]), o4 = e.dist(t[e.segment]), a4 = {};
      for (let s5 = e.segment + 1; s5 < t.length; s5++) a4[s5] = { x: t[s5].x, y: t[s5].y, tileUnitDistanceFromAnchor: n4 }, s5 < t.length - 1 && (n4 += t[s5 + 1].dist(t[s5]));
      for (let s5 = e.segment || 0; s5 >= 0; s5--) a4[s5] = { x: t[s5].x, y: t[s5].y, tileUnitDistanceFromAnchor: o4 }, s5 > 0 && (o4 += t[s5 - 1].dist(t[s5]));
      for (let s5 = 0; s5 < t.length; s5++) {
        let u5 = a4[s5];
        this.lineVertexArray.emplaceBack(u5.x, u5.y, u5.tileUnitDistanceFromAnchor);
      }
    }
    return { lineStartIndex: i, lineLength: this.lineVertexArray.length - i };
  }
  addSymbols(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f) {
    let m5 = e.indexArray, y4 = e.layoutVertexArray, g = e.segments.prepareSegment(4 * t.length, y4, m5, this.canOverlap ? a4.sortKey : void 0), x2 = this.glyphOffsetArray.length, b = g.vertexLength, w3 = this.allowVerticalPlacement && s5 === 2 ? Math.PI / 2 : 0, _ = a4.text && a4.text.sections;
    for (let S4 = 0; S4 < t.length; S4++) {
      let { tl: P4, tr: T3, bl: L3, br: C3, tex: E4, pixelOffsetTL: I3, pixelOffsetBR: R3, minFontScaleX: z4, minFontScaleY: k3, glyphOffset: M3, isSDF: G3, sectionIndex: K4 } = t[S4], ne2 = g.vertexLength, J4 = M3[1];
      Ql$1(y4, u5.x, u5.y, P4.x, J4 + P4.y, E4.x, E4.y, i, G3, I3.x, I3.y, z4, k3), Ql$1(y4, u5.x, u5.y, T3.x, J4 + T3.y, E4.x + E4.w, E4.y, i, G3, R3.x, I3.y, z4, k3), Ql$1(y4, u5.x, u5.y, L3.x, J4 + L3.y, E4.x, E4.y + E4.h, i, G3, I3.x, R3.y, z4, k3), Ql$1(y4, u5.x, u5.y, C3.x, J4 + C3.y, E4.x + E4.w, E4.y + E4.h, i, G3, R3.x, R3.y, z4, k3), xi(e.dynamicLayoutVertexArray, u5, w3), m5.emplaceBack(ne2, ne2 + 1, ne2 + 2), m5.emplaceBack(ne2 + 1, ne2 + 2, ne2 + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(M3[0]), (S4 === t.length - 1 || K4 !== t[S4 + 1].sectionIndex) && e.programConfigurations.populatePaintArrays(y4.length, a4, a4.index, {}, f, _ && _[K4]);
    }
    e.placedSymbolArray.emplaceBack(u5.x, u5.y, x2, this.glyphOffsetArray.length - x2, b, c, p4, u5.segment, i ? i[0] : 0, i ? i[1] : 0, n4[0], n4[1], s5, 0, false, 0, h);
  }
  _addCollisionDebugVertex(e, t, i, n4, o4, a4) {
    return t.emplaceBack(0, 0), e.emplaceBack(i.x, i.y, n4, o4, Math.round(a4.x), Math.round(a4.y));
  }
  addCollisionDebugVertices(e, t, i, n4, o4, a4, s5) {
    let u5 = o4.segments.prepareSegment(4, o4.layoutVertexArray, o4.indexArray), c = u5.vertexLength, p4 = o4.layoutVertexArray, h = o4.collisionVertexArray, f = s5.anchorX, m5 = s5.anchorY;
    this._addCollisionDebugVertex(p4, h, a4, f, m5, new ta.default(e, t)), this._addCollisionDebugVertex(p4, h, a4, f, m5, new ta.default(i, t)), this._addCollisionDebugVertex(p4, h, a4, f, m5, new ta.default(i, n4)), this._addCollisionDebugVertex(p4, h, a4, f, m5, new ta.default(e, n4)), u5.vertexLength += 4;
    let y4 = o4.indexArray;
    y4.emplaceBack(c, c + 1), y4.emplaceBack(c + 1, c + 2), y4.emplaceBack(c + 2, c + 3), y4.emplaceBack(c + 3, c), u5.primitiveLength += 4;
  }
  addDebugCollisionBoxes(e, t, i, n4) {
    for (let o4 = e; o4 < t; o4++) {
      let a4 = this.collisionBoxArray.get(o4), s5 = a4.x1, u5 = a4.y1, c = a4.x2, p4 = a4.y2;
      this.addCollisionDebugVertices(s5, u5, c, p4, n4 ? this.textCollisionBox : this.iconCollisionBox, a4.anchorPoint, i);
    }
  }
  generateCollisionDebugBuffers() {
    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ia(zo$1, jm$1.members, Ir$1), this.iconCollisionBox = new ia(zo$1, jm$1.members, Ir$1);
    for (let e = 0; e < this.symbolInstances.length; e++) {
      let t = this.symbolInstances.get(e);
      this.addDebugCollisionBoxes(t.textBoxStartIndex, t.textBoxEndIndex, t, true), this.addDebugCollisionBoxes(t.verticalTextBoxStartIndex, t.verticalTextBoxEndIndex, t, true), this.addDebugCollisionBoxes(t.iconBoxStartIndex, t.iconBoxEndIndex, t, false), this.addDebugCollisionBoxes(t.verticalIconBoxStartIndex, t.verticalIconBoxEndIndex, t, false);
    }
  }
  _deserializeCollisionBoxesForSymbol(e, t, i, n4, o4, a4, s5, u5, c) {
    let p4 = {};
    for (let h = t; h < i; h++) {
      let f = e.get(h);
      p4.textBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p4.textFeatureIndex = f.featureIndex;
      break;
    }
    for (let h = n4; h < o4; h++) {
      let f = e.get(h);
      p4.verticalTextBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p4.verticalTextFeatureIndex = f.featureIndex;
      break;
    }
    for (let h = a4; h < s5; h++) {
      let f = e.get(h);
      p4.iconBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p4.iconFeatureIndex = f.featureIndex;
      break;
    }
    for (let h = u5; h < c; h++) {
      let f = e.get(h);
      p4.verticalIconBox = { x1: f.x1, y1: f.y1, x2: f.x2, y2: f.y2, anchorPointX: f.anchorPointX, anchorPointY: f.anchorPointY }, p4.verticalIconFeatureIndex = f.featureIndex;
      break;
    }
    return p4;
  }
  deserializeCollisionBoxes(e) {
    this.collisionArrays = [];
    for (let t = 0; t < this.symbolInstances.length; t++) {
      let i = this.symbolInstances.get(t);
      this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, i.textBoxStartIndex, i.textBoxEndIndex, i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i.iconBoxStartIndex, i.iconBoxEndIndex, i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex));
    }
  }
  hasTextData() {
    return this.text.segments.get().length > 0;
  }
  hasIconData() {
    return this.icon.segments.get().length > 0;
  }
  hasDebugData() {
    return this.textCollisionBox && this.iconCollisionBox;
  }
  hasTextCollisionBoxData() {
    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
  }
  hasIconCollisionBoxData() {
    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
  }
  addIndicesForPlacedSymbol(e, t) {
    let i = e.placedSymbolArray.get(t), n4 = i.vertexStartIndex + i.numGlyphs * 4;
    for (let o4 = i.vertexStartIndex; o4 < n4; o4 += 4) e.indexArray.emplaceBack(o4, o4 + 1, o4 + 2), e.indexArray.emplaceBack(o4 + 1, o4 + 2, o4 + 3);
  }
  getSortedSymbolIndexes(e) {
    if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
    let t = Math.sin(e), i = Math.cos(e), n4 = [], o4 = [], a4 = [];
    for (let s5 = 0; s5 < this.symbolInstances.length; ++s5) {
      a4.push(s5);
      let u5 = this.symbolInstances.get(s5);
      n4.push(Math.round(t * u5.anchorX + i * u5.anchorY) | 0), o4.push(u5.featureIndex);
    }
    return a4.sort((s5, u5) => n4[s5] - n4[u5] || o4[u5] - o4[s5]), a4;
  }
  addToSortKeyRanges(e, t) {
    let i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
    i && i.sortKey === t ? i.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: t, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
  }
  sortFeatures(e) {
    if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
      this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
      for (let t of this.symbolInstanceIndexes) {
        let i = this.symbolInstances.get(t);
        this.featureSortOrder.push(i.featureIndex), [i.rightJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.leftJustifiedTextSymbolIndex].forEach((n4, o4, a4) => {
          n4 >= 0 && a4.indexOf(n4) === o4 && this.addIndicesForPlacedSymbol(this.text, n4);
        }), i.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i.verticalPlacedTextSymbolIndex), i.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.placedIconSymbolIndex), i.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.verticalPlacedIconSymbolIndex);
      }
      this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
    }
  }
};
H$3(ed$1, "SymbolBucket");
var Ot$1 = ed$1;
N$1("SymbolBucket", Ot$1, { omit: ["layers", "collisionBoxArray", "features", "compareText"] });
Ot$1.MAX_GLYPHS = 65535;
Ot$1.addDynamicAttributes = xi;
a();
function F0(r5, e) {
  return e.replace(/{([^{}]+)}/g, (t, i) => r5 && i in r5 ? String(r5[i]) : "");
}
H$3(F0, "resolveTokens");
a();
var R0, Vk = H$3(() => R0 = R0 || new De$2({ "symbol-placement": new Z$2(A$1.layout_symbol["symbol-placement"]), "symbol-spacing": new Z$2(A$1.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Z$2(A$1.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new $(A$1.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Z$2(A$1.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Z$2(A$1.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Z$2(A$1.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Z$2(A$1.layout_symbol["icon-ignore-placement"]), "icon-optional": new Z$2(A$1.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Z$2(A$1.layout_symbol["icon-rotation-alignment"]), "icon-size": new $(A$1.layout_symbol["icon-size"]), "icon-text-fit": new Z$2(A$1.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Z$2(A$1.layout_symbol["icon-text-fit-padding"]), "icon-image": new $(A$1.layout_symbol["icon-image"]), "icon-rotate": new $(A$1.layout_symbol["icon-rotate"]), "icon-padding": new $(A$1.layout_symbol["icon-padding"]), "icon-keep-upright": new Z$2(A$1.layout_symbol["icon-keep-upright"]), "icon-offset": new $(A$1.layout_symbol["icon-offset"]), "icon-anchor": new $(A$1.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Z$2(A$1.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Z$2(A$1.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Z$2(A$1.layout_symbol["text-rotation-alignment"]), "text-field": new $(A$1.layout_symbol["text-field"]), "text-font": new $(A$1.layout_symbol["text-font"]), "text-size": new $(A$1.layout_symbol["text-size"]), "text-max-width": new $(A$1.layout_symbol["text-max-width"]), "text-line-height": new Z$2(A$1.layout_symbol["text-line-height"]), "text-letter-spacing": new $(A$1.layout_symbol["text-letter-spacing"]), "text-justify": new $(A$1.layout_symbol["text-justify"]), "text-radial-offset": new $(A$1.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Z$2(A$1.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new $(A$1.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new $(A$1.layout_symbol["text-anchor"]), "text-max-angle": new Z$2(A$1.layout_symbol["text-max-angle"]), "text-writing-mode": new Z$2(A$1.layout_symbol["text-writing-mode"]), "text-rotate": new $(A$1.layout_symbol["text-rotate"]), "text-padding": new Z$2(A$1.layout_symbol["text-padding"]), "text-keep-upright": new Z$2(A$1.layout_symbol["text-keep-upright"]), "text-transform": new $(A$1.layout_symbol["text-transform"]), "text-offset": new $(A$1.layout_symbol["text-offset"]), "text-allow-overlap": new Z$2(A$1.layout_symbol["text-allow-overlap"]), "text-overlap": new Z$2(A$1.layout_symbol["text-overlap"]), "text-ignore-placement": new Z$2(A$1.layout_symbol["text-ignore-placement"]), "text-optional": new Z$2(A$1.layout_symbol["text-optional"]) }), "getLayout"), B0, Uk = H$3(() => B0 = B0 || new De$2({ "icon-opacity": new $(A$1.paint_symbol["icon-opacity"]), "icon-color": new $(A$1.paint_symbol["icon-color"]), "icon-halo-color": new $(A$1.paint_symbol["icon-halo-color"]), "icon-halo-width": new $(A$1.paint_symbol["icon-halo-width"]), "icon-halo-blur": new $(A$1.paint_symbol["icon-halo-blur"]), "icon-translate": new Z$2(A$1.paint_symbol["icon-translate"]), "icon-translate-anchor": new Z$2(A$1.paint_symbol["icon-translate-anchor"]), "text-opacity": new $(A$1.paint_symbol["text-opacity"]), "text-color": new $(A$1.paint_symbol["text-color"], { runtimeType: Ct$1, getOverride: H$3((r5) => r5.textColor, "getOverride"), hasOverride: H$3((r5) => !!r5.textColor, "hasOverride") }), "text-halo-color": new $(A$1.paint_symbol["text-halo-color"]), "text-halo-width": new $(A$1.paint_symbol["text-halo-width"]), "text-halo-blur": new $(A$1.paint_symbol["text-halo-blur"]), "text-translate": new Z$2(A$1.paint_symbol["text-translate"]), "text-translate-anchor": new Z$2(A$1.paint_symbol["text-translate-anchor"]) }), "getPaint"), eu$1 = { get paint() {
  return Uk();
}, get layout() {
  return Vk();
} };
a();
var td = class td2 {
  constructor(e) {
    if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
    this.type = e.property.overrides ? e.property.overrides.runtimeType : ji, this.defaultValue = e;
  }
  evaluate(e) {
    if (e.formattedSection) {
      let t = this.defaultValue.property.overrides;
      if (t && t.hasOverride(e.formattedSection)) return t.getOverride(e.formattedSection);
    }
    return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
  }
  eachChild(e) {
    if (!this.defaultValue.isConstant()) {
      let t = this.defaultValue.value;
      e(t._styleExpression.expression);
    }
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return null;
  }
};
H$3(td, "FormatSectionOverride");
var na = td;
N$1("FormatSectionOverride", na, { omit: ["defaultValue"] });
var oa = class oa2 extends Ge$1 {
  constructor(e) {
    super(e, eu$1);
  }
  recalculate(e, t) {
    if (super.recalculate(e, t), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout.get("symbol-placement") !== "point" ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
      let i = this.layout.get("text-writing-mode");
      if (i) {
        let n4 = [];
        for (let o4 of i) n4.indexOf(o4) < 0 && n4.push(o4);
        this.layout._values["text-writing-mode"] = n4;
      } else this.layout._values["text-writing-mode"] = ["horizontal"];
    }
    this._setPaintOverrides();
  }
  getValueAndResolveTokens(e, t, i, n4) {
    let o4 = this.layout.get(e).evaluate(t, {}, i, n4), a4 = this._unevaluatedLayout._values[e];
    return !a4.isDataDriven() && !ni(a4.value) && o4 ? F0(t.properties, o4) : o4;
  }
  createBucket(e) {
    return new Ot$1(e);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    throw new Error("Should take a different path in FeatureIndex");
  }
  _setPaintOverrides() {
    for (let e of eu$1.paint.overridableProperties) {
      if (!oa2.hasPaintOverride(this.layout, e)) continue;
      let t = this.paint.get(e), i = new na(t), n4 = new ei$1(i, t.property.specification), o4 = null;
      t.value.kind === "constant" || t.value.kind === "source" ? o4 = new vr("source", n4) : o4 = new wr$1("composite", n4, t.value.zoomStops), this.paint._values[e] = new at$1(t.property, o4, t.parameters);
    }
  }
  _handleOverridablePaintPropertyUpdate(e, t, i) {
    return !this.layout || t.isDataDriven() || i.isDataDriven() ? false : oa2.hasPaintOverride(this.layout, e);
  }
  static hasPaintOverride(e, t) {
    let i = e.get("text-field"), n4 = eu$1.paint.properties[t], o4 = false, a4 = H$3((s5) => {
      for (let u5 of s5) if (n4.overrides && n4.overrides.hasOverride(u5)) {
        o4 = true;
        return;
      }
    }, "checkSections");
    if (i.value.kind === "constant" && i.value.value instanceof wt$1) a4(i.value.value.sections);
    else if (i.value.kind === "source") {
      let s5 = H$3((c) => {
        if (!o4) if (c instanceof br && He(c.value) === Zi$1) {
          let p4 = c.value;
          a4(p4.sections);
        } else c instanceof Kn ? a4(c.sections) : c.eachChild(s5);
      }, "checkExpression"), u5 = i.value;
      u5._styleExpression && s5(u5._styleExpression.expression);
    }
    return o4;
  }
};
H$3(oa, "SymbolStyleLayer");
var tu$1 = oa;
a();
a();
var O0, Nk = H$3(() => O0 = O0 || new De$2({ "background-color": new Z$2(A$1.paint_background["background-color"]), "background-pattern": new ai(A$1.paint_background["background-pattern"]), "background-opacity": new Z$2(A$1.paint_background["background-opacity"]) }), "getPaint"), V0 = { get paint() {
  return Nk();
} };
var rd$1 = class rd extends Ge$1 {
  constructor(e) {
    super(e, V0);
  }
};
H$3(rd$1, "BackgroundStyleLayer");
var ru$1 = rd$1;
a();
a();
var U0, Gk = H$3(() => U0 = U0 || new De$2({ "raster-opacity": new Z$2(A$1.paint_raster["raster-opacity"]), "raster-hue-rotate": new Z$2(A$1.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Z$2(A$1.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Z$2(A$1.paint_raster["raster-brightness-max"]), "raster-saturation": new Z$2(A$1.paint_raster["raster-saturation"]), "raster-contrast": new Z$2(A$1.paint_raster["raster-contrast"]), "raster-resampling": new Z$2(A$1.paint_raster["raster-resampling"]), "raster-fade-duration": new Z$2(A$1.paint_raster["raster-fade-duration"]) }), "getPaint"), N0 = { get paint() {
  return Gk();
} };
var id = class id2 extends Ge$1 {
  constructor(e) {
    super(e, N0);
  }
};
H$3(id, "RasterStyleLayer");
var iu$1 = id;
a();
function G0(r5) {
  let e = [], t = r5.id;
  return t === void 0 && e.push({ message: "layers.".concat(t, ': missing required property "id"') }), r5.render === void 0 && e.push({ message: "layers.".concat(t, ': missing required method "render"') }), r5.renderingMode && r5.renderingMode !== "2d" && r5.renderingMode !== "3d" && e.push({ message: "layers.".concat(t, ': property "renderingMode" must be either "2d" or "3d"') }), e;
}
H$3(G0, "validateCustomStyleLayer");
var nd = class nd2 extends Ge$1 {
  constructor(t) {
    super(t, {});
    this.onAdd = H$3((t5) => {
      this.implementation.onAdd && this.implementation.onAdd(t5, t5.painter.context.gl);
    }, "onAdd");
    this.onRemove = H$3((t5) => {
      this.implementation.onRemove && this.implementation.onRemove(t5, t5.painter.context.gl);
    }, "onRemove");
    this.implementation = t;
  }
  is3D() {
    return this.implementation.renderingMode === "3d";
  }
  hasOffscreenPass() {
    return this.implementation.prerender !== void 0;
  }
  recalculate() {
  }
  updateTransitions() {
  }
  hasTransition() {
    return false;
  }
  serialize() {
    throw new Error("Custom layers cannot be serialized");
  }
};
H$3(nd, "CustomStyleLayer");
var nu$1 = nd;
function ou$1(r5) {
  if (r5.type === "custom") return new nu$1(r5);
  switch (r5.type) {
    case "background":
      return new ru$1(r5);
    case "circle":
      return new Dl(r5);
    case "fill":
      return new ql$1(r5);
    case "fill-extrusion":
      return new Hl(r5);
    case "heatmap":
      return new Bl(r5);
    case "hillshade":
      return new Ol(r5);
    case "line":
      return new Wl(r5);
    case "raster":
      return new iu$1(r5);
    case "symbol":
      return new tu$1(r5);
  }
}
H$3(ou$1, "createStyleLayer");
a();
a();
function gn(r5) {
  let e = [];
  if (typeof r5 == "string") e.push({ id: "default", url: r5 });
  else if (r5 && r5.length > 0) {
    let t = [];
    for (let { id: i, url: n4 } of r5) {
      let o4 = "".concat(i).concat(n4);
      t.indexOf(o4) === -1 && (t.push(o4), e.push({ id: i, url: n4 }));
    }
  }
  return e;
}
H$3(gn, "coerceSpriteToArray");
async function q0(r5, e, t, i) {
  let n4 = gn(r5), o4 = t > 1 ? "@2x" : "", a4 = {}, s5 = {};
  for (let { id: u5, url: c } of n4) {
    let p4 = e.transformRequest(e.normalizeSpriteURL(c, o4, ".json"), "SpriteJSON");
    a4[u5] = gr$1(p4, i);
    let h = e.transformRequest(e.normalizeSpriteURL(c, o4, ".png"), "SpriteImage");
    s5[u5] = st$1.getImage(h, i);
  }
  return await Promise.all([...Object.values(a4), ...Object.values(s5)]), qk(a4, s5);
}
H$3(q0, "loadSprite");
async function qk(r5, e) {
  let t = {};
  for (let i in r5) {
    t[i] = {};
    let n4 = Y$1.getImageCanvasContext((await e[i]).data), o4 = (await r5[i]).data;
    for (let a4 in o4) {
      let { width: s5, height: u5, x: c, y: p4, sdf: h, pixelRatio: f, stretchX: m5, stretchY: y4, content: g } = o4[a4], x2 = { width: s5, height: u5, x: c, y: p4, context: n4 };
      t[i][a4] = { data: null, pixelRatio: f, sdf: h, stretchX: m5, stretchY: y4, content: g, spriteData: x2 };
    }
  }
  return t;
}
H$3(qk, "doOnceCompleted");
a();
a();
var od = class od2 {
  constructor(e, t, i, n4) {
    this.context = e, this.format = i, this.texture = e.gl.createTexture(), this.update(t, n4);
  }
  update(e, t, i) {
    let { width: n4, height: o4 } = e, a4 = (!this.size || this.size[0] !== n4 || this.size[1] !== o4) && !i, { context: s5 } = this, { gl: u5 } = s5;
    if (this.useMipmap = !!(t && t.useMipmap), u5.bindTexture(u5.TEXTURE_2D, this.texture), s5.pixelStoreUnpackFlipY.set(false), s5.pixelStoreUnpack.set(1), s5.pixelStoreUnpackPremultiplyAlpha.set(this.format === u5.RGBA && (!t || t.premultiply !== false)), a4) this.size = [n4, o4], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ht$1(e) ? u5.texImage2D(u5.TEXTURE_2D, 0, this.format, this.format, u5.UNSIGNED_BYTE, e) : u5.texImage2D(u5.TEXTURE_2D, 0, this.format, n4, o4, 0, this.format, u5.UNSIGNED_BYTE, e.data);
    else {
      let { x: c, y: p4 } = i || { x: 0, y: 0 };
      e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ht$1(e) ? u5.texSubImage2D(u5.TEXTURE_2D, 0, c, p4, u5.RGBA, u5.UNSIGNED_BYTE, e) : u5.texSubImage2D(u5.TEXTURE_2D, 0, c, p4, n4, o4, u5.RGBA, u5.UNSIGNED_BYTE, e.data);
    }
    this.useMipmap && this.isSizePowerOfTwo() && u5.generateMipmap(u5.TEXTURE_2D);
  }
  bind(e, t, i) {
    let { context: n4 } = this, { gl: o4 } = n4;
    o4.bindTexture(o4.TEXTURE_2D, this.texture), i === o4.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo() && (i = o4.LINEAR), e !== this.filter && (o4.texParameteri(o4.TEXTURE_2D, o4.TEXTURE_MAG_FILTER, e), o4.texParameteri(o4.TEXTURE_2D, o4.TEXTURE_MIN_FILTER, i || e), this.filter = e), t !== this.wrap && (o4.texParameteri(o4.TEXTURE_2D, o4.TEXTURE_WRAP_S, t), o4.texParameteri(o4.TEXTURE_2D, o4.TEXTURE_WRAP_T, t), this.wrap = t);
  }
  isSizePowerOfTwo() {
    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 === 0;
  }
  destroy() {
    let { gl: e } = this.context;
    e.deleteTexture(this.texture), this.texture = null;
  }
};
H$3(od, "Texture");
var ve$2 = od;
a();
function j0(r5) {
  let { userImage: e } = r5;
  return e && e.render && e.render() ? (r5.data.replace(new Uint8Array(e.data.buffer)), true) : false;
}
H$3(j0, "renderStyleImage");
var au$1 = 1, ad = class ad2 extends de$1 {
  constructor() {
    super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new Se$2({ width: 1, height: 1 }), this.dirty = true;
  }
  isLoaded() {
    return this.loaded;
  }
  setLoaded(e) {
    if (this.loaded !== e && (this.loaded = e, e)) {
      for (let { ids: t, promiseResolve: i } of this.requestors) i(this._getImagesForIds(t));
      this.requestors = [];
    }
  }
  getImage(e) {
    let t = this.images[e];
    if (t && !t.data && t.spriteData) {
      let i = t.spriteData;
      t.data = new Se$2({ width: i.width, height: i.height }, i.context.getImageData(i.x, i.y, i.width, i.height).data), t.spriteData = null;
    }
    return t;
  }
  addImage(e, t) {
    if (this.images[e]) throw new Error("Image id ".concat(e, " already exist, use updateImage instead"));
    this._validate(e, t) && (this.images[e] = t);
  }
  _validate(e, t) {
    let i = true, n4 = t.data || t.spriteData;
    return this._validateStretch(t.stretchX, n4 && n4.width) || (this.fire(new H$2(new Error('Image "'.concat(e, '" has invalid "stretchX" value')))), i = false), this._validateStretch(t.stretchY, n4 && n4.height) || (this.fire(new H$2(new Error('Image "'.concat(e, '" has invalid "stretchY" value')))), i = false), this._validateContent(t.content, t) || (this.fire(new H$2(new Error('Image "'.concat(e, '" has invalid "content" value')))), i = false), i;
  }
  _validateStretch(e, t) {
    if (!e) return true;
    let i = 0;
    for (let n4 of e) {
      if (n4[0] < i || n4[1] < n4[0] || t < n4[1]) return false;
      i = n4[1];
    }
    return true;
  }
  _validateContent(e, t) {
    if (!e) return true;
    if (e.length !== 4) return false;
    let i = t.spriteData, n4 = i && i.width || t.data.width, o4 = i && i.height || t.data.height;
    return !(e[0] < 0 || n4 < e[0] || e[1] < 0 || o4 < e[1] || e[2] < 0 || n4 < e[2] || e[3] < 0 || o4 < e[3] || e[2] < e[0] || e[3] < e[1]);
  }
  updateImage(e, t, i = true) {
    let n4 = this.getImage(e);
    if (i && (n4.data.width !== t.data.width || n4.data.height !== t.data.height)) throw new Error("size mismatch between old image (".concat(n4.data.width, "x").concat(n4.data.height, ") and new image (").concat(t.data.width, "x").concat(t.data.height, ")."));
    t.version = n4.version + 1, this.images[e] = t, this.updatedImages[e] = true;
  }
  removeImage(e) {
    let t = this.images[e];
    delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();
  }
  listImages() {
    return Object.keys(this.images);
  }
  getImages(e) {
    return new Promise((t, i) => {
      let n4 = true;
      if (!this.isLoaded()) for (let o4 of e) this.images[o4] || (n4 = false);
      this.isLoaded() || n4 ? t(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: t });
    });
  }
  _getImagesForIds(e) {
    let t = {};
    for (let i of e) {
      let n4 = this.getImage(i);
      n4 || (this.fire(new F("styleimagemissing", { id: i })), n4 = this.getImage(i)), n4 ? t[i] = { data: n4.data.clone(), pixelRatio: n4.pixelRatio, sdf: n4.sdf, version: n4.version, stretchX: n4.stretchX, stretchY: n4.stretchY, content: n4.content, hasRenderCallback: !!(n4.userImage && n4.userImage.render) } : Le$1('Image "'.concat(i, '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.'));
    }
    return t;
  }
  getPixelSize() {
    let { width: e, height: t } = this.atlasImage;
    return { width: e, height: t };
  }
  getPattern(e) {
    let t = this.patterns[e], i = this.getImage(e);
    if (!i) return null;
    if (t && t.position.version === i.version) return t.position;
    if (t) t.position.version = i.version;
    else {
      let n4 = i.data.width + au$1 * 2, o4 = i.data.height + au$1 * 2, a4 = { w: n4, h: o4, x: 0, y: 0 }, s5 = new mn(a4, i);
      this.patterns[e] = { bin: a4, position: s5 };
    }
    return this._updatePatternAtlas(), this.patterns[e].position;
  }
  bind(e) {
    let t = e.gl;
    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new ve$2(e, this.atlasImage, t.RGBA), this.atlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE);
  }
  _updatePatternAtlas() {
    let e = [];
    for (let o4 in this.patterns) e.push(this.patterns[o4].bin);
    let { w: t, h: i } = Qo(e), n4 = this.atlasImage;
    n4.resize({ width: t || 1, height: i || 1 });
    for (let o4 in this.patterns) {
      let { bin: a4 } = this.patterns[o4], s5 = a4.x + au$1, u5 = a4.y + au$1, c = this.getImage(o4).data, p4 = c.width, h = c.height;
      Se$2.copy(c, n4, { x: 0, y: 0 }, { x: s5, y: u5 }, { width: p4, height: h }), Se$2.copy(c, n4, { x: 0, y: h - 1 }, { x: s5, y: u5 - 1 }, { width: p4, height: 1 }), Se$2.copy(c, n4, { x: 0, y: 0 }, { x: s5, y: u5 + h }, { width: p4, height: 1 }), Se$2.copy(c, n4, { x: p4 - 1, y: 0 }, { x: s5 - 1, y: u5 }, { width: 1, height: h }), Se$2.copy(c, n4, { x: 0, y: 0 }, { x: s5 + p4, y: u5 }, { width: 1, height: h });
    }
    this.dirty = true;
  }
  beginFrame() {
    this.callbackDispatchedThisFrame = {};
  }
  dispatchRenderCallbacks(e) {
    for (let t of e) {
      if (this.callbackDispatchedThisFrame[t]) continue;
      this.callbackDispatchedThisFrame[t] = true;
      let i = this.getImage(t);
      i || Le$1('Image with ID: "'.concat(t, '" was not found')), j0(i) && this.updateImage(t, i);
    }
  }
};
H$3(ad, "ImageManager");
var su$1 = ad;
a();
a();
async function Z0(r5, e, t, i) {
  let n4 = e * 256, o4 = n4 + 255, a4 = i.transformRequest(t.replace("{fontstack}", r5).replace("{range}", "".concat(n4, "-").concat(o4)), "Glyphs"), s5 = await pb$1(a4, new AbortController());
  if (!s5 || !s5.data) throw new Error("Could not load glyph range. range: ".concat(e, ", ").concat(n4, "-").concat(o4));
  let u5 = {};
  for (let c of k0(s5.data)) u5[c.id] = c;
  return u5;
}
H$3(Z0, "loadGlyphRange");
a();
var sd = class sd2 {
  constructor({ fontSize: e = 24, buffer: t = 3, radius: i = 8, cutoff: n4 = 0.25, fontFamily: o4 = "sans-serif", fontWeight: a4 = "normal", fontStyle: s5 = "normal" } = {}) {
    this.buffer = t, this.cutoff = n4, this.radius = i;
    let u5 = this.size = e + t * 4, c = this._createCanvas(u5), p4 = this.ctx = c.getContext("2d", { willReadFrequently: true });
    p4.font = "".concat(s5, " ").concat(a4, " ").concat(e, "px ").concat(o4), p4.textBaseline = "alphabetic", p4.textAlign = "left", p4.fillStyle = "black", this.gridOuter = new Float64Array(u5 * u5), this.gridInner = new Float64Array(u5 * u5), this.f = new Float64Array(u5), this.z = new Float64Array(u5 + 1), this.v = new Uint16Array(u5);
  }
  _createCanvas(e) {
    let t = document.createElement("canvas");
    return t.width = t.height = e, t;
  }
  draw(e) {
    let { width: t, actualBoundingBoxAscent: i, actualBoundingBoxDescent: n4, actualBoundingBoxLeft: o4, actualBoundingBoxRight: a4 } = this.ctx.measureText(e), s5 = Math.ceil(i), u5 = 0, c = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a4 - o4))), p4 = Math.min(this.size - this.buffer, s5 + Math.ceil(n4)), h = c + 2 * this.buffer, f = p4 + 2 * this.buffer, m5 = Math.max(h * f, 0), y4 = new Uint8ClampedArray(m5), g = { data: y4, width: h, height: f, glyphWidth: c, glyphHeight: p4, glyphTop: s5, glyphLeft: u5, glyphAdvance: t };
    if (c === 0 || p4 === 0) return g;
    let { ctx: x2, buffer: b, gridInner: w3, gridOuter: _ } = this;
    x2.clearRect(b, b, c, p4), x2.fillText(e, b, b + s5);
    let S4 = x2.getImageData(b, b, c, p4);
    _.fill(1e20, 0, m5), w3.fill(0, 0, m5);
    for (let P4 = 0; P4 < p4; P4++) for (let T3 = 0; T3 < c; T3++) {
      let L3 = S4.data[4 * (P4 * c + T3) + 3] / 255;
      if (L3 === 0) continue;
      let C3 = (P4 + b) * h + T3 + b;
      if (L3 === 1) _[C3] = 0, w3[C3] = 1e20;
      else {
        let E4 = 0.5 - L3;
        _[C3] = E4 > 0 ? E4 * E4 : 0, w3[C3] = E4 < 0 ? E4 * E4 : 0;
      }
    }
    H0(_, 0, 0, h, f, h, this.f, this.v, this.z), H0(w3, b, b, c, p4, h, this.f, this.v, this.z);
    for (let P4 = 0; P4 < m5; P4++) {
      let T3 = Math.sqrt(_[P4]) - Math.sqrt(w3[P4]);
      y4[P4] = Math.round(255 - 255 * (T3 / this.radius + this.cutoff));
    }
    return g;
  }
};
H$3(sd, "TinySDF");
var aa$1 = sd;
function H0(r5, e, t, i, n4, o4, a4, s5, u5) {
  for (let c = e; c < e + i; c++) $0(r5, t * o4 + c, o4, n4, a4, s5, u5);
  for (let c = t; c < t + n4; c++) $0(r5, c * o4 + e, 1, i, a4, s5, u5);
}
H$3(H0, "edt");
function $0(r5, e, t, i, n4, o4, a4) {
  o4[0] = 0, a4[0] = -1e20, a4[1] = 1e20, n4[0] = r5[e];
  for (let s5 = 1, u5 = 0, c = 0; s5 < i; s5++) {
    n4[s5] = r5[e + s5 * t];
    let p4 = s5 * s5;
    do {
      let h = o4[u5];
      c = (n4[s5] - n4[h] + p4 - h * h) / (s5 - h) / 2;
    } while (c <= a4[u5] && --u5 > -1);
    u5++, o4[u5] = s5, a4[u5] = c, a4[u5 + 1] = 1e20;
  }
  for (let s5 = 0, u5 = 0; s5 < i; s5++) {
    for (; a4[u5 + 1] < s5; ) u5++;
    let c = o4[u5], p4 = s5 - c;
    r5[e + s5 * t] = n4[c] + p4 * p4;
  }
}
H$3($0, "edt1d");
var bi = class bi2 {
  constructor(e, t) {
    this.requestManager = e, this.localIdeographFontFamily = t, this.entries = {};
  }
  setURL(e) {
    this.url = e;
  }
  async getGlyphs(e) {
    let t = [];
    for (let o4 in e) for (let a4 of e[o4]) t.push(this._getAndCacheGlyphsPromise(o4, a4));
    let i = await Promise.all(t), n4 = {};
    for (let { stack: o4, id: a4, glyph: s5 } of i) n4[o4] || (n4[o4] = {}), n4[o4][a4] = s5 && { id: s5.id, bitmap: s5.bitmap.clone(), metrics: s5.metrics };
    return n4;
  }
  async _getAndCacheGlyphsPromise(e, t) {
    let i = this.entries[e];
    i || (i = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
    let n4 = i.glyphs[t];
    if (n4 !== void 0) return { stack: e, id: t, glyph: n4 };
    if (n4 = this._tinySDF(i, e, t), n4) return i.glyphs[t] = n4, { stack: e, id: t, glyph: n4 };
    let o4 = Math.floor(t / 256);
    if (o4 * 256 > 65535) throw new Error("glyphs > 65535 not supported");
    if (i.ranges[o4]) return { stack: e, id: t, glyph: n4 };
    if (!this.url) throw new Error("glyphsUrl is not set");
    if (!i.requests[o4]) {
      let s5 = bi2.loadGlyphRange(e, o4, this.url, this.requestManager);
      i.requests[o4] = s5;
    }
    let a4 = await i.requests[o4];
    for (let s5 in a4) this._doesCharSupportLocalGlyph(+s5) || (i.glyphs[+s5] = a4[+s5]);
    return i.ranges[o4] = true, { stack: e, id: t, glyph: a4[t] || null };
  }
  _doesCharSupportLocalGlyph(e) {
    return !!this.localIdeographFontFamily && (he$1["CJK Unified Ideographs"](e) || he$1["Hangul Syllables"](e) || he$1.Hiragana(e) || he$1.Katakana(e));
  }
  _tinySDF(e, t, i) {
    let n4 = this.localIdeographFontFamily;
    if (!n4 || !this._doesCharSupportLocalGlyph(i)) return;
    let o4 = 2, a4 = e.tinySDF;
    if (!a4) {
      let p4 = "400";
      /bold/i.test(t) ? p4 = "900" : /medium/i.test(t) ? p4 = "500" : /light/i.test(t) && (p4 = "200"), a4 = e.tinySDF = new bi2.TinySDF({ fontSize: 24 * o4, buffer: 3 * o4, radius: 8 * o4, cutoff: 0.25, fontFamily: n4, fontWeight: p4 });
    }
    let s5 = a4.draw(String.fromCharCode(i));
    return { id: i, bitmap: new mi({ width: s5.width || 30 * o4, height: s5.height || 30 * o4 }, s5.data), metrics: { width: s5.glyphWidth / o4 || 24, height: s5.glyphHeight / o4 || 24, left: s5.glyphLeft / o4 + 0.5 || 0, top: s5.glyphTop / o4 - 27.5 || -8, advance: s5.glyphAdvance / o4 || 24, isDoubleResolution: true } };
  }
};
H$3(bi, "GlyphManager"), bi.loadGlyphRange = Z0, bi.TinySDF = aa$1;
var lu$1 = bi;
a();
var cd = class cd2 {
  constructor() {
    this.specification = A$1.light.position;
  }
  possiblyEvaluate(e, t) {
    return ib$1(e.expression.evaluate(t));
  }
  interpolate(e, t, i) {
    return { x: Pe$2.number(e.x, t.x, i), y: Pe$2.number(e.y, t.y, i), z: Pe$2.number(e.z, t.z, i) };
  }
};
H$3(cd, "LightPositionProperty");
var ud$1 = cd, W0 = "-transition", ld$1, pd$1 = class pd extends de$1 {
  constructor(e) {
    super(), ld$1 = ld$1 || new De$2({ anchor: new Z$2(A$1.light.anchor), position: new ud$1(), color: new Z$2(A$1.light.color), intensity: new Z$2(A$1.light.intensity) }), this._transitionable = new Qi(ld$1), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
  }
  getLight() {
    return this._transitionable.serialize();
  }
  setLight(e, t = {}) {
    if (!this._validate(S_, e, t)) for (let i in e) {
      let n4 = e[i];
      i.endsWith(W0) ? this._transitionable.setTransition(i.slice(0, -W0.length), n4) : this._transitionable.setValue(i, n4);
    }
  }
  updateTransitions(e) {
    this._transitioning = this._transitionable.transitioned(e, this._transitioning);
  }
  hasTransition() {
    return this._transitioning.hasTransition();
  }
  recalculate(e) {
    this.properties = this._transitioning.possiblyEvaluate(e);
  }
  _validate(e, t, i) {
    return i && i.validate === false ? false : Wi$1(this, e.call(Ne$1, { value: t, style: { glyphs: true, sprite: true }, styleSpec: A$1 }));
  }
};
H$3(pd$1, "Light");
var uu$1 = pd$1;
a();
var hd$1 = class hd {
  constructor(e, t) {
    this.width = e, this.height = t, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
  }
  getDash(e, t) {
    let i = e.join(",") + String(t);
    return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(e, t)), this.dashEntry[i];
  }
  getDashRanges(e, t, i) {
    let n4 = e.length % 2 === 1, o4 = [], a4 = n4 ? -e[e.length - 1] * i : 0, s5 = e[0] * i, u5 = true;
    o4.push({ left: a4, right: s5, isDash: u5, zeroLength: e[0] === 0 });
    let c = e[0];
    for (let p4 = 1; p4 < e.length; p4++) {
      u5 = !u5;
      let h = e[p4];
      a4 = c * i, c += h, s5 = c * i, o4.push({ left: a4, right: s5, isDash: u5, zeroLength: h === 0 });
    }
    return o4;
  }
  addRoundDash(e, t, i) {
    let n4 = t / 2;
    for (let o4 = -i; o4 <= i; o4++) {
      let a4 = this.nextRow + i + o4, s5 = this.width * a4, u5 = 0, c = e[u5];
      for (let p4 = 0; p4 < this.width; p4++) {
        p4 / c.right > 1 && (c = e[++u5]);
        let h = Math.abs(p4 - c.left), f = Math.abs(p4 - c.right), m5 = Math.min(h, f), y4, g = o4 / i * (n4 + 1);
        if (c.isDash) {
          let x2 = n4 - Math.abs(g);
          y4 = Math.sqrt(m5 * m5 + x2 * x2);
        } else y4 = n4 - Math.sqrt(m5 * m5 + g * g);
        this.data[s5 + p4] = Math.max(0, Math.min(255, y4 + 128));
      }
    }
  }
  addRegularDash(e) {
    for (let s5 = e.length - 1; s5 >= 0; --s5) {
      let u5 = e[s5], c = e[s5 + 1];
      u5.zeroLength ? e.splice(s5, 1) : c && c.isDash === u5.isDash && (c.left = u5.left, e.splice(s5, 1));
    }
    let t = e[0], i = e[e.length - 1];
    t.isDash === i.isDash && (t.left = i.left - this.width, i.right = t.right + this.width);
    let n4 = this.width * this.nextRow, o4 = 0, a4 = e[o4];
    for (let s5 = 0; s5 < this.width; s5++) {
      s5 / a4.right > 1 && (a4 = e[++o4]);
      let u5 = Math.abs(s5 - a4.left), c = Math.abs(s5 - a4.right), p4 = Math.min(u5, c), h = a4.isDash ? p4 : -p4;
      this.data[n4 + s5] = Math.max(0, Math.min(255, h + 128));
    }
  }
  addDash(e, t) {
    let i = t ? 7 : 0, n4 = 2 * i + 1;
    if (this.nextRow + n4 > this.height) return Le$1("LineAtlas out of space"), null;
    let o4 = 0;
    for (let s5 = 0; s5 < e.length; s5++) o4 += e[s5];
    if (o4 !== 0) {
      let s5 = this.width / o4, u5 = this.getDashRanges(e, this.width, s5);
      t ? this.addRoundDash(u5, s5, i) : this.addRegularDash(u5);
    }
    let a4 = { y: (this.nextRow + i + 0.5) / this.height, height: 2 * i / this.height, width: o4 };
    return this.nextRow += n4, this.dirty = true, a4;
  }
  bind(e) {
    let t = e.gl;
    this.texture ? (t.bindTexture(t.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, this.width, this.height, t.ALPHA, t.UNSIGNED_BYTE, this.data))) : (this.texture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texImage2D(t.TEXTURE_2D, 0, t.ALPHA, this.width, this.height, 0, t.ALPHA, t.UNSIGNED_BYTE, this.data));
  }
};
H$3(hd$1, "LineAtlas");
var cu$1 = hd$1;
a();
a();
a();
var fd$1 = class fd {
  constructor(e) {
    this._methodToThrottle = e, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
      this._triggered = false, this._methodToThrottle();
    });
  }
  trigger() {
    this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
      this._triggered = false, this._methodToThrottle();
    }, 0));
  }
  remove() {
    delete this._channel, this._methodToThrottle = () => {
    };
  }
};
H$3(fd$1, "ThrottledInvoker");
var pu$1 = fd$1;
var md$1 = class md {
  constructor(e, t) {
    this.target = e, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new pu$1(() => this.process()), this.subscription = ub$1(this.target, "message", (i) => this.receive(i), false), this.globalScope = rr$1(self) ? e : window;
  }
  registerMessageHandler(e, t) {
    this.messageHandlers[e] = t;
  }
  sendAsync(e, t) {
    return new Promise((i, n4) => {
      let o4 = Math.round(Math.random() * 1e18).toString(36).substring(0, 10);
      this.resolveRejects[o4] = { resolve: i, reject: n4 }, t && t.signal.addEventListener("abort", () => {
        delete this.resolveRejects[o4];
        let u5 = { id: o4, type: "<cancel>", origin: location.origin, targetMapId: e.targetMapId, sourceMapId: this.mapId };
        this.target.postMessage(u5);
      }, { once: true });
      let a4 = [], s5 = G$1(F$1({}, e), { id: o4, sourceMapId: this.mapId, origin: location.origin, data: Xi$1(e.data, a4) });
      this.target.postMessage(s5, { transfer: a4 });
    });
  }
  receive(e) {
    let t = e.data, i = t.id;
    if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== location.origin) && !(t.targetMapId && this.mapId !== t.targetMapId)) {
      if (t.type === "<cancel>") {
        delete this.tasks[i];
        let n4 = this.abortControllers[i];
        delete this.abortControllers[i], n4 && n4.abort();
        return;
      }
      if (rr$1(self) || t.mustQueue) {
        this.tasks[i] = t, this.taskQueue.push(i), this.invoker.trigger();
        return;
      }
      this.processTask(i, t);
    }
  }
  process() {
    if (this.taskQueue.length === 0) return;
    let e = this.taskQueue.shift(), t = this.tasks[e];
    delete this.tasks[e], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(e, t);
  }
  async processTask(e, t) {
    if (t.type === "<response>") {
      let o4 = this.resolveRejects[e];
      if (delete this.resolveRejects[e], !o4) return;
      t.error ? o4.reject(Ki(t.error)) : o4.resolve(Ki(t.data));
      return;
    }
    if (!this.messageHandlers[t.type]) {
      this.completeTask(e, new Error("Could not find a registered handler for ".concat(t.type, ", map ID: ").concat(this.mapId, ", available handlers: ").concat(Object.keys(this.messageHandlers).join(", "))));
      return;
    }
    let i = Ki(t.data), n4 = new AbortController();
    this.abortControllers[e] = n4;
    try {
      let o4 = await this.messageHandlers[t.type](t.sourceMapId, i, n4);
      this.completeTask(e, null, o4);
    } catch (o4) {
      this.completeTask(e, o4);
    }
  }
  completeTask(e, t, i) {
    let n4 = [];
    delete this.abortControllers[e];
    let o4 = { id: e, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? Xi$1(t) : null, data: Xi$1(i, n4) };
    this.target.postMessage(o4, { transfer: n4 });
  }
  remove() {
    this.invoker.remove(), this.subscription.unsubscribe();
  }
};
H$3(md$1, "Actor");
var hu2 = md$1;
a();
a();
a();
a();
var X0 = `(()=>{var _y=Object.create;var Ti=Object.defineProperty,Iy=Object.defineProperties,Ty=Object.getOwnPropertyDescriptor,Cy=Object.getOwnPropertyDescriptors,ky=Object.getOwnPropertyNames,Bl=Object.getOwnPropertySymbols,My=Object.getPrototypeOf,Rl=Object.prototype.hasOwnProperty,Ey=Object.prototype.propertyIsEnumerable;var zl=(t,e,r)=>e in t?Ti(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,Dt=(t,e)=>{for(var r in e||(e={}))Rl.call(e,r)&&zl(t,r,e[r]);if(Bl)for(var r of Bl(e))Ey.call(e,r)&&zl(t,r,e[r]);return t},Ci=(t,e)=>Iy(t,Cy(e));var Ae=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Ol=(t,e)=>{for(var r in e)Ti(t,r,{get:e[r],enumerable:!0})},Fy=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of ky(e))!Rl.call(t,i)&&i!==r&&Ti(t,i,{get:()=>e[i],enumerable:!(n=Ty(e,i))||n.enumerable});return t};var Z=(t,e,r)=>(r=t!=null?_y(My(t)):{},Fy(e||!t||!t.__esModule?Ti(r,"default",{value:t,enumerable:!0}):r,t));var he=Ae((d0,Nl)=>{"use strict";Nl.exports=sr;function sr(t,e){this.x=t,this.y=e}sr.prototype={clone:function(){return new sr(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[0]*this.x+t[1]*this.y,r=t[2]*this.x+t[3]*this.y;return this.x=e,this.y=r,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=e*this.x-r*this.y,i=r*this.x+e*this.y;return this.x=n,this.y=i,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),i=e.x+r*(this.x-e.x)-n*(this.y-e.y),o=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=i,this.y=o,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}};sr.convert=function(t){return t instanceof sr?t:Array.isArray(t)?new sr(t[0],t[1]):t}});var Gl=Ae((g0,$l)=>{"use strict";$l.exports=Ul;function Ul(t,e,r,n){this.cx=3*t,this.bx=3*(r-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=e,this.p2x=r,this.p2y=n}Ul.prototype={sampleCurveX:function(t){return((this.ax*t+this.bx)*t+this.cx)*t},sampleCurveY:function(t){return((this.ay*t+this.by)*t+this.cy)*t},sampleCurveDerivativeX:function(t){return(3*this.ax*t+2*this.bx)*t+this.cx},solveCurveX:function(t,e){if(e===void 0&&(e=1e-6),t<0)return 0;if(t>1)return 1;for(var r=t,n=0;n<8;n++){var i=this.sampleCurveX(r)-t;if(Math.abs(i)<e)return r;var o=this.sampleCurveDerivativeX(r);if(Math.abs(o)<1e-6)break;r=r-i/o}var a=0,s=1;for(r=t,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-t)<e));n++)t>i?a=r:s=r,r=(s-a)*.5+a;return r},solve:function(t,e){return this.sampleCurveY(this.solveCurveX(t,e))}}});var Mc=Ae((Yv,Ts)=>{function hd(t,e){var r,n,i,o,a,s,l,u,c,p;for(r=t.length&3,n=t.length-r,i=e,a=3432918353,l=461845907,p=0;p<n;)c=t.charCodeAt(p)&255|(t.charCodeAt(++p)&255)<<8|(t.charCodeAt(++p)&255)<<16|(t.charCodeAt(++p)&255)<<24,++p,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c,i=i<<13|i>>>19,o=(i&65535)*5+(((i>>>16)*5&65535)<<16)&4294967295,i=(o&65535)+27492+(((o>>>16)+58964&65535)<<16);switch(c=0,r){case 3:c^=(t.charCodeAt(p+2)&255)<<16;case 2:c^=(t.charCodeAt(p+1)&255)<<8;case 1:c^=t.charCodeAt(p)&255,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c}return i^=t.length,i^=i>>>16,i=(i&65535)*2246822507+(((i>>>16)*2246822507&65535)<<16)&4294967295,i^=i>>>13,i=(i&65535)*3266489909+(((i>>>16)*3266489909&65535)<<16)&4294967295,i^=i>>>16,i>>>0}typeof Ts<"u"&&(Ts.exports=hd)});var Ec=Ae((Qv,Cs)=>{function dd(t,e){for(var r=t.length,n=e^r,i=0,o;r>=4;)o=t.charCodeAt(i)&255|(t.charCodeAt(++i)&255)<<8|(t.charCodeAt(++i)&255)<<16|(t.charCodeAt(++i)&255)<<24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),o^=o>>>24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)^o,r-=4,++i;switch(r){case 3:n^=(t.charCodeAt(i+2)&255)<<16;case 2:n^=(t.charCodeAt(i+1)&255)<<8;case 1:n^=t.charCodeAt(i)&255,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)}return n^=n>>>13,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16),n^=n>>>15,n>>>0}typeof Cs!==void 0&&(Cs.exports=dd)});var ks=Ae((e1,Lo)=>{var Fc=Mc(),gd=Ec();Lo.exports=Fc;Lo.exports.murmur3=Fc;Lo.exports.murmur2=gd});var $s=Ae((JP,Us)=>{"use strict";Us.exports=Jo;Us.exports.default=Jo;function Jo(t,e,r){r=r||2;var n=e&&e.length,i=n?e[0]*r:t.length,o=xp(t,0,i,r,!0),a=[];if(!o||o.next===o.prev)return a;var s,l,u,c,p,f,y;if(n&&(o=nx(t,e,o,r)),t.length>80*r){s=u=t[0],l=c=t[1];for(var m=r;m<i;m+=r)p=t[m],f=t[m+1],p<s&&(s=p),f<l&&(l=f),p>u&&(u=p),f>c&&(c=f);y=Math.max(u-s,c-l),y=y!==0?32767/y:0}return Wn(o,a,r,s,l,y,0),a}function xp(t,e,r,n,i){var o,a;if(i===Ns(t,e,r,n)>0)for(o=e;o<r;o+=n)a=gp(o,t[o],t[o+1],a);else for(o=r-n;o>=e;o-=n)a=gp(o,t[o],t[o+1],a);return a&&Zo(a,a.next)&&(Xn(a),a=a.next),a}function tr(t,e){if(!t)return t;e||(e=t);var r=t,n;do if(n=!1,!r.steiner&&(Zo(r,r.next)||oe(r.prev,r,r.next)===0)){if(Xn(r),r=e=r.prev,r===r.next)break;n=!0}else r=r.next;while(n||r!==e);return e}function Wn(t,e,r,n,i,o,a){if(t){!a&&o&&lx(t,n,i,o);for(var s=t,l,u;t.prev!==t.next;){if(l=t.prev,u=t.next,o?ex(t,n,i,o):Qg(t)){e.push(l.i/r|0),e.push(t.i/r|0),e.push(u.i/r|0),Xn(t),t=u.next,s=u.next;continue}if(t=u,t===s){a?a===1?(t=tx(tr(t),e,r),Wn(t,e,r,n,i,o,2)):a===2&&rx(t,e,r,n,i,o):Wn(tr(t),e,r,n,i,o,1);break}}}}function Qg(t){var e=t.prev,r=t,n=t.next;if(oe(e,r,n)>=0)return!1;for(var i=e.x,o=r.x,a=n.x,s=e.y,l=r.y,u=n.y,c=i<o?i<a?i:a:o<a?o:a,p=s<l?s<u?s:u:l<u?l:u,f=i>o?i>a?i:a:o>a?o:a,y=s>l?s>u?s:u:l>u?l:u,m=n.next;m!==e;){if(m.x>=c&&m.x<=f&&m.y>=p&&m.y<=y&&Ir(i,s,o,l,a,u,m.x,m.y)&&oe(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function ex(t,e,r,n){var i=t.prev,o=t,a=t.next;if(oe(i,o,a)>=0)return!1;for(var s=i.x,l=o.x,u=a.x,c=i.y,p=o.y,f=a.y,y=s<l?s<u?s:u:l<u?l:u,m=c<p?c<f?c:f:p<f?p:f,h=s>l?s>u?s:u:l>u?l:u,d=c>p?c>f?c:f:p>f?p:f,g=Rs(y,m,e,r,n),b=Rs(h,d,e,r,n),x=t.prevZ,v=t.nextZ;x&&x.z>=g&&v&&v.z<=b;){if(x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Ir(s,c,l,p,u,f,x.x,x.y)&&oe(x.prev,x,x.next)>=0||(x=x.prevZ,v.x>=y&&v.x<=h&&v.y>=m&&v.y<=d&&v!==i&&v!==a&&Ir(s,c,l,p,u,f,v.x,v.y)&&oe(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;x&&x.z>=g;){if(x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Ir(s,c,l,p,u,f,x.x,x.y)&&oe(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;v&&v.z<=b;){if(v.x>=y&&v.x<=h&&v.y>=m&&v.y<=d&&v!==i&&v!==a&&Ir(s,c,l,p,u,f,v.x,v.y)&&oe(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function tx(t,e,r){var n=t;do{var i=n.prev,o=n.next.next;!Zo(i,o)&&bp(i,n,n.next,o)&&Hn(i,o)&&Hn(o,i)&&(e.push(i.i/r|0),e.push(n.i/r|0),e.push(o.i/r|0),Xn(n),Xn(n.next),n=t=o),n=n.next}while(n!==t);return tr(n)}function rx(t,e,r,n,i,o){var a=t;do{for(var s=a.next.next;s!==a.prev;){if(a.i!==s.i&&px(a,s)){var l=vp(a,s);a=tr(a,a.next),l=tr(l,l.next),Wn(a,e,r,n,i,o,0),Wn(l,e,r,n,i,o,0);return}s=s.next}a=a.next}while(a!==t)}function nx(t,e,r,n){var i=[],o,a,s,l,u;for(o=0,a=e.length;o<a;o++)s=e[o]*n,l=o<a-1?e[o+1]*n:t.length,u=xp(t,s,l,n,!1),u===u.next&&(u.steiner=!0),i.push(cx(u));for(i.sort(ix),o=0;o<i.length;o++)r=ox(i[o],r);return r}function ix(t,e){return t.x-e.x}function ox(t,e){var r=ax(t,e);if(!r)return e;var n=vp(r,t);return tr(n,n.next),tr(r,r.next)}function ax(t,e){var r=e,n=t.x,i=t.y,o=-1/0,a;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var s=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=n&&s>o&&(o=s,a=r.x<r.next.x?r:r.next,s===n))return a}r=r.next}while(r!==e);if(!a)return null;var l=a,u=a.x,c=a.y,p=1/0,f;r=a;do n>=r.x&&r.x>=u&&n!==r.x&&Ir(i<c?n:o,i,u,c,i<c?o:n,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(n-r.x),Hn(r,t)&&(f<p||f===p&&(r.x>a.x||r.x===a.x&&sx(a,r)))&&(a=r,p=f)),r=r.next;while(r!==l);return a}function sx(t,e){return oe(t.prev,t,e.prev)<0&&oe(e.next,t,t.next)<0}function lx(t,e,r,n){var i=t;do i.z===0&&(i.z=Rs(i.x,i.y,e,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,ux(i)}function ux(t){var e,r,n,i,o,a,s,l,u=1;do{for(r=t,t=null,o=null,a=0;r;){for(a++,n=r,s=0,e=0;e<u&&(s++,n=n.nextZ,!!n);e++);for(l=u;s>0||l>0&&n;)s!==0&&(l===0||!n||r.z<=n.z)?(i=r,r=r.nextZ,s--):(i=n,n=n.nextZ,l--),o?o.nextZ=i:t=i,i.prevZ=o,o=i;r=n}o.nextZ=null,u*=2}while(a>1);return t}function Rs(t,e,r,n,i){return t=(t-r)*i|0,e=(e-n)*i|0,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t|e<<1}function cx(t){var e=t,r=t;do(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;while(e!==t);return r}function Ir(t,e,r,n,i,o,a,s){return(i-a)*(e-s)>=(t-a)*(o-s)&&(t-a)*(n-s)>=(r-a)*(e-s)&&(r-a)*(o-s)>=(i-a)*(n-s)}function px(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!fx(t,e)&&(Hn(t,e)&&Hn(e,t)&&yx(t,e)&&(oe(t.prev,t,e.prev)||oe(t,e.prev,e))||Zo(t,e)&&oe(t.prev,t,t.next)>0&&oe(e.prev,e,e.next)>0)}function oe(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function Zo(t,e){return t.x===e.x&&t.y===e.y}function bp(t,e,r,n){var i=jo(oe(t,e,r)),o=jo(oe(t,e,n)),a=jo(oe(r,n,t)),s=jo(oe(r,n,e));return!!(i!==o&&a!==s||i===0&&qo(t,r,e)||o===0&&qo(t,n,e)||a===0&&qo(r,t,n)||s===0&&qo(r,e,n))}function qo(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function jo(t){return t>0?1:t<0?-1:0}function fx(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&bp(r,r.next,t,e))return!0;r=r.next}while(r!==t);return!1}function Hn(t,e){return oe(t.prev,t,t.next)<0?oe(t,e,t.next)>=0&&oe(t,t.prev,e)>=0:oe(t,e,t.prev)<0||oe(t,t.next,e)<0}function yx(t,e){var r=t,n=!1,i=(t.x+e.x)/2,o=(t.y+e.y)/2;do r.y>o!=r.next.y>o&&r.next.y!==r.y&&i<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==t);return n}function vp(t,e){var r=new Os(t.i,t.x,t.y),n=new Os(e.i,e.x,e.y),i=t.next,o=e.prev;return t.next=e,e.prev=t,r.next=i,i.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function gp(t,e,r,n){var i=new Os(t,e,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Xn(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Os(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}Jo.deviation=function(t,e,r,n){var i=e&&e.length,o=i?e[0]*r:t.length,a=Math.abs(Ns(t,0,o,r));if(i)for(var s=0,l=e.length;s<l;s++){var u=e[s]*r,c=s<l-1?e[s+1]*r:t.length;a-=Math.abs(Ns(t,u,c,r))}var p=0;for(s=0;s<n.length;s+=3){var f=n[s]*r,y=n[s+1]*r,m=n[s+2]*r;p+=Math.abs((t[f]-t[m])*(t[y+1]-t[f+1])-(t[f]-t[y])*(t[m+1]-t[f+1]))}return a===0&&p===0?0:Math.abs((p-a)/a)};function Ns(t,e,r,n){for(var i=0,o=e,a=r-n;o<r;o+=n)i+=(t[a]-t[o])*(t[o+1]+t[a+1]),a=o;return i}Jo.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,i=0;i<t.length;i++){for(var o=0;o<t[i].length;o++)for(var a=0;a<e;a++)r.vertices.push(t[i][o][a]);i>0&&(n+=t[i-1].length,r.holes.push(n))}return r}});var qs=Ae((kS,Cp)=>{"use strict";var vx=he();Cp.exports=Mr;function Mr(t,e,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=i,t.readFields(Px,this,e)}function Px(t,e,r){t==1?e.id=r.readVarint():t==2?Sx(r,e):t==3?e.type=r.readVarint():t==4&&(e._geometry=r.pos)}function Sx(t,e){for(var r=t.readVarint()+t.pos;t.pos<r;){var n=e._keys[t.readVarint()],i=e._values[t.readVarint()];e.properties[n]=i}}Mr.types=["Unknown","Point","LineString","Polygon"];Mr.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,o=0,a=[],s;t.pos<e;){if(n<=0){var l=t.readVarint();r=l&7,n=l>>3}if(n--,r===1||r===2)i+=t.readSVarint(),o+=t.readSVarint(),r===1&&(s&&a.push(s),s=[]),s.push(new vx(i,o));else if(r===7)s&&s.push(s[0].clone());else throw new Error("unknown command "+r)}return s&&a.push(s),a};Mr.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,i=0,o=0,a=1/0,s=-1/0,l=1/0,u=-1/0;t.pos<e;){if(n<=0){var c=t.readVarint();r=c&7,n=c>>3}if(n--,r===1||r===2)i+=t.readSVarint(),o+=t.readSVarint(),i<a&&(a=i),i>s&&(s=i),o<l&&(l=o),o>u&&(u=o);else if(r!==7)throw new Error("unknown command "+r)}return[a,l,s,u]};Mr.prototype.toGeoJSON=function(t,e,r){var n=this.extent*Math.pow(2,r),i=this.extent*t,o=this.extent*e,a=this.loadGeometry(),s=Mr.types[this.type],l,u;function c(y){for(var m=0;m<y.length;m++){var h=y[m],d=180-(h.y+o)*360/n;y[m]=[(h.x+i)*360/n-180,360/Math.PI*Math.atan(Math.exp(d*Math.PI/180))-90]}}switch(this.type){case 1:var p=[];for(l=0;l<a.length;l++)p[l]=a[l][0];a=p,c(a);break;case 2:for(l=0;l<a.length;l++)c(a[l]);break;case 3:for(a=wx(a),l=0;l<a.length;l++)for(u=0;u<a[l].length;u++)c(a[l][u]);break}a.length===1?a=a[0]:s="Multi"+s;var f={type:"Feature",geometry:{type:s,coordinates:a},properties:this.properties};return"id"in this&&(f.id=this.id),f};function wx(t){var e=t.length;if(e<=1)return[t];for(var r=[],n,i,o=0;o<e;o++){var a=Ax(t[o]);a!==0&&(i===void 0&&(i=a<0),i===a<0?(n&&r.push(n),n=[t[o]]):n.push(t[o]))}return n&&r.push(n),r}function Ax(t){for(var e=0,r=0,n=t.length,i=n-1,o,a;r<n;i=r++)o=t[r],a=t[i],e+=(a.x-o.x)*(o.y+a.y);return e}});var js=Ae((MS,Mp)=>{"use strict";var _x=qs();Mp.exports=kp;function kp(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(Ix,this,e),this.length=this._features.length}function Ix(t,e,r){t===15?e.version=r.readVarint():t===1?e.name=r.readString():t===5?e.extent=r.readVarint():t===2?e._features.push(r.pos):t===3?e._keys.push(r.readString()):t===4&&e._values.push(Tx(r))}function Tx(t){for(var e=null,r=t.readVarint()+t.pos;t.pos<r;){var n=t.readVarint()>>3;e=n===1?t.readString():n===2?t.readFloat():n===3?t.readDouble():n===4?t.readVarint64():n===5?t.readVarint():n===6?t.readSVarint():n===7?t.readBoolean():null}return e}kp.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new _x(this._pbf,e,this.extent,this._keys,this._values)}});var Fp=Ae((ES,Ep)=>{"use strict";var Cx=js();Ep.exports=kx;function kx(t,e){this.layers=t.readFields(Mx,{},e)}function Mx(t,e,r){if(t===3){var n=new Cx(r,r.readVarint()+r.pos);n.length&&(e[n.name]=n)}}});var Tt=Ae((FS,Ho)=>{Ho.exports.VectorTile=Fp();Ho.exports.VectorTileFeature=qs();Ho.exports.VectorTileLayer=js()});var Qp=Ae(Xs=>{Xs.read=function(t,e,r,n,i){var o,a,s=i*8-n-1,l=(1<<s)-1,u=l>>1,c=-7,p=r?i-1:0,f=r?-1:1,y=t[e+p];for(p+=f,o=y&(1<<-c)-1,y>>=-c,c+=s;c>0;o=o*256+t[e+p],p+=f,c-=8);for(a=o&(1<<-c)-1,o>>=-c,c+=n;c>0;a=a*256+t[e+p],p+=f,c-=8);if(o===0)o=1-u;else{if(o===l)return a?NaN:(y?-1:1)*(1/0);a=a+Math.pow(2,n),o=o-u}return(y?-1:1)*a*Math.pow(2,o-n)};Xs.write=function(t,e,r,n,i,o){var a,s,l,u=o*8-i-1,c=(1<<u)-1,p=c>>1,f=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=n?0:o-1,m=n?1:-1,h=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,a=c):(a=Math.floor(Math.log(e)/Math.LN2),e*(l=Math.pow(2,-a))<1&&(a--,l*=2),a+p>=1?e+=f/l:e+=f*Math.pow(2,1-p),e*l>=2&&(a++,l/=2),a+p>=c?(s=0,a=c):a+p>=1?(s=(e*l-1)*Math.pow(2,i),a=a+p):(s=e*Math.pow(2,p-1)*Math.pow(2,i),a=0));i>=8;t[r+y]=s&255,y+=m,s/=256,i-=8);for(a=a<<i|s,u+=i;u>0;t[r+y]=a&255,y+=m,a/=256,u-=8);t[r+y-m]|=h*128}});var ei=Ae((m2,of)=>{"use strict";of.exports=J;var ea=Qp();function J(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length}J.Varint=0;J.Fixed64=1;J.Bytes=2;J.Fixed32=5;var Ks=65536*65536,ef=1/Ks,Hx=12,nf=typeof TextDecoder>"u"?null:new TextDecoder("utf-8");J.prototype={destroy:function(){this.buf=null},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,o=this.pos;this.type=n&7,t(i,e,this),this.pos===o&&this.skip(n)}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=ta(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=rf(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=ta(this.buf,this.pos)+ta(this.buf,this.pos+4)*Ks;return this.pos+=8,t},readSFixed64:function(){var t=ta(this.buf,this.pos)+rf(this.buf,this.pos+4)*Ks;return this.pos+=8,t},readFloat:function(){var t=ea.read(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=ea.read(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e=this.buf,r,n;return n=e[this.pos++],r=n&127,n<128||(n=e[this.pos++],r|=(n&127)<<7,n<128)||(n=e[this.pos++],r|=(n&127)<<14,n<128)||(n=e[this.pos++],r|=(n&127)<<21,n<128)?r:(n=e[this.pos],r|=(n&15)<<28,Xx(r,t,this))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2===1?(t+1)/-2:t/2},readBoolean:function(){return!!this.readVarint()},readString:function(){var t=this.readVarint()+this.pos,e=this.pos;return this.pos=t,t-e>=Hx&&nf?cb(this.buf,e,t):ub(this.buf,e,t)},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==J.Bytes)return t.push(this.readVarint(e));var r=ct(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==J.Bytes)return t.push(this.readSVarint());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==J.Bytes)return t.push(this.readBoolean());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==J.Bytes)return t.push(this.readFloat());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==J.Bytes)return t.push(this.readDouble());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==J.Bytes)return t.push(this.readFixed32());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==J.Bytes)return t.push(this.readSFixed32());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==J.Bytes)return t.push(this.readFixed64());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==J.Bytes)return t.push(this.readSFixed64());var e=ct(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=t&7;if(e===J.Varint)for(;this.buf[this.pos++]>127;);else if(e===J.Bytes)this.pos=this.readVarint()+this.pos;else if(e===J.Fixed32)this.pos+=4;else if(e===J.Fixed64)this.pos+=8;else throw new Error("Unimplemented type: "+e)},writeTag:function(t,e){this.writeVarint(t<<3|e)},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),Lr(this.buf,t,this.pos),this.pos+=4},writeSFixed32:function(t){this.realloc(4),Lr(this.buf,t,this.pos),this.pos+=4},writeFixed64:function(t){this.realloc(8),Lr(this.buf,t&-1,this.pos),Lr(this.buf,Math.floor(t*ef),this.pos+4),this.pos+=8},writeSFixed64:function(t){this.realloc(8),Lr(this.buf,t&-1,this.pos),Lr(this.buf,Math.floor(t*ef),this.pos+4),this.pos+=8},writeVarint:function(t){if(t=+t||0,t>268435455||t<0){Kx(t,this);return}this.realloc(4),this.buf[this.pos++]=t&127|(t>127?128:0),!(t<=127)&&(this.buf[this.pos++]=(t>>>=7)&127|(t>127?128:0),!(t<=127)&&(this.buf[this.pos++]=(t>>>=7)&127|(t>127?128:0),!(t<=127)&&(this.buf[this.pos++]=t>>>7&127)))},writeSVarint:function(t){this.writeVarint(t<0?-t*2-1:t*2)},writeBoolean:function(t){this.writeVarint(!!t)},writeString:function(t){t=String(t),this.realloc(t.length*4),this.pos++;var e=this.pos;this.pos=pb(this.buf,t,this.pos);var r=this.pos-e;r>=128&&tf(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r},writeFloat:function(t){this.realloc(4),ea.write(this.buf,t,this.pos,!0,23,4),this.pos+=4},writeDouble:function(t){this.realloc(8),ea.write(this.buf,t,this.pos,!0,52,8),this.pos+=8},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r]},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&tf(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n},writeMessage:function(t,e,r){this.writeTag(t,J.Bytes),this.writeRawMessage(e,r)},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,eb,e)},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,tb,e)},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,ib,e)},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,rb,e)},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,nb,e)},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,ob,e)},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,ab,e)},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,sb,e)},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,lb,e)},writeBytesField:function(t,e){this.writeTag(t,J.Bytes),this.writeBytes(e)},writeFixed32Field:function(t,e){this.writeTag(t,J.Fixed32),this.writeFixed32(e)},writeSFixed32Field:function(t,e){this.writeTag(t,J.Fixed32),this.writeSFixed32(e)},writeFixed64Field:function(t,e){this.writeTag(t,J.Fixed64),this.writeFixed64(e)},writeSFixed64Field:function(t,e){this.writeTag(t,J.Fixed64),this.writeSFixed64(e)},writeVarintField:function(t,e){this.writeTag(t,J.Varint),this.writeVarint(e)},writeSVarintField:function(t,e){this.writeTag(t,J.Varint),this.writeSVarint(e)},writeStringField:function(t,e){this.writeTag(t,J.Bytes),this.writeString(e)},writeFloatField:function(t,e){this.writeTag(t,J.Fixed32),this.writeFloat(e)},writeDoubleField:function(t,e){this.writeTag(t,J.Fixed64),this.writeDouble(e)},writeBooleanField:function(t,e){this.writeVarintField(t,!!e)}};function Xx(t,e,r){var n=r.buf,i,o;if(o=n[r.pos++],i=(o&112)>>4,o<128||(o=n[r.pos++],i|=(o&127)<<3,o<128)||(o=n[r.pos++],i|=(o&127)<<10,o<128)||(o=n[r.pos++],i|=(o&127)<<17,o<128)||(o=n[r.pos++],i|=(o&127)<<24,o<128)||(o=n[r.pos++],i|=(o&1)<<31,o<128))return Fr(t,i,e);throw new Error("Expected varint not more than 10 bytes")}function ct(t){return t.type===J.Bytes?t.readVarint()+t.pos:t.pos+1}function Fr(t,e,r){return r?e*4294967296+(t>>>0):(e>>>0)*4294967296+(t>>>0)}function Kx(t,e){var r,n;if(t>=0?(r=t%4294967296|0,n=t/4294967296|0):(r=~(-t%4294967296),n=~(-t/4294967296),r^4294967295?r=r+1|0:(r=0,n=n+1|0)),t>=18446744073709552e3||t<-18446744073709552e3)throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10),Yx(r,n,e),Qx(n,e)}function Yx(t,e,r){r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos++]=t&127|128,t>>>=7,r.buf[r.pos]=t&127}function Qx(t,e){var r=(t&7)<<4;e.buf[e.pos++]|=r|((t>>>=3)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127|((t>>>=7)?128:0),t&&(e.buf[e.pos++]=t&127)))))}function tf(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(Math.LN2*7));r.realloc(n);for(var i=r.pos-1;i>=t;i--)r.buf[i+n]=r.buf[i]}function eb(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r])}function tb(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r])}function rb(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r])}function nb(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r])}function ib(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r])}function ob(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r])}function ab(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r])}function sb(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r])}function lb(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r])}function ta(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+t[e+3]*16777216}function Lr(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24}function rf(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}function ub(t,e,r){for(var n="",i=e;i<r;){var o=t[i],a=null,s=o>239?4:o>223?3:o>191?2:1;if(i+s>r)break;var l,u,c;s===1?o<128&&(a=o):s===2?(l=t[i+1],(l&192)===128&&(a=(o&31)<<6|l&63,a<=127&&(a=null))):s===3?(l=t[i+1],u=t[i+2],(l&192)===128&&(u&192)===128&&(a=(o&15)<<12|(l&63)<<6|u&63,(a<=2047||a>=55296&&a<=57343)&&(a=null))):s===4&&(l=t[i+1],u=t[i+2],c=t[i+3],(l&192)===128&&(u&192)===128&&(c&192)===128&&(a=(o&15)<<18|(l&63)<<12|(u&63)<<6|c&63,(a<=65535||a>=1114112)&&(a=null))),a===null?(a=65533,s=1):a>65535&&(a-=65536,n+=String.fromCharCode(a>>>10&1023|55296),a=56320|a&1023),n+=String.fromCharCode(a),i+=s}return n}function cb(t,e,r){return nf.decode(t.subarray(e,r))}function pb(t,e,r){for(var n=0,i,o;n<e.length;n++){if(i=e.charCodeAt(n),i>55295&&i<57344)if(o)if(i<56320){t[r++]=239,t[r++]=191,t[r++]=189,o=i;continue}else i=o-55296<<10|i-56320|65536,o=null;else{i>56319||n+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):o=i;continue}else o&&(t[r++]=239,t[r++]=191,t[r++]=189,o=null);i<128?t[r++]=i:(i<2048?t[r++]=i>>6|192:(i<65536?t[r++]=i>>12|224:(t[r++]=i>>18|240,t[r++]=i>>12&63|128),t[r++]=i>>6&63|128),t[r++]=i&63|128)}return r}});var ey=Ae((pT,Qf)=>{Qf.exports=Aa;function Aa(t,e){var r=t&&t.type,n;if(r==="FeatureCollection")for(n=0;n<t.features.length;n++)Aa(t.features[n],e);else if(r==="GeometryCollection")for(n=0;n<t.geometries.length;n++)Aa(t.geometries[n],e);else if(r==="Feature")Aa(t.geometry,e);else if(r==="Polygon")Kf(t.coordinates,e);else if(r==="MultiPolygon")for(n=0;n<t.coordinates.length;n++)Kf(t.coordinates[n],e);return t}function Kf(t,e){if(t.length!==0){Yf(t[0],e);for(var r=1;r<t.length;r++)Yf(t[r],!e)}}function Yf(t,e){for(var r=0,n=0,i=0,o=t.length,a=o-1;i<o;a=i++){var s=(t[i][0]-t[a][0])*(t[a][1]+t[i][1]),l=r+s;n+=Math.abs(r)>=Math.abs(s)?r-l+s:s-l+r,r=l}r+n>=0!=!!e&&t.reverse()}});var iy=Ae((mT,ny)=>{"use strict";var Zb=he(),Wb=Tt().VectorTileFeature;ny.exports=ry;function ry(t,e){this.options=e||{},this.features=t,this.length=t.length}ry.prototype.feature=function(t){return new Ia(this.features[t],this.options.extent)};function Ia(t,e){this.id=typeof t.id=="number"?t.id:void 0,this.type=t.type,this.rawGeometry=t.type===1?[t.geometry]:t.geometry,this.properties=t.tags,this.extent=e||4096}Ia.prototype.loadGeometry=function(){var t=this.rawGeometry;this.geometry=[];for(var e=0;e<t.length;e++){for(var r=t[e],n=[],i=0;i<r.length;i++)n.push(new Zb(r[i][0],r[i][1]));this.geometry.push(n)}return this.geometry};Ia.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var t=this.geometry,e=1/0,r=-1/0,n=1/0,i=-1/0,o=0;o<t.length;o++)for(var a=t[o],s=0;s<a.length;s++){var l=a[s];e=Math.min(e,l.x),r=Math.max(r,l.x),n=Math.min(n,l.y),i=Math.max(i,l.y)}return[e,n,r,i]};Ia.prototype.toGeoJSON=Wb.prototype.toGeoJSON});var sy=Ae((hT,gi)=>{var Hb=ei(),ay=iy();gi.exports=dl;gi.exports.fromVectorTileJs=dl;gi.exports.fromGeojsonVt=Xb;gi.exports.GeoJSONWrapper=ay;function dl(t){var e=new Hb;return Kb(t,e),e.finish()}function Xb(t,e){e=e||{};var r={};for(var n in t)r[n]=new ay(t[n].features,e),r[n].name=n,r[n].version=e.version,r[n].extent=e.extent;return dl({layers:r})}function Kb(t,e){for(var r in t.layers)e.writeMessage(3,Yb,t.layers[r])}function Yb(t,e){e.writeVarintField(15,t.version||1),e.writeStringField(1,t.name||""),e.writeVarintField(5,t.extent||4096);var r,n={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<t.length;r++)n.feature=t.feature(r),e.writeMessage(2,Qb,n);var i=n.keys;for(r=0;r<i.length;r++)e.writeStringField(3,i[r]);var o=n.values;for(r=0;r<o.length;r++)e.writeMessage(4,r0,o[r])}function Qb(t,e){var r=t.feature;r.id!==void 0&&e.writeVarintField(1,r.id),e.writeMessage(2,e0,t),e.writeVarintField(3,r.type),e.writeMessage(4,t0,r)}function e0(t,e){var r=t.feature,n=t.keys,i=t.values,o=t.keycache,a=t.valuecache;for(var s in r.properties){var l=r.properties[s],u=o[s];if(l!==null){typeof u>"u"&&(n.push(s),u=n.length-1,o[s]=u),e.writeVarint(u);var c=typeof l;c!=="string"&&c!=="boolean"&&c!=="number"&&(l=JSON.stringify(l));var p=c+":"+l,f=a[p];typeof f>"u"&&(i.push(l),f=i.length-1,a[p]=f),e.writeVarint(f)}}}function hl(t,e){return(e<<3)+(t&7)}function oy(t){return t<<1^t>>31}function t0(t,e){for(var r=t.loadGeometry(),n=t.type,i=0,o=0,a=r.length,s=0;s<a;s++){var l=r[s],u=1;n===1&&(u=l.length),e.writeVarint(hl(1,u));for(var c=n===3?l.length-1:l.length,p=0;p<c;p++){p===1&&n!==1&&e.writeVarint(hl(2,c-1));var f=l[p].x-i,y=l[p].y-o;e.writeVarint(oy(f)),e.writeVarint(oy(y)),i+=f,o+=y}n===3&&e.writeVarint(hl(7,1))}}function r0(t,e){var r=typeof t;r==="string"?e.writeStringField(1,t):r==="boolean"?e.writeBooleanField(7,t):r==="number"&&(t%1!==0?e.writeDoubleField(3,t):t<0?e.writeSVarintField(6,t):e.writeVarintField(5,t))}});var Ly=Z(he(),1),Zl=Z(Gl(),1);var Oa;function ql(){return Oa==null&&(Oa=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")&&typeof createImageBitmap=="function"),Oa}var ki;function jl(){if(ki==null&&(ki=!1,ql())){let r=new OffscreenCanvas(5,5).getContext("2d",{willReadFrequently:!0});if(r){for(let i=0;i<5*5;i++){let o=i*4;r.fillStyle="rgb(".concat(o,",").concat(o+1,",").concat(o+2,")"),r.fillRect(i%5,Math.floor(i/5),1,1)}let n=r.getImageData(0,0,5,5).data;for(let i=0;i<5*5*4;i++)if(i%4!==3&&n[i]!==i){ki=!0;break}}}return ki||!1}function Wl(t){if(t<=0)return 0;if(t>=1)return 1;let e=t*t,r=e*t;return 4*(t<.5?r:3*(t-e)+r-.75)}function Dy(t,e,r,n){let i=new Zl.default(t,e,r,n);return function(o){return i.solve(o)}}var S0=Dy(.25,.1,.25,1);function it(t,e,r){return Math.min(r,Math.max(e,t))}function Hl(t,e,r){let n=r-e,i=((t-e)%n+n)%n+e;return i===e?r:i}function Pe(t,...e){for(let r of e)for(let n in r)t[n]=r[n];return t}function Xl(t){return Math.log(t)/Math.LN2%1===0}function jr(t,e,r){let n={};for(let i in t)n[i]=e.call(r||this,t[i],i,t);return n}function Kl(t,e,r){let n={};for(let i in t)e.call(r||this,t[i],i,t)&&(n[i]=t[i]);return n}function nt(t){return Array.isArray(t)?t.map(nt):typeof t=="object"&&t?jr(t,nt):t}function Yl(t,e){for(let r=0;r<t.length;r++)if(e.indexOf(t[r])>=0)return!0;return!1}var Jl={};function fe(t){Jl[t]||(typeof console<"u"&&console.warn(t),Jl[t]=!0)}function ot(t,e,r){return(r.y-t.y)*(e.x-t.x)>(e.y-t.y)*(r.x-t.x)}function Ql(t){let e=0;for(let r=0,n=t.length,i=n-1,o,a;r<n;i=r++)o=t[r],a=t[i],e+=(a.x-o.x)*(o.y+a.y);return e}function at(t){return typeof WorkerGlobalScope<"u"&&typeof t<"u"&&t instanceof WorkerGlobalScope}function Jr(t){return typeof ImageBitmap<"u"&&t instanceof ImageBitmap}function Vy(t,e,r,n,i){let o=Math.max(-e,0)*4,l=(Math.max(0,r)-r)*n*4+o,u=n*4,c=Math.max(0,e),p=Math.max(0,r),f=Math.min(t.width,e+n),y=Math.min(t.height,r+i);return{rect:{x:c,y:p,width:f-c,height:y-p},layout:[{offset:l,stride:u}]}}async function By(t,e,r,n,i){if(typeof VideoFrame>"u")throw new Error("VideoFrame not supported");let o=new VideoFrame(t,{timestamp:0});try{let a=o==null?void 0:o.format;if(!a||!(a.startsWith("BGR")||a.startsWith("RGB")))throw new Error("Unrecognized format ".concat(a));let s=a.startsWith("BGR"),l=new Uint8ClampedArray(n*i*4);if(await o.copyTo(l,Vy(t,e,r,n,i)),s)for(let u=0;u<l.length;u+=4){let c=l[u];l[u]=l[u+2],l[u+2]=c}return l}finally{o.close()}}var Gr,qr;function zy(t,e,r,n,i){let o=t.width,a=t.height;(!Gr||!qr)&&(Gr=new OffscreenCanvas(o,a),qr=Gr.getContext("2d",{willReadFrequently:!0})),Gr.width=o,Gr.height=a,qr.drawImage(t,0,0,o,a);let s=qr.getImageData(e,r,n,i);return qr.clearRect(0,0,o,a),s.data}async function eu(t,e,r,n,i){if(jl())try{return await By(t,e,r,n,i)}catch(o){}return zy(t,e,r,n,i)}function tu(t,e,r,n){return t.addEventListener(e,r,n),{unsubscribe:()=>{t.removeEventListener(e,r,n)}}}var Vt=class t{constructor(e,r,n){let i=this.cells=[];if(e instanceof ArrayBuffer){this.arrayBuffer=e;let a=new Int32Array(this.arrayBuffer);e=a[0],r=a[1],n=a[2],this.d=r+2*n;for(let u=0;u<this.d*this.d;u++){let c=a[3+u],p=a[3+u+1];i.push(c===p?null:a.subarray(c,p))}let s=a[3+i.length],l=a[3+i.length+1];this.keys=a.subarray(s,l),this.bboxes=a.subarray(l),this.insert=this._insertReadonly}else{this.d=r+2*n;for(let a=0;a<this.d*this.d;a++)i.push([]);this.keys=[],this.bboxes=[]}this.n=r,this.extent=e,this.padding=n,this.scale=r/e,this.uid=0;let o=n/r*e;this.min=-o,this.max=e+o}insert(e,r,n,i,o){this._forEachCell(r,n,i,o,this._insertCell,this.uid++,void 0,void 0),this.keys.push(e),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i),this.bboxes.push(o)}_insertReadonly(){throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")}_insertCell(e,r,n,i,o,a){this.cells[o].push(a)}query(e,r,n,i,o){let a=this.min,s=this.max;if(e<=a&&r<=a&&s<=n&&s<=i&&!o)return Array.prototype.slice.call(this.keys);{let l=[],u={};return this._forEachCell(e,r,n,i,this._queryCell,l,u,o),l}}_queryCell(e,r,n,i,o,a,s,l){let u=this.cells[o];if(u!==null){let c=this.keys,p=this.bboxes;for(let f=0;f<u.length;f++){let y=u[f];if(s[y]===void 0){let m=y*4;(l?l(p[m+0],p[m+1],p[m+2],p[m+3]):e<=p[m+2]&&r<=p[m+3]&&n>=p[m+0]&&i>=p[m+1])?(s[y]=!0,a.push(c[y])):s[y]=!1}}}}_forEachCell(e,r,n,i,o,a,s,l){let u=this._convertToCellCoord(e),c=this._convertToCellCoord(r),p=this._convertToCellCoord(n),f=this._convertToCellCoord(i);for(let y=u;y<=p;y++)for(let m=c;m<=f;m++){let h=this.d*m+y;if(!(l&&!l(this._convertFromCellCoord(y),this._convertFromCellCoord(m),this._convertFromCellCoord(y+1),this._convertFromCellCoord(m+1)))&&o.call(this,e,r,n,i,h,a,s,l))return}}_convertFromCellCoord(e){return(e-this.padding)/this.scale}_convertToCellCoord(e){return Math.max(0,Math.min(this.d-1,Math.floor(e*this.scale)+this.padding))}toArrayBuffer(){if(this.arrayBuffer)return this.arrayBuffer;let e=this.cells,r=3+this.cells.length+1+1,n=0;for(let a=0;a<this.cells.length;a++)n+=this.cells[a].length;let i=new Int32Array(r+n+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;let o=r;for(let a=0;a<e.length;a++){let s=e[a];i[3+a]=o,i.set(s,o),o+=s.length}return i[3+e.length]=o,i.set(this.keys,o),o+=this.keys.length,i[3+e.length+1]=o,i.set(this.bboxes,o),o+=this.bboxes.length,i.buffer}static serialize(e,r){let n=e.toArrayBuffer();return r&&r.push(n),{buffer:n}}static deserialize(e){return new t(e.buffer)}};var Ry=8,Oy={version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},roll:{type:"number",default:0,units:"degrees"},light:{type:"light"},sky:{type:"sky"},projection:{type:"projection"},terrain:{type:"terrain"},sources:{required:!0,type:"sources"},sprite:{type:"sprite"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},Ny={"*":{type:"source"}},Uy=["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],$y={type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},promoteId:{type:"promoteId"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},Gy={type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},qy={type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{},custom:{}},default:"mapbox"},redFactor:{type:"number",default:1},blueFactor:{type:"number",default:1},greenFactor:{type:"number",default:1},baseShift:{type:"number",default:0},volatile:{type:"boolean",default:!1},"*":{type:"*"}},jy={type:{required:!0,type:"enum",values:{geojson:{}}},data:{required:!0,type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},filter:{type:"*"},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterMinPoints:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1},promoteId:{type:"promoteId"}},Jy={type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Zy={type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Wy={id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},Hy=["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background"],Xy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Ky={"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Yy={"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Qy={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},em={"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},tm={"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image",{"!":"icon-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"resolvedImage",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"padding",default:[2],units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},"viewport-glyph":{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-variable-anchor-offset":{type:"variableAnchorOffsetCollection",requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field",{"!":"text-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},rm={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},nm={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},im={type:"array",value:"*"},om={type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{}}},am={type:"enum",values:{Point:{},LineString:{},Polygon:{}}},sm={type:"array",minimum:0,maximum:24,value:["number","color"],length:2},lm={type:"array",value:"*",minimum:1},um={anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},cm={"sky-color":{type:"color","property-type":"data-constant",default:"#88C6FC",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-color":{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"fog-ground-blend":{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"horizon-fog-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"sky-horizon-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0},"atmosphere-blend":{type:"number","property-type":"data-constant",default:.8,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},pm={source:{type:"string",required:!0},exaggeration:{type:"number",minimum:0,default:1}},fm={type:{type:"enum",default:"mercator",values:{mercator:{},globe:{}}}},ym=["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background"],mm={"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},hm={"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},dm={"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},gm={"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},xm={"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},bm={"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},vm={"hillshade-illumination-direction":{type:"number",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"color",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},Pm={"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},Sm={duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},wm={"*":{type:"string"}},S={$version:Ry,$root:Oy,sources:Ny,source:Uy,source_vector:$y,source_raster:Gy,source_raster_dem:qy,source_geojson:jy,source_video:Jy,source_image:Zy,layer:Wy,layout:Hy,layout_background:Xy,layout_fill:Ky,layout_circle:Yy,layout_heatmap:Qy,"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:em,layout_symbol:tm,layout_raster:rm,layout_hillshade:nm,filter:im,filter_operator:om,geometry_type:am,function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:sm,expression:lm,light:um,sky:cm,terrain:pm,projection:fm,paint:ym,paint_fill:mm,"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:hm,paint_circle:dm,paint_heatmap:gm,paint_symbol:xm,paint_raster:bm,paint_hillshade:vm,paint_background:Pm,transition:Sm,"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}},promoteId:wm},Am=["type","source","source-layer","minzoom","maxzoom","filter","layout"];var M=class{constructor(e,r,n,i){this.message=(e?"".concat(e,": "):"")+n,i&&(this.identifier=i),r!=null&&r.__line__&&(this.line=r.__line__)}};function fr(t,...e){for(let r of e)for(let n in r)t[n]=r[n];return t}var Be=class extends Error{constructor(e,r){super(r),this.message=r,this.key=e}},Ha=class t{constructor(e,r=[]){this.parent=e,this.bindings={};for(let[n,i]of r)this.bindings[n]=i}concat(e){return new t(this,e)}get(e){if(this.bindings[e])return this.bindings[e];if(this.parent)return this.parent.get(e);throw new Error("".concat(e," not found in scope."))}has(e){return this.bindings[e]?!0:this.parent?this.parent.has(e):!1}},hr={kind:"null"},L={kind:"number"},G={kind:"string"},U={kind:"boolean"},Re={kind:"color"},cr={kind:"object"},$={kind:"value"},_m={kind:"error"},Wi={kind:"collator"},dr={kind:"formatted"},Hi={kind:"padding"},cn={kind:"resolvedImage"},Xi={kind:"variableAnchorOffsetCollection"};function Ee(t,e){return{kind:"array",itemType:t,N:e}}function te(t){if(t.kind==="array"){let e=te(t.itemType);return typeof t.N=="number"?"array<".concat(e,", ").concat(t.N,">"):t.itemType.kind==="value"?"array":"array<".concat(e,">")}else return t.kind}var Im=[hr,L,G,U,Re,dr,cr,Ee($),Hi,cn,Xi];function Kr(t,e){if(e.kind==="error")return null;if(t.kind==="array"){if(e.kind==="array"&&(e.N===0&&e.itemType.kind==="value"||!Kr(t.itemType,e.itemType))&&(typeof t.N!="number"||t.N===e.N))return null}else{if(t.kind===e.kind)return null;if(t.kind==="value"){for(let r of Im)if(!Kr(r,e))return null}}return"Expected ".concat(te(t)," but found ").concat(te(e)," instead.")}function fs(t,e){return e.some(r=>r.kind===t.kind)}function Rt(t,e){return e.some(r=>r==="null"?t===null:r==="array"?Array.isArray(t):r==="object"?t&&!Array.isArray(t)&&typeof t=="object":r===typeof t)}function Zr(t,e){return t.kind==="array"&&e.kind==="array"?t.itemType.kind===e.itemType.kind&&typeof t.N=="number":t.kind===e.kind}var wu=.96422,Au=1,_u=.82521,Iu=4/29,pr=6/29,Tu=3*pr*pr,Tm=pr*pr*pr,Cm=Math.PI/180,km=180/Math.PI;function Cu(t){return t=t%360,t<0&&(t+=360),t}function ku([t,e,r,n]){t=Na(t),e=Na(e),r=Na(r);let i,o,a=Ua((.2225045*t+.7168786*e+.0606169*r)/Au);t===e&&e===r?i=o=a:(i=Ua((.4360747*t+.3850649*e+.1430804*r)/wu),o=Ua((.0139322*t+.0971045*e+.7141733*r)/_u));let s=116*a-16;return[s<0?0:s,500*(i-a),200*(a-o),n]}function Na(t){return t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function Ua(t){return t>Tm?Math.pow(t,1/3):t/Tu+Iu}function Mu([t,e,r,n]){let i=(t+16)/116,o=isNaN(e)?i:i+e/500,a=isNaN(r)?i:i-r/200;return i=Au*Ga(i),o=wu*Ga(o),a=_u*Ga(a),[$a(3.1338561*o-1.6168667*i-.4906146*a),$a(-.9787684*o+1.9161415*i+.033454*a),$a(.0719453*o-.2289914*i+1.4052427*a),n]}function $a(t){return t=t<=.00304?12.92*t:1.055*Math.pow(t,1/2.4)-.055,t<0?0:t>1?1:t}function Ga(t){return t>pr?t*t*t:Tu*(t-Iu)}function Mm(t){let[e,r,n,i]=ku(t),o=Math.sqrt(r*r+n*n);return[Math.round(o*1e4)?Cu(Math.atan2(n,r)*km):NaN,o,e,i]}function Em([t,e,r,n]){return t=isNaN(t)?0:t*Cm,Mu([r,Math.cos(t)*e,Math.sin(t)*e,n])}function Fm([t,e,r,n]){t=Cu(t),e/=100,r/=100;function i(o){let a=(o+t/30)%12,s=e*Math.min(r,1-r);return r-s*Math.max(-1,Math.min(a-3,9-a,1))}return[i(0),i(8),i(4),n]}function Lm(t){if(t=t.toLowerCase().trim(),t==="transparent")return[0,0,0,0];let e=Dm[t];if(e){let[i,o,a]=e;return[i/255,o/255,a/255,1]}if(t.startsWith("#")&&/^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t)){let o=t.length<6?1:2,a=1;return[Mi(t.slice(a,a+=o)),Mi(t.slice(a,a+=o)),Mi(t.slice(a,a+=o)),Mi(t.slice(a,a+o)||"ff")]}if(t.startsWith("rgb")){let i=/^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,o=t.match(i);if(o){let[a,s,l,u,c,p,f,y,m,h,d,g]=o,b=[u||" ",f||" ",h].join("");if(b==="  "||b==="  /"||b===",,"||b===",,,"){let x=[l,p,m].join(""),v=x==="%%%"?100:x===""?255:0;if(v){let P=[lr(+s/v,0,1),lr(+c/v,0,1),lr(+y/v,0,1),d?ru(+d,g):1];if(nu(P))return P}}return}}let r=/^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,n=t.match(r);if(n){let[i,o,a,s,l,u,c,p,f]=n,y=[a||" ",l||" ",c].join("");if(y==="  "||y==="  /"||y===",,"||y===",,,"){let m=[+o,lr(+s,0,100),lr(+u,0,100),p?ru(+p,f):1];if(nu(m))return Fm(m)}}}function Mi(t){return parseInt(t.padEnd(2,t),16)/255}function ru(t,e){return lr(e?t/100:t,0,1)}function lr(t,e,r){return Math.min(Math.max(e,t),r)}function nu(t){return!t.some(Number.isNaN)}var Dm={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},W=class t{constructor(e,r,n,i=1,o=!0){this.r=e,this.g=r,this.b=n,this.a=i,o||(this.r*=i,this.g*=i,this.b*=i,i||this.overwriteGetter("rgb",[e,r,n,i]))}static parse(e){if(e instanceof t)return e;if(typeof e!="string")return;let r=Lm(e);if(r)return new t(...r,!1)}get rgb(){let{r:e,g:r,b:n,a:i}=this,o=i||1/0;return this.overwriteGetter("rgb",[e/o,r/o,n/o,i])}get hcl(){return this.overwriteGetter("hcl",Mm(this.rgb))}get lab(){return this.overwriteGetter("lab",ku(this.rgb))}overwriteGetter(e,r){return Object.defineProperty(this,e,{value:r}),r}toString(){let[e,r,n,i]=this.rgb;return"rgba(".concat([e,r,n].map(o=>Math.round(o*255)).join(","),",").concat(i,")")}};W.black=new W(0,0,0,1);W.white=new W(1,1,1,1);W.transparent=new W(0,0,0,0);W.red=new W(1,0,0,1);var Yr=class{constructor(e,r,n){e?this.sensitivity=r?"variant":"case":this.sensitivity=r?"accent":"base",this.locale=n,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(e,r){return this.collator.compare(e,r)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}},Qr=class{constructor(e,r,n,i,o){this.text=e,this.image=r,this.scale=n,this.fontStack=i,this.textColor=o}},Fe=class t{constructor(e){this.sections=e}static fromString(e){return new t([new Qr(e,null,null,null,null)])}isEmpty(){return this.sections.length===0?!0:!this.sections.some(e=>e.text.length!==0||e.image&&e.image.name.length!==0)}static factory(e){return e instanceof t?e:t.fromString(e)}toString(){return this.sections.length===0?"":this.sections.map(e=>e.text).join("")}},Ze=class t{constructor(e){this.values=e.slice()}static parse(e){if(e instanceof t)return e;if(typeof e=="number")return new t([e,e,e,e]);if(Array.isArray(e)&&!(e.length<1||e.length>4)){for(let r of e)if(typeof r!="number")return;switch(e.length){case 1:e=[e[0],e[0],e[0],e[0]];break;case 2:e=[e[0],e[1],e[0],e[1]];break;case 3:e=[e[0],e[1],e[2],e[1]];break}return new t(e)}}toString(){return JSON.stringify(this.values)}},Vm=new Set(["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"]),Ne=class t{constructor(e){this.values=e.slice()}static parse(e){if(e instanceof t)return e;if(!(!Array.isArray(e)||e.length<1||e.length%2!==0)){for(let r=0;r<e.length;r+=2){let n=e[r],i=e[r+1];if(typeof n!="string"||!Vm.has(n)||!Array.isArray(i)||i.length!==2||typeof i[0]!="number"||typeof i[1]!="number")return}return new t(e)}}toString(){return JSON.stringify(this.values)}},Te=class t{constructor(e){this.name=e.name,this.available=e.available}toString(){return this.name}static fromString(e){return e?new t({name:e,available:!1}):null}};function Eu(t,e,r,n){if(!(typeof t=="number"&&t>=0&&t<=255&&typeof e=="number"&&e>=0&&e<=255&&typeof r=="number"&&r>=0&&r<=255)){let i=typeof n=="number"?[t,e,r,n]:[t,e,r];return"Invalid rgba value [".concat(i.join(", "),"]: 'r', 'g', and 'b' must be between 0 and 255.")}return typeof n>"u"||typeof n=="number"&&n>=0&&n<=1?null:"Invalid rgba value [".concat([t,e,r,n].join(", "),"]: 'a' must be between 0 and 1.")}function en(t){if(t===null||typeof t=="string"||typeof t=="boolean"||typeof t=="number"||t instanceof W||t instanceof Yr||t instanceof Fe||t instanceof Ze||t instanceof Ne||t instanceof Te)return!0;if(Array.isArray(t)){for(let e of t)if(!en(e))return!1;return!0}else if(typeof t=="object"){for(let e in t)if(!en(t[e]))return!1;return!0}else return!1}function ue(t){if(t===null)return hr;if(typeof t=="string")return G;if(typeof t=="boolean")return U;if(typeof t=="number")return L;if(t instanceof W)return Re;if(t instanceof Yr)return Wi;if(t instanceof Fe)return dr;if(t instanceof Ze)return Hi;if(t instanceof Ne)return Xi;if(t instanceof Te)return cn;if(Array.isArray(t)){let e=t.length,r;for(let n of t){let i=ue(n);if(!r)r=i;else{if(r===i)continue;r=$;break}}return Ee(r||$,e)}else return cr}function Hr(t){let e=typeof t;return t===null?"":e==="string"||e==="number"||e==="boolean"?String(t):t instanceof W||t instanceof Fe||t instanceof Ze||t instanceof Ne||t instanceof Te?t.toString():JSON.stringify(t)}var mt=class t{constructor(e,r){this.type=e,this.value=r}static parse(e,r){if(e.length!==2)return r.error("'literal' expression requires exactly one argument, but found ".concat(e.length-1," instead."));if(!en(e[1]))return r.error("invalid value");let n=e[1],i=ue(n),o=r.expectedType;return i.kind==="array"&&i.N===0&&o&&o.kind==="array"&&(typeof o.N!="number"||o.N===0)&&(i=o),new t(i,n)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}},ie=class{constructor(e){this.name="ExpressionEvaluationError",this.message=e}toJSON(){return this.message}},Ei={string:G,number:L,boolean:U,object:cr},je=class t{constructor(e,r){this.type=e,this.args=r}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=1,i,o=e[0];if(o==="array"){let s;if(e.length>2){let u=e[1];if(typeof u!="string"||!(u in Ei)||u==="object")return r.error('The item type argument of "array" must be one of string, number, boolean',1);s=Ei[u],n++}else s=$;let l;if(e.length>3){if(e[2]!==null&&(typeof e[2]!="number"||e[2]<0||e[2]!==Math.floor(e[2])))return r.error('The length argument to "array" must be a positive integer literal',2);l=e[2],n++}i=Ee(s,l)}else{if(!Ei[o])throw new Error("Types doesn't contain name = ".concat(o));i=Ei[o]}let a=[];for(;n<e.length;n++){let s=r.parse(e[n],n,$);if(!s)return null;a.push(s)}return new t(i,a)}evaluate(e){for(let r=0;r<this.args.length;r++){let n=this.args[r].evaluate(e);if(Kr(this.type,ue(n))){if(r===this.args.length-1)throw new ie("Expected value to be of type ".concat(te(this.type),", but found ").concat(te(ue(n))," instead."))}else return n}throw new Error}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}},iu={"to-boolean":U,"to-color":Re,"to-number":L,"to-string":G},yt=class t{constructor(e,r){this.type=e,this.args=r}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=e[0];if(!iu[n])throw new Error("Can't parse ".concat(n," as it is not part of the known types"));if((n==="to-boolean"||n==="to-string")&&e.length!==2)return r.error("Expected one argument.");let i=iu[n],o=[];for(let a=1;a<e.length;a++){let s=r.parse(e[a],a,$);if(!s)return null;o.push(s)}return new t(i,o)}evaluate(e){switch(this.type.kind){case"boolean":return!!this.args[0].evaluate(e);case"color":{let r,n;for(let i of this.args){if(r=i.evaluate(e),n=null,r instanceof W)return r;if(typeof r=="string"){let o=e.parseColor(r);if(o)return o}else if(Array.isArray(r)&&(r.length<3||r.length>4?n="Invalid rgba value ".concat(JSON.stringify(r),": expected an array containing either three or four numeric values."):n=Eu(r[0],r[1],r[2],r[3]),!n))return new W(r[0]/255,r[1]/255,r[2]/255,r[3])}throw new ie(n||"Could not parse color from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"padding":{let r;for(let n of this.args){r=n.evaluate(e);let i=Ze.parse(r);if(i)return i}throw new ie("Could not parse padding from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"variableAnchorOffsetCollection":{let r;for(let n of this.args){r=n.evaluate(e);let i=Ne.parse(r);if(i)return i}throw new ie("Could not parse variableAnchorOffsetCollection from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"number":{let r=null;for(let n of this.args){if(r=n.evaluate(e),r===null)return 0;let i=Number(r);if(!isNaN(i))return i}throw new ie("Could not convert ".concat(JSON.stringify(r)," to number."))}case"formatted":return Fe.fromString(Hr(this.args[0].evaluate(e)));case"resolvedImage":return Te.fromString(Hr(this.args[0].evaluate(e)));default:return Hr(this.args[0].evaluate(e))}}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}},Bm=["Unknown","Point","LineString","Polygon"],Vi=class{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null}id(){return this.feature&&"id"in this.feature?this.feature.id:null}geometryType(){return this.feature?typeof this.feature.type=="number"?Bm[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}parseColor(e){let r=this._parseColorCache[e];return r||(r=this._parseColorCache[e]=W.parse(e)),r}},Bi=class t{constructor(e,r,n=[],i,o=new Ha,a=[]){this.registry=e,this.path=n,this.key=n.map(s=>"[".concat(s,"]")).join(""),this.scope=o,this.errors=a,this.expectedType=i,this._isConstant=r}parse(e,r,n,i,o={}){return r?this.concat(r,n,i)._parse(e,o):this._parse(e,o)}_parse(e,r){(e===null||typeof e=="string"||typeof e=="boolean"||typeof e=="number")&&(e=["literal",e]);function n(i,o,a){return a==="assert"?new je(o,[i]):a==="coerce"?new yt(o,[i]):i}if(Array.isArray(e)){if(e.length===0)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');let i=e[0];if(typeof i!="string")return this.error("Expression name must be a string, but found ".concat(typeof i,' instead. If you wanted a literal array, use ["literal", [...]].'),0),null;let o=this.registry[i];if(o){let a=o.parse(e,this);if(!a)return null;if(this.expectedType){let s=this.expectedType,l=a.type;if((s.kind==="string"||s.kind==="number"||s.kind==="boolean"||s.kind==="object"||s.kind==="array")&&l.kind==="value")a=n(a,s,r.typeAnnotation||"assert");else if((s.kind==="color"||s.kind==="formatted"||s.kind==="resolvedImage")&&(l.kind==="value"||l.kind==="string"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="padding"&&(l.kind==="value"||l.kind==="number"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="variableAnchorOffsetCollection"&&(l.kind==="value"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(this.checkSubtype(s,l))return null}if(!(a instanceof mt)&&a.type.kind!=="resolvedImage"&&this._isConstant(a)){let s=new Vi;try{a=new mt(a.type,a.evaluate(s))}catch(l){return this.error(l.message),null}}return a}return this.error('Unknown expression "'.concat(i,'". If you wanted a literal array, use ["literal", [...]].'),0)}else return typeof e>"u"?this.error("'undefined' value invalid. Use null instead."):typeof e=="object"?this.error('Bare objects invalid. Use ["literal", {...}] instead.'):this.error("Expected an array, but found ".concat(typeof e," instead."))}concat(e,r,n){let i=typeof e=="number"?this.path.concat(e):this.path,o=n?this.scope.concat(n):this.scope;return new t(this.registry,this._isConstant,i,r||null,o,this.errors)}error(e,...r){let n="".concat(this.key).concat(r.map(i=>"[".concat(i,"]")).join(""));this.errors.push(new Be(n,e))}checkSubtype(e,r){let n=Kr(e,r);return n&&this.error(n),n}},zi=class t{constructor(e,r){this.type=r.type,this.bindings=[].concat(e),this.result=r}evaluate(e){return this.result.evaluate(e)}eachChild(e){for(let r of this.bindings)e(r[1]);e(this.result)}static parse(e,r){if(e.length<4)return r.error("Expected at least 3 arguments, but found ".concat(e.length-1," instead."));let n=[];for(let o=1;o<e.length-1;o+=2){let a=e[o];if(typeof a!="string")return r.error("Expected string, but found ".concat(typeof a," instead."),o);if(/[^a-zA-Z0-9_]/.test(a))return r.error("Variable names must contain only alphanumeric characters or '_'.",o);let s=r.parse(e[o+1],o+1);if(!s)return null;n.push([a,s])}let i=r.parse(e[e.length-1],e.length-1,r.expectedType,n);return i?new t(n,i):null}outputDefined(){return this.result.outputDefined()}},Ri=class t{constructor(e,r){this.type=r.type,this.name=e,this.boundExpression=r}static parse(e,r){if(e.length!==2||typeof e[1]!="string")return r.error("'var' expression requires exactly one string literal argument.");let n=e[1];return r.scope.has(n)?new t(n,r.scope.get(n)):r.error('Unknown variable "'.concat(n,'". Make sure "').concat(n,'" has been bound in an enclosing "let" expression before using it.'),1)}evaluate(e){return this.boundExpression.evaluate(e)}eachChild(){}outputDefined(){return!1}},Xa=class t{constructor(e,r,n){this.type=e,this.index=r,this.input=n}static parse(e,r){if(e.length!==3)return r.error("Expected 2 arguments, but found ".concat(e.length-1," instead."));let n=r.parse(e[1],1,L),i=r.parse(e[2],2,Ee(r.expectedType||$));if(!n||!i)return null;let o=i.type;return new t(o.itemType,n,i)}evaluate(e){let r=this.index.evaluate(e),n=this.input.evaluate(e);if(r<0)throw new ie("Array index out of bounds: ".concat(r," < 0."));if(r>=n.length)throw new ie("Array index out of bounds: ".concat(r," > ").concat(n.length-1,"."));if(r!==Math.floor(r))throw new ie("Array index must be an integer, but found ".concat(r," instead."));return n[r]}eachChild(e){e(this.index),e(this.input)}outputDefined(){return!1}},Ka=class t{constructor(e,r){this.type=U,this.needle=e,this.haystack=r}static parse(e,r){if(e.length!==3)return r.error("Expected 2 arguments, but found ".concat(e.length-1," instead."));let n=r.parse(e[1],1,$),i=r.parse(e[2],2,$);return!n||!i?null:fs(n.type,[U,G,L,hr,$])?new t(n,i):r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(n.type)," instead"))}evaluate(e){let r=this.needle.evaluate(e),n=this.haystack.evaluate(e);if(!n)return!1;if(!Rt(r,["boolean","string","number","null"]))throw new ie("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(ue(r))," instead."));if(!Rt(n,["string","array"]))throw new ie("Expected second argument to be of type array or string, but found ".concat(te(ue(n))," instead."));return n.indexOf(r)>=0}eachChild(e){e(this.needle),e(this.haystack)}outputDefined(){return!0}},Ya=class t{constructor(e,r,n){this.type=L,this.needle=e,this.haystack=r,this.fromIndex=n}static parse(e,r){if(e.length<=2||e.length>=5)return r.error("Expected 3 or 4 arguments, but found ".concat(e.length-1," instead."));let n=r.parse(e[1],1,$),i=r.parse(e[2],2,$);if(!n||!i)return null;if(!fs(n.type,[U,G,L,hr,$]))return r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(n.type)," instead"));if(e.length===4){let o=r.parse(e[3],3,L);return o?new t(n,i,o):null}else return new t(n,i)}evaluate(e){let r=this.needle.evaluate(e),n=this.haystack.evaluate(e);if(!Rt(r,["boolean","string","number","null"]))throw new ie("Expected first argument to be of type boolean, string, number or null, but found ".concat(te(ue(r))," instead."));let i;if(this.fromIndex&&(i=this.fromIndex.evaluate(e)),Rt(n,["string"])){let o=n.indexOf(r,i);return o===-1?-1:[...n.slice(0,o)].length}else{if(Rt(n,["array"]))return n.indexOf(r,i);throw new ie("Expected second argument to be of type array or string, but found ".concat(te(ue(n))," instead."))}}eachChild(e){e(this.needle),e(this.haystack),this.fromIndex&&e(this.fromIndex)}outputDefined(){return!1}},Qa=class t{constructor(e,r,n,i,o,a){this.inputType=e,this.type=r,this.input=n,this.cases=i,this.outputs=o,this.otherwise=a}static parse(e,r){if(e.length<5)return r.error("Expected at least 4 arguments, but found only ".concat(e.length-1,"."));if(e.length%2!==1)return r.error("Expected an even number of arguments.");let n,i;r.expectedType&&r.expectedType.kind!=="value"&&(i=r.expectedType);let o={},a=[];for(let u=2;u<e.length-1;u+=2){let c=e[u],p=e[u+1];Array.isArray(c)||(c=[c]);let f=r.concat(u);if(c.length===0)return f.error("Expected at least one branch label.");for(let m of c){if(typeof m!="number"&&typeof m!="string")return f.error("Branch labels must be numbers or strings.");if(typeof m=="number"&&Math.abs(m)>Number.MAX_SAFE_INTEGER)return f.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER,"."));if(typeof m=="number"&&Math.floor(m)!==m)return f.error("Numeric branch labels must be integer values.");if(!n)n=ue(m);else if(f.checkSubtype(n,ue(m)))return null;if(typeof o[String(m)]<"u")return f.error("Branch labels must be unique.");o[String(m)]=a.length}let y=r.parse(p,u,i);if(!y)return null;i=i||y.type,a.push(y)}let s=r.parse(e[1],1,$);if(!s)return null;let l=r.parse(e[e.length-1],e.length-1,i);return!l||s.type.kind!=="value"&&r.concat(1).checkSubtype(n,s.type)?null:new t(n,i,s,o,a,l)}evaluate(e){let r=this.input.evaluate(e);return(ue(r)===this.inputType&&this.outputs[this.cases[r]]||this.otherwise).evaluate(e)}eachChild(e){e(this.input),this.outputs.forEach(e),e(this.otherwise)}outputDefined(){return this.outputs.every(e=>e.outputDefined())&&this.otherwise.outputDefined()}},es=class t{constructor(e,r,n){this.type=e,this.branches=r,this.otherwise=n}static parse(e,r){if(e.length<4)return r.error("Expected at least 3 arguments, but found only ".concat(e.length-1,"."));if(e.length%2!==0)return r.error("Expected an odd number of arguments.");let n;r.expectedType&&r.expectedType.kind!=="value"&&(n=r.expectedType);let i=[];for(let a=1;a<e.length-1;a+=2){let s=r.parse(e[a],a,U);if(!s)return null;let l=r.parse(e[a+1],a+1,n);if(!l)return null;i.push([s,l]),n=n||l.type}let o=r.parse(e[e.length-1],e.length-1,n);if(!o)return null;if(!n)throw new Error("Can't infer output type");return new t(n,i,o)}evaluate(e){for(let[r,n]of this.branches)if(r.evaluate(e))return n.evaluate(e);return this.otherwise.evaluate(e)}eachChild(e){for(let[r,n]of this.branches)e(r),e(n);e(this.otherwise)}outputDefined(){return this.branches.every(([e,r])=>r.outputDefined())&&this.otherwise.outputDefined()}},ts=class t{constructor(e,r,n,i){this.type=e,this.input=r,this.beginIndex=n,this.endIndex=i}static parse(e,r){if(e.length<=2||e.length>=5)return r.error("Expected 3 or 4 arguments, but found ".concat(e.length-1," instead."));let n=r.parse(e[1],1,$),i=r.parse(e[2],2,L);if(!n||!i)return null;if(!fs(n.type,[Ee($),G,$]))return r.error("Expected first argument to be of type array or string, but found ".concat(te(n.type)," instead"));if(e.length===4){let o=r.parse(e[3],3,L);return o?new t(n.type,n,i,o):null}else return new t(n.type,n,i)}evaluate(e){let r=this.input.evaluate(e),n=this.beginIndex.evaluate(e),i;if(this.endIndex&&(i=this.endIndex.evaluate(e)),Rt(r,["string"]))return[...r].slice(n,i).join("");if(Rt(r,["array"]))return r.slice(n,i);throw new ie("Expected first argument to be of type array or string, but found ".concat(te(ue(r))," instead."))}eachChild(e){e(this.input),e(this.beginIndex),this.endIndex&&e(this.endIndex)}outputDefined(){return!1}};function Ki(t,e){let r=t.length-1,n=0,i=r,o=0,a,s;for(;n<=i;)if(o=Math.floor((n+i)/2),a=t[o],s=t[o+1],a<=e){if(o===r||e<s)return o;n=o+1}else if(a>e)i=o-1;else throw new ie("Input is not a number.");return 0}var yr=class t{constructor(e,r,n){this.type=e,this.input=r,this.labels=[],this.outputs=[];for(let[i,o]of n)this.labels.push(i),this.outputs.push(o)}static parse(e,r){if(e.length-1<4)return r.error("Expected at least 4 arguments, but found only ".concat(e.length-1,"."));if((e.length-1)%2!==0)return r.error("Expected an even number of arguments.");let n=r.parse(e[1],1,L);if(!n)return null;let i=[],o=null;r.expectedType&&r.expectedType.kind!=="value"&&(o=r.expectedType);for(let a=1;a<e.length;a+=2){let s=a===1?-1/0:e[a],l=e[a+1],u=a,c=a+1;if(typeof s!="number")return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',u);if(i.length&&i[i.length-1][0]>=s)return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',u);let p=r.parse(l,c,o);if(!p)return null;o=o||p.type,i.push([s,p])}return new t(o,n,i)}evaluate(e){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(e);let i=this.input.evaluate(e);if(i<=r[0])return n[0].evaluate(e);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(e);let a=Ki(r,i);return n[a].evaluate(e)}eachChild(e){e(this.input);for(let r of this.outputs)e(r)}outputDefined(){return this.outputs.every(e=>e.outputDefined())}};function zm(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var qa,ou;function Rm(){if(ou)return qa;ou=1,qa=t;function t(e,r,n,i){this.cx=3*e,this.bx=3*(n-e)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*r,this.by=3*(i-r)-this.cy,this.ay=1-this.cy-this.by,this.p1x=e,this.p1y=r,this.p2x=n,this.p2y=i}return t.prototype={sampleCurveX:function(e){return((this.ax*e+this.bx)*e+this.cx)*e},sampleCurveY:function(e){return((this.ay*e+this.by)*e+this.cy)*e},sampleCurveDerivativeX:function(e){return(3*this.ax*e+2*this.bx)*e+this.cx},solveCurveX:function(e,r){if(r===void 0&&(r=1e-6),e<0)return 0;if(e>1)return 1;for(var n=e,i=0;i<8;i++){var o=this.sampleCurveX(n)-e;if(Math.abs(o)<r)return n;var a=this.sampleCurveDerivativeX(n);if(Math.abs(a)<1e-6)break;n=n-o/a}var s=0,l=1;for(n=e,i=0;i<20&&(o=this.sampleCurveX(n),!(Math.abs(o-e)<r));i++)e>o?s=n:l=n,n=(l-s)*.5+s;return n},solve:function(e,r){return this.sampleCurveY(this.solveCurveX(e,r))}},qa}var Om=Rm(),Nm=zm(Om);function Um(t){return t==="rgb"||t==="hcl"||t==="lab"}function Ot(t,e,r){return t+r*(e-t)}function $m(t,e,r,n="rgb"){switch(n){case"rgb":{let[i,o,a,s]=Oi(t.rgb,e.rgb,r);return new W(i,o,a,s,!1)}case"hcl":{let[i,o,a,s]=t.hcl,[l,u,c,p]=e.hcl,f,y;if(!isNaN(i)&&!isNaN(l)){let b=l-i;l>i&&b>180?b-=360:l<i&&i-l>180&&(b+=360),f=i+r*b}else isNaN(i)?isNaN(l)?f=NaN:(f=l,(a===1||a===0)&&(y=u)):(f=i,(c===1||c===0)&&(y=o));let[m,h,d,g]=Em([f,y!=null?y:Ot(o,u,r),Ot(a,c,r),Ot(s,p,r)]);return new W(m,h,d,g,!1)}case"lab":{let[i,o,a,s]=Mu(Oi(t.lab,e.lab,r));return new W(i,o,a,s,!1)}}}function Oi(t,e,r){return t.map((n,i)=>Ot(n,e[i],r))}function Gm(t,e,r){return new Ze(Oi(t.values,e.values,r))}function qm(t,e,r){let n=t.values,i=e.values;if(n.length!==i.length)throw new ie("Cannot interpolate values of different length. from: ".concat(t.toString(),", to: ").concat(e.toString()));let o=[];for(let a=0;a<n.length;a+=2){if(n[a]!==i[a])throw new ie("Cannot interpolate values containing mismatched anchors. from[".concat(a,"]: ").concat(n[a],", to[").concat(a,"]: ").concat(i[a]));o.push(n[a]);let[s,l]=n[a+1],[u,c]=i[a+1];o.push([Ot(s,u,r),Ot(l,c,r)])}return new Ne(o)}var Oe={number:Ot,color:$m,array:Oi,padding:Gm,variableAnchorOffsetCollection:qm},Je=class t{constructor(e,r,n,i,o){this.type=e,this.operator=r,this.interpolation=n,this.input=i,this.labels=[],this.outputs=[];for(let[a,s]of o)this.labels.push(a),this.outputs.push(s)}static interpolationFactor(e,r,n,i){let o=0;if(e.name==="exponential")o=ja(r,e.base,n,i);else if(e.name==="linear")o=ja(r,1,n,i);else if(e.name==="cubic-bezier"){let a=e.controlPoints;o=new Nm(a[0],a[1],a[2],a[3]).solve(ja(r,1,n,i))}return o}static parse(e,r){let[n,i,o,...a]=e;if(!Array.isArray(i)||i.length===0)return r.error("Expected an interpolation type expression.",1);if(i[0]==="linear")i={name:"linear"};else if(i[0]==="exponential"){let u=i[1];if(typeof u!="number")return r.error("Exponential interpolation requires a numeric base.",1,1);i={name:"exponential",base:u}}else if(i[0]==="cubic-bezier"){let u=i.slice(1);if(u.length!==4||u.some(c=>typeof c!="number"||c<0||c>1))return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);i={name:"cubic-bezier",controlPoints:u}}else return r.error("Unknown interpolation type ".concat(String(i[0])),1,0);if(e.length-1<4)return r.error("Expected at least 4 arguments, but found only ".concat(e.length-1,"."));if((e.length-1)%2!==0)return r.error("Expected an even number of arguments.");if(o=r.parse(o,2,L),!o)return null;let s=[],l=null;n==="interpolate-hcl"||n==="interpolate-lab"?l=Re:r.expectedType&&r.expectedType.kind!=="value"&&(l=r.expectedType);for(let u=0;u<a.length;u+=2){let c=a[u],p=a[u+1],f=u+3,y=u+4;if(typeof c!="number")return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',f);if(s.length&&s[s.length-1][0]>=c)return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',f);let m=r.parse(p,y,l);if(!m)return null;l=l||m.type,s.push([c,m])}return!Zr(l,L)&&!Zr(l,Re)&&!Zr(l,Hi)&&!Zr(l,Xi)&&!Zr(l,Ee(L))?r.error("Type ".concat(te(l)," is not interpolatable.")):new t(l,n,i,o,s)}evaluate(e){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(e);let i=this.input.evaluate(e);if(i<=r[0])return n[0].evaluate(e);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(e);let a=Ki(r,i),s=r[a],l=r[a+1],u=t.interpolationFactor(this.interpolation,i,s,l),c=n[a].evaluate(e),p=n[a+1].evaluate(e);switch(this.operator){case"interpolate":return Oe[this.type.kind](c,p,u);case"interpolate-hcl":return Oe.color(c,p,u,"hcl");case"interpolate-lab":return Oe.color(c,p,u,"lab")}}eachChild(e){e(this.input);for(let r of this.outputs)e(r)}outputDefined(){return this.outputs.every(e=>e.outputDefined())}};function ja(t,e,r,n){let i=n-r,o=t-r;return i===0?0:e===1?o/i:(Math.pow(e,o)-1)/(Math.pow(e,i)-1)}var Ni=class t{constructor(e,r){this.type=e,this.args=r}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=null,i=r.expectedType;i&&i.kind!=="value"&&(n=i);let o=[];for(let s of e.slice(1)){let l=r.parse(s,1+o.length,n,void 0,{typeAnnotation:"omit"});if(!l)return null;n=n||l.type,o.push(l)}if(!n)throw new Error("No output type");return i&&o.some(s=>Kr(i,s.type))?new t($,o):new t(n,o)}evaluate(e){let r=null,n=0,i;for(let o of this.args)if(n++,r=o.evaluate(e),r&&r instanceof Te&&!r.available&&(i||(i=r.name),r=null,n===this.args.length&&(r=i)),r!==null)break;return r}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}};function au(t,e){return t==="=="||t==="!="?e.kind==="boolean"||e.kind==="string"||e.kind==="number"||e.kind==="null"||e.kind==="value":e.kind==="string"||e.kind==="number"||e.kind==="value"}function jm(t,e,r){return e===r}function Jm(t,e,r){return e!==r}function Zm(t,e,r){return e<r}function Wm(t,e,r){return e>r}function Hm(t,e,r){return e<=r}function Xm(t,e,r){return e>=r}function Fu(t,e,r,n){return n.compare(e,r)===0}function Km(t,e,r,n){return!Fu(t,e,r,n)}function Ym(t,e,r,n){return n.compare(e,r)<0}function Qm(t,e,r,n){return n.compare(e,r)>0}function eh(t,e,r,n){return n.compare(e,r)<=0}function th(t,e,r,n){return n.compare(e,r)>=0}function gr(t,e,r){let n=t!=="=="&&t!=="!=";return class Lu{constructor(o,a,s){this.type=U,this.lhs=o,this.rhs=a,this.collator=s,this.hasUntypedArgument=o.type.kind==="value"||a.type.kind==="value"}static parse(o,a){if(o.length!==3&&o.length!==4)return a.error("Expected two or three arguments.");let s=o[0],l=a.parse(o[1],1,$);if(!l)return null;if(!au(s,l.type))return a.concat(1).error('"'.concat(s,"\\" comparisons are not supported for type '").concat(te(l.type),"'."));let u=a.parse(o[2],2,$);if(!u)return null;if(!au(s,u.type))return a.concat(2).error('"'.concat(s,"\\" comparisons are not supported for type '").concat(te(u.type),"'."));if(l.type.kind!==u.type.kind&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot compare types '".concat(te(l.type),"' and '").concat(te(u.type),"'."));n&&(l.type.kind==="value"&&u.type.kind!=="value"?l=new je(u.type,[l]):l.type.kind!=="value"&&u.type.kind==="value"&&(u=new je(l.type,[u])));let c=null;if(o.length===4){if(l.type.kind!=="string"&&u.type.kind!=="string"&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot use collator to compare non-string types.");if(c=a.parse(o[3],3,Wi),!c)return null}return new Lu(l,u,c)}evaluate(o){let a=this.lhs.evaluate(o),s=this.rhs.evaluate(o);if(n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!==u.kind||!(l.kind==="string"||l.kind==="number"))throw new ie('Expected arguments for "'.concat(t,'" to be (string, string) or (number, number), but found (').concat(l.kind,", ").concat(u.kind,") instead."))}if(this.collator&&!n&&this.hasUntypedArgument){let l=ue(a),u=ue(s);if(l.kind!=="string"||u.kind!=="string")return e(o,a,s)}return this.collator?r(o,a,s,this.collator.evaluate(o)):e(o,a,s)}eachChild(o){o(this.lhs),o(this.rhs),this.collator&&o(this.collator)}outputDefined(){return!0}}}var rh=gr("==",jm,Fu),nh=gr("!=",Jm,Km),ih=gr("<",Zm,Ym),oh=gr(">",Wm,Qm),ah=gr("<=",Hm,eh),sh=gr(">=",Xm,th),Ui=class t{constructor(e,r,n){this.type=Wi,this.locale=n,this.caseSensitive=e,this.diacriticSensitive=r}static parse(e,r){if(e.length!==2)return r.error("Expected one argument.");let n=e[1];if(typeof n!="object"||Array.isArray(n))return r.error("Collator options argument must be an object.");let i=r.parse(n["case-sensitive"]===void 0?!1:n["case-sensitive"],1,U);if(!i)return null;let o=r.parse(n["diacritic-sensitive"]===void 0?!1:n["diacritic-sensitive"],1,U);if(!o)return null;let a=null;return n.locale&&(a=r.parse(n.locale,1,G),!a)?null:new t(i,o,a)}evaluate(e){return new Yr(this.caseSensitive.evaluate(e),this.diacriticSensitive.evaluate(e),this.locale?this.locale.evaluate(e):null)}eachChild(e){e(this.caseSensitive),e(this.diacriticSensitive),this.locale&&e(this.locale)}outputDefined(){return!1}},rs=class t{constructor(e,r,n,i,o){this.type=G,this.number=e,this.locale=r,this.currency=n,this.minFractionDigits=i,this.maxFractionDigits=o}static parse(e,r){if(e.length!==3)return r.error("Expected two arguments.");let n=r.parse(e[1],1,L);if(!n)return null;let i=e[2];if(typeof i!="object"||Array.isArray(i))return r.error("NumberFormat options argument must be an object.");let o=null;if(i.locale&&(o=r.parse(i.locale,1,G),!o))return null;let a=null;if(i.currency&&(a=r.parse(i.currency,1,G),!a))return null;let s=null;if(i["min-fraction-digits"]&&(s=r.parse(i["min-fraction-digits"],1,L),!s))return null;let l=null;return i["max-fraction-digits"]&&(l=r.parse(i["max-fraction-digits"],1,L),!l)?null:new t(n,o,a,s,l)}evaluate(e){return new Intl.NumberFormat(this.locale?this.locale.evaluate(e):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(e):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(e):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(e):void 0}).format(this.number.evaluate(e))}eachChild(e){e(this.number),this.locale&&e(this.locale),this.currency&&e(this.currency),this.minFractionDigits&&e(this.minFractionDigits),this.maxFractionDigits&&e(this.maxFractionDigits)}outputDefined(){return!1}},tn=class t{constructor(e){this.type=dr,this.sections=e}static parse(e,r){if(e.length<2)return r.error("Expected at least one argument.");let n=e[1];if(!Array.isArray(n)&&typeof n=="object")return r.error("First argument must be an image or text section.");let i=[],o=!1;for(let a=1;a<=e.length-1;++a){let s=e[a];if(o&&typeof s=="object"&&!Array.isArray(s)){o=!1;let l=null;if(s["font-scale"]&&(l=r.parse(s["font-scale"],1,L),!l))return null;let u=null;if(s["text-font"]&&(u=r.parse(s["text-font"],1,Ee(G)),!u))return null;let c=null;if(s["text-color"]&&(c=r.parse(s["text-color"],1,Re),!c))return null;let p=i[i.length-1];p.scale=l,p.font=u,p.textColor=c}else{let l=r.parse(e[a],1,$);if(!l)return null;let u=l.type.kind;if(u!=="string"&&u!=="value"&&u!=="null"&&u!=="resolvedImage")return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");o=!0,i.push({content:l,scale:null,font:null,textColor:null})}}return new t(i)}evaluate(e){let r=n=>{let i=n.content.evaluate(e);return ue(i)===cn?new Qr("",i,null,null,null):new Qr(Hr(i),null,n.scale?n.scale.evaluate(e):null,n.font?n.font.evaluate(e).join(","):null,n.textColor?n.textColor.evaluate(e):null)};return new Fe(this.sections.map(r))}eachChild(e){for(let r of this.sections)e(r.content),r.scale&&e(r.scale),r.font&&e(r.font),r.textColor&&e(r.textColor)}outputDefined(){return!1}},ns=class t{constructor(e){this.type=cn,this.input=e}static parse(e,r){if(e.length!==2)return r.error("Expected two arguments.");let n=r.parse(e[1],1,G);return n?new t(n):r.error("No image name provided.")}evaluate(e){let r=this.input.evaluate(e),n=Te.fromString(r);return n&&e.availableImages&&(n.available=e.availableImages.indexOf(r)>-1),n}eachChild(e){e(this.input)}outputDefined(){return!1}},is=class t{constructor(e){this.type=L,this.input=e}static parse(e,r){if(e.length!==2)return r.error("Expected 1 argument, but found ".concat(e.length-1," instead."));let n=r.parse(e[1],1);return n?n.type.kind!=="array"&&n.type.kind!=="string"&&n.type.kind!=="value"?r.error("Expected argument of type string or array, but found ".concat(te(n.type)," instead.")):new t(n):null}evaluate(e){let r=this.input.evaluate(e);if(typeof r=="string")return[...r].length;if(Array.isArray(r))return r.length;throw new ie("Expected value to be of type string or array, but found ".concat(te(ue(r))," instead."))}eachChild(e){e(this.input)}outputDefined(){return!1}},Xe=8192;function lh(t,e){let r=uh(t[0]),n=ph(t[1]),i=Math.pow(2,e.z);return[Math.round(r*i*Xe),Math.round(n*i*Xe)]}function ys(t,e){let r=Math.pow(2,e.z),n=(t[0]/Xe+e.x)/r,i=(t[1]/Xe+e.y)/r;return[ch(n),fh(i)]}function uh(t){return(180+t)/360}function ch(t){return t*360-180}function ph(t){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function fh(t){return 360/Math.PI*Math.atan(Math.exp((180-t*360)*Math.PI/180))-90}function pn(t,e){t[0]=Math.min(t[0],e[0]),t[1]=Math.min(t[1],e[1]),t[2]=Math.max(t[2],e[0]),t[3]=Math.max(t[3],e[1])}function rn(t,e){return!(t[0]<=e[0]||t[2]>=e[2]||t[1]<=e[1]||t[3]>=e[3])}function yh(t,e,r){return e[1]>t[1]!=r[1]>t[1]&&t[0]<(r[0]-e[0])*(t[1]-e[1])/(r[1]-e[1])+e[0]}function mh(t,e,r){let n=t[0]-e[0],i=t[1]-e[1],o=t[0]-r[0],a=t[1]-r[1];return n*a-o*i===0&&n*o<=0&&i*a<=0}function Yi(t,e,r,n){let i=[e[0]-t[0],e[1]-t[1]],o=[n[0]-r[0],n[1]-r[1]];return xh(o,i)===0?!1:!!(su(t,e,r,n)&&su(r,n,t,e))}function hh(t,e,r){for(let n of r)for(let i=0;i<n.length-1;++i)if(Yi(t,e,n[i],n[i+1]))return!0;return!1}function xr(t,e,r=!1){let n=!1;for(let i of e)for(let o=0;o<i.length-1;o++){if(mh(t,i[o],i[o+1]))return r;yh(t,i[o],i[o+1])&&(n=!n)}return n}function dh(t,e){for(let r of e)if(xr(t,r))return!0;return!1}function Du(t,e){for(let r of t)if(!xr(r,e))return!1;for(let r=0;r<t.length-1;++r)if(hh(t[r],t[r+1],e))return!1;return!0}function gh(t,e){for(let r of e)if(Du(t,r))return!0;return!1}function xh(t,e){return t[0]*e[1]-t[1]*e[0]}function su(t,e,r,n){let i=t[0]-r[0],o=t[1]-r[1],a=e[0]-r[0],s=e[1]-r[1],l=n[0]-r[0],u=n[1]-r[1],c=i*u-l*o,p=a*u-l*s;return c>0&&p<0||c<0&&p>0}function ms(t,e,r){let n=[];for(let i=0;i<t.length;i++){let o=[];for(let a=0;a<t[i].length;a++){let s=lh(t[i][a],r);pn(e,s),o.push(s)}n.push(o)}return n}function Vu(t,e,r){let n=[];for(let i=0;i<t.length;i++){let o=ms(t[i],e,r);n.push(o)}return n}function Bu(t,e,r,n){if(t[0]<r[0]||t[0]>r[2]){let i=n*.5,o=t[0]-r[0]>i?-n:r[0]-t[0]>i?n:0;o===0&&(o=t[0]-r[2]>i?-n:r[2]-t[0]>i?n:0),t[0]+=o}pn(e,t)}function bh(t){t[0]=t[1]=1/0,t[2]=t[3]=-1/0}function lu(t,e,r,n){let i=Math.pow(2,n.z)*Xe,o=[n.x*Xe,n.y*Xe],a=[];for(let s of t)for(let l of s){let u=[l.x+o[0],l.y+o[1]];Bu(u,e,r,i),a.push(u)}return a}function uu(t,e,r,n){let i=Math.pow(2,n.z)*Xe,o=[n.x*Xe,n.y*Xe],a=[];for(let s of t){let l=[];for(let u of s){let c=[u.x+o[0],u.y+o[1]];pn(e,c),l.push(c)}a.push(l)}if(e[2]-e[0]<=i/2){bh(e);for(let s of a)for(let l of s)Bu(l,e,r,i)}return a}function vh(t,e){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(e.type==="Polygon"){let o=ms(e.coordinates,n,i),a=lu(t.geometry(),r,n,i);if(!rn(r,n))return!1;for(let s of a)if(!xr(s,o))return!1}if(e.type==="MultiPolygon"){let o=Vu(e.coordinates,n,i),a=lu(t.geometry(),r,n,i);if(!rn(r,n))return!1;for(let s of a)if(!dh(s,o))return!1}return!0}function Ph(t,e){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(e.type==="Polygon"){let o=ms(e.coordinates,n,i),a=uu(t.geometry(),r,n,i);if(!rn(r,n))return!1;for(let s of a)if(!Du(s,o))return!1}if(e.type==="MultiPolygon"){let o=Vu(e.coordinates,n,i),a=uu(t.geometry(),r,n,i);if(!rn(r,n))return!1;for(let s of a)if(!gh(s,o))return!1}return!0}var nn=class t{constructor(e,r){this.type=U,this.geojson=e,this.geometries=r}static parse(e,r){if(e.length!==2)return r.error("'within' expression requires exactly one argument, but found ".concat(e.length-1," instead."));if(en(e[1])){let n=e[1];if(n.type==="FeatureCollection"){let i=[];for(let o of n.features){let{type:a,coordinates:s}=o.geometry;a==="Polygon"&&i.push(s),a==="MultiPolygon"&&i.push(...s)}if(i.length){let o={type:"MultiPolygon",coordinates:i};return new t(n,o)}}else if(n.type==="Feature"){let i=n.geometry.type;if(i==="Polygon"||i==="MultiPolygon")return new t(n,n.geometry)}else if(n.type==="Polygon"||n.type==="MultiPolygon")return new t(n,n)}return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")}evaluate(e){if(e.geometry()!=null&&e.canonicalID()!=null){if(e.geometryType()==="Point")return vh(e,this.geometries);if(e.geometryType()==="LineString")return Ph(e,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}},$i=class{constructor(e=[],r=(n,i)=>n<i?-1:n>i?1:0){if(this.data=e,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(e){this.data.push(e),this._up(this.length++)}pop(){if(this.length===0)return;let e=this.data[0],r=this.data.pop();return--this.length>0&&(this.data[0]=r,this._down(0)),e}peek(){return this.data[0]}_up(e){let{data:r,compare:n}=this,i=r[e];for(;e>0;){let o=e-1>>1,a=r[o];if(n(i,a)>=0)break;r[e]=a,e=o}r[e]=i}_down(e){let{data:r,compare:n}=this,i=this.length>>1,o=r[e];for(;e<i;){let a=(e<<1)+1,s=a+1;if(s<this.length&&n(r[s],r[a])<0&&(a=s),n(r[a],o)>=0)break;r[e]=r[a],e=a}r[e]=o}};function Sh(t,e,r,n,i){zu(t,e,r,n||t.length-1,i||wh)}function zu(t,e,r,n,i){for(;n>r;){if(n-r>600){var o=n-r+1,a=e-r+1,s=Math.log(o),l=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(e-a*l/o+u)),p=Math.min(n,Math.floor(e+(o-a)*l/o+u));zu(t,e,c,p,i)}var f=t[e],y=r,m=n;for(Wr(t,r,e),i(t[n],f)>0&&Wr(t,r,n);y<m;){for(Wr(t,y,m),y++,m--;i(t[y],f)<0;)y++;for(;i(t[m],f)>0;)m--}i(t[r],f)===0?Wr(t,r,m):(m++,Wr(t,m,n)),m<=e&&(r=m+1),e<=m&&(n=m-1)}}function Wr(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function wh(t,e){return t<e?-1:t>e?1:0}function Ah(t,e){if(t.length<=1)return[t];let n=[],i,o;for(let a of t){let s=Ih(a);s!==0&&(a.area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[a]):i.push(a))}if(i&&n.push(i),e>1)for(let a=0;a<n.length;a++)n[a].length<=e||(Sh(n[a],e,1,n[a].length-1,_h),n[a]=n[a].slice(0,e));return n}function _h(t,e){return e.area-t.area}function Ih(t){let e=0;for(let r=0,n=t.length,i=n-1,o,a;r<n;i=r++)o=t[r],a=t[i],e+=(a.x-o.x)*(o.y+a.y);return e}var Th=6378.137,cu=1/298.257223563,pu=cu*(2-cu),fu=Math.PI/180,on=class{constructor(e){let r=fu*Th*1e3,n=Math.cos(e*fu),i=1/(1-pu*(1-n*n)),o=Math.sqrt(i);this.kx=r*o*n,this.ky=r*o*i*(1-pu)}distance(e,r){let n=this.wrap(e[0]-r[0])*this.kx,i=(e[1]-r[1])*this.ky;return Math.sqrt(n*n+i*i)}pointOnLine(e,r){let n=1/0,i,o,a,s;for(let l=0;l<e.length-1;l++){let u=e[l][0],c=e[l][1],p=this.wrap(e[l+1][0]-u)*this.kx,f=(e[l+1][1]-c)*this.ky,y=0;(p!==0||f!==0)&&(y=(this.wrap(r[0]-u)*this.kx*p+(r[1]-c)*this.ky*f)/(p*p+f*f),y>1?(u=e[l+1][0],c=e[l+1][1]):y>0&&(u+=p/this.kx*y,c+=f/this.ky*y)),p=this.wrap(r[0]-u)*this.kx,f=(r[1]-c)*this.ky;let m=p*p+f*f;m<n&&(n=m,i=u,o=c,a=l,s=y)}return{point:[i,o],index:a,t:Math.max(0,Math.min(1,s))}}wrap(e){for(;e<-180;)e+=360;for(;e>180;)e-=360;return e}},os=100,as=50;function Ru(t,e){return e[0]-t[0]}function Gi(t){return t[1]-t[0]+1}function st(t,e){return t[1]>=t[0]&&t[1]<e}function ss(t,e){if(t[0]>t[1])return[null,null];let r=Gi(t);if(e){if(r===2)return[t,null];let i=Math.floor(r/2);return[[t[0],t[0]+i],[t[0]+i,t[1]]]}if(r===1)return[t,null];let n=Math.floor(r/2)-1;return[[t[0],t[0]+n],[t[0]+n+1,t[1]]]}function ls(t,e){if(!st(e,t.length))return[1/0,1/0,-1/0,-1/0];let r=[1/0,1/0,-1/0,-1/0];for(let n=e[0];n<=e[1];++n)pn(r,t[n]);return r}function us(t){let e=[1/0,1/0,-1/0,-1/0];for(let r of t)for(let n of r)pn(e,n);return e}function yu(t){return t[0]!==-1/0&&t[1]!==-1/0&&t[2]!==1/0&&t[3]!==1/0}function hs(t,e,r){if(!yu(t)||!yu(e))return NaN;let n=0,i=0;return t[2]<e[0]&&(n=e[0]-t[2]),t[0]>e[2]&&(n=t[0]-e[2]),t[1]>e[3]&&(i=t[1]-e[3]),t[3]<e[1]&&(i=e[1]-t[3]),r.distance([0,0],[n,i])}function zt(t,e,r){let n=r.pointOnLine(e,t);return r.distance(t,n.point)}function ds(t,e,r,n,i){let o=Math.min(zt(t,[r,n],i),zt(e,[r,n],i)),a=Math.min(zt(r,[t,e],i),zt(n,[t,e],i));return Math.min(o,a)}function Ch(t,e,r,n,i){if(!(st(e,t.length)&&st(n,r.length)))return 1/0;let a=1/0;for(let s=e[0];s<e[1];++s){let l=t[s],u=t[s+1];for(let c=n[0];c<n[1];++c){let p=r[c],f=r[c+1];if(Yi(l,u,p,f))return 0;a=Math.min(a,ds(l,u,p,f,i))}}return a}function kh(t,e,r,n,i){if(!(st(e,t.length)&&st(n,r.length)))return NaN;let a=1/0;for(let s=e[0];s<=e[1];++s)for(let l=n[0];l<=n[1];++l)if(a=Math.min(a,i.distance(t[s],r[l])),a===0)return a;return a}function Mh(t,e,r){if(xr(t,e,!0))return 0;let n=1/0;for(let i of e){let o=i[0],a=i[i.length-1];if(o!==a&&(n=Math.min(n,zt(t,[a,o],r)),n===0))return n;let s=r.pointOnLine(i,t);if(n=Math.min(n,r.distance(t,s.point)),n===0)return n}return n}function Eh(t,e,r,n){if(!st(e,t.length))return NaN;for(let o=e[0];o<=e[1];++o)if(xr(t[o],r,!0))return 0;let i=1/0;for(let o=e[0];o<e[1];++o){let a=t[o],s=t[o+1];for(let l of r)for(let u=0,c=l.length,p=c-1;u<c;p=u++){let f=l[p],y=l[u];if(Yi(a,s,f,y))return 0;i=Math.min(i,ds(a,s,f,y,n))}}return i}function mu(t,e){for(let r of t)for(let n of r)if(xr(n,e,!0))return!0;return!1}function Fh(t,e,r,n=1/0){let i=us(t),o=us(e);if(n!==1/0&&hs(i,o,r)>=n)return n;if(rn(i,o)){if(mu(t,e))return 0}else if(mu(e,t))return 0;let a=1/0;for(let s of t)for(let l=0,u=s.length,c=u-1;l<u;c=l++){let p=s[c],f=s[l];for(let y of e)for(let m=0,h=y.length,d=h-1;m<h;d=m++){let g=y[d],b=y[m];if(Yi(p,f,g,b))return 0;a=Math.min(a,ds(p,f,g,b,r))}}return a}function hu(t,e,r,n,i,o){if(!o)return;let a=hs(ls(n,o),i,r);a<e&&t.push([a,o,[0,0]])}function Fi(t,e,r,n,i,o,a){if(!o||!a)return;let s=hs(ls(n,o),ls(i,a),r);s<e&&t.push([s,o,a])}function qi(t,e,r,n,i=1/0){let o=Math.min(n.distance(t[0],r[0][0]),i);if(o===0)return o;let a=new $i([[0,[0,t.length-1],[0,0]]],Ru),s=us(r);for(;a.length>0;){let l=a.pop();if(l[0]>=o)continue;let u=l[1],c=e?as:os;if(Gi(u)<=c){if(!st(u,t.length))return NaN;if(e){let p=Eh(t,u,r,n);if(isNaN(p)||p===0)return p;o=Math.min(o,p)}else for(let p=u[0];p<=u[1];++p){let f=Mh(t[p],r,n);if(o=Math.min(o,f),o===0)return 0}}else{let p=ss(u,e);hu(a,o,n,t,s,p[0]),hu(a,o,n,t,s,p[1])}}return o}function ji(t,e,r,n,i,o=1/0){let a=Math.min(o,i.distance(t[0],r[0]));if(a===0)return a;let s=new $i([[0,[0,t.length-1],[0,r.length-1]]],Ru);for(;s.length>0;){let l=s.pop();if(l[0]>=a)continue;let u=l[1],c=l[2],p=e?as:os,f=n?as:os;if(Gi(u)<=p&&Gi(c)<=f){if(!st(u,t.length)&&st(c,r.length))return NaN;let y;if(e&&n)y=Ch(t,u,r,c,i),a=Math.min(a,y);else if(e&&!n){let m=t.slice(u[0],u[1]+1);for(let h=c[0];h<=c[1];++h)if(y=zt(r[h],m,i),a=Math.min(a,y),a===0)return a}else if(!e&&n){let m=r.slice(c[0],c[1]+1);for(let h=u[0];h<=u[1];++h)if(y=zt(t[h],m,i),a=Math.min(a,y),a===0)return a}else y=kh(t,u,r,c,i),a=Math.min(a,y)}else{let y=ss(u,e),m=ss(c,n);Fi(s,a,i,t,r,y[0],m[0]),Fi(s,a,i,t,r,y[0],m[1]),Fi(s,a,i,t,r,y[1],m[0]),Fi(s,a,i,t,r,y[1],m[1])}}return a}function Lh(t,e){let r=t.geometry(),n=r.flat().map(a=>ys([a.x,a.y],t.canonical));if(r.length===0)return NaN;let i=new on(n[0][1]),o=1/0;for(let a of e){switch(a.type){case"Point":o=Math.min(o,ji(n,!1,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,ji(n,!1,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,qi(n,!1,a.coordinates,i,o));break}if(o===0)return o}return o}function Dh(t,e){let r=t.geometry(),n=r.flat().map(a=>ys([a.x,a.y],t.canonical));if(r.length===0)return NaN;let i=new on(n[0][1]),o=1/0;for(let a of e){switch(a.type){case"Point":o=Math.min(o,ji(n,!0,[a.coordinates],!1,i,o));break;case"LineString":o=Math.min(o,ji(n,!0,a.coordinates,!0,i,o));break;case"Polygon":o=Math.min(o,qi(n,!0,a.coordinates,i,o));break}if(o===0)return o}return o}function Vh(t,e){let r=t.geometry();if(r.length===0||r[0].length===0)return NaN;let n=Ah(r,0).map(a=>a.map(s=>s.map(l=>ys([l.x,l.y],t.canonical)))),i=new on(n[0][0][0][1]),o=1/0;for(let a of e)for(let s of n){switch(a.type){case"Point":o=Math.min(o,qi([a.coordinates],!1,s,i,o));break;case"LineString":o=Math.min(o,qi(a.coordinates,!0,s,i,o));break;case"Polygon":o=Math.min(o,Fh(s,a.coordinates,i,o));break}if(o===0)return o}return o}function Ja(t){return t.type==="MultiPolygon"?t.coordinates.map(e=>({type:"Polygon",coordinates:e})):t.type==="MultiLineString"?t.coordinates.map(e=>({type:"LineString",coordinates:e})):t.type==="MultiPoint"?t.coordinates.map(e=>({type:"Point",coordinates:e})):[t]}var an=class t{constructor(e,r){this.type=L,this.geojson=e,this.geometries=r}static parse(e,r){if(e.length!==2)return r.error("'distance' expression requires exactly one argument, but found ".concat(e.length-1," instead."));if(en(e[1])){let n=e[1];if(n.type==="FeatureCollection")return new t(n,n.features.map(i=>Ja(i.geometry)).flat());if(n.type==="Feature")return new t(n,Ja(n.geometry));if("type"in n&&"coordinates"in n)return new t(n,Ja(n))}return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.")}evaluate(e){if(e.geometry()!=null&&e.canonicalID()!=null){if(e.geometryType()==="Point")return Lh(e,this.geometries);if(e.geometryType()==="LineString")return Dh(e,this.geometries);if(e.geometryType()==="Polygon")return Vh(e,this.geometries)}return NaN}eachChild(){}outputDefined(){return!0}},Gt={"==":rh,"!=":nh,">":oh,"<":ih,">=":sh,"<=":ah,array:je,at:Xa,boolean:je,case:es,coalesce:Ni,collator:Ui,format:tn,image:ns,in:Ka,"index-of":Ya,interpolate:Je,"interpolate-hcl":Je,"interpolate-lab":Je,length:is,let:zi,literal:mt,match:Qa,number:je,"number-format":rs,object:je,slice:ts,step:yr,string:je,"to-boolean":yt,"to-color":yt,"to-number":yt,"to-string":yt,var:Ri,within:nn,distance:an},Ke=class t{constructor(e,r,n,i){this.name=e,this.type=r,this._evaluate=n,this.args=i}evaluate(e){return this._evaluate(e,this.args)}eachChild(e){this.args.forEach(e)}outputDefined(){return!1}static parse(e,r){let n=e[0],i=t.definitions[n];if(!i)return r.error('Unknown expression "'.concat(n,'". If you wanted a literal array, use ["literal", [...]].'),0);let o=Array.isArray(i)?i[0]:i.type,a=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=a.filter(([u])=>!Array.isArray(u)||u.length===e.length-1),l=null;for(let[u,c]of s){l=new Bi(r.registry,Ji,r.path,null,r.scope);let p=[],f=!1;for(let y=1;y<e.length;y++){let m=e[y],h=Array.isArray(u)?u[y-1]:u.type,d=l.parse(m,1+p.length,h);if(!d){f=!0;break}p.push(d)}if(!f){if(Array.isArray(u)&&u.length!==p.length){l.error("Expected ".concat(u.length," arguments, but found ").concat(p.length," instead."));continue}for(let y=0;y<p.length;y++){let m=Array.isArray(u)?u[y]:u.type,h=p[y];l.concat(y+1).checkSubtype(m,h.type)}if(l.errors.length===0)return new t(n,o,c,p)}}if(s.length===1)r.errors.push(...l.errors);else{let c=(s.length?s:a).map(([f])=>zh(f)).join(" | "),p=[];for(let f=1;f<e.length;f++){let y=r.parse(e[f],1+p.length);if(!y)return null;p.push(te(y.type))}r.error("Expected arguments of type ".concat(c,", but found (").concat(p.join(", "),") instead."))}return null}static register(e,r){t.definitions=r;for(let n in r)e[n]=t}};function du(t,[e,r,n,i]){e=e.evaluate(t),r=r.evaluate(t),n=n.evaluate(t);let o=i?i.evaluate(t):1,a=Eu(e,r,n,o);if(a)throw new ie(a);return new W(e/255,r/255,n/255,o,!1)}function gu(t,e){return t in e}function Za(t,e){let r=e[t];return typeof r>"u"?null:r}function Bh(t,e,r,n){for(;r<=n;){let i=r+n>>1;if(e[i]===t)return!0;e[i]>t?n=i-1:r=i+1}return!1}function Bt(t){return{type:t}}Ke.register(Gt,{error:[_m,[G],(t,[e])=>{throw new ie(e.evaluate(t))}],typeof:[G,[$],(t,[e])=>te(ue(e.evaluate(t)))],"to-rgba":[Ee(L,4),[Re],(t,[e])=>{let[r,n,i,o]=e.evaluate(t).rgb;return[r*255,n*255,i*255,o]}],rgb:[Re,[L,L,L],du],rgba:[Re,[L,L,L,L],du],has:{type:U,overloads:[[[G],(t,[e])=>gu(e.evaluate(t),t.properties())],[[G,cr],(t,[e,r])=>gu(e.evaluate(t),r.evaluate(t))]]},get:{type:$,overloads:[[[G],(t,[e])=>Za(e.evaluate(t),t.properties())],[[G,cr],(t,[e,r])=>Za(e.evaluate(t),r.evaluate(t))]]},"feature-state":[$,[G],(t,[e])=>Za(e.evaluate(t),t.featureState||{})],properties:[cr,[],t=>t.properties()],"geometry-type":[G,[],t=>t.geometryType()],id:[$,[],t=>t.id()],zoom:[L,[],t=>t.globals.zoom],"heatmap-density":[L,[],t=>t.globals.heatmapDensity||0],"line-progress":[L,[],t=>t.globals.lineProgress||0],accumulated:[$,[],t=>t.globals.accumulated===void 0?null:t.globals.accumulated],"+":[L,Bt(L),(t,e)=>{let r=0;for(let n of e)r+=n.evaluate(t);return r}],"*":[L,Bt(L),(t,e)=>{let r=1;for(let n of e)r*=n.evaluate(t);return r}],"-":{type:L,overloads:[[[L,L],(t,[e,r])=>e.evaluate(t)-r.evaluate(t)],[[L],(t,[e])=>-e.evaluate(t)]]},"/":[L,[L,L],(t,[e,r])=>e.evaluate(t)/r.evaluate(t)],"%":[L,[L,L],(t,[e,r])=>e.evaluate(t)%r.evaluate(t)],ln2:[L,[],()=>Math.LN2],pi:[L,[],()=>Math.PI],e:[L,[],()=>Math.E],"^":[L,[L,L],(t,[e,r])=>Math.pow(e.evaluate(t),r.evaluate(t))],sqrt:[L,[L],(t,[e])=>Math.sqrt(e.evaluate(t))],log10:[L,[L],(t,[e])=>Math.log(e.evaluate(t))/Math.LN10],ln:[L,[L],(t,[e])=>Math.log(e.evaluate(t))],log2:[L,[L],(t,[e])=>Math.log(e.evaluate(t))/Math.LN2],sin:[L,[L],(t,[e])=>Math.sin(e.evaluate(t))],cos:[L,[L],(t,[e])=>Math.cos(e.evaluate(t))],tan:[L,[L],(t,[e])=>Math.tan(e.evaluate(t))],asin:[L,[L],(t,[e])=>Math.asin(e.evaluate(t))],acos:[L,[L],(t,[e])=>Math.acos(e.evaluate(t))],atan:[L,[L],(t,[e])=>Math.atan(e.evaluate(t))],min:[L,Bt(L),(t,e)=>Math.min(...e.map(r=>r.evaluate(t)))],max:[L,Bt(L),(t,e)=>Math.max(...e.map(r=>r.evaluate(t)))],abs:[L,[L],(t,[e])=>Math.abs(e.evaluate(t))],round:[L,[L],(t,[e])=>{let r=e.evaluate(t);return r<0?-Math.round(-r):Math.round(r)}],floor:[L,[L],(t,[e])=>Math.floor(e.evaluate(t))],ceil:[L,[L],(t,[e])=>Math.ceil(e.evaluate(t))],"filter-==":[U,[G,$],(t,[e,r])=>t.properties()[e.value]===r.value],"filter-id-==":[U,[$],(t,[e])=>t.id()===e.value],"filter-type-==":[U,[G],(t,[e])=>t.geometryType()===e.value],"filter-<":[U,[G,$],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<i}],"filter-id-<":[U,[$],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r<n}],"filter->":[U,[G,$],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>i}],"filter-id->":[U,[$],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r>n}],"filter-<=":[U,[G,$],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n<=i}],"filter-id-<=":[U,[$],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r<=n}],"filter->=":[U,[G,$],(t,[e,r])=>{let n=t.properties()[e.value],i=r.value;return typeof n==typeof i&&n>=i}],"filter-id->=":[U,[$],(t,[e])=>{let r=t.id(),n=e.value;return typeof r==typeof n&&r>=n}],"filter-has":[U,[$],(t,[e])=>e.value in t.properties()],"filter-has-id":[U,[],t=>t.id()!==null&&t.id()!==void 0],"filter-type-in":[U,[Ee(G)],(t,[e])=>e.value.indexOf(t.geometryType())>=0],"filter-id-in":[U,[Ee($)],(t,[e])=>e.value.indexOf(t.id())>=0],"filter-in-small":[U,[G,Ee($)],(t,[e,r])=>r.value.indexOf(t.properties()[e.value])>=0],"filter-in-large":[U,[G,Ee($)],(t,[e,r])=>Bh(t.properties()[e.value],r.value,0,r.value.length-1)],all:{type:U,overloads:[[[U,U],(t,[e,r])=>e.evaluate(t)&&r.evaluate(t)],[Bt(U),(t,e)=>{for(let r of e)if(!r.evaluate(t))return!1;return!0}]]},any:{type:U,overloads:[[[U,U],(t,[e,r])=>e.evaluate(t)||r.evaluate(t)],[Bt(U),(t,e)=>{for(let r of e)if(r.evaluate(t))return!0;return!1}]]},"!":[U,[U],(t,[e])=>!e.evaluate(t)],"is-supported-script":[U,[G],(t,[e])=>{let r=t.globals&&t.globals.isSupportedScript;return r?r(e.evaluate(t)):!0}],upcase:[G,[G],(t,[e])=>e.evaluate(t).toUpperCase()],downcase:[G,[G],(t,[e])=>e.evaluate(t).toLowerCase()],concat:[G,Bt($),(t,e)=>e.map(r=>Hr(r.evaluate(t))).join("")],"resolved-locale":[G,[Wi],(t,[e])=>e.evaluate(t).resolvedLocale()]});function zh(t){return Array.isArray(t)?"(".concat(t.map(te).join(", "),")"):"(".concat(te(t.type),"...)")}function Ji(t){if(t instanceof Ri)return Ji(t.boundExpression);if(t instanceof Ke&&t.name==="error")return!1;if(t instanceof Ui)return!1;if(t instanceof nn)return!1;if(t instanceof an)return!1;let e=t instanceof yt||t instanceof je,r=!0;return t.eachChild(n=>{e?r=r&&Ji(n):r=r&&n instanceof mt}),r?Qi(t)&&eo(t,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"]):!1}function Qi(t){if(t instanceof Ke){if(t.name==="get"&&t.args.length===1)return!1;if(t.name==="feature-state")return!1;if(t.name==="has"&&t.args.length===1)return!1;if(t.name==="properties"||t.name==="geometry-type"||t.name==="id")return!1;if(/^filter-/.test(t.name))return!1}if(t instanceof nn||t instanceof an)return!1;let e=!0;return t.eachChild(r=>{e&&!Qi(r)&&(e=!1)}),e}function sn(t){if(t instanceof Ke&&t.name==="feature-state")return!1;let e=!0;return t.eachChild(r=>{e&&!sn(r)&&(e=!1)}),e}function eo(t,e){if(t instanceof Ke&&e.indexOf(t.name)>=0)return!1;let r=!0;return t.eachChild(n=>{r&&!eo(n,e)&&(r=!1)}),r}function cs(t){return{result:"success",value:t}}function ur(t){return{result:"error",value:t}}function ht(t){return t["property-type"]==="data-driven"||t["property-type"]==="cross-faded-data-driven"}function Ou(t){return!!t.expression&&t.expression.parameters.indexOf("zoom")>-1}function gs(t){return!!t.expression&&t.expression.interpolated}function j(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":t===null?"null":typeof t}function to(t){return typeof t=="object"&&t!==null&&!Array.isArray(t)}function Rh(t){return t}function Nu(t,e){let r=e.type==="color",n=t.stops&&typeof t.stops[0][0]=="object",i=n||t.property!==void 0,o=n||!i,a=t.type||(gs(e)?"exponential":"interval");if(r||e.type==="padding"){let c=r?W.parse:Ze.parse;t=fr({},t),t.stops&&(t.stops=t.stops.map(p=>[p[0],c(p[1])])),t.default?t.default=c(t.default):t.default=c(e.default)}if(t.colorSpace&&!Um(t.colorSpace))throw new Error('Unknown color space: "'.concat(t.colorSpace,'"'));let s,l,u;if(a==="exponential")s=xu;else if(a==="interval")s=Nh;else if(a==="categorical"){s=Oh,l=Object.create(null);for(let c of t.stops)l[c[0]]=c[1];u=typeof t.stops[0][0]}else if(a==="identity")s=Uh;else throw new Error('Unknown function type "'.concat(a,'"'));if(n){let c={},p=[];for(let m=0;m<t.stops.length;m++){let h=t.stops[m],d=h[0].zoom;c[d]===void 0&&(c[d]={zoom:d,type:t.type,property:t.property,default:t.default,stops:[]},p.push(d)),c[d].stops.push([h[0].value,h[1]])}let f=[];for(let m of p)f.push([c[m].zoom,Nu(c[m],e)]);let y={name:"linear"};return{kind:"composite",interpolationType:y,interpolationFactor:Je.interpolationFactor.bind(void 0,y),zoomStops:f.map(m=>m[0]),evaluate({zoom:m},h){return xu({stops:f,base:t.base},e,m).evaluate(m,h)}}}else if(o){let c=a==="exponential"?{name:"exponential",base:t.base!==void 0?t.base:1}:null;return{kind:"camera",interpolationType:c,interpolationFactor:Je.interpolationFactor.bind(void 0,c),zoomStops:t.stops.map(p=>p[0]),evaluate:({zoom:p})=>s(t,e,p,l,u)}}else return{kind:"source",evaluate(c,p){let f=p&&p.properties?p.properties[t.property]:void 0;return f===void 0?fn(t.default,e.default):s(t,e,f,l,u)}}}function fn(t,e,r){if(t!==void 0)return t;if(e!==void 0)return e;if(r!==void 0)return r}function Oh(t,e,r,n,i){let o=typeof r===i?n[r]:void 0;return fn(o,t.default,e.default)}function Nh(t,e,r){if(j(r)!=="number")return fn(t.default,e.default);let n=t.stops.length;if(n===1||r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[n-1][0])return t.stops[n-1][1];let i=Ki(t.stops.map(o=>o[0]),r);return t.stops[i][1]}function xu(t,e,r){let n=t.base!==void 0?t.base:1;if(j(r)!=="number")return fn(t.default,e.default);let i=t.stops.length;if(i===1||r<=t.stops[0][0])return t.stops[0][1];if(r>=t.stops[i-1][0])return t.stops[i-1][1];let o=Ki(t.stops.map(c=>c[0]),r),a=$h(r,n,t.stops[o][0],t.stops[o+1][0]),s=t.stops[o][1],l=t.stops[o+1][1],u=Oe[e.type]||Rh;return typeof s.evaluate=="function"?{evaluate(...c){let p=s.evaluate.apply(void 0,c),f=l.evaluate.apply(void 0,c);if(!(p===void 0||f===void 0))return u(p,f,a,t.colorSpace)}}:u(s,l,a,t.colorSpace)}function Uh(t,e,r){switch(e.type){case"color":r=W.parse(r);break;case"formatted":r=Fe.fromString(r.toString());break;case"resolvedImage":r=Te.fromString(r.toString());break;case"padding":r=Ze.parse(r);break;default:j(r)!==e.type&&(e.type!=="enum"||!e.values[r])&&(r=void 0)}return fn(r,t.default,e.default)}function $h(t,e,r,n){let i=n-r,o=t-r;return i===0?0:e===1?o/i:(Math.pow(e,o)-1)/(Math.pow(e,i)-1)}var Nt=class{constructor(e,r){this.expression=e,this._warningHistory={},this._evaluator=new Vi,this._defaultValue=r?qh(r):null,this._enumValues=r&&r.type==="enum"?r.values:null}evaluateWithoutErrorHandling(e,r,n,i,o,a){return this._evaluator.globals=e,this._evaluator.feature=r,this._evaluator.featureState=n,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a,this.expression.evaluate(this._evaluator)}evaluate(e,r,n,i,o,a){this._evaluator.globals=e,this._evaluator.feature=r||null,this._evaluator.featureState=n||null,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a||null;try{let s=this.expression.evaluate(this._evaluator);if(s==null||typeof s=="number"&&s!==s)return this._defaultValue;if(this._enumValues&&!(s in this._enumValues))throw new ie("Expected value to be one of ".concat(Object.keys(this._enumValues).map(l=>JSON.stringify(l)).join(", "),", but found ").concat(JSON.stringify(s)," instead."));return s}catch(s){return this._warningHistory[s.message]||(this._warningHistory[s.message]=!0,typeof console<"u"&&console.warn(s.message)),this._defaultValue}}};function qt(t){return Array.isArray(t)&&t.length>0&&typeof t[0]=="string"&&t[0]in Gt}function jt(t,e){let r=new Bi(Gt,Ji,[],e?Gh(e):void 0),n=r.parse(t,void 0,void 0,void 0,e&&e.type==="string"?{typeAnnotation:"coerce"}:void 0);return n?cs(new Nt(n,e)):ur(r.errors)}var dt=class{constructor(e,r){this.kind=e,this._styleExpression=r,this.isStateDependent=e!=="constant"&&!sn(r.expression)}evaluateWithoutErrorHandling(e,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(e,r,n,i,o,a)}evaluate(e,r,n,i,o,a){return this._styleExpression.evaluate(e,r,n,i,o,a)}},gt=class{constructor(e,r,n,i){this.kind=e,this.zoomStops=n,this._styleExpression=r,this.isStateDependent=e!=="camera"&&!sn(r.expression),this.interpolationType=i}evaluateWithoutErrorHandling(e,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(e,r,n,i,o,a)}evaluate(e,r,n,i,o,a){return this._styleExpression.evaluate(e,r,n,i,o,a)}interpolationFactor(e,r,n){return this.interpolationType?Je.interpolationFactor(this.interpolationType,e,r,n):0}};function Uu(t,e){let r=jt(t,e);if(r.result==="error")return r;let n=r.value.expression,i=Qi(n);if(!i&&!ht(e))return ur([new Be("","data expressions not supported")]);let o=eo(n,["zoom"]);if(!o&&!Ou(e))return ur([new Be("","zoom expressions not supported")]);let a=Di(n);if(!a&&!o)return ur([new Be("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);if(a instanceof Be)return ur([a]);if(a instanceof Je&&!gs(e))return ur([new Be("",'"interpolate" expressions cannot be used with this property')]);if(!a)return cs(i?new dt("constant",r.value):new dt("source",r.value));let s=a instanceof Je?a.interpolation:void 0;return cs(i?new gt("camera",r.value,a.labels,s):new gt("composite",r.value,a.labels,s))}var ln=class t{constructor(e,r){this._parameters=e,this._specification=r,fr(this,Nu(this._parameters,this._specification))}static deserialize(e){return new t(e._parameters,e._specification)}static serialize(e){return{_parameters:e._parameters,_specification:e._specification}}};function $u(t,e){if(to(t))return new ln(t,e);if(qt(t)){let r=Uu(t,e);if(r.result==="error")throw new Error(r.value.map(n=>"".concat(n.key,": ").concat(n.message)).join(", "));return r.value}else{let r=t;return e.type==="color"&&typeof t=="string"?r=W.parse(t):e.type==="padding"&&(typeof t=="number"||Array.isArray(t))?r=Ze.parse(t):e.type==="variableAnchorOffsetCollection"&&Array.isArray(t)&&(r=Ne.parse(t)),{kind:"constant",evaluate:()=>r}}}function Di(t){let e=null;if(t instanceof zi)e=Di(t.result);else if(t instanceof Ni){for(let r of t.args)if(e=Di(r),e)break}else(t instanceof yr||t instanceof Je)&&t.input instanceof Ke&&t.input.name==="zoom"&&(e=t);return e instanceof Be||t.eachChild(r=>{let n=Di(r);n instanceof Be?e=n:!e&&n?e=new Be("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'):e&&n&&e!==n&&(e=new Be("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))}),e}function Gh(t){let e={color:Re,string:G,number:L,enum:G,boolean:U,formatted:dr,padding:Hi,resolvedImage:cn,variableAnchorOffsetCollection:Xi};return t.type==="array"?Ee(e[t.value]||$,t.length):e[t.type]}function qh(t){return t.type==="color"&&to(t.default)?new W(0,0,0,0):t.type==="color"?W.parse(t.default)||null:t.type==="padding"?Ze.parse(t.default)||null:t.type==="variableAnchorOffsetCollection"?Ne.parse(t.default)||null:t.default===void 0?null:t.default}function xs(t){if(t===!0||t===!1)return!0;if(!Array.isArray(t)||t.length===0)return!1;switch(t[0]){case"has":return t.length>=2&&t[1]!=="$id"&&t[1]!=="$type";case"in":return t.length>=3&&(typeof t[1]!="string"||Array.isArray(t[2]));case"!in":case"!has":case"none":return!1;case"==":case"!=":case">":case">=":case"<":case"<=":return t.length!==3||Array.isArray(t[1])||Array.isArray(t[2]);case"any":case"all":for(let e of t.slice(1))if(!xs(e)&&typeof e!="boolean")return!1;return!0;default:return!0}}var jh={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function yn(t){if(t==null)return{filter:()=>!0,needGeometry:!1};xs(t)||(t=Zi(t));let e=jt(t,jh);if(e.result==="error")throw new Error(e.value.map(r=>"".concat(r.key,": ").concat(r.message)).join(", "));{let r=Gu(t);return{filter:(n,i,o)=>e.value.evaluate(n,i,{},o),needGeometry:r}}}function Jh(t,e){return t<e?-1:t>e?1:0}function Gu(t){if(!Array.isArray(t))return!1;if(t[0]==="within"||t[0]==="distance")return!0;for(let e=1;e<t.length;e++)if(Gu(t[e]))return!0;return!1}function Zi(t){if(!t)return!0;let e=t[0];return t.length<=1?e!=="any":e==="=="?Wa(t[1],t[2],"=="):e==="!="?Li(Wa(t[1],t[2],"==")):e==="<"||e===">"||e==="<="||e===">="?Wa(t[1],t[2],e):e==="any"?Zh(t.slice(1)):e==="all"?["all"].concat(t.slice(1).map(Zi)):e==="none"?["all"].concat(t.slice(1).map(Zi).map(Li)):e==="in"?bu(t[1],t.slice(2)):e==="!in"?Li(bu(t[1],t.slice(2))):e==="has"?vu(t[1]):e==="!has"?Li(vu(t[1])):!0}function Wa(t,e,r){switch(t){case"$type":return["filter-type-".concat(r),e];case"$id":return["filter-id-".concat(r),e];default:return["filter-".concat(r),t,e]}}function Zh(t){return["any"].concat(t.map(Zi))}function bu(t,e){if(e.length===0)return!1;switch(t){case"$type":return["filter-type-in",["literal",e]];case"$id":return["filter-id-in",["literal",e]];default:return e.length>200&&!e.some(r=>typeof r!=typeof e[0])?["filter-in-large",t,["literal",e.sort(Jh)]]:["filter-in-small",t,["literal",e]]}}function vu(t){switch(t){case"$type":return!0;case"$id":return["filter-has-id"];default:return["filter-has",t]}}function Li(t){return["!",t]}function ps(t){let e=typeof t;if(e==="number"||e==="boolean"||e==="string"||t===void 0||t===null)return JSON.stringify(t);if(Array.isArray(t)){let i="[";for(let o of t)i+="".concat(ps(o),",");return"".concat(i,"]")}let r=Object.keys(t).sort(),n="{";for(let i=0;i<r.length;i++)n+="".concat(JSON.stringify(r[i]),":").concat(ps(t[r[i]]),",");return"".concat(n,"}")}function Wh(t){let e="";for(let r of Am)e+="/".concat(ps(t[r]));return e}function qu(t,e){let r={};for(let i=0;i<t.length;i++){let o=e&&e[t[i].id]||Wh(t[i]);e&&(e[t[i].id]=o);let a=r[o];a||(a=r[o]=[]),a.push(t[i])}let n=[];for(let i in r)n.push(r[i]);return n}function ju(t){let e=t.key,r=t.value;return r?[new M(e,r,"constants have been deprecated as of v8")]:[]}function ae(t){return t instanceof Number||t instanceof String||t instanceof Boolean?t.valueOf():t}function Ut(t){if(Array.isArray(t))return t.map(Ut);if(t instanceof Object&&!(t instanceof Number||t instanceof String||t instanceof Boolean)){let e={};for(let r in t)e[r]=Ut(t[r]);return e}return ae(t)}function ze(t){let e=t.key,r=t.value,n=t.valueSpec||{},i=t.objectElementValidators||{},o=t.style,a=t.styleSpec,s=t.validateSpec,l=[],u=j(r);if(u!=="object")return[new M(e,r,"object expected, ".concat(u," found"))];for(let c in r){let p=c.split(".")[0],f=n[p]||n["*"],y;if(i[p])y=i[p];else if(n[p])y=s;else if(i["*"])y=i["*"];else if(n["*"])y=s;else{l.push(new M(e,r[c],'unknown property "'.concat(c,'"')));continue}l=l.concat(y({key:(e&&"".concat(e,"."))+c,value:r[c],valueSpec:f,style:o,styleSpec:a,object:r,objectKey:c,validateSpec:s},r))}for(let c in n)i[c]||n[c].required&&n[c].default===void 0&&r[c]===void 0&&l.push(new M(e,r,'missing required property "'.concat(c,'"')));return l}function bs(t){let e=t.value,r=t.valueSpec,n=t.validateSpec,i=t.style,o=t.styleSpec,a=t.key,s=t.arrayElementValidator||n;if(j(e)!=="array")return[new M(a,e,"array expected, ".concat(j(e)," found"))];if(r.length&&e.length!==r.length)return[new M(a,e,"array length ".concat(r.length," expected, length ").concat(e.length," found"))];if(r["min-length"]&&e.length<r["min-length"])return[new M(a,e,"array length at least ".concat(r["min-length"]," expected, length ").concat(e.length," found"))];let l={type:r.value,values:r.values};o.$version<7&&(l.function=r.function),j(r.value)==="object"&&(l=r.value);let u=[];for(let c=0;c<e.length;c++)u=u.concat(s({array:e,arrayIndex:c,value:e[c],valueSpec:l,validateSpec:t.validateSpec,style:i,styleSpec:o,key:"".concat(a,"[").concat(c,"]")}));return u}function vs(t){let e=t.key,r=t.value,n=t.valueSpec,i=j(r);return i==="number"&&r!==r&&(i="NaN"),i!=="number"?[new M(e,r,"number expected, ".concat(i," found"))]:"minimum"in n&&r<n.minimum?[new M(e,r,"".concat(r," is less than the minimum value ").concat(n.minimum))]:"maximum"in n&&r>n.maximum?[new M(e,r,"".concat(r," is greater than the maximum value ").concat(n.maximum))]:[]}function Ju(t){let e=t.valueSpec,r=ae(t.value.type),n,i={},o,a,s=r!=="categorical"&&t.value.property===void 0,l=!s,u=j(t.value.stops)==="array"&&j(t.value.stops[0])==="array"&&j(t.value.stops[0][0])==="object",c=ze({key:t.key,value:t.value,valueSpec:t.styleSpec.function,validateSpec:t.validateSpec,style:t.style,styleSpec:t.styleSpec,objectElementValidators:{stops:p,default:m}});return r==="identity"&&s&&c.push(new M(t.key,t.value,'missing required property "property"')),r!=="identity"&&!t.value.stops&&c.push(new M(t.key,t.value,'missing required property "stops"')),r==="exponential"&&t.valueSpec.expression&&!gs(t.valueSpec)&&c.push(new M(t.key,t.value,"exponential functions not supported")),t.styleSpec.$version>=8&&(l&&!ht(t.valueSpec)?c.push(new M(t.key,t.value,"property functions not supported")):s&&!Ou(t.valueSpec)&&c.push(new M(t.key,t.value,"zoom functions not supported"))),(r==="categorical"||u)&&t.value.property===void 0&&c.push(new M(t.key,t.value,'"property" property is required')),c;function p(h){if(r==="identity")return[new M(h.key,h.value,'identity function may not have a "stops" property')];let d=[],g=h.value;return d=d.concat(bs({key:h.key,value:g,valueSpec:h.valueSpec,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,arrayElementValidator:f})),j(g)==="array"&&g.length===0&&d.push(new M(h.key,g,"array must have at least one stop")),d}function f(h){let d=[],g=h.value,b=h.key;if(j(g)!=="array")return[new M(b,g,"array expected, ".concat(j(g)," found"))];if(g.length!==2)return[new M(b,g,"array length 2 expected, length ".concat(g.length," found"))];if(u){if(j(g[0])!=="object")return[new M(b,g,"object expected, ".concat(j(g[0])," found"))];if(g[0].zoom===void 0)return[new M(b,g,"object stop key must have zoom")];if(g[0].value===void 0)return[new M(b,g,"object stop key must have value")];if(a&&a>ae(g[0].zoom))return[new M(b,g[0].zoom,"stop zoom values must appear in ascending order")];ae(g[0].zoom)!==a&&(a=ae(g[0].zoom),o=void 0,i={}),d=d.concat(ze({key:"".concat(b,"[0]"),value:g[0],valueSpec:{zoom:{}},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,objectElementValidators:{zoom:vs,value:y}}))}else d=d.concat(y({key:"".concat(b,"[0]"),value:g[0],valueSpec:{},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec},g));return qt(Ut(g[1]))?d.concat([new M("".concat(b,"[1]"),g[1],"expressions are not allowed in function stops.")]):d.concat(h.validateSpec({key:"".concat(b,"[1]"),value:g[1],valueSpec:e,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec}))}function y(h,d){let g=j(h.value),b=ae(h.value),x=h.value!==null?h.value:d;if(!n)n=g;else if(g!==n)return[new M(h.key,x,"".concat(g," stop domain type must match previous stop domain type ").concat(n))];if(g!=="number"&&g!=="string"&&g!=="boolean")return[new M(h.key,x,"stop domain value must be a number, string, or boolean")];if(g!=="number"&&r!=="categorical"){let v="number expected, ".concat(g," found");return ht(e)&&r===void 0&&(v+='\\nIf you intended to use a categorical function, specify \`"type": "categorical"\`.'),[new M(h.key,x,v)]}return r==="categorical"&&g==="number"&&(!isFinite(b)||Math.floor(b)!==b)?[new M(h.key,x,"integer expected, found ".concat(b))]:r!=="categorical"&&g==="number"&&o!==void 0&&b<o?[new M(h.key,x,"stop domain values must appear in ascending order")]:(o=b,r==="categorical"&&b in i?[new M(h.key,x,"stop domain values must be unique")]:(i[b]=!0,[]))}function m(h){return h.validateSpec({key:h.key,value:h.value,valueSpec:e,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec})}}function mr(t){let e=(t.expressionContext==="property"?Uu:jt)(Ut(t.value),t.valueSpec);if(e.result==="error")return e.value.map(n=>new M("".concat(t.key).concat(n.key),t.value,n.message));let r=e.value.expression||e.value._styleExpression.expression;if(t.expressionContext==="property"&&t.propertyKey==="text-font"&&!r.outputDefined())return[new M(t.key,t.value,'Invalid data expression for "'.concat(t.propertyKey,'". Output values must be contained as literals within the expression.'))];if(t.expressionContext==="property"&&t.propertyType==="layout"&&!sn(r))return[new M(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];if(t.expressionContext==="filter"&&!sn(r))return[new M(t.key,t.value,'"feature-state" data expressions are not supported with filters.')];if(t.expressionContext&&t.expressionContext.indexOf("cluster")===0){if(!eo(r,["zoom","feature-state"]))return[new M(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if(t.expressionContext==="cluster-initial"&&!Qi(r))return[new M(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return[]}function Hh(t){let e=t.value,r=t.key,n=j(e);return n!=="boolean"?[new M(r,e,"boolean expected, ".concat(n," found"))]:[]}function Xh(t){let e=t.key,r=t.value,n=j(r);return n!=="string"?[new M(e,r,"color expected, ".concat(n," found"))]:W.parse(String(r))?[]:[new M(e,r,'color expected, "'.concat(r,'" found'))]}function un(t){let e=t.key,r=t.value,n=t.valueSpec,i=[];return Array.isArray(n.values)?n.values.indexOf(ae(r))===-1&&i.push(new M(e,r,"expected one of [".concat(n.values.join(", "),"], ").concat(JSON.stringify(r)," found"))):Object.keys(n.values).indexOf(ae(r))===-1&&i.push(new M(e,r,"expected one of [".concat(Object.keys(n.values).join(", "),"], ").concat(JSON.stringify(r)," found"))),i}function Ps(t){return xs(Ut(t.value))?mr(fr({},t,{expressionContext:"filter",valueSpec:{value:"boolean"}})):Zu(t)}function Zu(t){let e=t.value,r=t.key;if(j(e)!=="array")return[new M(r,e,"array expected, ".concat(j(e)," found"))];let n=t.styleSpec,i,o=[];if(e.length<1)return[new M(r,e,"filter array must have at least 1 element")];switch(o=o.concat(un({key:"".concat(r,"[0]"),value:e[0],valueSpec:n.filter_operator,style:t.style,styleSpec:t.styleSpec})),ae(e[0])){case"<":case"<=":case">":case">=":e.length>=2&&ae(e[1])==="$type"&&o.push(new M(r,e,'"$type" cannot be use with operator "'.concat(e[0],'"')));case"==":case"!=":e.length!==3&&o.push(new M(r,e,'filter array for operator "'.concat(e[0],'" must have 3 elements')));case"in":case"!in":e.length>=2&&(i=j(e[1]),i!=="string"&&o.push(new M("".concat(r,"[1]"),e[1],"string expected, ".concat(i," found"))));for(let a=2;a<e.length;a++)i=j(e[a]),ae(e[1])==="$type"?o=o.concat(un({key:"".concat(r,"[").concat(a,"]"),value:e[a],valueSpec:n.geometry_type,style:t.style,styleSpec:t.styleSpec})):i!=="string"&&i!=="number"&&i!=="boolean"&&o.push(new M("".concat(r,"[").concat(a,"]"),e[a],"string, number, or boolean expected, ".concat(i," found")));break;case"any":case"all":case"none":for(let a=1;a<e.length;a++)o=o.concat(Zu({key:"".concat(r,"[").concat(a,"]"),value:e[a],style:t.style,styleSpec:t.styleSpec}));break;case"has":case"!has":i=j(e[1]),e.length!==2?o.push(new M(r,e,'filter array for "'.concat(e[0],'" operator must have 2 elements'))):i!=="string"&&o.push(new M("".concat(r,"[1]"),e[1],"string expected, ".concat(i," found")));break}return o}function Wu(t,e){let r=t.key,n=t.validateSpec,i=t.style,o=t.styleSpec,a=t.value,s=t.objectKey,l=o["".concat(e,"_").concat(t.layerType)];if(!l)return[];let u=s.match(/^(.*)-transition$/);if(e==="paint"&&u&&l[u[1]]&&l[u[1]].transition)return n({key:r,value:a,valueSpec:o.transition,style:i,styleSpec:o});let c=t.valueSpec||l[s];if(!c)return[new M(r,a,'unknown property "'.concat(s,'"'))];let p;if(j(a)==="string"&&ht(c)&&!c.tokens&&(p=/^{([^}]+)}$/.exec(a)))return[new M(r,a,'"'.concat(s,'" does not support interpolation syntax\\n')+'Use an identity property function instead: \`{ "type": "identity", "property": '.concat(JSON.stringify(p[1])," }\`."))];let f=[];return t.layerType==="symbol"&&(s==="text-field"&&i&&!i.glyphs&&f.push(new M(r,a,'use of "text-field" requires a style "glyphs" property')),s==="text-font"&&to(Ut(a))&&ae(a.type)==="identity"&&f.push(new M(r,a,'"text-font" does not support identity functions'))),f.concat(n({key:t.key,value:a,valueSpec:c,style:i,styleSpec:o,expressionContext:"property",propertyType:e,propertyKey:s}))}function Hu(t){return Wu(t,"paint")}function Xu(t){return Wu(t,"layout")}function Ku(t){let e=[],r=t.value,n=t.key,i=t.style,o=t.styleSpec;!r.type&&!r.ref&&e.push(new M(n,r,'either "type" or "ref" is required'));let a=ae(r.type),s=ae(r.ref);if(r.id){let l=ae(r.id);for(let u=0;u<t.arrayIndex;u++){let c=i.layers[u];ae(c.id)===l&&e.push(new M(n,r.id,'duplicate layer id "'.concat(r.id,'", previously used at line ').concat(c.id.__line__)))}}if("ref"in r){["type","source","source-layer","filter","layout"].forEach(u=>{u in r&&e.push(new M(n,r[u],'"'.concat(u,'" is prohibited for ref layers')))});let l;i.layers.forEach(u=>{ae(u.id)===s&&(l=u)}),l?l.ref?e.push(new M(n,r.ref,"ref cannot reference another ref layer")):a=ae(l.type):e.push(new M(n,r.ref,'ref layer "'.concat(s,'" not found')))}else if(a!=="background")if(!r.source)e.push(new M(n,r,'missing required property "source"'));else{let l=i.sources&&i.sources[r.source],u=l&&ae(l.type);l?u==="vector"&&a==="raster"?e.push(new M(n,r.source,'layer "'.concat(r.id,'" requires a raster source'))):u!=="raster-dem"&&a==="hillshade"?e.push(new M(n,r.source,'layer "'.concat(r.id,'" requires a raster-dem source'))):u==="raster"&&a!=="raster"?e.push(new M(n,r.source,'layer "'.concat(r.id,'" requires a vector source'))):u==="vector"&&!r["source-layer"]?e.push(new M(n,r,'layer "'.concat(r.id,'" must specify a "source-layer"'))):u==="raster-dem"&&a!=="hillshade"?e.push(new M(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")):a==="line"&&r.paint&&r.paint["line-gradient"]&&(u!=="geojson"||!l.lineMetrics)&&e.push(new M(n,r,'layer "'.concat(r.id,'" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.'))):e.push(new M(n,r.source,'source "'.concat(r.source,'" not found')))}return e=e.concat(ze({key:n,value:r,valueSpec:o.layer,style:t.style,styleSpec:t.styleSpec,validateSpec:t.validateSpec,objectElementValidators:{"*"(){return[]},type(){return t.validateSpec({key:"".concat(n,".type"),value:r.type,valueSpec:o.layer.type,style:t.style,styleSpec:t.styleSpec,validateSpec:t.validateSpec,object:r,objectKey:"type"})},filter:Ps,layout(l){return ze({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return Xu(fr({layerType:a},u))}}})},paint(l){return ze({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return Hu(fr({layerType:a},u))}}})}}})),e}function $t(t){let e=t.value,r=t.key,n=j(e);return n!=="string"?[new M(r,e,"string expected, ".concat(n," found"))]:[]}function Kh(t){var e;let r=(e=t.sourceName)!==null&&e!==void 0?e:"",n=t.value,i=t.styleSpec,o=i.source_raster_dem,a=t.style,s=[],l=j(n);if(n===void 0)return s;if(l!=="object")return s.push(new M("source_raster_dem",n,"object expected, ".concat(l," found"))),s;let c=ae(n.encoding)==="custom",p=["redFactor","greenFactor","blueFactor","baseShift"],f=t.value.encoding?'"'.concat(t.value.encoding,'"'):"Default";for(let y in n)!c&&p.includes(y)?s.push(new M(y,n[y],'In "'.concat(r,'": "').concat(y,'" is only valid when "encoding" is set to "custom". ').concat(f," encoding found"))):o[y]?s=s.concat(t.validateSpec({key:y,value:n[y],valueSpec:o[y],validateSpec:t.validateSpec,style:a,styleSpec:i})):s.push(new M(y,n[y],'unknown property "'.concat(y,'"')));return s}var Pu={promoteId:Yh};function Yu(t){let e=t.value,r=t.key,n=t.styleSpec,i=t.style,o=t.validateSpec;if(!e.type)return[new M(r,e,'"type" is required')];let a=ae(e.type),s;switch(a){case"vector":case"raster":return s=ze({key:r,value:e,valueSpec:n["source_".concat(a.replace("-","_"))],style:t.style,styleSpec:n,objectElementValidators:Pu,validateSpec:o}),s;case"raster-dem":return s=Kh({sourceName:r,value:e,style:t.style,styleSpec:n,validateSpec:o}),s;case"geojson":if(s=ze({key:r,value:e,valueSpec:n.source_geojson,style:i,styleSpec:n,validateSpec:o,objectElementValidators:Pu}),e.cluster)for(let l in e.clusterProperties){let[u,c]=e.clusterProperties[l],p=typeof u=="string"?[u,["accumulated"],["get",l]]:u;s.push(...mr({key:"".concat(r,".").concat(l,".map"),value:c,validateSpec:o,expressionContext:"cluster-map"})),s.push(...mr({key:"".concat(r,".").concat(l,".reduce"),value:p,validateSpec:o,expressionContext:"cluster-reduce"}))}return s;case"video":return ze({key:r,value:e,valueSpec:n.source_video,style:i,validateSpec:o,styleSpec:n});case"image":return ze({key:r,value:e,valueSpec:n.source_image,style:i,validateSpec:o,styleSpec:n});case"canvas":return[new M(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return un({key:"".concat(r,".type"),value:e.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]},style:i,validateSpec:o,styleSpec:n})}}function Yh({key:t,value:e}){if(j(e)==="string")return $t({key:t,value:e});{let r=[];for(let n in e)r.push(...$t({key:"".concat(t,".").concat(n),value:e[n]}));return r}}function Qu(t){let e=t.value,r=t.styleSpec,n=r.light,i=t.style,o=[],a=j(e);if(e===void 0)return o;if(a!=="object")return o=o.concat([new M("light",e,"object expected, ".concat(a," found"))]),o;for(let s in e){let l=s.match(/^(.*)-transition$/);l&&n[l[1]]&&n[l[1]].transition?o=o.concat(t.validateSpec({key:s,value:e[s],valueSpec:r.transition,validateSpec:t.validateSpec,style:i,styleSpec:r})):n[s]?o=o.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],validateSpec:t.validateSpec,style:i,styleSpec:r})):o=o.concat([new M(s,e[s],'unknown property "'.concat(s,'"'))])}return o}function ec(t){let e=t.value,r=t.styleSpec,n=r.sky,i=t.style,o=j(e);if(e===void 0)return[];if(o!=="object")return[new M("sky",e,"object expected, ".concat(o," found"))];let a=[];for(let s in e)n[s]?a=a.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new M(s,e[s],'unknown property "'.concat(s,'"'))]);return a}function tc(t){let e=t.value,r=t.styleSpec,n=r.terrain,i=t.style,o=[],a=j(e);if(e===void 0)return o;if(a!=="object")return o=o.concat([new M("terrain",e,"object expected, ".concat(a," found"))]),o;for(let s in e)n[s]?o=o.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],validateSpec:t.validateSpec,style:i,styleSpec:r})):o=o.concat([new M(s,e[s],'unknown property "'.concat(s,'"'))]);return o}function Qh(t){return $t(t).length===0?[]:mr(t)}function ed(t){return $t(t).length===0?[]:mr(t)}function td(t){let e=t.key,r=t.value;if(j(r)==="array"){if(r.length<1||r.length>4)return[new M(e,r,"padding requires 1 to 4 values; ".concat(r.length," values found"))];let i={type:"number"},o=[];for(let a=0;a<r.length;a++)o=o.concat(t.validateSpec({key:"".concat(e,"[").concat(a,"]"),value:r[a],validateSpec:t.validateSpec,valueSpec:i}));return o}else return vs({key:e,value:r,valueSpec:{}})}function rd(t){let e=t.key,r=t.value,n=j(r),i=t.styleSpec;if(n!=="array"||r.length<1||r.length%2!==0)return[new M(e,r,"variableAnchorOffsetCollection requires a non-empty array of even length")];let o=[];for(let a=0;a<r.length;a+=2)o=o.concat(un({key:"".concat(e,"[").concat(a,"]"),value:r[a],valueSpec:i.layout_symbol["text-anchor"]})),o=o.concat(bs({key:"".concat(e,"[").concat(a+1,"]"),value:r[a+1],valueSpec:{length:2,value:"number"},validateSpec:t.validateSpec,style:t.style,styleSpec:i}));return o}function rc(t){let e=[],r=t.value,n=t.key;if(Array.isArray(r)){let i=[],o=[];for(let a in r){r[a].id&&i.includes(r[a].id)&&e.push(new M(n,r,"all the sprites' ids must be unique, but ".concat(r[a].id," is duplicated"))),i.push(r[a].id),r[a].url&&o.includes(r[a].url)&&e.push(new M(n,r,"all the sprites' URLs must be unique, but ".concat(r[a].url," is duplicated"))),o.push(r[a].url);let s={id:{type:"string",required:!0},url:{type:"string",required:!0}};e=e.concat(ze({key:"".concat(n,"[").concat(a,"]"),value:r[a],valueSpec:s,validateSpec:t.validateSpec}))}return e}else return $t({key:n,value:r})}function nd(t){let e=t.value,r=t.styleSpec,n=r.projection,i=t.style,o=j(e);if(e===void 0)return[];if(o!=="object")return[new M("projection",e,"object expected, ".concat(o," found"))];let a=[];for(let s in e)n[s]?a=a.concat(t.validateSpec({key:s,value:e[s],valueSpec:n[s],style:i,styleSpec:r})):a=a.concat([new M(s,e[s],'unknown property "'.concat(s,'"'))]);return a}var Su={"*"(){return[]},array:bs,boolean:Hh,number:vs,color:Xh,constants:ju,enum:un,filter:Ps,function:Ju,layer:Ku,object:ze,source:Yu,light:Qu,sky:ec,terrain:tc,projection:nd,string:$t,formatted:Qh,resolvedImage:ed,padding:td,variableAnchorOffsetCollection:rd,sprite:rc};function Xr(t){let e=t.value,r=t.valueSpec,n=t.styleSpec;return t.validateSpec=Xr,r.expression&&to(ae(e))?Ju(t):r.expression&&qt(Ut(e))?mr(t):r.type&&Su[r.type]?Su[r.type](t):ze(fr({},t,{valueSpec:r.type?n[r.type]:r}))}function nc(t){let e=t.value,r=t.key,n=$t(t);return n.length||(e.indexOf("{fontstack}")===-1&&n.push(new M(r,e,'"glyphs" url must include a "{fontstack}" token')),e.indexOf("{range}")===-1&&n.push(new M(r,e,'"glyphs" url must include a "{range}" token'))),n}function Ue(t,e=S){let r=[];return r=r.concat(Xr({key:"",value:t,valueSpec:e.$root,styleSpec:e,style:t,validateSpec:Xr,objectElementValidators:{glyphs:nc,"*"(){return[]}}})),t.constants&&(r=r.concat(ju({key:"constants",value:t.constants,style:t,styleSpec:e,validateSpec:Xr}))),ic(r)}Ue.source=Qe(Ye(Yu));Ue.sprite=Qe(Ye(rc));Ue.glyphs=Qe(Ye(nc));Ue.light=Qe(Ye(Qu));Ue.sky=Qe(Ye(ec));Ue.terrain=Qe(Ye(tc));Ue.layer=Qe(Ye(Ku));Ue.filter=Qe(Ye(Ps));Ue.paintProperty=Qe(Ye(Hu));Ue.layoutProperty=Qe(Ye(Xu));function Ye(t){return function(e){return t(Ci(Dt({},e),{validateSpec:Xr}))}}function ic(t){return[].concat(t).sort((e,r)=>e.line-r.line)}function Qe(t){return function(...e){return ic(t.apply(this,e))}}var oc="AbortError";function ac(t){return t.message===oc}function Ss(){return new Error(oc)}var ro={MAX_PARALLEL_IMAGE_REQUESTS:16,MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME:8,MAX_TILE_CACHE_ZOOM_LEVELS:5,REGISTERED_PROTOCOLS:{},WORKER_URL:""};function sc(t){return ro.REGISTERED_PROTOCOLS[t.substring(0,t.indexOf("://"))]}function lc(t,e){ro.REGISTERED_PROTOCOLS[t]=e}function uc(t){delete ro.REGISTERED_PROTOCOLS[t]}var cc="global-dispatcher",br=class extends Error{constructor(e,r,n,i){super("AJAXError: ".concat(r," (").concat(e,"): ").concat(n)),this.status=e,this.statusText=r,this.url=n,this.body=i}},fc=()=>at(self)?self.worker&&self.worker.referrer:(window.location.protocol==="blob:"?window.parent:window).location.href,id=t=>/^file:/.test(t)||/^file:/.test(fc())&&!/^\\w+:/.test(t);async function od(t,e){let r=new Request(t.url,{method:t.method||"GET",body:t.body,credentials:t.credentials,headers:t.headers,cache:t.cache,referrer:fc(),signal:e.signal});t.type==="json"&&r.headers.set("Accept","application/json");let n=await fetch(r);if(!n.ok){let a=await n.blob();throw new br(n.status,n.statusText,t.url,a)}let i;t.type==="arrayBuffer"||t.type==="image"?i=n.arrayBuffer():t.type==="json"?i=n.json():i=n.text();let o=await i;if(e.signal.aborted)throw Ss();return{data:o,cacheControl:n.headers.get("Cache-Control"),expires:n.headers.get("Expires")}}function ad(t,e){return new Promise((r,n)=>{let i=new XMLHttpRequest;i.open(t.method||"GET",t.url,!0),(t.type==="arrayBuffer"||t.type==="image")&&(i.responseType="arraybuffer");for(let o in t.headers)i.setRequestHeader(o,t.headers[o]);t.type==="json"&&(i.responseType="text",i.setRequestHeader("Accept","application/json")),i.withCredentials=t.credentials==="include",i.onerror=()=>{n(new Error(i.statusText))},i.onload=()=>{if(!e.signal.aborted)if((i.status>=200&&i.status<300||i.status===0)&&i.response!==null){let o=i.response;if(t.type==="json")try{o=JSON.parse(i.response)}catch(a){n(a);return}r({data:o,cacheControl:i.getResponseHeader("Cache-Control"),expires:i.getResponseHeader("Expires")})}else{let o=new Blob([i.response],{type:i.getResponseHeader("Content-Type")});n(new br(i.status,i.statusText,t.url,o))}},e.signal.addEventListener("abort",()=>{i.abort(),n(Ss())}),i.send(t.body)})}var yc=function(t,e){if(/:\\/\\//.test(t.url)&&!/^https?:|^file:/.test(t.url)){let r=sc(t.url);if(r)return r(t,e);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:t,targetMapId:cc},e)}if(!id(t.url)){if(fetch&&Request&&AbortController&&Object.prototype.hasOwnProperty.call(Request.prototype,"signal"))return od(t,e);if(at(self)&&self.worker&&self.worker.actor)return self.worker.actor.sendAsync({type:"GR",data:t,mustQueue:!0,targetMapId:cc},e)}return ad(t,e)},mc=(t,e)=>yc(Pe(t,{type:"json"}),e),hc=(t,e)=>yc(Pe(t,{type:"arrayBuffer"}),e);var xt={};function C(t,e,r={}){if(xt[t])throw new Error("".concat(t," is already registered."));Object.defineProperty(e,"_classRegistryKey",{value:t,writeable:!1}),xt[t]={klass:e,omit:r.omit||[],shallow:r.shallow||[]}}C("Object",Object);C("TransferableGridIndex",Vt);C("Color",W);C("Error",Error);C("AJAXError",br);C("ResolvedImage",Te);C("StylePropertyFunction",ln);C("StyleExpression",Nt,{omit:["_evaluator"]});C("ZoomDependentExpression",gt);C("ZoomConstantExpression",dt);C("CompoundExpression",Ke,{omit:["_evaluate"]});for(let t in Gt)Gt[t]._classRegistryKey||C("Expression_".concat(t),Gt[t]);function dc(t){return t&&typeof ArrayBuffer<"u"&&(t instanceof ArrayBuffer||t.constructor&&t.constructor.name==="ArrayBuffer")}function vr(t,e){if(t==null||typeof t=="boolean"||typeof t=="number"||typeof t=="string"||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||t instanceof Blob||t instanceof Error)return t;if(dc(t)||Jr(t))return e&&e.push(t),t;if(ArrayBuffer.isView(t)){let r=t;return e&&e.push(r.buffer),r}if(t instanceof ImageData)return e&&e.push(t.data.buffer),t;if(Array.isArray(t)){let r=[];for(let n of t)r.push(vr(n,e));return r}if(typeof t=="object"){let r=t.constructor,n=r._classRegistryKey;if(!n)throw new Error("can't serialize object of unregistered class ".concat(r.name));if(!xt[n])throw new Error("".concat(n," is not registered."));let i=r.serialize?r.serialize(t,e):{};if(r.serialize){if(e&&i===e[e.length-1])throw new Error("statically serialized object won't survive transfer of $name property")}else{for(let o in t){if(!t.hasOwnProperty(o)||xt[n].omit.indexOf(o)>=0)continue;let a=t[o];i[o]=xt[n].shallow.indexOf(o)>=0?a:vr(a,e)}t instanceof Error&&(i.message=t.message)}if(i.$name)throw new Error("$name property is reserved for worker serialization logic.");return n!=="Object"&&(i.$name=n),i}throw new Error("can't serialize object of type ".concat(typeof t))}function Pr(t){if(t==null||typeof t=="boolean"||typeof t=="number"||typeof t=="string"||t instanceof Boolean||t instanceof Number||t instanceof String||t instanceof Date||t instanceof RegExp||t instanceof Blob||t instanceof Error||dc(t)||Jr(t)||ArrayBuffer.isView(t)||t instanceof ImageData)return t;if(Array.isArray(t))return t.map(Pr);if(typeof t=="object"){let e=t.$name||"Object";if(!xt[e])throw new Error("can't deserialize unregistered class ".concat(e));let{klass:r}=xt[e];if(!r)throw new Error("can't deserialize unregistered class ".concat(e));if(r.deserialize)return r.deserialize(t);let n=Object.create(r.prototype);for(let i of Object.keys(t)){if(i==="$name")continue;let o=t[i];n[i]=xt[e].shallow.indexOf(i)>=0?o:Pr(o)}return n}throw new Error("can't deserialize object of type ".concat(typeof t))}var no=class{constructor(e){this._methodToThrottle=e,this._triggered=!1,typeof MessageChannel<"u"&&(this._channel=new MessageChannel,this._channel.port2.onmessage=()=>{this._triggered=!1,this._methodToThrottle()})}trigger(){this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout(()=>{this._triggered=!1,this._methodToThrottle()},0))}remove(){delete this._channel,this._methodToThrottle=()=>{}}};var io=class{constructor(e,r){this.target=e,this.mapId=r,this.resolveRejects={},this.tasks={},this.taskQueue=[],this.abortControllers={},this.messageHandlers={},this.invoker=new no(()=>this.process()),this.subscription=tu(this.target,"message",n=>this.receive(n),!1),this.globalScope=at(self)?e:window}registerMessageHandler(e,r){this.messageHandlers[e]=r}sendAsync(e,r){return new Promise((n,i)=>{let o=Math.round(Math.random()*1e18).toString(36).substring(0,10);this.resolveRejects[o]={resolve:n,reject:i},r&&r.signal.addEventListener("abort",()=>{delete this.resolveRejects[o];let l={id:o,type:"<cancel>",origin:location.origin,targetMapId:e.targetMapId,sourceMapId:this.mapId};this.target.postMessage(l)},{once:!0});let a=[],s=Ci(Dt({},e),{id:o,sourceMapId:this.mapId,origin:location.origin,data:vr(e.data,a)});this.target.postMessage(s,{transfer:a})})}receive(e){let r=e.data,n=r.id;if(!(r.origin!=="file://"&&location.origin!=="file://"&&r.origin!==location.origin)&&!(r.targetMapId&&this.mapId!==r.targetMapId)){if(r.type==="<cancel>"){delete this.tasks[n];let i=this.abortControllers[n];delete this.abortControllers[n],i&&i.abort();return}if(at(self)||r.mustQueue){this.tasks[n]=r,this.taskQueue.push(n),this.invoker.trigger();return}this.processTask(n,r)}}process(){if(this.taskQueue.length===0)return;let e=this.taskQueue.shift(),r=this.tasks[e];delete this.tasks[e],this.taskQueue.length>0&&this.invoker.trigger(),r&&this.processTask(e,r)}async processTask(e,r){if(r.type==="<response>"){let o=this.resolveRejects[e];if(delete this.resolveRejects[e],!o)return;r.error?o.reject(Pr(r.error)):o.resolve(Pr(r.data));return}if(!this.messageHandlers[r.type]){this.completeTask(e,new Error("Could not find a registered handler for ".concat(r.type,", map ID: ").concat(this.mapId,", available handlers: ").concat(Object.keys(this.messageHandlers).join(", "))));return}let n=Pr(r.data),i=new AbortController;this.abortControllers[e]=i;try{let o=await this.messageHandlers[r.type](r.sourceMapId,n,i);this.completeTask(e,null,o)}catch(o){this.completeTask(e,o)}}completeTask(e,r,n){let i=[];delete this.abortControllers[e];let o={id:e,type:"<response>",sourceMapId:this.mapId,origin:location.origin,error:r?vr(r):null,data:vr(n,i)};this.target.postMessage(o,{transfer:i})}remove(){this.invoker.remove(),this.subscription.unsubscribe()}};function gc(t,e,r){r[t]&&r[t].indexOf(e)!==-1||(r[t]=r[t]||[],r[t].push(e))}function ws(t,e,r){if(r&&r[t]){let n=r[t].indexOf(e);n!==-1&&r[t].splice(n,1)}}var oo=class{constructor(e,r={}){Pe(this,r),this.type=e}},mn=class extends oo{constructor(e,r={}){super("error",Pe({error:e},r))}},ao=class{on(e,r){return this._listeners=this._listeners||{},gc(e,r,this._listeners),this}off(e,r){return ws(e,r,this._listeners),ws(e,r,this._oneTimeListeners),this}once(e,r){return r?(this._oneTimeListeners=this._oneTimeListeners||{},gc(e,r,this._oneTimeListeners),this):new Promise(n=>this.once(e,n))}fire(e,r){typeof e=="string"&&(e=new oo(e,r||{}));let n=e.type;if(this.listens(n)){e.target=this;let i=this._listeners&&this._listeners[n]?this._listeners[n].slice():[];for(let s of i)s.call(this,e);let o=this._oneTimeListeners&&this._oneTimeListeners[n]?this._oneTimeListeners[n].slice():[];for(let s of o)ws(n,s,this._oneTimeListeners),s.call(this,e);let a=this._eventedParent;a&&(Pe(e,typeof this._eventedParentData=="function"?this._eventedParentData():this._eventedParentData),a.fire(e))}else e instanceof mn&&console.error(e.error);return this}listens(e){return this._listeners&&this._listeners[e]&&this._listeners[e].length>0||this._oneTimeListeners&&this._oneTimeListeners[e]&&this._oneTimeListeners[e].length>0||this._eventedParent&&this._eventedParent.listens(e)}setEventedParent(e,r){return this._eventedParent=e,this._eventedParentData=r,this}};var bt=Ue,tv=bt.source,rv=bt.light,nv=bt.terrain,iv=bt.filter,xc=bt.paintProperty,bc=bt.layoutProperty;function vc(t,e){let r=!1;if(e&&e.length)for(let n of e)t.fire(new mn(new Error(n.message))),r=!0;return r}var so=class{constructor(){this.first=!0}update(e,r){let n=Math.floor(e);return this.first?(this.first=!1,this.lastIntegerZoom=n,this.lastIntegerZoomTime=0,this.lastZoom=e,this.lastFloorZoom=n,!0):(this.lastFloorZoom>n?(this.lastIntegerZoom=n+1,this.lastIntegerZoomTime=r):this.lastFloorZoom<n&&(this.lastIntegerZoom=n,this.lastIntegerZoomTime=r),e!==this.lastZoom?(this.lastZoom=e,this.lastFloorZoom=n,!0):!1)}};var D={"Latin-1 Supplement":t=>t>=128&&t<=255,Arabic:t=>t>=1536&&t<=1791,"Arabic Supplement":t=>t>=1872&&t<=1919,"Arabic Extended-A":t=>t>=2208&&t<=2303,"Hangul Jamo":t=>t>=4352&&t<=4607,"Unified Canadian Aboriginal Syllabics":t=>t>=5120&&t<=5759,Khmer:t=>t>=6016&&t<=6143,"Unified Canadian Aboriginal Syllabics Extended":t=>t>=6320&&t<=6399,"General Punctuation":t=>t>=8192&&t<=8303,"Letterlike Symbols":t=>t>=8448&&t<=8527,"Number Forms":t=>t>=8528&&t<=8591,"Miscellaneous Technical":t=>t>=8960&&t<=9215,"Control Pictures":t=>t>=9216&&t<=9279,"Optical Character Recognition":t=>t>=9280&&t<=9311,"Enclosed Alphanumerics":t=>t>=9312&&t<=9471,"Geometric Shapes":t=>t>=9632&&t<=9727,"Miscellaneous Symbols":t=>t>=9728&&t<=9983,"Miscellaneous Symbols and Arrows":t=>t>=11008&&t<=11263,"CJK Radicals Supplement":t=>t>=11904&&t<=12031,"Kangxi Radicals":t=>t>=12032&&t<=12255,"Ideographic Description Characters":t=>t>=12272&&t<=12287,"CJK Symbols and Punctuation":t=>t>=12288&&t<=12351,Hiragana:t=>t>=12352&&t<=12447,Katakana:t=>t>=12448&&t<=12543,Bopomofo:t=>t>=12544&&t<=12591,"Hangul Compatibility Jamo":t=>t>=12592&&t<=12687,Kanbun:t=>t>=12688&&t<=12703,"Bopomofo Extended":t=>t>=12704&&t<=12735,"CJK Strokes":t=>t>=12736&&t<=12783,"Katakana Phonetic Extensions":t=>t>=12784&&t<=12799,"Enclosed CJK Letters and Months":t=>t>=12800&&t<=13055,"CJK Compatibility":t=>t>=13056&&t<=13311,"CJK Unified Ideographs Extension A":t=>t>=13312&&t<=19903,"Yijing Hexagram Symbols":t=>t>=19904&&t<=19967,"CJK Unified Ideographs":t=>t>=19968&&t<=40959,"Yi Syllables":t=>t>=40960&&t<=42127,"Yi Radicals":t=>t>=42128&&t<=42191,"Hangul Jamo Extended-A":t=>t>=43360&&t<=43391,"Hangul Syllables":t=>t>=44032&&t<=55215,"Hangul Jamo Extended-B":t=>t>=55216&&t<=55295,"Private Use Area":t=>t>=57344&&t<=63743,"CJK Compatibility Ideographs":t=>t>=63744&&t<=64255,"Arabic Presentation Forms-A":t=>t>=64336&&t<=65023,"Vertical Forms":t=>t>=65040&&t<=65055,"CJK Compatibility Forms":t=>t>=65072&&t<=65103,"Small Form Variants":t=>t>=65104&&t<=65135,"Arabic Presentation Forms-B":t=>t>=65136&&t<=65279,"Halfwidth and Fullwidth Forms":t=>t>=65280&&t<=65519};function hn(t){for(let e of t)if(lo(e.charCodeAt(0)))return!0;return!1}function Pc(t){for(let e of t)if(!sd(e.charCodeAt(0)))return!1;return!0}function sd(t){return!(D.Arabic(t)||D["Arabic Supplement"](t)||D["Arabic Extended-A"](t)||D["Arabic Presentation Forms-A"](t)||D["Arabic Presentation Forms-B"](t))}function Sc(t){return t<11904?!1:!!(D["Bopomofo Extended"](t)||D.Bopomofo(t)||D["CJK Compatibility Forms"](t)||D["CJK Compatibility Ideographs"](t)||D["CJK Compatibility"](t)||D["CJK Radicals Supplement"](t)||D["CJK Strokes"](t)||D["CJK Symbols and Punctuation"](t)||D["CJK Unified Ideographs Extension A"](t)||D["CJK Unified Ideographs"](t)||D["Enclosed CJK Letters and Months"](t)||D["Halfwidth and Fullwidth Forms"](t)||D.Hiragana(t)||D["Ideographic Description Characters"](t)||D["Kangxi Radicals"](t)||D["Katakana Phonetic Extensions"](t)||D.Katakana(t)||D["Vertical Forms"](t)||D["Yi Radicals"](t)||D["Yi Syllables"](t))}function lo(t){return t===746||t===747?!0:t<4352?!1:!!(D["Bopomofo Extended"](t)||D.Bopomofo(t)||D["CJK Compatibility Forms"](t)&&!(t>=65097&&t<=65103)||D["CJK Compatibility Ideographs"](t)||D["CJK Compatibility"](t)||D["CJK Radicals Supplement"](t)||D["CJK Strokes"](t)||D["CJK Symbols and Punctuation"](t)&&!(t>=12296&&t<=12305)&&!(t>=12308&&t<=12319)&&t!==12336||D["CJK Unified Ideographs Extension A"](t)||D["CJK Unified Ideographs"](t)||D["Enclosed CJK Letters and Months"](t)||D["Hangul Compatibility Jamo"](t)||D["Hangul Jamo Extended-A"](t)||D["Hangul Jamo Extended-B"](t)||D["Hangul Jamo"](t)||D["Hangul Syllables"](t)||D.Hiragana(t)||D["Ideographic Description Characters"](t)||D.Kanbun(t)||D["Kangxi Radicals"](t)||D["Katakana Phonetic Extensions"](t)||D.Katakana(t)&&t!==12540||D["Halfwidth and Fullwidth Forms"](t)&&t!==65288&&t!==65289&&t!==65293&&!(t>=65306&&t<=65310)&&t!==65339&&t!==65341&&t!==65343&&!(t>=65371&&t<=65503)&&t!==65507&&!(t>=65512&&t<=65519)||D["Small Form Variants"](t)&&!(t>=65112&&t<=65118)&&!(t>=65123&&t<=65126)||D["Unified Canadian Aboriginal Syllabics"](t)||D["Unified Canadian Aboriginal Syllabics Extended"](t)||D["Vertical Forms"](t)||D["Yijing Hexagram Symbols"](t)||D["Yi Syllables"](t)||D["Yi Radicals"](t))}function ld(t){return!!(D["Latin-1 Supplement"](t)&&(t===167||t===169||t===174||t===177||t===188||t===189||t===190||t===215||t===247)||D["General Punctuation"](t)&&(t===8214||t===8224||t===8225||t===8240||t===8241||t===8251||t===8252||t===8258||t===8263||t===8264||t===8265||t===8273)||D["Letterlike Symbols"](t)||D["Number Forms"](t)||D["Miscellaneous Technical"](t)&&(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||t===9003||t>=9085&&t<=9114||t>=9150&&t<=9165||t===9167||t>=9169&&t<=9179||t>=9186&&t<=9215)||D["Control Pictures"](t)&&t!==9251||D["Optical Character Recognition"](t)||D["Enclosed Alphanumerics"](t)||D["Geometric Shapes"](t)||D["Miscellaneous Symbols"](t)&&!(t>=9754&&t<=9759)||D["Miscellaneous Symbols and Arrows"](t)&&(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243)||D["CJK Symbols and Punctuation"](t)||D.Katakana(t)||D["Private Use Area"](t)||D["CJK Compatibility Forms"](t)||D["Small Form Variants"](t)||D["Halfwidth and Fullwidth Forms"](t)||t===8734||t===8756||t===8757||t>=9984&&t<=10087||t>=10102&&t<=10131||t===65532||t===65533)}function As(t){return!(lo(t)||ld(t))}function wc(t){return D.Arabic(t)||D["Arabic Supplement"](t)||D["Arabic Extended-A"](t)||D["Arabic Presentation Forms-A"](t)||D["Arabic Presentation Forms-B"](t)}function Ac(t){return t>=1424&&t<=2303||D["Arabic Presentation Forms-A"](t)||D["Arabic Presentation Forms-B"](t)}function ud(t,e){return!(!e&&Ac(t)||t>=2304&&t<=3583||t>=3840&&t<=4255||D.Khmer(t))}function _c(t){for(let e of t)if(Ac(e.charCodeAt(0)))return!0;return!1}function Ic(t,e){for(let r of t)if(!ud(r.charCodeAt(0),e))return!1;return!0}var _s=class{constructor(){this.applyArabicShaping=null;this.processBidirectionalText=null;this.processStyledBidirectionalText=null;this.pluginStatus="unavailable";this.pluginURL=null}setState(e){this.pluginStatus=e.pluginStatus,this.pluginURL=e.pluginURL}getState(){return{pluginStatus:this.pluginStatus,pluginURL:this.pluginURL}}setMethods(e){this.applyArabicShaping=e.applyArabicShaping,this.processBidirectionalText=e.processBidirectionalText,this.processStyledBidirectionalText=e.processStyledBidirectionalText}isParsed(){return this.applyArabicShaping!=null&&this.processBidirectionalText!=null&&this.processStyledBidirectionalText!=null}getPluginURL(){return this.pluginURL}getRTLTextPluginStatus(){return this.pluginStatus}},ye=new _s;var q=class{constructor(e,r){this.zoom=e,r?(this.now=r.now,this.fadeDuration=r.fadeDuration,this.zoomHistory=r.zoomHistory,this.transition=r.transition):(this.now=0,this.fadeDuration=0,this.zoomHistory=new so,this.transition={})}isSupportedScript(e){return Ic(e,ye.getRTLTextPluginStatus()==="loaded")}crossFadingFactor(){return this.fadeDuration===0?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)}getCrossfadeParameters(){let e=this.zoom,r=e-Math.floor(e),n=this.crossFadingFactor();return e>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:r+(1-r)*n}:{fromScale:.5,toScale:1,t:1-(1-n)*r}}};var Sr=class{constructor(e,r){this.property=e,this.value=r,this.expression=$u(r===void 0?e.specification.default:r,e.specification)}isDataDriven(){return this.expression.kind==="source"||this.expression.kind==="composite"}possiblyEvaluate(e,r,n){return this.property.possiblyEvaluate(this,e,r,n)}},dn=class{constructor(e){this.property=e,this.value=new Sr(e,void 0)}transitioned(e,r){return new co(this.property,this.value,r,Pe({},e.transition,this.transition),e.now)}untransitioned(){return new co(this.property,this.value,null,{},0)}},uo=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultTransitionablePropertyValues)}getValue(e){return nt(this._values[e].value.value)}setValue(e,r){Object.prototype.hasOwnProperty.call(this._values,e)||(this._values[e]=new dn(this._values[e].property)),this._values[e].value=new Sr(this._values[e].property,r===null?void 0:nt(r))}getTransition(e){return nt(this._values[e].transition)}setTransition(e,r){Object.prototype.hasOwnProperty.call(this._values,e)||(this._values[e]=new dn(this._values[e].property)),this._values[e].transition=nt(r)||void 0}serialize(){let e={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(e[r]=n);let i=this.getTransition(r);i!==void 0&&(e["".concat(r,"-transition")]=i)}return e}transitioned(e,r){let n=new po(this._properties);for(let i of Object.keys(this._values))n._values[i]=this._values[i].transitioned(e,r._values[i]);return n}untransitioned(){let e=new po(this._properties);for(let r of Object.keys(this._values))e._values[r]=this._values[r].untransitioned();return e}},co=class{constructor(e,r,n,i,o){this.property=e,this.value=r,this.begin=o+i.delay||0,this.end=this.begin+i.duration||0,e.specification.transition&&(i.delay||i.duration)&&(this.prior=n)}possiblyEvaluate(e,r,n){let i=e.now||0,o=this.value.possiblyEvaluate(e,r,n),a=this.prior;if(a){if(i>this.end)return this.prior=null,o;if(this.value.isDataDriven())return this.prior=null,o;if(i<this.begin)return a.possiblyEvaluate(e,r,n);{let s=(i-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(e,r,n),o,Wl(s))}}else return o}},po=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultTransitioningPropertyValues)}possiblyEvaluate(e,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(e,r,n);return i}hasTransition(){for(let e of Object.keys(this._values))if(this._values[e].prior)return!0;return!1}},fo=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultPropertyValues)}hasValue(e){return this._values[e].value!==void 0}getValue(e){return nt(this._values[e].value)}setValue(e,r){this._values[e]=new Sr(this._values[e].property,r===null?void 0:nt(r))}serialize(){let e={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(e[r]=n)}return e}possiblyEvaluate(e,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(e,r,n);return i}},Se=class{constructor(e,r,n){this.property=e,this.value=r,this.parameters=n}isConstant(){return this.value.kind==="constant"}constantOr(e){return this.value.kind==="constant"?this.value.value:e}evaluate(e,r,n,i){return this.property.evaluate(this.value,this.parameters,e,r,n,i)}},vt=class{constructor(e){this._properties=e,this._values=Object.create(e.defaultPossiblyEvaluatedValues)}get(e){return this._values[e]}},B=class{constructor(e){this.specification=e}possiblyEvaluate(e,r){if(e.isDataDriven())throw new Error("Value should not be data driven");return e.expression.evaluate(r)}interpolate(e,r,n){let i=this.specification.type,o=Oe[i];return o?o(e,r,n):e}},R=class{constructor(e,r){this.specification=e,this.overrides=r}possiblyEvaluate(e,r,n,i){return e.expression.kind==="constant"||e.expression.kind==="camera"?new Se(this,{kind:"constant",value:e.expression.evaluate(r,null,{},n,i)},r):new Se(this,e.expression,r)}interpolate(e,r,n){if(e.value.kind!=="constant"||r.value.kind!=="constant")return e;if(e.value.value===void 0||r.value.value===void 0)return new Se(this,{kind:"constant",value:void 0},e.parameters);let i=this.specification.type,o=Oe[i];if(o){let a=o(e.value.value,r.value.value,n);return new Se(this,{kind:"constant",value:a},e.parameters)}else return e}evaluate(e,r,n,i,o,a){return e.kind==="constant"?e.value:e.evaluate(r,n,i,o,a)}},lt=class extends R{possiblyEvaluate(e,r,n,i){if(e.value===void 0)return new Se(this,{kind:"constant",value:void 0},r);if(e.expression.kind==="constant"){let o=e.expression.evaluate(r,null,{},n,i),s=e.property.specification.type==="resolvedImage"&&typeof o!="string"?o.name:o,l=this._calculate(s,s,s,r);return new Se(this,{kind:"constant",value:l},r)}else if(e.expression.kind==="camera"){let o=this._calculate(e.expression.evaluate({zoom:r.zoom-1}),e.expression.evaluate({zoom:r.zoom}),e.expression.evaluate({zoom:r.zoom+1}),r);return new Se(this,{kind:"constant",value:o},r)}else return new Se(this,e.expression,r)}evaluate(e,r,n,i,o,a){if(e.kind==="source"){let s=e.evaluate(r,n,i,o,a);return this._calculate(s,s,s,r)}else return e.kind==="composite"?this._calculate(e.evaluate({zoom:Math.floor(r.zoom)-1},n,i),e.evaluate({zoom:Math.floor(r.zoom)},n,i),e.evaluate({zoom:Math.floor(r.zoom)+1},n,i),r):e.value}_calculate(e,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:e,to:r}:{from:n,to:r}}interpolate(e){return e}},Jt=class{constructor(e){this.specification=e}possiblyEvaluate(e,r,n,i){if(e.value!==void 0)if(e.expression.kind==="constant"){let o=e.expression.evaluate(r,null,{},n,i);return this._calculate(o,o,o,r)}else return this._calculate(e.expression.evaluate(new q(Math.floor(r.zoom-1),r)),e.expression.evaluate(new q(Math.floor(r.zoom),r)),e.expression.evaluate(new q(Math.floor(r.zoom+1),r)),r)}_calculate(e,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:e,to:r}:{from:n,to:r}}interpolate(e){return e}},Zt=class{constructor(e){this.specification=e}possiblyEvaluate(e,r,n,i){return!!e.expression.evaluate(r,null,{},n,i)}interpolate(){return!1}},re=class{constructor(e){this.properties=e,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[];for(let r in e){let n=e[r];n.specification.overridable&&this.overridableProperties.push(r);let i=this.defaultPropertyValues[r]=new Sr(n,void 0),o=this.defaultTransitionablePropertyValues[r]=new dn(n);this.defaultTransitioningPropertyValues[r]=o.untransitioned(),this.defaultPossiblyEvaluatedValues[r]=i.possiblyEvaluate({})}}};C("DataDrivenProperty",R);C("DataConstantProperty",B);C("CrossFadedDataDrivenProperty",lt);C("CrossFadedProperty",Jt);C("ColorRampProperty",Zt);var yo="-transition",se=class extends ao{constructor(e,r){if(super(),this.id=e.id,this.type=e.type,this._featureFilter={filter:()=>!0,needGeometry:!1},e.type!=="custom"&&(e=e,this.metadata=e.metadata,this.minzoom=e.minzoom,this.maxzoom=e.maxzoom,e.type!=="background"&&(this.source=e.source,this.sourceLayer=e["source-layer"],this.filter=e.filter),r.layout&&(this._unevaluatedLayout=new fo(r.layout)),r.paint)){this._transitionablePaint=new uo(r.paint);for(let n in e.paint)this.setPaintProperty(n,e.paint[n],{validate:!1});for(let n in e.layout)this.setLayoutProperty(n,e.layout[n],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new vt(r.paint)}}getCrossfadeParameters(){return this._crossfadeParameters}getLayoutProperty(e){return e==="visibility"?this.visibility:this._unevaluatedLayout.getValue(e)}setLayoutProperty(e,r,n={}){if(r!=null){let i="layers.".concat(this.id,".layout.").concat(e);if(this._validate(bc,i,e,r,n))return}if(e==="visibility"){this.visibility=r;return}this._unevaluatedLayout.setValue(e,r)}getPaintProperty(e){return e.endsWith(yo)?this._transitionablePaint.getTransition(e.slice(0,-yo.length)):this._transitionablePaint.getValue(e)}setPaintProperty(e,r,n={}){if(r!=null){let i="layers.".concat(this.id,".paint.").concat(e);if(this._validate(xc,i,e,r,n))return!1}if(e.endsWith(yo))return this._transitionablePaint.setTransition(e.slice(0,-yo.length),r||void 0),!1;{let i=this._transitionablePaint._values[e],o=i.property.specification["property-type"]==="cross-faded-data-driven",a=i.value.isDataDriven(),s=i.value;this._transitionablePaint.setValue(e,r),this._handleSpecialPaintPropertyUpdate(e);let l=this._transitionablePaint._values[e].value;return l.isDataDriven()||a||o||this._handleOverridablePaintPropertyUpdate(e,s,l)}}_handleSpecialPaintPropertyUpdate(e){}_handleOverridablePaintPropertyUpdate(e,r,n){return!1}isHidden(e){return this.minzoom&&e<this.minzoom||this.maxzoom&&e>=this.maxzoom?!0:this.visibility==="none"}updateTransitions(e){this._transitioningPaint=this._transitionablePaint.transitioned(e,this._transitioningPaint)}hasTransition(){return this._transitioningPaint.hasTransition()}recalculate(e,r){e.getCrossfadeParameters&&(this._crossfadeParameters=e.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(e,void 0,r)),this.paint=this._transitioningPaint.possiblyEvaluate(e,void 0,r)}serialize(){let e={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(e.layout=e.layout||{},e.layout.visibility=this.visibility),Kl(e,(r,n)=>r!==void 0&&!(n==="layout"&&!Object.keys(r).length)&&!(n==="paint"&&!Object.keys(r).length))}_validate(e,r,n,i,o={}){return o&&o.validate===!1?!1:vc(this,e.call(bt,{key:r,layerType:this.type,objectKey:n,value:i,styleSpec:S,style:{glyphs:!0,sprite:!0}}))}is3D(){return!1}isTileClipped(){return!1}hasOffscreenPass(){return!1}resize(){}isStateDependent(){for(let e in this.paint._values){let r=this.paint.get(e);if(!(!(r instanceof Se)||!ht(r.property.specification))&&(r.value.kind==="source"||r.value.kind==="composite")&&r.value.isStateDependent)return!0}return!1}};var cd={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Pt=class{constructor(e,r){this._structArray=e,this._pos1=r*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8}},pd=128,fd=5,ee=class{constructor(){this.isTransferred=!1,this.capacity=-1,this.resize(0)}static serialize(e,r){return e._trim(),r&&(e.isTransferred=!0,r.push(e.arrayBuffer)),{length:e.length,arrayBuffer:e.arrayBuffer}}static deserialize(e){let r=Object.create(this.prototype);return r.arrayBuffer=e.arrayBuffer,r.length=e.length,r.capacity=e.arrayBuffer.byteLength/r.bytesPerElement,r._refreshViews(),r}_trim(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews())}clear(){this.length=0}resize(e){this.reserve(e),this.length=e}reserve(e){if(e>this.capacity){this.capacity=Math.max(e,Math.floor(this.capacity*fd),pd),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);let r=this.uint8;this._refreshViews(),r&&this.uint8.set(r)}}_refreshViews(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")}};function Y(t,e=1){let r=0,n=0,i=t.map(a=>{let s=yd(a.type),l=r=Tc(r,Math.max(e,s)),u=a.components||1;return n=Math.max(n,s),r+=s*u,{name:a.name,type:a.type,components:u,offset:l}}),o=Tc(r,Math.max(n,e));return{members:i,size:o,alignment:e}}function yd(t){return cd[t].BYTES_PER_ELEMENT}function Tc(t,e){return Math.ceil(t/e)*e}var Cc=Z(he(),1),Wt=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r){let n=this.length;return this.resize(n+1),this.emplace(n,e,r)}emplace(e,r,n){let i=e*2;return this.int16[i+0]=r,this.int16[i+1]=n,e}};Wt.prototype.bytesPerElement=4;C("StructArrayLayout2i4",Wt);var gn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*3;return this.int16[o+0]=r,this.int16[o+1]=n,this.int16[o+2]=i,e}};gn.prototype.bytesPerElement=6;C("StructArrayLayout3i6",gn);var mo=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,e,r,n,i)}emplace(e,r,n,i,o){let a=e*4;return this.int16[a+0]=r,this.int16[a+1]=n,this.int16[a+2]=i,this.int16[a+3]=o,e}};mo.prototype.bytesPerElement=8;C("StructArrayLayout4i8",mo);var xn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,e,r,n,i,o,a)}emplace(e,r,n,i,o,a,s){let l=e*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,e}};xn.prototype.bytesPerElement=12;C("StructArrayLayout2i4i12",xn);var bn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,e,r,n,i,o,a)}emplace(e,r,n,i,o,a,s){let l=e*4,u=e*8;return this.int16[l+0]=r,this.int16[l+1]=n,this.uint8[u+4]=i,this.uint8[u+5]=o,this.uint8[u+6]=a,this.uint8[u+7]=s,e}};bn.prototype.bytesPerElement=8;C("StructArrayLayout2i4ub8",bn);var St=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r){let n=this.length;return this.resize(n+1),this.emplace(n,e,r)}emplace(e,r,n){let i=e*2;return this.float32[i+0]=r,this.float32[i+1]=n,e}};St.prototype.bytesPerElement=8;C("StructArrayLayout2f8",St);var vn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c){let p=this.length;return this.resize(p+1),this.emplace(p,e,r,n,i,o,a,s,l,u,c)}emplace(e,r,n,i,o,a,s,l,u,c,p){let f=e*10;return this.uint16[f+0]=r,this.uint16[f+1]=n,this.uint16[f+2]=i,this.uint16[f+3]=o,this.uint16[f+4]=a,this.uint16[f+5]=s,this.uint16[f+6]=l,this.uint16[f+7]=u,this.uint16[f+8]=c,this.uint16[f+9]=p,e}};vn.prototype.bytesPerElement=20;C("StructArrayLayout10ui20",vn);var Pn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c,p,f){let y=this.length;return this.resize(y+1),this.emplace(y,e,r,n,i,o,a,s,l,u,c,p,f)}emplace(e,r,n,i,o,a,s,l,u,c,p,f,y){let m=e*12;return this.int16[m+0]=r,this.int16[m+1]=n,this.int16[m+2]=i,this.int16[m+3]=o,this.uint16[m+4]=a,this.uint16[m+5]=s,this.uint16[m+6]=l,this.uint16[m+7]=u,this.int16[m+8]=c,this.int16[m+9]=p,this.int16[m+10]=f,this.int16[m+11]=y,e}};Pn.prototype.bytesPerElement=24;C("StructArrayLayout4i4ui4i24",Pn);var Sn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*3;return this.float32[o+0]=r,this.float32[o+1]=n,this.float32[o+2]=i,e}};Sn.prototype.bytesPerElement=12;C("StructArrayLayout3f12",Sn);var wn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer)}emplaceBack(e){let r=this.length;return this.resize(r+1),this.emplace(r,e)}emplace(e,r){let n=e*1;return this.uint32[n+0]=r,e}};wn.prototype.bytesPerElement=4;C("StructArrayLayout1ul4",wn);var An=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u){let c=this.length;return this.resize(c+1),this.emplace(c,e,r,n,i,o,a,s,l,u)}emplace(e,r,n,i,o,a,s,l,u,c){let p=e*10,f=e*5;return this.int16[p+0]=r,this.int16[p+1]=n,this.int16[p+2]=i,this.int16[p+3]=o,this.int16[p+4]=a,this.int16[p+5]=s,this.uint32[f+3]=l,this.uint16[p+8]=u,this.uint16[p+9]=c,e}};An.prototype.bytesPerElement=20;C("StructArrayLayout6i1ul2ui20",An);var _n=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,e,r,n,i,o,a)}emplace(e,r,n,i,o,a,s){let l=e*6;return this.int16[l+0]=r,this.int16[l+1]=n,this.int16[l+2]=i,this.int16[l+3]=o,this.int16[l+4]=a,this.int16[l+5]=s,e}};_n.prototype.bytesPerElement=12;C("StructArrayLayout2i2i2i12",_n);var ho=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o){let a=this.length;return this.resize(a+1),this.emplace(a,e,r,n,i,o)}emplace(e,r,n,i,o,a){let s=e*4,l=e*8;return this.float32[s+0]=r,this.float32[s+1]=n,this.float32[s+2]=i,this.int16[l+6]=o,this.int16[l+7]=a,e}};ho.prototype.bytesPerElement=16;C("StructArrayLayout2f1f2i16",ho);var In=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,e,r,n,i)}emplace(e,r,n,i,o){let a=e*12,s=e*3;return this.uint8[a+0]=r,this.uint8[a+1]=n,this.float32[s+1]=i,this.float32[s+2]=o,e}};In.prototype.bytesPerElement=12;C("StructArrayLayout2ub2f12",In);var Tn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*3;return this.uint16[o+0]=r,this.uint16[o+1]=n,this.uint16[o+2]=i,e}};Tn.prototype.bytesPerElement=6;C("StructArrayLayout3ui6",Tn);var Cn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g){let b=this.length;return this.resize(b+1),this.emplace(b,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g)}emplace(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b){let x=e*24,v=e*12,P=e*48;return this.int16[x+0]=r,this.int16[x+1]=n,this.uint16[x+2]=i,this.uint16[x+3]=o,this.uint32[v+2]=a,this.uint32[v+3]=s,this.uint32[v+4]=l,this.uint16[x+10]=u,this.uint16[x+11]=c,this.uint16[x+12]=p,this.float32[v+7]=f,this.float32[v+8]=y,this.uint8[P+36]=m,this.uint8[P+37]=h,this.uint8[P+38]=d,this.uint32[v+10]=g,this.int16[x+22]=b,e}};Cn.prototype.bytesPerElement=48;C("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",Cn);var kn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k){let V=this.length;return this.resize(V+1),this.emplace(V,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k)}emplace(e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k,V){let A=e*32,z=e*16;return this.int16[A+0]=r,this.int16[A+1]=n,this.int16[A+2]=i,this.int16[A+3]=o,this.int16[A+4]=a,this.int16[A+5]=s,this.int16[A+6]=l,this.int16[A+7]=u,this.uint16[A+8]=c,this.uint16[A+9]=p,this.uint16[A+10]=f,this.uint16[A+11]=y,this.uint16[A+12]=m,this.uint16[A+13]=h,this.uint16[A+14]=d,this.uint16[A+15]=g,this.uint16[A+16]=b,this.uint16[A+17]=x,this.uint16[A+18]=v,this.uint16[A+19]=P,this.uint16[A+20]=w,this.uint16[A+21]=T,this.uint16[A+22]=F,this.uint32[z+12]=E,this.float32[z+13]=_,this.float32[z+14]=I,this.uint16[A+30]=k,this.uint16[A+31]=V,e}};kn.prototype.bytesPerElement=64;C("StructArrayLayout8i15ui1ul2f2ui64",kn);var Ht=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e){let r=this.length;return this.resize(r+1),this.emplace(r,e)}emplace(e,r){let n=e*1;return this.float32[n+0]=r,e}};Ht.prototype.bytesPerElement=4;C("StructArrayLayout1f4",Ht);var Mn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*6,a=e*3;return this.uint16[o+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,e}};Mn.prototype.bytesPerElement=12;C("StructArrayLayout1ui2f12",Mn);var En=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r,n){let i=this.length;return this.resize(i+1),this.emplace(i,e,r,n)}emplace(e,r,n,i){let o=e*2,a=e*4;return this.uint32[o+0]=r,this.uint16[a+2]=n,this.uint16[a+3]=i,e}};En.prototype.bytesPerElement=8;C("StructArrayLayout1ul2ui8",En);var Fn=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e,r){let n=this.length;return this.resize(n+1),this.emplace(n,e,r)}emplace(e,r,n){let i=e*2;return this.uint16[i+0]=r,this.uint16[i+1]=n,e}};Fn.prototype.bytesPerElement=4;C("StructArrayLayout2ui4",Fn);var go=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(e){let r=this.length;return this.resize(r+1),this.emplace(r,e)}emplace(e,r){let n=e*1;return this.uint16[n+0]=r,e}};go.prototype.bytesPerElement=2;C("StructArrayLayout1ui2",go);var wr=class extends ee{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(e,r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,e,r,n,i)}emplace(e,r,n,i,o){let a=e*4;return this.float32[a+0]=r,this.float32[a+1]=n,this.float32[a+2]=i,this.float32[a+3]=o,e}};wr.prototype.bytesPerElement=16;C("StructArrayLayout4f16",wr);var xo=class extends Pt{get anchorPointX(){return this._structArray.int16[this._pos2+0]}get anchorPointY(){return this._structArray.int16[this._pos2+1]}get x1(){return this._structArray.int16[this._pos2+2]}get y1(){return this._structArray.int16[this._pos2+3]}get x2(){return this._structArray.int16[this._pos2+4]}get y2(){return this._structArray.int16[this._pos2+5]}get featureIndex(){return this._structArray.uint32[this._pos4+3]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+8]}get bucketIndex(){return this._structArray.uint16[this._pos2+9]}get anchorPoint(){return new Cc.default(this.anchorPointX,this.anchorPointY)}};xo.prototype.size=20;var Ln=class extends An{get(e){return new xo(this,e)}};C("CollisionBoxArray",Ln);var bo=class extends Pt{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get glyphStartIndex(){return this._structArray.uint16[this._pos2+2]}get numGlyphs(){return this._structArray.uint16[this._pos2+3]}get vertexStartIndex(){return this._structArray.uint32[this._pos4+2]}get lineStartIndex(){return this._structArray.uint32[this._pos4+3]}get lineLength(){return this._structArray.uint32[this._pos4+4]}get segment(){return this._structArray.uint16[this._pos2+10]}get lowerSize(){return this._structArray.uint16[this._pos2+11]}get upperSize(){return this._structArray.uint16[this._pos2+12]}get lineOffsetX(){return this._structArray.float32[this._pos4+7]}get lineOffsetY(){return this._structArray.float32[this._pos4+8]}get writingMode(){return this._structArray.uint8[this._pos1+36]}get placedOrientation(){return this._structArray.uint8[this._pos1+37]}set placedOrientation(e){this._structArray.uint8[this._pos1+37]=e}get hidden(){return this._structArray.uint8[this._pos1+38]}set hidden(e){this._structArray.uint8[this._pos1+38]=e}get crossTileID(){return this._structArray.uint32[this._pos4+10]}set crossTileID(e){this._structArray.uint32[this._pos4+10]=e}get associatedIconIndex(){return this._structArray.int16[this._pos2+22]}};bo.prototype.size=48;var Dn=class extends Cn{get(e){return new bo(this,e)}};C("PlacedSymbolArray",Dn);var vo=class extends Pt{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get rightJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+2]}get centerJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+3]}get leftJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+4]}get verticalPlacedTextSymbolIndex(){return this._structArray.int16[this._pos2+5]}get placedIconSymbolIndex(){return this._structArray.int16[this._pos2+6]}get verticalPlacedIconSymbolIndex(){return this._structArray.int16[this._pos2+7]}get key(){return this._structArray.uint16[this._pos2+8]}get textBoxStartIndex(){return this._structArray.uint16[this._pos2+9]}get textBoxEndIndex(){return this._structArray.uint16[this._pos2+10]}get verticalTextBoxStartIndex(){return this._structArray.uint16[this._pos2+11]}get verticalTextBoxEndIndex(){return this._structArray.uint16[this._pos2+12]}get iconBoxStartIndex(){return this._structArray.uint16[this._pos2+13]}get iconBoxEndIndex(){return this._structArray.uint16[this._pos2+14]}get verticalIconBoxStartIndex(){return this._structArray.uint16[this._pos2+15]}get verticalIconBoxEndIndex(){return this._structArray.uint16[this._pos2+16]}get featureIndex(){return this._structArray.uint16[this._pos2+17]}get numHorizontalGlyphVertices(){return this._structArray.uint16[this._pos2+18]}get numVerticalGlyphVertices(){return this._structArray.uint16[this._pos2+19]}get numIconVertices(){return this._structArray.uint16[this._pos2+20]}get numVerticalIconVertices(){return this._structArray.uint16[this._pos2+21]}get useRuntimeCollisionCircles(){return this._structArray.uint16[this._pos2+22]}get crossTileID(){return this._structArray.uint32[this._pos4+12]}set crossTileID(e){this._structArray.uint32[this._pos4+12]=e}get textBoxScale(){return this._structArray.float32[this._pos4+13]}get collisionCircleDiameter(){return this._structArray.float32[this._pos4+14]}get textAnchorOffsetStartIndex(){return this._structArray.uint16[this._pos2+30]}get textAnchorOffsetEndIndex(){return this._structArray.uint16[this._pos2+31]}};vo.prototype.size=64;var Vn=class extends kn{get(e){return new vo(this,e)}};C("SymbolInstanceArray",Vn);var Bn=class extends Ht{getoffsetX(e){return this.float32[e*1+0]}};C("GlyphOffsetArray",Bn);var zn=class extends gn{getx(e){return this.int16[e*3+0]}gety(e){return this.int16[e*3+1]}gettileUnitDistanceFromAnchor(e){return this.int16[e*3+2]}};C("SymbolLineVertexArray",zn);var Po=class extends Pt{get textAnchor(){return this._structArray.uint16[this._pos2+0]}get textOffset0(){return this._structArray.float32[this._pos4+1]}get textOffset1(){return this._structArray.float32[this._pos4+2]}};Po.prototype.size=12;var Rn=class extends Mn{get(e){return new Po(this,e)}};C("TextAnchorOffsetArray",Rn);var So=class extends Pt{get featureIndex(){return this._structArray.uint32[this._pos4+0]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+2]}get bucketIndex(){return this._structArray.uint16[this._pos2+3]}};So.prototype.size=8;var On=class extends En{get(e){return new So(this,e)}};C("FeatureIndexArray",On);var wo=class extends Wt{};var Ao=class extends Wt{},_o=class extends Wt{},Io=class extends xn{};var To=class extends bn{},Co=class extends St{},ut=class extends vn{},ko=class extends Pn{},Mo=class extends Sn{},Eo=class extends wn{},Nn=class extends _n{};var Fo=class extends In{};var Le=class extends Tn{},wt=class extends Fn{};var md=Y([{name:"a_pos",components:2,type:"Int16"}],4);var{members:kc,size:$v,alignment:Gv}=md;var me=class t{constructor(e=[]){this.segments=e}prepareSegment(e,r,n,i){let o=this.segments[this.segments.length-1];return e>t.MAX_VERTEX_ARRAY_LENGTH&&fe("Max vertices per segment is ".concat(t.MAX_VERTEX_ARRAY_LENGTH,": bucket requested ").concat(e)),(!o||o.vertexLength+e>t.MAX_VERTEX_ARRAY_LENGTH||o.sortKey!==i)&&(o={vertexOffset:r.length,primitiveOffset:n.length,vertexLength:0,primitiveLength:0},i!==void 0&&(o.sortKey=i),this.segments.push(o)),o}get(){return this.segments}destroy(){for(let e of this.segments)for(let r in e.vaos)e.vaos[r].destroy()}static simpleSegment(e,r,n,i){return new t([{vertexOffset:e,primitiveOffset:r,vertexLength:n,primitiveLength:i,vaos:{},sortKey:0}])}};me.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1;C("SegmentVector",me);function Is(t,e){return t=it(Math.floor(t),0,255),e=it(Math.floor(e),0,255),256*t+e}var Un=Y([{name:"a_pattern_from",components:4,type:"Uint16"},{name:"a_pattern_to",components:4,type:"Uint16"},{name:"a_pixel_ratio_from",components:1,type:"Uint16"},{name:"a_pixel_ratio_to",components:1,type:"Uint16"}]);var Dc=Z(ks(),1);var $n=class t{constructor(){this.ids=[],this.positions=[],this.indexed=!1}add(e,r,n,i){this.ids.push(Lc(e)),this.positions.push(r,n,i)}getPositions(e){if(!this.indexed)throw new Error("Trying to get index, but feature positions are not indexed");let r=Lc(e),n=0,i=this.ids.length-1;for(;n<i;){let a=n+i>>1;this.ids[a]>=r?i=a:n=a+1}let o=[];for(;this.ids[n]===r;){let a=this.positions[3*n],s=this.positions[3*n+1],l=this.positions[3*n+2];o.push({index:a,start:s,end:l}),n++}return o}static serialize(e,r){let n=new Float64Array(e.ids),i=new Uint32Array(e.positions);return Ms(n,i,0,n.length-1),r&&r.push(n.buffer,i.buffer),{ids:n,positions:i}}static deserialize(e){let r=new t;return r.ids=e.ids,r.positions=e.positions,r.indexed=!0,r}};function Lc(t){let e=+t;return!isNaN(e)&&e<=Number.MAX_SAFE_INTEGER?e:(0,Dc.default)(String(t))}function Ms(t,e,r,n){for(;r<n;){let i=t[r+n>>1],o=r-1,a=n+1;for(;;){do o++;while(t[o]<i);do a--;while(t[a]>i);if(o>=a)break;Do(t,o,a),Do(e,3*o,3*a),Do(e,3*o+1,3*a+1),Do(e,3*o+2,3*a+2)}a-r<n-a?(Ms(t,e,r,a),r=a+1):(Ms(t,e,a+1,n),n=a)}}function Do(t,e,r){let n=t[e];t[e]=t[r],t[r]=n}C("FeaturePositionMap",$n);var Gn=class{constructor(e,r){this.gl=e.gl,this.location=r}};var Ar=class extends Gn{constructor(e,r){super(e,r),this.current=0}set(e){this.current!==e&&(this.current=e,this.gl.uniform1f(this.location,e))}};var Vo=class extends Gn{constructor(e,r){super(e,r),this.current=[0,0,0,0]}set(e){(e[0]!==this.current[0]||e[1]!==this.current[1]||e[2]!==this.current[2]||e[3]!==this.current[3])&&(this.current=e,this.gl.uniform4f(this.location,e[0],e[1],e[2],e[3]))}},Bo=class extends Gn{constructor(e,r){super(e,r),this.current=W.transparent}set(e){(e.r!==this.current.r||e.g!==this.current.g||e.b!==this.current.b||e.a!==this.current.a)&&(this.current=e,this.gl.uniform4f(this.location,e.r,e.g,e.b,e.a))}},i1=new Float32Array(16);function Es(t){return[Is(255*t.r,255*t.g),Is(255*t.b,255*t.a)]}var Xt=class{constructor(e,r,n){this.value=e,this.uniformNames=r.map(i=>"u_".concat(i)),this.type=n}setUniform(e,r,n){e.set(n.constantOr(this.value))}getBinding(e,r,n){return this.type==="color"?new Bo(e,r):new Ar(e,r)}},At=class{constructor(e,r){this.uniformNames=r.map(n=>"u_".concat(n)),this.patternFrom=null,this.patternTo=null,this.pixelRatioFrom=1,this.pixelRatioTo=1}setConstantPatternPositions(e,r){this.pixelRatioFrom=r.pixelRatio,this.pixelRatioTo=e.pixelRatio,this.patternFrom=r.tlbr,this.patternTo=e.tlbr}setUniform(e,r,n,i){let o=i==="u_pattern_to"?this.patternTo:i==="u_pattern_from"?this.patternFrom:i==="u_pixel_ratio_to"?this.pixelRatioTo:i==="u_pixel_ratio_from"?this.pixelRatioFrom:null;o&&e.set(o)}getBinding(e,r,n){return n.substr(0,9)==="u_pattern"?new Vo(e,r):new Ar(e,r)}},We=class{constructor(e,r,n,i){this.expression=e,this.type=n,this.maxValue=0,this.paintVertexAttributes=r.map(o=>({name:"a_".concat(o),type:"Float32",components:n==="color"?2:1,offset:0})),this.paintVertexArray=new i}populatePaintArray(e,r,n,i,o){let a=this.paintVertexArray.length,s=this.expression.evaluate(new q(0),r,{},i,[],o);this.paintVertexArray.resize(e),this._setPaintValue(a,e,s)}updatePaintArray(e,r,n,i){let o=this.expression.evaluate({zoom:0},n,i);this._setPaintValue(e,r,o)}_setPaintValue(e,r,n){if(this.type==="color"){let i=Es(n);for(let o=e;o<r;o++)this.paintVertexArray.emplace(o,i[0],i[1])}else{for(let i=e;i<r;i++)this.paintVertexArray.emplace(i,n);this.maxValue=Math.max(this.maxValue,Math.abs(n))}}upload(e){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=e.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}},De=class{constructor(e,r,n,i,o,a){this.expression=e,this.uniformNames=r.map(s=>"u_".concat(s,"_t")),this.type=n,this.useIntegerZoom=i,this.zoom=o,this.maxValue=0,this.paintVertexAttributes=r.map(s=>({name:"a_".concat(s),type:"Float32",components:n==="color"?4:2,offset:0})),this.paintVertexArray=new a}populatePaintArray(e,r,n,i,o){let a=this.expression.evaluate(new q(this.zoom),r,{},i,[],o),s=this.expression.evaluate(new q(this.zoom+1),r,{},i,[],o),l=this.paintVertexArray.length;this.paintVertexArray.resize(e),this._setPaintValue(l,e,a,s)}updatePaintArray(e,r,n,i){let o=this.expression.evaluate({zoom:this.zoom},n,i),a=this.expression.evaluate({zoom:this.zoom+1},n,i);this._setPaintValue(e,r,o,a)}_setPaintValue(e,r,n,i){if(this.type==="color"){let o=Es(n),a=Es(i);for(let s=e;s<r;s++)this.paintVertexArray.emplace(s,o[0],o[1],a[0],a[1])}else{for(let o=e;o<r;o++)this.paintVertexArray.emplace(o,n,i);this.maxValue=Math.max(this.maxValue,Math.abs(n),Math.abs(i))}}upload(e){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=e.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}setUniform(e,r){let n=this.useIntegerZoom?Math.floor(r.zoom):r.zoom,i=it(this.expression.interpolationFactor(n,this.zoom,this.zoom+1),0,1);e.set(i)}getBinding(e,r,n){return new Ar(e,r)}},et=class{constructor(e,r,n,i,o,a){this.expression=e,this.type=r,this.useIntegerZoom=n,this.zoom=i,this.layerId=a,this.zoomInPaintVertexArray=new o,this.zoomOutPaintVertexArray=new o}populatePaintArray(e,r,n){let i=this.zoomInPaintVertexArray.length;this.zoomInPaintVertexArray.resize(e),this.zoomOutPaintVertexArray.resize(e),this._setPaintValues(i,e,r.patterns&&r.patterns[this.layerId],n)}updatePaintArray(e,r,n,i,o){this._setPaintValues(e,r,n.patterns&&n.patterns[this.layerId],o)}_setPaintValues(e,r,n,i){if(!i||!n)return;let{min:o,mid:a,max:s}=n,l=i[o],u=i[a],c=i[s];if(!(!l||!u||!c))for(let p=e;p<r;p++)this.zoomInPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],l.tl[0],l.tl[1],l.br[0],l.br[1],u.pixelRatio,l.pixelRatio),this.zoomOutPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],c.tl[0],c.tl[1],c.br[0],c.br[1],u.pixelRatio,c.pixelRatio)}upload(e){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=e.createVertexBuffer(this.zoomInPaintVertexArray,Un.members,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=e.createVertexBuffer(this.zoomOutPaintVertexArray,Un.members,this.expression.isStateDependent))}destroy(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy()}},zo=class{constructor(e,r,n){this.binders={},this._buffers=[];let i=[];for(let o in e.paint._values){if(!n(o))continue;let a=e.paint.get(o);if(!(a instanceof Se)||!ht(a.property.specification))continue;let s=xd(o,e.type),l=a.value,u=a.property.specification.type,c=a.property.useIntegerZoom,p=a.property.specification["property-type"],f=p==="cross-faded"||p==="cross-faded-data-driven";if(l.kind==="constant")this.binders[o]=f?new At(l.value,s):new Xt(l.value,s,u),i.push("/u_".concat(o));else if(l.kind==="source"||f){let y=Vc(o,u,"source");this.binders[o]=f?new et(l,u,c,r,y,e.id):new We(l,s,u,y),i.push("/a_".concat(o))}else{let y=Vc(o,u,"composite");this.binders[o]=new De(l,s,u,c,r,y),i.push("/z_".concat(o))}}this.cacheKey=i.sort().join("")}getMaxValue(e){let r=this.binders[e];return r instanceof We||r instanceof De?r.maxValue:0}populatePaintArrays(e,r,n,i,o){for(let a in this.binders){let s=this.binders[a];(s instanceof We||s instanceof De||s instanceof et)&&s.populatePaintArray(e,r,n,i,o)}}setConstantPatternPositions(e,r){for(let n in this.binders){let i=this.binders[n];i instanceof At&&i.setConstantPatternPositions(e,r)}}updatePaintArrays(e,r,n,i,o){let a=!1;for(let s in e){let l=r.getPositions(s);for(let u of l){let c=n.feature(u.index);for(let p in this.binders){let f=this.binders[p];if((f instanceof We||f instanceof De||f instanceof et)&&f.expression.isStateDependent===!0){let y=i.paint.get(p);f.expression=y.value,f.updatePaintArray(u.start,u.end,c,e[s],o),a=!0}}}}return a}defines(){let e=[];for(let r in this.binders){let n=this.binders[r];(n instanceof Xt||n instanceof At)&&e.push(...n.uniformNames.map(i=>"#define HAS_UNIFORM_".concat(i)))}return e}getBinderAttributes(){let e=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof We||n instanceof De)for(let i=0;i<n.paintVertexAttributes.length;i++)e.push(n.paintVertexAttributes[i].name);else if(n instanceof et)for(let i=0;i<Un.members.length;i++)e.push(Un.members[i].name)}return e}getBinderUniforms(){let e=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof Xt||n instanceof At||n instanceof De)for(let i of n.uniformNames)e.push(i)}return e}getPaintVertexBuffers(){return this._buffers}getUniforms(e,r){let n=[];for(let i in this.binders){let o=this.binders[i];if(o instanceof Xt||o instanceof At||o instanceof De){for(let a of o.uniformNames)if(r[a]){let s=o.getBinding(e,r[a],a);n.push({name:a,property:i,binding:s})}}}return n}setUniforms(e,r,n,i){for(let{name:o,property:a,binding:s}of r)this.binders[a].setUniform(s,i,n.get(a),o)}updatePaintBuffers(e){this._buffers=[];for(let r in this.binders){let n=this.binders[r];if(e&&n instanceof et){let i=e.fromScale===2?n.zoomInPaintVertexBuffer:n.zoomOutPaintVertexBuffer;i&&this._buffers.push(i)}else(n instanceof We||n instanceof De)&&n.paintVertexBuffer&&this._buffers.push(n.paintVertexBuffer)}}upload(e){for(let r in this.binders){let n=this.binders[r];(n instanceof We||n instanceof De||n instanceof et)&&n.upload(e)}this.updatePaintBuffers()}destroy(){for(let e in this.binders){let r=this.binders[e];(r instanceof We||r instanceof De||r instanceof et)&&r.destroy()}}},Ce=class{constructor(e,r,n=()=>!0){this.programConfigurations={};for(let i of e)this.programConfigurations[i.id]=new zo(i,r,n);this.needsUpload=!1,this._featureMap=new $n,this._bufferOffset=0}populatePaintArrays(e,r,n,i,o,a){for(let s in this.programConfigurations)this.programConfigurations[s].populatePaintArrays(e,r,i,o,a);r.id!==void 0&&this._featureMap.add(r.id,n,this._bufferOffset,e),this._bufferOffset=e,this.needsUpload=!0}updatePaintArrays(e,r,n,i){for(let o of n)this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(e,this._featureMap,r,o,i)||this.needsUpload}get(e){return this.programConfigurations[e]}upload(e){if(this.needsUpload){for(let r in this.programConfigurations)this.programConfigurations[r].upload(e);this.needsUpload=!1}}destroy(){for(let e in this.programConfigurations)this.programConfigurations[e].destroy()}};function xd(t,e){return{"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-extrusion-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"]}[t]||[t.replace("".concat(e,"-"),"").replace(/-/g,"_")]}function bd(t){return{"line-pattern":{source:ut,composite:ut},"fill-pattern":{source:ut,composite:ut},"fill-extrusion-pattern":{source:ut,composite:ut}}[t]}function Vc(t,e,r){let n={color:{source:St,composite:wr},number:{source:Ht,composite:St}},i=bd(t);return i&&i[r]||n[e][r]}C("ConstantBinder",Xt);C("CrossFadedConstantBinder",At);C("SourceExpressionBinder",We);C("CrossFadedCompositeBinder",et);C("CompositeExpressionBinder",De);C("ProgramConfiguration",zo,{omit:["_buffers"]});C("ProgramConfigurationSet",Ce);var vd=15,Fs=Math.pow(2,vd-1)-1,Bc=-Fs-1;function ke(t){let e=8192/t.extent,r=t.loadGeometry();for(let n=0;n<r.length;n++){let i=r[n];for(let o=0;o<i.length;o++){let a=i[o],s=Math.round(a.x*e),l=Math.round(a.y*e);a.x=it(s,Bc,Fs),a.y=it(l,Bc,Fs),(s<a.x||s>a.x+1||l<a.y||l>a.y+1)&&fe("Geometry exceeds allowed extent, reduce your vector tile buffer size")}}return r}function $e(t,e){return{type:t.type,id:t.id,properties:t.properties,geometry:e?ke(t):[]}}function Ro(t,e,r,n,i){t.emplaceBack(e*2+(n+1)/2,r*2+(i+1)/2)}var Kt=class{constructor(e){this.zoom=e.zoom,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.layoutVertexArray=new Ao,this.indexArray=new Le,this.segments=new me,this.programConfigurations=new Ce(e.layers,e.zoom),this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){let i=this.layers[0],o=[],a=null,s=!1;i.type==="circle"&&(a=i.layout.get("circle-sort-key"),s=!a.isConstant());for(let{feature:l,id:u,index:c,sourceLayerIndex:p}of e){let f=this.layers[0]._featureFilter.needGeometry,y=$e(l,f);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),y,n))continue;let m=s?a.evaluate(y,{},n):void 0,h={id:u,properties:l.properties,type:l.type,sourceLayerIndex:p,index:c,geometry:f?y.geometry:ke(l),patterns:{},sortKey:m};o.push(h)}s&&o.sort((l,u)=>l.sortKey-u.sortKey);for(let l of o){let{geometry:u,index:c,sourceLayerIndex:p}=l,f=e[c].feature;this.addFeature(l,u,c,n),r.featureIndex.insert(f,u,c,p,this.index)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,kc),this.indexBuffer=e.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}addFeature(e,r,n,i){for(let o of r)for(let a of o){let s=a.x,l=a.y;if(s<0||s>=8192||l<0||l>=8192)continue;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,e.sortKey),c=u.vertexLength;Ro(this.layoutVertexArray,s,l,-1,-1),Ro(this.layoutVertexArray,s,l,1,-1),Ro(this.layoutVertexArray,s,l,1,1),Ro(this.layoutVertexArray,s,l,-1,1),this.indexArray.emplaceBack(c,c+1,c+2),this.indexArray.emplaceBack(c,c+3,c+2),u.vertexLength+=4,u.primitiveLength+=2}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,{},i)}};C("CircleBucket",Kt,{omit:["layers"]});var qn=Z(he(),1);function Rc(t,e){for(let r=0;r<t.length;r++)if(_r(e,t[r]))return!0;for(let r=0;r<e.length;r++)if(_r(t,e[r]))return!0;return!!Ds(t,e)}function Oc(t,e,r){return!!(_r(t,e)||Ls(e,t,r))}function Oo(t,e){if(t.length===1)return zc(e,t[0]);for(let r=0;r<e.length;r++){let n=e[r];for(let i=0;i<n.length;i++)if(_r(t,n[i]))return!0}for(let r=0;r<t.length;r++)if(zc(e,t[r]))return!0;for(let r=0;r<e.length;r++)if(Ds(t,e[r]))return!0;return!1}function Nc(t,e,r){for(let n=0;n<e.length;n++){let i=e[n];if(t.length>=3){for(let o=0;o<i.length;o++)if(_r(t,i[o]))return!0}if(Pd(t,i,r))return!0}return!1}function Pd(t,e,r){if(t.length>1){if(Ds(t,e))return!0;for(let n=0;n<e.length;n++)if(Ls(e[n],t,r))return!0}for(let n=0;n<t.length;n++)if(Ls(t[n],e,r))return!0;return!1}function Ds(t,e){if(t.length===0||e.length===0)return!1;for(let r=0;r<t.length-1;r++){let n=t[r],i=t[r+1];for(let o=0;o<e.length-1;o++){let a=e[o],s=e[o+1];if(Sd(n,i,a,s))return!0}}return!1}function Sd(t,e,r,n){return ot(t,r,n)!==ot(e,r,n)&&ot(t,e,r)!==ot(t,e,n)}function Ls(t,e,r){let n=r*r;if(e.length===1)return t.distSqr(e[0])<n;for(let i=1;i<e.length;i++){let o=e[i-1],a=e[i];if(Vs(t,o,a)<n)return!0}return!1}function Vs(t,e,r){let n=e.distSqr(r);if(n===0)return t.distSqr(e);let i=((t.x-e.x)*(r.x-e.x)+(t.y-e.y)*(r.y-e.y))/n;return i<0?t.distSqr(e):i>1?t.distSqr(r):t.distSqr(r.sub(e)._mult(i)._add(e))}function zc(t,e){let r=!1,n,i,o;for(let a=0;a<t.length;a++){n=t[a];for(let s=0,l=n.length-1;s<n.length;l=s++)i=n[s],o=n[l],i.y>e.y!=o.y>e.y&&e.x<(o.x-i.x)*(e.y-i.y)/(o.y-i.y)+i.x&&(r=!r)}return r}function _r(t,e){let r=!1;for(let n=0,i=t.length-1;n<t.length;i=n++){let o=t[n],a=t[i];o.y>e.y!=a.y>e.y&&e.x<(a.x-o.x)*(e.y-o.y)/(a.y-o.y)+o.x&&(r=!r)}return r}function Uc(t,e,r,n,i){for(let a of t)if(e<=a.x&&r<=a.y&&n>=a.x&&i>=a.y)return!0;let o=[new qn.default(e,r),new qn.default(e,i),new qn.default(n,i),new qn.default(n,r)];if(t.length>2){for(let a of o)if(_r(t,a))return!0}for(let a=0;a<t.length-1;a++){let s=t[a],l=t[a+1];if(wd(s,l,o))return!0}return!1}function wd(t,e,r){let n=r[0],i=r[2];if(t.x<n.x&&e.x<n.x||t.x>i.x&&e.x>i.x||t.y<n.y&&e.y<n.y||t.y>i.y&&e.y>i.y)return!1;let o=ot(t,e,r[0]);return o!==ot(t,e,r[1])||o!==ot(t,e,r[2])||o!==ot(t,e,r[3])}var No=Z(he(),1);function Yt(t,e,r){let n=e.paint.get(t).value;return n.kind==="constant"?n.value:r.programConfigurations.get(e.id).getMaxValue(t)}function _t(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function It(t,e,r,n,i){if(!e[0]&&!e[1])return t;let o=No.default.convert(e)._mult(i);r==="viewport"&&o._rotate(-n);let a=[];for(let s=0;s<t.length;s++){let l=t[s];a.push(l.sub(o))}return a}function $c(t,e){let r=[];for(let n=0;n<t.length;n++){let i=t[n],o=[];for(let a=0;a<i.length;a++){let s=i[a-1],l=i[a],u=i[a+1],c=a===0?new No.default(0,0):l.sub(s)._unit()._perp(),p=a===i.length-1?new No.default(0,0):u.sub(l)._unit()._perp(),f=c._add(p)._unit(),y=f.x*p.x+f.y*p.y;y!==0&&f._mult(1/y),o.push(f._mult(e)._add(l))}r.push(o)}return r}var Gc,Ad=()=>Gc=Gc||new re({"circle-sort-key":new R(S.layout_circle["circle-sort-key"])}),qc,_d=()=>qc=qc||new re({"circle-radius":new R(S.paint_circle["circle-radius"]),"circle-color":new R(S.paint_circle["circle-color"]),"circle-blur":new R(S.paint_circle["circle-blur"]),"circle-opacity":new R(S.paint_circle["circle-opacity"]),"circle-translate":new B(S.paint_circle["circle-translate"]),"circle-translate-anchor":new B(S.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new B(S.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new B(S.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new R(S.paint_circle["circle-stroke-width"]),"circle-stroke-color":new R(S.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new R(S.paint_circle["circle-stroke-opacity"])}),jc={get paint(){return _d()},get layout(){return Ad()}};var Q=1e-6,Ge=typeof Float32Array<"u"?Float32Array:Array,jn=Math.random;var X1=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var Jn={};Ol(Jn,{add:()=>ug,adjoint:()=>Ld,clone:()=>Td,copy:()=>Cd,create:()=>Id,determinant:()=>Dd,equals:()=>yg,exactEquals:()=>fg,frob:()=>lg,fromQuat:()=>Yd,fromQuat2:()=>Zd,fromRotation:()=>Gd,fromRotationTranslation:()=>Hc,fromRotationTranslationScale:()=>Xd,fromRotationTranslationScaleOrigin:()=>Kd,fromScaling:()=>$d,fromTranslation:()=>Ud,fromValues:()=>kd,fromXRotation:()=>qd,fromYRotation:()=>jd,fromZRotation:()=>Jd,frustum:()=>Qd,getRotation:()=>Hd,getScaling:()=>Xc,getTranslation:()=>Wd,identity:()=>Zc,invert:()=>Fd,lookAt:()=>og,mul:()=>mg,multiply:()=>Wc,multiplyScalar:()=>cg,multiplyScalarAndAdd:()=>pg,ortho:()=>ng,orthoNO:()=>Yc,orthoZO:()=>ig,perspective:()=>eg,perspectiveFromFieldOfView:()=>rg,perspectiveNO:()=>Kc,perspectiveZO:()=>tg,rotate:()=>zd,rotateX:()=>Rd,rotateY:()=>Od,rotateZ:()=>Nd,scale:()=>Bd,set:()=>Md,str:()=>sg,sub:()=>hg,subtract:()=>Qc,targetTo:()=>ag,translate:()=>Vd,transpose:()=>Ed});function Id(){var t=new Ge(16);return Ge!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function Td(t){var e=new Ge(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function Cd(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function kd(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h){var d=new Ge(16);return d[0]=t,d[1]=e,d[2]=r,d[3]=n,d[4]=i,d[5]=o,d[6]=a,d[7]=s,d[8]=l,d[9]=u,d[10]=c,d[11]=p,d[12]=f,d[13]=y,d[14]=m,d[15]=h,d}function Md(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t[4]=o,t[5]=a,t[6]=s,t[7]=l,t[8]=u,t[9]=c,t[10]=p,t[11]=f,t[12]=y,t[13]=m,t[14]=h,t[15]=d,t}function Zc(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Ed(t,e){if(t===e){var r=e[1],n=e[2],i=e[3],o=e[6],a=e[7],s=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=r,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=o,t[11]=e[14],t[12]=i,t[13]=a,t[14]=s}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function Fd(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=e[4],s=e[5],l=e[6],u=e[7],c=e[8],p=e[9],f=e[10],y=e[11],m=e[12],h=e[13],d=e[14],g=e[15],b=r*s-n*a,x=r*l-i*a,v=r*u-o*a,P=n*l-i*s,w=n*u-o*s,T=i*u-o*l,F=c*h-p*m,E=c*d-f*m,_=c*g-y*m,I=p*d-f*h,k=p*g-y*h,V=f*g-y*d,A=b*V-x*k+v*I+P*_-w*E+T*F;return A?(A=1/A,t[0]=(s*V-l*k+u*I)*A,t[1]=(i*k-n*V-o*I)*A,t[2]=(h*T-d*w+g*P)*A,t[3]=(f*w-p*T-y*P)*A,t[4]=(l*_-a*V-u*E)*A,t[5]=(r*V-i*_+o*E)*A,t[6]=(d*v-m*T-g*x)*A,t[7]=(c*T-f*v+y*x)*A,t[8]=(a*k-s*_+u*F)*A,t[9]=(n*_-r*k-o*F)*A,t[10]=(m*w-h*v+g*b)*A,t[11]=(p*v-c*w-y*b)*A,t[12]=(s*E-a*I-l*F)*A,t[13]=(r*I-n*E+i*F)*A,t[14]=(h*x-m*P-d*b)*A,t[15]=(c*P-p*x+f*b)*A,t):null}function Ld(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=e[4],s=e[5],l=e[6],u=e[7],c=e[8],p=e[9],f=e[10],y=e[11],m=e[12],h=e[13],d=e[14],g=e[15];return t[0]=s*(f*g-y*d)-p*(l*g-u*d)+h*(l*y-u*f),t[1]=-(n*(f*g-y*d)-p*(i*g-o*d)+h*(i*y-o*f)),t[2]=n*(l*g-u*d)-s*(i*g-o*d)+h*(i*u-o*l),t[3]=-(n*(l*y-u*f)-s*(i*y-o*f)+p*(i*u-o*l)),t[4]=-(a*(f*g-y*d)-c*(l*g-u*d)+m*(l*y-u*f)),t[5]=r*(f*g-y*d)-c*(i*g-o*d)+m*(i*y-o*f),t[6]=-(r*(l*g-u*d)-a*(i*g-o*d)+m*(i*u-o*l)),t[7]=r*(l*y-u*f)-a*(i*y-o*f)+c*(i*u-o*l),t[8]=a*(p*g-y*h)-c*(s*g-u*h)+m*(s*y-u*p),t[9]=-(r*(p*g-y*h)-c*(n*g-o*h)+m*(n*y-o*p)),t[10]=r*(s*g-u*h)-a*(n*g-o*h)+m*(n*u-o*s),t[11]=-(r*(s*y-u*p)-a*(n*y-o*p)+c*(n*u-o*s)),t[12]=-(a*(p*d-f*h)-c*(s*d-l*h)+m*(s*f-l*p)),t[13]=r*(p*d-f*h)-c*(n*d-i*h)+m*(n*f-i*p),t[14]=-(r*(s*d-l*h)-a*(n*d-i*h)+m*(n*l-i*s)),t[15]=r*(s*f-l*p)-a*(n*f-i*p)+c*(n*l-i*s),t}function Dd(t){var e=t[0],r=t[1],n=t[2],i=t[3],o=t[4],a=t[5],s=t[6],l=t[7],u=t[8],c=t[9],p=t[10],f=t[11],y=t[12],m=t[13],h=t[14],d=t[15],g=e*a-r*o,b=e*s-n*o,x=e*l-i*o,v=r*s-n*a,P=r*l-i*a,w=n*l-i*s,T=u*m-c*y,F=u*h-p*y,E=u*d-f*y,_=c*h-p*m,I=c*d-f*m,k=p*d-f*h;return g*k-b*I+x*_+v*E-P*F+w*T}function Wc(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=e[4],l=e[5],u=e[6],c=e[7],p=e[8],f=e[9],y=e[10],m=e[11],h=e[12],d=e[13],g=e[14],b=e[15],x=r[0],v=r[1],P=r[2],w=r[3];return t[0]=x*n+v*s+P*p+w*h,t[1]=x*i+v*l+P*f+w*d,t[2]=x*o+v*u+P*y+w*g,t[3]=x*a+v*c+P*m+w*b,x=r[4],v=r[5],P=r[6],w=r[7],t[4]=x*n+v*s+P*p+w*h,t[5]=x*i+v*l+P*f+w*d,t[6]=x*o+v*u+P*y+w*g,t[7]=x*a+v*c+P*m+w*b,x=r[8],v=r[9],P=r[10],w=r[11],t[8]=x*n+v*s+P*p+w*h,t[9]=x*i+v*l+P*f+w*d,t[10]=x*o+v*u+P*y+w*g,t[11]=x*a+v*c+P*m+w*b,x=r[12],v=r[13],P=r[14],w=r[15],t[12]=x*n+v*s+P*p+w*h,t[13]=x*i+v*l+P*f+w*d,t[14]=x*o+v*u+P*y+w*g,t[15]=x*a+v*c+P*m+w*b,t}function Vd(t,e,r){var n=r[0],i=r[1],o=r[2],a,s,l,u,c,p,f,y,m,h,d,g;return e===t?(t[12]=e[0]*n+e[4]*i+e[8]*o+e[12],t[13]=e[1]*n+e[5]*i+e[9]*o+e[13],t[14]=e[2]*n+e[6]*i+e[10]*o+e[14],t[15]=e[3]*n+e[7]*i+e[11]*o+e[15]):(a=e[0],s=e[1],l=e[2],u=e[3],c=e[4],p=e[5],f=e[6],y=e[7],m=e[8],h=e[9],d=e[10],g=e[11],t[0]=a,t[1]=s,t[2]=l,t[3]=u,t[4]=c,t[5]=p,t[6]=f,t[7]=y,t[8]=m,t[9]=h,t[10]=d,t[11]=g,t[12]=a*n+c*i+m*o+e[12],t[13]=s*n+p*i+h*o+e[13],t[14]=l*n+f*i+d*o+e[14],t[15]=u*n+y*i+g*o+e[15]),t}function Bd(t,e,r){var n=r[0],i=r[1],o=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=e[7]*i,t[8]=e[8]*o,t[9]=e[9]*o,t[10]=e[10]*o,t[11]=e[11]*o,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function zd(t,e,r,n){var i=n[0],o=n[1],a=n[2],s=Math.hypot(i,o,a),l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F,E,_,I,k,V,A,z;return s<Q?null:(s=1/s,i*=s,o*=s,a*=s,l=Math.sin(r),u=Math.cos(r),c=1-u,p=e[0],f=e[1],y=e[2],m=e[3],h=e[4],d=e[5],g=e[6],b=e[7],x=e[8],v=e[9],P=e[10],w=e[11],T=i*i*c+u,F=o*i*c+a*l,E=a*i*c-o*l,_=i*o*c-a*l,I=o*o*c+u,k=a*o*c+i*l,V=i*a*c+o*l,A=o*a*c-i*l,z=a*a*c+u,t[0]=p*T+h*F+x*E,t[1]=f*T+d*F+v*E,t[2]=y*T+g*F+P*E,t[3]=m*T+b*F+w*E,t[4]=p*_+h*I+x*k,t[5]=f*_+d*I+v*k,t[6]=y*_+g*I+P*k,t[7]=m*_+b*I+w*k,t[8]=p*V+h*A+x*z,t[9]=f*V+d*A+v*z,t[10]=y*V+g*A+P*z,t[11]=m*V+b*A+w*z,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)}function Rd(t,e,r){var n=Math.sin(r),i=Math.cos(r),o=e[4],a=e[5],s=e[6],l=e[7],u=e[8],c=e[9],p=e[10],f=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=o*i+u*n,t[5]=a*i+c*n,t[6]=s*i+p*n,t[7]=l*i+f*n,t[8]=u*i-o*n,t[9]=c*i-a*n,t[10]=p*i-s*n,t[11]=f*i-l*n,t}function Od(t,e,r){var n=Math.sin(r),i=Math.cos(r),o=e[0],a=e[1],s=e[2],l=e[3],u=e[8],c=e[9],p=e[10],f=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=o*i-u*n,t[1]=a*i-c*n,t[2]=s*i-p*n,t[3]=l*i-f*n,t[8]=o*n+u*i,t[9]=a*n+c*i,t[10]=s*n+p*i,t[11]=l*n+f*i,t}function Nd(t,e,r){var n=Math.sin(r),i=Math.cos(r),o=e[0],a=e[1],s=e[2],l=e[3],u=e[4],c=e[5],p=e[6],f=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=o*i+u*n,t[1]=a*i+c*n,t[2]=s*i+p*n,t[3]=l*i+f*n,t[4]=u*i-o*n,t[5]=c*i-a*n,t[6]=p*i-s*n,t[7]=f*i-l*n,t}function Ud(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function $d(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Gd(t,e,r){var n=r[0],i=r[1],o=r[2],a=Math.hypot(n,i,o),s,l,u;return a<Q?null:(a=1/a,n*=a,i*=a,o*=a,s=Math.sin(e),l=Math.cos(e),u=1-l,t[0]=n*n*u+l,t[1]=i*n*u+o*s,t[2]=o*n*u-i*s,t[3]=0,t[4]=n*i*u-o*s,t[5]=i*i*u+l,t[6]=o*i*u+n*s,t[7]=0,t[8]=n*o*u+i*s,t[9]=i*o*u-n*s,t[10]=o*o*u+l,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function qd(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function jd(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Jd(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Hc(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3],s=n+n,l=i+i,u=o+o,c=n*s,p=n*l,f=n*u,y=i*l,m=i*u,h=o*u,d=a*s,g=a*l,b=a*u;return t[0]=1-(y+h),t[1]=p+b,t[2]=f-g,t[3]=0,t[4]=p-b,t[5]=1-(c+h),t[6]=m+d,t[7]=0,t[8]=f+g,t[9]=m-d,t[10]=1-(c+y),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function Zd(t,e){var r=new Ge(3),n=-e[0],i=-e[1],o=-e[2],a=e[3],s=e[4],l=e[5],u=e[6],c=e[7],p=n*n+i*i+o*o+a*a;return p>0?(r[0]=(s*a+c*n+l*o-u*i)*2/p,r[1]=(l*a+c*i+u*n-s*o)*2/p,r[2]=(u*a+c*o+s*i-l*n)*2/p):(r[0]=(s*a+c*n+l*o-u*i)*2,r[1]=(l*a+c*i+u*n-s*o)*2,r[2]=(u*a+c*o+s*i-l*n)*2),Hc(t,e,r),t}function Wd(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}function Xc(t,e){var r=e[0],n=e[1],i=e[2],o=e[4],a=e[5],s=e[6],l=e[8],u=e[9],c=e[10];return t[0]=Math.hypot(r,n,i),t[1]=Math.hypot(o,a,s),t[2]=Math.hypot(l,u,c),t}function Hd(t,e){var r=new Ge(3);Xc(r,e);var n=1/r[0],i=1/r[1],o=1/r[2],a=e[0]*n,s=e[1]*i,l=e[2]*o,u=e[4]*n,c=e[5]*i,p=e[6]*o,f=e[8]*n,y=e[9]*i,m=e[10]*o,h=a+c+m,d=0;return h>0?(d=Math.sqrt(h+1)*2,t[3]=.25*d,t[0]=(p-y)/d,t[1]=(f-l)/d,t[2]=(s-u)/d):a>c&&a>m?(d=Math.sqrt(1+a-c-m)*2,t[3]=(p-y)/d,t[0]=.25*d,t[1]=(s+u)/d,t[2]=(f+l)/d):c>m?(d=Math.sqrt(1+c-a-m)*2,t[3]=(f-l)/d,t[0]=(s+u)/d,t[1]=.25*d,t[2]=(p+y)/d):(d=Math.sqrt(1+m-a-c)*2,t[3]=(s-u)/d,t[0]=(f+l)/d,t[1]=(p+y)/d,t[2]=.25*d),t}function Xd(t,e,r,n){var i=e[0],o=e[1],a=e[2],s=e[3],l=i+i,u=o+o,c=a+a,p=i*l,f=i*u,y=i*c,m=o*u,h=o*c,d=a*c,g=s*l,b=s*u,x=s*c,v=n[0],P=n[1],w=n[2];return t[0]=(1-(m+d))*v,t[1]=(f+x)*v,t[2]=(y-b)*v,t[3]=0,t[4]=(f-x)*P,t[5]=(1-(p+d))*P,t[6]=(h+g)*P,t[7]=0,t[8]=(y+b)*w,t[9]=(h-g)*w,t[10]=(1-(p+m))*w,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function Kd(t,e,r,n,i){var o=e[0],a=e[1],s=e[2],l=e[3],u=o+o,c=a+a,p=s+s,f=o*u,y=o*c,m=o*p,h=a*c,d=a*p,g=s*p,b=l*u,x=l*c,v=l*p,P=n[0],w=n[1],T=n[2],F=i[0],E=i[1],_=i[2],I=(1-(h+g))*P,k=(y+v)*P,V=(m-x)*P,A=(y-v)*w,z=(1-(f+g))*w,O=(d+b)*w,N=(m+x)*T,K=(d-b)*T,xe=(1-(f+h))*T;return t[0]=I,t[1]=k,t[2]=V,t[3]=0,t[4]=A,t[5]=z,t[6]=O,t[7]=0,t[8]=N,t[9]=K,t[10]=xe,t[11]=0,t[12]=r[0]+F-(I*F+A*E+N*_),t[13]=r[1]+E-(k*F+z*E+K*_),t[14]=r[2]+_-(V*F+O*E+xe*_),t[15]=1,t}function Yd(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=r+r,s=n+n,l=i+i,u=r*a,c=n*a,p=n*s,f=i*a,y=i*s,m=i*l,h=o*a,d=o*s,g=o*l;return t[0]=1-p-m,t[1]=c+g,t[2]=f-d,t[3]=0,t[4]=c-g,t[5]=1-u-m,t[6]=y+h,t[7]=0,t[8]=f+d,t[9]=y-h,t[10]=1-u-p,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Qd(t,e,r,n,i,o,a){var s=1/(r-e),l=1/(i-n),u=1/(o-a);return t[0]=o*2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o*2*l,t[6]=0,t[7]=0,t[8]=(r+e)*s,t[9]=(i+n)*l,t[10]=(a+o)*u,t[11]=-1,t[12]=0,t[13]=0,t[14]=a*o*2*u,t[15]=0,t}function Kc(t,e,r,n,i){var o=1/Math.tan(e/2),a;return t[0]=o/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,i!=null&&i!==1/0?(a=1/(n-i),t[10]=(i+n)*a,t[14]=2*i*n*a):(t[10]=-1,t[14]=-2*n),t}var eg=Kc;function tg(t,e,r,n,i){var o=1/Math.tan(e/2),a;return t[0]=o/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,i!=null&&i!==1/0?(a=1/(n-i),t[10]=i*a,t[14]=i*n*a):(t[10]=-1,t[14]=-n),t}function rg(t,e,r,n){var i=Math.tan(e.upDegrees*Math.PI/180),o=Math.tan(e.downDegrees*Math.PI/180),a=Math.tan(e.leftDegrees*Math.PI/180),s=Math.tan(e.rightDegrees*Math.PI/180),l=2/(a+s),u=2/(i+o);return t[0]=l,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=-((a-s)*l*.5),t[9]=(i-o)*u*.5,t[10]=n/(r-n),t[11]=-1,t[12]=0,t[13]=0,t[14]=n*r/(r-n),t[15]=0,t}function Yc(t,e,r,n,i,o,a){var s=1/(e-r),l=1/(n-i),u=1/(o-a);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*u,t[11]=0,t[12]=(e+r)*s,t[13]=(i+n)*l,t[14]=(a+o)*u,t[15]=1,t}var ng=Yc;function ig(t,e,r,n,i,o,a){var s=1/(e-r),l=1/(n-i),u=1/(o-a);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=u,t[11]=0,t[12]=(e+r)*s,t[13]=(i+n)*l,t[14]=o*u,t[15]=1,t}function og(t,e,r,n){var i,o,a,s,l,u,c,p,f,y,m=e[0],h=e[1],d=e[2],g=n[0],b=n[1],x=n[2],v=r[0],P=r[1],w=r[2];return Math.abs(m-v)<Q&&Math.abs(h-P)<Q&&Math.abs(d-w)<Q?Zc(t):(c=m-v,p=h-P,f=d-w,y=1/Math.hypot(c,p,f),c*=y,p*=y,f*=y,i=b*f-x*p,o=x*c-g*f,a=g*p-b*c,y=Math.hypot(i,o,a),y?(y=1/y,i*=y,o*=y,a*=y):(i=0,o=0,a=0),s=p*a-f*o,l=f*i-c*a,u=c*o-p*i,y=Math.hypot(s,l,u),y?(y=1/y,s*=y,l*=y,u*=y):(s=0,l=0,u=0),t[0]=i,t[1]=s,t[2]=c,t[3]=0,t[4]=o,t[5]=l,t[6]=p,t[7]=0,t[8]=a,t[9]=u,t[10]=f,t[11]=0,t[12]=-(i*m+o*h+a*d),t[13]=-(s*m+l*h+u*d),t[14]=-(c*m+p*h+f*d),t[15]=1,t)}function ag(t,e,r,n){var i=e[0],o=e[1],a=e[2],s=n[0],l=n[1],u=n[2],c=i-r[0],p=o-r[1],f=a-r[2],y=c*c+p*p+f*f;y>0&&(y=1/Math.sqrt(y),c*=y,p*=y,f*=y);var m=l*f-u*p,h=u*c-s*f,d=s*p-l*c;return y=m*m+h*h+d*d,y>0&&(y=1/Math.sqrt(y),m*=y,h*=y,d*=y),t[0]=m,t[1]=h,t[2]=d,t[3]=0,t[4]=p*d-f*h,t[5]=f*m-c*d,t[6]=c*h-p*m,t[7]=0,t[8]=c,t[9]=p,t[10]=f,t[11]=0,t[12]=i,t[13]=o,t[14]=a,t[15]=1,t}function sg(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"}function lg(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}function ug(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t[6]=e[6]+r[6],t[7]=e[7]+r[7],t[8]=e[8]+r[8],t[9]=e[9]+r[9],t[10]=e[10]+r[10],t[11]=e[11]+r[11],t[12]=e[12]+r[12],t[13]=e[13]+r[13],t[14]=e[14]+r[14],t[15]=e[15]+r[15],t}function Qc(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t[6]=e[6]-r[6],t[7]=e[7]-r[7],t[8]=e[8]-r[8],t[9]=e[9]-r[9],t[10]=e[10]-r[10],t[11]=e[11]-r[11],t[12]=e[12]-r[12],t[13]=e[13]-r[13],t[14]=e[14]-r[14],t[15]=e[15]-r[15],t}function cg(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*r,t[9]=e[9]*r,t[10]=e[10]*r,t[11]=e[11]*r,t[12]=e[12]*r,t[13]=e[13]*r,t[14]=e[14]*r,t[15]=e[15]*r,t}function pg(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t[6]=e[6]+r[6]*n,t[7]=e[7]+r[7]*n,t[8]=e[8]+r[8]*n,t[9]=e[9]+r[9]*n,t[10]=e[10]+r[10]*n,t[11]=e[11]+r[11]*n,t[12]=e[12]+r[12]*n,t[13]=e[13]+r[13]*n,t[14]=e[14]+r[14]*n,t[15]=e[15]+r[15]*n,t}function fg(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]}function yg(t,e){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],u=t[7],c=t[8],p=t[9],f=t[10],y=t[11],m=t[12],h=t[13],d=t[14],g=t[15],b=e[0],x=e[1],v=e[2],P=e[3],w=e[4],T=e[5],F=e[6],E=e[7],_=e[8],I=e[9],k=e[10],V=e[11],A=e[12],z=e[13],O=e[14],N=e[15];return Math.abs(r-b)<=Q*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(n-x)<=Q*Math.max(1,Math.abs(n),Math.abs(x))&&Math.abs(i-v)<=Q*Math.max(1,Math.abs(i),Math.abs(v))&&Math.abs(o-P)<=Q*Math.max(1,Math.abs(o),Math.abs(P))&&Math.abs(a-w)<=Q*Math.max(1,Math.abs(a),Math.abs(w))&&Math.abs(s-T)<=Q*Math.max(1,Math.abs(s),Math.abs(T))&&Math.abs(l-F)<=Q*Math.max(1,Math.abs(l),Math.abs(F))&&Math.abs(u-E)<=Q*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(c-_)<=Q*Math.max(1,Math.abs(c),Math.abs(_))&&Math.abs(p-I)<=Q*Math.max(1,Math.abs(p),Math.abs(I))&&Math.abs(f-k)<=Q*Math.max(1,Math.abs(f),Math.abs(k))&&Math.abs(y-V)<=Q*Math.max(1,Math.abs(y),Math.abs(V))&&Math.abs(m-A)<=Q*Math.max(1,Math.abs(m),Math.abs(A))&&Math.abs(h-z)<=Q*Math.max(1,Math.abs(h),Math.abs(z))&&Math.abs(d-O)<=Q*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(g-N)<=Q*Math.max(1,Math.abs(g),Math.abs(N))}var mg=Wc,hg=Qc;var Qt={};Ol(Qt,{add:()=>vg,ceil:()=>Pg,clone:()=>dg,copy:()=>xg,create:()=>ep,cross:()=>Fg,dist:()=>qg,distance:()=>ip,div:()=>Gg,divide:()=>np,dot:()=>Eg,equals:()=>Ng,exactEquals:()=>Og,floor:()=>Sg,forEach:()=>Wg,fromValues:()=>gg,inverse:()=>kg,len:()=>Jg,length:()=>ap,lerp:()=>Lg,max:()=>Ag,min:()=>wg,mul:()=>$g,multiply:()=>rp,negate:()=>Cg,normalize:()=>Mg,random:()=>Dg,round:()=>_g,scale:()=>Ig,scaleAndAdd:()=>Tg,set:()=>bg,sqrDist:()=>jg,sqrLen:()=>Zg,squaredDistance:()=>op,squaredLength:()=>sp,str:()=>Rg,sub:()=>Ug,subtract:()=>tp,transformMat4:()=>Vg,transformQuat:()=>Bg,zero:()=>zg});function ep(){var t=new Ge(4);return Ge!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function dg(t){var e=new Ge(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function gg(t,e,r,n){var i=new Ge(4);return i[0]=t,i[1]=e,i[2]=r,i[3]=n,i}function xg(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function bg(t,e,r,n,i){return t[0]=e,t[1]=r,t[2]=n,t[3]=i,t}function vg(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t}function tp(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t}function rp(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t[3]=e[3]*r[3],t}function np(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t[3]=e[3]/r[3],t}function Pg(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t[3]=Math.ceil(e[3]),t}function Sg(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t[3]=Math.floor(e[3]),t}function wg(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t[3]=Math.min(e[3],r[3]),t}function Ag(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t[3]=Math.max(e[3],r[3]),t}function _g(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t[3]=Math.round(e[3]),t}function Ig(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function Tg(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t}function ip(t,e){var r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return Math.hypot(r,n,i,o)}function op(t,e){var r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return r*r+n*n+i*i+o*o}function ap(t){var e=t[0],r=t[1],n=t[2],i=t[3];return Math.hypot(e,r,n,i)}function sp(t){var e=t[0],r=t[1],n=t[2],i=t[3];return e*e+r*r+n*n+i*i}function Cg(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t}function kg(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t[3]=1/e[3],t}function Mg(t,e){var r=e[0],n=e[1],i=e[2],o=e[3],a=r*r+n*n+i*i+o*o;return a>0&&(a=1/Math.sqrt(a)),t[0]=r*a,t[1]=n*a,t[2]=i*a,t[3]=o*a,t}function Eg(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}function Fg(t,e,r,n){var i=r[0]*n[1]-r[1]*n[0],o=r[0]*n[2]-r[2]*n[0],a=r[0]*n[3]-r[3]*n[0],s=r[1]*n[2]-r[2]*n[1],l=r[1]*n[3]-r[3]*n[1],u=r[2]*n[3]-r[3]*n[2],c=e[0],p=e[1],f=e[2],y=e[3];return t[0]=p*u-f*l+y*s,t[1]=-(c*u)+f*a-y*o,t[2]=c*l-p*a+y*i,t[3]=-(c*s)+p*o-f*i,t}function Lg(t,e,r,n){var i=e[0],o=e[1],a=e[2],s=e[3];return t[0]=i+n*(r[0]-i),t[1]=o+n*(r[1]-o),t[2]=a+n*(r[2]-a),t[3]=s+n*(r[3]-s),t}function Dg(t,e){e=e||1;var r,n,i,o,a,s;do r=jn()*2-1,n=jn()*2-1,a=r*r+n*n;while(a>=1);do i=jn()*2-1,o=jn()*2-1,s=i*i+o*o;while(s>=1);var l=Math.sqrt((1-a)/s);return t[0]=e*r,t[1]=e*n,t[2]=e*i*l,t[3]=e*o*l,t}function Vg(t,e,r){var n=e[0],i=e[1],o=e[2],a=e[3];return t[0]=r[0]*n+r[4]*i+r[8]*o+r[12]*a,t[1]=r[1]*n+r[5]*i+r[9]*o+r[13]*a,t[2]=r[2]*n+r[6]*i+r[10]*o+r[14]*a,t[3]=r[3]*n+r[7]*i+r[11]*o+r[15]*a,t}function Bg(t,e,r){var n=e[0],i=e[1],o=e[2],a=r[0],s=r[1],l=r[2],u=r[3],c=u*n+s*o-l*i,p=u*i+l*n-a*o,f=u*o+a*i-s*n,y=-a*n-s*i-l*o;return t[0]=c*u+y*-a+p*-l-f*-s,t[1]=p*u+y*-s+f*-a-c*-l,t[2]=f*u+y*-l+c*-s-p*-a,t[3]=e[3],t}function zg(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}function Rg(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"}function Og(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function Ng(t,e){var r=t[0],n=t[1],i=t[2],o=t[3],a=e[0],s=e[1],l=e[2],u=e[3];return Math.abs(r-a)<=Q*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=Q*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-l)<=Q*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(o-u)<=Q*Math.max(1,Math.abs(o),Math.abs(u))}var Ug=tp,$g=rp,Gg=np,qg=ip,jg=op,Jg=ap,Zg=sp,Wg=function(){var t=ep();return function(e,r,n,i,o,a){var s,l;for(r||(r=4),n||(n=0),i?l=Math.min(i*r+n,e.length):l=e.length,s=n;s<l;s+=r)t[0]=e[s],t[1]=e[s+1],t[2]=e[s+2],t[3]=e[s+3],o(t,t,a),e[s]=t[0],e[s+1]=t[1],e[s+2]=t[2],e[s+3]=t[3];return e}}();var lp=Z(he(),1),Uo=class extends se{constructor(e){super(e,jc)}createBucket(e){return new Kt(e)}queryRadius(e){let r=e;return Yt("circle-radius",this,r)+Yt("circle-stroke-width",this,r)+_t(this.paint.get("circle-translate"))}queryIntersectsFeature(e,r,n,i,o,a,s,l){let u=It(e,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),a.angle,s),c=this.paint.get("circle-radius").evaluate(r,n),p=this.paint.get("circle-stroke-width").evaluate(r,n),f=c+p,y=this.paint.get("circle-pitch-alignment")==="map",m=y?u:Hg(u,l),h=y?f*s:f;for(let d of i)for(let g of d){let b=y?g:up(g,l),x=h,v=Qt.transformMat4([],[g.x,g.y,0,1],l);if(this.paint.get("circle-pitch-scale")==="viewport"&&this.paint.get("circle-pitch-alignment")==="map"?x*=v[3]/a.cameraToCenterDistance:this.paint.get("circle-pitch-scale")==="map"&&this.paint.get("circle-pitch-alignment")==="viewport"&&(x*=a.cameraToCenterDistance/v[3]),Oc(m,b,x))return!0}return!1}};function up(t,e){let r=Qt.transformMat4([],[t.x,t.y,0,1],e);return new lp.default(r[0]/r[3],r[1]/r[3])}function Hg(t,e){return t.map(r=>up(r,e))}var Zn=class extends Kt{};C("HeatmapBucket",Zn,{omit:["layers"]});var cp,Xg=()=>cp=cp||new re({"heatmap-radius":new R(S.paint_heatmap["heatmap-radius"]),"heatmap-weight":new R(S.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new B(S.paint_heatmap["heatmap-intensity"]),"heatmap-color":new Zt(S.paint_heatmap["heatmap-color"]),"heatmap-opacity":new B(S.paint_heatmap["heatmap-opacity"])}),pp={get paint(){return Xg()}};function Bs(t,{width:e,height:r},n,i){if(!i)i=new Uint8Array(e*r*n);else if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==e*r*n)throw new RangeError("mismatched image size. expected: ".concat(i.length," but got: ").concat(e*r*n));return t.width=e,t.height=r,t.data=i,t}function fp(t,{width:e,height:r},n){if(e===t.width&&r===t.height)return;let i=Bs({},{width:e,height:r},n);zs(t,i,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,e),height:Math.min(t.height,r)},n),t.width=e,t.height=r,t.data=i.data}function zs(t,e,r,n,i,o){if(i.width===0||i.height===0)return e;if(i.width>t.width||i.height>t.height||r.x>t.width-i.width||r.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>e.width||i.height>e.height||n.x>e.width-i.width||n.y>e.height-i.height)throw new RangeError("out of range destination coordinates for image copy");let a=t.data,s=e.data;if(a===s)throw new Error("srcData equals dstData, so image is already copied");for(let l=0;l<i.height;l++){let u=((r.y+l)*t.width+r.x)*o,c=((n.y+l)*e.width+n.x)*o;for(let p=0;p<i.width*o;p++)s[c+p]=a[u+p]}return e}var er=class t{constructor(e,r){Bs(this,e,1,r)}resize(e){fp(this,e,1)}clone(){return new t({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(e,r,n,i,o){zs(e,r,n,i,o,1)}},de=class t{constructor(e,r){Bs(this,e,4,r)}resize(e){fp(this,e,4)}replace(e,r){r?this.data.set(e):e instanceof Uint8ClampedArray?this.data=new Uint8Array(e.buffer):this.data=e}clone(){return new t({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(e,r,n,i,o){zs(e,r,n,i,o,4)}};C("AlphaImage",er);C("RGBAImage",de);function yp(t){let e={},r=t.resolution||256,n=t.clips?t.clips.length:1,i=t.image||new de({width:r,height:n});if(!Xl(r))throw new Error("width is not a power of 2 - ".concat(r));let o=(a,s,l)=>{e[t.evaluationKey]=l;let u=t.expression.evaluate(e);i.data[a+s+0]=Math.floor(u.r*255/u.a),i.data[a+s+1]=Math.floor(u.g*255/u.a),i.data[a+s+2]=Math.floor(u.b*255/u.a),i.data[a+s+3]=Math.floor(u.a*255)};if(t.clips)for(let a=0,s=0;a<n;++a,s+=r*4)for(let l=0,u=0;l<r;l++,u+=4){let c=l/(r-1),{start:p,end:f}=t.clips[a],y=p*(1-c)+f*c;o(s,u,y)}else for(let a=0,s=0;a<r;a++,s+=4){let l=a/(r-1);o(0,s,l)}return i}var $o=class extends se{createBucket(e){return new Zn(e)}constructor(e){super(e,pp),this._updateColorRamp()}_handleSpecialPaintPropertyUpdate(e){e==="heatmap-color"&&this._updateColorRamp()}_updateColorRamp(){let e=this._transitionablePaint._values["heatmap-color"].value.expression;this.colorRamp=yp({expression:e,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null}resize(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null)}queryRadius(){return 0}queryIntersectsFeature(){return!1}hasOffscreenPass(){return this.paint.get("heatmap-opacity")!==0&&this.visibility!=="none"}};var mp,Kg=()=>mp=mp||new re({"hillshade-illumination-direction":new B(S.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new B(S.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new B(S.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new B(S.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new B(S.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new B(S.paint_hillshade["hillshade-accent-color"])}),hp={get paint(){return Kg()}};var Go=class extends se{constructor(e){super(e,hp)}hasOffscreenPass(){return this.paint.get("hillshade-exaggeration")!==0&&this.visibility!=="none"}};var Yg=Y([{name:"a_pos",components:2,type:"Int16"}],4);var{members:dp,size:GP,alignment:qP}=Yg;var Sp=Z($s(),1);function Gs(t,e,r,n,i){Pp(t,e,r||0,n||t.length-1,i||mx)}function Pp(t,e,r,n,i){for(;n>r;){if(n-r>600){var o=n-r+1,a=e-r+1,s=Math.log(o),l=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(e-a*l/o+u)),p=Math.min(n,Math.floor(e+(o-a)*l/o+u));Pp(t,e,c,p,i)}var f=t[e],y=r,m=n;for(Kn(t,r,e),i(t[n],f)>0&&Kn(t,r,n);y<m;){for(Kn(t,y,m),y++,m--;i(t[y],f)<0;)y++;for(;i(t[m],f)>0;)m--}i(t[r],f)===0?Kn(t,r,m):(m++,Kn(t,m,n)),m<=e&&(r=m+1),e<=m&&(n=m-1)}}function Kn(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function mx(t,e){return t<e?-1:t>e?1:0}function Tr(t,e){let r=t.length;if(r<=1)return[t];let n=[],i,o;for(let a=0;a<r;a++){let s=Ql(t[a]);s!==0&&(t[a].area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[t[a]]):i.push(t[a]))}if(i&&n.push(i),e>1)for(let a=0;a<n.length;a++)n[a].length<=e||(Gs(n[a],e,1,n[a].length-1,hx),n[a]=n[a].slice(0,e));return n}function hx(t,e){return e.area-t.area}function Cr(t,e,r){let n=r.patternDependencies,i=!1;for(let o of e){let a=o.paint.get("".concat(t,"-pattern"));a.isConstant()||(i=!0);let s=a.constantOr(null);s&&(i=!0,n[s.to]=!0,n[s.from]=!0)}return i}function kr(t,e,r,n,i){let o=i.patternDependencies;for(let a of e){let l=a.paint.get("".concat(t,"-pattern")).value;if(l.kind!=="constant"){let u=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),p=l.evaluate({zoom:n+1},r,{},i.availableImages);u=u&&u.name?u.name:u,c=c&&c.name?c.name:c,p=p&&p.name?p.name:p,o[u]=!0,o[c]=!0,o[p]=!0,r.patterns[a.id]={min:u,mid:c,max:p}}}return r}var dx=500,rr=class{constructor(e){this.zoom=e.zoom,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new _o,this.indexArray=new Le,this.indexArray2=new wt,this.programConfigurations=new Ce(e.layers,e.zoom),this.segments=new me,this.segments2=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){this.hasPattern=Cr("fill",this.layers,r);let i=this.layers[0].layout.get("fill-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of e){let p=this.layers[0]._featureFilter.needGeometry,f=$e(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n,r.availableImages):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:ke(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=kr("fill",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=e[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}addFeatures(e,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,dp),this.indexBuffer=e.createIndexBuffer(this.indexArray),this.indexBuffer2=e.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy())}addFeature(e,r,n,i,o){for(let a of Tr(r,dx)){let s=0;for(let y of a)s+=y.length;let l=this.segments.prepareSegment(s,this.layoutVertexArray,this.indexArray),u=l.vertexLength,c=[],p=[];for(let y of a){if(y.length===0)continue;y!==a[0]&&p.push(c.length/2);let m=this.segments2.prepareSegment(y.length,this.layoutVertexArray,this.indexArray2),h=m.vertexLength;this.layoutVertexArray.emplaceBack(y[0].x,y[0].y),this.indexArray2.emplaceBack(h+y.length-1,h),c.push(y[0].x),c.push(y[0].y);for(let d=1;d<y.length;d++)this.layoutVertexArray.emplaceBack(y[d].x,y[d].y),this.indexArray2.emplaceBack(h+d-1,h+d),c.push(y[d].x),c.push(y[d].y);m.vertexLength+=y.length,m.primitiveLength+=y.length}let f=(0,Sp.default)(c,p);for(let y=0;y<f.length;y+=3)this.indexArray.emplaceBack(u+f[y],u+f[y+1],u+f[y+2]);l.vertexLength+=s,l.primitiveLength+=f.length/3}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,o,i)}};C("FillBucket",rr,{omit:["layers","patternFeatures"]});var wp,gx=()=>wp=wp||new re({"fill-sort-key":new R(S.layout_fill["fill-sort-key"])}),Ap,xx=()=>Ap=Ap||new re({"fill-antialias":new B(S.paint_fill["fill-antialias"]),"fill-opacity":new R(S.paint_fill["fill-opacity"]),"fill-color":new R(S.paint_fill["fill-color"]),"fill-outline-color":new R(S.paint_fill["fill-outline-color"]),"fill-translate":new B(S.paint_fill["fill-translate"]),"fill-translate-anchor":new B(S.paint_fill["fill-translate-anchor"]),"fill-pattern":new lt(S.paint_fill["fill-pattern"])}),_p={get paint(){return xx()},get layout(){return gx()}};var Wo=class extends se{constructor(e){super(e,_p)}recalculate(e,r){super.recalculate(e,r);let n=this.paint._values["fill-outline-color"];n.value.kind==="constant"&&n.value.value===void 0&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"])}createBucket(e){return new rr(e)}queryRadius(){return _t(this.paint.get("fill-translate"))}queryIntersectsFeature(e,r,n,i,o,a,s){let l=It(e,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),a.angle,s);return Oo(l,i)}isTileClipped(){return!0}};var bx=Y([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4),Ip=Y([{name:"a_centroid",components:2,type:"Int16"}],4);var{members:Tp,size:IS,alignment:TS}=bx;var Lp=Z($s(),1),Dp=Z(Tt(),1);var Ex=Dp.default.VectorTileFeature.types,Fx=500,Js=Math.pow(2,13);function Yn(t,e,r,n,i,o,a,s){t.emplaceBack(e,r,Math.floor(n*Js)*2+a,i*Js*2,o*Js*2,Math.round(s))}var nr=class{constructor(e){this.zoom=e.zoom,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.layoutVertexArray=new Io,this.centroidVertexArray=new wo,this.indexArray=new Le,this.programConfigurations=new Ce(e.layers,e.zoom),this.segments=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){this.features=[],this.hasPattern=Cr("fill-extrusion",this.layers,r);for(let{feature:i,id:o,index:a,sourceLayerIndex:s}of e){let l=this.layers[0]._featureFilter.needGeometry,u=$e(i,l);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),u,n))continue;let c={id:o,sourceLayerIndex:s,index:a,geometry:l?u.geometry:ke(i),properties:i.properties,type:i.type,patterns:{}};this.hasPattern?this.features.push(kr("fill-extrusion",this.layers,c,this.zoom,r)):this.addFeature(c,c.geometry,a,n,{}),r.featureIndex.insert(i,c.geometry,a,s,this.index,!0)}}addFeatures(e,r,n){for(let i of this.features){let{geometry:o}=i;this.addFeature(i,o,i.index,r,n)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0&&this.centroidVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,Tp),this.centroidVertexBuffer=e.createVertexBuffer(this.centroidVertexArray,Ip.members,!0),this.indexBuffer=e.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.centroidVertexBuffer.destroy())}addFeature(e,r,n,i,o){let a={x:0,y:0,vertexCount:0};for(let s of Tr(r,Fx)){let l=0;for(let m of s)l+=m.length;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray);for(let m of s){if(m.length===0||Dx(m))continue;let h=0;for(let d=0;d<m.length;d++){let g=m[d];if(d>=1){let b=m[d-1];if(!Lx(g,b)){u.vertexLength+4>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));let x=g.sub(b)._perp()._unit(),v=b.dist(g);h+v>32768&&(h=0),Yn(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,0,h),Yn(this.layoutVertexArray,g.x,g.y,x.x,x.y,0,1,h),a.x+=2*g.x,a.y+=2*g.y,a.vertexCount+=2,h+=v,Yn(this.layoutVertexArray,b.x,b.y,x.x,x.y,0,0,h),Yn(this.layoutVertexArray,b.x,b.y,x.x,x.y,0,1,h),a.x+=2*b.x,a.y+=2*b.y,a.vertexCount+=2;let P=u.vertexLength;this.indexArray.emplaceBack(P,P+2,P+1),this.indexArray.emplaceBack(P+1,P+2,P+3),u.vertexLength+=4,u.primitiveLength+=2}}}}if(u.vertexLength+l>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(l,this.layoutVertexArray,this.indexArray)),Ex[e.type]!=="Polygon")continue;let c=[],p=[],f=u.vertexLength;for(let m of s)if(m.length!==0){m!==s[0]&&p.push(c.length/2);for(let h=0;h<m.length;h++){let d=m[h];Yn(this.layoutVertexArray,d.x,d.y,0,0,1,1,0),a.x+=d.x,a.y+=d.y,a.vertexCount+=1,c.push(d.x),c.push(d.y)}}let y=(0,Lp.default)(c,p);for(let m=0;m<y.length;m+=3)this.indexArray.emplaceBack(f+y[m],f+y[m+2],f+y[m+1]);u.primitiveLength+=y.length/3,u.vertexLength+=l}for(let s=0;s<a.vertexCount;s++)this.centroidVertexArray.emplaceBack(Math.floor(a.x/a.vertexCount),Math.floor(a.y/a.vertexCount));this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,o,i)}};C("FillExtrusionBucket",nr,{omit:["layers","features"]});function Lx(t,e){return t.x===e.x&&(t.x<0||t.x>8192)||t.y===e.y&&(t.y<0||t.y>8192)}function Dx(t){return t.every(e=>e.x<0)||t.every(e=>e.x>8192)||t.every(e=>e.y<0)||t.every(e=>e.y>8192)}var Vp,Vx=()=>Vp=Vp||new re({"fill-extrusion-opacity":new B(S["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new R(S["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new B(S["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new B(S["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new lt(S["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new R(S["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new R(S["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new B(S["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])}),Bp={get paint(){return Vx()}};var Xo=Z(he(),1);var Ko=class extends se{constructor(e){super(e,Bp)}createBucket(e){return new nr(e)}queryRadius(){return _t(this.paint.get("fill-extrusion-translate"))}is3D(){return!0}queryIntersectsFeature(e,r,n,i,o,a,s,l){let u=It(e,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),a.angle,s),c=this.paint.get("fill-extrusion-height").evaluate(r,n),p=this.paint.get("fill-extrusion-base").evaluate(r,n),f=Rx(u,l,a,0),y=zx(i,p,c,l),m=y[0],h=y[1];return Bx(m,h,f)}};function Qn(t,e){return t.x*e.x+t.y*e.y}function zp(t,e){if(t.length===1){let r=0,n=e[r++],i;for(;!i||n.equals(i);)if(i=e[r++],!i)return 1/0;for(;r<e.length;r++){let o=e[r],a=t[0],s=i.sub(n),l=o.sub(n),u=a.sub(n),c=Qn(s,s),p=Qn(s,l),f=Qn(l,l),y=Qn(u,s),m=Qn(u,l),h=c*f-p*p,d=(f*y-p*m)/h,g=(c*m-p*y)/h,b=1-d-g,x=n.z*b+i.z*d+o.z*g;if(isFinite(x))return x}return 1/0}else{let r=1/0;for(let n of e)r=Math.min(r,n.z);return r}}function Bx(t,e,r){let n=1/0;Oo(r,e)&&(n=zp(r,e[0]));for(let i=0;i<e.length;i++){let o=e[i],a=t[i];for(let s=0;s<o.length-1;s++){let l=o[s],u=o[s+1],c=a[s],p=a[s+1],f=[l,u,p,c,l];Rc(r,f)&&(n=Math.min(n,zp(r,f)))}}return n===1/0?!1:n}function zx(t,e,r,n){let i=[],o=[],a=n[8]*e,s=n[9]*e,l=n[10]*e,u=n[11]*e,c=n[8]*r,p=n[9]*r,f=n[10]*r,y=n[11]*r;for(let m of t){let h=[],d=[];for(let g of m){let b=g.x,x=g.y,v=n[0]*b+n[4]*x+n[12],P=n[1]*b+n[5]*x+n[13],w=n[2]*b+n[6]*x+n[14],T=n[3]*b+n[7]*x+n[15],F=v+a,E=P+s,_=w+l,I=T+u,k=v+c,V=P+p,A=w+f,z=T+y,O=new Xo.default(F/I,E/I);O.z=_/I,h.push(O);let N=new Xo.default(k/z,V/z);N.z=A/z,d.push(N)}i.push(h),o.push(d)}return[i,o]}function Rx(t,e,r,n){let i=[];for(let o of t){let a=[o.x,o.y,n,1];Qt.transformMat4(a,a,e),i.push(new Xo.default(a[0]/a[3],a[1]/a[3]))}return i}var Ox=Y([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4),{members:Rp,size:uw,alignment:cw}=Ox;var Nx=Y([{name:"a_uv_x",components:1,type:"Float32"},{name:"a_split_index",components:1,type:"Float32"}]),{members:Op,size:yw,alignment:mw}=Nx;var $p=Z(Tt(),1);var Ux=$p.default.VectorTileFeature.types,Np=63,$x=Math.cos(75/2*(Math.PI/180)),Gx=15,qx=20,jx=15,Gp=1/2,Up=Math.pow(2,jx-1)/Gp,ir=class{constructor(e){this.zoom=e.zoom,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(r=>r.id),this.index=e.index,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach(r=>{this.gradients[r.id]={}}),this.layoutVertexArray=new To,this.layoutVertexArray2=new Co,this.indexArray=new Le,this.programConfigurations=new Ce(e.layers,e.zoom),this.segments=new me,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(e,r,n){this.hasPattern=Cr("line",this.layers,r);let i=this.layers[0].layout.get("line-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of e){let p=this.layers[0]._featureFilter.needGeometry,f=$e(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:ke(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=kr("line",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=e[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(e,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(e,r,this.stateDependentLayers,n)}addFeatures(e,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(e){this.uploaded||(this.layoutVertexArray2.length!==0&&(this.layoutVertexBuffer2=e.createVertexBuffer(this.layoutVertexArray2,Op)),this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,Rp),this.indexBuffer=e.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(e),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}lineFeatureClips(e){if(e.properties&&Object.prototype.hasOwnProperty.call(e.properties,"mapbox_clip_start")&&Object.prototype.hasOwnProperty.call(e.properties,"mapbox_clip_end")){let r=+e.properties.mapbox_clip_start,n=+e.properties.mapbox_clip_end;return{start:r,end:n}}}addFeature(e,r,n,i,o){let a=this.layers[0].layout,s=a.get("line-join").evaluate(e,{}),l=a.get("line-cap"),u=a.get("line-miter-limit"),c=a.get("line-round-limit");this.lineClips=this.lineFeatureClips(e);for(let p of r)this.addLine(p,e,s,l,u,c);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,e,n,o,i)}addLine(e,r,n,i,o,a){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.lineClips){this.lineClipsArray.push(this.lineClips);for(let g=0;g<e.length-1;g++)this.totalDistance+=e[g].dist(e[g+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance)}let s=Ux[r.type]==="Polygon",l=e.length;for(;l>=2&&e[l-1].equals(e[l-2]);)l--;let u=0;for(;u<l-1&&e[u].equals(e[u+1]);)u++;if(l<(s?3:2))return;n==="bevel"&&(o=1.05);let c=this.overscaling<=16?Gx*8192/(512*this.overscaling):0,p=this.segments.prepareSegment(l*10,this.layoutVertexArray,this.indexArray),f,y,m,h,d;this.e1=this.e2=-1,s&&(f=e[l-2],d=e[u].sub(f)._unit()._perp());for(let g=u;g<l;g++){if(m=g===l-1?s?e[u+1]:void 0:e[g+1],m&&e[g].equals(m))continue;d&&(h=d),f&&(y=f),f=e[g],d=m?m.sub(f)._unit()._perp():h,h=h||d;let b=h.add(d);(b.x!==0||b.y!==0)&&b._unit();let x=h.x*d.x+h.y*d.y,v=b.x*d.x+b.y*d.y,P=v!==0?1/v:1/0,w=2*Math.sqrt(2-2*v),T=v<$x&&y&&m,F=h.x*d.y-h.y*d.x>0;if(T&&g>u){let I=f.dist(y);if(I>2*c){let k=f.sub(f.sub(y)._mult(c/I)._round());this.updateDistance(y,k),this.addCurrentVertex(k,h,0,0,p),y=k}}let E=y&&m,_=E?n:s?"butt":i;if(E&&_==="round"&&(P<a?_="miter":P<=2&&(_="fakeround")),_==="miter"&&P>o&&(_="bevel"),_==="bevel"&&(P>2&&(_="flipbevel"),P<o&&(_="miter")),y&&this.updateDistance(y,f),_==="miter")b._mult(P),this.addCurrentVertex(f,b,0,0,p);else if(_==="flipbevel"){if(P>100)b=d.mult(-1);else{let I=P*h.add(d).mag()/h.sub(d).mag();b._perp()._mult(I*(F?-1:1))}this.addCurrentVertex(f,b,0,0,p),this.addCurrentVertex(f,b.mult(-1),0,0,p)}else if(_==="bevel"||_==="fakeround"){let I=-Math.sqrt(P*P-1),k=F?I:0,V=F?0:I;if(y&&this.addCurrentVertex(f,h,k,V,p),_==="fakeround"){let A=Math.round(w*180/Math.PI/qx);for(let z=1;z<A;z++){let O=z/A;if(O!==.5){let K=O-.5,xe=1.0904+x*(-3.2452+x*(3.55645-x*1.43519)),X=.848013+x*(-1.06021+x*.215638);O=O+O*K*(O-1)*(xe*K*K+X)}let N=d.sub(h)._mult(O)._add(h)._unit()._mult(F?-1:1);this.addHalfVertex(f,N.x,N.y,!1,F,0,p)}}m&&this.addCurrentVertex(f,d,-k,-V,p)}else if(_==="butt")this.addCurrentVertex(f,b,0,0,p);else if(_==="square"){let I=y?1:-1;this.addCurrentVertex(f,b,I,I,p)}else _==="round"&&(y&&(this.addCurrentVertex(f,h,0,0,p),this.addCurrentVertex(f,h,1,1,p,!0)),m&&(this.addCurrentVertex(f,d,-1,-1,p,!0),this.addCurrentVertex(f,d,0,0,p)));if(T&&g<l-1){let I=f.dist(m);if(I>2*c){let k=f.add(m.sub(f)._mult(c/I)._round());this.updateDistance(f,k),this.addCurrentVertex(k,d,0,0,p),f=k}}}}addCurrentVertex(e,r,n,i,o,a=!1){let s=r.x+r.y*n,l=r.y-r.x*n,u=-r.x+r.y*i,c=-r.y-r.x*i;this.addHalfVertex(e,s,l,a,!1,n,o),this.addHalfVertex(e,u,c,a,!0,-i,o),this.distance>Up/2&&this.totalDistance===0&&(this.distance=0,this.updateScaledDistance(),this.addCurrentVertex(e,r,n,i,o,a))}addHalfVertex({x:e,y:r},n,i,o,a,s,l){let c=(this.lineClips?this.scaledDistance*(Up-1):this.scaledDistance)*Gp;if(this.layoutVertexArray.emplaceBack((e<<1)+(o?1:0),(r<<1)+(a?1:0),Math.round(Np*n)+128,Math.round(Np*i)+128,(s===0?0:s<0?-1:1)+1|(c&63)<<2,c>>6),this.lineClips){let f=this.scaledDistance-this.lineClips.start,y=this.lineClips.end-this.lineClips.start,m=f/y;this.layoutVertexArray2.emplaceBack(m,this.lineClipsArray.length)}let p=l.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,p),l.primitiveLength++),a?this.e2=p:this.e1=p}updateScaledDistance(){this.scaledDistance=this.lineClips?this.lineClips.start+(this.lineClips.end-this.lineClips.start)*this.distance/this.totalDistance:this.distance}updateDistance(e,r){this.distance+=e.dist(r),this.updateScaledDistance()}};C("LineBucket",ir,{omit:["layers","patternFeatures"]});var qp,Jx=()=>qp=qp||new re({"line-cap":new B(S.layout_line["line-cap"]),"line-join":new R(S.layout_line["line-join"]),"line-miter-limit":new B(S.layout_line["line-miter-limit"]),"line-round-limit":new B(S.layout_line["line-round-limit"]),"line-sort-key":new R(S.layout_line["line-sort-key"])}),jp,Zx=()=>jp=jp||new re({"line-opacity":new R(S.paint_line["line-opacity"]),"line-color":new R(S.paint_line["line-color"]),"line-translate":new B(S.paint_line["line-translate"]),"line-translate-anchor":new B(S.paint_line["line-translate-anchor"]),"line-width":new R(S.paint_line["line-width"]),"line-gap-width":new R(S.paint_line["line-gap-width"]),"line-offset":new R(S.paint_line["line-offset"]),"line-blur":new R(S.paint_line["line-blur"]),"line-dasharray":new Jt(S.paint_line["line-dasharray"]),"line-pattern":new lt(S.paint_line["line-pattern"]),"line-gradient":new Zt(S.paint_line["line-gradient"])}),Zs={get paint(){return Zx()},get layout(){return Jx()}};var Ws=class extends R{possiblyEvaluate(e,r){return r=new q(Math.floor(r.zoom),{now:r.now,fadeDuration:r.fadeDuration,zoomHistory:r.zoomHistory,transition:r.transition}),super.possiblyEvaluate(e,r)}evaluate(e,r,n,i){return r=Pe({},r,{zoom:Math.floor(r.zoom)}),super.evaluate(e,r,n,i)}},Yo,Qo=class extends se{constructor(e){super(e,Zs),this.gradientVersion=0,Yo||(Yo=new Ws(Zs.paint.properties["line-width"].specification),Yo.useIntegerZoom=!0)}_handleSpecialPaintPropertyUpdate(e){if(e==="line-gradient"){let r=this.gradientExpression();qt(r)?this.stepInterpolant=r._styleExpression.expression instanceof yr:this.stepInterpolant=!1,this.gradientVersion=(this.gradientVersion+1)%Number.MAX_SAFE_INTEGER}}gradientExpression(){return this._transitionablePaint._values["line-gradient"].value.expression}recalculate(e,r){super.recalculate(e,r),this.paint._values["line-floorwidth"]=Yo.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,e)}createBucket(e){return new ir(e)}queryRadius(e){let r=e,n=Jp(Yt("line-width",this,r),Yt("line-gap-width",this,r)),i=Yt("line-offset",this,r);return n/2+Math.abs(i)+_t(this.paint.get("line-translate"))}queryIntersectsFeature(e,r,n,i,o,a,s){let l=It(e,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),a.angle,s),u=s/2*Jp(this.paint.get("line-width").evaluate(r,n),this.paint.get("line-gap-width").evaluate(r,n)),c=this.paint.get("line-offset").evaluate(r,n);return c&&(i=$c(i,c*s)),Nc(l,i,u)}isTileClipped(){return!0}};function Jp(t,e){return e>0?e+2*t:t}var Zp=Y([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),Wp=Y([{name:"a_projected_pos",components:3,type:"Float32"}],4),Kw=Y([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),Hp=Y([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}]),Yw=Y([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]),Hs=Y([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4),Qw=Y([{name:"a_pos",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4),e2=Y([{name:"triangle",components:3,type:"Uint16"}]),t2=Y([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),r2=Y([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",name:"collisionCircleDiameter"},{type:"Uint16",name:"textAnchorOffsetStartIndex"},{type:"Uint16",name:"textAnchorOffsetEndIndex"}]),n2=Y([{type:"Float32",name:"offsetX"}]),i2=Y([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]),o2=Y([{type:"Uint16",name:"textAnchor"},{type:"Float32",components:2,name:"textOffset"}]);var oi=Z(he(),1);function Wx(t,e,r){let n=e.layout.get("text-transform").evaluate(r,{});return n==="uppercase"?t=t.toLocaleUpperCase():n==="lowercase"&&(t=t.toLocaleLowerCase()),ye.applyArabicShaping&&(t=ye.applyArabicShaping(t)),t}function Xp(t,e,r){return t.sections.forEach(n=>{n.text=Wx(n.text,e,r)}),t}function Kp(t){let e={},r={},n=[],i=0;function o(u){n.push(t[u]),i++}function a(u,c,p){let f=r[u];return delete r[u],r[c]=f,n[f].geometry[0].pop(),n[f].geometry[0]=n[f].geometry[0].concat(p[0]),f}function s(u,c,p){let f=e[c];return delete e[c],e[u]=f,n[f].geometry[0].shift(),n[f].geometry[0]=p[0].concat(n[f].geometry[0]),f}function l(u,c,p){let f=p?c[0][c[0].length-1]:c[0][0];return"".concat(u,":").concat(f.x,":").concat(f.y)}for(let u=0;u<t.length;u++){let c=t[u],p=c.geometry,f=c.text?c.text.toString():null;if(!f){o(u);continue}let y=l(f,p),m=l(f,p,!0);if(y in r&&m in e&&r[y]!==e[m]){let h=s(y,m,p),d=a(y,m,n[h].geometry);delete e[y],delete r[m],r[l(f,n[d].geometry,!0)]=d,n[h].geometry=null}else y in r?a(y,m,p):m in e?s(y,m,p):(o(u),e[y]=i-1,r[m]=i-1)}return n.filter(u=>u.geometry)}var Er={"!":"\\uFE15","#":"\\uFF03",$:"\\uFF04","%":"\\uFF05","&":"\\uFF06","(":"\\uFE35",")":"\\uFE36","*":"\\uFF0A","+":"\\uFF0B",",":"\\uFE10","-":"\\uFE32",".":"\\u30FB","/":"\\uFF0F",":":"\\uFE13",";":"\\uFE14","<":"\\uFE3F","=":"\\uFF1D",">":"\\uFE40","?":"\\uFE16","@":"\\uFF20","[":"\\uFE47","\\\\":"\\uFF3C","]":"\\uFE48","^":"\\uFF3E",_:"\\uFE33","\`":"\\uFF40","{":"\\uFE37","|":"\\u2015","}":"\\uFE38","~":"\\uFF5E","\\xA2":"\\uFFE0","\\xA3":"\\uFFE1","\\xA5":"\\uFFE5","\\xA6":"\\uFFE4","\\xAC":"\\uFFE2","\\xAF":"\\uFFE3","\\u2013":"\\uFE32","\\u2014":"\\uFE31","\\u2018":"\\uFE43","\\u2019":"\\uFE44","\\u201C":"\\uFE41","\\u201D":"\\uFE42","\\u2026":"\\uFE19","\\u2027":"\\u30FB","\\u20A9":"\\uFFE6","\\u3001":"\\uFE11","\\u3002":"\\uFE12","\\u3008":"\\uFE3F","\\u3009":"\\uFE40","\\u300A":"\\uFE3D","\\u300B":"\\uFE3E","\\u300C":"\\uFE41","\\u300D":"\\uFE42","\\u300E":"\\uFE43","\\u300F":"\\uFE44","\\u3010":"\\uFE3B","\\u3011":"\\uFE3C","\\u3014":"\\uFE39","\\u3015":"\\uFE3A","\\u3016":"\\uFE17","\\u3017":"\\uFE18","\\uFF01":"\\uFE15","\\uFF08":"\\uFE35","\\uFF09":"\\uFE36","\\uFF0C":"\\uFE10","\\uFF0D":"\\uFE32","\\uFF0E":"\\u30FB","\\uFF1A":"\\uFE13","\\uFF1B":"\\uFE14","\\uFF1C":"\\uFE3F","\\uFF1E":"\\uFE40","\\uFF1F":"\\uFE16","\\uFF3B":"\\uFE47","\\uFF3D":"\\uFE48","\\uFF3F":"\\uFE33","\\uFF5B":"\\uFE37","\\uFF5C":"\\u2015","\\uFF5D":"\\uFE38","\\uFF5F":"\\uFE35","\\uFF60":"\\uFE36","\\uFF61":"\\uFE12","\\uFF62":"\\uFE41","\\uFF63":"\\uFE42"};function Yp(t){let e="";for(let r=0;r<t.length;r++){let n=t.charCodeAt(r+1)||null,i=t.charCodeAt(r-1)||null;(!n||!As(n)||Er[t[r+1]])&&(!i||!As(i)||Er[t[r-1]])&&Er[t[r]]?e+=Er[t[r]]:e+=t[r]}return e}var ne=24;var fb=Z(ei(),1),yb=3;var ra=yb;function ti(t){let e=0,r=0;for(let s of t)e+=s.w*s.h,r=Math.max(r,s.w);t.sort((s,l)=>l.h-s.h);let i=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),r),h:1/0}],o=0,a=0;for(let s of t)for(let l=i.length-1;l>=0;l--){let u=i[l];if(!(s.w>u.w||s.h>u.h)){if(s.x=u.x,s.y=u.y,a=Math.max(a,s.y+s.h),o=Math.max(o,s.x+s.w),s.w===u.w&&s.h===u.h){let c=i.pop();l<i.length&&(i[l]=c)}else s.h===u.h?(u.x+=s.w,u.w-=s.w):s.w===u.w?(u.y+=s.h,u.h-=s.h):(i.push({x:u.x+s.w,y:u.y,w:u.w-s.w,h:s.h}),u.y+=s.h,u.h-=s.h);break}}return{w:o,h:a,fill:e/(o*a)||0}}var ge=1;var na=class{constructor(e,{pixelRatio:r,version:n,stretchX:i,stretchY:o,content:a}){this.paddedRect=e,this.pixelRatio=r,this.stretchX=i,this.stretchY=o,this.content=a,this.version=n}get tl(){return[this.paddedRect.x+ge,this.paddedRect.y+ge]}get br(){return[this.paddedRect.x+this.paddedRect.w-ge,this.paddedRect.y+this.paddedRect.h-ge]}get tlbr(){return this.tl.concat(this.br)}get displaySize(){return[(this.paddedRect.w-ge*2)/this.pixelRatio,(this.paddedRect.h-ge*2)/this.pixelRatio]}},ri=class{constructor(e,r){let n={},i={};this.haveRenderCallbacks=[];let o=[];this.addImages(e,n,o),this.addImages(r,i,o);let{w:a,h:s}=ti(o),l=new de({width:a||1,height:s||1});for(let u in e){let c=e[u],p=n[u].paddedRect;de.copy(c.data,l,{x:0,y:0},{x:p.x+ge,y:p.y+ge},c.data)}for(let u in r){let c=r[u],p=i[u].paddedRect,f=p.x+ge,y=p.y+ge,m=c.data.width,h=c.data.height;de.copy(c.data,l,{x:0,y:0},{x:f,y},c.data),de.copy(c.data,l,{x:0,y:h-1},{x:f,y:y-1},{width:m,height:1}),de.copy(c.data,l,{x:0,y:0},{x:f,y:y+h},{width:m,height:1}),de.copy(c.data,l,{x:m-1,y:0},{x:f-1,y},{width:1,height:h}),de.copy(c.data,l,{x:0,y:0},{x:f+m,y},{width:1,height:h})}this.image=l,this.iconPositions=n,this.patternPositions=i}addImages(e,r,n){for(let i in e){let o=e[i],a={x:0,y:0,w:o.data.width+2*ge,h:o.data.height+2*ge};n.push(a),r[i]=new na(a,o),o.hasRenderCallback&&this.haveRenderCallbacks.push(i)}}patchUpdatedImages(e,r){e.dispatchRenderCallbacks(this.haveRenderCallbacks);for(let n in e.updatedImages)this.patchUpdatedImage(this.iconPositions[n],e.getImage(n),r),this.patchUpdatedImage(this.patternPositions[n],e.getImage(n),r)}patchUpdatedImage(e,r,n){if(!e||!r||e.version===r.version)return;e.version=r.version;let[i,o]=e.tl;n.update(r.data,void 0,{x:i,y:o})}};C("ImagePosition",na);C("ImageAtlas",ri);var aa=(i=>(i[i.none=0]="none",i[i.horizontal=1]="horizontal",i[i.vertical=2]="vertical",i[i.horizontalOnly=3]="horizontalOnly",i))(aa||{}),Dr=-17;function mb(t){for(let e of t)if(e.positionedGlyphs.length!==0)return!1;return!0}var af=57344,sf=63743,ia=class t{constructor(){this.scale=1,this.fontStack="",this.imageName=null}static forText(e,r){let n=new t;return n.scale=e||1,n.fontStack=r,n}static forImage(e){let r=new t;return r.imageName=e,r}},ni=class t{constructor(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null}static fromFeature(e,r){let n=new t;for(let i=0;i<e.sections.length;i++){let o=e.sections[i];o.image?n.addImageSection(o):n.addTextSection(o,r)}return n}length(){return this.text.length}getSection(e){return this.sections[this.sectionIndex[e]]}getSectionIndex(e){return this.sectionIndex[e]}getCharCode(e){return this.text.charCodeAt(e)}verticalizePunctuation(){this.text=Yp(this.text)}trim(){let e=0;for(let n=0;n<this.text.length&&oa[this.text.charCodeAt(n)];n++)e++;let r=this.text.length;for(let n=this.text.length-1;n>=0&&n>=e&&oa[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(e,r),this.sectionIndex=this.sectionIndex.slice(e,r)}substring(e,r){let n=new t;return n.text=this.text.substring(e,r),n.sectionIndex=this.sectionIndex.slice(e,r),n.sections=this.sections,n}toString(){return this.text}getMaxScale(){return this.sectionIndex.reduce((e,r)=>Math.max(e,this.sections[r].scale),0)}addTextSection(e,r){this.text+=e.text,this.sections.push(ia.forText(e.scale,e.fontStack||r));let n=this.sections.length-1;for(let i=0;i<e.text.length;++i)this.sectionIndex.push(n)}addImageSection(e){let r=e.image?e.image.name:"";if(r.length===0){fe("Can't add FormattedSection with an empty image.");return}let n=this.getNextImageSectionCharCode();if(!n){fe("Reached maximum number of images ".concat(sf-af+2));return}this.text+=String.fromCharCode(n),this.sections.push(ia.forImage(r)),this.sectionIndex.push(this.sections.length-1)}getNextImageSectionCharCode(){return this.imageSectionID?this.imageSectionID>=sf?null:++this.imageSectionID:(this.imageSectionID=af,this.imageSectionID)}};function hb(t,e){let r=[],n=t.text,i=0;for(let o of e)r.push(t.substring(i,o)),i=o;return i<n.length&&r.push(t.substring(i,n.length)),r}function ii(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h){let d=ni.fromFeature(t,i);p===2&&d.verticalizePunctuation();let g,{processBidirectionalText:b,processStyledBidirectionalText:x}=ye;if(b&&d.sections.length===1){g=[];let w=b(d.toString(),Ys(d,u,o,e,n,y,m));for(let T of w){let F=new ni;F.text=T,F.sections=d.sections;for(let E=0;E<T.length;E++)F.sectionIndex.push(0);g.push(F)}}else if(x){g=[];let w=x(d.text,d.sectionIndex,Ys(d,u,o,e,n,y,m));for(let T of w){let F=new ni;F.text=T[0],F.sectionIndex=T[1],F.sections=d.sections,g.push(F)}}else g=hb(d,Ys(d,u,o,e,n,y,m));let v=[],P={positionedLines:v,text:d.toString(),top:c[1],bottom:c[1],left:c[0],right:c[0],writingMode:p,iconsInText:!1,verticalizable:!1};return bb(P,e,r,n,g,a,s,l,p,u,f,h),mb(v)?!1:P}var oa={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},db={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function cf(t,e,r,n,i,o){if(e.imageName){let a=n[e.imageName];return a?a.displaySize[0]*e.scale*ne/o+i:0}else{let a=r[e.fontStack],s=a&&a[t];return s?s.metrics.advance*e.scale+i:0}}function gb(t,e,r,n,i,o){let a=0;for(let l=0;l<t.length();l++){let u=t.getSection(l);a+=cf(t.getCharCode(l),u,n,i,e,o)}let s=Math.max(1,Math.ceil(a/r));return a/s}function lf(t,e,r,n){let i=Math.pow(t-e,2);return n?t<e?i/2:i*2:i+Math.abs(r)*r}function xb(t,e,r){let n=0;return t===10&&(n-=1e4),r&&(n+=150),(t===40||t===65288)&&(n+=50),(e===41||e===65289)&&(n+=50),n}function uf(t,e,r,n,i,o){let a=null,s=lf(e,r,i,o);for(let l of n){let u=e-l.x,c=lf(u,r,i,o)+l.badness;c<=s&&(a=l,s=c)}return{index:t,x:e,priorBreak:a,badness:s}}function pf(t){return t?pf(t.priorBreak).concat(t.index):[]}function Ys(t,e,r,n,i,o,a){if(o!=="point")return[];if(!t)return[];let s=[],l=gb(t,e,r,n,i,a),u=t.text.indexOf("\\u200B")>=0,c=0;for(let p=0;p<t.length();p++){let f=t.getSection(p),y=t.getCharCode(p);if(oa[y]||(c+=cf(y,f,n,i,e,a)),p<t.length()-1){let m=Sc(y);(db[y]||m||f.imageName)&&s.push(uf(p+1,c,l,s,xb(y,t.getCharCode(p+1),m&&u),!1))}}return pf(uf(t.length(),c,l,s,0,!0))}function ff(t){let e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=1;break;case"left":case"top-left":case"bottom-left":e=0;break}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;break}return{horizontalAlign:e,verticalAlign:r}}function bb(t,e,r,n,i,o,a,s,l,u,c,p){let f=0,y=Dr,m=0,h=0,d=s==="right"?1:s==="left"?0:.5,g=0;for(let P of i){P.trim();let w=P.getMaxScale(),T=(w-1)*ne,F={positionedGlyphs:[],lineOffset:0};t.positionedLines[g]=F;let E=F.positionedGlyphs,_=0;if(!P.length()){y+=o,++g;continue}for(let k=0;k<P.length();k++){let V=P.getSection(k),A=P.getSectionIndex(k),z=P.getCharCode(k),O=0,N=null,K=null,xe=null,X=ne,le=!(l===1||!c&&!lo(z)||c&&(oa[z]||wc(z)));if(V.imageName){let ce=n[V.imageName];if(!ce)continue;xe=V.imageName,t.iconsInText=t.iconsInText||!0,K=ce.paddedRect;let pe=ce.displaySize;V.scale=V.scale*ne/p,N={width:pe[0],height:pe[1],left:ge,top:-ra,advance:le?pe[1]:pe[0]};let _e=ne-pe[1]*V.scale;O=T+_e,X=N.advance;let be=le?pe[0]*V.scale-ne*w:pe[1]*V.scale-ne*w;be>0&&be>_&&(_=be)}else{let ce=r[V.fontStack],pe=ce&&ce[z];if(pe&&pe.rect)K=pe.rect,N=pe.metrics;else{let _e=e[V.fontStack],be=_e&&_e[z];if(!be)continue;N=be.metrics}O=(w-V.scale)*ne}le?(t.verticalizable=!0,E.push({glyph:z,imageName:xe,x:f,y:y+O,vertical:le,scale:V.scale,fontStack:V.fontStack,sectionIndex:A,metrics:N,rect:K}),f+=X*V.scale+u):(E.push({glyph:z,imageName:xe,x:f,y:y+O,vertical:le,scale:V.scale,fontStack:V.fontStack,sectionIndex:A,metrics:N,rect:K}),f+=N.advance*V.scale+u)}if(E.length!==0){let k=f-u;m=Math.max(k,m),vb(E,0,E.length-1,d,_)}f=0;let I=o*w+_;F.lineOffset=Math.max(_,T),y+=I,h=Math.max(I,h),++g}let b=y-Dr,{horizontalAlign:x,verticalAlign:v}=ff(a);Pb(t.positionedLines,d,x,v,m,h,o,b,i.length),t.top+=-v*b,t.bottom=t.top+b,t.left+=-x*m,t.right=t.left+m}function vb(t,e,r,n,i){if(!n&&!i)return;let o=t[r],a=o.metrics.advance*o.scale,s=(t[r].x+a)*n;for(let l=e;l<=r;l++)t[l].x-=s,t[l].y+=i}function Pb(t,e,r,n,i,o,a,s,l){let u=(e-r)*i,c=0;o!==a?c=-s*n-Dr:c=(-n*l+.5)*a;for(let p of t)for(let f of p.positionedGlyphs)f.x+=u,f.y+=c}function yf(t,e,r){let{horizontalAlign:n,verticalAlign:i}=ff(r),o=e[0],a=e[1],s=o-t.displaySize[0]*n,l=s+t.displaySize[0],u=a-t.displaySize[1]*i,c=u+t.displaySize[1];return{image:t,top:u,bottom:c,left:s,right:l}}function Qs(t,e,r,n,i,o){let a=t.image,s;if(a.content){let d=a.content,g=a.pixelRatio||1;s=[d[0]/g,d[1]/g,a.displaySize[0]-d[2]/g,a.displaySize[1]-d[3]/g]}let l=e.left*o,u=e.right*o,c,p,f,y;r==="width"||r==="both"?(y=i[0]+l-n[3],p=i[0]+u+n[1]):(y=i[0]+(l+u-a.displaySize[0])/2,p=y+a.displaySize[0]);let m=e.top*o,h=e.bottom*o;return r==="height"||r==="both"?(c=i[1]+m-n[0],f=i[1]+h+n[2]):(c=i[1]+(m+h-a.displaySize[1])/2,f=c+a.displaySize[1]),{image:a,top:c,right:p,bottom:f,left:y,collisionPadding:s}}var mf=Z(Tt(),1);var Vr=255,Ct=128,tt=Vr*Ct;function el(t,e){let{expression:r}=e;if(r.kind==="constant")return{kind:"constant",layoutSize:r.evaluate(new q(t+1))};if(r.kind==="source")return{kind:"source"};{let{zoomStops:n,interpolationType:i}=r,o=0;for(;o<n.length&&n[o]<=t;)o++;o=Math.max(0,o-1);let a=o;for(;a<n.length&&n[a]<t+1;)a++;a=Math.min(n.length-1,a);let s=n[o],l=n[a];if(r.kind==="composite")return{kind:"composite",minZoom:s,maxZoom:l,interpolationType:i};let u=r.evaluate(new q(s)),c=r.evaluate(new q(l));return{kind:"camera",minZoom:s,maxZoom:l,minSize:u,maxSize:c,interpolationType:i}}}function tl(t,e,r){let n="never",i=t.get(e);return i?n=i:t.get(r)&&(n="always"),n}var Sb=mf.default.VectorTileFeature.types,wb=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function sa(t,e,r,n,i,o,a,s,l,u,c,p,f){let y=s?Math.min(tt,Math.round(s[0])):0,m=s?Math.min(tt,Math.round(s[1])):0;t.emplaceBack(e,r,Math.round(n*32),Math.round(i*32),o,a,(y<<1)+(l?1:0),m,u*16,c*16,p*256,f*256)}function hf(t,e,r){t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r),t.emplaceBack(e.x,e.y,r)}function Ab(t){for(let e of t.sections)if(_c(e.text))return!0;return!1}var ai=class{constructor(e){this.layoutVertexArray=new ko,this.indexArray=new Le,this.programConfigurations=e,this.segments=new me,this.dynamicLayoutVertexArray=new Mo,this.opacityVertexArray=new Eo,this.hasVisibleVertices=!1,this.placedSymbolArray=new Dn}isEmpty(){return this.layoutVertexArray.length===0&&this.indexArray.length===0&&this.dynamicLayoutVertexArray.length===0&&this.opacityVertexArray.length===0}upload(e,r,n,i){this.isEmpty()||(n&&(this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,Zp.members),this.indexBuffer=e.createIndexBuffer(this.indexArray,r),this.dynamicLayoutVertexBuffer=e.createVertexBuffer(this.dynamicLayoutVertexArray,Wp.members,!0),this.opacityVertexBuffer=e.createVertexBuffer(this.opacityVertexArray,wb,!0),this.opacityVertexBuffer.itemSize=1),(n||i)&&this.programConfigurations.upload(e))}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy())}};C("SymbolBuffers",ai);var si=class{constructor(e,r,n){this.layoutVertexArray=new e,this.layoutAttributes=r,this.indexArray=new n,this.segments=new me,this.collisionVertexArray=new Fo}upload(e){this.layoutVertexBuffer=e.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=e.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=e.createVertexBuffer(this.collisionVertexArray,Hp.members,!0)}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy())}};C("CollisionBuffers",si);var He=class{constructor(e){this.collisionBoxArray=e.collisionBoxArray,this.zoom=e.zoom,this.overscaling=e.overscaling,this.layers=e.layers,this.layerIds=this.layers.map(l=>l.id),this.index=e.index,this.pixelRatio=e.pixelRatio,this.sourceLayerIndex=e.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.sortKeyRanges=[],this.collisionCircleArray=[],this.placementInvProjMatrix=Jn.identity([]),this.placementViewportMatrix=Jn.identity([]);let n=this.layers[0]._unevaluatedLayout._values;this.textSizeData=el(this.zoom,n["text-size"]),this.iconSizeData=el(this.zoom,n["icon-size"]);let i=this.layers[0].layout,o=i.get("symbol-sort-key"),a=i.get("symbol-z-order");this.canOverlap=tl(i,"text-overlap","text-allow-overlap")!=="never"||tl(i,"icon-overlap","icon-allow-overlap")!=="never"||i.get("text-ignore-placement")||i.get("icon-ignore-placement"),this.sortFeaturesByKey=a!=="viewport-y"&&!o.isConstant();let s=a==="viewport-y"||a==="auto"&&!this.sortFeaturesByKey;this.sortFeaturesByY=s&&this.canOverlap,i.get("symbol-placement")==="point"&&(this.writingModes=i.get("text-writing-mode").map(l=>aa[l])),this.stateDependentLayerIds=this.layers.filter(l=>l.isStateDependent()).map(l=>l.id),this.sourceID=e.sourceID}createArrays(){this.text=new ai(new Ce(this.layers,this.zoom,e=>/^text/.test(e))),this.icon=new ai(new Ce(this.layers,this.zoom,e=>/^icon/.test(e))),this.glyphOffsetArray=new Bn,this.lineVertexArray=new zn,this.symbolInstances=new Vn,this.textAnchorOffsets=new Rn}calculateGlyphDependencies(e,r,n,i,o){for(let a=0;a<e.length;a++)if(r[e.charCodeAt(a)]=!0,(n||i)&&o){let s=Er[e.charAt(a)];s&&(r[s.charCodeAt(0)]=!0)}}populate(e,r,n){let i=this.layers[0],o=i.layout,a=o.get("text-font"),s=o.get("text-field"),l=o.get("icon-image"),u=(s.value.kind!=="constant"||s.value.value instanceof Fe&&!s.value.value.isEmpty()||s.value.value.toString().length>0)&&(a.value.kind!=="constant"||a.value.value.length>0),c=l.value.kind!=="constant"||!!l.value.value||Object.keys(l.parameters).length>0,p=o.get("symbol-sort-key");if(this.features=[],!u&&!c)return;let f=r.iconDependencies,y=r.glyphDependencies,m=r.availableImages,h=new q(this.zoom);for(let{feature:d,id:g,index:b,sourceLayerIndex:x}of e){let v=i._featureFilter.needGeometry,P=$e(d,v);if(!i._featureFilter.filter(h,P,n))continue;v||(P.geometry=ke(d));let w;if(u){let _=i.getValueAndResolveTokens("text-field",P,n,m),I=Fe.factory(_),k=this.hasRTLText=this.hasRTLText||Ab(I);(!k||ye.getRTLTextPluginStatus()==="unavailable"||k&&ye.isParsed())&&(w=Xp(I,i,P))}let T;if(c){let _=i.getValueAndResolveTokens("icon-image",P,n,m);_ instanceof Te?T=_:T=Te.fromString(_)}if(!w&&!T)continue;let F=this.sortFeaturesByKey?p.evaluate(P,{},n):void 0,E={id:g,text:w,icon:T,index:b,sourceLayerIndex:x,geometry:P.geometry,properties:d.properties,type:Sb[d.type],sortKey:F};if(this.features.push(E),T&&(f[T.name]=!0),w){let _=a.evaluate(P,{},n).join(","),I=o.get("text-rotation-alignment")!=="viewport"&&o.get("symbol-placement")!=="point";this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(2)>=0;for(let k of w.sections)if(k.image)f[k.image.name]=!0;else{let V=hn(w.toString()),A=k.fontStack||_,z=y[A]=y[A]||{};this.calculateGlyphDependencies(k.text,z,I,this.allowVerticalPlacement,V)}}}o.get("symbol-placement")==="line"&&(this.features=Kp(this.features)),this.sortFeaturesByKey&&this.features.sort((d,g)=>d.sortKey-g.sortKey)}update(e,r,n){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(e,r,this.layers,n),this.icon.programConfigurations.updatePaintArrays(e,r,this.layers,n))}isEmpty(){return this.symbolInstances.length===0&&!this.hasRTLText}uploadPending(){return!this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload}upload(e){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(e),this.iconCollisionBox.upload(e)),this.text.upload(e,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(e,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0}destroyDebugData(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy()}destroy(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData()}addToLineVertexArray(e,r){let n=this.lineVertexArray.length;if(e.segment!==void 0){let i=e.dist(r[e.segment+1]),o=e.dist(r[e.segment]),a={};for(let s=e.segment+1;s<r.length;s++)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:i},s<r.length-1&&(i+=r[s+1].dist(r[s]));for(let s=e.segment||0;s>=0;s--)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:o},s>0&&(o+=r[s-1].dist(r[s]));for(let s=0;s<r.length;s++){let l=a[s];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor)}}return{lineStartIndex:n,lineLength:this.lineVertexArray.length-n}}addSymbols(e,r,n,i,o,a,s,l,u,c,p,f){let y=e.indexArray,m=e.layoutVertexArray,h=e.segments.prepareSegment(4*r.length,m,y,this.canOverlap?a.sortKey:void 0),d=this.glyphOffsetArray.length,g=h.vertexLength,b=this.allowVerticalPlacement&&s===2?Math.PI/2:0,x=a.text&&a.text.sections;for(let v=0;v<r.length;v++){let{tl:P,tr:w,bl:T,br:F,tex:E,pixelOffsetTL:_,pixelOffsetBR:I,minFontScaleX:k,minFontScaleY:V,glyphOffset:A,isSDF:z,sectionIndex:O}=r[v],N=h.vertexLength,K=A[1];sa(m,l.x,l.y,P.x,K+P.y,E.x,E.y,n,z,_.x,_.y,k,V),sa(m,l.x,l.y,w.x,K+w.y,E.x+E.w,E.y,n,z,I.x,_.y,k,V),sa(m,l.x,l.y,T.x,K+T.y,E.x,E.y+E.h,n,z,_.x,I.y,k,V),sa(m,l.x,l.y,F.x,K+F.y,E.x+E.w,E.y+E.h,n,z,I.x,I.y,k,V),hf(e.dynamicLayoutVertexArray,l,b),y.emplaceBack(N,N+1,N+2),y.emplaceBack(N+1,N+2,N+3),h.vertexLength+=4,h.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(A[0]),(v===r.length-1||O!==r[v+1].sectionIndex)&&e.programConfigurations.populatePaintArrays(m.length,a,a.index,{},f,x&&x[O])}e.placedSymbolArray.emplaceBack(l.x,l.y,d,this.glyphOffsetArray.length-d,g,u,c,l.segment,n?n[0]:0,n?n[1]:0,i[0],i[1],s,0,!1,0,p)}_addCollisionDebugVertex(e,r,n,i,o,a){return r.emplaceBack(0,0),e.emplaceBack(n.x,n.y,i,o,Math.round(a.x),Math.round(a.y))}addCollisionDebugVertices(e,r,n,i,o,a,s){let l=o.segments.prepareSegment(4,o.layoutVertexArray,o.indexArray),u=l.vertexLength,c=o.layoutVertexArray,p=o.collisionVertexArray,f=s.anchorX,y=s.anchorY;this._addCollisionDebugVertex(c,p,a,f,y,new oi.default(e,r)),this._addCollisionDebugVertex(c,p,a,f,y,new oi.default(n,r)),this._addCollisionDebugVertex(c,p,a,f,y,new oi.default(n,i)),this._addCollisionDebugVertex(c,p,a,f,y,new oi.default(e,i)),l.vertexLength+=4;let m=o.indexArray;m.emplaceBack(u,u+1),m.emplaceBack(u+1,u+2),m.emplaceBack(u+2,u+3),m.emplaceBack(u+3,u),l.primitiveLength+=4}addDebugCollisionBoxes(e,r,n,i){for(let o=e;o<r;o++){let a=this.collisionBoxArray.get(o),s=a.x1,l=a.y1,u=a.x2,c=a.y2;this.addCollisionDebugVertices(s,l,u,c,i?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,n)}}generateCollisionDebugBuffers(){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new si(Nn,Hs.members,wt),this.iconCollisionBox=new si(Nn,Hs.members,wt);for(let e=0;e<this.symbolInstances.length;e++){let r=this.symbolInstances.get(e);this.addDebugCollisionBoxes(r.textBoxStartIndex,r.textBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.iconBoxStartIndex,r.iconBoxEndIndex,r,!1),this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex,r,!1)}}_deserializeCollisionBoxesForSymbol(e,r,n,i,o,a,s,l,u){let c={};for(let p=r;p<n;p++){let f=e.get(p);c.textBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.textFeatureIndex=f.featureIndex;break}for(let p=i;p<o;p++){let f=e.get(p);c.verticalTextBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalTextFeatureIndex=f.featureIndex;break}for(let p=a;p<s;p++){let f=e.get(p);c.iconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.iconFeatureIndex=f.featureIndex;break}for(let p=l;p<u;p++){let f=e.get(p);c.verticalIconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalIconFeatureIndex=f.featureIndex;break}return c}deserializeCollisionBoxes(e){this.collisionArrays=[];for(let r=0;r<this.symbolInstances.length;r++){let n=this.symbolInstances.get(r);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e,n.textBoxStartIndex,n.textBoxEndIndex,n.verticalTextBoxStartIndex,n.verticalTextBoxEndIndex,n.iconBoxStartIndex,n.iconBoxEndIndex,n.verticalIconBoxStartIndex,n.verticalIconBoxEndIndex))}}hasTextData(){return this.text.segments.get().length>0}hasIconData(){return this.icon.segments.get().length>0}hasDebugData(){return this.textCollisionBox&&this.iconCollisionBox}hasTextCollisionBoxData(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0}hasIconCollisionBoxData(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0}addIndicesForPlacedSymbol(e,r){let n=e.placedSymbolArray.get(r),i=n.vertexStartIndex+n.numGlyphs*4;for(let o=n.vertexStartIndex;o<i;o+=4)e.indexArray.emplaceBack(o,o+1,o+2),e.indexArray.emplaceBack(o+1,o+2,o+3)}getSortedSymbolIndexes(e){if(this.sortedAngle===e&&this.symbolInstanceIndexes!==void 0)return this.symbolInstanceIndexes;let r=Math.sin(e),n=Math.cos(e),i=[],o=[],a=[];for(let s=0;s<this.symbolInstances.length;++s){a.push(s);let l=this.symbolInstances.get(s);i.push(Math.round(r*l.anchorX+n*l.anchorY)|0),o.push(l.featureIndex)}return a.sort((s,l)=>i[s]-i[l]||o[l]-o[s]),a}addToSortKeyRanges(e,r){let n=this.sortKeyRanges[this.sortKeyRanges.length-1];n&&n.sortKey===r?n.symbolInstanceEnd=e+1:this.sortKeyRanges.push({sortKey:r,symbolInstanceStart:e,symbolInstanceEnd:e+1})}sortFeatures(e){if(this.sortFeaturesByY&&this.sortedAngle!==e&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(e),this.sortedAngle=e,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(let r of this.symbolInstanceIndexes){let n=this.symbolInstances.get(r);this.featureSortOrder.push(n.featureIndex),[n.rightJustifiedTextSymbolIndex,n.centerJustifiedTextSymbolIndex,n.leftJustifiedTextSymbolIndex].forEach((i,o,a)=>{i>=0&&a.indexOf(i)===o&&this.addIndicesForPlacedSymbol(this.text,i)}),n.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.text,n.verticalPlacedTextSymbolIndex),n.placedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.placedIconSymbolIndex),n.verticalPlacedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.verticalPlacedIconSymbolIndex)}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray)}}};C("SymbolBucket",He,{omit:["layers","collisionBoxArray","features","compareText"]});He.MAX_GLYPHS=65535;He.addDynamicAttributes=hf;function df(t,e){return e.replace(/{([^{}]+)}/g,(r,n)=>t&&n in t?String(t[n]):"")}var gf,_b=()=>gf=gf||new re({"symbol-placement":new B(S.layout_symbol["symbol-placement"]),"symbol-spacing":new B(S.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new B(S.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new R(S.layout_symbol["symbol-sort-key"]),"symbol-z-order":new B(S.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new B(S.layout_symbol["icon-allow-overlap"]),"icon-overlap":new B(S.layout_symbol["icon-overlap"]),"icon-ignore-placement":new B(S.layout_symbol["icon-ignore-placement"]),"icon-optional":new B(S.layout_symbol["icon-optional"]),"icon-rotation-alignment":new B(S.layout_symbol["icon-rotation-alignment"]),"icon-size":new R(S.layout_symbol["icon-size"]),"icon-text-fit":new B(S.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new B(S.layout_symbol["icon-text-fit-padding"]),"icon-image":new R(S.layout_symbol["icon-image"]),"icon-rotate":new R(S.layout_symbol["icon-rotate"]),"icon-padding":new R(S.layout_symbol["icon-padding"]),"icon-keep-upright":new B(S.layout_symbol["icon-keep-upright"]),"icon-offset":new R(S.layout_symbol["icon-offset"]),"icon-anchor":new R(S.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new B(S.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new B(S.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new B(S.layout_symbol["text-rotation-alignment"]),"text-field":new R(S.layout_symbol["text-field"]),"text-font":new R(S.layout_symbol["text-font"]),"text-size":new R(S.layout_symbol["text-size"]),"text-max-width":new R(S.layout_symbol["text-max-width"]),"text-line-height":new B(S.layout_symbol["text-line-height"]),"text-letter-spacing":new R(S.layout_symbol["text-letter-spacing"]),"text-justify":new R(S.layout_symbol["text-justify"]),"text-radial-offset":new R(S.layout_symbol["text-radial-offset"]),"text-variable-anchor":new B(S.layout_symbol["text-variable-anchor"]),"text-variable-anchor-offset":new R(S.layout_symbol["text-variable-anchor-offset"]),"text-anchor":new R(S.layout_symbol["text-anchor"]),"text-max-angle":new B(S.layout_symbol["text-max-angle"]),"text-writing-mode":new B(S.layout_symbol["text-writing-mode"]),"text-rotate":new R(S.layout_symbol["text-rotate"]),"text-padding":new B(S.layout_symbol["text-padding"]),"text-keep-upright":new B(S.layout_symbol["text-keep-upright"]),"text-transform":new R(S.layout_symbol["text-transform"]),"text-offset":new R(S.layout_symbol["text-offset"]),"text-allow-overlap":new B(S.layout_symbol["text-allow-overlap"]),"text-overlap":new B(S.layout_symbol["text-overlap"]),"text-ignore-placement":new B(S.layout_symbol["text-ignore-placement"]),"text-optional":new B(S.layout_symbol["text-optional"])}),xf,Ib=()=>xf=xf||new re({"icon-opacity":new R(S.paint_symbol["icon-opacity"]),"icon-color":new R(S.paint_symbol["icon-color"]),"icon-halo-color":new R(S.paint_symbol["icon-halo-color"]),"icon-halo-width":new R(S.paint_symbol["icon-halo-width"]),"icon-halo-blur":new R(S.paint_symbol["icon-halo-blur"]),"icon-translate":new B(S.paint_symbol["icon-translate"]),"icon-translate-anchor":new B(S.paint_symbol["icon-translate-anchor"]),"text-opacity":new R(S.paint_symbol["text-opacity"]),"text-color":new R(S.paint_symbol["text-color"],{runtimeType:Re,getOverride:t=>t.textColor,hasOverride:t=>!!t.textColor}),"text-halo-color":new R(S.paint_symbol["text-halo-color"]),"text-halo-width":new R(S.paint_symbol["text-halo-width"]),"text-halo-blur":new R(S.paint_symbol["text-halo-blur"]),"text-translate":new B(S.paint_symbol["text-translate"]),"text-translate-anchor":new B(S.paint_symbol["text-translate-anchor"])}),la={get paint(){return Ib()},get layout(){return _b()}};var li=class{constructor(e){if(e.property.overrides===void 0)throw new Error("overrides must be provided to instantiate FormatSectionOverride class");this.type=e.property.overrides?e.property.overrides.runtimeType:hr,this.defaultValue=e}evaluate(e){if(e.formattedSection){let r=this.defaultValue.property.overrides;if(r&&r.hasOverride(e.formattedSection))return r.getOverride(e.formattedSection)}return e.feature&&e.featureState?this.defaultValue.evaluate(e.feature,e.featureState):this.defaultValue.property.specification.default}eachChild(e){if(!this.defaultValue.isConstant()){let r=this.defaultValue.value;e(r._styleExpression.expression)}}outputDefined(){return!1}serialize(){return null}};C("FormatSectionOverride",li,{omit:["defaultValue"]});var ua=class t extends se{constructor(e){super(e,la)}recalculate(e,r){if(super.recalculate(e,r),this.layout.get("icon-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["icon-rotation-alignment"]="map":this.layout._values["icon-rotation-alignment"]="viewport"),this.layout.get("text-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["text-rotation-alignment"]="map":this.layout._values["text-rotation-alignment"]="viewport"),this.layout.get("text-pitch-alignment")==="auto"&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")==="map"?"map":"viewport"),this.layout.get("icon-pitch-alignment")==="auto"&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),this.layout.get("symbol-placement")==="point"){let n=this.layout.get("text-writing-mode");if(n){let i=[];for(let o of n)i.indexOf(o)<0&&i.push(o);this.layout._values["text-writing-mode"]=i}else this.layout._values["text-writing-mode"]=["horizontal"]}this._setPaintOverrides()}getValueAndResolveTokens(e,r,n,i){let o=this.layout.get(e).evaluate(r,{},n,i),a=this._unevaluatedLayout._values[e];return!a.isDataDriven()&&!qt(a.value)&&o?df(r.properties,o):o}createBucket(e){return new He(e)}queryRadius(){return 0}queryIntersectsFeature(){throw new Error("Should take a different path in FeatureIndex")}_setPaintOverrides(){for(let e of la.paint.overridableProperties){if(!t.hasPaintOverride(this.layout,e))continue;let r=this.paint.get(e),n=new li(r),i=new Nt(n,r.property.specification),o=null;r.value.kind==="constant"||r.value.kind==="source"?o=new dt("source",i):o=new gt("composite",i,r.value.zoomStops),this.paint._values[e]=new Se(r.property,o,r.parameters)}}_handleOverridablePaintPropertyUpdate(e,r,n){return!this.layout||r.isDataDriven()||n.isDataDriven()?!1:t.hasPaintOverride(this.layout,e)}static hasPaintOverride(e,r){let n=e.get("text-field"),i=la.paint.properties[r],o=!1,a=s=>{for(let l of s)if(i.overrides&&i.overrides.hasOverride(l)){o=!0;return}};if(n.value.kind==="constant"&&n.value.value instanceof Fe)a(n.value.value.sections);else if(n.value.kind==="source"){let s=u=>{if(!o)if(u instanceof mt&&ue(u.value)===dr){let c=u.value;a(c.sections)}else u instanceof tn?a(u.sections):u.eachChild(s)},l=n.value;l._styleExpression&&s(l._styleExpression.expression)}return o}};function bf(t,e,r,n=1){let i=t.get("icon-padding").evaluate(e,{},r),o=i&&i.values;return[o[0]*n,o[1]*n,o[2]*n,o[3]*n]}var vf,Tb=()=>vf=vf||new re({"background-color":new B(S.paint_background["background-color"]),"background-pattern":new Jt(S.paint_background["background-pattern"]),"background-opacity":new B(S.paint_background["background-opacity"])}),Pf={get paint(){return Tb()}};var ca=class extends se{constructor(e){super(e,Pf)}};var Sf,Cb=()=>Sf=Sf||new re({"raster-opacity":new B(S.paint_raster["raster-opacity"]),"raster-hue-rotate":new B(S.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new B(S.paint_raster["raster-brightness-min"]),"raster-brightness-max":new B(S.paint_raster["raster-brightness-max"]),"raster-saturation":new B(S.paint_raster["raster-saturation"]),"raster-contrast":new B(S.paint_raster["raster-contrast"]),"raster-resampling":new B(S.paint_raster["raster-resampling"]),"raster-fade-duration":new B(S.paint_raster["raster-fade-duration"])}),wf={get paint(){return Cb()}};var pa=class extends se{constructor(e){super(e,wf)}};var fa=class extends se{constructor(r){super(r,{});this.onAdd=r=>{this.implementation.onAdd&&this.implementation.onAdd(r,r.painter.context.gl)};this.onRemove=r=>{this.implementation.onRemove&&this.implementation.onRemove(r,r.painter.context.gl)};this.implementation=r}is3D(){return this.implementation.renderingMode==="3d"}hasOffscreenPass(){return this.implementation.prerender!==void 0}recalculate(){}updateTransitions(){}hasTransition(){return!1}serialize(){throw new Error("Custom layers cannot be serialized")}};function Af(t){if(t.type==="custom")return new fa(t);switch(t.type){case"background":return new ca(t);case"circle":return new Uo(t);case"fill":return new Wo(t);case"fill-extrusion":return new Ko(t);case"heatmap":return new $o(t);case"hillshade":return new Go(t);case"line":return new Qo(t);case"raster":return new pa(t);case"symbol":return new ua(t)}}var ya=class{constructor(e){this.keyCache={},e&&this.replace(e)}replace(e){this._layerConfigs={},this._layers={},this.update(e,[])}update(e,r){for(let i of e){this._layerConfigs[i.id]=i;let o=this._layers[i.id]=Af(i);o._featureFilter=yn(o.filter),this.keyCache[i.id]&&delete this.keyCache[i.id]}for(let i of r)delete this.keyCache[i],delete this._layerConfigs[i],delete this._layers[i];this.familiesBySource={};let n=qu(Object.values(this._layerConfigs),this.keyCache);for(let i of n){let o=i.map(p=>this._layers[p.id]),a=o[0];if(a.visibility==="none")continue;let s=a.source||"",l=this.familiesBySource[s];l||(l=this.familiesBySource[s]={});let u=a.sourceLayer||"_geojsonTileLayer",c=l[u];c||(c=l[u]=[]),c.push(o)}}};var Hf=Z(Tt(),1),Xf=Z(ei(),1);var Br=class{constructor(e){this._stringToNumber={},this._numberToString=[];for(let r=0;r<e.length;r++){let n=e[r];this._stringToNumber[n]=r,this._numberToString[r]=n}}encode(e){return this._stringToNumber[e]}decode(e){if(e>=this._numberToString.length)throw new Error("Out of bounds. Index requested n=".concat(e," can't be >= this._numberToString.length ").concat(this._numberToString.length));return this._numberToString[e]}};var Tf=Z(Tt(),1),Cf=Z(ei(),1);var ma=class{constructor(e,r,n,i,o){this.type="Feature",this._vectorTileFeature=e,e._z=r,e._x=n,e._y=i,this.properties=e.properties,this.id=o}get geometry(){return this._geometry===void 0&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry}set geometry(e){this._geometry=e}toJSON(){let e={geometry:this.geometry};for(let r in this)r==="_geometry"||r==="_vectorTileFeature"||(e[r]=this[r]);return e}};var ui=class{constructor(e,r){this.tileID=e,this.x=e.canonical.x,this.y=e.canonical.y,this.z=e.canonical.z,this.grid=new Vt(8192,16,0),this.grid3D=new Vt(8192,16,0),this.featureIndexArray=new On,this.promoteId=r}insert(e,r,n,i,o,a){let s=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(n,i,o);let l=a?this.grid3D:this.grid;for(let u=0;u<r.length;u++){let c=r[u],p=[1/0,1/0,-1/0,-1/0];for(let f=0;f<c.length;f++){let y=c[f];p[0]=Math.min(p[0],y.x),p[1]=Math.min(p[1],y.y),p[2]=Math.max(p[2],y.x),p[3]=Math.max(p[3],y.y)}p[0]<8192&&p[1]<8192&&p[2]>=0&&p[3]>=0&&l.insert(s,p[0],p[1],p[2],p[3])}}loadVTLayers(){return this.vtLayers||(this.vtLayers=new Tf.default.VectorTile(new Cf.default(this.rawTileData)).layers,this.sourceLayerCoder=new Br(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers}query(e,r,n,i){this.loadVTLayers();let o=e.params||{},a=8192/e.tileSize/e.scale,s=yn(o.filter),l=e.queryGeometry,u=e.queryPadding*a,c=If(l),p=this.grid.query(c.minX-u,c.minY-u,c.maxX+u,c.maxY+u),f=If(e.cameraQueryGeometry),y=this.grid3D.query(f.minX-u,f.minY-u,f.maxX+u,f.maxY+u,(d,g,b,x)=>Uc(e.cameraQueryGeometry,d-u,g-u,b+u,x+u));for(let d of y)p.push(d);p.sort(kb);let m={},h;for(let d=0;d<p.length;d++){let g=p[d];if(g===h)continue;h=g;let b=this.featureIndexArray.get(g),x=null;this.loadMatchingFeature(m,b.bucketIndex,b.sourceLayerIndex,b.featureIndex,s,o.layers,o.availableImages,r,n,i,(v,P,w)=>(x||(x=ke(v)),P.queryIntersectsFeature(l,v,w,x,this.z,e.transform,a,e.pixelPosMatrix)))}return m}loadMatchingFeature(e,r,n,i,o,a,s,l,u,c,p){let f=this.bucketLayerIDs[r];if(a&&!Yl(a,f))return;let y=this.sourceLayerCoder.decode(n),h=this.vtLayers[y].feature(i);if(o.needGeometry){let g=$e(h,!0);if(!o.filter(new q(this.tileID.overscaledZ),g,this.tileID.canonical))return}else if(!o.filter(new q(this.tileID.overscaledZ),h))return;let d=this.getId(h,y);for(let g=0;g<f.length;g++){let b=f[g];if(a&&a.indexOf(b)<0)continue;let x=l[b];if(!x)continue;let v={};d&&c&&(v=c.getState(x.sourceLayer||"_geojsonTileLayer",d));let P=Pe({},u[b]);P.paint=_f(P.paint,x.paint,h,v,s),P.layout=_f(P.layout,x.layout,h,v,s);let w=!p||p(h,x,v);if(!w)continue;let T=new ma(h,this.z,this.x,this.y,d);T.layer=P;let F=e[b];F===void 0&&(F=e[b]=[]),F.push({featureIndex:i,feature:T,intersectionZ:w})}}lookupSymbolFeatures(e,r,n,i,o,a,s,l){let u={};this.loadVTLayers();let c=yn(o);for(let p of e)this.loadMatchingFeature(u,n,i,p,c,a,s,l,r);return u}hasLayer(e){for(let r of this.bucketLayerIDs)for(let n of r)if(e===n)return!0;return!1}getId(e,r){let n=e.id;if(this.promoteId){let i=typeof this.promoteId=="string"?this.promoteId:this.promoteId[r];n=e.properties[i],typeof n=="boolean"&&(n=Number(n))}return n}};C("FeatureIndex",ui,{omit:["rawTileData","sourceLayerCoder"]});function _f(t,e,r,n,i){return jr(t,(o,a)=>{let s=e instanceof vt?e.get(a):null;return s&&s.evaluate?s.evaluate(r,n,i):s})}function If(t){let e=1/0,r=1/0,n=-1/0,i=-1/0;for(let o of t)e=Math.min(e,o.x),r=Math.min(r,o.y),n=Math.max(n,o.x),i=Math.max(i,o.y);return{minX:e,minY:r,maxX:n,maxY:i}}function kb(t,e){return e-t}var kf=Z(he(),1);var rt=class t extends kf.default{constructor(e,r,n,i){super(e,r),this.angle=n,i!==void 0&&(this.segment=i)}clone(){return new t(this.x,this.y,this.angle,this.segment)}};C("Anchor",rt);function rl(t,e,r,n,i){if(e.segment===void 0||r===0)return!0;let o=e,a=e.segment+1,s=0;for(;s>-r/2;){if(a--,a<0)return!1;s-=t[a].dist(o),o=t[a]}s+=t[a].dist(t[a+1]),a++;let l=[],u=0;for(;s<r/2;){let c=t[a-1],p=t[a],f=t[a+1];if(!f)return!1;let y=c.angleTo(p)-p.angleTo(f);for(y=Math.abs((y+3*Math.PI)%(Math.PI*2)-Math.PI),l.push({distance:s,angleDelta:y}),u+=y;s-l[0].distance>n;)u-=l.shift().angleDelta;if(u>i)return!1;a++,s+=p.dist(f)}return!0}function Mf(t){let e=0;for(let r=0;r<t.length-1;r++)e+=t[r].dist(t[r+1]);return e}function Ef(t,e,r){return t?3/5*e*r:0}function Ff(t,e){return Math.max(t?t.right-t.left:0,e?e.right-e.left:0)}function Lf(t,e,r,n,i,o){let a=Ef(r,i,o),s=Ff(r,n)*o,l=0,u=Mf(t)/2;for(let c=0;c<t.length-1;c++){let p=t[c],f=t[c+1],y=p.dist(f);if(l+y>u){let m=(u-l)/y,h=Oe.number(p.x,f.x,m),d=Oe.number(p.y,f.y,m),g=new rt(h,d,f.angleTo(p),c);return g._round(),!a||rl(t,g,s,a,e)?g:void 0}l+=y}}function Df(t,e,r,n,i,o,a,s,l){let u=Ef(n,o,a),c=Ff(n,i),p=c*a,f=t[0].x===0||t[0].x===l||t[0].y===0||t[0].y===l;e-p<e/4&&(e=p+e/4);let y=o*2,m=f?e/2*s%e:(c/2+y)*a*s%e;return Vf(t,m,e,u,r,p,f,!1,l)}function Vf(t,e,r,n,i,o,a,s,l){let u=o/2,c=Mf(t),p=0,f=e-r,y=[];for(let m=0;m<t.length-1;m++){let h=t[m],d=t[m+1],g=h.dist(d),b=d.angleTo(h);for(;f+r<p+g;){f+=r;let x=(f-p)/g,v=Oe.number(h.x,d.x,x),P=Oe.number(h.y,d.y,x);if(v>=0&&v<l&&P>=0&&P<l&&f-u>=0&&f+u<=c){let w=new rt(v,P,b,m);w._round(),(!n||rl(t,w,o,n,i))&&y.push(w)}}p+=g}return!s&&!y.length&&!a&&(y=Vf(t,p/2,r,n,i,o,a,!0,l)),y}var pt=Z(he(),1);function Bf(t,e,r,n,i){let o=[];for(let a=0;a<t.length;a++){let s=t[a],l;for(let u=0;u<s.length-1;u++){let c=s[u],p=s[u+1];c.x<e&&p.x<e||(c.x<e?c=new pt.default(e,c.y+(p.y-c.y)*((e-c.x)/(p.x-c.x)))._round():p.x<e&&(p=new pt.default(e,c.y+(p.y-c.y)*((e-c.x)/(p.x-c.x)))._round()),!(c.y<r&&p.y<r)&&(c.y<r?c=new pt.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round():p.y<r&&(p=new pt.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round()),!(c.x>=n&&p.x>=n)&&(c.x>=n?c=new pt.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round():p.x>=n&&(p=new pt.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round()),!(c.y>=i&&p.y>=i)&&(c.y>=i?c=new pt.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round():p.y>=i&&(p=new pt.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round()),(!l||!c.equals(l[l.length-1]))&&(l=[c],o.push(l)),l.push(p)))))}}return o}var we=Z(he(),1);var zr=ge;function nl(t,e,r,n){let i=[],o=t.image,a=o.pixelRatio,s=o.paddedRect.w-2*zr,l=o.paddedRect.h-2*zr,u=t.right-t.left,c=t.bottom-t.top,p=o.stretchX||[[0,s]],f=o.stretchY||[[0,l]],y=(I,k)=>I+k[1]-k[0],m=p.reduce(y,0),h=f.reduce(y,0),d=s-m,g=l-h,b=0,x=m,v=0,P=h,w=0,T=d,F=0,E=g;if(o.content&&n){let I=o.content;b=ha(p,0,I[0]),v=ha(f,0,I[1]),x=ha(p,I[0],I[2]),P=ha(f,I[1],I[3]),w=I[0]-b,F=I[1]-v,T=I[2]-I[0]-x,E=I[3]-I[1]-P}let _=(I,k,V,A)=>{let z=da(I.stretch-b,x,u,t.left),O=ga(I.fixed-w,T,I.stretch,m),N=da(k.stretch-v,P,c,t.top),K=ga(k.fixed-F,E,k.stretch,h),xe=da(V.stretch-b,x,u,t.left),X=ga(V.fixed-w,T,V.stretch,m),le=da(A.stretch-v,P,c,t.top),ce=ga(A.fixed-F,E,A.stretch,h),pe=new we.default(z,N),_e=new we.default(xe,N),be=new we.default(xe,le),Ai=new we.default(z,le),Da=new we.default(O/a,K/a),Va=new we.default(X/a,ce/a),Ur=e*Math.PI/180;if(Ur){let Ie=Math.sin(Ur),ve=Math.cos(Ur),Ve=[ve,-Ie,Ie,ve];pe._matMult(Ve),_e._matMult(Ve),Ai._matMult(Ve),be._matMult(Ve)}let _i=I.stretch+I.fixed,Me=V.stretch+V.fixed,Ft=k.stretch+k.fixed,Ii=A.stretch+A.fixed,Ba={x:o.paddedRect.x+zr+_i,y:o.paddedRect.y+zr+Ft,w:Me-_i,h:Ii-Ft},za=T/a/u,Ra=E/a/c;return{tl:pe,tr:_e,bl:Ai,br:be,tex:Ba,writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:Da,pixelOffsetBR:Va,minFontScaleX:za,minFontScaleY:Ra,isSDF:r}};if(!n||!o.stretchX&&!o.stretchY)i.push(_({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:s+1},{fixed:0,stretch:l+1}));else{let I=zf(p,d,m),k=zf(f,g,h);for(let V=0;V<I.length-1;V++){let A=I[V],z=I[V+1];for(let O=0;O<k.length-1;O++){let N=k[O],K=k[O+1];i.push(_(A,N,z,K))}}}return i}function ha(t,e,r){let n=0;for(let i of t)n+=Math.max(e,Math.min(r,i[1]))-Math.max(e,Math.min(r,i[0]));return n}function zf(t,e,r){let n=[{fixed:-zr,stretch:0}];for(let[i,o]of t){let a=n[n.length-1];n.push({fixed:i-a.stretch,stretch:a.stretch}),n.push({fixed:i-a.stretch,stretch:a.stretch+(o-i)})}return n.push({fixed:e+zr,stretch:r}),n}function da(t,e,r,n){return t/e*r+n}function ga(t,e,r,n){return t-e*r/n}function Rf(t,e,r,n,i,o,a,s){let l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,u=[];for(let c of e.positionedLines)for(let p of c.positionedGlyphs){if(!p.rect)continue;let f=p.rect||{},m=ra+1,h=!0,d=1,g=0,b=(i||s)&&p.vertical,x=p.metrics.advance*p.scale/2;if(s&&e.verticalizable){let X=(p.scale-1)*ne,le=(ne-p.metrics.width*p.scale)/2;g=c.lineOffset/2-(p.imageName?-le:X)}if(p.imageName){let X=a[p.imageName];h=X.sdf,d=X.pixelRatio,m=ge/d}let v=i?[p.x+x,p.y]:[0,0],P=i?[0,0]:[p.x+x+r[0],p.y+r[1]-g],w=[0,0];b&&(w=P,P=[0,0]);let T=p.metrics.isDoubleResolution?2:1,F=(p.metrics.left-m)*p.scale-x+P[0],E=(-p.metrics.top-m)*p.scale+P[1],_=F+f.w/T*p.scale/d,I=E+f.h/T*p.scale/d,k=new we.default(F,E),V=new we.default(_,E),A=new we.default(F,I),z=new we.default(_,I);if(b){let X=new we.default(-x,x-Dr),le=-Math.PI/2,ce=ne/2-x,pe=p.imageName?ce:0,_e=new we.default(5-Dr-ce,-pe),be=new we.default(...w);k._rotateAround(le,X)._add(_e)._add(be),V._rotateAround(le,X)._add(_e)._add(be),A._rotateAround(le,X)._add(_e)._add(be),z._rotateAround(le,X)._add(_e)._add(be)}if(l){let X=Math.sin(l),le=Math.cos(l),ce=[le,-X,X,le];k._matMult(ce),V._matMult(ce),A._matMult(ce),z._matMult(ce)}let O=new we.default(0,0),N=new we.default(0,0);u.push({tl:k,tr:V,bl:A,br:z,tex:f,writingMode:e.writingMode,glyphOffset:v,sectionIndex:p.sectionIndex,isSDF:h,pixelOffsetTL:O,pixelOffsetBR:N,minFontScaleX:0,minFontScaleY:0})}return u}var ci=Z(he(),1),or=class{constructor(e,r,n,i,o,a,s,l,u,c){if(this.boxStartIndex=e.length,u){let p=a.top,f=a.bottom,y=a.collisionPadding;y&&(p-=y[1],f+=y[3]);let m=f-p;m>0&&(m=Math.max(10,m),this.circleDiameter=m)}else{let p=a.top*s-l[0],f=a.bottom*s+l[2],y=a.left*s-l[3],m=a.right*s+l[1],h=a.collisionPadding;if(h&&(y-=h[0]*s,p-=h[1]*s,m+=h[2]*s,f+=h[3]*s),c){let d=new ci.default(y,p),g=new ci.default(m,p),b=new ci.default(y,f),x=new ci.default(m,f),v=c*Math.PI/180;d._rotate(v),g._rotate(v),b._rotate(v),x._rotate(v),y=Math.min(d.x,g.x,b.x,x.x),m=Math.max(d.x,g.x,b.x,x.x),p=Math.min(d.y,g.y,b.y,x.y),f=Math.max(d.y,g.y,b.y,x.y)}e.emplaceBack(r.x,r.y,y,p,m,f,n,i,o)}this.boxEndIndex=e.length}};var pi=class{constructor(e=[],r=Mb){if(this.data=e,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(e){this.data.push(e),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;let e=this.data[0],r=this.data.pop();return this.length--,this.length>0&&(this.data[0]=r,this._down(0)),e}peek(){return this.data[0]}_up(e){let{data:r,compare:n}=this,i=r[e];for(;e>0;){let o=e-1>>1,a=r[o];if(n(i,a)>=0)break;r[e]=a,e=o}r[e]=i}_down(e){let{data:r,compare:n}=this,i=this.length>>1,o=r[e];for(;e<i;){let a=(e<<1)+1,s=r[a],l=a+1;if(l<this.length&&n(r[l],s)<0&&(a=l,s=r[l]),n(s,o)>=0)break;r[e]=s,e=a}r[e]=o}};function Mb(t,e){return t<e?-1:t>e?1:0}var il=Z(he(),1);function Of(t,e=1,r=!1){let n=1/0,i=1/0,o=-1/0,a=-1/0,s=t[0];for(let h=0;h<s.length;h++){let d=s[h];(!h||d.x<n)&&(n=d.x),(!h||d.y<i)&&(i=d.y),(!h||d.x>o)&&(o=d.x),(!h||d.y>a)&&(a=d.y)}let l=o-n,u=a-i,c=Math.min(l,u),p=c/2,f=new pi([],Eb);if(c===0)return new il.default(n,i);for(let h=n;h<o;h+=c)for(let d=i;d<a;d+=c)f.push(new Rr(h+p,d+p,p,t));let y=Lb(t),m=f.length;for(;f.length;){let h=f.pop();(h.d>y.d||!y.d)&&(y=h,r&&console.log("found best %d after %d probes",Math.round(1e4*h.d)/1e4,m)),!(h.max-y.d<=e)&&(p=h.h/2,f.push(new Rr(h.p.x-p,h.p.y-p,p,t)),f.push(new Rr(h.p.x+p,h.p.y-p,p,t)),f.push(new Rr(h.p.x-p,h.p.y+p,p,t)),f.push(new Rr(h.p.x+p,h.p.y+p,p,t)),m+=4)}return r&&(console.log("num probes: ".concat(m)),console.log("best distance: ".concat(y.d))),y.p}function Eb(t,e){return e.max-t.max}function Rr(t,e,r,n){this.p=new il.default(t,e),this.h=r,this.d=Fb(this.p,n),this.max=this.d+this.h*Math.SQRT2}function Fb(t,e){let r=!1,n=1/0;for(let i=0;i<e.length;i++){let o=e[i];for(let a=0,s=o.length,l=s-1;a<s;l=a++){let u=o[a],c=o[l];u.y>t.y!=c.y>t.y&&t.x<(c.x-u.x)*(t.y-u.y)/(c.y-u.y)+u.x&&(r=!r),n=Math.min(n,Vs(t,u,c))}}return(r?1:-1)*Math.sqrt(n)}function Lb(t){let e=0,r=0,n=0,i=t[0];for(let o=0,a=i.length,s=a-1;o<a;s=o++){let l=i[o],u=i[s],c=l.x*u.y-u.x*l.y;r+=(l.x+u.x)*c,n+=(l.y+u.y)*c,e+=c*3}return new Rr(r/e,n/e,0,t)}var ll=Z(ks(),1);var ol=(o=>(o[o.center=1]="center",o[o.left=2]="left",o[o.right=3]="right",o[o.top=4]="top",o[o.bottom=5]="bottom",o[o["top-left"]=6]="top-left",o[o["top-right"]=7]="top-right",o[o["bottom-left"]=8]="bottom-left",o[o["bottom-right"]=9]="bottom-right",o))(ol||{}),kt=7,xa=Number.POSITIVE_INFINITY;function al(t,e){function r(i,o){let a=0,s=0;o<0&&(o=0);let l=o/Math.SQRT2;switch(i){case"top-right":case"top-left":s=l-kt;break;case"bottom-right":case"bottom-left":s=-l+kt;break;case"bottom":s=-o+kt;break;case"top":s=o-kt;break}switch(i){case"top-right":case"bottom-right":a=-l;break;case"top-left":case"bottom-left":a=l;break;case"left":a=o;break;case"right":a=-o;break}return[a,s]}function n(i,o,a){let s=0,l=0;switch(o=Math.abs(o),a=Math.abs(a),i){case"top-right":case"top-left":case"top":l=a-kt;break;case"bottom-right":case"bottom-left":case"bottom":l=-a+kt;break}switch(i){case"top-right":case"bottom-right":case"right":s=-o;break;case"top-left":case"bottom-left":case"left":s=o;break}return[s,l]}return e[1]!==xa?n(t,e[0],e[1]):r(t,e[0])}function sl(t,e,r){var a;let n=t.layout,i=(a=n.get("text-variable-anchor-offset"))==null?void 0:a.evaluate(e,{},r);if(i){let s=i.values,l=[];for(let u=0;u<s.length;u+=2){let c=l[u]=s[u],p=s[u+1].map(f=>f*ne);c.startsWith("top")?p[1]-=kt:c.startsWith("bottom")&&(p[1]+=kt),l[u+1]=p}return new Ne(l)}let o=n.get("text-variable-anchor");if(o){let s;t._unevaluatedLayout.getValue("text-radial-offset")!==void 0?s=[n.get("text-radial-offset").evaluate(e,{},r)*ne,xa]:s=n.get("text-offset").evaluate(e,{},r).map(c=>c*ne);let u=[];for(let c of o)u.push(c,al(c,s));return new Ne(u)}return null}function $f(t){t.bucket.createArrays();let e=512*t.bucket.overscaling;t.bucket.tilePixelRatio=8192/e,t.bucket.compareText={},t.bucket.iconsNeedLinear=!1;let r=t.bucket.layers[0],n=r.layout,i=r._unevaluatedLayout._values,o={layoutIconSize:i["icon-size"].possiblyEvaluate(new q(t.bucket.zoom+1),t.canonical),layoutTextSize:i["text-size"].possiblyEvaluate(new q(t.bucket.zoom+1),t.canonical),textMaxSize:i["text-size"].possiblyEvaluate(new q(18))};if(t.bucket.textSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=t.bucket.textSizeData;o.compositeTextSizes=[i["text-size"].possiblyEvaluate(new q(c),t.canonical),i["text-size"].possiblyEvaluate(new q(p),t.canonical)]}if(t.bucket.iconSizeData.kind==="composite"){let{minZoom:c,maxZoom:p}=t.bucket.iconSizeData;o.compositeIconSizes=[i["icon-size"].possiblyEvaluate(new q(c),t.canonical),i["icon-size"].possiblyEvaluate(new q(p),t.canonical)]}let a=n.get("text-line-height")*ne,s=n.get("text-rotation-alignment")!=="viewport"&&n.get("symbol-placement")!=="point",l=n.get("text-keep-upright"),u=n.get("text-size");for(let c of t.bucket.features){let p=n.get("text-font").evaluate(c,{},t.canonical).join(","),f=u.evaluate(c,{},t.canonical),y=o.layoutTextSize.evaluate(c,{},t.canonical),m=o.layoutIconSize.evaluate(c,{},t.canonical),h={horizontal:{},vertical:void 0},d=c.text,g=[0,0];if(d){let P=d.toString(),w=n.get("text-letter-spacing").evaluate(c,{},t.canonical)*ne,T=Pc(P)?w:0,F=n.get("text-anchor").evaluate(c,{},t.canonical),E=sl(r,c,t.canonical);if(!E){let A=n.get("text-radial-offset").evaluate(c,{},t.canonical);A?g=al(F,[A*ne,xa]):g=n.get("text-offset").evaluate(c,{},t.canonical).map(z=>z*ne)}let _=s?"center":n.get("text-justify").evaluate(c,{},t.canonical),I=n.get("symbol-placement"),k=I==="point"?n.get("text-max-width").evaluate(c,{},t.canonical)*ne:0,V=()=>{t.bucket.allowVerticalPlacement&&hn(P)&&(h.vertical=ii(d,t.glyphMap,t.glyphPositions,t.imagePositions,p,k,a,F,"left",T,g,2,!0,I,y,f))};if(!s&&E){let A=new Set;if(_==="auto")for(let O=0;O<E.values.length;O+=2)A.add(Nf(E.values[O]));else A.add(_);let z=!1;for(let O of A)if(!h.horizontal[O])if(z)h.horizontal[O]=h.horizontal[0];else{let N=ii(d,t.glyphMap,t.glyphPositions,t.imagePositions,p,k,a,"center",O,T,g,1,!1,I,y,f);N&&(h.horizontal[O]=N,z=N.positionedLines.length===1)}V()}else{_==="auto"&&(_=Nf(F));let A=ii(d,t.glyphMap,t.glyphPositions,t.imagePositions,p,k,a,F,_,T,g,1,!1,I,y,f);A&&(h.horizontal[_]=A),V(),hn(P)&&s&&l&&(h.vertical=ii(d,t.glyphMap,t.glyphPositions,t.imagePositions,p,k,a,F,_,T,g,2,!1,I,y,f))}}let b,x=!1;if(c.icon&&c.icon.name){let P=t.imageMap[c.icon.name];P&&(b=yf(t.imagePositions[c.icon.name],n.get("icon-offset").evaluate(c,{},t.canonical),n.get("icon-anchor").evaluate(c,{},t.canonical)),x=!!P.sdf,t.bucket.sdfIcons===void 0?t.bucket.sdfIcons=x:t.bucket.sdfIcons!==x&&fe("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(P.pixelRatio!==t.bucket.pixelRatio||n.get("icon-rotate").constantOr(1)!==0)&&(t.bucket.iconsNeedLinear=!0))}let v=Gf(h.horizontal)||h.vertical;t.bucket.iconsInText=v?v.iconsInText:!1,(v||b)&&Db(t.bucket,c,h,b,t.imageMap,o,y,m,g,x,t.canonical)}t.showCollisionBoxes&&t.bucket.generateCollisionDebugBuffers()}function Nf(t){switch(t){case"right":case"top-right":case"bottom-right":return"right";case"left":case"top-left":case"bottom-left":return"left"}return"center"}function Db(t,e,r,n,i,o,a,s,l,u,c){let p=o.textMaxSize.evaluate(e,{});p===void 0&&(p=a);let f=t.layers[0].layout,y=f.get("icon-offset").evaluate(e,{},c),m=Gf(r.horizontal),h=24,d=a/h,g=t.tilePixelRatio*d,b=t.tilePixelRatio*p/h,x=t.tilePixelRatio*s,v=t.tilePixelRatio*f.get("symbol-spacing"),P=f.get("text-padding")*t.tilePixelRatio,w=bf(f,e,c,t.tilePixelRatio),T=f.get("text-max-angle")/180*Math.PI,F=f.get("text-rotation-alignment")!=="viewport"&&f.get("symbol-placement")!=="point",E=f.get("icon-rotation-alignment")==="map"&&f.get("symbol-placement")!=="point",_=f.get("symbol-placement"),I=v/2,k=f.get("icon-text-fit"),V;n&&k!=="none"&&(t.allowVerticalPlacement&&r.vertical&&(V=Qs(n,r.vertical,k,f.get("icon-text-fit-padding"),y,d)),m&&(n=Qs(n,m,k,f.get("icon-text-fit-padding"),y,d)));let A=(z,O)=>{O.x<0||O.x>=8192||O.y<0||O.y>=8192||Bb(t,O,z,r,n,i,V,t.layers[0],t.collisionBoxArray,e.index,e.sourceLayerIndex,t.index,g,[P,P,P,P],F,l,x,w,E,y,e,o,u,c,a)};if(_==="line")for(let z of Bf(e.geometry,0,0,8192,8192)){let O=Df(z,v,T,r.vertical||m,n,h,b,t.overscaling,8192);for(let N of O){let K=m;(!K||!zb(t,K.text,I,N))&&A(z,N)}}else if(_==="line-center"){for(let z of e.geometry)if(z.length>1){let O=Lf(z,T,r.vertical||m,n,h,b);O&&A(z,O)}}else if(e.type==="Polygon")for(let z of Tr(e.geometry,0)){let O=Of(z,16);A(z[0],new rt(O.x,O.y,0))}else if(e.type==="LineString")for(let z of e.geometry)A(z,new rt(z[0].x,z[0].y,0));else if(e.type==="Point")for(let z of e.geometry)for(let O of z)A([O],new rt(O.x,O.y,0))}function Vb(t,e){let r=t.length,n=e==null?void 0:e.values;if((n==null?void 0:n.length)>0)for(let i=0;i<n.length;i+=2){let o=ol[n[i]],a=n[i+1];t.emplaceBack(o,a[0],a[1])}return[r,t.length]}function Uf(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m){let h=Rf(e,r,s,i,o,a,n,t.allowVerticalPlacement),d=t.textSizeData,g=null;d.kind==="source"?(g=[Ct*i.layout.get("text-size").evaluate(a,{})],g[0]>tt&&fe("".concat(t.layerIds[0],': Value for "text-size" is >= ').concat(Vr,'. Reduce your "text-size".'))):d.kind==="composite"&&(g=[Ct*y.compositeTextSizes[0].evaluate(a,{},m),Ct*y.compositeTextSizes[1].evaluate(a,{},m)],(g[0]>tt||g[1]>tt)&&fe("".concat(t.layerIds[0],': Value for "text-size" is >= ').concat(Vr,'. Reduce your "text-size".'))),t.addSymbols(t.text,h,g,s,o,a,u,e,l.lineStartIndex,l.lineLength,f,m);for(let b of c)p[b]=t.text.placedSymbolArray.length-1;return h.length*4}function Gf(t){for(let e in t)return t[e];return null}function Bb(t,e,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,b,x,v,P,w,T,F){let E=t.addToLineVertexArray(e,r),_,I,k,V,A=0,z=0,O=0,N=0,K=-1,xe=-1,X={},le=(0,ll.default)("");if(t.allowVerticalPlacement&&n.vertical){let ve=s.layout.get("text-rotate").evaluate(v,{},T)+90,Ve=n.vertical;k=new or(l,e,u,c,p,Ve,f,y,m,ve),a&&(V=new or(l,e,u,c,p,a,d,g,m,ve))}if(i){let Ie=s.layout.get("icon-rotate").evaluate(v,{}),ve=s.layout.get("icon-text-fit")!=="none",Ve=nl(i,Ie,w,ve),$r=a?nl(a,Ie,w,ve):void 0;I=new or(l,e,u,c,p,i,d,g,!1,Ie),A=Ve.length*4;let Vl=t.iconSizeData,Lt=null;Vl.kind==="source"?(Lt=[Ct*s.layout.get("icon-size").evaluate(v,{})],Lt[0]>tt&&fe("".concat(t.layerIds[0],': Value for "icon-size" is >= ').concat(Vr,'. Reduce your "icon-size".'))):Vl.kind==="composite"&&(Lt=[Ct*P.compositeIconSizes[0].evaluate(v,{},T),Ct*P.compositeIconSizes[1].evaluate(v,{},T)],(Lt[0]>tt||Lt[1]>tt)&&fe("".concat(t.layerIds[0],': Value for "icon-size" is >= ').concat(Vr,'. Reduce your "icon-size".'))),t.addSymbols(t.icon,Ve,Lt,x,b,v,0,e,E.lineStartIndex,E.lineLength,-1,T),K=t.icon.placedSymbolArray.length-1,$r&&(z=$r.length*4,t.addSymbols(t.icon,$r,Lt,x,b,v,2,e,E.lineStartIndex,E.lineLength,-1,T),xe=t.icon.placedSymbolArray.length-1)}let ce=Object.keys(n.horizontal);for(let Ie of ce){let ve=n.horizontal[Ie];if(!_){le=(0,ll.default)(ve.text);let $r=s.layout.get("text-rotate").evaluate(v,{},T);_=new or(l,e,u,c,p,ve,f,y,m,$r)}let Ve=ve.positionedLines.length===1;if(O+=Uf(t,e,ve,o,s,m,v,h,E,n.vertical?1:3,Ve?ce:[Ie],X,K,P,T),Ve)break}n.vertical&&(N+=Uf(t,e,n.vertical,o,s,m,v,h,E,2,["vertical"],X,xe,P,T));let pe=_?_.boxStartIndex:t.collisionBoxArray.length,_e=_?_.boxEndIndex:t.collisionBoxArray.length,be=k?k.boxStartIndex:t.collisionBoxArray.length,Ai=k?k.boxEndIndex:t.collisionBoxArray.length,Da=I?I.boxStartIndex:t.collisionBoxArray.length,Va=I?I.boxEndIndex:t.collisionBoxArray.length,Ur=V?V.boxStartIndex:t.collisionBoxArray.length,_i=V?V.boxEndIndex:t.collisionBoxArray.length,Me=-1,Ft=(Ie,ve)=>Ie&&Ie.circleDiameter?Math.max(Ie.circleDiameter,ve):ve;Me=Ft(_,Me),Me=Ft(k,Me),Me=Ft(I,Me),Me=Ft(V,Me);let Ii=Me>-1?1:0;Ii&&(Me*=F/ne),t.glyphOffsetArray.length>=He.MAX_GLYPHS&&fe("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),v.sortKey!==void 0&&t.addToSortKeyRanges(t.symbolInstances.length,v.sortKey);let Ba=sl(s,v,T),[za,Ra]=Vb(t.textAnchorOffsets,Ba);t.symbolInstances.emplaceBack(e.x,e.y,X.right>=0?X.right:-1,X.center>=0?X.center:-1,X.left>=0?X.left:-1,X.vertical||-1,K,xe,le,pe,_e,be,Ai,Da,Va,Ur,_i,u,O,N,A,z,Ii,0,f,Me,za,Ra)}function zb(t,e,r,n){let i=t.compareText;if(!(e in i))i[e]=[];else{let o=i[e];for(let a=o.length-1;a>=0;a--)if(n.dist(o[a])<r)return!0}return i[e].push(n),!1}var ba=1,fi=class{constructor(e){let r={},n=[];for(let s in e){let l=e[s],u=r[s]={};for(let c in l){let p=l[+c];if(!p||p.bitmap.width===0||p.bitmap.height===0)continue;let f={x:0,y:0,w:p.bitmap.width+2*ba,h:p.bitmap.height+2*ba};n.push(f),u[c]={rect:f,metrics:p.metrics}}}let{w:i,h:o}=ti(n),a=new er({width:i||1,height:o||1});for(let s in e){let l=e[s];for(let u in l){let c=l[+u];if(!c||c.bitmap.width===0||c.bitmap.height===0)continue;let p=r[s][u].rect;er.copy(c.bitmap,a,{x:0,y:0},{x:p.x+ba,y:p.y+ba},c.bitmap)}}this.image=a,this.positions=r}};C("GlyphAtlas",fi);function jf(t,e,r){e=Math.pow(2,r)-e-1;var n=qf(t*256,e*256,r),i=qf((t+1)*256,(e+1)*256,r);return n[0]+","+n[1]+","+i[0]+","+i[1]}function qf(t,e,r){var n=2*Math.PI*6378137/256/Math.pow(2,r),i=t*n-2*Math.PI*6378137/2,o=e*n-2*Math.PI*6378137/2;return[i,o]}var Wf=Z(he(),1);var ul=63710088e-1,yi=class t{constructor(e,r){if(isNaN(e)||isNaN(r))throw new Error("Invalid LngLat object: (".concat(e,", ").concat(r,")"));if(this.lng=+e,this.lat=+r,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")}wrap(){return new t(Hl(this.lng,-180,180),this.lat)}toArray(){return[this.lng,this.lat]}toString(){return"LngLat(".concat(this.lng,", ").concat(this.lat,")")}distanceTo(e){let r=Math.PI/180,n=this.lat*r,i=e.lat*r,o=Math.sin(n)*Math.sin(i)+Math.cos(n)*Math.cos(i)*Math.cos((e.lng-this.lng)*r);return ul*Math.acos(Math.min(o,1))}static convert(e){if(e instanceof t)return e;if(Array.isArray(e)&&(e.length===2||e.length===3))return new t(Number(e[0]),Number(e[1]));if(!Array.isArray(e)&&typeof e=="object"&&e!==null)return new t(Number("lng"in e?e.lng:e.lon),Number(e.lat));throw new Error("\`LngLatLike\` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")}};var Jf=2*Math.PI*ul;function Zf(t){return Jf*Math.cos(t*Math.PI/180)}function Rb(t){return(180+t)/360}function Ob(t){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function Nb(t,e){return t/Zf(e)}function Ub(t){return t*360-180}function cl(t){let e=180-t*360;return 360/Math.PI*Math.atan(Math.exp(e*Math.PI/180))-90}function $b(t,e){return t*Zf(cl(e))}function Gb(t){return 1/Math.cos(t*Math.PI/180)}var va=class t{constructor(e,r,n=0){this.x=+e,this.y=+r,this.z=+n}static fromLngLat(e,r=0){let n=yi.convert(e);return new t(Rb(n.lng),Ob(n.lat),Nb(r,n.lat))}toLngLat(){return new yi(Ub(this.x),cl(this.y))}toAltitude(){return $b(this.z,this.y)}meterInMercatorCoordinateUnits(){return 1/Jf*Gb(cl(this.y))}};var Pa=class{constructor(e,r,n){if(e<0||e>25||n<0||n>=Math.pow(2,e)||r<0||r>=Math.pow(2,e))throw new Error("x=".concat(r,", y=").concat(n,", z=").concat(e," outside of bounds. 0<=x<").concat(Math.pow(2,e),", 0<=y<").concat(Math.pow(2,e)," 0<=z<=25 "));this.z=e,this.x=r,this.y=n,this.key=mi(0,e,e,r,n)}equals(e){return this.z===e.z&&this.x===e.x&&this.y===e.y}url(e,r,n){let i=jf(this.x,this.y,this.z),o=qb(this.z,this.x,this.y);return e[(this.x+this.y)%e.length].replace(/{prefix}/g,(this.x%16).toString(16)+(this.y%16).toString(16)).replace(/{z}/g,String(this.z)).replace(/{x}/g,String(this.x)).replace(/{y}/g,String(n==="tms"?Math.pow(2,this.z)-this.y-1:this.y)).replace(/{ratio}/g,r>1?"@2x":"").replace(/{quadkey}/g,o).replace(/{bbox-epsg-3857}/g,i)}isChildOf(e){let r=this.z-e.z;return r>0&&e.x===this.x>>r&&e.y===this.y>>r}getTilePoint(e){let r=Math.pow(2,this.z);return new Wf.default((e.x*r-this.x)*8192,(e.y*r-this.y)*8192)}toString(){return"".concat(this.z,"/").concat(this.x,"/").concat(this.y)}},pl=class{constructor(e,r){this.wrap=e,this.canonical=r,this.key=mi(e,r.z,r.z,r.x,r.y)}},hi=class t{constructor(e,r,n,i,o){if(e<n)throw new Error("overscaledZ should be >= z; overscaledZ = ".concat(e,"; z = ").concat(n));this.overscaledZ=e,this.wrap=r,this.canonical=new Pa(n,+i,+o),this.key=mi(r,e,n,i,o)}clone(){return new t(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)}equals(e){return this.overscaledZ===e.overscaledZ&&this.wrap===e.wrap&&this.canonical.equals(e.canonical)}scaledTo(e){if(e>this.overscaledZ)throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(e,"; overscaledZ = ").concat(this.overscaledZ));let r=this.canonical.z-e;return e>this.canonical.z?new t(e,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new t(e,this.wrap,e,this.canonical.x>>r,this.canonical.y>>r)}calculateScaledKey(e,r){if(e>this.overscaledZ)throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(e,"; overscaledZ = ").concat(this.overscaledZ));let n=this.canonical.z-e;return e>this.canonical.z?mi(this.wrap*+r,e,this.canonical.z,this.canonical.x,this.canonical.y):mi(this.wrap*+r,e,e,this.canonical.x>>n,this.canonical.y>>n)}isChildOf(e){if(e.wrap!==this.wrap)return!1;let r=this.canonical.z-e.canonical.z;return e.overscaledZ===0||e.overscaledZ<this.overscaledZ&&e.canonical.x===this.canonical.x>>r&&e.canonical.y===this.canonical.y>>r}children(e){if(this.overscaledZ>=e)return[new t(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];let r=this.canonical.z+1,n=this.canonical.x*2,i=this.canonical.y*2;return[new t(r,this.wrap,r,n,i),new t(r,this.wrap,r,n+1,i),new t(r,this.wrap,r,n,i+1),new t(r,this.wrap,r,n+1,i+1)]}isLessThan(e){return this.wrap<e.wrap?!0:this.wrap>e.wrap?!1:this.overscaledZ<e.overscaledZ?!0:this.overscaledZ>e.overscaledZ?!1:this.canonical.x<e.canonical.x?!0:this.canonical.x>e.canonical.x?!1:this.canonical.y<e.canonical.y}wrapped(){return new t(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)}unwrapTo(e){return new t(this.overscaledZ,e,this.canonical.z,this.canonical.x,this.canonical.y)}overscaleFactor(){return Math.pow(2,this.overscaledZ-this.canonical.z)}toUnwrapped(){return new pl(this.wrap,this.canonical)}toString(){return"".concat(this.overscaledZ,"/").concat(this.canonical.x,"/").concat(this.canonical.y)}getTilePoint(e){return this.canonical.getTilePoint(new va(e.x-this.wrap,e.y))}};function mi(t,e,r,n,i){t*=2,t<0&&(t=t*-1-1);let o=1<<r;return(o*o*t+o*i+n).toString(36)+r.toString(36)+e.toString(36)}function qb(t,e,r){let n="",i;for(let o=t;o>0;o--)i=1<<o-1,n+=(e&i?1:0)+(r&i?2:0);return n}C("CanonicalTileID",Pa);C("OverscaledTileID",hi,{omit:["posMatrix"]});var Sa=class{constructor(e){this.tileID=new hi(e.tileID.overscaledZ,e.tileID.wrap,e.tileID.canonical.z,e.tileID.canonical.x,e.tileID.canonical.y),this.uid=e.uid,this.zoom=e.zoom,this.pixelRatio=e.pixelRatio,this.tileSize=e.tileSize,this.source=e.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=e.showCollisionBoxes,this.collectResourceTiming=!!e.collectResourceTiming,this.returnDependencies=!!e.returnDependencies,this.promoteId=e.promoteId,this.inFlightDependencies=[]}async parse(e,r,n,i){this.status="parsing",this.data=e,this.collisionBoxArray=new Ln;let o=new Br(Object.keys(e.layers).sort()),a=new ui(this.tileID,this.promoteId);a.bucketLayerIDs=[];let s={},l={featureIndex:a,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:n},u=r.familiesBySource[this.source];for(let P in u){let w=e.layers[P];if(!w)continue;w.version===1&&fe('Vector tile source "'.concat(this.source,'" layer "').concat(P,'" ')+"does not use vector tile spec v2 and therefore may have some rendering errors.");let T=o.encode(P),F=[];for(let E=0;E<w.length;E++){let _=w.feature(E),I=a.getId(_,P);F.push({feature:_,id:I,index:E,sourceLayerIndex:T})}for(let E of u[P]){let _=E[0];if(_.source!==this.source&&fe("layer.source = ".concat(_.source," does not equal this.source = ").concat(this.source)),_.minzoom&&this.zoom<Math.floor(_.minzoom)||_.maxzoom&&this.zoom>=_.maxzoom||_.visibility==="none")continue;fl(E,this.zoom,n),(s[_.id]=_.createBucket({index:a.bucketLayerIDs.length,layers:E,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:T,sourceID:this.source})).populate(F,l,this.tileID.canonical),a.bucketLayerIDs.push(E.map(k=>k.id))}}let c=jr(l.glyphDependencies,P=>Object.keys(P).map(Number));this.inFlightDependencies.forEach(P=>P==null?void 0:P.abort()),this.inFlightDependencies=[];let p=Promise.resolve({});if(Object.keys(c).length){let P=new AbortController;this.inFlightDependencies.push(P),p=i.sendAsync({type:"GG",data:{stacks:c,source:this.source,tileID:this.tileID,type:"glyphs"}},P)}let f=Object.keys(l.iconDependencies),y=Promise.resolve({});if(f.length){let P=new AbortController;this.inFlightDependencies.push(P),y=i.sendAsync({type:"GI",data:{icons:f,source:this.source,tileID:this.tileID,type:"icons"}},P)}let m=Object.keys(l.patternDependencies),h=Promise.resolve({});if(m.length){let P=new AbortController;this.inFlightDependencies.push(P),h=i.sendAsync({type:"GI",data:{icons:m,source:this.source,tileID:this.tileID,type:"patterns"}},P)}let[d,g,b]=await Promise.all([p,y,h]),x=new fi(d),v=new ri(g,b);for(let P in s){let w=s[P];w instanceof He?(fl(w.layers,this.zoom,n),$f({bucket:w,glyphMap:d,glyphPositions:x.positions,imageMap:g,imagePositions:v.iconPositions,showCollisionBoxes:this.showCollisionBoxes,canonical:this.tileID.canonical})):w.hasPattern&&(w instanceof ir||w instanceof rr||w instanceof nr)&&(fl(w.layers,this.zoom,n),w.addFeatures(l,this.tileID.canonical,v.patternPositions))}return this.status="done",{buckets:Object.values(s).filter(P=>!P.isEmpty()),featureIndex:a,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:x.image,imageAtlas:v,glyphMap:this.returnDependencies?d:null,iconMap:this.returnDependencies?g:null,glyphPositions:this.returnDependencies?x.positions:null}}};function fl(t,e,r){let n=new q(e);for(let i of t)i.recalculate(n,r)}var jb=60,HI=1e3/jb;var Or=class{constructor(e){this._marks={start:[e.url,"start"].join("#"),end:[e.url,"end"].join("#"),measure:e.url.toString()},performance.mark(this._marks.start)}finish(){performance.mark(this._marks.end);let e=performance.getEntriesByName(this._marks.measure);return e.length===0&&(performance.measure(this._marks.measure,this._marks.start,this._marks.end),e=performance.getEntriesByName(this._marks.measure),performance.clearMarks(this._marks.start),performance.clearMarks(this._marks.end),performance.clearMeasures(this._marks.measure)),e}};var Nr=class{constructor(e,r,n){this.actor=e,this.layerIndex=r,this.availableImages=n,this.fetching={},this.loading={},this.loaded={}}async loadVectorTile(e,r){let n=await hc(e.request,r);try{return{vectorTile:new Hf.default.VectorTile(new Xf.default(n.data)),rawData:n.data,cacheControl:n.cacheControl,expires:n.expires}}catch(i){let o=new Uint8Array(n.data),a=o[0]===31&&o[1]===139,s="Unable to parse the tile at ".concat(e.request.url,", ");throw a?s+="please make sure the data is not gzipped and that you have configured the relevant header in the server":s+="got error: ".concat(i.messge),new Error(s)}}async loadTile(e){let r=e.uid,n=e&&e.request&&e.request.collectResourceTiming?new Or(e.request):!1,i=new Sa(e);this.loading[r]=i;let o=new AbortController;i.abort=o;try{let a=await this.loadVectorTile(e,o);if(delete this.loading[r],!a)return null;let s=a.rawData,l={};a.expires&&(l.expires=a.expires),a.cacheControl&&(l.cacheControl=a.cacheControl);let u={};if(n){let p=n.finish();p&&(u.resourceTiming=JSON.parse(JSON.stringify(p)))}i.vectorTile=a.vectorTile;let c=i.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor);this.loaded[r]=i,this.fetching[r]={rawTileData:s,cacheControl:l,resourceTiming:u};try{let p=await c;return Pe({rawTileData:s.slice(0)},p,l,u)}finally{delete this.fetching[r]}}catch(a){throw delete this.loading[r],i.status="done",this.loaded[r]=i,a}}async reloadTile(e){let r=e.uid;if(!this.loaded||!this.loaded[r])throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");let n=this.loaded[r];if(n.showCollisionBoxes=e.showCollisionBoxes,n.status==="parsing"){let i=await n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor),o;if(this.fetching[r]){let{rawTileData:a,cacheControl:s,resourceTiming:l}=this.fetching[r];delete this.fetching[r],o=Pe({rawTileData:a.slice(0)},i,s,l)}else o=i;return o}if(n.status==="done"&&n.vectorTile)return n.parse(n.vectorTile,this.layerIndex,this.availableImages,this.actor)}async abortTile(e){let r=this.loading,n=e.uid;r&&r[n]&&r[n].abort&&(r[n].abort.abort(),delete r[n])}async removeTile(e){this.loaded&&this.loaded[e.uid]&&delete this.loaded[e.uid]}};var di=class{constructor(e,r,n,i=1,o=1,a=1,s=0){if(this.uid=e,r.height!==r.width)throw new RangeError("DEM tiles must be square");if(n&&!["mapbox","terrarium","custom"].includes(n)){fe('"'.concat(n,'" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".'));return}this.stride=r.height;let l=this.dim=r.height-2;switch(this.data=new Uint32Array(r.data.buffer),n){case"terrarium":this.redFactor=256,this.greenFactor=1,this.blueFactor=1/256,this.baseShift=32768;break;case"custom":this.redFactor=i,this.greenFactor=o,this.blueFactor=a,this.baseShift=s;break;case"mapbox":default:this.redFactor=6553.6,this.greenFactor=25.6,this.blueFactor=.1,this.baseShift=1e4;break}for(let u=0;u<l;u++)this.data[this._idx(-1,u)]=this.data[this._idx(0,u)],this.data[this._idx(l,u)]=this.data[this._idx(l-1,u)],this.data[this._idx(u,-1)]=this.data[this._idx(u,0)],this.data[this._idx(u,l)]=this.data[this._idx(u,l-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(l,-1)]=this.data[this._idx(l-1,0)],this.data[this._idx(-1,l)]=this.data[this._idx(0,l-1)],this.data[this._idx(l,l)]=this.data[this._idx(l-1,l-1)],this.min=Number.MAX_SAFE_INTEGER,this.max=Number.MIN_SAFE_INTEGER;for(let u=0;u<l;u++)for(let c=0;c<l;c++){let p=this.get(u,c);p>this.max&&(this.max=p),p<this.min&&(this.min=p)}}get(e,r){let n=new Uint8Array(this.data.buffer),i=this._idx(e,r)*4;return this.unpack(n[i],n[i+1],n[i+2])}getUnpackVector(){return[this.redFactor,this.greenFactor,this.blueFactor,this.baseShift]}_idx(e,r){if(e<-1||e>=this.dim+1||r<-1||r>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return(r+1)*this.stride+(e+1)}unpack(e,r,n){return e*this.redFactor+r*this.greenFactor+n*this.blueFactor-this.baseShift}getPixels(){return new de({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))}backfillBorder(e,r,n){if(this.dim!==e.dim)throw new Error("dem dimension mismatch");let i=r*this.dim,o=r*this.dim+this.dim,a=n*this.dim,s=n*this.dim+this.dim;switch(r){case-1:i=o-1;break;case 1:o=i+1;break}switch(n){case-1:a=s-1;break;case 1:s=a+1;break}let l=-r*this.dim,u=-n*this.dim;for(let c=a;c<s;c++)for(let p=i;p<o;p++)this.data[this._idx(p,c)]=e.data[this._idx(p+l,c+u)]}};C("DEMData",di);var wa=class{constructor(){this.loaded={}}async loadTile(e){let{uid:r,encoding:n,rawImageData:i,redFactor:o,greenFactor:a,blueFactor:s,baseShift:l}=e,u=i.width+2,c=i.height+2,p=Jr(i)?new de({width:u,height:c},await eu(i,-1,-1,u,c)):i,f=new di(r,p,n,o,a,s,l);return this.loaded=this.loaded||{},this.loaded[r]=f,f}removeTile(e){let r=this.loaded,n=e.uid;r&&r[n]&&delete r[n]}};var wy=Z(ey(),1);var yl=Z(he(),1),ty=Z(Tt(),1);var Jb=ty.default.VectorTileFeature.prototype.toGeoJSON,ml=class{constructor(e){this._feature=e,this.extent=8192,this.type=e.type,this.properties=e.tags,"id"in e&&!isNaN(e.id)&&(this.id=parseInt(e.id,10))}loadGeometry(){if(this._feature.type===1){let e=[];for(let r of this._feature.geometry)e.push([new yl.default(r[0],r[1])]);return e}else{let e=[];for(let r of this._feature.geometry){let n=[];for(let i of r)n.push(new yl.default(i[0],i[1]));e.push(n)}return e}}toGeoJSON(e,r,n){return Jb.call(this,e,r,n)}},_a=class{constructor(e){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=8192,this.length=e.length,this._features=e}feature(e){return new ml(this._features[e])}};var Ay=Z(sy(),1);var ly=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],gl=1,xi=8,vi=class t{static from(e){if(!(e instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");let[r,n]=new Uint8Array(e,0,2);if(r!==219)throw new Error("Data does not appear to be in a KDBush format.");let i=n>>4;if(i!==gl)throw new Error("Got v".concat(i," data when expected v").concat(gl,"."));let o=ly[n&15];if(!o)throw new Error("Unrecognized array type.");let[a]=new Uint16Array(e,2,1),[s]=new Uint32Array(e,4,1);return new t(s,a,o,e)}constructor(e,r=64,n=Float64Array,i){if(isNaN(e)||e<0)throw new Error("Unpexpected numItems value: ".concat(e,"."));this.numItems=+e,this.nodeSize=Math.min(Math.max(+r,2),65535),this.ArrayType=n,this.IndexArrayType=e<65536?Uint16Array:Uint32Array;let o=ly.indexOf(this.ArrayType),a=e*2*this.ArrayType.BYTES_PER_ELEMENT,s=e*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-s%8)%8;if(o<0)throw new Error("Unexpected typed array class: ".concat(n,"."));i&&i instanceof ArrayBuffer?(this.data=i,this.ids=new this.IndexArrayType(this.data,xi,e),this.coords=new this.ArrayType(this.data,xi+s+l,e*2),this._pos=e*2,this._finished=!0):(this.data=new ArrayBuffer(xi+a+s+l),this.ids=new this.IndexArrayType(this.data,xi,e),this.coords=new this.ArrayType(this.data,xi+s+l,e*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,(gl<<4)+o]),new Uint16Array(this.data,2,1)[0]=r,new Uint32Array(this.data,4,1)[0]=e)}add(e,r){let n=this._pos>>1;return this.ids[n]=n,this.coords[this._pos++]=e,this.coords[this._pos++]=r,n}finish(){let e=this._pos>>1;if(e!==this.numItems)throw new Error("Added ".concat(e," items when expected ").concat(this.numItems,"."));return bl(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(e,r,n,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:o,coords:a,nodeSize:s}=this,l=[0,o.length-1,0],u=[];for(;l.length;){let c=l.pop()||0,p=l.pop()||0,f=l.pop()||0;if(p-f<=s){for(let d=f;d<=p;d++){let g=a[2*d],b=a[2*d+1];g>=e&&g<=n&&b>=r&&b<=i&&u.push(o[d])}continue}let y=f+p>>1,m=a[2*y],h=a[2*y+1];m>=e&&m<=n&&h>=r&&h<=i&&u.push(o[y]),(c===0?e<=m:r<=h)&&(l.push(f),l.push(y-1),l.push(1-c)),(c===0?n>=m:i>=h)&&(l.push(y+1),l.push(p),l.push(1-c))}return u}within(e,r,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:i,coords:o,nodeSize:a}=this,s=[0,i.length-1,0],l=[],u=n*n;for(;s.length;){let c=s.pop()||0,p=s.pop()||0,f=s.pop()||0;if(p-f<=a){for(let d=f;d<=p;d++)uy(o[2*d],o[2*d+1],e,r)<=u&&l.push(i[d]);continue}let y=f+p>>1,m=o[2*y],h=o[2*y+1];uy(m,h,e,r)<=u&&l.push(i[y]),(c===0?e-n<=m:r-n<=h)&&(s.push(f),s.push(y-1),s.push(1-c)),(c===0?e+n>=m:r+n>=h)&&(s.push(y+1),s.push(p),s.push(1-c))}return l}};function bl(t,e,r,n,i,o){if(i-n<=r)return;let a=n+i>>1;cy(t,e,a,n,i,o),bl(t,e,r,n,a-1,1-o),bl(t,e,r,a+1,i,1-o)}function cy(t,e,r,n,i,o){for(;i>n;){if(i-n>600){let u=i-n+1,c=r-n+1,p=Math.log(u),f=.5*Math.exp(2*p/3),y=.5*Math.sqrt(p*f*(u-f)/u)*(c-u/2<0?-1:1),m=Math.max(n,Math.floor(r-c*f/u+y)),h=Math.min(i,Math.floor(r+(u-c)*f/u+y));cy(t,e,r,m,h,o)}let a=e[2*r+o],s=n,l=i;for(bi(t,e,n,r),e[2*i+o]>a&&bi(t,e,n,i);s<l;){for(bi(t,e,s,l),s++,l--;e[2*s+o]<a;)s++;for(;e[2*l+o]>a;)l--}e[2*n+o]===a?bi(t,e,n,l):(l++,bi(t,e,l,i)),l<=r&&(n=l+1),r<=l&&(i=l-1)}}function bi(t,e,r,n){xl(t,r,n),xl(e,2*r,2*n),xl(e,2*r+1,2*n+1)}function xl(t,e,r){let n=t[e];t[e]=t[r],t[r]=n}function uy(t,e,r,n){let i=t-r,o=e-n;return i*i+o*o}var n0={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},py=Math.fround||(t=>e=>(t[0]=+e,t[0]))(new Float32Array(1)),ar=2,Et=3,vl=4,Mt=5,yy=6,Pi=class{constructor(e){this.options=Object.assign(Object.create(n0),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(e){let{log:r,minZoom:n,maxZoom:i}=this.options;r&&console.time("total time");let o="prepare ".concat(e.length," points");r&&console.time(o),this.points=e;let a=[];for(let l=0;l<e.length;l++){let u=e[l];if(!u.geometry)continue;let[c,p]=u.geometry.coordinates,f=py(Ta(c)),y=py(Ca(p));a.push(f,y,1/0,l,-1,1),this.options.reduce&&a.push(0)}let s=this.trees[i+1]=this._createTree(a);r&&console.timeEnd(o);for(let l=i;l>=n;l--){let u=+Date.now();s=this.trees[l]=this._createTree(this._cluster(s,l)),r&&console.log("z%d: %d clusters in %dms",l,s.numItems,+Date.now()-u)}return r&&console.timeEnd("total time"),this}getClusters(e,r){let n=((e[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,e[1])),o=e[2]===180?180:((e[2]+180)%360+360)%360-180,a=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)n=-180,o=180;else if(n>o){let p=this.getClusters([n,i,180,a],r),f=this.getClusters([-180,i,o,a],r);return p.concat(f)}let s=this.trees[this._limitZoom(r)],l=s.range(Ta(n),Ca(a),Ta(o),Ca(i)),u=s.data,c=[];for(let p of l){let f=this.stride*p;c.push(u[f+Mt]>1?fy(u,f,this.clusterProps):this.points[u[f+Et]])}return c}getChildren(e){let r=this._getOriginId(e),n=this._getOriginZoom(e),i="No cluster with the specified id.",o=this.trees[n];if(!o)throw new Error(i);let a=o.data;if(r*this.stride>=a.length)throw new Error(i);let s=this.options.radius/(this.options.extent*Math.pow(2,n-1)),l=a[r*this.stride],u=a[r*this.stride+1],c=o.within(l,u,s),p=[];for(let f of c){let y=f*this.stride;a[y+vl]===e&&p.push(a[y+Mt]>1?fy(a,y,this.clusterProps):this.points[a[y+Et]])}if(p.length===0)throw new Error(i);return p}getLeaves(e,r,n){r=r||10,n=n||0;let i=[];return this._appendLeaves(i,e,r,n,0),i}getTile(e,r,n){let i=this.trees[this._limitZoom(e)],o=Math.pow(2,e),{extent:a,radius:s}=this.options,l=s/a,u=(n-l)/o,c=(n+1+l)/o,p={features:[]};return this._addTileFeatures(i.range((r-l)/o,u,(r+1+l)/o,c),i.data,r,n,o,p),r===0&&this._addTileFeatures(i.range(1-l/o,u,1,c),i.data,o,n,o,p),r===o-1&&this._addTileFeatures(i.range(0,u,l/o,c),i.data,-1,n,o,p),p.features.length?p:null}getClusterExpansionZoom(e){let r=this._getOriginZoom(e)-1;for(;r<=this.options.maxZoom;){let n=this.getChildren(e);if(r++,n.length!==1)break;e=n[0].properties.cluster_id}return r}_appendLeaves(e,r,n,i,o){let a=this.getChildren(r);for(let s of a){let l=s.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(e,l.cluster_id,n,i,o):o<i?o++:e.push(s),e.length===n)break}return o}_createTree(e){let r=new vi(e.length/this.stride|0,this.options.nodeSize,Float32Array);for(let n=0;n<e.length;n+=this.stride)r.add(e[n],e[n+1]);return r.finish(),r.data=e,r}_addTileFeatures(e,r,n,i,o,a){for(let s of e){let l=s*this.stride,u=r[l+Mt]>1,c,p,f;if(u)c=my(r,l,this.clusterProps),p=r[l],f=r[l+1];else{let h=this.points[r[l+Et]];c=h.properties;let[d,g]=h.geometry.coordinates;p=Ta(d),f=Ca(g)}let y={type:1,geometry:[[Math.round(this.options.extent*(p*o-n)),Math.round(this.options.extent*(f*o-i))]],tags:c},m;u||this.options.generateId?m=r[l+Et]:m=this.points[r[l+Et]].id,m!==void 0&&(y.id=m),a.features.push(y)}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,r){let{radius:n,extent:i,reduce:o,minPoints:a}=this.options,s=n/(i*Math.pow(2,r)),l=e.data,u=[],c=this.stride;for(let p=0;p<l.length;p+=c){if(l[p+ar]<=r)continue;l[p+ar]=r;let f=l[p],y=l[p+1],m=e.within(l[p],l[p+1],s),h=l[p+Mt],d=h;for(let g of m){let b=g*c;l[b+ar]>r&&(d+=l[b+Mt])}if(d>h&&d>=a){let g=f*h,b=y*h,x,v=-1,P=((p/c|0)<<5)+(r+1)+this.points.length;for(let w of m){let T=w*c;if(l[T+ar]<=r)continue;l[T+ar]=r;let F=l[T+Mt];g+=l[T]*F,b+=l[T+1]*F,l[T+vl]=P,o&&(x||(x=this._map(l,p,!0),v=this.clusterProps.length,this.clusterProps.push(x)),o(x,this._map(l,T)))}l[p+vl]=P,u.push(g/d,b/d,1/0,P,-1,d),o&&u.push(v)}else{for(let g=0;g<c;g++)u.push(l[p+g]);if(d>1)for(let g of m){let b=g*c;if(!(l[b+ar]<=r)){l[b+ar]=r;for(let x=0;x<c;x++)u.push(l[b+x])}}}}return u}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return(e-this.points.length)%32}_map(e,r,n){if(e[r+Mt]>1){let a=this.clusterProps[e[r+yy]];return n?Object.assign({},a):a}let i=this.points[e[r+Et]].properties,o=this.options.map(i);return n&&o===i?Object.assign({},o):o}};function fy(t,e,r){return{type:"Feature",id:t[e+Et],properties:my(t,e,r),geometry:{type:"Point",coordinates:[i0(t[e]),o0(t[e+1])]}}}function my(t,e,r){let n=t[e+Mt],i=n>=1e4?"".concat(Math.round(n/1e3),"k"):n>=1e3?"".concat(Math.round(n/100)/10,"k"):n,o=t[e+yy],a=o===-1?{}:Object.assign({},r[o]);return Object.assign(a,{cluster:!0,cluster_id:t[e+Et],point_count:n,point_count_abbreviated:i})}function Ta(t){return t/360+.5}function Ca(t){let e=Math.sin(t*Math.PI/180),r=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return r<0?0:r>1?1:r}function i0(t){return(t-.5)*360}function o0(t){let e=(180-t*360)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}function Si(t,e,r,n){for(var i=n,o=r-e>>1,a=r-e,s,l=t[e],u=t[e+1],c=t[r],p=t[r+1],f=e+3;f<r;f+=3){var y=a0(t[f],t[f+1],l,u,c,p);if(y>i)s=f,i=y;else if(y===i){var m=Math.abs(f-o);m<a&&(s=f,a=m)}}i>n&&(s-e>3&&Si(t,e,s,n),t[s+2]=i,r-s>3&&Si(t,s,r,n))}function a0(t,e,r,n,i,o){var a=i-r,s=o-n;if(a!==0||s!==0){var l=((t-r)*a+(e-n)*s)/(a*a+s*s);l>1?(r=i,n=o):l>0&&(r+=a*l,n+=s*l)}return a=t-r,s=e-n,a*a+s*s}function ft(t,e,r,n){var i={id:typeof t>"u"?null:t,type:e,geometry:r,tags:n,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return s0(i),i}function s0(t){var e=t.geometry,r=t.type;if(r==="Point"||r==="MultiPoint"||r==="LineString")Pl(t,e);else if(r==="Polygon"||r==="MultiLineString")for(var n=0;n<e.length;n++)Pl(t,e[n]);else if(r==="MultiPolygon")for(n=0;n<e.length;n++)for(var i=0;i<e[n].length;i++)Pl(t,e[n][i])}function Pl(t,e){for(var r=0;r<e.length;r+=3)t.minX=Math.min(t.minX,e[r]),t.minY=Math.min(t.minY,e[r+1]),t.maxX=Math.max(t.maxX,e[r]),t.maxY=Math.max(t.maxY,e[r+1])}function Al(t,e){var r=[];if(t.type==="FeatureCollection")for(var n=0;n<t.features.length;n++)ka(r,t.features[n],e,n);else t.type==="Feature"?ka(r,t,e):ka(r,{geometry:t},e);return r}function ka(t,e,r,n){if(e.geometry){var i=e.geometry.coordinates,o=e.geometry.type,a=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),s=[],l=e.id;if(r.promoteId?l=e.properties[r.promoteId]:r.generateId&&(l=n||0),o==="Point")hy(i,s);else if(o==="MultiPoint")for(var u=0;u<i.length;u++)hy(i[u],s);else if(o==="LineString")wl(i,s,a,!1);else if(o==="MultiLineString")if(r.lineMetrics){for(u=0;u<i.length;u++)s=[],wl(i[u],s,a,!1),t.push(ft(l,"LineString",s,e.properties));return}else Sl(i,s,a,!1);else if(o==="Polygon")Sl(i,s,a,!0);else if(o==="MultiPolygon")for(u=0;u<i.length;u++){var c=[];Sl(i[u],c,a,!0),s.push(c)}else if(o==="GeometryCollection"){for(u=0;u<e.geometry.geometries.length;u++)ka(t,{id:l,geometry:e.geometry.geometries[u],properties:e.properties},r,n);return}else throw new Error("Input data is not a valid GeoJSON object.");t.push(ft(l,o,s,e.properties))}}function hy(t,e){e.push(dy(t[0])),e.push(gy(t[1])),e.push(0)}function wl(t,e,r,n){for(var i,o,a=0,s=0;s<t.length;s++){var l=dy(t[s][0]),u=gy(t[s][1]);e.push(l),e.push(u),e.push(0),s>0&&(n?a+=(i*u-l*o)/2:a+=Math.sqrt(Math.pow(l-i,2)+Math.pow(u-o,2))),i=l,o=u}var c=e.length-3;e[2]=1,Si(e,0,c,r),e[c+2]=1,e.size=Math.abs(a),e.start=0,e.end=e.size}function Sl(t,e,r,n){for(var i=0;i<t.length;i++){var o=[];wl(t[i],o,r,n),e.push(o)}}function dy(t){return t/360+.5}function gy(t){var e=Math.sin(t*Math.PI/180),r=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return r<0?0:r>1?1:r}function qe(t,e,r,n,i,o,a,s){if(r/=e,n/=e,o>=r&&a<n)return t;if(a<r||o>=n)return null;for(var l=[],u=0;u<t.length;u++){var c=t[u],p=c.geometry,f=c.type,y=i===0?c.minX:c.minY,m=i===0?c.maxX:c.maxY;if(y>=r&&m<n){l.push(c);continue}else if(m<r||y>=n)continue;var h=[];if(f==="Point"||f==="MultiPoint")l0(p,h,r,n,i);else if(f==="LineString")by(p,h,r,n,i,!1,s.lineMetrics);else if(f==="MultiLineString")_l(p,h,r,n,i,!1);else if(f==="Polygon")_l(p,h,r,n,i,!0);else if(f==="MultiPolygon")for(var d=0;d<p.length;d++){var g=[];_l(p[d],g,r,n,i,!0),g.length&&h.push(g)}if(h.length){if(s.lineMetrics&&f==="LineString"){for(d=0;d<h.length;d++)l.push(ft(c.id,f,h[d],c.tags));continue}(f==="LineString"||f==="MultiLineString")&&(h.length===1?(f="LineString",h=h[0]):f="MultiLineString"),(f==="Point"||f==="MultiPoint")&&(f=h.length===3?"Point":"MultiPoint"),l.push(ft(c.id,f,h,c.tags))}}return l.length?l:null}function l0(t,e,r,n,i){for(var o=0;o<t.length;o+=3){var a=t[o+i];a>=r&&a<=n&&(e.push(t[o]),e.push(t[o+1]),e.push(t[o+2]))}}function by(t,e,r,n,i,o,a){for(var s=xy(t),l=i===0?u0:c0,u=t.start,c,p,f=0;f<t.length-3;f+=3){var y=t[f],m=t[f+1],h=t[f+2],d=t[f+3],g=t[f+4],b=i===0?y:m,x=i===0?d:g,v=!1;a&&(c=Math.sqrt(Math.pow(y-d,2)+Math.pow(m-g,2))),b<r?x>r&&(p=l(s,y,m,d,g,r),a&&(s.start=u+c*p)):b>n?x<n&&(p=l(s,y,m,d,g,n),a&&(s.start=u+c*p)):Il(s,y,m,h),x<r&&b>=r&&(p=l(s,y,m,d,g,r),v=!0),x>n&&b<=n&&(p=l(s,y,m,d,g,n),v=!0),!o&&v&&(a&&(s.end=u+c*p),e.push(s),s=xy(t)),a&&(u+=c)}var P=t.length-3;y=t[P],m=t[P+1],h=t[P+2],b=i===0?y:m,b>=r&&b<=n&&Il(s,y,m,h),P=s.length-3,o&&P>=3&&(s[P]!==s[0]||s[P+1]!==s[1])&&Il(s,s[0],s[1],s[2]),s.length&&e.push(s)}function xy(t){var e=[];return e.size=t.size,e.start=t.start,e.end=t.end,e}function _l(t,e,r,n,i,o){for(var a=0;a<t.length;a++)by(t[a],e,r,n,i,o,!1)}function Il(t,e,r,n){t.push(e),t.push(r),t.push(n)}function u0(t,e,r,n,i,o){var a=(o-e)/(n-e);return t.push(o),t.push(r+(i-r)*a),t.push(1),a}function c0(t,e,r,n,i,o){var a=(o-r)/(i-r);return t.push(e+(n-e)*a),t.push(o),t.push(1),a}function Cl(t,e){var r=e.buffer/e.extent,n=t,i=qe(t,1,-1-r,r,0,-1,2,e),o=qe(t,1,1-r,2+r,0,-1,2,e);return(i||o)&&(n=qe(t,1,-r,1+r,0,-1,2,e)||[],i&&(n=vy(i,1).concat(n)),o&&(n=n.concat(vy(o,-1)))),n}function vy(t,e){for(var r=[],n=0;n<t.length;n++){var i=t[n],o=i.type,a;if(o==="Point"||o==="MultiPoint"||o==="LineString")a=Tl(i.geometry,e);else if(o==="MultiLineString"||o==="Polygon"){a=[];for(var s=0;s<i.geometry.length;s++)a.push(Tl(i.geometry[s],e))}else if(o==="MultiPolygon")for(a=[],s=0;s<i.geometry.length;s++){for(var l=[],u=0;u<i.geometry[s].length;u++)l.push(Tl(i.geometry[s][u],e));a.push(l)}r.push(ft(i.id,o,a,i.tags))}return r}function Tl(t,e){var r=[];r.size=t.size,t.start!==void 0&&(r.start=t.start,r.end=t.end);for(var n=0;n<t.length;n+=3)r.push(t[n]+e,t[n+1],t[n+2]);return r}function Ma(t,e){if(t.transformed)return t;var r=1<<t.z,n=t.x,i=t.y,o,a,s;for(o=0;o<t.features.length;o++){var l=t.features[o],u=l.geometry,c=l.type;if(l.geometry=[],c===1)for(a=0;a<u.length;a+=2)l.geometry.push(Py(u[a],u[a+1],e,r,n,i));else for(a=0;a<u.length;a++){var p=[];for(s=0;s<u[a].length;s+=2)p.push(Py(u[a][s],u[a][s+1],e,r,n,i));l.geometry.push(p)}}return t.transformed=!0,t}function Py(t,e,r,n,i,o){return[Math.round(r*(t*n-i)),Math.round(r*(e*n-o))]}function Ml(t,e,r,n,i){for(var o=e===i.maxZoom?0:i.tolerance/((1<<e)*i.extent),a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:n,z:e,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},s=0;s<t.length;s++){a.numFeatures++,p0(a,t[s],o,i);var l=t[s].minX,u=t[s].minY,c=t[s].maxX,p=t[s].maxY;l<a.minX&&(a.minX=l),u<a.minY&&(a.minY=u),c>a.maxX&&(a.maxX=c),p>a.maxY&&(a.maxY=p)}return a}function p0(t,e,r,n){var i=e.geometry,o=e.type,a=[];if(o==="Point"||o==="MultiPoint")for(var s=0;s<i.length;s+=3)a.push(i[s]),a.push(i[s+1]),t.numPoints++,t.numSimplified++;else if(o==="LineString")kl(a,i,t,r,!1,!1);else if(o==="MultiLineString"||o==="Polygon")for(s=0;s<i.length;s++)kl(a,i[s],t,r,o==="Polygon",s===0);else if(o==="MultiPolygon")for(var l=0;l<i.length;l++){var u=i[l];for(s=0;s<u.length;s++)kl(a,u[s],t,r,!0,s===0)}if(a.length){var c=e.tags||null;if(o==="LineString"&&n.lineMetrics){c={};for(var p in e.tags)c[p]=e.tags[p];c.mapbox_clip_start=i.start/i.size,c.mapbox_clip_end=i.end/i.size}var f={geometry:a,type:o==="Polygon"||o==="MultiPolygon"?3:o==="LineString"||o==="MultiLineString"?2:1,tags:c};e.id!==null&&(f.id=e.id),t.features.push(f)}}function kl(t,e,r,n,i,o){var a=n*n;if(n>0&&e.size<(i?a:n)){r.numPoints+=e.length/3;return}for(var s=[],l=0;l<e.length;l+=3)(n===0||e[l+2]>a)&&(r.numSimplified++,s.push(e[l]),s.push(e[l+1])),r.numPoints++;i&&f0(s,o),t.push(s)}function f0(t,e){for(var r=0,n=0,i=t.length,o=i-2;n<i;o=n,n+=2)r+=(t[n]-t[o])*(t[n+1]+t[o+1]);if(r>0===e)for(n=0,i=t.length;n<i/2;n+=2){var a=t[n],s=t[n+1];t[n]=t[i-2-n],t[n+1]=t[i-1-n],t[i-2-n]=a,t[i-1-n]=s}}function Fl(t,e){return new Ea(t,e)}function Ea(t,e){e=this.options=y0(Object.create(this.options),e);var r=e.debug;if(r&&console.time("preprocess data"),e.maxZoom<0||e.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(e.promoteId&&e.generateId)throw new Error("promoteId and generateId cannot be used together.");var n=Al(t,e);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",e.indexMaxZoom,e.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),n=Cl(n,e),n.length&&this.splitTile(n,0,0,0),r&&(n.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}Ea.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};Ea.prototype.splitTile=function(t,e,r,n,i,o,a){for(var s=[t,e,r,n],l=this.options,u=l.debug;s.length;){n=s.pop(),r=s.pop(),e=s.pop(),t=s.pop();var c=1<<e,p=El(e,r,n),f=this.tiles[p];if(!f&&(u>1&&console.time("creation"),f=this.tiles[p]=Ml(t,e,r,n,l),this.tileCoords.push({z:e,x:r,y:n}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",e,r,n,f.numFeatures,f.numPoints,f.numSimplified),console.timeEnd("creation"));var y="z"+e;this.stats[y]=(this.stats[y]||0)+1,this.total++}if(f.source=t,i){if(e===l.maxZoom||e===i)continue;var m=1<<i-e;if(r!==Math.floor(o/m)||n!==Math.floor(a/m))continue}else if(e===l.indexMaxZoom||f.numPoints<=l.indexMaxPoints)continue;if(f.source=null,t.length!==0){u>1&&console.time("clipping");var h=.5*l.buffer/l.extent,d=.5-h,g=.5+h,b=1+h,x,v,P,w,T,F;x=v=P=w=null,T=qe(t,c,r-h,r+g,0,f.minX,f.maxX,l),F=qe(t,c,r+d,r+b,0,f.minX,f.maxX,l),t=null,T&&(x=qe(T,c,n-h,n+g,1,f.minY,f.maxY,l),v=qe(T,c,n+d,n+b,1,f.minY,f.maxY,l),T=null),F&&(P=qe(F,c,n-h,n+g,1,f.minY,f.maxY,l),w=qe(F,c,n+d,n+b,1,f.minY,f.maxY,l),F=null),u>1&&console.timeEnd("clipping"),s.push(x||[],e+1,r*2,n*2),s.push(v||[],e+1,r*2,n*2+1),s.push(P||[],e+1,r*2+1,n*2),s.push(w||[],e+1,r*2+1,n*2+1)}}};Ea.prototype.getTile=function(t,e,r){var n=this.options,i=n.extent,o=n.debug;if(t<0||t>24)return null;var a=1<<t;e=(e%a+a)%a;var s=El(t,e,r);if(this.tiles[s])return Ma(this.tiles[s],i);o>1&&console.log("drilling down to z%d-%d-%d",t,e,r);for(var l=t,u=e,c=r,p;!p&&l>0;)l--,u=Math.floor(u/2),c=Math.floor(c/2),p=this.tiles[El(l,u,c)];return!p||!p.source?null:(o>1&&console.log("found parent tile z%d-%d-%d",l,u,c),o>1&&console.time("drilling down"),this.splitTile(p.source,l,u,c,t,e,r),o>1&&console.timeEnd("drilling down"),this.tiles[s]?Ma(this.tiles[s],i):null)};function El(t,e,r){return((1<<t)*r+e)*32+t}function y0(t,e){for(var r in e)t[r]=e[r];return t}function wi(t,e){return e?t.properties[e]:t.id}function Ll(t,e){if(t==null)return!0;if(t.type==="Feature")return wi(t,e)!=null;if(t.type==="FeatureCollection"){let r=new Set;for(let n of t.features){let i=wi(n,e);if(i==null||r.has(i))return!1;r.add(i)}return!0}return!1}function Dl(t,e){let r=new Map;if(t!=null)if(t.type==="Feature")r.set(wi(t,e),t);else for(let n of t.features)r.set(wi(n,e),n);return r}function Sy(t,e,r){var n,i,o,a;if(e.removeAll&&t.clear(),e.remove)for(let s of e.remove)t.delete(s);if(e.add)for(let s of e.add){let l=wi(s,r);l!=null&&t.set(l,s)}if(e.update)for(let s of e.update){let l=t.get(s.id);if(l==null)continue;let u=s.newGeometry||s.removeAllProperties,c=!s.removeAllProperties&&(((n=s.removeProperties)==null?void 0:n.length)>0||((i=s.addOrUpdateProperties)==null?void 0:i.length)>0);if((u||c)&&(l=Dt({},l),t.set(s.id,l),c&&(l.properties=Dt({},l.properties))),s.newGeometry&&(l.geometry=s.newGeometry),s.removeAllProperties)l.properties={};else if(((o=s.removeProperties)==null?void 0:o.length)>0)for(let p of s.removeProperties)Object.prototype.hasOwnProperty.call(l.properties,p)&&delete l.properties[p];if(((a=s.addOrUpdateProperties)==null?void 0:a.length)>0)for(let{key:p,value:f}of s.addOrUpdateProperties)l.properties[p]=f}}var Fa=class extends Nr{constructor(){super(...arguments);this._dataUpdateable=new Map}async loadVectorTile(r,n){let i=r.tileID.canonical;if(!this._geoJSONIndex)throw new Error("Unable to parse the data into a cluster or geojson");let o=this._geoJSONIndex.getTile(i.z,i.x,i.y);if(!o)return null;let a=new _a(o.features),s=(0,Ay.default)(a);return(s.byteOffset!==0||s.byteLength!==s.buffer.byteLength)&&(s=new Uint8Array(s)),{vectorTile:a,rawData:s.buffer}}async loadData(r){var i;(i=this._pendingRequest)==null||i.abort();let n=r&&r.request&&r.request.collectResourceTiming?new Or(r.request):!1;this._pendingRequest=new AbortController;try{let o=await this.loadGeoJSON(r,this._pendingRequest);if(delete this._pendingRequest,typeof o!="object")throw new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object."));if((0,wy.default)(o,!0),r.filter){let s=jt(r.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if(s.result==="error")throw new Error(s.value.map(u=>"".concat(u.key,": ").concat(u.message)).join(", "));o={type:"FeatureCollection",features:o.features.filter(u=>s.value.evaluate({zoom:0},u))}}this._geoJSONIndex=r.cluster?new Pi(m0(r)).load(o.features):Fl(o,r.geojsonVtOptions),this.loaded={};let a={};if(n){let s=n.finish();s&&(a.resourceTiming={},a.resourceTiming[r.source]=JSON.parse(JSON.stringify(s)))}return a}catch(o){if(delete this._pendingRequest,ac(o))return{abandoned:!0};throw o}}reloadTile(r){let n=this.loaded,i=r.uid;return n&&n[i]?super.reloadTile(r):this.loadTile(r)}async loadGeoJSON(r,n){let{promoteId:i}=r;if(r.request){let o=await mc(r.request,n);return this._dataUpdateable=Ll(o.data,i)?Dl(o.data,i):void 0,o.data}if(typeof r.data=="string")try{let o=JSON.parse(r.data);return this._dataUpdateable=Ll(o,i)?Dl(o,i):void 0,o}catch(o){throw new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object."))}if(!r.dataDiff)throw new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object."));if(!this._dataUpdateable)throw new Error("Cannot update existing geojson data in ".concat(r.source));return Sy(this._dataUpdateable,r.dataDiff,i),{type:"FeatureCollection",features:Array.from(this._dataUpdateable.values())}}async removeSource(r){this._pendingRequest&&this._pendingRequest.abort()}getClusterExpansionZoom(r){return this._geoJSONIndex.getClusterExpansionZoom(r.clusterId)}getClusterChildren(r){return this._geoJSONIndex.getChildren(r.clusterId)}getClusterLeaves(r){return this._geoJSONIndex.getLeaves(r.clusterId,r.limit,r.offset)}};function m0({superclusterOptions:t,clusterProperties:e}){if(!e||!t)return t;let r={},n={},i={accumulated:null,zoom:0},o={properties:null},a=Object.keys(e);for(let s of a){let[l,u]=e[s],c=jt(u),p=jt(typeof l=="string"?[l,["accumulated"],["get",s]]:l);r[s]=c.value,n[s]=p.value}return t.map=s=>{o.properties=s;let l={};for(let u of a)l[u]=r[u].evaluate(i,o);return l},t.reduce=(s,l)=>{o.properties=l;for(let u of a)i.accumulated=s[u],s[u]=n[u].evaluate(i,o)},t}var La=class{constructor(e){this.self=e,this.actor=new io(e),this.layerIndexes={},this.availableImages={},this.workerSources={},this.demWorkerSources={},this.externalWorkerSourceTypes={},this.self.registerWorkerSource=(r,n)=>{if(this.externalWorkerSourceTypes[r])throw new Error('Worker source with name "'.concat(r,'" already registered.'));this.externalWorkerSourceTypes[r]=n},this.self.addProtocol=lc,this.self.removeProtocol=uc,this.self.registerRTLTextPlugin=r=>{if(ye.isParsed())throw new Error("RTL text plugin already registered.");ye.setMethods(r)},this.actor.registerMessageHandler("LDT",(r,n)=>this._getDEMWorkerSource(r,n.source).loadTile(n)),this.actor.registerMessageHandler("RDT",async(r,n)=>{this._getDEMWorkerSource(r,n.source).removeTile(n)}),this.actor.registerMessageHandler("GCEZ",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterExpansionZoom(n)),this.actor.registerMessageHandler("GCC",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterChildren(n)),this.actor.registerMessageHandler("GCL",async(r,n)=>this._getWorkerSource(r,n.type,n.source).getClusterLeaves(n)),this.actor.registerMessageHandler("LD",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadData(n)),this.actor.registerMessageHandler("LT",(r,n)=>this._getWorkerSource(r,n.type,n.source).loadTile(n)),this.actor.registerMessageHandler("RT",(r,n)=>this._getWorkerSource(r,n.type,n.source).reloadTile(n)),this.actor.registerMessageHandler("AT",(r,n)=>this._getWorkerSource(r,n.type,n.source).abortTile(n)),this.actor.registerMessageHandler("RMT",(r,n)=>this._getWorkerSource(r,n.type,n.source).removeTile(n)),this.actor.registerMessageHandler("RS",async(r,n)=>{if(!this.workerSources[r]||!this.workerSources[r][n.type]||!this.workerSources[r][n.type][n.source])return;let i=this.workerSources[r][n.type][n.source];delete this.workerSources[r][n.type][n.source],i.removeSource!==void 0&&i.removeSource(n)}),this.actor.registerMessageHandler("RM",async r=>{delete this.layerIndexes[r],delete this.availableImages[r],delete this.workerSources[r],delete this.demWorkerSources[r]}),this.actor.registerMessageHandler("SR",async(r,n)=>{this.referrer=n}),this.actor.registerMessageHandler("SRPS",(r,n)=>this._syncRTLPluginState(r,n)),this.actor.registerMessageHandler("IS",async(r,n)=>{this.self.importScripts(n)}),this.actor.registerMessageHandler("SI",(r,n)=>this._setImages(r,n)),this.actor.registerMessageHandler("UL",async(r,n)=>{this._getLayerIndex(r).update(n.layers,n.removedIds)}),this.actor.registerMessageHandler("SL",async(r,n)=>{this._getLayerIndex(r).replace(n)})}async _setImages(e,r){this.availableImages[e]=r;for(let n in this.workerSources[e]){let i=this.workerSources[e][n];for(let o in i)i[o].availableImages=r}}async _syncRTLPluginState(e,r){if(ye.isParsed())return ye.getState();if(r.pluginStatus!=="loading")return ye.setState(r),r;let n=r.pluginURL;if(this.self.importScripts(n),ye.isParsed()){let o={pluginStatus:"loaded",pluginURL:n};return ye.setState(o),o}throw ye.setState({pluginStatus:"error",pluginURL:""}),new Error("RTL Text Plugin failed to import scripts from ".concat(n))}_getAvailableImages(e){let r=this.availableImages[e];return r||(r=[]),r}_getLayerIndex(e){let r=this.layerIndexes[e];return r||(r=this.layerIndexes[e]=new ya),r}_getWorkerSource(e,r,n){if(this.workerSources[e]||(this.workerSources[e]={}),this.workerSources[e][r]||(this.workerSources[e][r]={}),!this.workerSources[e][r][n]){let i={sendAsync:(o,a)=>(o.targetMapId=e,this.actor.sendAsync(o,a))};switch(r){case"vector":this.workerSources[e][r][n]=new Nr(i,this._getLayerIndex(e),this._getAvailableImages(e));break;case"geojson":this.workerSources[e][r][n]=new Fa(i,this._getLayerIndex(e),this._getAvailableImages(e));break;default:this.workerSources[e][r][n]=new this.externalWorkerSourceTypes[r](i,this._getLayerIndex(e),this._getAvailableImages(e));break}}return this.workerSources[e][r][n]}_getDEMWorkerSource(e,r){return this.demWorkerSources[e]||(this.demWorkerSources[e]={}),this.demWorkerSources[e][r]||(this.demWorkerSources[e][r]=new wa),this.demWorkerSources[e][r]}};at(self)&&(self.worker=new La(self));})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
`;
var jk = H$3(() => Ke.WORKER_URL ? Ke.WORKER_URL : URL.createObjectURL(new Blob([X0], { type: "text/javascript" })), "getWorkerURL");
function K0() {
  return new Worker(jk());
}
H$3(K0, "workerFactory");
var mu2 = "maplibre_preloaded_worker_pool", fu2 = class fu3 {
  constructor() {
    this.active = {};
  }
  acquire(e) {
    if (!this.workers) for (this.workers = []; this.workers.length < fu3.workerCount; ) this.workers.push(K0());
    return this.active[e] = true, this.workers.slice();
  }
  release(e) {
    delete this.active[e], this.numActive() === 0 && (this.workers.forEach((t) => {
      t.terminate();
    }), this.workers = null);
  }
  isPreloaded() {
    return !!this.active[mu2];
  }
  numActive() {
    return Object.keys(this.active).length;
  }
};
H$3(fu2, "WorkerPool");
var zr = fu2, Zk = Math.floor(Y$1.hardwareConcurrency / 2);
zr.workerCount = ob$1(globalThis) ? Math.max(Math.min(Zk, 3), 1) : 1;
var sa$1;
function la$1() {
  return sa$1 || (sa$1 = new zr()), sa$1;
}
H$3(la$1, "getGlobalWorkerPool");
function Hk() {
  la$1().acquire(mu2);
}
H$3(Hk, "prewarm");
function $k() {
  let r5 = sa$1;
  r5 && (r5.isPreloaded() && r5.numActive() === 1 ? (r5.release(mu2), sa$1 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
}
H$3($k, "clearPrewarmedResources");
var dd$1 = class dd {
  constructor(e, t) {
    this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = t;
    let i = this.workerPool.acquire(t);
    for (let n4 = 0; n4 < i.length; n4++) {
      let o4 = i[n4], a4 = new hu2(o4, t);
      a4.name = "Worker ".concat(n4), this.actors.push(a4);
    }
    if (!this.actors.length) throw new Error("No actors found");
  }
  broadcast(e, t) {
    let i = [];
    for (let n4 of this.actors) i.push(n4.sendAsync({ type: e, data: t }));
    return Promise.all(i);
  }
  getActor() {
    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
  }
  remove(e = true) {
    this.actors.forEach((t) => {
      t.remove();
    }), this.actors = [], e && this.workerPool.release(this.id);
  }
  registerMessageHandler(e, t) {
    for (let i of this.actors) i.registerMessageHandler(e, t);
  }
};
H$3(dd$1, "Dispatcher");
var ua$1 = dd$1, du$1;
function yu() {
  return du$1 || (du$1 = new ua$1(la$1(), ls$1), du$1.registerMessageHandler("GR", (r5, e, t) => ki$1(e, t))), du$1;
}
H$3(yu, "getGlobalDispatcher");
a();
function Wk(r5, e) {
  let t = q$2.create();
  return q$2.translate(t, t, [1, 1, 0]), q$2.scale(t, t, [r5.width * 0.5, r5.height * 0.5, 1]), q$2.multiply(t, t, r5.calculatePosMatrix(e.toUnwrapped()));
}
H$3(Wk, "getPixelPosMatrix");
function Xk(r5, e, t) {
  if (r5) for (let i of r5) {
    let n4 = e[i];
    if (n4 && n4.source === t && n4.type === "fill-extrusion") return true;
  }
  else for (let i in e) {
    let n4 = e[i];
    if (n4.source === t && n4.type === "fill-extrusion") return true;
  }
  return false;
}
H$3(Xk, "queryIncludes3DLayer");
function J0(r5, e, t, i, n4, o4) {
  let a4 = Xk(n4 && n4.layers, e, r5.id), s5 = o4.maxPitchScaleFactor(), u5 = r5.tilesIn(i, s5, a4);
  u5.sort(e1$1);
  let c = [];
  for (let h of u5) c.push({ wrappedTileID: h.tileID.wrapped().key, queryResults: h.tile.queryRenderedFeatures(e, t, r5._state, h.queryGeometry, h.cameraQueryGeometry, h.scale, n4, o4, s5, Wk(r5.transform, h.tileID)) });
  let p4 = Kk(c);
  for (let h in p4) p4[h].forEach((f) => {
    let m5 = f.feature, y4 = r5.getFeatureState(m5.layer["source-layer"], m5.id);
    m5.source = m5.layer.source, m5.layer["source-layer"] && (m5.sourceLayer = m5.layer["source-layer"]), m5.state = y4;
  });
  return p4;
}
H$3(J0, "queryRenderedFeatures");
function Y0(r5, e, t, i, n4, o4, a4) {
  let s5 = {}, u5 = o4.queryRenderedSymbols(i), c = [];
  for (let p4 of Object.keys(u5).map(Number)) c.push(a4[p4]);
  c.sort(e1$1);
  for (let p4 of c) {
    let h = p4.featureIndex.lookupSymbolFeatures(u5[p4.bucketInstanceId], e, p4.bucketIndex, p4.sourceLayerIndex, n4.filter, n4.layers, n4.availableImages, r5);
    for (let f in h) {
      let m5 = s5[f] = s5[f] || [], y4 = h[f];
      y4.sort((g, x2) => {
        let b = p4.featureSortOrder;
        if (b) {
          let w3 = b.indexOf(g.featureIndex);
          return b.indexOf(x2.featureIndex) - w3;
        } else return x2.featureIndex - g.featureIndex;
      });
      for (let g of y4) m5.push(g);
    }
  }
  for (let p4 in s5) s5[p4].forEach((h) => {
    let f = h.feature, m5 = r5[p4], g = t[m5.source].getFeatureState(f.layer["source-layer"], f.id);
    f.source = f.layer.source, f.layer["source-layer"] && (f.sourceLayer = f.layer["source-layer"]), f.state = g;
  });
  return s5;
}
H$3(Y0, "queryRenderedSymbols");
function Q0(r5, e) {
  let t = r5.getRenderableIds().map((o4) => r5.getTileByID(o4)), i = [], n4 = {};
  for (let o4 = 0; o4 < t.length; o4++) {
    let a4 = t[o4], s5 = a4.tileID.canonical.key;
    n4[s5] || (n4[s5] = true, a4.querySourceFeatures(i, e));
  }
  return i;
}
H$3(Q0, "querySourceFeatures");
function e1$1(r5, e) {
  let t = r5.tileID, i = e.tileID;
  return t.overscaledZ - i.overscaledZ || t.canonical.y - i.canonical.y || t.wrap - i.wrap || t.canonical.x - i.canonical.x;
}
H$3(e1$1, "sortTilesIn");
function Kk(r5) {
  let e = {}, t = {};
  for (let i of r5) {
    let n4 = i.queryResults, o4 = i.wrappedTileID, a4 = t[o4] = t[o4] || {};
    for (let s5 in n4) {
      let u5 = n4[s5], c = a4[s5] = a4[s5] || {}, p4 = e[s5] = e[s5] || [];
      for (let h of u5) c[h.featureIndex] || (c[h.featureIndex] = true, p4.push(h));
    }
  }
  return e;
}
H$3(Kk, "mergeRenderedFeatureLayers");
a();
a();
a();
a();
async function gu2(r5, e, t) {
  let i = r5;
  if (r5.url ? i = (await gr$1(e.transformRequest(r5.url, "Source"), t)).data : await Y$1.frameAsync(t), !i) return null;
  let n4 = yr$1(V$1(i, r5), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
  return "vector_layers" in i && i.vector_layers && (n4.vectorLayerIds = i.vector_layers.map((o4) => o4.id)), n4;
}
H$3(gu2, "loadTileJson");
a();
a();
a();
var ca$1 = 63710088e-1, _i = class _i2 {
  constructor(e, t) {
    if (isNaN(e) || isNaN(t)) throw new Error("Invalid LngLat object: (".concat(e, ", ").concat(t, ")"));
    if (this.lng = +e, this.lat = +t, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
  }
  wrap() {
    return new _i2(er$1(this.lng, -180, 180), this.lat);
  }
  toArray() {
    return [this.lng, this.lat];
  }
  toString() {
    return "LngLat(".concat(this.lng, ", ").concat(this.lat, ")");
  }
  distanceTo(e) {
    let t = Math.PI / 180, i = this.lat * t, n4 = e.lat * t, o4 = Math.sin(i) * Math.sin(n4) + Math.cos(i) * Math.cos(n4) * Math.cos((e.lng - this.lng) * t);
    return ca$1 * Math.acos(Math.min(o4, 1));
  }
  static convert(e) {
    if (e instanceof _i2) return e;
    if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new _i2(Number(e[0]), Number(e[1]));
    if (!Array.isArray(e) && typeof e == "object" && e !== null) return new _i2(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
  }
};
H$3(_i, "LngLat");
var ie$1 = _i;
var Fr = class Fr2 {
  constructor(e, t) {
    e && (t ? this.setSouthWest(e).setNorthEast(t) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
  }
  setNorthEast(e) {
    return this._ne = e instanceof ie$1 ? new ie$1(e.lng, e.lat) : ie$1.convert(e), this;
  }
  setSouthWest(e) {
    return this._sw = e instanceof ie$1 ? new ie$1(e.lng, e.lat) : ie$1.convert(e), this;
  }
  extend(e) {
    let t = this._sw, i = this._ne, n4, o4;
    if (e instanceof ie$1) n4 = e, o4 = e;
    else if (e instanceof Fr2) {
      if (n4 = e._sw, o4 = e._ne, !n4 || !o4) return this;
    } else {
      if (Array.isArray(e)) if (e.length === 4 || e.every(Array.isArray)) {
        let a4 = e;
        return this.extend(Fr2.convert(a4));
      } else {
        let a4 = e;
        return this.extend(ie$1.convert(a4));
      }
      else if (e && ("lng" in e || "lon" in e) && "lat" in e) return this.extend(ie$1.convert(e));
      return this;
    }
    return !t && !i ? (this._sw = new ie$1(n4.lng, n4.lat), this._ne = new ie$1(o4.lng, o4.lat)) : (t.lng = Math.min(n4.lng, t.lng), t.lat = Math.min(n4.lat, t.lat), i.lng = Math.max(o4.lng, i.lng), i.lat = Math.max(o4.lat, i.lat)), this;
  }
  getCenter() {
    return new ie$1((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
  }
  getSouthWest() {
    return this._sw;
  }
  getNorthEast() {
    return this._ne;
  }
  getNorthWest() {
    return new ie$1(this.getWest(), this.getNorth());
  }
  getSouthEast() {
    return new ie$1(this.getEast(), this.getSouth());
  }
  getWest() {
    return this._sw.lng;
  }
  getSouth() {
    return this._sw.lat;
  }
  getEast() {
    return this._ne.lng;
  }
  getNorth() {
    return this._ne.lat;
  }
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }
  toString() {
    return "LngLatBounds(".concat(this._sw.toString(), ", ").concat(this._ne.toString(), ")");
  }
  isEmpty() {
    return !(this._sw && this._ne);
  }
  contains(e) {
    let { lng: t, lat: i } = ie$1.convert(e), n4 = this._sw.lat <= i && i <= this._ne.lat, o4 = this._sw.lng <= t && t <= this._ne.lng;
    return this._sw.lng > this._ne.lng && (o4 = this._sw.lng >= t && t >= this._ne.lng), n4 && o4;
  }
  static convert(e) {
    return e instanceof Fr2 || !e ? e : new Fr2(e);
  }
  static fromLngLat(e, t = 0) {
    let n4 = 360 * t / 40075017, o4 = n4 / Math.cos(Math.PI / 180 * e.lat);
    return new Fr2(new ie$1(e.lng - o4, e.lat - n4), new ie$1(e.lng + o4, e.lat + n4));
  }
};
H$3(Fr, "LngLatBounds");
var ut$1 = Fr;
a();
var t1$1 = 2 * Math.PI * ca$1;
function r1$1(r5) {
  return t1$1 * Math.cos(r5 * Math.PI / 180);
}
H$3(r1$1, "circumferenceAtLatitude");
function Rr(r5) {
  return (180 + r5) / 360;
}
H$3(Rr, "mercatorXfromLng");
function Br$1(r5) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r5 * Math.PI / 360))) / 360;
}
H$3(Br$1, "mercatorYfromLat");
function bu$1(r5, e) {
  return r5 / r1$1(e);
}
H$3(bu$1, "mercatorZfromAltitude");
function Jk(r5) {
  return r5 * 360 - 180;
}
H$3(Jk, "lngFromMercatorX");
function yd$1(r5) {
  let e = 180 - r5 * 360;
  return 360 / Math.PI * Math.atan(Math.exp(e * Math.PI / 180)) - 90;
}
H$3(yd$1, "latFromMercatorY");
function Yk(r5, e) {
  return r5 * r1$1(yd$1(e));
}
H$3(Yk, "altitudeFromMercatorZ");
function Qk(r5) {
  return 1 / Math.cos(r5 * Math.PI / 180);
}
H$3(Qk, "mercatorScale");
var xu$1 = class xu {
  constructor(e, t, i = 0) {
    this.x = +e, this.y = +t, this.z = +i;
  }
  static fromLngLat(e, t = 0) {
    let i = ie$1.convert(e);
    return new xu(Rr(i.lng), Br$1(i.lat), bu$1(t, i.lat));
  }
  toLngLat() {
    return new ie$1(Jk(this.x), yd$1(this.y));
  }
  toAltitude() {
    return Yk(this.z, this.y);
  }
  meterInMercatorCoordinateUnits() {
    return 1 / t1$1 * Qk(yd$1(this.y));
  }
};
H$3(xu$1, "MercatorCoordinate");
var Fe$1 = xu$1;
var gd = class gd2 {
  constructor(e, t, i) {
    this.bounds = ut$1.convert(this.validateBounds(e)), this.minzoom = t || 0, this.maxzoom = i || 24;
  }
  validateBounds(e) {
    return !Array.isArray(e) || e.length !== 4 ? [-180, -90, 180, 90] : [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])];
  }
  contains(e) {
    let t = Math.pow(2, e.z), i = { minX: Math.floor(Rr(this.bounds.getWest()) * t), minY: Math.floor(Br$1(this.bounds.getNorth()) * t), maxX: Math.ceil(Rr(this.bounds.getEast()) * t), maxY: Math.ceil(Br$1(this.bounds.getSouth()) * t) };
    return e.x >= i.minX && e.x < i.maxX && e.y >= i.minY && e.y < i.maxY;
  }
};
H$3(gd, "TileBounds");
var xn$1 = gd;
var xd$1 = class xd extends de$1 {
  constructor(e, t, i, n4) {
    if (super(), this.id = e, this.dispatcher = i, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, V$1(this, yr$1(t, ["url", "scheme", "tileSize", "promoteId"])), this._options = V$1({ type: "vector" }, t), this._collectResourceTiming = t.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
    this.setEventedParent(n4);
  }
  async load() {
    this._loaded = false, this.fire(new F("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let e = await gu2(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (V$1(this, e), e.bounds && (this.tileBounds = new xn$1(e.bounds, this.minzoom, this.maxzoom)), this.fire(new F("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new F("data", { dataType: "source", sourceDataType: "content" })));
    } catch (e) {
      this._tileJSONRequest = null, this.fire(new H$2(e));
    }
  }
  loaded() {
    return this._loaded;
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setSourceProperty(e) {
    this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  serialize() {
    return V$1({}, this._options);
  }
  async loadTile(e) {
    let t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = { request: this.map._requestManager.transformRequest(t, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    i.request.collectResourceTiming = this._collectResourceTiming;
    let n4 = "RT";
    if (!e.actor || e.state === "expired") e.actor = this.dispatcher.getActor(), n4 = "LT";
    else if (e.state === "loading") return new Promise((o4, a4) => {
      e.reloadPromise = { resolve: o4, reject: a4 };
    });
    e.abortController = new AbortController();
    try {
      let o4 = await e.actor.sendAsync({ type: n4, data: i }, e.abortController);
      if (delete e.abortController, e.aborted) return;
      this._afterTileLoadWorkerResponse(e, o4);
    } catch (o4) {
      if (delete e.abortController, e.aborted) return;
      if (o4 && o4.status !== 404) throw o4;
      this._afterTileLoadWorkerResponse(e, null);
    }
  }
  _afterTileLoadWorkerResponse(e, t) {
    if (t && t.resourceTiming && (e.resourceTiming = t.resourceTiming), t && this.map._refreshExpiredTiles && e.setExpiryData(t), e.loadVectorData(t, this.map.painter), e.reloadPromise) {
      let i = e.reloadPromise;
      e.reloadPromise = null, this.loadTile(e).then(i.resolve).catch(i.reject);
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && await e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  async unloadTile(e) {
    e.unloadVectorData(), e.actor && await e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  hasTransition() {
    return false;
  }
};
H$3(xd$1, "VectorTileSource");
var pa$1 = xd$1;
a();
var bd$1 = class bd extends de$1 {
  constructor(e, t, i, n4) {
    super(), this.id = e, this.dispatcher = i, this.setEventedParent(n4), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = V$1({ type: "raster" }, t), V$1(this, yr$1(t, ["url", "scheme", "tileSize"]));
  }
  async load() {
    this._loaded = false, this.fire(new F("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
    try {
      let e = await gu2(this._options, this.map._requestManager, this._tileJSONRequest);
      this._tileJSONRequest = null, this._loaded = true, e && (V$1(this, e), e.bounds && (this.tileBounds = new xn$1(e.bounds, this.minzoom, this.maxzoom)), this.fire(new F("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new F("data", { dataType: "source", sourceDataType: "content" })));
    } catch (e) {
      this._tileJSONRequest = null, this.fire(new H$2(e));
    }
  }
  loaded() {
    return this._loaded;
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
  }
  setSourceProperty(e) {
    this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load();
  }
  setTiles(e) {
    return this.setSourceProperty(() => {
      this._options.tiles = e;
    }), this;
  }
  setUrl(e) {
    return this.setSourceProperty(() => {
      this.url = e, this._options.url = e;
    }), this;
  }
  serialize() {
    return V$1({}, this._options);
  }
  hasTile(e) {
    return !this.tileBounds || this.tileBounds.contains(e.canonical);
  }
  async loadTile(e) {
    let t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
    e.abortController = new AbortController();
    try {
      let i = await st$1.getImage(this.map._requestManager.transformRequest(t, "Tile"), e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (i && i.data) {
        this.map._refreshExpiredTiles && i.cacheControl && i.expires && e.setExpiryData({ cacheControl: i.cacheControl, expires: i.expires });
        let n4 = this.map.painter.context, o4 = n4.gl, a4 = i.data;
        e.texture = this.map.painter.getTileTexture(a4.width), e.texture ? e.texture.update(a4, { useMipmap: true }) : (e.texture = new ve$2(n4, a4, o4.RGBA, { useMipmap: true }), e.texture.bind(o4.LINEAR, o4.CLAMP_TO_EDGE, o4.LINEAR_MIPMAP_NEAREST), n4.extTextureFilterAnisotropic && o4.texParameterf(o4.TEXTURE_2D, n4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n4.extTextureFilterAnisotropicMax)), e.state = "loaded";
      }
    } catch (i) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (i) throw e.state = "errored", i;
    }
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController);
  }
  async unloadTile(e) {
    e.texture && this.map.painter.saveTileTexture(e.texture);
  }
  hasTransition() {
    return false;
  }
};
H$3(bd$1, "RasterTileSource");
var vi = bd$1;
a();
a();
a();
function n1$1(r5, e, t) {
  e = Math.pow(2, t) - e - 1;
  var i = i1$1(r5 * 256, e * 256, t), n4 = i1$1((r5 + 1) * 256, (e + 1) * 256, t);
  return i[0] + "," + i[1] + "," + n4[0] + "," + n4[1];
}
H$3(n1$1, "getTileBBox");
function i1$1(r5, e, t) {
  var i = 2 * Math.PI * 6378137 / 256 / Math.pow(2, t), n4 = r5 * i - 2 * Math.PI * 6378137 / 2, o4 = e * i - 2 * Math.PI * 6378137 / 2;
  return [n4, o4];
}
H$3(i1$1, "getMercCoords");
var o1$1 = N$2(ge(), 1);
var _d$1 = class _d {
  constructor(e, t, i) {
    if (e < 0 || e > 25 || i < 0 || i >= Math.pow(2, e) || t < 0 || t >= Math.pow(2, e)) throw new Error("x=".concat(t, ", y=").concat(i, ", z=").concat(e, " outside of bounds. 0<=x<").concat(Math.pow(2, e), ", 0<=y<").concat(Math.pow(2, e), " 0<=z<=25 "));
    this.z = e, this.x = t, this.y = i, this.key = ha$1(0, e, e, t, i);
  }
  equals(e) {
    return this.z === e.z && this.x === e.x && this.y === e.y;
  }
  url(e, t, i) {
    let n4 = n1$1(this.x, this.y, this.z), o4 = eL$1(this.z, this.x, this.y);
    return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, t > 1 ? "@2x" : "").replace(/{quadkey}/g, o4).replace(/{bbox-epsg-3857}/g, n4);
  }
  isChildOf(e) {
    let t = this.z - e.z;
    return t > 0 && e.x === this.x >> t && e.y === this.y >> t;
  }
  getTilePoint(e) {
    let t = Math.pow(2, this.z);
    return new o1$1.default((e.x * t - this.x) * 8192, (e.y * t - this.y) * 8192);
  }
  toString() {
    return "".concat(this.z, "/").concat(this.x, "/").concat(this.y);
  }
};
H$3(_d$1, "CanonicalTileID");
var bn$1 = _d$1, vd$1 = class vd {
  constructor(e, t) {
    this.wrap = e, this.canonical = t, this.key = ha$1(e, t.z, t.z, t.x, t.y);
  }
};
H$3(vd$1, "UnwrappedTileID");
var _n$1 = vd$1, Pt$2 = class Pt {
  constructor(e, t, i, n4, o4) {
    if (e < i) throw new Error("overscaledZ should be >= z; overscaledZ = ".concat(e, "; z = ").concat(i));
    this.overscaledZ = e, this.wrap = t, this.canonical = new bn$1(i, +n4, +o4), this.key = ha$1(t, e, i, n4, o4);
  }
  clone() {
    return new Pt(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  equals(e) {
    return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
  }
  scaledTo(e) {
    if (e > this.overscaledZ) throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(e, "; overscaledZ = ").concat(this.overscaledZ));
    let t = this.canonical.z - e;
    return e > this.canonical.z ? new Pt(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Pt(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t);
  }
  calculateScaledKey(e, t) {
    if (e > this.overscaledZ) throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(e, "; overscaledZ = ").concat(this.overscaledZ));
    let i = this.canonical.z - e;
    return e > this.canonical.z ? ha$1(this.wrap * +t, e, this.canonical.z, this.canonical.x, this.canonical.y) : ha$1(this.wrap * +t, e, e, this.canonical.x >> i, this.canonical.y >> i);
  }
  isChildOf(e) {
    if (e.wrap !== this.wrap) return false;
    let t = this.canonical.z - e.canonical.z;
    return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> t && e.canonical.y === this.canonical.y >> t;
  }
  children(e) {
    if (this.overscaledZ >= e) return [new Pt(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
    let t = this.canonical.z + 1, i = this.canonical.x * 2, n4 = this.canonical.y * 2;
    return [new Pt(t, this.wrap, t, i, n4), new Pt(t, this.wrap, t, i + 1, n4), new Pt(t, this.wrap, t, i, n4 + 1), new Pt(t, this.wrap, t, i + 1, n4 + 1)];
  }
  isLessThan(e) {
    return this.wrap < e.wrap ? true : this.wrap > e.wrap ? false : this.overscaledZ < e.overscaledZ ? true : this.overscaledZ > e.overscaledZ ? false : this.canonical.x < e.canonical.x ? true : this.canonical.x > e.canonical.x ? false : this.canonical.y < e.canonical.y;
  }
  wrapped() {
    return new Pt(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  unwrapTo(e) {
    return new Pt(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  overscaleFactor() {
    return Math.pow(2, this.overscaledZ - this.canonical.z);
  }
  toUnwrapped() {
    return new _n$1(this.wrap, this.canonical);
  }
  toString() {
    return "".concat(this.overscaledZ, "/").concat(this.canonical.x, "/").concat(this.canonical.y);
  }
  getTilePoint(e) {
    return this.canonical.getTilePoint(new Fe$1(e.x - this.wrap, e.y));
  }
};
H$3(Pt$2, "OverscaledTileID");
var Je = Pt$2;
function ha$1(r5, e, t, i, n4) {
  r5 *= 2, r5 < 0 && (r5 = r5 * -1 - 1);
  let o4 = 1 << t;
  return (o4 * o4 * r5 + o4 * n4 + i).toString(36) + t.toString(36) + e.toString(36);
}
H$3(ha$1, "calculateKey");
function eL$1(r5, e, t) {
  let i = "", n4;
  for (let o4 = r5; o4 > 0; o4--) n4 = 1 << o4 - 1, i += (e & n4 ? 1 : 0) + (t & n4 ? 2 : 0);
  return i;
}
H$3(eL$1, "getQuadkey");
N$1("CanonicalTileID", bn$1);
N$1("OverscaledTileID", Je, { omit: ["posMatrix"] });
a();
var Sd$1 = class Sd {
  constructor(e, t, i, n4 = 1, o4 = 1, a4 = 1, s5 = 0) {
    if (this.uid = e, t.height !== t.width) throw new RangeError("DEM tiles must be square");
    if (i && !["mapbox", "terrarium", "custom"].includes(i)) {
      Le$1('"'.concat(i, '" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".'));
      return;
    }
    this.stride = t.height;
    let u5 = this.dim = t.height - 2;
    switch (this.data = new Uint32Array(t.data.buffer), i) {
      case "terrarium":
        this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
        break;
      case "custom":
        this.redFactor = n4, this.greenFactor = o4, this.blueFactor = a4, this.baseShift = s5;
        break;
      case "mapbox":
      default:
        this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
        break;
    }
    for (let c = 0; c < u5; c++) this.data[this._idx(-1, c)] = this.data[this._idx(0, c)], this.data[this._idx(u5, c)] = this.data[this._idx(u5 - 1, c)], this.data[this._idx(c, -1)] = this.data[this._idx(c, 0)], this.data[this._idx(c, u5)] = this.data[this._idx(c, u5 - 1)];
    this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(u5, -1)] = this.data[this._idx(u5 - 1, 0)], this.data[this._idx(-1, u5)] = this.data[this._idx(0, u5 - 1)], this.data[this._idx(u5, u5)] = this.data[this._idx(u5 - 1, u5 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
    for (let c = 0; c < u5; c++) for (let p4 = 0; p4 < u5; p4++) {
      let h = this.get(c, p4);
      h > this.max && (this.max = h), h < this.min && (this.min = h);
    }
  }
  get(e, t) {
    let i = new Uint8Array(this.data.buffer), n4 = this._idx(e, t) * 4;
    return this.unpack(i[n4], i[n4 + 1], i[n4 + 2]);
  }
  getUnpackVector() {
    return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
  }
  _idx(e, t) {
    if (e < -1 || e >= this.dim + 1 || t < -1 || t >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
    return (t + 1) * this.stride + (e + 1);
  }
  unpack(e, t, i) {
    return e * this.redFactor + t * this.greenFactor + i * this.blueFactor - this.baseShift;
  }
  getPixels() {
    return new Se$2({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
  }
  backfillBorder(e, t, i) {
    if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
    let n4 = t * this.dim, o4 = t * this.dim + this.dim, a4 = i * this.dim, s5 = i * this.dim + this.dim;
    switch (t) {
      case -1:
        n4 = o4 - 1;
        break;
      case 1:
        o4 = n4 + 1;
        break;
    }
    switch (i) {
      case -1:
        a4 = s5 - 1;
        break;
      case 1:
        s5 = a4 + 1;
        break;
    }
    let u5 = -t * this.dim, c = -i * this.dim;
    for (let p4 = a4; p4 < s5; p4++) for (let h = n4; h < o4; h++) this.data[this._idx(h, p4)] = e.data[this._idx(h + u5, p4 + c)];
  }
};
H$3(Sd$1, "DEMData");
var wd$1 = Sd$1;
N$1("DEMData", wd$1);
var Pd$1 = class Pd extends vi {
  constructor(e, t, i, n4) {
    super(e, t, i, n4), this.type = "raster-dem", this.maxzoom = 22, this._options = V$1({ type: "raster-dem" }, t), this.encoding = t.encoding || "mapbox", this.redFactor = t.redFactor, this.greenFactor = t.greenFactor, this.blueFactor = t.blueFactor, this.baseShift = t.baseShift;
  }
  async loadTile(e) {
    let t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = this.map._requestManager.transformRequest(t, "Tile");
    e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
    try {
      let n4 = await st$1.getImage(i, e.abortController, this.map._refreshExpiredTiles);
      if (delete e.abortController, e.aborted) {
        e.state = "unloaded";
        return;
      }
      if (n4 && n4.data) {
        let o4 = n4.data;
        this.map._refreshExpiredTiles && n4.cacheControl && n4.expires && e.setExpiryData({ cacheControl: n4.cacheControl, expires: n4.expires });
        let s5 = ht$1(o4) && rs() ? o4 : await this.readImageNow(o4), u5 = { type: this.type, uid: e.uid, source: this.id, rawImageData: s5, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
        if (!e.actor || e.state === "expired") {
          e.actor = this.dispatcher.getActor();
          let c = await e.actor.sendAsync({ type: "LDT", data: u5 });
          e.dem = c, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
        }
      }
    } catch (n4) {
      if (delete e.abortController, e.aborted) e.state = "unloaded";
      else if (n4) throw e.state = "errored", n4;
    }
  }
  async readImageNow(e) {
    if (typeof VideoFrame < "u" && _p$1()) {
      let t = e.width + 2, i = e.height + 2;
      try {
        return new Se$2({ width: t, height: i }, await lb$1(e, -1, -1, t, i));
      } catch (n4) {
      }
    }
    return Y$1.getImageData(e, 1);
  }
  _getNeighboringTiles(e) {
    let t = e.canonical, i = Math.pow(2, t.z), n4 = (t.x - 1 + i) % i, o4 = t.x === 0 ? e.wrap - 1 : e.wrap, a4 = (t.x + 1 + i) % i, s5 = t.x + 1 === i ? e.wrap + 1 : e.wrap, u5 = {};
    return u5[new Je(e.overscaledZ, o4, t.z, n4, t.y).key] = { backfilled: false }, u5[new Je(e.overscaledZ, s5, t.z, a4, t.y).key] = { backfilled: false }, t.y > 0 && (u5[new Je(e.overscaledZ, o4, t.z, n4, t.y - 1).key] = { backfilled: false }, u5[new Je(e.overscaledZ, e.wrap, t.z, t.x, t.y - 1).key] = { backfilled: false }, u5[new Je(e.overscaledZ, s5, t.z, a4, t.y - 1).key] = { backfilled: false }), t.y + 1 < i && (u5[new Je(e.overscaledZ, o4, t.z, n4, t.y + 1).key] = { backfilled: false }, u5[new Je(e.overscaledZ, e.wrap, t.z, t.x, t.y + 1).key] = { backfilled: false }, u5[new Je(e.overscaledZ, s5, t.z, a4, t.y + 1).key] = { backfilled: false }), u5;
  }
  async unloadTile(e) {
    e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && await e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } });
  }
};
H$3(Pd$1, "RasterDEMTileSource");
var fa$1 = Pd$1;
a();
var Td$1 = class Td extends de$1 {
  constructor(e, t, i, n4) {
    super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = i.getActor(), this.setEventedParent(n4), this._data = t.data, this._options = V$1({}, t), this._collectResourceTiming = t.collectResourceTiming, t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
    let o4 = 8192 / this.tileSize;
    this.workerOptions = V$1({ source: this.id, cluster: t.cluster || false, geojsonVtOptions: { buffer: (t.buffer !== void 0 ? t.buffer : 128) * o4, tolerance: (t.tolerance !== void 0 ? t.tolerance : 0.375) * o4, extent: 8192, maxZoom: this.maxzoom, lineMetrics: t.lineMetrics || false, generateId: t.generateId || false }, superclusterOptions: { maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t.clusterMinPoints || 2), extent: 8192, radius: (t.clusterRadius || 50) * o4, log: false, generateId: t.generateId || false }, clusterProperties: t.clusterProperties, filter: t.filter }, t.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
  }
  async load() {
    await this._updateWorkerData();
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  setData(e) {
    return this._data = e, this._updateWorkerData(), this;
  }
  updateData(e) {
    return this._updateWorkerData(e), this;
  }
  setClusterOptions(e) {
    return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = e.clusterRadius), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
  }
  getClusterExpansionZoom(e) {
    return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterChildren(e) {
    return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
  }
  getClusterLeaves(e, t, i) {
    return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: t, offset: i } });
  }
  async _updateWorkerData(e) {
    let t = V$1({ type: this.type }, this.workerOptions);
    e ? t.dataDiff = e : typeof this._data == "string" ? (t.request = this.map._requestManager.transformRequest(Y$1.resolveURL(this._data), "Source"), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new F("dataloading", { dataType: "source" }));
    try {
      let i = await this.actor.sendAsync({ type: "LD", data: t });
      if (this._pendingLoads--, this._removed || i.abandoned) {
        this.fire(new F("dataabort", { dataType: "source" }));
        return;
      }
      let n4 = null;
      i.resourceTiming && i.resourceTiming[this.id] && (n4 = i.resourceTiming[this.id].slice(0));
      let o4 = { dataType: "source" };
      this._collectResourceTiming && n4 && n4.length > 0 && V$1(o4, { resourceTiming: n4 }), this.fire(new F("data", G$1(F$1({}, o4), { sourceDataType: "metadata" }))), this.fire(new F("data", G$1(F$1({}, o4), { sourceDataType: "content" })));
    } catch (i) {
      if (this._pendingLoads--, this._removed) {
        this.fire(new F("dataabort", { dataType: "source" }));
        return;
      }
      this.fire(new H$2(i));
    }
  }
  loaded() {
    return this._pendingLoads === 0;
  }
  async loadTile(e) {
    let t = e.actor ? "RT" : "LT";
    e.actor = this.actor;
    let i = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    e.abortController = new AbortController();
    let n4 = await this.actor.sendAsync({ type: t, data: i }, e.abortController);
    delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(n4, this.map.painter, t === "RT");
  }
  async abortTile(e) {
    e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
  }
  async unloadTile(e) {
    e.unloadVectorData(), await this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
  }
  onRemove() {
    this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
  }
  serialize() {
    return V$1({}, this._options, { type: this.type, data: this._data });
  }
  hasTransition() {
    return false;
  }
};
H$3(Td$1, "GeoJSONSource");
var ma$1 = Td$1;
a();
a();
a();
var Or$2 = _e$1([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
var Md$1 = class Md extends de$1 {
  constructor(e, t, i, n4) {
    super(), this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(n4), this.options = t;
  }
  async load(e) {
    this._loaded = false, this.fire(new F("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
    try {
      let t = await st$1.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
      this._request = null, this._loaded = true, t && t.data && (this.image = t.data, e && (this.coordinates = e), this._finishLoading());
    } catch (t) {
      this._request = null, this._loaded = true, this.fire(new H$2(t));
    }
  }
  loaded() {
    return this._loaded;
  }
  updateImage(e) {
    return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
      this.texture = null;
    }), this) : this;
  }
  _finishLoading() {
    this.map && (this.setCoordinates(this.coordinates), this.fire(new F("data", { dataType: "source", sourceDataType: "metadata" })));
  }
  onAdd(e) {
    this.map = e, this.load();
  }
  onRemove() {
    this._request && (this._request.abort(), this._request = null);
  }
  setCoordinates(e) {
    this.coordinates = e;
    let t = e.map(Fe$1.fromLngLat);
    this.tileID = tL$1(t), this.minzoom = this.maxzoom = this.tileID.z;
    let i = t.map((n4) => this.tileID.getTilePoint(n4)._round());
    return this._boundsArray = new nn$1(), this._boundsArray.emplaceBack(i[0].x, i[0].y, 0, 0), this._boundsArray.emplaceBack(i[1].x, i[1].y, 8192, 0), this._boundsArray.emplaceBack(i[3].x, i[3].y, 0, 8192), this._boundsArray.emplaceBack(i[2].x, i[2].y, 8192, 8192), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new F("data", { dataType: "source", sourceDataType: "content" })), this;
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || !this.image) return;
    let e = this.map.painter.context, t = e.gl;
    this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Or$2.members)), this.boundsSegments || (this.boundsSegments = me$1.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new ve$2(e, this.image, t.RGBA), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE));
    let i = false;
    for (let n4 in this.tiles) {
      let o4 = this.tiles[n4];
      o4.state !== "loaded" && (o4.state = "loaded", o4.texture = this.texture, i = true);
    }
    i && this.fire(new F("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  async loadTile(e) {
    this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
  }
  serialize() {
    return { type: "image", url: this.options.url, coordinates: this.coordinates };
  }
  hasTransition() {
    return false;
  }
};
H$3(Md$1, "ImageSource");
var Lt$1 = Md$1;
function tL$1(r5) {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, n4 = -1 / 0;
  for (let p4 of r5) e = Math.min(e, p4.x), t = Math.min(t, p4.y), i = Math.max(i, p4.x), n4 = Math.max(n4, p4.y);
  let o4 = i - e, a4 = n4 - t, s5 = Math.max(o4, a4), u5 = Math.max(0, Math.floor(-Math.log(s5) / Math.LN2)), c = Math.pow(2, u5);
  return new bn$1(u5, Math.floor((e + i) / 2 * c), Math.floor((t + n4) / 2 * c));
}
H$3(tL$1, "getCoordinatesCenterTileID");
var Ad$1 = class Ad extends Lt$1 {
  constructor(e, t, i, n4) {
    super(e, t, i, n4), this.roundZoom = true, this.type = "video", this.options = t;
  }
  async load() {
    this._loaded = false;
    let e = this.options;
    this.urls = [];
    for (let t of e.urls) this.urls.push(this.map._requestManager.transformRequest(t, "Source").url);
    try {
      let t = await hb$1(this.urls);
      if (this._loaded = true, !t) return;
      this.video = t, this.video.loop = true, this.video.addEventListener("playing", () => {
        this.map.triggerRepaint();
      }), this.map && this.video.play(), this._finishLoading();
    } catch (t) {
      this.fire(new H$2(t));
    }
  }
  pause() {
    this.video && this.video.pause();
  }
  play() {
    this.video && this.video.play();
  }
  seek(e) {
    if (this.video) {
      let t = this.video.seekable;
      e < t.start(0) || e > t.end(0) ? this.fire(new H$2(new B$1("sources.".concat(this.id), null, "Playback for this video can be set only between the ".concat(t.start(0), " and ").concat(t.end(0), "-second mark.")))) : this.video.currentTime = e;
    }
  }
  getVideo() {
    return this.video;
  }
  onAdd(e) {
    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
  }
  prepare() {
    if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
    let e = this.map.painter.context, t = e.gl;
    this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Or$2.members)), this.boundsSegments || (this.boundsSegments = me$1.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new ve$2(e, this.video, t.RGBA), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE));
    let i = false;
    for (let n4 in this.tiles) {
      let o4 = this.tiles[n4];
      o4.state !== "loaded" && (o4.state = "loaded", o4.texture = this.texture, i = true);
    }
    i && this.fire(new F("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "video", urls: this.urls, coordinates: this.coordinates };
  }
  hasTransition() {
    return this.video && !this.video.paused;
  }
};
H$3(Ad$1, "VideoSource");
var da$1 = Ad$1;
a();
var Id$1 = class Id extends Lt$1 {
  constructor(e, t, i, n4) {
    super(e, t, i, n4), t.coordinates ? (!Array.isArray(t.coordinates) || t.coordinates.length !== 4 || t.coordinates.some((o4) => !Array.isArray(o4) || o4.length !== 2 || o4.some((a4) => typeof a4 != "number"))) && this.fire(new H$2(new B$1("sources.".concat(e), null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new H$2(new B$1("sources.".concat(e), null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != "boolean" && this.fire(new H$2(new B$1("sources.".concat(e), null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas != "string" && !(t.canvas instanceof HTMLCanvasElement) && this.fire(new H$2(new B$1("sources.".concat(e), null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new H$2(new B$1("sources.".concat(e), null, 'missing required property "canvas"'))), this.options = t, this.animate = t.animate !== void 0 ? t.animate : true;
  }
  async load() {
    if (this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions()) {
      this.fire(new H$2(new Error("Canvas dimensions cannot be less than or equal to zero.")));
      return;
    }
    this.play = function() {
      this._playing = true, this.map.triggerRepaint();
    }, this.pause = function() {
      this._playing && (this.prepare(), this._playing = false);
    }, this._finishLoading();
  }
  getCanvas() {
    return this.canvas;
  }
  onAdd(e) {
    this.map = e, this.load(), this.canvas && this.animate && this.play();
  }
  onRemove() {
    this.pause();
  }
  prepare() {
    let e = false;
    if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
    let t = this.map.painter.context, i = t.gl;
    this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, Or$2.members)), this.boundsSegments || (this.boundsSegments = me$1.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new ve$2(t, this.canvas, i.RGBA, { premultiply: true });
    let n4 = false;
    for (let o4 in this.tiles) {
      let a4 = this.tiles[o4];
      a4.state !== "loaded" && (a4.state = "loaded", a4.texture = this.texture, n4 = true);
    }
    n4 && this.fire(new F("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
  }
  serialize() {
    return { type: "canvas", coordinates: this.coordinates };
  }
  hasTransition() {
    return this._playing;
  }
  _hasInvalidDimensions() {
    for (let e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
    return false;
  }
};
H$3(Id$1, "CanvasSource");
var ya$1 = Id$1;
var a1$1 = {}, s1$1 = H$3((r5, e, t, i) => {
  let n4 = l1$1(e.type), o4 = new n4(r5, e, t, i);
  if (o4.id !== r5) throw new Error("Expected Source id to be ".concat(r5, " instead of ").concat(o4.id));
  return o4;
}, "create"), l1$1 = H$3((r5) => {
  switch (r5) {
    case "geojson":
      return ma$1;
    case "image":
      return Lt$1;
    case "raster":
      return vi;
    case "raster-dem":
      return fa$1;
    case "vector":
      return pa$1;
    case "video":
      return da$1;
    case "canvas":
      return ya$1;
  }
  return a1$1[r5];
}, "getSourceType"), rL$1 = H$3((r5, e) => {
  a1$1[r5] = e;
}, "setSourceType");
H$3(async (r5, e) => {
  if (l1$1(r5)) throw new Error('A source type called "'.concat(r5, '" already exists.'));
  rL$1(r5, e);
}, "addSourceType");
a();
a();
function u1$1(r5, e) {
  let t = {};
  if (!e) return t;
  for (let i of r5) {
    let n4 = i.layerIds.map((o4) => e.getLayer(o4)).filter(Boolean);
    if (n4.length !== 0) {
      i.layers = n4, i.stateDependentLayerIds && (i.stateDependentLayers = i.stateDependentLayerIds.map((o4) => n4.filter((a4) => a4.id === o4)[0]));
      for (let o4 of n4) t[o4.id] = i;
    }
  }
  return t;
}
H$3(u1$1, "deserialize");
a();
a();
var Cd$1 = class Cd {
  constructor(e) {
    this._stringToNumber = {}, this._numberToString = [];
    for (let t = 0; t < e.length; t++) {
      let i = e[t];
      this._stringToNumber[i] = t, this._numberToString[t] = i;
    }
  }
  encode(e) {
    return this._stringToNumber[e];
  }
  decode(e) {
    if (e >= this._numberToString.length) throw new Error("Out of bounds. Index requested n=".concat(e, " can't be >= this._numberToString.length ").concat(this._numberToString.length));
    return this._numberToString[e];
  }
};
H$3(Cd$1, "DictionaryCoder");
var _u$1 = Cd$1;
var h1$1 = N$2(Wo$1(), 1), f1$1 = N$2($m(), 1);
a();
var Ed$1 = class Ed {
  constructor(e, t, i, n4, o4) {
    this.type = "Feature", this._vectorTileFeature = e, e._z = t, e._x = i, e._y = n4, this.properties = e.properties, this.id = o4;
  }
  get geometry() {
    return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
  }
  set geometry(e) {
    this._geometry = e;
  }
  toJSON() {
    let e = { geometry: this.geometry };
    for (let t in this) t === "_geometry" || t === "_vectorTileFeature" || (e[t] = this[t]);
    return e;
  }
};
H$3(Ed$1, "GeoJSONFeature");
var vn = Ed$1;
var Ld$1 = class Ld {
  constructor(e, t) {
    this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new oi(8192, 16, 0), this.grid3D = new oi(8192, 16, 0), this.featureIndexArray = new Do$1(), this.promoteId = t;
  }
  insert(e, t, i, n4, o4, a4) {
    let s5 = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(i, n4, o4);
    let u5 = a4 ? this.grid3D : this.grid;
    for (let c = 0; c < t.length; c++) {
      let p4 = t[c], h = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let f = 0; f < p4.length; f++) {
        let m5 = p4[f];
        h[0] = Math.min(h[0], m5.x), h[1] = Math.min(h[1], m5.y), h[2] = Math.max(h[2], m5.x), h[3] = Math.max(h[3], m5.y);
      }
      h[0] < 8192 && h[1] < 8192 && h[2] >= 0 && h[3] >= 0 && u5.insert(s5, h[0], h[1], h[2], h[3]);
    }
  }
  loadVTLayers() {
    return this.vtLayers || (this.vtLayers = new h1$1.default.VectorTile(new f1$1.default(this.rawTileData)).layers, this.sourceLayerCoder = new _u$1(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
  }
  query(e, t, i, n4) {
    this.loadVTLayers();
    let o4 = e.params || {}, a4 = 8192 / e.tileSize / e.scale, s5 = so(o4.filter), u5 = e.queryGeometry, c = e.queryPadding * a4, p4 = p1$1(u5), h = this.grid.query(p4.minX - c, p4.minY - c, p4.maxX + c, p4.maxY + c), f = p1$1(e.cameraQueryGeometry), m5 = this.grid3D.query(f.minX - c, f.minY - c, f.maxX + c, f.maxY + c, (x2, b, w3, _) => Z_$1(e.cameraQueryGeometry, x2 - c, b - c, w3 + c, _ + c));
    for (let x2 of m5) h.push(x2);
    h.sort(nL$1);
    let y4 = {}, g;
    for (let x2 = 0; x2 < h.length; x2++) {
      let b = h[x2];
      if (b === g) continue;
      g = b;
      let w3 = this.featureIndexArray.get(b), _ = null;
      this.loadMatchingFeature(y4, w3.bucketIndex, w3.sourceLayerIndex, w3.featureIndex, s5, o4.layers, o4.availableImages, t, i, n4, (S4, P4, T3) => (_ || (_ = dt$1(S4)), P4.queryIntersectsFeature(u5, S4, T3, _, this.z, e.transform, a4, e.pixelPosMatrix)));
    }
    return y4;
  }
  loadMatchingFeature(e, t, i, n4, o4, a4, s5, u5, c, p4, h) {
    let f = this.bucketLayerIDs[t];
    if (a4 && !eb$1(a4, f)) return;
    let m5 = this.sourceLayerCoder.decode(i), g = this.vtLayers[m5].feature(n4);
    if (o4.needGeometry) {
      let b = yt$1(g, true);
      if (!o4.filter(new ye(this.tileID.overscaledZ), b, this.tileID.canonical)) return;
    } else if (!o4.filter(new ye(this.tileID.overscaledZ), g)) return;
    let x2 = this.getId(g, m5);
    for (let b = 0; b < f.length; b++) {
      let w3 = f[b];
      if (a4 && a4.indexOf(w3) < 0) continue;
      let _ = u5[w3];
      if (!_) continue;
      let S4 = {};
      x2 && p4 && (S4 = p4.getState(_.sourceLayer || "_geojsonTileLayer", x2));
      let P4 = V$1({}, c[w3]);
      P4.paint = c1$1(P4.paint, _.paint, g, S4, s5), P4.layout = c1$1(P4.layout, _.layout, g, S4, s5);
      let T3 = !h || h(g, _, S4);
      if (!T3) continue;
      let L3 = new vn(g, this.z, this.x, this.y, x2);
      L3.layer = P4;
      let C3 = e[w3];
      C3 === void 0 && (C3 = e[w3] = []), C3.push({ featureIndex: n4, feature: L3, intersectionZ: T3 });
    }
  }
  lookupSymbolFeatures(e, t, i, n4, o4, a4, s5, u5) {
    let c = {};
    this.loadVTLayers();
    let p4 = so(o4);
    for (let h of e) this.loadMatchingFeature(c, i, n4, h, p4, a4, s5, u5, t);
    return c;
  }
  hasLayer(e) {
    for (let t of this.bucketLayerIDs) for (let i of t) if (e === i) return true;
    return false;
  }
  getId(e, t) {
    let i = e.id;
    if (this.promoteId) {
      let n4 = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[t];
      i = e.properties[n4], typeof i == "boolean" && (i = Number(i));
    }
    return i;
  }
};
H$3(Ld$1, "FeatureIndex");
var kd$1 = Ld$1;
N$1("FeatureIndex", kd$1, { omit: ["rawTileData", "sourceLayerCoder"] });
function c1$1(r5, e, t, i, n4) {
  return Dn(r5, (o4, a4) => {
    let s5 = e instanceof Pr$2 ? e.get(a4) : null;
    return s5 && s5.evaluate ? s5.evaluate(t, i, n4) : s5;
  });
}
H$3(c1$1, "evaluateProperties");
function p1$1(r5) {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, n4 = -1 / 0;
  for (let o4 of r5) e = Math.min(e, o4.x), t = Math.min(t, o4.y), i = Math.max(i, o4.x), n4 = Math.max(n4, o4.y);
  return { minX: e, minY: t, maxX: i, maxY: n4 };
}
H$3(p1$1, "getBounds");
function nL$1(r5, e) {
  return e - r5;
}
H$3(nL$1, "topDownFeatureComparator");
a();
a();
var ga$1 = "RTLPluginLoaded";
var Fd$1 = class Fd extends de$1 {
  constructor() {
    super(...arguments);
    this.status = "unavailable";
    this.url = null;
    this.dispatcher = yu();
  }
  _syncState(t) {
    return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch((i) => {
      throw this.status = "error", i;
    });
  }
  getRTLTextPluginStatus() {
    return this.status;
  }
  clearRTLTextPlugin() {
    this.status = "unavailable", this.url = null;
  }
  async setRTLTextPlugin(t, i = false) {
    if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
    if (this.url = Y$1.resolveURL(t), !this.url) throw new Error("requested url ".concat(t, " is invalid"));
    if (this.status === "unavailable") if (i) this.status = "deferred", this._syncState(this.status);
    else return this._requestImport();
    else if (this.status === "requested") return this._requestImport();
  }
  async _requestImport() {
    await this._syncState("loading"), this.status = "loaded", this.fire(new F(ga$1));
  }
  lazyLoad() {
    this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
  }
};
H$3(Fd$1, "RTLMainThreadPlugin");
var zd = Fd$1, Dd$1 = null;
function Vr$1() {
  return Dd$1 || (Dd$1 = new zd()), Dd$1;
}
H$3(Vr$1, "rtlMainThreadPluginFactory");
var oL$1 = 3e4, Rd$1 = class Rd {
  constructor(e, t) {
    this.timeAdded = 0;
    this.fadeEndTime = 0;
    this.tileID = e, this.uid = ns(), this.uses = 0, this.tileSize = t, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
  }
  registerFadeDuration(e) {
    let t = e + this.timeAdded;
    t < this.fadeEndTime || (this.fadeEndTime = t);
  }
  wasRequested() {
    return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
  }
  clearTextures(e) {
    this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
  }
  loadVectorData(e, t, i) {
    if (this.hasData() && this.unloadVectorData(), this.state = "loaded", !e) {
      this.collisionBoxArray = new Ao$1();
      return;
    }
    e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = u1$1(e.buckets, t.style), this.hasSymbolBuckets = false;
    for (let n4 in this.buckets) {
      let o4 = this.buckets[n4];
      if (o4 instanceof Ot$1) if (this.hasSymbolBuckets = true, i) o4.justReloaded = true;
      else break;
    }
    if (this.hasRTLText = false, this.hasSymbolBuckets) for (let n4 in this.buckets) {
      let o4 = this.buckets[n4];
      if (o4 instanceof Ot$1 && o4.hasRTLText) {
        this.hasRTLText = true, Vr$1().lazyLoad();
        break;
      }
    }
    this.queryPadding = 0;
    for (let n4 in this.buckets) {
      let o4 = this.buckets[n4];
      this.queryPadding = Math.max(this.queryPadding, t.style.getLayer(n4).queryRadius(o4));
    }
    e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
  }
  unloadVectorData() {
    for (let e in this.buckets) this.buckets[e].destroy();
    this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
  }
  getBucket(e) {
    return this.buckets[e.id];
  }
  upload(e) {
    for (let i in this.buckets) {
      let n4 = this.buckets[i];
      n4.uploadPending() && n4.upload(e);
    }
    let t = e.gl;
    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new ve$2(e, this.imageAtlas.image, t.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new ve$2(e, this.glyphAtlasImage, t.ALPHA), this.glyphAtlasImage = null);
  }
  prepare(e) {
    this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
  }
  queryRenderedFeatures(e, t, i, n4, o4, a4, s5, u5, c, p4) {
    return !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData ? {} : this.latestFeatureIndex.query({ queryGeometry: n4, cameraQueryGeometry: o4, scale: a4, tileSize: this.tileSize, pixelPosMatrix: p4, transform: u5, params: s5, queryPadding: this.queryPadding * c }, e, t, i);
  }
  querySourceFeatures(e, t) {
    let i = this.latestFeatureIndex;
    if (!i || !i.rawTileData) return;
    let n4 = i.loadVTLayers(), o4 = t && t.sourceLayer ? t.sourceLayer : "", a4 = n4._geojsonTileLayer || n4[o4];
    if (!a4) return;
    let s5 = so(t && t.filter), { z: u5, x: c, y: p4 } = this.tileID.canonical, h = { z: u5, x: c, y: p4 };
    for (let f = 0; f < a4.length; f++) {
      let m5 = a4.feature(f);
      if (s5.needGeometry) {
        let x2 = yt$1(m5, true);
        if (!s5.filter(new ye(this.tileID.overscaledZ), x2, this.tileID.canonical)) continue;
      } else if (!s5.filter(new ye(this.tileID.overscaledZ), m5)) continue;
      let y4 = i.getId(m5, o4), g = new vn(m5, u5, c, p4, y4);
      g.tile = h, e.push(g);
    }
  }
  hasData() {
    return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
  }
  patternsLoaded() {
    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
  }
  setExpiryData(e) {
    let t = this.expirationTime;
    if (e.cacheControl) {
      let i = nb$1(e.cacheControl);
      i["max-age"] && (this.expirationTime = Date.now() + i["max-age"] * 1e3);
    } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
    if (this.expirationTime) {
      let i = Date.now(), n4 = false;
      if (this.expirationTime > i) n4 = false;
      else if (!t) n4 = true;
      else if (this.expirationTime < t) n4 = true;
      else {
        let o4 = this.expirationTime - t;
        o4 ? this.expirationTime = i + Math.max(o4, oL$1) : n4 = true;
      }
      n4 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
    }
  }
  getExpiryTimeout() {
    if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
  }
  setFeatureState(e, t) {
    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
    let i = this.latestFeatureIndex.loadVTLayers();
    for (let n4 in this.buckets) {
      if (!t.style.hasLayer(n4)) continue;
      let o4 = this.buckets[n4], a4 = o4.layers[0].sourceLayer || "_geojsonTileLayer", s5 = i[a4], u5 = e[a4];
      if (!s5 || !u5 || Object.keys(u5).length === 0) continue;
      o4.update(u5, s5, this.imageAtlas && this.imageAtlas.patternPositions || {});
      let c = t && t.style && t.style.getLayer(n4);
      c && (this.queryPadding = Math.max(this.queryPadding, c.queryRadius(o4)));
    }
  }
  holdingForFade() {
    return this.symbolFadeHoldUntil !== void 0;
  }
  symbolFadeFinished() {
    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Y$1.now();
  }
  clearFadeHold() {
    this.symbolFadeHoldUntil = void 0;
  }
  setHoldDuration(e) {
    this.symbolFadeHoldUntil = Y$1.now() + e;
  }
  setDependencies(e, t) {
    let i = {};
    for (let n4 of t) i[n4] = true;
    this.dependencies[e] = i;
  }
  hasDependency(e, t) {
    for (let i of e) {
      let n4 = this.dependencies[i];
      if (n4) {
        for (let o4 of t) if (n4[o4]) return true;
      }
    }
    return false;
  }
};
H$3(Rd$1, "Tile");
var wn$2 = Rd$1;
a();
var Bd$1 = class Bd {
  constructor(e, t) {
    this.max = e, this.onRemove = t, this.reset();
  }
  reset() {
    for (let e in this.data) for (let t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);
    return this.data = {}, this.order = [], this;
  }
  add(e, t, i) {
    let n4 = e.wrapped().key;
    this.data[n4] === void 0 && (this.data[n4] = []);
    let o4 = { value: t, timeout: void 0 };
    if (i !== void 0 && (o4.timeout = setTimeout(() => {
      this.remove(e, o4);
    }, i)), this.data[n4].push(o4), this.order.push(n4), this.order.length > this.max) {
      let a4 = this._getAndRemoveByKey(this.order[0]);
      a4 && this.onRemove(a4);
    }
    return this;
  }
  has(e) {
    return e.wrapped().key in this.data;
  }
  getAndRemove(e) {
    return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
  }
  _getAndRemoveByKey(e) {
    let t = this.data[e].shift();
    return t.timeout && clearTimeout(t.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value;
  }
  getByKey(e) {
    let t = this.data[e];
    return t ? t[0].value : null;
  }
  get(e) {
    return this.has(e) ? this.data[e.wrapped().key][0].value : null;
  }
  remove(e, t) {
    if (!this.has(e)) return this;
    let i = e.wrapped().key, n4 = t === void 0 ? 0 : this.data[i].indexOf(t), o4 = this.data[i][n4];
    return this.data[i].splice(n4, 1), o4.timeout && clearTimeout(o4.timeout), this.data[i].length === 0 && delete this.data[i], this.onRemove(o4.value), this.order.splice(this.order.indexOf(i), 1), this;
  }
  setMaxSize(e) {
    for (this.max = e; this.order.length > this.max; ) {
      let t = this._getAndRemoveByKey(this.order[0]);
      t && this.onRemove(t);
    }
    return this;
  }
  filter(e) {
    let t = [];
    for (let i in this.data) for (let n4 of this.data[i]) e(n4.value) || t.push(n4);
    for (let i of t) this.remove(i.value.tileID, i);
  }
};
H$3(Bd$1, "TileCache");
var vu$1 = Bd$1;
var Vd$1 = N$2(ge(), 1);
a();
var Od$1 = class Od {
  constructor() {
    this.state = {}, this.stateChanges = {}, this.deletedStates = {};
  }
  updateState(e, t, i) {
    let n4 = String(t);
    if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][n4] = this.stateChanges[e][n4] || {}, V$1(this.stateChanges[e][n4], i), this.deletedStates[e] === null) {
      this.deletedStates[e] = {};
      for (let o4 in this.state[e]) o4 !== n4 && (this.deletedStates[e][o4] = null);
    } else if (this.deletedStates[e] && this.deletedStates[e][n4] === null) {
      this.deletedStates[e][n4] = {};
      for (let a4 in this.state[e][n4]) i[a4] || (this.deletedStates[e][n4][a4] = null);
    } else for (let a4 in i) this.deletedStates[e] && this.deletedStates[e][n4] && this.deletedStates[e][n4][a4] === null && delete this.deletedStates[e][n4][a4];
  }
  removeFeatureState(e, t, i) {
    if (this.deletedStates[e] === null) return;
    let o4 = String(t);
    if (this.deletedStates[e] = this.deletedStates[e] || {}, i && t !== void 0) this.deletedStates[e][o4] !== null && (this.deletedStates[e][o4] = this.deletedStates[e][o4] || {}, this.deletedStates[e][o4][i] = null);
    else if (t !== void 0) if (this.stateChanges[e] && this.stateChanges[e][o4]) {
      this.deletedStates[e][o4] = {};
      for (i in this.stateChanges[e][o4]) this.deletedStates[e][o4][i] = null;
    } else this.deletedStates[e][o4] = null;
    else this.deletedStates[e] = null;
  }
  getState(e, t) {
    let i = String(t), n4 = this.state[e] || {}, o4 = this.stateChanges[e] || {}, a4 = V$1({}, n4[i], o4[i]);
    if (this.deletedStates[e] === null) return {};
    if (this.deletedStates[e]) {
      let s5 = this.deletedStates[e][t];
      if (s5 === null) return {};
      for (let u5 in s5) delete a4[u5];
    }
    return a4;
  }
  initializeTileState(e, t) {
    e.setFeatureState(this.state, t);
  }
  coalesceChanges(e, t) {
    let i = {};
    for (let n4 in this.stateChanges) {
      this.state[n4] = this.state[n4] || {};
      let o4 = {};
      for (let a4 in this.stateChanges[n4]) this.state[n4][a4] || (this.state[n4][a4] = {}), V$1(this.state[n4][a4], this.stateChanges[n4][a4]), o4[a4] = this.state[n4][a4];
      i[n4] = o4;
    }
    for (let n4 in this.deletedStates) {
      this.state[n4] = this.state[n4] || {};
      let o4 = {};
      if (this.deletedStates[n4] === null) for (let a4 in this.state[n4]) o4[a4] = {}, this.state[n4][a4] = {};
      else for (let a4 in this.deletedStates[n4]) {
        if (this.deletedStates[n4][a4] === null) this.state[n4][a4] = {};
        else for (let u5 of Object.keys(this.deletedStates[n4][a4])) delete this.state[n4][a4][u5];
        o4[a4] = this.state[n4][a4];
      }
      i[n4] = i[n4] || {}, V$1(i[n4], o4);
    }
    if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(i).length !== 0) for (let n4 in e) e[n4].setFeatureState(i, t);
  }
};
H$3(Od$1, "SourceFeatureState");
var wu$1 = Od$1;
var wi$1 = class wi extends de$1 {
  constructor(e, t, i) {
    super(), this.id = e, this.dispatcher = i, this.on("data", (n4) => this._dataHandler(n4)), this.on("dataloading", () => {
      this._sourceErrored = false;
    }), this.on("error", () => {
      this._sourceErrored = this._source.loaded();
    }), this._source = s1$1(e, t, i, this), this._tiles = {}, this._cache = new vu$1(0, (n4) => this._unloadTile(n4)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new wu$1(), this._didEmitContent = false, this._updated = false;
  }
  onAdd(e) {
    this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
  }
  onRemove(e) {
    this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
  }
  loaded() {
    if (this._sourceErrored) return true;
    if (!this._sourceLoaded || !this._source.loaded()) return false;
    if ((this.used !== void 0 || this.usedForTerrain !== void 0) && !this.used && !this.usedForTerrain) return true;
    if (!this._updated) return false;
    for (let e in this._tiles) {
      let t = this._tiles[e];
      if (t.state !== "loaded" && t.state !== "errored") return false;
    }
    return true;
  }
  getSource() {
    return this._source;
  }
  pause() {
    this._paused = true;
  }
  resume() {
    if (!this._paused) return;
    let e = this._shouldReloadOnResume;
    this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
  }
  async _loadTile(e, t, i) {
    try {
      await this._source.loadTile(e), this._tileLoaded(e, t, i);
    } catch (n4) {
      e.state = "errored", n4.status !== 404 ? this._source.fire(new H$2(n4, { tile: e })) : this.update(this.transform, this.terrain);
    }
  }
  _unloadTile(e) {
    this._source.unloadTile && this._source.unloadTile(e);
  }
  _abortTile(e) {
    this._source.abortTile && this._source.abortTile(e), this._source.fire(new F("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
  }
  serialize() {
    return this._source.serialize();
  }
  prepare(e) {
    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
    for (let t in this._tiles) {
      let i = this._tiles[t];
      i.upload(e), i.prepare(this.map.style.imageManager);
    }
  }
  getIds() {
    return Object.values(this._tiles).map((e) => e.tileID).sort(m1$1).map((e) => e.key);
  }
  getRenderableIds(e) {
    let t = [];
    for (let i in this._tiles) this._isIdRenderable(i, e) && t.push(this._tiles[i]);
    return e ? t.sort((i, n4) => {
      let o4 = i.tileID, a4 = n4.tileID, s5 = new Vd$1.default(o4.canonical.x, o4.canonical.y)._rotate(this.transform.angle), u5 = new Vd$1.default(a4.canonical.x, a4.canonical.y)._rotate(this.transform.angle);
      return o4.overscaledZ - a4.overscaledZ || u5.y - s5.y || u5.x - s5.x;
    }).map((i) => i.tileID.key) : t.map((i) => i.tileID).sort(m1$1).map((i) => i.key);
  }
  hasRenderableParent(e) {
    let t = this.findLoadedParent(e, 0);
    return t ? this._isIdRenderable(t.tileID.key) : false;
  }
  _isIdRenderable(e, t) {
    return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade());
  }
  reload() {
    if (this._paused) {
      this._shouldReloadOnResume = true;
      return;
    }
    this._cache.reset();
    for (let e in this._tiles) this._tiles[e].state !== "errored" && this._reloadTile(e, "reloading");
  }
  async _reloadTile(e, t) {
    let i = this._tiles[e];
    i && (i.state !== "loading" && (i.state = t), await this._loadTile(i, e, t));
  }
  _tileLoaded(e, t, i) {
    e.timeAdded = Y$1.now(), i === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(t, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new F("data", { dataType: "source", tile: e, coord: e.tileID }));
  }
  _backfillDEM(e) {
    let t = this.getRenderableIds();
    for (let n4 = 0; n4 < t.length; n4++) {
      let o4 = t[n4];
      if (e.neighboringTiles && e.neighboringTiles[o4]) {
        let a4 = this.getTileByID(o4);
        i(e, a4), i(a4, e);
      }
    }
    function i(n4, o4) {
      n4.needsHillshadePrepare = true, n4.needsTerrainPrepare = true;
      let a4 = o4.tileID.canonical.x - n4.tileID.canonical.x, s5 = o4.tileID.canonical.y - n4.tileID.canonical.y, u5 = Math.pow(2, n4.tileID.canonical.z), c = o4.tileID.key;
      a4 === 0 && s5 === 0 || Math.abs(s5) > 1 || (Math.abs(a4) > 1 && (Math.abs(a4 + u5) === 1 ? a4 += u5 : Math.abs(a4 - u5) === 1 && (a4 -= u5)), !(!o4.dem || !n4.dem) && (n4.dem.backfillBorder(o4.dem, a4, s5), n4.neighboringTiles && n4.neighboringTiles[c] && (n4.neighboringTiles[c].backfilled = true)));
    }
    H$3(i, "fillBorder");
  }
  getTile(e) {
    return this.getTileByID(e.key);
  }
  getTileByID(e) {
    return this._tiles[e];
  }
  _retainLoadedChildren(e, t, i, n4) {
    for (let o4 in this._tiles) {
      let a4 = this._tiles[o4];
      if (n4[o4] || !a4.hasData() || a4.tileID.overscaledZ <= t || a4.tileID.overscaledZ > i) continue;
      let s5 = a4.tileID;
      for (; a4 && a4.tileID.overscaledZ > t + 1; ) {
        let c = a4.tileID.scaledTo(a4.tileID.overscaledZ - 1);
        a4 = this._tiles[c.key], a4 && a4.hasData() && (s5 = c);
      }
      let u5 = s5;
      for (; u5.overscaledZ > t; ) if (u5 = u5.scaledTo(u5.overscaledZ - 1), e[u5.key]) {
        n4[s5.key] = s5;
        break;
      }
    }
  }
  findLoadedParent(e, t) {
    if (e.key in this._loadedParentTiles) {
      let i = this._loadedParentTiles[e.key];
      return i && i.tileID.overscaledZ >= t ? i : null;
    }
    for (let i = e.overscaledZ - 1; i >= t; i--) {
      let n4 = e.scaledTo(i), o4 = this._getLoadedTile(n4);
      if (o4) return o4;
    }
  }
  _getLoadedTile(e) {
    let t = this._tiles[e.key];
    return t && t.hasData() ? t : this._cache.getByKey(e.wrapped().key);
  }
  updateCacheSize(e) {
    let t = Math.ceil(e.width / this._source.tileSize) + 1, i = Math.ceil(e.height / this._source.tileSize) + 1, n4 = t * i, o4 = this._maxTileCacheZoomLevels === null ? Ke.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels, a4 = Math.floor(n4 * o4), s5 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, a4) : a4;
    this._cache.setMaxSize(s5);
  }
  handleWrapJump(e) {
    let t = this._prevLng === void 0 ? e : this._prevLng, n4 = (e - t) / 360, o4 = Math.round(n4);
    if (this._prevLng = e, o4) {
      let a4 = {};
      for (let s5 in this._tiles) {
        let u5 = this._tiles[s5];
        u5.tileID = u5.tileID.unwrapTo(u5.tileID.wrap + o4), a4[u5.tileID.key] = u5;
      }
      this._tiles = a4;
      for (let s5 in this._timers) clearTimeout(this._timers[s5]), delete this._timers[s5];
      for (let s5 in this._tiles) {
        let u5 = this._tiles[s5];
        this._setTileReloadTimer(s5, u5);
      }
    }
  }
  update(e, t) {
    if (!this._sourceLoaded || this._paused) return;
    this.transform = e, this.terrain = t, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {};
    let i;
    !this.used && !this.usedForTerrain ? i = [] : this._source.tileID ? i = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((p4) => new Je(p4.canonical.z, p4.wrap, p4.canonical.z, p4.canonical.x, p4.canonical.y)) : (i = e.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this.usedForTerrain ? false : this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: t }), this._source.hasTile && (i = i.filter((p4) => this._source.hasTile(p4))));
    let n4 = e.coveringZoomLevel(this._source), o4 = Math.max(n4 - wi.maxOverzooming, this._source.minzoom), a4 = Math.max(n4 + wi.maxUnderzooming, this._source.minzoom);
    if (this.usedForTerrain) {
      let p4 = {};
      for (let h of i) if (h.canonical.z > this._source.minzoom) {
        let f = h.scaledTo(h.canonical.z - 1);
        p4[f.key] = f;
        let m5 = h.scaledTo(Math.max(this._source.minzoom, Math.min(h.canonical.z, 5)));
        p4[m5.key] = m5;
      }
      i = i.concat(Object.values(p4));
    }
    let s5 = i.length === 0 && !this._updated && this._didEmitContent;
    this._updated = true, s5 && this.fire(new F("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
    let u5 = this._updateRetainedTiles(i, n4);
    if (d1$1(this._source.type)) {
      let p4 = {}, h = {}, f = Object.keys(u5), m5 = Y$1.now();
      for (let y4 of f) {
        let g = u5[y4], x2 = this._tiles[y4];
        if (!x2 || x2.fadeEndTime !== 0 && x2.fadeEndTime <= m5) continue;
        let b = this.findLoadedParent(g, o4);
        b && (this._addTile(b.tileID), p4[b.tileID.key] = b.tileID), h[y4] = g;
      }
      this._retainLoadedChildren(h, n4, a4, u5);
      for (let y4 in p4) u5[y4] || (this._coveredTiles[y4] = true, u5[y4] = p4[y4]);
      if (t) {
        let y4 = {}, g = {};
        for (let x2 of i) this._tiles[x2.key].hasData() ? y4[x2.key] = x2 : g[x2.key] = x2;
        for (let x2 in g) {
          let b = g[x2].children(this._source.maxzoom);
          this._tiles[b[0].key] && this._tiles[b[1].key] && this._tiles[b[2].key] && this._tiles[b[3].key] && (y4[b[0].key] = u5[b[0].key] = b[0], y4[b[1].key] = u5[b[1].key] = b[1], y4[b[2].key] = u5[b[2].key] = b[2], y4[b[3].key] = u5[b[3].key] = b[3], delete g[x2]);
        }
        for (let x2 in g) {
          let b = this.findLoadedParent(g[x2], this._source.minzoom);
          if (b) {
            y4[b.tileID.key] = u5[b.tileID.key] = b.tileID;
            for (let w3 in y4) y4[w3].isChildOf(b.tileID) && delete y4[w3];
          }
        }
        for (let x2 in this._tiles) y4[x2] || (this._coveredTiles[x2] = true);
      }
    }
    for (let p4 in u5) this._tiles[p4].clearFadeHold();
    let c = Jx$1(this._tiles, u5);
    for (let p4 of c) {
      let h = this._tiles[p4];
      h.hasSymbolBuckets && !h.holdingForFade() ? h.setHoldDuration(this.map._fadeDuration) : (!h.hasSymbolBuckets || h.symbolFadeFinished()) && this._removeTile(p4);
    }
    this._updateLoadedParentTileCache();
  }
  releaseSymbolFadeTiles() {
    for (let e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
  }
  _updateRetainedTiles(e, t) {
    let i = {}, n4 = {}, o4 = Math.max(t - wi.maxOverzooming, this._source.minzoom), a4 = Math.max(t + wi.maxUnderzooming, this._source.minzoom), s5 = {};
    for (let u5 of e) {
      let c = this._addTile(u5);
      i[u5.key] = u5, !c.hasData() && t < this._source.maxzoom && (s5[u5.key] = u5);
    }
    this._retainLoadedChildren(s5, t, a4, i);
    for (let u5 of e) {
      let c = this._tiles[u5.key];
      if (c.hasData()) continue;
      if (t + 1 > this._source.maxzoom) {
        let h = u5.children(this._source.maxzoom)[0], f = this.getTile(h);
        if (f && f.hasData()) {
          i[h.key] = h;
          continue;
        }
      } else {
        let h = u5.children(this._source.maxzoom);
        if (i[h[0].key] && i[h[1].key] && i[h[2].key] && i[h[3].key]) continue;
      }
      let p4 = c.wasRequested();
      for (let h = u5.overscaledZ - 1; h >= o4; --h) {
        let f = u5.scaledTo(h);
        if (n4[f.key]) break;
        if (n4[f.key] = true, c = this.getTile(f), !c && p4 && (c = this._addTile(f)), c) {
          let m5 = c.hasData();
          if ((p4 || m5) && (i[f.key] = f), p4 = c.wasRequested(), m5) break;
        }
      }
    }
    return i;
  }
  _updateLoadedParentTileCache() {
    this._loadedParentTiles = {};
    for (let e in this._tiles) {
      let t = [], i, n4 = this._tiles[e].tileID;
      for (; n4.overscaledZ > 0; ) {
        if (n4.key in this._loadedParentTiles) {
          i = this._loadedParentTiles[n4.key];
          break;
        }
        t.push(n4.key);
        let o4 = n4.scaledTo(n4.overscaledZ - 1);
        if (i = this._getLoadedTile(o4), i) break;
        n4 = o4;
      }
      for (let o4 of t) this._loadedParentTiles[o4] = i;
    }
  }
  _addTile(e) {
    let t = this._tiles[e.key];
    if (t) return t;
    t = this._cache.getAndRemove(e), t && (this._setTileReloadTimer(e.key, t), t.tileID = e, this._state.initializeTileState(t, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, t)));
    let i = t;
    return t || (t = new wn$2(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(t, e.key, t.state)), t.uses++, this._tiles[e.key] = t, i || this._source.fire(new F("dataloading", { tile: t, coord: t.tileID, dataType: "source" })), t;
  }
  _setTileReloadTimer(e, t) {
    e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
    let i = t.getExpiryTimeout();
    i && (this._timers[e] = setTimeout(() => {
      this._reloadTile(e, "expired"), delete this._timers[e];
    }, i));
  }
  _removeTile(e) {
    let t = this._tiles[e];
    t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), !(t.uses > 0) && (t.hasData() && t.state !== "reloading" ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = true, this._abortTile(t), this._unloadTile(t))));
  }
  _dataHandler(e) {
    let t = e.sourceDataType;
    e.dataType === "source" && t === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && t === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
  }
  clearTiles() {
    this._shouldReloadOnResume = false, this._paused = false;
    for (let e in this._tiles) this._removeTile(e);
    this._cache.reset();
  }
  tilesIn(e, t, i) {
    let n4 = [], o4 = this.transform;
    if (!o4) return n4;
    let a4 = i ? o4.getCameraQueryGeometry(e) : e, s5 = e.map((y4) => o4.pointCoordinate(y4, this.terrain)), u5 = a4.map((y4) => o4.pointCoordinate(y4, this.terrain)), c = this.getIds(), p4 = 1 / 0, h = 1 / 0, f = -1 / 0, m5 = -1 / 0;
    for (let y4 of u5) p4 = Math.min(p4, y4.x), h = Math.min(h, y4.y), f = Math.max(f, y4.x), m5 = Math.max(m5, y4.y);
    for (let y4 = 0; y4 < c.length; y4++) {
      let g = this._tiles[c[y4]];
      if (g.holdingForFade()) continue;
      let x2 = g.tileID, b = Math.pow(2, o4.zoom - g.tileID.overscaledZ), w3 = t * g.queryPadding * 8192 / g.tileSize / b, _ = [x2.getTilePoint(new Fe$1(p4, h)), x2.getTilePoint(new Fe$1(f, m5))];
      if (_[0].x - w3 < 8192 && _[0].y - w3 < 8192 && _[1].x + w3 >= 0 && _[1].y + w3 >= 0) {
        let S4 = s5.map((T3) => x2.getTilePoint(T3)), P4 = u5.map((T3) => x2.getTilePoint(T3));
        n4.push({ tile: g, tileID: x2, queryGeometry: S4, cameraQueryGeometry: P4, scale: b });
      }
    }
    return n4;
  }
  getVisibleCoordinates(e) {
    let t = this.getRenderableIds(e).map((i) => this._tiles[i].tileID);
    for (let i of t) i.posMatrix = this.transform.calculatePosMatrix(i.toUnwrapped());
    return t;
  }
  hasTransition() {
    if (this._source.hasTransition()) return true;
    if (d1$1(this._source.type)) {
      let e = Y$1.now();
      for (let t in this._tiles) if (this._tiles[t].fadeEndTime >= e) return true;
    }
    return false;
  }
  setFeatureState(e, t, i) {
    e = e || "_geojsonTileLayer", this._state.updateState(e, t, i);
  }
  removeFeatureState(e, t, i) {
    e = e || "_geojsonTileLayer", this._state.removeFeatureState(e, t, i);
  }
  getFeatureState(e, t) {
    return e = e || "_geojsonTileLayer", this._state.getState(e, t);
  }
  setDependencies(e, t, i) {
    let n4 = this._tiles[e];
    n4 && n4.setDependencies(t, i);
  }
  reloadTilesForDependencies(e, t) {
    for (let i in this._tiles) this._tiles[i].hasDependency(e, t) && this._reloadTile(i, "reloading");
    this._cache.filter((i) => !i.hasDependency(e, t));
  }
};
H$3(wi$1, "SourceCache");
var cr = wi$1;
cr.maxOverzooming = 10;
cr.maxUnderzooming = 3;
function m1$1(r5, e) {
  let t = Math.abs(r5.wrap * 2) - +(r5.wrap < 0), i = Math.abs(e.wrap * 2) - +(e.wrap < 0);
  return r5.overscaledZ - e.overscaledZ || i - t || e.canonical.y - r5.canonical.y || e.canonical.x - r5.canonical.x;
}
H$3(m1$1, "compareTileId");
function d1$1(r5) {
  return r5 === "raster" || r5 === "image" || r5 === "video";
}
H$3(d1$1, "isRasterType");
a();
a();
a();
var $t$2 = N$2(ge(), 1);
a();
var pr = N$2(ge(), 1);
function Ud$1(r5, e, t, i, n4) {
  let o4 = [];
  for (let a4 = 0; a4 < r5.length; a4++) {
    let s5 = r5[a4], u5;
    for (let c = 0; c < s5.length - 1; c++) {
      let p4 = s5[c], h = s5[c + 1];
      p4.x < e && h.x < e || (p4.x < e ? p4 = new pr.default(e, p4.y + (h.y - p4.y) * ((e - p4.x) / (h.x - p4.x)))._round() : h.x < e && (h = new pr.default(e, p4.y + (h.y - p4.y) * ((e - p4.x) / (h.x - p4.x)))._round()), !(p4.y < t && h.y < t) && (p4.y < t ? p4 = new pr.default(p4.x + (h.x - p4.x) * ((t - p4.y) / (h.y - p4.y)), t)._round() : h.y < t && (h = new pr.default(p4.x + (h.x - p4.x) * ((t - p4.y) / (h.y - p4.y)), t)._round()), !(p4.x >= i && h.x >= i) && (p4.x >= i ? p4 = new pr.default(i, p4.y + (h.y - p4.y) * ((i - p4.x) / (h.x - p4.x)))._round() : h.x >= i && (h = new pr.default(i, p4.y + (h.y - p4.y) * ((i - p4.x) / (h.x - p4.x)))._round()), !(p4.y >= n4 && h.y >= n4) && (p4.y >= n4 ? p4 = new pr.default(p4.x + (h.x - p4.x) * ((n4 - p4.y) / (h.y - p4.y)), n4)._round() : h.y >= n4 && (h = new pr.default(p4.x + (h.x - p4.x) * ((n4 - p4.y) / (h.y - p4.y)), n4)._round()), (!u5 || !p4.equals(u5[u5.length - 1])) && (u5 = [p4], o4.push(u5)), u5.push(h)))));
    }
  }
  return o4;
}
H$3(Ud$1, "clipLine");
a();
var Nd$1 = class Nd {
  constructor(e, t) {
    this.reset(e, t);
  }
  reset(e, t) {
    this.points = e || [], this._distances = [0];
    for (let i = 1; i < this.points.length; i++) this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);
    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, this.length * 0.5), this.paddedLength = this.length - this.padding * 2;
  }
  lerp(e) {
    if (this.points.length === 1) return this.points[0];
    e = Ae$2(e, 0, 1);
    let t = 1, i = this._distances[t], n4 = e * this.paddedLength + this.padding;
    for (; i < n4 && t < this._distances.length; ) i = this._distances[++t];
    let o4 = t - 1, a4 = this._distances[o4], s5 = i - a4, u5 = s5 > 0 ? (n4 - a4) / s5 : 0;
    return this.points[o4].mult(1 - u5).add(this.points[t].mult(u5));
  }
};
H$3(Nd$1, "PathInterpolator");
var Su$1 = Nd$1;
a();
function Pu$1(r5, e) {
  let t = true;
  return r5 === "always" || (r5 === "never" || e === "never") && (t = false), t;
}
H$3(Pu$1, "overlapAllowed");
var Gd$1 = class Gd {
  constructor(e, t, i) {
    let n4 = this.boxCells = [], o4 = this.circleCells = [];
    this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);
    for (let a4 = 0; a4 < this.xCellCount * this.yCellCount; a4++) n4.push([]), o4.push([]);
    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;
  }
  keysLength() {
    return this.boxKeys.length + this.circleKeys.length;
  }
  insert(e, t, i, n4, o4) {
    this._forEachCell(t, i, n4, o4, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(n4), this.bboxes.push(o4);
  }
  insertCircle(e, t, i, n4) {
    this._forEachCell(t - n4, i - n4, t + n4, i + n4, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(n4);
  }
  _insertBoxCell(e, t, i, n4, o4, a4) {
    this.boxCells[o4].push(a4);
  }
  _insertCircleCell(e, t, i, n4, o4, a4) {
    this.circleCells[o4].push(a4);
  }
  _query(e, t, i, n4, o4, a4, s5) {
    if (i < 0 || e > this.width || n4 < 0 || t > this.height) return [];
    let u5 = [];
    if (e <= 0 && t <= 0 && this.width <= i && this.height <= n4) {
      if (o4) return [{ key: null, x1: e, y1: t, x2: i, y2: n4 }];
      for (let c = 0; c < this.boxKeys.length; c++) u5.push({ key: this.boxKeys[c], x1: this.bboxes[c * 4], y1: this.bboxes[c * 4 + 1], x2: this.bboxes[c * 4 + 2], y2: this.bboxes[c * 4 + 3] });
      for (let c = 0; c < this.circleKeys.length; c++) {
        let p4 = this.circles[c * 3], h = this.circles[c * 3 + 1], f = this.circles[c * 3 + 2];
        u5.push({ key: this.circleKeys[c], x1: p4 - f, y1: h - f, x2: p4 + f, y2: h + f });
      }
    } else {
      let c = { hitTest: o4, overlapMode: a4, seenUids: { box: {}, circle: {} } };
      this._forEachCell(e, t, i, n4, this._queryCell, u5, c, s5);
    }
    return u5;
  }
  query(e, t, i, n4) {
    return this._query(e, t, i, n4, false, null);
  }
  hitTest(e, t, i, n4, o4, a4) {
    return this._query(e, t, i, n4, true, o4, a4).length > 0;
  }
  hitTestCircle(e, t, i, n4, o4) {
    let a4 = e - i, s5 = e + i, u5 = t - i, c = t + i;
    if (s5 < 0 || a4 > this.width || c < 0 || u5 > this.height) return false;
    let p4 = [], h = { hitTest: true, overlapMode: n4, circle: { x: e, y: t, radius: i }, seenUids: { box: {}, circle: {} } };
    return this._forEachCell(a4, u5, s5, c, this._queryCellCircle, p4, h, o4), p4.length > 0;
  }
  _queryCell(e, t, i, n4, o4, a4, s5, u5) {
    let { seenUids: c, hitTest: p4, overlapMode: h } = s5, f = this.boxCells[o4];
    if (f !== null) {
      let y4 = this.bboxes;
      for (let g of f) if (!c.box[g]) {
        c.box[g] = true;
        let x2 = g * 4, b = this.boxKeys[g];
        if (e <= y4[x2 + 2] && t <= y4[x2 + 3] && i >= y4[x2 + 0] && n4 >= y4[x2 + 1] && (!u5 || u5(b)) && (!p4 || !Pu$1(h, b.overlapMode)) && (a4.push({ key: b, x1: y4[x2], y1: y4[x2 + 1], x2: y4[x2 + 2], y2: y4[x2 + 3] }), p4)) return true;
      }
    }
    let m5 = this.circleCells[o4];
    if (m5 !== null) {
      let y4 = this.circles;
      for (let g of m5) if (!c.circle[g]) {
        c.circle[g] = true;
        let x2 = g * 3, b = this.circleKeys[g];
        if (this._circleAndRectCollide(y4[x2], y4[x2 + 1], y4[x2 + 2], e, t, i, n4) && (!u5 || u5(b)) && (!p4 || !Pu$1(h, b.overlapMode))) {
          let w3 = y4[x2], _ = y4[x2 + 1], S4 = y4[x2 + 2];
          if (a4.push({ key: b, x1: w3 - S4, y1: _ - S4, x2: w3 + S4, y2: _ + S4 }), p4) return true;
        }
      }
    }
    return false;
  }
  _queryCellCircle(e, t, i, n4, o4, a4, s5, u5) {
    let { circle: c, seenUids: p4, overlapMode: h } = s5, f = this.boxCells[o4];
    if (f !== null) {
      let y4 = this.bboxes;
      for (let g of f) if (!p4.box[g]) {
        p4.box[g] = true;
        let x2 = g * 4, b = this.boxKeys[g];
        if (this._circleAndRectCollide(c.x, c.y, c.radius, y4[x2 + 0], y4[x2 + 1], y4[x2 + 2], y4[x2 + 3]) && (!u5 || u5(b)) && !Pu$1(h, b.overlapMode)) return a4.push(true), true;
      }
    }
    let m5 = this.circleCells[o4];
    if (m5 !== null) {
      let y4 = this.circles;
      for (let g of m5) if (!p4.circle[g]) {
        p4.circle[g] = true;
        let x2 = g * 3, b = this.circleKeys[g];
        if (this._circlesCollide(y4[x2], y4[x2 + 1], y4[x2 + 2], c.x, c.y, c.radius) && (!u5 || u5(b)) && !Pu$1(h, b.overlapMode)) return a4.push(true), true;
      }
    }
  }
  _forEachCell(e, t, i, n4, o4, a4, s5, u5) {
    let c = this._convertToXCellCoord(e), p4 = this._convertToYCellCoord(t), h = this._convertToXCellCoord(i), f = this._convertToYCellCoord(n4);
    for (let m5 = c; m5 <= h; m5++) for (let y4 = p4; y4 <= f; y4++) {
      let g = this.xCellCount * y4 + m5;
      if (o4.call(this, e, t, i, n4, g, a4, s5, u5)) return;
    }
  }
  _convertToXCellCoord(e) {
    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
  }
  _convertToYCellCoord(e) {
    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
  }
  _circlesCollide(e, t, i, n4, o4, a4) {
    let s5 = n4 - e, u5 = o4 - t, c = i + a4;
    return c * c > s5 * s5 + u5 * u5;
  }
  _circleAndRectCollide(e, t, i, n4, o4, a4, s5) {
    let u5 = (a4 - n4) / 2, c = Math.abs(e - (n4 + u5));
    if (c > u5 + i) return false;
    let p4 = (s5 - o4) / 2, h = Math.abs(t - (o4 + p4));
    if (h > p4 + i) return false;
    if (c <= u5 || h <= p4) return true;
    let f = c - u5, m5 = h - p4;
    return f * f + m5 * m5 <= i * i;
  }
};
H$3(Gd$1, "GridIndex");
var xa$1 = Gd$1;
a();
var Sn$1 = N$2(ge(), 1);
function ba$1(r5, e, t, i, n4) {
  let o4 = q$2.create();
  return e ? (q$2.scale(o4, o4, [1 / n4, 1 / n4, 1]), t || q$2.rotateZ(o4, o4, i.angle)) : q$2.multiply(o4, i.labelPlaneMatrix, r5), o4;
}
H$3(ba$1, "getLabelPlaneMatrix");
function Mu$1(r5, e, t, i, n4) {
  if (e) {
    let o4 = q$2.clone(r5);
    return q$2.scale(o4, o4, [n4, n4, 1]), t || q$2.rotateZ(o4, o4, -i.angle), o4;
  } else return i.glCoordMatrix;
}
H$3(Mu$1, "getGlCoordMatrix");
function bt$1(r5, e, t) {
  let i;
  t ? (i = [r5.x, r5.y, t(r5.x, r5.y), 1], qe$1.transformMat4(i, i, e)) : (i = [r5.x, r5.y, 0, 1], Au$1(i, i, e));
  let n4 = i[3];
  return { point: new Sn$1.default(i[0] / n4, i[1] / n4), signedDistanceFromCamera: n4 };
}
H$3(bt$1, "project");
function _a$1(r5, e) {
  return 0.5 + 0.5 * (r5 / e);
}
H$3(_a$1, "getPerspectiveRatio");
function aL$1(r5, e) {
  let t = r5[0] / r5[3], i = r5[1] / r5[3];
  return t >= -e[0] && t <= e[0] && i >= -e[1] && i <= e[1];
}
H$3(aL$1, "isVisible");
function x1$1(r5, e, t, i, n4, o4, a4, s5, u5, c) {
  let p4 = i ? r5.textSizeData : r5.iconSizeData, h = gi(p4, t.transform.zoom), f = [256 / t.width * 2 + 1, 256 / t.height * 2 + 1], m5 = i ? r5.text.dynamicLayoutVertexArray : r5.icon.dynamicLayoutVertexArray;
  m5.clear();
  let y4 = r5.lineVertexArray, g = i ? r5.text.placedSymbolArray : r5.icon.placedSymbolArray, x2 = t.transform.width / t.transform.height, b = false;
  for (let w3 = 0; w3 < g.length; w3++) {
    let _ = g.get(w3);
    if (_.hidden || _.writingMode === 2 && !b) {
      Si$1(_.numGlyphs, m5);
      continue;
    }
    b = false;
    let S4;
    if (c ? (S4 = [_.anchorX, _.anchorY, c(_.anchorX, _.anchorY), 1], qe$1.transformMat4(S4, S4, e)) : (S4 = [_.anchorX, _.anchorY, 0, 1], Au$1(S4, S4, e)), !aL$1(S4, f)) {
      Si$1(_.numGlyphs, m5);
      continue;
    }
    let P4 = S4[3], T3 = _a$1(t.transform.cameraToCenterDistance, P4), L3 = dn$1(p4, h, _), C3 = a4 ? L3 / T3 : L3 * T3, E4 = new Sn$1.default(_.anchorX, _.anchorY), I3 = bt$1(E4, n4, c).point, R3 = { projections: {}, offsets: {} }, z4 = g1$1(_, C3, false, s5, e, n4, o4, r5.glyphOffsetArray, y4, m5, I3, E4, R3, x2, u5, c);
    b = z4.useVertical, (z4.notEnoughRoom || b || z4.needsFlipping && g1$1(_, C3, true, s5, e, n4, o4, r5.glyphOffsetArray, y4, m5, I3, E4, R3, x2, u5, c).notEnoughRoom) && Si$1(_.numGlyphs, m5);
  }
  i ? r5.text.dynamicLayoutVertexBuffer.updateData(m5) : r5.icon.dynamicLayoutVertexBuffer.updateData(m5);
}
H$3(x1$1, "updateLineLabels");
function Zd(r5, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f) {
  let m5 = s5.glyphStartIndex + s5.numGlyphs, y4 = s5.lineStartIndex, g = s5.lineStartIndex + s5.lineLength, x2 = e.getoffsetX(s5.glyphStartIndex), b = e.getoffsetX(m5 - 1), w3 = Tu$1(r5 * x2, t, i, n4, o4, a4, s5.segment, y4, g, u5, c, p4, h, f);
  if (!w3) return null;
  let _ = Tu$1(r5 * b, t, i, n4, o4, a4, s5.segment, y4, g, u5, c, p4, h, f);
  return _ ? { first: w3, last: _ } : null;
}
H$3(Zd, "placeFirstAndLastGlyph");
function y1$1(r5, e, t, i) {
  if (r5 === 1) {
    let n4 = Math.abs(t.y - e.y), o4 = Math.abs(t.x - e.x) * i;
    if (n4 > o4) return { useVertical: true };
  }
  return (r5 === 2 ? e.y < t.y : e.x > t.x) ? { needsFlipping: true } : null;
}
H$3(y1$1, "requiresOrientationChange");
function g1$1(r5, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g) {
  let x2 = e / 24, b = r5.lineOffsetX * x2, w3 = r5.lineOffsetY * x2, _;
  if (r5.numGlyphs > 1) {
    let S4 = r5.glyphStartIndex + r5.numGlyphs, P4 = r5.lineStartIndex, T3 = r5.lineStartIndex + r5.lineLength, L3 = Zd(x2, s5, b, w3, t, p4, h, r5, u5, o4, f, y4, g);
    if (!L3) return { notEnoughRoom: true };
    let C3 = bt$1(L3.first.point, a4, g).point, E4 = bt$1(L3.last.point, a4, g).point;
    if (i && !t) {
      let I3 = y1$1(r5.writingMode, C3, E4, m5);
      if (I3) return I3;
    }
    _ = [L3.first];
    for (let I3 = r5.glyphStartIndex + 1; I3 < S4 - 1; I3++) {
      let R3 = Tu$1(x2 * s5.getoffsetX(I3), b, w3, t, p4, h, r5.segment, P4, T3, u5, o4, f, y4, g);
      if (R3 == null) return { notEnoughRoom: true };
      _.push(R3);
    }
    _.push(L3.last);
  } else {
    if (i && !t) {
      let P4 = bt$1(h, n4, g).point, T3 = r5.lineStartIndex + r5.segment + 1, L3 = new Sn$1.default(u5.getx(T3), u5.gety(T3)), C3 = bt$1(L3, n4, g), E4 = C3.signedDistanceFromCamera > 0 ? C3.point : b1$1(h, L3, P4, 1, n4, g), I3 = y1$1(r5.writingMode, P4, E4, m5);
      if (I3) return I3;
    }
    let S4 = Tu$1(x2 * s5.getoffsetX(r5.glyphStartIndex), b, w3, t, p4, h, r5.segment, r5.lineStartIndex, r5.lineStartIndex + r5.lineLength, u5, o4, f, y4, g);
    if (!S4) return { notEnoughRoom: true };
    _ = [S4];
  }
  for (let S4 of _) xi(c, S4.point, S4.angle);
  return {};
}
H$3(g1$1, "placeGlyphsAlongLine");
function b1$1(r5, e, t, i, n4, o4) {
  let a4 = bt$1(r5.add(r5.sub(e)._unit()), n4, o4).point, s5 = t.sub(a4);
  return t.add(s5._mult(i / s5.mag()));
}
H$3(b1$1, "projectTruncatedLineSegment");
function qd(r5, e) {
  let { projectionCache: t, lineVertexArray: i, labelPlaneMatrix: n4, tileAnchorPoint: o4, distanceFromAnchor: a4, getElevation: s5, previousVertex: u5, direction: c, absOffsetX: p4 } = e;
  if (t.projections[r5]) return t.projections[r5];
  let h = new Sn$1.default(i.getx(r5), i.gety(r5)), f = bt$1(h, n4, s5);
  if (f.signedDistanceFromCamera > 0) return t.projections[r5] = f.point, f.point;
  let m5 = r5 - c, y4 = a4 === 0 ? o4 : new Sn$1.default(i.getx(m5), i.gety(m5));
  return b1$1(y4, h, u5, p4 - a4 + 1, n4, s5);
}
H$3(qd, "projectVertexToViewport");
function jd$1(r5, e, t) {
  return r5._unit()._perp()._mult(e * t);
}
H$3(jd$1, "transformToOffsetNormal");
function sL(r5, e, t, i, n4, o4, a4, s5) {
  let { projectionCache: u5, direction: c } = s5;
  if (u5.offsets[r5]) return u5.offsets[r5];
  let p4 = t.add(e);
  if (r5 + c < i || r5 + c >= n4) return u5.offsets[r5] = p4, p4;
  let h = qd(r5 + c, s5), f = jd$1(h.sub(t), a4, c), m5 = t.add(f), y4 = h.add(f);
  return u5.offsets[r5] = tb$1(o4, p4, m5, y4) || p4, u5.offsets[r5];
}
H$3(sL, "findOffsetIntersectionPoint");
function Tu$1(r5, e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5) {
  let y4 = i ? r5 - e : r5 + e, g = y4 > 0 ? 1 : -1, x2 = 0;
  i && (g *= -1, x2 = Math.PI), g < 0 && (x2 += Math.PI);
  let b = g > 0 ? s5 + a4 : s5 + a4 + 1, w3 = n4, _ = n4, S4, P4, T3 = 0, L3 = 0, C3 = Math.abs(y4), E4 = [], I3;
  for (; T3 + L3 <= C3; ) {
    if (b += g, b < s5 || b >= u5) return null;
    T3 += L3, _ = w3, P4 = S4;
    let M3 = { projectionCache: h, lineVertexArray: c, labelPlaneMatrix: p4, tileAnchorPoint: o4, distanceFromAnchor: T3, getElevation: m5, previousVertex: _, direction: g, absOffsetX: C3 };
    if (w3 = qd(b, M3), t === 0) E4.push(_), I3 = w3.sub(_);
    else {
      let G3, K4 = w3.sub(_);
      if (K4.mag() === 0) {
        let ne2 = qd(b + g, M3);
        G3 = jd$1(ne2.sub(w3), t, g);
      } else G3 = jd$1(K4, t, g);
      P4 || (P4 = _.add(G3)), S4 = sL(b, G3, w3, s5, u5, P4, t, M3), E4.push(P4), I3 = S4.sub(P4);
    }
    L3 = I3.mag();
  }
  let R3 = (C3 - T3) / L3, z4 = I3._mult(R3)._add(P4 || _), k3 = x2 + Math.atan2(w3.y - _.y, w3.x - _.x);
  return E4.push(z4), { point: z4, angle: f ? k3 : 0, path: E4 };
}
H$3(Tu$1, "placeGlyphAlongLine");
var lL$1 = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
function Si$1(r5, e) {
  for (let t = 0; t < r5; t++) {
    let i = e.length;
    e.resize(i + 4), e.float32.set(lL$1, i * 3);
  }
}
H$3(Si$1, "hideGlyphs");
function Au$1(r5, e, t) {
  let i = e[0], n4 = e[1];
  return r5[0] = t[0] * i + t[4] * n4 + t[12], r5[1] = t[1] * i + t[5] * n4 + t[13], r5[3] = t[3] * i + t[7] * n4 + t[15], r5;
}
H$3(Au$1, "xyTransformMat4");
var Xe$1 = 100, $d$1 = class $d {
  constructor(e, t = new xa$1(e.width + 2 * Xe$1, e.height + 2 * Xe$1, 25), i = new xa$1(e.width + 2 * Xe$1, e.height + 2 * Xe$1, 25)) {
    this.transform = e, this.grid = t, this.ignoredGrid = i, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Xe$1, this.screenBottomBoundary = e.height + Xe$1, this.gridRightBoundary = e.width + 2 * Xe$1, this.gridBottomBoundary = e.height + 2 * Xe$1, this.perspectiveRatioCutoff = 0.6;
  }
  placeCollisionBox(e, t, i, n4, o4, a4) {
    let s5 = this.projectAndGetPerspectiveRatio(n4, e.anchorPointX, e.anchorPointY, a4), u5 = i * s5.perspectiveRatio, c = e.x1 * u5 + s5.point.x, p4 = e.y1 * u5 + s5.point.y, h = e.x2 * u5 + s5.point.x, f = e.y2 * u5 + s5.point.y;
    return !this.isInsideGrid(c, p4, h, f) || t !== "always" && this.grid.hitTest(c, p4, h, f, t, o4) || s5.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [c, p4, h, f], offscreen: this.isOffscreen(c, p4, h, f) };
  }
  placeCollisionCircles(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4) {
    let g = [], x2 = new $t$2.default(t.anchorX, t.anchorY), b = bt$1(x2, a4, y4), w3 = _a$1(this.transform.cameraToCenterDistance, b.signedDistanceFromCamera), S4 = (p4 ? o4 / w3 : o4 * w3) / Dr, P4 = bt$1(x2, s5, y4).point, T3 = { projections: {}, offsets: {} }, L3 = t.lineOffsetX * S4, C3 = t.lineOffsetY * S4, E4 = Zd(S4, n4, L3, C3, false, P4, x2, t, i, s5, T3, false, y4), I3 = false, R3 = false, z4 = true;
    if (E4) {
      let k3 = f * 0.5 * w3 + m5, M3 = new $t$2.default(-Xe$1, -Xe$1), G3 = new $t$2.default(this.screenRightBoundary, this.screenBottomBoundary), K4 = new Su$1(), ne2 = E4.first, J4 = E4.last, W4 = [];
      for (let ce2 = ne2.path.length - 1; ce2 >= 1; ce2--) W4.push(ne2.path[ce2]);
      for (let ce2 = 1; ce2 < J4.path.length; ce2++) W4.push(J4.path[ce2]);
      let Ye2 = k3 * 2.5;
      if (u5) {
        let ce2 = W4.map((Me2) => bt$1(Me2, u5, y4));
        ce2.some((Me2) => Me2.signedDistanceFromCamera <= 0) ? W4 = [] : W4 = ce2.map((Me2) => Me2.point);
      }
      let Ve3 = [];
      if (W4.length > 0) {
        let ce2 = W4[0].clone(), Me2 = W4[0].clone();
        for (let Qe2 = 1; Qe2 < W4.length; Qe2++) ce2.x = Math.min(ce2.x, W4[Qe2].x), ce2.y = Math.min(ce2.y, W4[Qe2].y), Me2.x = Math.max(Me2.x, W4[Qe2].x), Me2.y = Math.max(Me2.y, W4[Qe2].y);
        ce2.x >= M3.x && Me2.x <= G3.x && ce2.y >= M3.y && Me2.y <= G3.y ? Ve3 = [W4] : Me2.x < M3.x || ce2.x > G3.x || Me2.y < M3.y || ce2.y > G3.y ? Ve3 = [] : Ve3 = Ud$1([W4], M3.x, M3.y, G3.x, G3.y);
      }
      for (let ce2 of Ve3) {
        K4.reset(ce2, k3 * 0.25);
        let Me2 = 0;
        K4.length <= 0.5 * k3 ? Me2 = 1 : Me2 = Math.ceil(K4.paddedLength / Ye2) + 1;
        for (let Qe2 = 0; Qe2 < Me2; Qe2++) {
          let mr2 = Qe2 / Math.max(Me2 - 1, 1), dr2 = K4.lerp(mr2), zt2 = dr2.x + Xe$1, Xt2 = dr2.y + Xe$1;
          g.push(zt2, Xt2, k3, 0);
          let Gr2 = zt2 - k3, Kt2 = Xt2 - k3, Jt2 = zt2 + k3, et2 = Xt2 + k3;
          if (z4 = z4 && this.isOffscreen(Gr2, Kt2, Jt2, et2), R3 = R3 || this.isInsideGrid(Gr2, Kt2, Jt2, et2), e !== "always" && this.grid.hitTestCircle(zt2, Xt2, k3, e, h) && (I3 = true, !c)) return { circles: [], offscreen: false, collisionDetected: I3 };
        }
      }
    }
    return { circles: !c && I3 || !R3 || w3 < this.perspectiveRatioCutoff ? [] : g, offscreen: z4, collisionDetected: I3 };
  }
  queryRenderedSymbols(e) {
    if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
    let t = [], i = 1 / 0, n4 = 1 / 0, o4 = -1 / 0, a4 = -1 / 0;
    for (let p4 of e) {
      let h = new $t$2.default(p4.x + Xe$1, p4.y + Xe$1);
      i = Math.min(i, h.x), n4 = Math.min(n4, h.y), o4 = Math.max(o4, h.x), a4 = Math.max(a4, h.y), t.push(h);
    }
    let s5 = this.grid.query(i, n4, o4, a4).concat(this.ignoredGrid.query(i, n4, o4, a4)), u5 = {}, c = {};
    for (let p4 of s5) {
      let h = p4.key;
      if (u5[h.bucketInstanceId] === void 0 && (u5[h.bucketInstanceId] = {}), u5[h.bucketInstanceId][h.featureIndex]) continue;
      let f = [new $t$2.default(p4.x1, p4.y1), new $t$2.default(p4.x2, p4.y1), new $t$2.default(p4.x2, p4.y2), new $t$2.default(p4.x1, p4.y2)];
      El$1(t, f) && (u5[h.bucketInstanceId][h.featureIndex] = true, c[h.bucketInstanceId] === void 0 && (c[h.bucketInstanceId] = []), c[h.bucketInstanceId].push(h.featureIndex));
    }
    return c;
  }
  insertCollisionBox(e, t, i, n4, o4, a4) {
    let s5 = i ? this.ignoredGrid : this.grid, u5 = { bucketInstanceId: n4, featureIndex: o4, collisionGroupID: a4, overlapMode: t };
    s5.insert(u5, e[0], e[1], e[2], e[3]);
  }
  insertCollisionCircles(e, t, i, n4, o4, a4) {
    let s5 = i ? this.ignoredGrid : this.grid, u5 = { bucketInstanceId: n4, featureIndex: o4, collisionGroupID: a4, overlapMode: t };
    for (let c = 0; c < e.length; c += 4) s5.insertCircle(u5, e[c], e[c + 1], e[c + 2]);
  }
  projectAndGetPerspectiveRatio(e, t, i, n4) {
    let o4;
    return n4 ? (o4 = [t, i, n4(t, i), 1], qe$1.transformMat4(o4, o4, e)) : (o4 = [t, i, 0, 1], Au$1(o4, o4, e)), { point: new $t$2.default((o4[0] / o4[3] + 1) / 2 * this.transform.width + Xe$1, (-o4[1] / o4[3] + 1) / 2 * this.transform.height + Xe$1), perspectiveRatio: 0.5 + 0.5 * (this.transform.cameraToCenterDistance / o4[3]) };
  }
  isOffscreen(e, t, i, n4) {
    return i < Xe$1 || e >= this.screenRightBoundary || n4 < Xe$1 || t > this.screenBottomBoundary;
  }
  isInsideGrid(e, t, i, n4) {
    return i >= 0 && e < this.gridRightBoundary && n4 >= 0 && t < this.gridBottomBoundary;
  }
  getViewportMatrix() {
    let e = q$2.identity([]);
    return q$2.translate(e, e, [-Xe$1, -Xe$1, 0]), e;
  }
};
H$3($d$1, "CollisionIndex");
var Iu$1 = $d$1;
a();
a();
var _1$1 = N$2(ge(), 1);
var Cu$1 = class Cu extends _1$1.default {
  constructor(e, t, i, n4) {
    super(e, t), this.angle = i, n4 !== void 0 && (this.segment = n4);
  }
  clone() {
    return new Cu(this.x, this.y, this.angle, this.segment);
  }
};
H$3(Cu$1, "Anchor");
var va$1 = Cu$1;
N$1("Anchor", va$1);
a();
a();
a();
N$2(ge(), 1);
a();
N$2(ge(), 1);
a();
N$2(m$1(), 1);
N$2(ge(), 1);
N$2(Yf(), 1);
a();
var wa$1 = ((o4) => (o4[o4.center = 1] = "center", o4[o4.left = 2] = "left", o4[o4.right = 3] = "right", o4[o4.top = 4] = "top", o4[o4.bottom = 5] = "bottom", o4[o4["top-left"] = 6] = "top-left", o4[o4["top-right"] = 7] = "top-right", o4[o4["bottom-left"] = 8] = "bottom-left", o4[o4["bottom-right"] = 9] = "bottom-right", o4))(wa$1 || {});
function v1$1(r5) {
  switch (r5) {
    case "right":
    case "top-right":
    case "bottom-right":
      return "right";
    case "left":
    case "top-left":
    case "bottom-left":
      return "left";
  }
  return "center";
}
H$3(v1$1, "getAnchorJustification");
a();
function $e$1(r5, e, t) {
  return e * (8192 / (r5.tileSize * Math.pow(2, t - r5.tileID.overscaledZ)));
}
H$3($e$1, "pixelsToTileUnits");
var zu$1 = N$2(ge(), 1);
var Yd$1 = class Yd {
  constructor(e, t, i, n4) {
    e ? this.opacity = Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : this.opacity = n4 && i ? 1 : 0, this.placed = i;
  }
  isHidden() {
    return this.opacity === 0 && !this.placed;
  }
};
H$3(Yd$1, "OpacityState");
var ku$1 = Yd$1, Qd$1 = class Qd {
  constructor(e, t, i, n4, o4) {
    this.text = new ku$1(e ? e.text : null, t, i, o4), this.icon = new ku$1(e ? e.icon : null, t, n4, o4);
  }
  isHidden() {
    return this.text.isHidden() && this.icon.isHidden();
  }
};
H$3(Qd$1, "JointOpacityState");
var Pi$2 = Qd$1, ey$1 = class ey {
  constructor(e, t, i) {
    this.text = e, this.icon = t, this.skipFade = i;
  }
};
H$3(ey$1, "JointPlacement");
var Lu$1 = ey$1, ty$1 = class ty {
  constructor() {
    this.invProjMatrix = q$2.create(), this.viewportMatrix = q$2.create(), this.circles = [];
  }
};
H$3(ty$1, "CollisionCircleArray");
var Xd = ty$1, ry$1 = class ry {
  constructor(e, t, i, n4, o4) {
    this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = n4, this.tileID = o4;
  }
};
H$3(ry$1, "RetainedQueryData");
var Kd$1 = ry$1, iy$1 = class iy {
  constructor(e) {
    this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
  }
  get(e) {
    if (this.crossSourceCollisions) return { ID: 0, predicate: null };
    if (!this.collisionGroups[e]) {
      let t = ++this.maxGroupID;
      this.collisionGroups[e] = { ID: t, predicate: H$3((i) => i.collisionGroupID === t, "predicate") };
    }
    return this.collisionGroups[e];
  }
};
H$3(iy$1, "CollisionGroups");
var Jd$1 = iy$1;
function w1$1(r5, e, t, i, n4) {
  let { horizontalAlign: o4, verticalAlign: a4 } = Jl$1(r5), s5 = -(o4 - 0.5) * e, u5 = -(a4 - 0.5) * t;
  return new zu$1.default(s5 + i[0] * n4, u5 + i[1] * n4);
}
H$3(w1$1, "calculateVariableLayoutShift");
function Wd(r5, e, t, i, n4, o4) {
  let { x1: a4, x2: s5, y1: u5, y2: c, anchorPointX: p4, anchorPointY: h } = r5, f = new zu$1.default(e, t);
  return i && f._rotate(n4 ? o4 : -o4), { x1: a4 + f.x, y1: u5 + f.y, x2: s5 + f.x, y2: c + f.y, anchorPointX: p4, anchorPointY: h };
}
H$3(Wd, "shiftVariableCollisionBox");
var ny$1 = class ny {
  constructor(e, t, i, n4, o4) {
    this.transform = e.clone(), this.terrain = t, this.collisionIndex = new Iu$1(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i, this.retainedQueryData = {}, this.collisionGroups = new Jd$1(n4), this.collisionCircleArrays = {}, this.prevPlacement = o4, o4 && (o4.prevPlacement = void 0), this.placedOrientations = {};
  }
  getBucketParts(e, t, i, n4) {
    let o4 = i.getBucket(t), a4 = i.latestFeatureIndex;
    if (!o4 || !a4 || t.id !== o4.layerIds[0]) return;
    let s5 = i.collisionBoxArray, u5 = o4.layers[0].layout, c = Math.pow(2, this.transform.zoom - i.tileID.overscaledZ), p4 = i.tileSize / 8192, h = this.transform.calculatePosMatrix(i.tileID.toUnwrapped()), f = u5.get("text-pitch-alignment") === "map", m5 = u5.get("text-rotation-alignment") === "map", y4 = $e$1(i, 1, this.transform.zoom), g = ba$1(h, f, m5, this.transform, y4), x2 = null;
    if (f) {
      let w3 = Mu$1(h, f, m5, this.transform, y4);
      x2 = q$2.multiply([], this.transform.labelPlaneMatrix, w3);
    }
    this.retainedQueryData[o4.bucketInstanceId] = new Kd$1(o4.bucketInstanceId, a4, o4.sourceLayerIndex, o4.index, i.tileID);
    let b = { bucket: o4, layout: u5, posMatrix: h, textLabelPlaneMatrix: g, labelToScreenMatrix: x2, scale: c, textPixelRatio: p4, holdingForFade: i.holdingForFade(), collisionBoxArray: s5, partiallyEvaluatedTextSize: gi(o4.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o4.sourceID) };
    if (n4) for (let w3 of o4.sortKeyRanges) {
      let { sortKey: _, symbolInstanceStart: S4, symbolInstanceEnd: P4 } = w3;
      e.push({ sortKey: _, symbolInstanceStart: S4, symbolInstanceEnd: P4, parameters: b });
    }
    else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: o4.symbolInstances.length, parameters: b });
  }
  attemptAnchorPlacement(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2) {
    let b = wa$1[e.textAnchor], w3 = [e.textOffset0, e.textOffset1], _ = w1$1(b, i, n4, w3, o4), S4 = this.collisionIndex.placeCollisionBox(Wd(t, _.x, _.y, a4, s5, this.transform.angle), h, u5, c, p4.predicate, x2);
    if (!(g && this.collisionIndex.placeCollisionBox(Wd(g, _.x, _.y, a4, s5, this.transform.angle), h, u5, c, p4.predicate, x2).box.length === 0) && S4.box.length > 0) {
      let P4;
      if (this.prevPlacement && this.prevPlacement.variableOffsets[f.crossTileID] && this.prevPlacement.placements[f.crossTileID] && this.prevPlacement.placements[f.crossTileID].text && (P4 = this.prevPlacement.variableOffsets[f.crossTileID].anchor), f.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      return this.variableOffsets[f.crossTileID] = { textOffset: w3, width: i, height: n4, anchor: b, textBoxScale: o4, prevAnchor: P4 }, this.markUsedJustification(m5, b, f, y4), m5.allowVerticalPlacement && (this.markUsedOrientation(m5, y4, f), this.placedOrientations[f.crossTileID] = y4), { shift: _, placedGlyphBoxes: S4 };
    }
  }
  placeLayerBucketPart(e, t, i) {
    let { bucket: n4, layout: o4, posMatrix: a4, textLabelPlaneMatrix: s5, labelToScreenMatrix: u5, textPixelRatio: c, holdingForFade: p4, collisionBoxArray: h, partiallyEvaluatedTextSize: f, collisionGroup: m5 } = e.parameters, y4 = o4.get("text-optional"), g = o4.get("icon-optional"), x2 = yn(o4, "text-overlap", "text-allow-overlap"), b = x2 === "always", w3 = yn(o4, "icon-overlap", "icon-allow-overlap"), _ = w3 === "always", S4 = o4.get("text-rotation-alignment") === "map", P4 = o4.get("text-pitch-alignment") === "map", T3 = o4.get("icon-text-fit") !== "none", L3 = o4.get("symbol-z-order") === "viewport-y", C3 = b && (_ || !n4.hasIconData() || g), E4 = _ && (b || !n4.hasTextData() || y4);
    !n4.collisionArrays && h && n4.deserializeCollisionBoxes(h);
    let I3 = this.retainedQueryData[n4.bucketInstanceId].tileID, R3 = this.terrain ? (k3, M3) => this.terrain.getElevation(I3, k3, M3) : null, z4 = H$3((k3, M3) => {
      var Kt2, Jt2;
      if (t[k3.crossTileID]) return;
      if (p4) {
        this.placements[k3.crossTileID] = new Lu$1(false, false, false);
        return;
      }
      let G3 = false, K4 = false, ne2 = true, J4 = null, W4 = { box: null, offscreen: null }, Ye2 = { box: null }, Ve3 = null, ce2 = null, Me2 = null, Qe2 = 0, mr2 = 0, dr2 = 0;
      M3.textFeatureIndex ? Qe2 = M3.textFeatureIndex : k3.useRuntimeCollisionCircles && (Qe2 = k3.featureIndex), M3.verticalTextFeatureIndex && (mr2 = M3.verticalTextFeatureIndex);
      let zt2 = M3.textBox;
      if (zt2) {
        let et2 = H$3((Ze2) => {
          let ct2 = 1;
          if (n4.allowVerticalPlacement && !Ze2 && this.prevPlacement) {
            let Yt2 = this.prevPlacement.placedOrientations[k3.crossTileID];
            Yt2 && (this.placedOrientations[k3.crossTileID] = Yt2, ct2 = Yt2, this.markUsedOrientation(n4, ct2, k3));
          }
          return ct2;
        }, "updatePreviousOrientationIfNotPlaced"), ot2 = H$3((Ze2, ct2) => {
          if (n4.allowVerticalPlacement && k3.numVerticalGlyphVertices > 0 && M3.verticalTextBox) {
            for (let Yt2 of n4.writingModes) if (Yt2 === 2 ? (W4 = ct2(), Ye2 = W4) : W4 = Ze2(), W4 && W4.box && W4.box.length) break;
          } else W4 = Ze2();
        }, "placeTextForPlacementModes"), tt2 = k3.textAnchorOffsetStartIndex, qr2 = k3.textAnchorOffsetEndIndex;
        if (qr2 === tt2) {
          let Ze2 = H$3((jr2, es2) => {
            let rt2 = this.collisionIndex.placeCollisionBox(jr2, x2, c, a4, m5.predicate, R3);
            return rt2 && rt2.box && rt2.box.length && (this.markUsedOrientation(n4, es2, k3), this.placedOrientations[k3.crossTileID] = es2), rt2;
          }, "placeBox");
          ot2(H$3(() => Ze2(zt2, 1), "placeHorizontal"), H$3(() => {
            let jr2 = M3.verticalTextBox;
            return n4.allowVerticalPlacement && k3.numVerticalGlyphVertices > 0 && jr2 ? Ze2(jr2, 2) : { box: null, offscreen: null };
          }, "placeVertical")), et2(W4 && W4.box && W4.box.length);
        } else {
          let Ze2 = wa$1[(Jt2 = (Kt2 = this.prevPlacement) == null ? void 0 : Kt2.variableOffsets[k3.crossTileID]) == null ? void 0 : Jt2.anchor], ct2 = H$3((rt2, yp, d22) => {
            let y22 = rt2.x2 - rt2.x1, g22 = rt2.y2 - rt2.y1, x22 = k3.textBoxScale, b22 = T3 && w3 === "never" ? yp : null, Ii2 = { box: [], offscreen: false }, Ox3 = x2 === "never" ? 1 : 2, Vx2 = "never";
            Ze2 && Ox3++;
            for (let Ux2 = 0; Ux2 < Ox3; Ux2++) {
              for (let gp2 = tt2; gp2 < qr2; gp2++) {
                let Nx2 = n4.textAnchorOffsets.get(gp2);
                if (Ze2 && Nx2.textAnchor !== Ze2) continue;
                let xp2 = this.attemptAnchorPlacement(Nx2, rt2, y22, g22, x22, S4, P4, c, a4, m5, Vx2, k3, n4, d22, b22, R3);
                if (xp2 && (Ii2 = xp2.placedGlyphBoxes, Ii2 && Ii2.box && Ii2.box.length)) return G3 = true, J4 = xp2.shift, Ii2;
              }
              Ze2 ? Ze2 = null : Vx2 = x2;
            }
            return Ii2;
          }, "placeBoxForVariableAnchors");
          ot2(H$3(() => ct2(zt2, M3.iconBox, 1), "placeHorizontal"), H$3(() => {
            let rt2 = M3.verticalTextBox, yp = W4 && W4.box && W4.box.length;
            return n4.allowVerticalPlacement && !yp && k3.numVerticalGlyphVertices > 0 && rt2 ? ct2(rt2, M3.verticalIconBox, 2) : { box: null, offscreen: null };
          }, "placeVertical")), W4 && (G3 = W4.box, ne2 = W4.offscreen);
          let es2 = et2(W4 && W4.box);
          if (!G3 && this.prevPlacement) {
            let rt2 = this.prevPlacement.variableOffsets[k3.crossTileID];
            rt2 && (this.variableOffsets[k3.crossTileID] = rt2, this.markUsedJustification(n4, rt2.anchor, k3, es2));
          }
        }
      }
      if (Ve3 = W4, G3 = Ve3 && Ve3.box && Ve3.box.length > 0, ne2 = Ve3 && Ve3.offscreen, k3.useRuntimeCollisionCircles) {
        let et2 = n4.text.placedSymbolArray.get(k3.centerJustifiedTextSymbolIndex), ot2 = dn$1(n4.textSizeData, f, et2), tt2 = o4.get("text-padding"), qr2 = k3.collisionCircleDiameter;
        ce2 = this.collisionIndex.placeCollisionCircles(x2, et2, n4.lineVertexArray, n4.glyphOffsetArray, ot2, a4, s5, u5, i, P4, m5.predicate, qr2, tt2, R3), ce2.circles.length && ce2.collisionDetected && !i && Le$1("Collisions detected, but collision boxes are not shown"), G3 = b || ce2.circles.length > 0 && !ce2.collisionDetected, ne2 = ne2 && ce2.offscreen;
      }
      if (M3.iconFeatureIndex && (dr2 = M3.iconFeatureIndex), M3.iconBox) {
        let et2 = H$3((ot2) => {
          let tt2 = T3 && J4 ? Wd(ot2, J4.x, J4.y, S4, P4, this.transform.angle) : ot2;
          return this.collisionIndex.placeCollisionBox(tt2, w3, c, a4, m5.predicate, R3);
        }, "placeIconFeature");
        Ye2 && Ye2.box && Ye2.box.length && M3.verticalIconBox ? (Me2 = et2(M3.verticalIconBox), K4 = Me2.box.length > 0) : (Me2 = et2(M3.iconBox), K4 = Me2.box.length > 0), ne2 = ne2 && Me2.offscreen;
      }
      let Xt2 = y4 || k3.numHorizontalGlyphVertices === 0 && k3.numVerticalGlyphVertices === 0, Gr2 = g || k3.numIconVertices === 0;
      if (!Xt2 && !Gr2 ? K4 = G3 = K4 && G3 : Gr2 ? Xt2 || (K4 = K4 && G3) : G3 = K4 && G3, G3 && Ve3 && Ve3.box && (Ye2 && Ye2.box && mr2 ? this.collisionIndex.insertCollisionBox(Ve3.box, x2, o4.get("text-ignore-placement"), n4.bucketInstanceId, mr2, m5.ID) : this.collisionIndex.insertCollisionBox(Ve3.box, x2, o4.get("text-ignore-placement"), n4.bucketInstanceId, Qe2, m5.ID)), K4 && Me2 && this.collisionIndex.insertCollisionBox(Me2.box, w3, o4.get("icon-ignore-placement"), n4.bucketInstanceId, dr2, m5.ID), ce2 && (G3 && this.collisionIndex.insertCollisionCircles(ce2.circles, x2, o4.get("text-ignore-placement"), n4.bucketInstanceId, Qe2, m5.ID), i)) {
        let et2 = n4.bucketInstanceId, ot2 = this.collisionCircleArrays[et2];
        ot2 === void 0 && (ot2 = this.collisionCircleArrays[et2] = new Xd());
        for (let tt2 = 0; tt2 < ce2.circles.length; tt2 += 4) ot2.circles.push(ce2.circles[tt2 + 0]), ot2.circles.push(ce2.circles[tt2 + 1]), ot2.circles.push(ce2.circles[tt2 + 2]), ot2.circles.push(ce2.collisionDetected ? 1 : 0);
      }
      if (k3.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
      if (n4.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
      this.placements[k3.crossTileID] = new Lu$1(G3 || C3, K4 || E4, ne2 || n4.justReloaded), t[k3.crossTileID] = true;
    }, "placeSymbol");
    if (L3) {
      if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
      let k3 = n4.getSortedSymbolIndexes(this.transform.angle);
      for (let M3 = k3.length - 1; M3 >= 0; --M3) {
        let G3 = k3[M3];
        z4(n4.symbolInstances.get(G3), n4.collisionArrays[G3]);
      }
    } else for (let k3 = e.symbolInstanceStart; k3 < e.symbolInstanceEnd; k3++) z4(n4.symbolInstances.get(k3), n4.collisionArrays[k3]);
    if (i && n4.bucketInstanceId in this.collisionCircleArrays) {
      let k3 = this.collisionCircleArrays[n4.bucketInstanceId];
      q$2.invert(k3.invProjMatrix, a4), k3.viewportMatrix = this.collisionIndex.getViewportMatrix();
    }
    n4.justReloaded = false;
  }
  markUsedJustification(e, t, i, n4) {
    let o4 = { left: i.leftJustifiedTextSymbolIndex, center: i.centerJustifiedTextSymbolIndex, right: i.rightJustifiedTextSymbolIndex }, a4;
    n4 === 2 ? a4 = i.verticalPlacedTextSymbolIndex : a4 = o4[v1$1(t)];
    let s5 = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex, i.verticalPlacedTextSymbolIndex];
    for (let u5 of s5) u5 >= 0 && (a4 >= 0 && u5 !== a4 ? e.text.placedSymbolArray.get(u5).crossTileID = 0 : e.text.placedSymbolArray.get(u5).crossTileID = i.crossTileID);
  }
  markUsedOrientation(e, t, i) {
    let n4 = t === 1 || t === 3 ? t : 0, o4 = t === 2 ? t : 0, a4 = [i.leftJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.rightJustifiedTextSymbolIndex];
    for (let s5 of a4) e.text.placedSymbolArray.get(s5).placedOrientation = n4;
    i.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(i.verticalPlacedTextSymbolIndex).placedOrientation = o4);
  }
  commit(e) {
    this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
    let t = this.prevPlacement, i = false;
    this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;
    let n4 = t ? t.symbolFadeChange(e) : 1, o4 = t ? t.opacities : {}, a4 = t ? t.variableOffsets : {}, s5 = t ? t.placedOrientations : {};
    for (let u5 in this.placements) {
      let c = this.placements[u5], p4 = o4[u5];
      p4 ? (this.opacities[u5] = new Pi$2(p4, n4, c.text, c.icon), i = i || c.text !== p4.text.placed || c.icon !== p4.icon.placed) : (this.opacities[u5] = new Pi$2(null, n4, c.text, c.icon, c.skipFade), i = i || c.text || c.icon);
    }
    for (let u5 in o4) {
      let c = o4[u5];
      if (!this.opacities[u5]) {
        let p4 = new Pi$2(c, n4, false, false);
        p4.isHidden() || (this.opacities[u5] = p4, i = i || c.text.placed || c.icon.placed);
      }
    }
    for (let u5 in a4) !this.variableOffsets[u5] && this.opacities[u5] && !this.opacities[u5].isHidden() && (this.variableOffsets[u5] = a4[u5]);
    for (let u5 in s5) !this.placedOrientations[u5] && this.opacities[u5] && !this.opacities[u5].isHidden() && (this.placedOrientations[u5] = s5[u5]);
    if (t && t.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
    i ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);
  }
  updateLayerOpacities(e, t) {
    let i = {};
    for (let n4 of t) {
      let o4 = n4.getBucket(e);
      o4 && n4.latestFeatureIndex && e.id === o4.layerIds[0] && this.updateBucketOpacities(o4, i, n4.collisionBoxArray);
    }
  }
  updateBucketOpacities(e, t, i) {
    e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
    let n4 = e.layers[0], o4 = n4.layout, a4 = new Pi$2(null, 0, false, false, true), s5 = o4.get("text-allow-overlap"), u5 = o4.get("icon-allow-overlap"), c = n4._unevaluatedLayout.hasValue("text-variable-anchor") || n4._unevaluatedLayout.hasValue("text-variable-anchor-offset"), p4 = o4.get("text-rotation-alignment") === "map", h = o4.get("text-pitch-alignment") === "map", f = o4.get("icon-text-fit") !== "none", m5 = new Pi$2(null, 0, s5 && (u5 || !e.hasIconData() || o4.get("icon-optional")), u5 && (s5 || !e.hasTextData() || o4.get("text-optional")), true);
    !e.collisionArrays && i && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(i);
    let y4 = H$3((g, x2, b) => {
      for (let w3 = 0; w3 < x2 / 4; w3++) g.opacityVertexArray.emplaceBack(b);
      g.hasVisibleVertices = g.hasVisibleVertices || b !== Sa$1;
    }, "addOpacities");
    for (let g = 0; g < e.symbolInstances.length; g++) {
      let x2 = e.symbolInstances.get(g), { numHorizontalGlyphVertices: b, numVerticalGlyphVertices: w3, crossTileID: _ } = x2, S4 = t[_], P4 = this.opacities[_];
      S4 ? P4 = a4 : P4 || (P4 = m5, this.opacities[_] = P4), t[_] = true;
      let T3 = b > 0 || w3 > 0, L3 = x2.numIconVertices > 0, C3 = this.placedOrientations[x2.crossTileID], E4 = C3 === 2, I3 = C3 === 1 || C3 === 3;
      if (T3) {
        let R3 = S1$1(P4.text), z4 = E4 ? Sa$1 : R3;
        y4(e.text, b, z4);
        let k3 = I3 ? Sa$1 : R3;
        y4(e.text, w3, k3);
        let M3 = P4.text.isHidden();
        [x2.rightJustifiedTextSymbolIndex, x2.centerJustifiedTextSymbolIndex, x2.leftJustifiedTextSymbolIndex].forEach((ne2) => {
          ne2 >= 0 && (e.text.placedSymbolArray.get(ne2).hidden = M3 || E4 ? 1 : 0);
        }), x2.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(x2.verticalPlacedTextSymbolIndex).hidden = M3 || I3 ? 1 : 0);
        let G3 = this.variableOffsets[x2.crossTileID];
        G3 && this.markUsedJustification(e, G3.anchor, x2, C3);
        let K4 = this.placedOrientations[x2.crossTileID];
        K4 && (this.markUsedJustification(e, "left", x2, K4), this.markUsedOrientation(e, K4, x2));
      }
      if (L3) {
        let R3 = S1$1(P4.icon), z4 = !(f && x2.verticalPlacedIconSymbolIndex && E4);
        if (x2.placedIconSymbolIndex >= 0) {
          let k3 = z4 ? R3 : Sa$1;
          y4(e.icon, x2.numIconVertices, k3), e.icon.placedSymbolArray.get(x2.placedIconSymbolIndex).hidden = P4.icon.isHidden();
        }
        if (x2.verticalPlacedIconSymbolIndex >= 0) {
          let k3 = z4 ? Sa$1 : R3;
          y4(e.icon, x2.numVerticalIconVertices, k3), e.icon.placedSymbolArray.get(x2.verticalPlacedIconSymbolIndex).hidden = P4.icon.isHidden();
        }
      }
      if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
        let R3 = e.collisionArrays[g];
        if (R3) {
          let z4 = new zu$1.default(0, 0);
          if (R3.textBox || R3.verticalTextBox) {
            let M3 = true;
            if (c) {
              let G3 = this.variableOffsets[_];
              G3 ? (z4 = w1$1(G3.anchor, G3.width, G3.height, G3.textOffset, G3.textBoxScale), p4 && z4._rotate(h ? this.transform.angle : -this.transform.angle)) : M3 = false;
            }
            R3.textBox && Eu$1(e.textCollisionBox.collisionVertexArray, P4.text.placed, !M3 || E4, z4.x, z4.y), R3.verticalTextBox && Eu$1(e.textCollisionBox.collisionVertexArray, P4.text.placed, !M3 || I3, z4.x, z4.y);
          }
          let k3 = !!(!I3 && R3.verticalIconBox);
          R3.iconBox && Eu$1(e.iconCollisionBox.collisionVertexArray, P4.icon.placed, k3, f ? z4.x : 0, f ? z4.y : 0), R3.verticalIconBox && Eu$1(e.iconCollisionBox.collisionVertexArray, P4.icon.placed, !k3, f ? z4.x : 0, f ? z4.y : 0);
        }
      }
    }
    if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error("bucket.text.opacityVertexArray.length (= ".concat(e.text.opacityVertexArray.length, ") !== bucket.text.layoutVertexArray.length (= ").concat(e.text.layoutVertexArray.length, ") / 4"));
    if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error("bucket.icon.opacityVertexArray.length (= ".concat(e.icon.opacityVertexArray.length, ") !== bucket.icon.layoutVertexArray.length (= ").concat(e.icon.layoutVertexArray.length, ") / 4"));
    if (e.bucketInstanceId in this.collisionCircleArrays) {
      let g = this.collisionCircleArrays[e.bucketInstanceId];
      e.placementInvProjMatrix = g.invProjMatrix, e.placementViewportMatrix = g.viewportMatrix, e.collisionCircleArray = g.circles, delete this.collisionCircleArrays[e.bucketInstanceId];
    }
  }
  symbolFadeChange(e) {
    return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
  }
  zoomAdjustment(e) {
    return Math.max(0, (this.transform.zoom - e) / 1.5);
  }
  hasTransitions(e) {
    return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
  }
  stillRecent(e, t) {
    let i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
    return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;
  }
  setStale() {
    this.stale = true;
  }
};
H$3(ny$1, "Placement");
var Du$1 = ny$1;
function Eu$1(r5, e, t, i, n4) {
  r5.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n4 || 0), r5.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n4 || 0), r5.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n4 || 0), r5.emplaceBack(e ? 1 : 0, t ? 1 : 0, i || 0, n4 || 0);
}
H$3(Eu$1, "updateCollisionVertices");
var dL$1 = Math.pow(2, 25), yL$1 = Math.pow(2, 24), gL$1 = Math.pow(2, 17), xL$1 = Math.pow(2, 16), bL$1 = Math.pow(2, 9), _L$1 = Math.pow(2, 8), vL$1 = Math.pow(2, 1);
function S1$1(r5) {
  if (r5.opacity === 0 && !r5.placed) return 0;
  if (r5.opacity === 1 && r5.placed) return 4294967295;
  let e = r5.placed ? 1 : 0, t = Math.floor(r5.opacity * 127);
  return t * dL$1 + e * yL$1 + t * gL$1 + e * xL$1 + t * bL$1 + e * _L$1 + t * vL$1 + e;
}
H$3(S1$1, "packOpacity");
var Sa$1 = 0;
var ay$1 = class ay {
  constructor(e) {
    this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
  }
  continuePlacement(e, t, i, n4, o4) {
    let a4 = this._bucketParts;
    for (; this._currentTileIndex < e.length; ) {
      let s5 = e[this._currentTileIndex];
      if (t.getBucketParts(a4, n4, s5, this._sortAcrossTiles), this._currentTileIndex++, o4()) return true;
    }
    for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a4.sort((s5, u5) => s5.sortKey - u5.sortKey)); this._currentPartIndex < a4.length; ) {
      let s5 = a4[this._currentPartIndex];
      if (t.placeLayerBucketPart(s5, this._seenCrossTileIDs, i), this._currentPartIndex++, o4()) return true;
    }
    return false;
  }
};
H$3(ay$1, "LayerPlacement");
var oy$1 = ay$1, sy$1 = class sy {
  constructor(e, t, i, n4, o4, a4, s5, u5) {
    this.placement = new Du$1(e, t, a4, s5, u5), this._currentPlacementIndex = i.length - 1, this._forceFullPlacement = n4, this._showCollisionBoxes = o4, this._done = false;
  }
  isDone() {
    return this._done;
  }
  continuePlacement(e, t, i) {
    let n4 = Y$1.now(), o4 = H$3(() => this._forceFullPlacement ? false : Y$1.now() - n4 > 2, "shouldPausePlacement");
    for (; this._currentPlacementIndex >= 0; ) {
      let a4 = e[this._currentPlacementIndex], s5 = t[a4], u5 = this.placement.collisionIndex.transform.zoom;
      if (s5.type === "symbol" && (!s5.minzoom || s5.minzoom <= u5) && (!s5.maxzoom || s5.maxzoom > u5)) {
        if (this._inProgressLayer || (this._inProgressLayer = new oy$1(s5)), this._inProgressLayer.continuePlacement(i[s5.source], this.placement, this._showCollisionBoxes, s5, o4)) return;
        delete this._inProgressLayer;
      }
      this._currentPlacementIndex--;
    }
    this._done = true;
  }
  commit(e) {
    return this.placement.commit(e), this.placement;
  }
};
H$3(sy$1, "PauseablePlacement");
var Fu$1 = sy$1;
a();
a();
var P1$1 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], ly$1 = 1, Pa = 8, Ru$1 = class Ru {
  static from(e) {
    if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
    let [t, i] = new Uint8Array(e, 0, 2);
    if (t !== 219) throw new Error("Data does not appear to be in a KDBush format.");
    let n4 = i >> 4;
    if (n4 !== ly$1) throw new Error("Got v".concat(n4, " data when expected v").concat(ly$1, "."));
    let o4 = P1$1[i & 15];
    if (!o4) throw new Error("Unrecognized array type.");
    let [a4] = new Uint16Array(e, 2, 1), [s5] = new Uint32Array(e, 4, 1);
    return new Ru(s5, a4, o4, e);
  }
  constructor(e, t = 64, i = Float64Array, n4) {
    if (isNaN(e) || e < 0) throw new Error("Unpexpected numItems value: ".concat(e, "."));
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+t, 2), 65535), this.ArrayType = i, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    let o4 = P1$1.indexOf(this.ArrayType), a4 = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, s5 = e * this.IndexArrayType.BYTES_PER_ELEMENT, u5 = (8 - s5 % 8) % 8;
    if (o4 < 0) throw new Error("Unexpected typed array class: ".concat(i, "."));
    n4 && n4 instanceof ArrayBuffer ? (this.data = n4, this.ids = new this.IndexArrayType(this.data, Pa, e), this.coords = new this.ArrayType(this.data, Pa + s5 + u5, e * 2), this._pos = e * 2, this._finished = true) : (this.data = new ArrayBuffer(Pa + a4 + s5 + u5), this.ids = new this.IndexArrayType(this.data, Pa, e), this.coords = new this.ArrayType(this.data, Pa + s5 + u5, e * 2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, (ly$1 << 4) + o4]), new Uint16Array(this.data, 2, 1)[0] = t, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  add(e, t) {
    let i = this._pos >> 1;
    return this.ids[i] = i, this.coords[this._pos++] = e, this.coords[this._pos++] = t, i;
  }
  finish() {
    let e = this._pos >> 1;
    if (e !== this.numItems) throw new Error("Added ".concat(e, " items when expected ").concat(this.numItems, "."));
    return cy$1(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  range(e, t, i, n4) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: o4, coords: a4, nodeSize: s5 } = this, u5 = [0, o4.length - 1, 0], c = [];
    for (; u5.length; ) {
      let p4 = u5.pop() || 0, h = u5.pop() || 0, f = u5.pop() || 0;
      if (h - f <= s5) {
        for (let x2 = f; x2 <= h; x2++) {
          let b = a4[2 * x2], w3 = a4[2 * x2 + 1];
          b >= e && b <= i && w3 >= t && w3 <= n4 && c.push(o4[x2]);
        }
        continue;
      }
      let m5 = f + h >> 1, y4 = a4[2 * m5], g = a4[2 * m5 + 1];
      y4 >= e && y4 <= i && g >= t && g <= n4 && c.push(o4[m5]), (p4 === 0 ? e <= y4 : t <= g) && (u5.push(f), u5.push(m5 - 1), u5.push(1 - p4)), (p4 === 0 ? i >= y4 : n4 >= g) && (u5.push(m5 + 1), u5.push(h), u5.push(1 - p4));
    }
    return c;
  }
  within(e, t, i) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    let { ids: n4, coords: o4, nodeSize: a4 } = this, s5 = [0, n4.length - 1, 0], u5 = [], c = i * i;
    for (; s5.length; ) {
      let p4 = s5.pop() || 0, h = s5.pop() || 0, f = s5.pop() || 0;
      if (h - f <= a4) {
        for (let x2 = f; x2 <= h; x2++) T1$1(o4[2 * x2], o4[2 * x2 + 1], e, t) <= c && u5.push(n4[x2]);
        continue;
      }
      let m5 = f + h >> 1, y4 = o4[2 * m5], g = o4[2 * m5 + 1];
      T1$1(y4, g, e, t) <= c && u5.push(n4[m5]), (p4 === 0 ? e - i <= y4 : t - i <= g) && (s5.push(f), s5.push(m5 - 1), s5.push(1 - p4)), (p4 === 0 ? e + i >= y4 : t + i >= g) && (s5.push(m5 + 1), s5.push(h), s5.push(1 - p4));
    }
    return u5;
  }
};
H$3(Ru$1, "KDBush");
var Ma$1 = Ru$1;
function cy$1(r5, e, t, i, n4, o4) {
  if (n4 - i <= t) return;
  let a4 = i + n4 >> 1;
  M1$1(r5, e, a4, i, n4, o4), cy$1(r5, e, t, i, a4 - 1, 1 - o4), cy$1(r5, e, t, a4 + 1, n4, 1 - o4);
}
H$3(cy$1, "sort");
function M1$1(r5, e, t, i, n4, o4) {
  for (; n4 > i; ) {
    if (n4 - i > 600) {
      let c = n4 - i + 1, p4 = t - i + 1, h = Math.log(c), f = 0.5 * Math.exp(2 * h / 3), m5 = 0.5 * Math.sqrt(h * f * (c - f) / c) * (p4 - c / 2 < 0 ? -1 : 1), y4 = Math.max(i, Math.floor(t - p4 * f / c + m5)), g = Math.min(n4, Math.floor(t + (c - p4) * f / c + m5));
      M1$1(r5, e, t, y4, g, o4);
    }
    let a4 = e[2 * t + o4], s5 = i, u5 = n4;
    for (Ta$1(r5, e, i, t), e[2 * n4 + o4] > a4 && Ta$1(r5, e, i, n4); s5 < u5; ) {
      for (Ta$1(r5, e, s5, u5), s5++, u5--; e[2 * s5 + o4] < a4; ) s5++;
      for (; e[2 * u5 + o4] > a4; ) u5--;
    }
    e[2 * i + o4] === a4 ? Ta$1(r5, e, i, u5) : (u5++, Ta$1(r5, e, u5, n4)), u5 <= t && (i = u5 + 1), t <= u5 && (n4 = u5 - 1);
  }
}
H$3(M1$1, "select");
function Ta$1(r5, e, t, i) {
  uy$1(r5, t, i), uy$1(e, 2 * t, 2 * i), uy$1(e, 2 * t + 1, 2 * i + 1);
}
H$3(Ta$1, "swapItem");
function uy$1(r5, e, t) {
  let i = r5[e];
  r5[e] = r5[t], r5[t] = i;
}
H$3(uy$1, "swap");
function T1$1(r5, e, t, i) {
  let n4 = r5 - t, o4 = e - i;
  return n4 * n4 + o4 * o4;
}
H$3(T1$1, "sqDist");
var Aa = 512 / 8192 / 2, wL$1 = 128, my$1 = class my {
  constructor(e, t, i) {
    this.tileID = e;
    this.bucketInstanceId = i;
    this._symbolsByKey = {};
    let n4 = /* @__PURE__ */ new Map();
    for (let o4 = 0; o4 < t.length; o4++) {
      let a4 = t.get(o4), s5 = a4.key, u5 = n4.get(s5);
      u5 ? u5.push(a4) : n4.set(s5, [a4]);
    }
    for (let [o4, a4] of n4) {
      let s5 = a4.map((p4) => ({ x: Math.floor(p4.anchorX * Aa), y: Math.floor(p4.anchorY * Aa) })), u5 = a4.map((p4) => p4.crossTileID), c = { positions: s5, crossTileIDs: u5 };
      if (c.positions.length > wL$1) {
        let p4 = new Ma$1(c.positions.length, 16, Uint16Array);
        for (let { x: h, y: f } of c.positions) p4.add(h, f);
        p4.finish(), delete c.positions, c.index = p4;
      }
      this._symbolsByKey[o4] = c;
    }
  }
  getScaledCoordinates(e, t) {
    let { x: i, y: n4, z: o4 } = this.tileID.canonical, { x: a4, y: s5, z: u5 } = t.canonical, c = u5 - o4, p4 = Aa / Math.pow(2, c), h = (a4 * 8192 + e.anchorX) * p4, f = (s5 * 8192 + e.anchorY) * p4, m5 = i * 8192 * Aa, y4 = n4 * 8192 * Aa;
    return { x: Math.floor(h - m5), y: Math.floor(f - y4) };
  }
  findMatches(e, t, i) {
    let n4 = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);
    for (let o4 = 0; o4 < e.length; o4++) {
      let a4 = e.get(o4);
      if (a4.crossTileID) continue;
      let s5 = this._symbolsByKey[a4.key];
      if (!s5) continue;
      let u5 = this.getScaledCoordinates(a4, t);
      if (s5.index) {
        let c = s5.index.range(u5.x - n4, u5.y - n4, u5.x + n4, u5.y + n4).sort();
        for (let p4 of c) {
          let h = s5.crossTileIDs[p4];
          if (!i[h]) {
            i[h] = true, a4.crossTileID = h;
            break;
          }
        }
      } else if (s5.positions) for (let c = 0; c < s5.positions.length; c++) {
        let p4 = s5.positions[c], h = s5.crossTileIDs[c];
        if (Math.abs(p4.x - u5.x) <= n4 && Math.abs(p4.y - u5.y) <= n4 && !i[h]) {
          i[h] = true, a4.crossTileID = h;
          break;
        }
      }
    }
  }
  getCrossTileIDsLists() {
    return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
  }
};
H$3(my$1, "TileLayerIndex");
var py$1 = my$1, dy$1 = class dy {
  constructor() {
    this.maxCrossTileID = 0;
  }
  generate() {
    return ++this.maxCrossTileID;
  }
};
H$3(dy$1, "CrossTileIDs");
var hy$1 = dy$1, yy$1 = class yy {
  constructor() {
    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
  }
  handleWrapJump(e) {
    let t = Math.round((e - this.lng) / 360);
    if (t !== 0) for (let i in this.indexes) {
      let n4 = this.indexes[i], o4 = {};
      for (let a4 in n4) {
        let s5 = n4[a4];
        s5.tileID = s5.tileID.unwrapTo(s5.tileID.wrap + t), o4[s5.tileID.key] = s5;
      }
      this.indexes[i] = o4;
    }
    this.lng = e;
  }
  addBucket(e, t, i) {
    if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
      if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return false;
      this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
    }
    for (let o4 = 0; o4 < t.symbolInstances.length; o4++) {
      let a4 = t.symbolInstances.get(o4);
      a4.crossTileID = 0;
    }
    this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
    let n4 = this.usedCrossTileIDs[e.overscaledZ];
    for (let o4 in this.indexes) {
      let a4 = this.indexes[o4];
      if (Number(o4) > e.overscaledZ) for (let s5 in a4) {
        let u5 = a4[s5];
        u5.tileID.isChildOf(e) && u5.findMatches(t.symbolInstances, e, n4);
      }
      else {
        let s5 = e.scaledTo(Number(o4)), u5 = a4[s5.key];
        u5 && u5.findMatches(t.symbolInstances, e, n4);
      }
    }
    for (let o4 = 0; o4 < t.symbolInstances.length; o4++) {
      let a4 = t.symbolInstances.get(o4);
      a4.crossTileID || (a4.crossTileID = i.generate(), n4[a4.crossTileID] = true);
    }
    return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new py$1(e, t.symbolInstances, t.bucketInstanceId), true;
  }
  removeBucketCrossTileIDs(e, t) {
    for (let i of t.getCrossTileIDsLists()) for (let n4 of i) delete this.usedCrossTileIDs[e][n4];
  }
  removeStaleBuckets(e) {
    let t = false;
    for (let i in this.indexes) {
      let n4 = this.indexes[i];
      for (let o4 in n4) e[n4[o4].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, n4[o4]), delete n4[o4], t = true);
    }
    return t;
  }
};
H$3(yy$1, "CrossTileSymbolLayerIndex");
var fy = yy$1, gy$1 = class gy {
  constructor() {
    this.layerIndexes = {}, this.crossTileIDs = new hy$1(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
  }
  addLayer(e, t, i) {
    let n4 = this.layerIndexes[e.id];
    n4 === void 0 && (n4 = this.layerIndexes[e.id] = new fy());
    let o4 = false, a4 = {};
    n4.handleWrapJump(i);
    for (let s5 of t) {
      let u5 = s5.getBucket(e);
      !u5 || e.id !== u5.layerIds[0] || (u5.bucketInstanceId || (u5.bucketInstanceId = ++this.maxBucketInstanceId), n4.addBucket(s5.tileID, u5, this.crossTileIDs) && (o4 = true), a4[u5.bucketInstanceId] = true);
    }
    return n4.removeStaleBuckets(a4) && (o4 = true), o4;
  }
  pruneUnusedLayers(e) {
    let t = {};
    e.forEach((i) => {
      t[i] = true;
    });
    for (let i in this.layerIndexes) t[i] || delete this.layerIndexes[i];
  }
};
H$3(gy$1, "CrossTileSymbolIndex");
var Pn$2 = gy$1;
var Bu$1 = H$3((r5, e) => Wi$1(r5, e && e.filter((t) => t.identifier !== "source.canvas")), "emitValidationErrors"), SL$1 = l_(), xy$1 = class xy extends de$1 {
  constructor(t, i = {}) {
    super();
    this._rtlPluginLoaded = H$3(() => {
      for (let t5 in this.sourceCaches) {
        let i5 = this.sourceCaches[t5].getSource().type;
        (i5 === "vector" || i5 === "geojson") && this.sourceCaches[t5].reload();
      }
    }, "_rtlPluginLoaded");
    this.map = t, this.dispatcher = new ua$1(la$1(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", (n4, o4) => this.getGlyphs(n4, o4)), this.dispatcher.registerMessageHandler("GI", (n4, o4) => this.getImages(n4, o4)), this.imageManager = new su$1(), this.imageManager.setEventedParent(this), this.glyphManager = new lu$1(t._requestManager, i.localIdeographFontFamily), this.lineAtlas = new cu$1(256, 512), this.crossTileSymbolIndex = new Pn$2(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new Ji(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", us$1()), Vr$1().on(ga$1, this._rtlPluginLoaded), this.on("data", (n4) => {
      if (n4.dataType !== "source" || n4.sourceDataType !== "metadata") return;
      let o4 = this.sourceCaches[n4.sourceId];
      if (!o4) return;
      let a4 = o4.getSource();
      if (!(!a4 || !a4.vectorLayerIds)) for (let s5 in this._layers) {
        let u5 = this._layers[s5];
        u5.source === a4.id && this._validateLayer(u5);
      }
    });
  }
  loadURL(t, i = {}, n4) {
    this.fire(new F("dataloading", { dataType: "style" })), i.validate = typeof i.validate == "boolean" ? i.validate : true;
    let o4 = this.map._requestManager.transformRequest(t, "Style");
    this._loadStyleRequest = new AbortController(), gr$1(o4, this._loadStyleRequest).then((a4) => {
      this._loadStyleRequest = null, this._load(a4.data, i, n4);
    }).catch((a4) => {
      this._loadStyleRequest = null, a4 && this.fire(new H$2(a4));
    });
  }
  loadJSON(t, i = {}, n4) {
    this.fire(new F("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), Y$1.frameAsync(this._frameRequest).then(() => {
      this._frameRequest = null, i.validate = i.validate !== false, this._load(t, i, n4);
    }).catch(() => {
    });
  }
  loadEmpty() {
    this.fire(new F("dataloading", { dataType: "style" })), this._load(SL$1, { validate: false });
  }
  _load(t, i, n4) {
    var a4;
    let o4 = i.transformStyle ? i.transformStyle(n4, t) : t;
    if (!(i.validate && Bu$1(this, Ne$1(o4)))) {
      this._loaded = true, this.stylesheet = o4;
      for (let s5 in o4.sources) this.addSource(s5, o4.sources[s5], { validate: false });
      o4.sprite ? this._loadSprite(o4.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o4.glyphs), this._createLayers(), this.light = new uu$1(this.stylesheet.light), this.map.setTerrain((a4 = this.stylesheet.terrain) != null ? a4 : null), this.fire(new F("data", { dataType: "style" })), this.fire(new F("style.load"));
    }
  }
  _createLayers() {
    let t = ih$1(this.stylesheet.layers);
    this.dispatcher.broadcast("SL", t), this._order = t.map((i) => i.id), this._layers = {}, this._serializedLayers = null;
    for (let i of t) {
      let n4 = ou$1(i);
      n4.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = n4;
    }
  }
  _loadSprite(t, i = false, n4 = void 0) {
    this.imageManager.setLoaded(false), this._spriteRequest = new AbortController();
    let o4;
    q0(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((a4) => {
      if (this._spriteRequest = null, a4) for (let s5 in a4) {
        this._spritesImagesIds[s5] = [];
        let u5 = this._spritesImagesIds[s5] ? this._spritesImagesIds[s5].filter((c) => !(c in a4)) : [];
        for (let c of u5) this.imageManager.removeImage(c), this._changedImages[c] = true;
        for (let c in a4[s5]) {
          let p4 = s5 === "default" ? c : "".concat(s5, ":").concat(c);
          this._spritesImagesIds[s5].push(p4), p4 in this.imageManager.images ? this.imageManager.updateImage(p4, a4[s5][c], false) : this.imageManager.addImage(p4, a4[s5][c]), i && (this._changedImages[p4] = true);
        }
      }
    }).catch((a4) => {
      this._spriteRequest = null, o4 = a4, this.fire(new H$2(o4));
    }).finally(() => {
      this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" })), n4 && n4(o4);
    });
  }
  _unloadSprite() {
    for (let t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = true;
    this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" }));
  }
  _validateLayer(t) {
    let i = this.sourceCaches[t.source];
    if (!i) return;
    let n4 = t.sourceLayer;
    if (!n4) return;
    let o4 = i.getSource();
    (o4.type === "geojson" || o4.vectorLayerIds && o4.vectorLayerIds.indexOf(n4) === -1) && this.fire(new H$2(new Error('Source layer "'.concat(n4, '" ') + 'does not exist on source "'.concat(o4.id, '" ') + 'as specified by style layer "'.concat(t.id, '".'))));
  }
  loaded() {
    if (!this._loaded || Object.keys(this._updatedSources).length) return false;
    for (let t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return false;
    return !!this.imageManager.isLoaded();
  }
  _serializeByIds(t) {
    let i = this._serializedAllLayers();
    if (!t || t.length === 0) return Object.values(i);
    let n4 = [];
    for (let o4 of t) i[o4] && n4.push(i[o4]);
    return n4;
  }
  _serializedAllLayers() {
    let t = this._serializedLayers;
    if (t) return t;
    t = this._serializedLayers = {};
    let i = Object.keys(this._layers);
    for (let n4 of i) {
      let o4 = this._layers[n4];
      o4.type !== "custom" && (t[n4] = o4.serialize());
    }
    return t;
  }
  hasTransitions() {
    if (this.light && this.light.hasTransition()) return true;
    for (let t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return true;
    for (let t in this._layers) if (this._layers[t].hasTransition()) return true;
    return false;
  }
  _checkLoaded() {
    if (!this._loaded) throw new Error("Style is not done loading.");
  }
  update(t) {
    if (!this._loaded) return;
    let i = this._changed;
    if (i) {
      let o4 = Object.keys(this._updatedLayers), a4 = Object.keys(this._removedLayers);
      (o4.length || a4.length) && this._updateWorkerLayers(o4, a4);
      for (let s5 in this._updatedSources) {
        let u5 = this._updatedSources[s5];
        if (u5 === "reload") this._reloadSource(s5);
        else if (u5 === "clear") this._clearSource(s5);
        else throw new Error("Invalid action ".concat(u5));
      }
      this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
      for (let s5 in this._updatedPaintProps) this._layers[s5].updateTransitions(t);
      this.light.updateTransitions(t), this._resetUpdates();
    }
    let n4 = {};
    for (let o4 in this.sourceCaches) {
      let a4 = this.sourceCaches[o4];
      n4[o4] = a4.used, a4.used = false;
    }
    for (let o4 of this._order) {
      let a4 = this._layers[o4];
      a4.recalculate(t, this._availableImages), !a4.isHidden(t.zoom) && a4.source && (this.sourceCaches[a4.source].used = true);
    }
    for (let o4 in n4) {
      let a4 = this.sourceCaches[o4];
      !!n4[o4] != !!a4.used && a4.fire(new F("data", { sourceDataType: "visibility", dataType: "source", sourceId: o4 }));
    }
    this.light.recalculate(t), this.z = t.zoom, i && this.fire(new F("data", { dataType: "style" }));
  }
  _updateTilesForChangedImages() {
    let t = Object.keys(this._changedImages);
    if (t.length) {
      for (let i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], t);
      this._changedImages = {};
    }
  }
  _updateTilesForChangedGlyphs() {
    if (this._glyphsDidChange) {
      for (let t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["glyphs"], [""]);
      this._glyphsDidChange = false;
    }
  }
  _updateWorkerLayers(t, i) {
    this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t), removedIds: i });
  }
  _resetUpdates() {
    this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
  }
  setState(t, i = {}) {
    var u5;
    this._checkLoaded();
    let n4 = this.serialize();
    if (t = i.transformStyle ? i.transformStyle(n4, t) : t, ((u5 = i.validate) != null ? u5 : true) && Bu$1(this, Ne$1(t))) return false;
    t = pt$1(t), t.layers = ih$1(t.layers);
    let a4 = Nb(n4, t), s5 = this._getOperationsToPerform(a4);
    if (s5.unimplemented.length > 0) throw new Error("Unimplemented: ".concat(s5.unimplemented.join(", "), "."));
    if (s5.operations.length === 0) return false;
    for (let c of s5.operations) c();
    return this.stylesheet = t, this._serializedLayers = null, true;
  }
  _getOperationsToPerform(t) {
    let i = [], n4 = [];
    for (let o4 of t) switch (o4.command) {
      case "setCenter":
      case "setZoom":
      case "setBearing":
      case "setPitch":
        continue;
      case "addLayer":
        i.push(() => this.addLayer.apply(this, o4.args));
        break;
      case "removeLayer":
        i.push(() => this.removeLayer.apply(this, o4.args));
        break;
      case "setPaintProperty":
        i.push(() => this.setPaintProperty.apply(this, o4.args));
        break;
      case "setLayoutProperty":
        i.push(() => this.setLayoutProperty.apply(this, o4.args));
        break;
      case "setFilter":
        i.push(() => this.setFilter.apply(this, o4.args));
        break;
      case "addSource":
        i.push(() => this.addSource.apply(this, o4.args));
        break;
      case "removeSource":
        i.push(() => this.removeSource.apply(this, o4.args));
        break;
      case "setLayerZoomRange":
        i.push(() => this.setLayerZoomRange.apply(this, o4.args));
        break;
      case "setLight":
        i.push(() => this.setLight.apply(this, o4.args));
        break;
      case "setGeoJSONSourceData":
        i.push(() => this.setGeoJSONSourceData.apply(this, o4.args));
        break;
      case "setGlyphs":
        i.push(() => this.setGlyphs.apply(this, o4.args));
        break;
      case "setSprite":
        i.push(() => this.setSprite.apply(this, o4.args));
        break;
      case "setTerrain":
        i.push(() => this.map.setTerrain.apply(this, o4.args));
        break;
      case "setTransition":
        i.push(() => {
        });
        break;
      default:
        n4.push(o4.command);
        break;
    }
    return { operations: i, unimplemented: n4 };
  }
  addImage(t, i) {
    if (this.getImage(t)) return this.fire(new H$2(new Error('An image named "'.concat(t, '" already exists.'))));
    this.imageManager.addImage(t, i), this._afterImageUpdated(t);
  }
  updateImage(t, i) {
    this.imageManager.updateImage(t, i);
  }
  getImage(t) {
    return this.imageManager.getImage(t);
  }
  removeImage(t) {
    if (!this.getImage(t)) return this.fire(new H$2(new Error('An image named "'.concat(t, '" does not exist.'))));
    this.imageManager.removeImage(t), this._afterImageUpdated(t);
  }
  _afterImageUpdated(t) {
    this._availableImages = this.imageManager.listImages(), this._changedImages[t] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" }));
  }
  listImages() {
    return this._checkLoaded(), this.imageManager.listImages();
  }
  addSource(t, i, n4 = {}) {
    if (this._checkLoaded(), this.sourceCaches[t] !== void 0) throw new Error('Source "'.concat(t, '" already exists.'));
    if (!i.type) throw new Error("The type property must be defined, but only the following properties were given: ".concat(Object.keys(i).join(", "), "."));
    if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(Ne$1.source, "sources.".concat(t), i, null, n4)) return;
    this.map && this.map._collectResourceTiming && (i.collectResourceTiming = true);
    let s5 = this.sourceCaches[t] = new cr(t, i, this.dispatcher);
    s5.style = this, s5.setEventedParent(this, () => ({ isSourceLoaded: s5.loaded(), source: s5.serialize(), sourceId: t })), s5.onAdd(this.map), this._changed = true;
  }
  removeSource(t) {
    if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error("There is no source with this ID");
    for (let n4 in this._layers) if (this._layers[n4].source === t) return this.fire(new H$2(new Error('Source "'.concat(t, '" cannot be removed while layer "').concat(n4, '" is using it.'))));
    let i = this.sourceCaches[t];
    delete this.sourceCaches[t], delete this._updatedSources[t], i.fire(new F("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), i.setEventedParent(null), i.onRemove(this.map), this._changed = true;
  }
  setGeoJSONSourceData(t, i) {
    if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error("There is no source with this ID=".concat(t));
    let n4 = this.sourceCaches[t].getSource();
    if (n4.type !== "geojson") throw new Error("geojsonSource.type is ".concat(n4.type, ", which is !== 'geojson"));
    n4.setData(i), this._changed = true;
  }
  getSource(t) {
    return this.sourceCaches[t] && this.sourceCaches[t].getSource();
  }
  addLayer(t, i, n4 = {}) {
    this._checkLoaded();
    let o4 = t.id;
    if (this.getLayer(o4)) {
      this.fire(new H$2(new Error('Layer "'.concat(o4, '" already exists on this map.'))));
      return;
    }
    let a4;
    if (t.type === "custom") {
      if (Bu$1(this, G0(t))) return;
      a4 = ou$1(t);
    } else {
      if ("source" in t && typeof t.source == "object" && (this.addSource(o4, t.source), t = pt$1(t), t = V$1(t, { source: o4 })), this._validate(Ne$1.layer, "layers.".concat(o4), t, { arrayIndex: -1 }, n4)) return;
      a4 = ou$1(t), this._validateLayer(a4), a4.setEventedParent(this, { layer: { id: o4 } });
    }
    let s5 = i ? this._order.indexOf(i) : this._order.length;
    if (i && s5 === -1) {
      this.fire(new H$2(new Error('Cannot add layer "'.concat(o4, '" before non-existing layer "').concat(i, '".'))));
      return;
    }
    if (this._order.splice(s5, 0, o4), this._layerOrderChanged = true, this._layers[o4] = a4, this._removedLayers[o4] && a4.source && a4.type !== "custom") {
      let u5 = this._removedLayers[o4];
      delete this._removedLayers[o4], u5.type !== a4.type ? this._updatedSources[a4.source] = "clear" : (this._updatedSources[a4.source] = "reload", this.sourceCaches[a4.source].pause());
    }
    this._updateLayer(a4), a4.onAdd && a4.onAdd(this.map);
  }
  moveLayer(t, i) {
    if (this._checkLoaded(), this._changed = true, !this._layers[t]) {
      this.fire(new H$2(new Error("The layer '".concat(t, "' does not exist in the map's style and cannot be moved."))));
      return;
    }
    if (t === i) return;
    let o4 = this._order.indexOf(t);
    this._order.splice(o4, 1);
    let a4 = i ? this._order.indexOf(i) : this._order.length;
    if (i && a4 === -1) {
      this.fire(new H$2(new Error('Cannot move layer "'.concat(t, '" before non-existing layer "').concat(i, '".'))));
      return;
    }
    this._order.splice(a4, 0, t), this._layerOrderChanged = true;
  }
  removeLayer(t) {
    this._checkLoaded();
    let i = this._layers[t];
    if (!i) {
      this.fire(new H$2(new Error('Cannot remove non-existing layer "'.concat(t, '".'))));
      return;
    }
    i.setEventedParent(null);
    let n4 = this._order.indexOf(t);
    this._order.splice(n4, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t] = i, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i.onRemove && i.onRemove(this.map);
  }
  getLayer(t) {
    return this._layers[t];
  }
  getLayersOrder() {
    return [...this._order];
  }
  hasLayer(t) {
    return t in this._layers;
  }
  setLayerZoomRange(t, i, n4) {
    this._checkLoaded();
    let o4 = this.getLayer(t);
    if (!o4) {
      this.fire(new H$2(new Error('Cannot set the zoom range of non-existing layer "'.concat(t, '".'))));
      return;
    }
    o4.minzoom === i && o4.maxzoom === n4 || (i != null && (o4.minzoom = i), n4 != null && (o4.maxzoom = n4), this._updateLayer(o4));
  }
  setFilter(t, i, n4 = {}) {
    this._checkLoaded();
    let o4 = this.getLayer(t);
    if (!o4) {
      this.fire(new H$2(new Error('Cannot filter non-existing layer "'.concat(t, '".'))));
      return;
    }
    if (!Qt$1(o4.filter, i)) {
      if (i == null) {
        o4.filter = void 0, this._updateLayer(o4);
        return;
      }
      this._validate(Ne$1.filter, "layers.".concat(o4.id, ".filter"), i, null, n4) || (o4.filter = pt$1(i), this._updateLayer(o4));
    }
  }
  getFilter(t) {
    return pt$1(this.getLayer(t).filter);
  }
  setLayoutProperty(t, i, n4, o4 = {}) {
    this._checkLoaded();
    let a4 = this.getLayer(t);
    if (!a4) {
      this.fire(new H$2(new Error('Cannot style non-existing layer "'.concat(t, '".'))));
      return;
    }
    Qt$1(a4.getLayoutProperty(i), n4) || (a4.setLayoutProperty(i, n4, o4), this._updateLayer(a4));
  }
  getLayoutProperty(t, i) {
    let n4 = this.getLayer(t);
    if (!n4) {
      this.fire(new H$2(new Error('Cannot get style of non-existing layer "'.concat(t, '".'))));
      return;
    }
    return n4.getLayoutProperty(i);
  }
  setPaintProperty(t, i, n4, o4 = {}) {
    this._checkLoaded();
    let a4 = this.getLayer(t);
    if (!a4) {
      this.fire(new H$2(new Error('Cannot style non-existing layer "'.concat(t, '".'))));
      return;
    }
    if (Qt$1(a4.getPaintProperty(i), n4)) return;
    a4.setPaintProperty(i, n4, o4) && this._updateLayer(a4), this._changed = true, this._updatedPaintProps[t] = true, this._serializedLayers = null;
  }
  getPaintProperty(t, i) {
    return this.getLayer(t).getPaintProperty(i);
  }
  setFeatureState(t, i) {
    this._checkLoaded();
    let n4 = t.source, o4 = t.sourceLayer, a4 = this.sourceCaches[n4];
    if (a4 === void 0) {
      this.fire(new H$2(new Error("The source '".concat(n4, "' does not exist in the map's style."))));
      return;
    }
    let s5 = a4.getSource().type;
    if (s5 === "geojson" && o4) {
      this.fire(new H$2(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
      return;
    }
    if (s5 === "vector" && !o4) {
      this.fire(new H$2(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    t.id === void 0 && this.fire(new H$2(new Error("The feature id parameter must be provided."))), a4.setFeatureState(o4, t.id, i);
  }
  removeFeatureState(t, i) {
    this._checkLoaded();
    let n4 = t.source, o4 = this.sourceCaches[n4];
    if (o4 === void 0) {
      this.fire(new H$2(new Error("The source '".concat(n4, "' does not exist in the map's style."))));
      return;
    }
    let a4 = o4.getSource().type, s5 = a4 === "vector" ? t.sourceLayer : void 0;
    if (a4 === "vector" && !s5) {
      this.fire(new H$2(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    if (i && typeof t.id != "string" && typeof t.id != "number") {
      this.fire(new H$2(new Error("A feature id is required to remove its specific state property.")));
      return;
    }
    o4.removeFeatureState(s5, t.id, i);
  }
  getFeatureState(t) {
    this._checkLoaded();
    let i = t.source, n4 = t.sourceLayer, o4 = this.sourceCaches[i];
    if (o4 === void 0) {
      this.fire(new H$2(new Error("The source '".concat(i, "' does not exist in the map's style."))));
      return;
    }
    if (o4.getSource().type === "vector" && !n4) {
      this.fire(new H$2(new Error("The sourceLayer parameter must be provided for vector source types.")));
      return;
    }
    return t.id === void 0 && this.fire(new H$2(new Error("The feature id parameter must be provided."))), o4.getFeatureState(n4, t.id);
  }
  getTransition() {
    return V$1({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
  }
  serialize() {
    if (!this._loaded) return;
    let t = Dn(this.sourceCaches, (a4) => a4.serialize()), i = this._serializeByIds(this._order), n4 = this.map.getTerrain() || void 0, o4 = this.stylesheet;
    return os$1({ version: o4.version, name: o4.name, metadata: o4.metadata, light: o4.light, center: o4.center, zoom: o4.zoom, bearing: o4.bearing, pitch: o4.pitch, sprite: o4.sprite, glyphs: o4.glyphs, transition: o4.transition, sources: t, layers: i, terrain: n4 }, (a4) => a4 !== void 0);
  }
  _updateLayer(t) {
    this._updatedLayers[t.id] = true, t.source && !this._updatedSources[t.source] && this.sourceCaches[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._serializedLayers = null, this._changed = true;
  }
  _flattenAndSortRenderedFeatures(t) {
    let i = H$3((s5) => this._layers[s5].type === "fill-extrusion", "isLayer3D"), n4 = {}, o4 = [];
    for (let s5 = this._order.length - 1; s5 >= 0; s5--) {
      let u5 = this._order[s5];
      if (i(u5)) {
        n4[u5] = s5;
        for (let c of t) {
          let p4 = c[u5];
          if (p4) for (let h of p4) o4.push(h);
        }
      }
    }
    o4.sort((s5, u5) => u5.intersectionZ - s5.intersectionZ);
    let a4 = [];
    for (let s5 = this._order.length - 1; s5 >= 0; s5--) {
      let u5 = this._order[s5];
      if (i(u5)) for (let c = o4.length - 1; c >= 0; c--) {
        let p4 = o4[c].feature;
        if (n4[p4.layer.id] < s5) break;
        a4.push(p4), o4.pop();
      }
      else for (let c of t) {
        let p4 = c[u5];
        if (p4) for (let h of p4) a4.push(h.feature);
      }
    }
    return a4;
  }
  queryRenderedFeatures(t, i, n4) {
    i && i.filter && this._validate(Ne$1.filter, "queryRenderedFeatures.filter", i.filter, null, i);
    let o4 = {};
    if (i && i.layers) {
      if (!Array.isArray(i.layers)) return this.fire(new H$2(new Error("parameters.layers must be an Array."))), [];
      for (let u5 of i.layers) {
        let c = this._layers[u5];
        if (!c) return this.fire(new H$2(new Error("The layer '".concat(u5, "' does not exist in the map's style and cannot be queried for features.")))), [];
        o4[c.source] = true;
      }
    }
    let a4 = [];
    i.availableImages = this._availableImages;
    let s5 = this._serializedAllLayers();
    for (let u5 in this.sourceCaches) i.layers && !o4[u5] || a4.push(J0(this.sourceCaches[u5], this._layers, s5, t, i, n4));
    return this.placement && a4.push(Y0(this._layers, s5, this.sourceCaches, t, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a4);
  }
  querySourceFeatures(t, i) {
    i && i.filter && this._validate(Ne$1.filter, "querySourceFeatures.filter", i.filter, null, i);
    let n4 = this.sourceCaches[t];
    return n4 ? Q0(n4, i) : [];
  }
  getLight() {
    return this.light.getLight();
  }
  setLight(t, i = {}) {
    this._checkLoaded();
    let n4 = this.light.getLight(), o4 = false;
    for (let s5 in t) if (!Qt$1(t[s5], n4[s5])) {
      o4 = true;
      break;
    }
    if (!o4) return;
    let a4 = { now: Y$1.now(), transition: V$1({ duration: 300, delay: 0 }, this.stylesheet.transition) };
    this.light.setLight(t, i), this.light.updateTransitions(a4);
  }
  _validate(t, i, n4, o4, a4 = {}) {
    return a4 && a4.validate === false ? false : Bu$1(this, t.call(Ne$1, V$1({ key: i, style: this.serialize(), value: n4, styleSpec: A$1 }, o4)));
  }
  _remove(t = true) {
    this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Vr$1().off(ga$1, this._rtlPluginLoaded);
    for (let i in this._layers) this._layers[i].setEventedParent(null);
    for (let i in this.sourceCaches) {
      let n4 = this.sourceCaches[i];
      n4.setEventedParent(null), n4.onRemove(this.map);
    }
    this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
  }
  _clearSource(t) {
    this.sourceCaches[t].clearTiles();
  }
  _reloadSource(t) {
    this.sourceCaches[t].resume(), this.sourceCaches[t].reload();
  }
  _updateSources(t) {
    for (let i in this.sourceCaches) this.sourceCaches[i].update(t, this.map.terrain);
  }
  _generateCollisionBoxes() {
    for (let t in this.sourceCaches) this._reloadSource(t);
  }
  _updatePlacement(t, i, n4, o4, a4 = false) {
    let s5 = false, u5 = false, c = {};
    for (let h of this._order) {
      let f = this._layers[h];
      if (f.type !== "symbol") continue;
      if (!c[f.source]) {
        let y4 = this.sourceCaches[f.source];
        c[f.source] = y4.getRenderableIds(true).map((g) => y4.getTileByID(g)).sort((g, x2) => x2.tileID.overscaledZ - g.tileID.overscaledZ || (g.tileID.isLessThan(x2.tileID) ? -1 : 1));
      }
      let m5 = this.crossTileSymbolIndex.addLayer(f, c[f.source], t.center.lng);
      s5 = s5 || m5;
    }
    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), a4 = a4 || this._layerOrderChanged || n4 === 0, (a4 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(Y$1.now(), t.zoom)) && (this.pauseablePlacement = new Fu$1(t, this.map.terrain, this._order, a4, i, n4, o4, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, c), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(Y$1.now()), u5 = true), s5 && this.pauseablePlacement.placement.setStale()), u5 || s5) for (let h of this._order) {
      let f = this._layers[h];
      f.type === "symbol" && this.placement.updateLayerOpacities(f, c[f.source]);
    }
    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(Y$1.now());
  }
  _releaseSymbolFadeTiles() {
    for (let t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles();
  }
  async getImages(t, i) {
    let n4 = await this.imageManager.getImages(i.icons);
    this._updateTilesForChangedImages();
    let o4 = this.sourceCaches[i.source];
    return o4 && o4.setDependencies(i.tileID.key, i.type, i.icons), n4;
  }
  async getGlyphs(t, i) {
    let n4 = await this.glyphManager.getGlyphs(i.stacks), o4 = this.sourceCaches[i.source];
    return o4 && o4.setDependencies(i.tileID.key, i.type, [""]), n4;
  }
  getGlyphsUrl() {
    return this.stylesheet.glyphs || null;
  }
  setGlyphs(t, i = {}) {
    this._checkLoaded(), !(t && this._validate(Ne$1.glyphs, "glyphs", t, null, i)) && (this._glyphsDidChange = true, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
  }
  addSprite(t, i, n4 = {}, o4) {
    this._checkLoaded();
    let a4 = [{ id: t, url: i }], s5 = [...gn(this.stylesheet.sprite), ...a4];
    this._validate(Ne$1.sprite, "sprite", s5, null, n4) || (this.stylesheet.sprite = s5, this._loadSprite(a4, true, o4));
  }
  removeSprite(t) {
    this._checkLoaded();
    let i = gn(this.stylesheet.sprite);
    if (!i.find((n4) => n4.id === t)) {
      this.fire(new H$2(new Error('Sprite "'.concat(t, `" doesn't exists on this map.`))));
      return;
    }
    if (this._spritesImagesIds[t]) for (let n4 of this._spritesImagesIds[t]) this.imageManager.removeImage(n4), this._changedImages[n4] = true;
    i.splice(i.findIndex((n4) => n4.id === t), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new F("data", { dataType: "style" }));
  }
  getSprite() {
    return gn(this.stylesheet.sprite);
  }
  setSprite(t, i = {}, n4) {
    this._checkLoaded(), !(t && this._validate(Ne$1.sprite, "sprite", t, null, i)) && (this.stylesheet.sprite = t, t ? this._loadSprite(t, true, n4) : (this._unloadSprite(), n4 && n4(null)));
  }
};
H$3(xy$1, "Style");
var Tn$1 = xy$1;
a();
a();
var Ou$1 = _e$1([{ name: "a_pos", type: "Int16", components: 2 }]);
a();
a();
var A1$1 = "#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n";
a();
var I1$1 = "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}";
a();
var C1$1 = "uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var E1$1 = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
a();
var k1$1 = "uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var L1$1 = "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}";
a();
var D1$1 = "varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var z1$1 = "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}";
a();
var F1$1 = "void main() {gl_FragColor=vec4(1.0);}";
a();
var R1$1 = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
a();
var B1$1 = "uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var O1$1 = "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}";
a();
var V1$1 = "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}";
a();
var U1$1 = "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}";
a();
var N1$1 = "varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}";
a();
var G1$1 = "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}";
a();
var q1$1 = "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}";
a();
var j1$1 = "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}";
a();
var Z1$1 = "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}";
a();
var H1$1 = "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}";
a();
var $1$1 = "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var W1$1 = "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}";
a();
var X1$1 = "varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var K1$1 = "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";
a();
var J1$1 = "uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var Y1$1 = "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";
a();
var Q1$1 = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var ew$1 = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}";
a();
var tw$1 = "varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var rw = "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}";
a();
var iw = "uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var nw = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}";
a();
var ow = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var aw = "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}";
a();
var sw = "uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var lw = "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}";
a();
var uw = "uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var cw = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}";
a();
var pw = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var hw = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}";
a();
var fw = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var mw = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}";
a();
var dw = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var yw = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}";
a();
var gw = "uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var xw = "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}";
a();
var bw = "uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var _w = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}";
a();
var vw = "#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var ww = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}";
a();
var Sw = "#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
a();
var Pw = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}";
a();
var Tw = "varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}";
a();
var Mw = "precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}";
a();
var Aw = "uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}";
a();
var Vu$1 = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
var Ti$2 = { prelude: Ee$1(A1$1, I1$1), background: Ee$1(C1$1, E1$1), backgroundPattern: Ee$1(k1$1, L1$1), circle: Ee$1(D1$1, z1$1), clippingMask: Ee$1(F1$1, R1$1), heatmap: Ee$1(B1$1, O1$1), heatmapTexture: Ee$1(V1$1, U1$1), collisionBox: Ee$1(N1$1, G1$1), collisionCircle: Ee$1(q1$1, j1$1), debug: Ee$1(Z1$1, H1$1), fill: Ee$1($1$1, W1$1), fillOutline: Ee$1(X1$1, K1$1), fillOutlinePattern: Ee$1(J1$1, Y1$1), fillPattern: Ee$1(Q1$1, ew$1), fillExtrusion: Ee$1(tw$1, rw), fillExtrusionPattern: Ee$1(iw, nw), hillshadePrepare: Ee$1(ow, aw), hillshade: Ee$1(sw, lw), line: Ee$1(uw, cw), lineGradient: Ee$1(pw, hw), linePattern: Ee$1(fw, mw), lineSDF: Ee$1(dw, yw), raster: Ee$1(gw, xw), symbolIcon: Ee$1(bw, _w), symbolSDF: Ee$1(vw, ww), symbolTextAndIcon: Ee$1(Sw, Pw), terrain: Ee$1(Aw, Vu$1), terrainDepth: Ee$1(Tw, Vu$1), terrainCoords: Ee$1(Mw, Vu$1) };
function Ee$1(r5, e) {
  let t = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, i = e.match(/attribute ([\w]+) ([\w]+)/g), n4 = r5.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o4 = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a4 = o4 ? o4.concat(n4) : n4, s5 = {};
  return r5 = r5.replace(t, (u5, c, p4, h, f) => (s5[f] = true, c === "define" ? "\n#ifndef HAS_UNIFORM_u_".concat(f, "\nvarying ").concat(p4, " ").concat(h, " ").concat(f, ";\n#else\nuniform ").concat(p4, " ").concat(h, " u_").concat(f, ";\n#endif\n") : "\n#ifdef HAS_UNIFORM_u_".concat(f, "\n    ").concat(p4, " ").concat(h, " ").concat(f, " = u_").concat(f, ";\n#endif\n"))), e = e.replace(t, (u5, c, p4, h, f) => {
    let m5 = h === "float" ? "vec2" : "vec4", y4 = f.match(/color/) ? "color" : m5;
    return s5[f] ? c === "define" ? "\n#ifndef HAS_UNIFORM_u_".concat(f, "\nuniform lowp float u_").concat(f, "_t;\nattribute ").concat(p4, " ").concat(m5, " a_").concat(f, ";\nvarying ").concat(p4, " ").concat(h, " ").concat(f, ";\n#else\nuniform ").concat(p4, " ").concat(h, " u_").concat(f, ";\n#endif\n") : y4 === "vec4" ? "\n#ifndef HAS_UNIFORM_u_".concat(f, "\n    ").concat(f, " = a_").concat(f, ";\n#else\n    ").concat(p4, " ").concat(h, " ").concat(f, " = u_").concat(f, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(f, "\n    ").concat(f, " = unpack_mix_").concat(y4, "(a_").concat(f, ", u_").concat(f, "_t);\n#else\n    ").concat(p4, " ").concat(h, " ").concat(f, " = u_").concat(f, ";\n#endif\n") : c === "define" ? "\n#ifndef HAS_UNIFORM_u_".concat(f, "\nuniform lowp float u_").concat(f, "_t;\nattribute ").concat(p4, " ").concat(m5, " a_").concat(f, ";\n#else\nuniform ").concat(p4, " ").concat(h, " u_").concat(f, ";\n#endif\n") : y4 === "vec4" ? "\n#ifndef HAS_UNIFORM_u_".concat(f, "\n    ").concat(p4, " ").concat(h, " ").concat(f, " = a_").concat(f, ";\n#else\n    ").concat(p4, " ").concat(h, " ").concat(f, " = u_").concat(f, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(f, "\n    ").concat(p4, " ").concat(h, " ").concat(f, " = unpack_mix_").concat(y4, "(a_").concat(f, ", u_").concat(f, "_t);\n#else\n    ").concat(p4, " ").concat(h, " ").concat(f, " = u_").concat(f, ";\n#endif\n");
  }), { fragmentSource: r5, vertexSource: e, staticAttributes: i, staticUniforms: a4 };
}
H$3(Ee$1, "compile");
a();
a();
var by$1 = class by {
  constructor() {
    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
  }
  bind(e, t, i, n4, o4, a4, s5, u5, c) {
    this.context = e;
    let p4 = this.boundPaintVertexBuffers.length !== n4.length;
    for (let f = 0; !p4 && f < n4.length; f++) this.boundPaintVertexBuffers[f] !== n4[f] && (p4 = true);
    !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || p4 || this.boundIndexBuffer !== o4 || this.boundVertexOffset !== a4 || this.boundDynamicVertexBuffer !== s5 || this.boundDynamicVertexBuffer2 !== u5 || this.boundDynamicVertexBuffer3 !== c ? this.freshBind(t, i, n4, o4, a4, s5, u5, c) : (e.bindVertexArray.set(this.vao), s5 && s5.bind(), o4 && o4.dynamicDraw && o4.bind(), u5 && u5.bind(), c && c.bind());
  }
  freshBind(e, t, i, n4, o4, a4, s5, u5) {
    let c = e.numAttributes, p4 = this.context, h = p4.gl;
    this.vao && this.destroy(), this.vao = p4.createVertexArray(), p4.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = n4, this.boundVertexOffset = o4, this.boundDynamicVertexBuffer = a4, this.boundDynamicVertexBuffer2 = s5, this.boundDynamicVertexBuffer3 = u5, t.enableAttributes(h, e);
    for (let f of i) f.enableAttributes(h, e);
    a4 && a4.enableAttributes(h, e), s5 && s5.enableAttributes(h, e), u5 && u5.enableAttributes(h, e), t.bind(), t.setVertexAttribPointers(h, e, o4);
    for (let f of i) f.bind(), f.setVertexAttribPointers(h, e, o4);
    a4 && (a4.bind(), a4.setVertexAttribPointers(h, e, o4)), n4 && n4.bind(), s5 && (s5.bind(), s5.setVertexAttribPointers(h, e, o4)), u5 && (u5.bind(), u5.setVertexAttribPointers(h, e, o4)), p4.currentNumAttributes = c;
  }
  destroy() {
    this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
  }
};
H$3(by$1, "VertexArrayObject");
var Uu$1 = by$1;
a();
var Iw = H$3((r5, e) => ({ u_depth: new Q$2(r5, e.u_depth), u_terrain: new Q$2(r5, e.u_terrain), u_terrain_dim: new U$1(r5, e.u_terrain_dim), u_terrain_matrix: new re$3(r5, e.u_terrain_matrix), u_terrain_unpack: new Cr$1(r5, e.u_terrain_unpack), u_terrain_exaggeration: new U$1(r5, e.u_terrain_exaggeration) }), "terrainPreludeUniforms"), Cw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_texture: new Q$2(r5, e.u_texture), u_ele_delta: new U$1(r5, e.u_ele_delta) }), "terrainUniforms"), Ew = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_ele_delta: new U$1(r5, e.u_ele_delta) }), "terrainDepthUniforms"), kw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_texture: new Q$2(r5, e.u_texture), u_terrain_coords_id: new U$1(r5, e.u_terrain_coords_id), u_ele_delta: new U$1(r5, e.u_ele_delta) }), "terrainCoordsUniforms"), Lw = H$3((r5, e) => ({ u_matrix: r5, u_texture: 0, u_ele_delta: e }), "terrainUniformValues"), Dw = H$3((r5, e) => ({ u_matrix: r5, u_ele_delta: e }), "terrainDepthUniformValues"), zw = H$3((r5, e, t) => ({ u_matrix: r5, u_terrain_coords_id: e / 255, u_texture: 0, u_ele_delta: t }), "terrainCoordsUniformValues");
function _y$1(r5) {
  let e = [];
  for (let t = 0; t < r5.length; t++) {
    if (r5[t] === null) continue;
    let i = r5[t].split(" ");
    e.push(i.pop());
  }
  return e;
}
H$3(_y$1, "getTokenizedAttributesAndUniforms");
var vy$1 = class vy {
  constructor(e, t, i, n4, o4, a4) {
    let s5 = e.gl;
    this.program = s5.createProgram();
    let u5 = _y$1(t.staticAttributes), c = i ? i.getBinderAttributes() : [], p4 = u5.concat(c), h = Ti$2.prelude.staticUniforms ? _y$1(Ti$2.prelude.staticUniforms) : [], f = t.staticUniforms ? _y$1(t.staticUniforms) : [], m5 = i ? i.getBinderUniforms() : [], y4 = h.concat(f).concat(m5), g = [];
    for (let T3 of y4) g.indexOf(T3) < 0 && g.push(T3);
    let x2 = i ? i.defines() : [];
    o4 && x2.push("#define OVERDRAW_INSPECTOR;"), a4 && x2.push("#define TERRAIN3D;");
    let b = x2.concat(Ti$2.prelude.fragmentSource, t.fragmentSource).join("\n"), w3 = x2.concat(Ti$2.prelude.vertexSource, t.vertexSource).join("\n"), _ = s5.createShader(s5.FRAGMENT_SHADER);
    if (s5.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (s5.shaderSource(_, b), s5.compileShader(_), !s5.getShaderParameter(_, s5.COMPILE_STATUS)) throw new Error("Could not compile fragment shader: ".concat(s5.getShaderInfoLog(_)));
    s5.attachShader(this.program, _);
    let S4 = s5.createShader(s5.VERTEX_SHADER);
    if (s5.isContextLost()) {
      this.failedToCreate = true;
      return;
    }
    if (s5.shaderSource(S4, w3), s5.compileShader(S4), !s5.getShaderParameter(S4, s5.COMPILE_STATUS)) throw new Error("Could not compile vertex shader: ".concat(s5.getShaderInfoLog(S4)));
    s5.attachShader(this.program, S4), this.attributes = {};
    let P4 = {};
    this.numAttributes = p4.length;
    for (let T3 = 0; T3 < this.numAttributes; T3++) p4[T3] && (s5.bindAttribLocation(this.program, T3, p4[T3]), this.attributes[p4[T3]] = T3);
    if (s5.linkProgram(this.program), !s5.getProgramParameter(this.program, s5.LINK_STATUS)) throw new Error("Program failed to link: ".concat(s5.getProgramInfoLog(this.program)));
    s5.deleteShader(S4), s5.deleteShader(_);
    for (let T3 = 0; T3 < g.length; T3++) {
      let L3 = g[T3];
      if (L3 && !P4[L3]) {
        let C3 = s5.getUniformLocation(this.program, L3);
        C3 && (P4[L3] = C3);
      }
    }
    this.fixedUniforms = n4(e, P4), this.terrainUniforms = Iw(e, P4), this.binderUniforms = i ? i.getUniforms(e, P4) : [];
  }
  draw(e, t, i, n4, o4, a4, s5, u5, c, p4, h, f, m5, y4, g, x2, b, w3) {
    let _ = e.gl;
    if (this.failedToCreate) return;
    if (e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(n4), e.setColorMode(o4), e.setCullFace(a4), u5) {
      e.activeTexture.set(_.TEXTURE2), _.bindTexture(_.TEXTURE_2D, u5.depthTexture), e.activeTexture.set(_.TEXTURE3), _.bindTexture(_.TEXTURE_2D, u5.texture);
      for (let P4 in this.terrainUniforms) this.terrainUniforms[P4].set(u5[P4]);
    }
    for (let P4 in this.fixedUniforms) this.fixedUniforms[P4].set(s5[P4]);
    g && g.setUniforms(e, this.binderUniforms, m5, { zoom: y4 });
    let S4 = 0;
    switch (t) {
      case _.LINES:
        S4 = 2;
        break;
      case _.TRIANGLES:
        S4 = 3;
        break;
      case _.LINE_STRIP:
        S4 = 1;
        break;
    }
    for (let P4 of f.get()) {
      let T3 = P4.vaos || (P4.vaos = {});
      (T3[c] || (T3[c] = new Uu$1())).bind(e, this, p4, g ? g.getPaintVertexBuffers() : [], h, P4.vertexOffset, x2, b, w3), _.drawElements(t, P4.primitiveLength * S4, _.UNSIGNED_SHORT, P4.primitiveOffset * S4 * 2);
    }
  }
};
H$3(vy$1, "Program");
var Nu$1 = vy$1;
a();
a();
a();
function Gu$1(r5, e, t) {
  let i = 1 / $e$1(t, 1, e.transform.tileZoom), n4 = Math.pow(2, t.tileID.overscaledZ), o4 = t.tileSize * Math.pow(2, e.transform.tileZoom) / n4, a4 = o4 * (t.tileID.canonical.x + t.tileID.wrap * n4), s5 = o4 * t.tileID.canonical.y;
  return { u_image: 0, u_texsize: t.imageAtlasTexture.size, u_scale: [i, r5.fromScale, r5.toScale], u_fade: r5.t, u_pixel_coord_upper: [a4 >> 16, s5 >> 16], u_pixel_coord_lower: [a4 & 65535, s5 & 65535] };
}
H$3(Gu$1, "patternUniformValues");
function Fw(r5, e, t, i) {
  let n4 = t.imageManager.getPattern(r5.from.toString()), o4 = t.imageManager.getPattern(r5.to.toString()), { width: a4, height: s5 } = t.imageManager.getPixelSize(), u5 = Math.pow(2, i.tileID.overscaledZ), c = i.tileSize * Math.pow(2, t.transform.tileZoom) / u5, p4 = c * (i.tileID.canonical.x + i.tileID.wrap * u5), h = c * i.tileID.canonical.y;
  return { u_image: 0, u_pattern_tl_a: n4.tl, u_pattern_br_a: n4.br, u_pattern_tl_b: o4.tl, u_pattern_br_b: o4.br, u_texsize: [a4, s5], u_mix: e.t, u_pattern_size_a: n4.displaySize, u_pattern_size_b: o4.displaySize, u_scale_a: e.fromScale, u_scale_b: e.toScale, u_tile_units_to_pixels: 1 / $e$1(i, 1, t.transform.tileZoom), u_pixel_coord_upper: [p4 >> 16, h >> 16], u_pixel_coord_lower: [p4 & 65535, h & 65535] };
}
H$3(Fw, "bgPatternUniformValues");
var Rw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_lightpos: new lt$1(r5, e.u_lightpos), u_lightintensity: new U$1(r5, e.u_lightintensity), u_lightcolor: new lt$1(r5, e.u_lightcolor), u_vertical_gradient: new U$1(r5, e.u_vertical_gradient), u_opacity: new U$1(r5, e.u_opacity) }), "fillExtrusionUniforms"), Bw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_lightpos: new lt$1(r5, e.u_lightpos), u_lightintensity: new U$1(r5, e.u_lightintensity), u_lightcolor: new lt$1(r5, e.u_lightcolor), u_vertical_gradient: new U$1(r5, e.u_vertical_gradient), u_height_factor: new U$1(r5, e.u_height_factor), u_image: new Q$2(r5, e.u_image), u_texsize: new te$1(r5, e.u_texsize), u_pixel_coord_upper: new te$1(r5, e.u_pixel_coord_upper), u_pixel_coord_lower: new te$1(r5, e.u_pixel_coord_lower), u_scale: new lt$1(r5, e.u_scale), u_fade: new U$1(r5, e.u_fade), u_opacity: new U$1(r5, e.u_opacity) }), "fillExtrusionPatternUniforms"), wy = H$3((r5, e, t, i) => {
  let n4 = e.style.light, o4 = n4.properties.get("position"), a4 = [o4.x, o4.y, o4.z], s5 = Uo$1.create();
  n4.properties.get("anchor") === "viewport" && Uo$1.fromRotation(s5, -e.transform.angle), gt$1.transformMat3(a4, a4, s5);
  let u5 = n4.properties.get("color");
  return { u_matrix: r5, u_lightpos: a4, u_lightintensity: n4.properties.get("intensity"), u_lightcolor: [u5.r, u5.g, u5.b], u_vertical_gradient: +t, u_opacity: i };
}, "fillExtrusionUniformValues"), Ow = H$3((r5, e, t, i, n4, o4, a4) => V$1(wy(r5, e, t, i), Gu$1(o4, e, a4), { u_height_factor: -Math.pow(2, n4.overscaledZ) / a4.tileSize / 8 }), "fillExtrusionPatternUniformValues");
a();
var Vw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix) }), "fillUniforms"), Uw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_image: new Q$2(r5, e.u_image), u_texsize: new te$1(r5, e.u_texsize), u_pixel_coord_upper: new te$1(r5, e.u_pixel_coord_upper), u_pixel_coord_lower: new te$1(r5, e.u_pixel_coord_lower), u_scale: new lt$1(r5, e.u_scale), u_fade: new U$1(r5, e.u_fade) }), "fillPatternUniforms"), Nw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_world: new te$1(r5, e.u_world) }), "fillOutlineUniforms"), Gw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_world: new te$1(r5, e.u_world), u_image: new Q$2(r5, e.u_image), u_texsize: new te$1(r5, e.u_texsize), u_pixel_coord_upper: new te$1(r5, e.u_pixel_coord_upper), u_pixel_coord_lower: new te$1(r5, e.u_pixel_coord_lower), u_scale: new lt$1(r5, e.u_scale), u_fade: new U$1(r5, e.u_fade) }), "fillOutlinePatternUniforms"), Sy = H$3((r5) => ({ u_matrix: r5 }), "fillUniformValues"), Py$1 = H$3((r5, e, t, i) => V$1(Sy(r5), Gu$1(t, e, i)), "fillPatternUniformValues"), qw = H$3((r5, e) => ({ u_matrix: r5, u_world: e }), "fillOutlineUniformValues"), jw = H$3((r5, e, t, i, n4) => V$1(Py$1(r5, e, t, i), { u_world: n4 }), "fillOutlinePatternUniformValues");
a();
var Zw = H$3((r5, e) => ({ u_camera_to_center_distance: new U$1(r5, e.u_camera_to_center_distance), u_scale_with_map: new Q$2(r5, e.u_scale_with_map), u_pitch_with_map: new Q$2(r5, e.u_pitch_with_map), u_extrude_scale: new te$1(r5, e.u_extrude_scale), u_device_pixel_ratio: new U$1(r5, e.u_device_pixel_ratio), u_matrix: new re$3(r5, e.u_matrix) }), "circleUniforms"), Hw = H$3((r5, e, t, i) => {
  let n4 = r5.transform, o4, a4;
  if (i.paint.get("circle-pitch-alignment") === "map") {
    let s5 = $e$1(t, 1, n4.zoom);
    o4 = true, a4 = [s5, s5];
  } else o4 = false, a4 = n4.pixelsToGLUnits;
  return { u_camera_to_center_distance: n4.cameraToCenterDistance, u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"), u_matrix: r5.translatePosMatrix(e.posMatrix, t, i.paint.get("circle-translate"), i.paint.get("circle-translate-anchor")), u_pitch_with_map: +o4, u_device_pixel_ratio: r5.pixelRatio, u_extrude_scale: a4 };
}, "circleUniformValues");
a();
var $w = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_camera_to_center_distance: new U$1(r5, e.u_camera_to_center_distance), u_pixels_to_tile_units: new U$1(r5, e.u_pixels_to_tile_units), u_extrude_scale: new te$1(r5, e.u_extrude_scale), u_overscale_factor: new U$1(r5, e.u_overscale_factor) }), "collisionUniforms"), Ww = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_inv_matrix: new re$3(r5, e.u_inv_matrix), u_camera_to_center_distance: new U$1(r5, e.u_camera_to_center_distance), u_viewport_size: new te$1(r5, e.u_viewport_size) }), "collisionCircleUniforms"), Xw = H$3((r5, e, t) => {
  let i = $e$1(t, 1, e.zoom), n4 = Math.pow(2, e.zoom - t.tileID.overscaledZ), o4 = t.tileID.overscaleFactor();
  return { u_matrix: r5, u_camera_to_center_distance: e.cameraToCenterDistance, u_pixels_to_tile_units: i, u_extrude_scale: [e.pixelsToGLUnits[0] / (i * n4), e.pixelsToGLUnits[1] / (i * n4)], u_overscale_factor: o4 };
}, "collisionUniformValues"), Kw = H$3((r5, e, t) => ({ u_matrix: r5, u_inv_matrix: e, u_camera_to_center_distance: t.cameraToCenterDistance, u_viewport_size: [t.width, t.height] }), "collisionCircleUniformValues");
a();
var Jw = H$3((r5, e) => ({ u_color: new kt$1(r5, e.u_color), u_matrix: new re$3(r5, e.u_matrix), u_overlay: new Q$2(r5, e.u_overlay), u_overlay_scale: new U$1(r5, e.u_overlay_scale) }), "debugUniforms"), Ty = H$3((r5, e, t = 1) => ({ u_matrix: r5, u_color: e, u_overlay: 0, u_overlay_scale: t }), "debugUniformValues");
a();
var Yw = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix) }), "clippingMaskUniforms"), My = H$3((r5) => ({ u_matrix: r5 }), "clippingMaskUniformValues");
a();
var Qw = H$3((r5, e) => ({ u_extrude_scale: new U$1(r5, e.u_extrude_scale), u_intensity: new U$1(r5, e.u_intensity), u_matrix: new re$3(r5, e.u_matrix) }), "heatmapUniforms"), eS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_world: new te$1(r5, e.u_world), u_image: new Q$2(r5, e.u_image), u_color_ramp: new Q$2(r5, e.u_color_ramp), u_opacity: new U$1(r5, e.u_opacity) }), "heatmapTextureUniforms"), tS$1 = H$3((r5, e, t, i) => ({ u_matrix: r5, u_extrude_scale: $e$1(e, 1, t), u_intensity: i }), "heatmapUniformValues"), rS$1 = H$3((r5, e, t, i) => {
  let n4 = q$2.create();
  q$2.ortho(n4, 0, r5.width, r5.height, 0, 0, 1);
  let o4 = r5.context.gl;
  return { u_matrix: n4, u_world: [o4.drawingBufferWidth, o4.drawingBufferHeight], u_image: t, u_color_ramp: i, u_opacity: e.paint.get("heatmap-opacity") };
}, "heatmapTextureUniformValues");
a();
var iS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_image: new Q$2(r5, e.u_image), u_latrange: new te$1(r5, e.u_latrange), u_light: new te$1(r5, e.u_light), u_shadow: new kt$1(r5, e.u_shadow), u_highlight: new kt$1(r5, e.u_highlight), u_accent: new kt$1(r5, e.u_accent) }), "hillshadeUniforms"), nS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_image: new Q$2(r5, e.u_image), u_dimension: new te$1(r5, e.u_dimension), u_zoom: new U$1(r5, e.u_zoom), u_unpack: new Cr$1(r5, e.u_unpack) }), "hillshadePrepareUniforms"), oS$1 = H$3((r5, e, t, i) => {
  let n4 = t.paint.get("hillshade-shadow-color"), o4 = t.paint.get("hillshade-highlight-color"), a4 = t.paint.get("hillshade-accent-color"), s5 = t.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
  t.paint.get("hillshade-illumination-anchor") === "viewport" && (s5 -= r5.transform.angle);
  let u5 = !r5.options.moving;
  return { u_matrix: i ? i.posMatrix : r5.transform.calculatePosMatrix(e.tileID.toUnwrapped(), u5), u_image: 0, u_latrange: PL$1(r5, e.tileID), u_light: [t.paint.get("hillshade-exaggeration"), s5], u_shadow: n4, u_highlight: o4, u_accent: a4 };
}, "hillshadeUniformValues"), aS$1 = H$3((r5, e) => {
  let t = e.stride, i = q$2.create();
  return q$2.ortho(i, 0, 8192, -8192, 0, 0, 1), q$2.translate(i, i, [0, -8192, 0]), { u_matrix: i, u_image: 1, u_dimension: [t, t], u_zoom: r5.overscaledZ, u_unpack: e.getUnpackVector() };
}, "hillshadeUniformPrepareValues");
function PL$1(r5, e) {
  let t = Math.pow(2, e.canonical.z), i = e.canonical.y;
  return [new Fe$1(0, i / t).toLngLat().lat, new Fe$1(0, (i + 1) / t).toLngLat().lat];
}
H$3(PL$1, "getTileLatRange");
a();
var sS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_ratio: new U$1(r5, e.u_ratio), u_device_pixel_ratio: new U$1(r5, e.u_device_pixel_ratio), u_units_to_pixels: new te$1(r5, e.u_units_to_pixels) }), "lineUniforms"), lS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_ratio: new U$1(r5, e.u_ratio), u_device_pixel_ratio: new U$1(r5, e.u_device_pixel_ratio), u_units_to_pixels: new te$1(r5, e.u_units_to_pixels), u_image: new Q$2(r5, e.u_image), u_image_height: new U$1(r5, e.u_image_height) }), "lineGradientUniforms"), uS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_texsize: new te$1(r5, e.u_texsize), u_ratio: new U$1(r5, e.u_ratio), u_device_pixel_ratio: new U$1(r5, e.u_device_pixel_ratio), u_image: new Q$2(r5, e.u_image), u_units_to_pixels: new te$1(r5, e.u_units_to_pixels), u_scale: new lt$1(r5, e.u_scale), u_fade: new U$1(r5, e.u_fade) }), "linePatternUniforms"), cS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_ratio: new U$1(r5, e.u_ratio), u_device_pixel_ratio: new U$1(r5, e.u_device_pixel_ratio), u_units_to_pixels: new te$1(r5, e.u_units_to_pixels), u_patternscale_a: new te$1(r5, e.u_patternscale_a), u_patternscale_b: new te$1(r5, e.u_patternscale_b), u_sdfgamma: new U$1(r5, e.u_sdfgamma), u_image: new Q$2(r5, e.u_image), u_tex_y_a: new U$1(r5, e.u_tex_y_a), u_tex_y_b: new U$1(r5, e.u_tex_y_b), u_mix: new U$1(r5, e.u_mix) }), "lineSDFUniforms"), qu$1 = H$3((r5, e, t, i) => {
  let n4 = r5.transform;
  return { u_matrix: dS$1(r5, e, t, i), u_ratio: 1 / $e$1(e, 1, n4.zoom), u_device_pixel_ratio: r5.pixelRatio, u_units_to_pixels: [1 / n4.pixelsToGLUnits[0], 1 / n4.pixelsToGLUnits[1]] };
}, "lineUniformValues"), pS$1 = H$3((r5, e, t, i, n4) => V$1(qu$1(r5, e, t, n4), { u_image: 0, u_image_height: i }), "lineGradientUniformValues"), hS$1 = H$3((r5, e, t, i, n4) => {
  let o4 = r5.transform, a4 = mS$1(e, o4);
  return { u_matrix: dS$1(r5, e, t, n4), u_texsize: e.imageAtlasTexture.size, u_ratio: 1 / $e$1(e, 1, o4.zoom), u_device_pixel_ratio: r5.pixelRatio, u_image: 0, u_scale: [a4, i.fromScale, i.toScale], u_fade: i.t, u_units_to_pixels: [1 / o4.pixelsToGLUnits[0], 1 / o4.pixelsToGLUnits[1]] };
}, "linePatternUniformValues"), fS$1 = H$3((r5, e, t, i, n4, o4) => {
  let a4 = r5.transform, s5 = r5.lineAtlas, u5 = mS$1(e, a4), c = t.layout.get("line-cap") === "round", p4 = s5.getDash(i.from, c), h = s5.getDash(i.to, c), f = p4.width * n4.fromScale, m5 = h.width * n4.toScale;
  return V$1(qu$1(r5, e, t, o4), { u_patternscale_a: [u5 / f, -p4.height / 2], u_patternscale_b: [u5 / m5, -h.height / 2], u_sdfgamma: s5.width / (Math.min(f, m5) * 256 * r5.pixelRatio) / 2, u_image: 0, u_tex_y_a: p4.y, u_tex_y_b: h.y, u_mix: n4.t });
}, "lineSDFUniformValues");
function mS$1(r5, e) {
  return 1 / $e$1(r5, 1, e.tileZoom);
}
H$3(mS$1, "calculateTileRatio");
function dS$1(r5, e, t, i) {
  return r5.translatePosMatrix(i ? i.posMatrix : e.tileID.posMatrix, e, t.paint.get("line-translate"), t.paint.get("line-translate-anchor"));
}
H$3(dS$1, "calculateMatrix");
a();
var yS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_tl_parent: new te$1(r5, e.u_tl_parent), u_scale_parent: new U$1(r5, e.u_scale_parent), u_buffer_scale: new U$1(r5, e.u_buffer_scale), u_fade_t: new U$1(r5, e.u_fade_t), u_opacity: new U$1(r5, e.u_opacity), u_image0: new Q$2(r5, e.u_image0), u_image1: new Q$2(r5, e.u_image1), u_brightness_low: new U$1(r5, e.u_brightness_low), u_brightness_high: new U$1(r5, e.u_brightness_high), u_saturation_factor: new U$1(r5, e.u_saturation_factor), u_contrast_factor: new U$1(r5, e.u_contrast_factor), u_spin_weights: new lt$1(r5, e.u_spin_weights) }), "rasterUniforms"), gS$1 = H$3((r5, e, t, i, n4) => ({ u_matrix: r5, u_tl_parent: e, u_scale_parent: t, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * n4.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: n4.paint.get("raster-brightness-min"), u_brightness_high: n4.paint.get("raster-brightness-max"), u_saturation_factor: AL$1(n4.paint.get("raster-saturation")), u_contrast_factor: ML$1(n4.paint.get("raster-contrast")), u_spin_weights: TL$1(n4.paint.get("raster-hue-rotate")) }), "rasterUniformValues");
function TL$1(r5) {
  r5 *= Math.PI / 180;
  let e = Math.sin(r5), t = Math.cos(r5);
  return [(2 * t + 1) / 3, (-Math.sqrt(3) * e - t + 1) / 3, (Math.sqrt(3) * e - t + 1) / 3];
}
H$3(TL$1, "spinWeights");
function ML$1(r5) {
  return r5 > 0 ? 1 / (1 - r5) : 1 + r5;
}
H$3(ML$1, "contrastFactor");
function AL$1(r5) {
  return r5 > 0 ? 1 - 1 / (1.001 - r5) : -r5;
}
H$3(AL$1, "saturationFactor");
a();
var xS$1 = H$3((r5, e) => ({ u_is_size_zoom_constant: new Q$2(r5, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Q$2(r5, e.u_is_size_feature_constant), u_size_t: new U$1(r5, e.u_size_t), u_size: new U$1(r5, e.u_size), u_camera_to_center_distance: new U$1(r5, e.u_camera_to_center_distance), u_pitch: new U$1(r5, e.u_pitch), u_rotate_symbol: new Q$2(r5, e.u_rotate_symbol), u_aspect_ratio: new U$1(r5, e.u_aspect_ratio), u_fade_change: new U$1(r5, e.u_fade_change), u_matrix: new re$3(r5, e.u_matrix), u_label_plane_matrix: new re$3(r5, e.u_label_plane_matrix), u_coord_matrix: new re$3(r5, e.u_coord_matrix), u_is_text: new Q$2(r5, e.u_is_text), u_pitch_with_map: new Q$2(r5, e.u_pitch_with_map), u_texsize: new te$1(r5, e.u_texsize), u_texture: new Q$2(r5, e.u_texture) }), "symbolIconUniforms"), bS$1 = H$3((r5, e) => ({ u_is_size_zoom_constant: new Q$2(r5, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Q$2(r5, e.u_is_size_feature_constant), u_size_t: new U$1(r5, e.u_size_t), u_size: new U$1(r5, e.u_size), u_camera_to_center_distance: new U$1(r5, e.u_camera_to_center_distance), u_pitch: new U$1(r5, e.u_pitch), u_rotate_symbol: new Q$2(r5, e.u_rotate_symbol), u_aspect_ratio: new U$1(r5, e.u_aspect_ratio), u_fade_change: new U$1(r5, e.u_fade_change), u_matrix: new re$3(r5, e.u_matrix), u_label_plane_matrix: new re$3(r5, e.u_label_plane_matrix), u_coord_matrix: new re$3(r5, e.u_coord_matrix), u_is_text: new Q$2(r5, e.u_is_text), u_pitch_with_map: new Q$2(r5, e.u_pitch_with_map), u_texsize: new te$1(r5, e.u_texsize), u_texture: new Q$2(r5, e.u_texture), u_gamma_scale: new U$1(r5, e.u_gamma_scale), u_device_pixel_ratio: new U$1(r5, e.u_device_pixel_ratio), u_is_halo: new Q$2(r5, e.u_is_halo) }), "symbolSDFUniforms"), _S$1 = H$3((r5, e) => ({ u_is_size_zoom_constant: new Q$2(r5, e.u_is_size_zoom_constant), u_is_size_feature_constant: new Q$2(r5, e.u_is_size_feature_constant), u_size_t: new U$1(r5, e.u_size_t), u_size: new U$1(r5, e.u_size), u_camera_to_center_distance: new U$1(r5, e.u_camera_to_center_distance), u_pitch: new U$1(r5, e.u_pitch), u_rotate_symbol: new Q$2(r5, e.u_rotate_symbol), u_aspect_ratio: new U$1(r5, e.u_aspect_ratio), u_fade_change: new U$1(r5, e.u_fade_change), u_matrix: new re$3(r5, e.u_matrix), u_label_plane_matrix: new re$3(r5, e.u_label_plane_matrix), u_coord_matrix: new re$3(r5, e.u_coord_matrix), u_is_text: new Q$2(r5, e.u_is_text), u_pitch_with_map: new Q$2(r5, e.u_pitch_with_map), u_texsize: new te$1(r5, e.u_texsize), u_texsize_icon: new te$1(r5, e.u_texsize_icon), u_texture: new Q$2(r5, e.u_texture), u_texture_icon: new Q$2(r5, e.u_texture_icon), u_gamma_scale: new U$1(r5, e.u_gamma_scale), u_device_pixel_ratio: new U$1(r5, e.u_device_pixel_ratio), u_is_halo: new Q$2(r5, e.u_is_halo) }), "symbolTextAndIconUniforms"), Ay = H$3((r5, e, t, i, n4, o4, a4, s5, u5, c) => {
  let p4 = n4.transform;
  return { u_is_size_zoom_constant: +(r5 === "constant" || r5 === "source"), u_is_size_feature_constant: +(r5 === "constant" || r5 === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: p4.cameraToCenterDistance, u_pitch: p4.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +t, u_aspect_ratio: p4.width / p4.height, u_fade_change: n4.options.fadeDuration ? n4.symbolFadeChange : 1, u_matrix: o4, u_label_plane_matrix: a4, u_coord_matrix: s5, u_is_text: +u5, u_pitch_with_map: +i, u_texsize: c, u_texture: 0 };
}, "symbolIconUniformValues"), Iy = H$3((r5, e, t, i, n4, o4, a4, s5, u5, c, p4) => {
  let h = n4.transform;
  return V$1(Ay(r5, e, t, i, n4, o4, a4, s5, u5, c), { u_gamma_scale: i ? Math.cos(h._pitch) * h.cameraToCenterDistance : 1, u_device_pixel_ratio: n4.pixelRatio, u_is_halo: +p4 });
}, "symbolSDFUniformValues"), vS$1 = H$3((r5, e, t, i, n4, o4, a4, s5, u5, c) => V$1(Iy(r5, e, t, i, n4, o4, a4, s5, true, u5, true), { u_texsize_icon: c, u_texture_icon: 1 }), "symbolTextAndIconUniformValues");
a();
var wS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_opacity: new U$1(r5, e.u_opacity), u_color: new kt$1(r5, e.u_color) }), "backgroundUniforms"), SS$1 = H$3((r5, e) => ({ u_matrix: new re$3(r5, e.u_matrix), u_opacity: new U$1(r5, e.u_opacity), u_image: new Q$2(r5, e.u_image), u_pattern_tl_a: new te$1(r5, e.u_pattern_tl_a), u_pattern_br_a: new te$1(r5, e.u_pattern_br_a), u_pattern_tl_b: new te$1(r5, e.u_pattern_tl_b), u_pattern_br_b: new te$1(r5, e.u_pattern_br_b), u_texsize: new te$1(r5, e.u_texsize), u_mix: new U$1(r5, e.u_mix), u_pattern_size_a: new te$1(r5, e.u_pattern_size_a), u_pattern_size_b: new te$1(r5, e.u_pattern_size_b), u_scale_a: new U$1(r5, e.u_scale_a), u_scale_b: new U$1(r5, e.u_scale_b), u_pixel_coord_upper: new te$1(r5, e.u_pixel_coord_upper), u_pixel_coord_lower: new te$1(r5, e.u_pixel_coord_lower), u_tile_units_to_pixels: new U$1(r5, e.u_tile_units_to_pixels) }), "backgroundPatternUniforms"), PS$1 = H$3((r5, e, t) => ({ u_matrix: r5, u_opacity: e, u_color: t }), "backgroundUniformValues"), TS$1 = H$3((r5, e, t, i, n4, o4) => V$1(Fw(i, o4, t, n4), { u_matrix: r5, u_opacity: e }), "backgroundPatternUniformValues");
var MS$1 = { fillExtrusion: Rw, fillExtrusionPattern: Bw, fill: Vw, fillPattern: Uw, fillOutline: Nw, fillOutlinePattern: Gw, circle: Zw, collisionBox: $w, collisionCircle: Ww, debug: Jw, clippingMask: Yw, heatmap: Qw, heatmapTexture: eS$1, hillshade: iS$1, hillshadePrepare: nS$1, line: sS$1, lineGradient: lS$1, linePattern: uS$1, lineSDF: cS$1, raster: yS$1, symbolIcon: xS$1, symbolSDF: bS$1, symbolTextAndIcon: _S$1, background: wS$1, backgroundPattern: SS$1, terrain: Cw, terrainDepth: Ew, terrainCoords: kw };
a();
a();
var Cy$1 = class Cy {
  constructor(e, t, i) {
    this.context = e;
    let n4 = e.gl;
    this.buffer = n4.createBuffer(), this.dynamicDraw = !!i, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), n4.bufferData(n4.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? n4.DYNAMIC_DRAW : n4.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
  }
  bind() {
    this.context.bindElementBuffer.set(this.buffer);
  }
  updateData(e) {
    let t = this.context.gl;
    if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
    this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
H$3(Cy$1, "IndexBuffer");
var ju$1 = Cy$1;
a();
var IL$1 = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, Ey$1 = class Ey {
  constructor(e, t, i, n4) {
    this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = n4, this.context = e;
    let o4 = e.gl;
    this.buffer = o4.createBuffer(), e.bindVertexBuffer.set(this.buffer), o4.bufferData(o4.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o4.DYNAMIC_DRAW : o4.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
  }
  bind() {
    this.context.bindVertexBuffer.set(this.buffer);
  }
  updateData(e) {
    if (e.length !== this.length) throw new Error("Length of new data is ".concat(e.length, ", which doesn't match current length of ").concat(this.length));
    let t = this.context.gl;
    this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);
  }
  enableAttributes(e, t) {
    for (let i = 0; i < this.attributes.length; i++) {
      let n4 = this.attributes[i], o4 = t.attributes[n4.name];
      o4 !== void 0 && e.enableVertexAttribArray(o4);
    }
  }
  setVertexAttribPointers(e, t, i) {
    for (let n4 = 0; n4 < this.attributes.length; n4++) {
      let o4 = this.attributes[n4], a4 = t.attributes[o4.name];
      a4 !== void 0 && e.vertexAttribPointer(a4, o4.components, e[IL$1[o4.type]], false, this.itemSize, o4.offset + this.itemSize * (i || 0));
    }
  }
  destroy() {
    let e = this.context.gl;
    this.buffer && (e.deleteBuffer(this.buffer), delete this.buffer);
  }
};
H$3(Ey$1, "VertexBuffer");
var Zu = Ey$1;
a();
a();
a();
var ky$1 = /* @__PURE__ */ new WeakMap();
function Mn$1(r5) {
  var e;
  if (ky$1.has(r5)) return ky$1.get(r5);
  {
    let t = (e = r5.getParameter(r5.VERSION)) == null ? void 0 : e.startsWith("WebGL 2.0");
    return ky$1.set(r5, t), t;
  }
}
H$3(Mn$1, "isWebGL2");
var Ly = class Ly2 {
  constructor(e) {
    this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
  }
  get() {
    return this.current;
  }
  set(e) {
  }
  getDefault() {
    return this.default;
  }
  setDefault() {
    this.set(this.default);
  }
};
H$3(Ly, "BaseValue");
var be$1 = Ly, Dy = class Dy2 extends be$1 {
  getDefault() {
    return X$1.transparent;
  }
  set(e) {
    let t = this.current;
    e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a && !this.dirty || (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
H$3(Dy, "ClearColor");
var Hu$1 = Dy, zy$1 = class zy extends be$1 {
  getDefault() {
    return 1;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearDepth(e), this.current = e, this.dirty = false);
  }
};
H$3(zy$1, "ClearDepth");
var $u = zy$1, Fy$1 = class Fy extends be$1 {
  getDefault() {
    return 0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.clearStencil(e), this.current = e, this.dirty = false);
  }
};
H$3(Fy$1, "ClearStencil");
var Wu = Fy$1, Ry$1 = class Ry extends be$1 {
  getDefault() {
    return [true, true, true, true];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && !this.dirty || (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
H$3(Ry$1, "ColorMask");
var Xu$1 = Ry$1, By$1 = class By extends be$1 {
  getDefault() {
    return true;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthMask(e), this.current = e, this.dirty = false);
  }
};
H$3(By$1, "DepthMask");
var Ku = By$1, Oy = class Oy2 extends be$1 {
  getDefault() {
    return 255;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.stencilMask(e), this.current = e, this.dirty = false);
  }
};
H$3(Oy, "StencilMask");
var Ju = Oy, Vy$1 = class Vy extends be$1 {
  getDefault() {
    return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
  }
  set(e) {
    let t = this.current;
    e.func === t.func && e.ref === t.ref && e.mask === t.mask && !this.dirty || (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
  }
};
H$3(Vy$1, "StencilFunc");
var Yu$1 = Vy$1, Uy = class Uy2 extends be$1 {
  getDefault() {
    let e = this.gl;
    return [e.KEEP, e.KEEP, e.KEEP];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && !this.dirty || (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
  }
};
H$3(Uy, "StencilOp");
var Qu = Uy, Ny = class Ny2 extends be$1 {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = false;
  }
};
H$3(Ny, "StencilTest");
var ec = Ny, Gy$1 = class Gy extends be$1 {
  getDefault() {
    return [0, 1];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && !this.dirty || (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
H$3(Gy$1, "DepthRange");
var tc = Gy$1, qy$1 = class qy extends be$1 {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = false;
  }
};
H$3(qy$1, "DepthTest");
var rc = qy$1, jy = class jy2 extends be$1 {
  getDefault() {
    return this.gl.LESS;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.depthFunc(e), this.current = e, this.dirty = false);
  }
};
H$3(jy, "DepthFunc");
var ic = jy, Zy$1 = class Zy extends be$1 {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = false;
  }
};
H$3(Zy$1, "Blend");
var nc = Zy$1, Hy$1 = class Hy extends be$1 {
  getDefault() {
    let e = this.gl;
    return [e.ONE, e.ZERO];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && !this.dirty || (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
  }
};
H$3(Hy$1, "BlendFunc");
var oc = Hy$1, $y$1 = class $y extends be$1 {
  getDefault() {
    return X$1.transparent;
  }
  set(e) {
    let t = this.current;
    e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a && !this.dirty || (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
  }
};
H$3($y$1, "BlendColor");
var ac = $y$1, Wy$1 = class Wy extends be$1 {
  getDefault() {
    return this.gl.FUNC_ADD;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.blendEquation(e), this.current = e, this.dirty = false);
  }
};
H$3(Wy$1, "BlendEquation");
var sc = Wy$1, Xy$1 = class Xy extends be$1 {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = false;
  }
};
H$3(Xy$1, "CullFace");
var lc = Xy$1, Ky$1 = class Ky extends be$1 {
  getDefault() {
    return this.gl.BACK;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.cullFace(e), this.current = e, this.dirty = false);
  }
};
H$3(Ky$1, "CullFaceSide");
var uc = Ky$1, Jy$1 = class Jy extends be$1 {
  getDefault() {
    return this.gl.CCW;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.frontFace(e), this.current = e, this.dirty = false);
  }
};
H$3(Jy$1, "FrontFace");
var cc = Jy$1, Yy = class Yy2 extends be$1 {
  getDefault() {
    return null;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.useProgram(e), this.current = e, this.dirty = false);
  }
};
H$3(Yy, "ProgramValue");
var pc$1 = Yy, Qy$1 = class Qy extends be$1 {
  getDefault() {
    return this.gl.TEXTURE0;
  }
  set(e) {
    e === this.current && !this.dirty || (this.gl.activeTexture(e), this.current = e, this.dirty = false);
  }
};
H$3(Qy$1, "ActiveTextureUnit");
var hc$1 = Qy$1, eg = class eg2 extends be$1 {
  getDefault() {
    let e = this.gl;
    return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
  }
  set(e) {
    let t = this.current;
    e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && !this.dirty || (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
  }
};
H$3(eg, "Viewport");
var fc$1 = eg, tg = class tg2 extends be$1 {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = false;
  }
};
H$3(tg, "BindFramebuffer");
var mc$1 = tg, rg = class rg2 extends be$1 {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
H$3(rg, "BindRenderbuffer");
var dc$1 = rg, ig = class ig2 extends be$1 {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = false;
  }
};
H$3(ig, "BindTexture");
var yc$1 = ig, ng = class ng2 extends be$1 {
  getDefault() {
    return null;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
H$3(ng, "BindVertexBuffer");
var gc$1 = ng, og = class og2 extends be$1 {
  getDefault() {
    return null;
  }
  set(e) {
    let t = this.gl;
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
  }
};
H$3(og, "BindElementBuffer");
var xc$1 = og, ag = class ag2 extends be$1 {
  getDefault() {
    return null;
  }
  set(e) {
    var i;
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    Mn$1(t) ? t.bindVertexArray(e) : (i = t.getExtension("OES_vertex_array_object")) == null || i.bindVertexArrayOES(e), this.current = e, this.dirty = false;
  }
};
H$3(ag, "BindVertexArray");
var bc$1 = ag, sg = class sg2 extends be$1 {
  getDefault() {
    return 4;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
  }
};
H$3(sg, "PixelStoreUnpack");
var _c$1 = sg, lg = class lg2 extends be$1 {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
  }
};
H$3(lg, "PixelStoreUnpackPremultiplyAlpha");
var vc$1 = lg, ug = class ug2 extends be$1 {
  getDefault() {
    return false;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    let t = this.gl;
    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
  }
};
H$3(ug, "PixelStoreUnpackFlipY");
var wc$1 = ug, cg = class cg2 extends be$1 {
  constructor(e, t) {
    super(e), this.context = e, this.parent = t;
  }
  getDefault() {
    return null;
  }
};
H$3(cg, "FramebufferAttachment");
var Ia$1 = cg, pg = class pg2 extends Ia$1 {
  setDirty() {
    this.dirty = true;
  }
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t = this.gl;
    t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
  }
};
H$3(pg, "ColorAttachment");
var Sc$1 = pg, hg = class hg2 extends Ia$1 {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t = this.gl;
    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
H$3(hg, "DepthAttachment");
var Pc$1 = hg, fg = class fg2 extends Ia$1 {
  set(e) {
    if (e === this.current && !this.dirty) return;
    this.context.bindFramebuffer.set(this.parent);
    let t = this.gl;
    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = false;
  }
};
H$3(fg, "DepthStencilAttachment");
var Tc$1 = fg;
var mg = class mg2 {
  constructor(e, t, i, n4, o4) {
    this.context = e, this.width = t, this.height = i;
    let a4 = e.gl, s5 = this.framebuffer = a4.createFramebuffer();
    if (this.colorAttachment = new Sc$1(e, s5), n4) this.depthAttachment = o4 ? new Tc$1(e, s5) : new Pc$1(e, s5);
    else if (o4) throw new Error("Stencil cannot be set without depth");
    if (a4.checkFramebufferStatus(a4.FRAMEBUFFER) !== a4.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
  }
  destroy() {
    let e = this.context.gl, t = this.colorAttachment.get();
    if (t && e.deleteTexture(t), this.depthAttachment) {
      let i = this.depthAttachment.get();
      i && e.deleteRenderbuffer(i);
    }
    e.deleteFramebuffer(this.framebuffer);
  }
};
H$3(mg, "Framebuffer");
var Mc$1 = mg;
a();
var CL$1 = 0, AS$1 = 1, EL$1 = 771, dg = class dg2 {
  constructor(e, t, i) {
    this.blendFunction = e, this.blendColor = t, this.mask = i;
  }
};
H$3(dg, "ColorMode");
var ke$1 = dg;
ke$1.Replace = [AS$1, CL$1];
ke$1.disabled = new ke$1(ke$1.Replace, X$1.transparent, [false, false, false, false]);
ke$1.unblended = new ke$1(ke$1.Replace, X$1.transparent, [true, true, true, true]);
ke$1.alphaBlended = new ke$1([AS$1, EL$1], X$1.transparent, [true, true, true, true]);
var yg = class yg2 {
  constructor(e) {
    var t, i;
    if (this.gl = e, this.clearColor = new Hu$1(this), this.clearDepth = new $u(this), this.clearStencil = new Wu(this), this.colorMask = new Xu$1(this), this.depthMask = new Ku(this), this.stencilMask = new Ju(this), this.stencilFunc = new Yu$1(this), this.stencilOp = new Qu(this), this.stencilTest = new ec(this), this.depthRange = new tc(this), this.depthTest = new rc(this), this.depthFunc = new ic(this), this.blend = new nc(this), this.blendFunc = new oc(this), this.blendColor = new ac(this), this.blendEquation = new sc(this), this.cullFace = new lc(this), this.cullFaceSide = new uc(this), this.frontFace = new cc(this), this.program = new pc$1(this), this.activeTexture = new hc$1(this), this.viewport = new fc$1(this), this.bindFramebuffer = new mc$1(this), this.bindRenderbuffer = new dc$1(this), this.bindTexture = new yc$1(this), this.bindVertexBuffer = new gc$1(this), this.bindElementBuffer = new xc$1(this), this.bindVertexArray = new bc$1(this), this.pixelStoreUnpack = new _c$1(this), this.pixelStoreUnpackPremultiplyAlpha = new vc$1(this), this.pixelStoreUnpackFlipY = new wc$1(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Mn$1(e)) {
      this.HALF_FLOAT = e.HALF_FLOAT;
      let n4 = e.getExtension("EXT_color_buffer_half_float");
      this.RGBA16F = (t = e.RGBA16F) != null ? t : n4 == null ? void 0 : n4.RGBA16F_EXT, this.RGB16F = (i = e.RGB16F) != null ? i : n4 == null ? void 0 : n4.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
    } else {
      e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
      let n4 = e.getExtension("OES_texture_half_float");
      this.HALF_FLOAT = n4 == null ? void 0 : n4.HALF_FLOAT_OES;
    }
  }
  setDefault() {
    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
  }
  setDirty() {
    this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
  }
  createIndexBuffer(e, t) {
    return new ju$1(this, e, t);
  }
  createVertexBuffer(e, t, i) {
    return new Zu(this, e, t, i);
  }
  createRenderbuffer(e, t, i) {
    let n4 = this.gl, o4 = n4.createRenderbuffer();
    return this.bindRenderbuffer.set(o4), n4.renderbufferStorage(n4.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), o4;
  }
  createFramebuffer(e, t, i, n4) {
    return new Mc$1(this, e, t, i, n4);
  }
  clear({ color: e, depth: t, stencil: i }) {
    let n4 = this.gl, o4 = 0;
    e && (o4 |= n4.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), typeof t < "u" && (o4 |= n4.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(true)), typeof i < "u" && (o4 |= n4.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), n4.clear(o4);
  }
  setCullFace(e) {
    e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
  }
  setDepthMode(e) {
    e.func === this.gl.ALWAYS && !e.mask ? this.depthTest.set(false) : (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range));
  }
  setStencilMode(e) {
    e.test.func === this.gl.ALWAYS && !e.mask ? this.stencilTest.set(false) : (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask }));
  }
  setColorMode(e) {
    Qt$1(e.blendFunction, ke$1.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
  }
  createVertexArray() {
    var e;
    return Mn$1(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) == null ? void 0 : e.createVertexArrayOES();
  }
  deleteVertexArray(e) {
    var t;
    return Mn$1(this.gl) ? this.gl.deleteVertexArray(e) : (t = this.gl.getExtension("OES_vertex_array_object")) == null ? void 0 : t.deleteVertexArrayOES(e);
  }
  unbindVAO() {
    this.bindVertexArray.set(null);
  }
};
H$3(yg, "Context");
var Ac$1 = yg;
a();
var gg = class gg2 {
  constructor(e, t, i) {
    this.func = e, this.mask = t, this.range = i;
  }
};
H$3(gg, "DepthMode");
var ee$1 = gg;
ee$1.ReadOnly = false;
ee$1.ReadWrite = true;
ee$1.disabled = new ee$1(519, ee$1.ReadOnly, [0, 1]);
a();
var xg$1 = class xg {
  constructor(e, t, i, n4, o4, a4) {
    this.test = e, this.ref = t, this.mask = i, this.fail = n4, this.depthFail = o4, this.pass = a4;
  }
};
H$3(xg$1, "StencilMode");
var fe$1 = xg$1;
fe$1.disabled = new fe$1({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
a();
var bg = class bg2 {
  constructor(e, t, i) {
    this.enable = e, this.mode = t, this.frontFace = i;
  }
};
H$3(bg, "CullFaceMode");
var ue$1 = bg;
ue$1.disabled = new ue$1(false, 1029, 2305);
ue$1.backCCW = new ue$1(true, 1029, 2305);
a();
var vg$1 = N$2(ge(), 1);
a();
var Ic$1;
function _g(r5, e, t, i, n4, o4, a4) {
  let s5 = r5.context, u5 = s5.gl, c = r5.useProgram("collisionBox"), p4 = [], h = 0, f = 0;
  for (let w3 = 0; w3 < i.length; w3++) {
    let _ = i[w3], S4 = e.getTile(_), P4 = S4.getBucket(t);
    if (!P4) continue;
    let T3 = _.posMatrix;
    (n4[0] !== 0 || n4[1] !== 0) && (T3 = r5.translatePosMatrix(_.posMatrix, S4, n4, o4));
    let L3 = a4 ? P4.textCollisionBox : P4.iconCollisionBox, C3 = P4.collisionCircleArray;
    if (C3.length > 0) {
      let E4 = q$2.create(), I3 = T3;
      q$2.mul(E4, P4.placementInvProjMatrix, r5.transform.glCoordMatrix), q$2.mul(E4, E4, P4.placementViewportMatrix), p4.push({ circleArray: C3, circleOffset: f, transform: I3, invTransform: E4, coord: _ }), h += C3.length / 4, f = h;
    }
    L3 && c.draw(s5, u5.LINES, ee$1.disabled, fe$1.disabled, r5.colorModeForRenderPass(), ue$1.disabled, Xw(T3, r5.transform, S4), r5.style.map.terrain && r5.style.map.terrain.getTerrainData(_), t.id, L3.layoutVertexBuffer, L3.indexBuffer, L3.segments, null, r5.transform.zoom, null, null, L3.collisionVertexBuffer);
  }
  if (!a4 || !p4.length) return;
  let m5 = r5.useProgram("collisionCircle"), y4 = new wl$1();
  y4.resize(h * 4), y4._trim();
  let g = 0;
  for (let w3 of p4) for (let _ = 0; _ < w3.circleArray.length / 4; _++) {
    let S4 = _ * 4, P4 = w3.circleArray[S4 + 0], T3 = w3.circleArray[S4 + 1], L3 = w3.circleArray[S4 + 2], C3 = w3.circleArray[S4 + 3];
    y4.emplace(g++, P4, T3, L3, C3, 0), y4.emplace(g++, P4, T3, L3, C3, 1), y4.emplace(g++, P4, T3, L3, C3, 2), y4.emplace(g++, P4, T3, L3, C3, 3);
  }
  (!Ic$1 || Ic$1.length < h * 2) && (Ic$1 = kL$1(h));
  let x2 = s5.createIndexBuffer(Ic$1, true), b = s5.createVertexBuffer(y4, b0$1.members, true);
  for (let w3 of p4) {
    let _ = Kw(w3.transform, w3.invTransform, r5.transform);
    m5.draw(s5, u5.TRIANGLES, ee$1.disabled, fe$1.disabled, r5.colorModeForRenderPass(), ue$1.disabled, _, r5.style.map.terrain && r5.style.map.terrain.getTerrainData(w3.coord), t.id, b, x2, me$1.simpleSegment(0, w3.circleOffset * 2, w3.circleArray.length, w3.circleArray.length / 2), null, r5.transform.zoom, null, null, null);
  }
  b.destroy(), x2.destroy();
}
H$3(_g, "drawCollisionDebug");
function kL$1(r5) {
  let e = r5 * 2, t = new Pl$1();
  t.resize(e), t._trim();
  for (let i = 0; i < e; i++) {
    let n4 = i * 6;
    t.uint16[n4 + 0] = i * 4 + 0, t.uint16[n4 + 1] = i * 4 + 1, t.uint16[n4 + 2] = i * 4 + 2, t.uint16[n4 + 3] = i * 4 + 2, t.uint16[n4 + 4] = i * 4 + 3, t.uint16[n4 + 5] = i * 4 + 0;
  }
  return t;
}
H$3(kL$1, "createQuadTriangles");
var LL$1 = q$2.identity(new Float32Array(16));
function ES$1(r5, e, t, i, n4) {
  if (r5.renderPass !== "translucent") return;
  let o4 = fe$1.disabled, a4 = r5.colorModeForRenderPass();
  (t._unevaluatedLayout.hasValue("text-variable-anchor") || t._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && zL$1(i, r5, t, e, t.layout.get("text-rotation-alignment"), t.layout.get("text-pitch-alignment"), n4), t.paint.get("icon-opacity").constantOr(1) !== 0 && IS$1(r5, e, t, i, false, t.paint.get("icon-translate"), t.paint.get("icon-translate-anchor"), t.layout.get("icon-rotation-alignment"), t.layout.get("icon-pitch-alignment"), t.layout.get("icon-keep-upright"), o4, a4), t.paint.get("text-opacity").constantOr(1) !== 0 && IS$1(r5, e, t, i, true, t.paint.get("text-translate"), t.paint.get("text-translate-anchor"), t.layout.get("text-rotation-alignment"), t.layout.get("text-pitch-alignment"), t.layout.get("text-keep-upright"), o4, a4), e.map.showCollisionBoxes && (_g(r5, e, t, i, t.paint.get("text-translate"), t.paint.get("text-translate-anchor"), true), _g(r5, e, t, i, t.paint.get("icon-translate"), t.paint.get("icon-translate-anchor"), false));
}
H$3(ES$1, "drawSymbols");
function DL$1(r5, e, t, i, n4, o4) {
  let { horizontalAlign: a4, verticalAlign: s5 } = Jl$1(r5), u5 = -(a4 - 0.5) * e, c = -(s5 - 0.5) * t;
  return new vg$1.default((u5 / n4 + i[0]) * o4, (c / n4 + i[1]) * o4);
}
H$3(DL$1, "calculateVariableRenderShift");
function zL$1(r5, e, t, i, n4, o4, a4) {
  let s5 = e.transform, u5 = n4 === "map", c = o4 === "map";
  for (let p4 of r5) {
    let h = i.getTile(p4), f = h.getBucket(t);
    if (!f || !f.text || !f.text.segments.get().length) continue;
    let m5 = f.textSizeData, y4 = gi(m5, s5.zoom), g = $e$1(h, 1, e.transform.zoom), x2 = ba$1(p4.posMatrix, c, u5, e.transform, g), b = t.layout.get("icon-text-fit") !== "none" && f.hasIconData();
    if (y4) {
      let w3 = Math.pow(2, s5.zoom - h.tileID.overscaledZ), _ = e.style.map.terrain ? (S4, P4) => e.style.map.terrain.getElevation(p4, S4, P4) : null;
      FL$1(f, u5, c, a4, s5, x2, p4.posMatrix, w3, y4, b, _);
    }
  }
}
H$3(zL$1, "updateVariableAnchors");
function FL$1(r5, e, t, i, n4, o4, a4, s5, u5, c, p4) {
  let h = r5.text.placedSymbolArray, f = r5.text.dynamicLayoutVertexArray, m5 = r5.icon.dynamicLayoutVertexArray, y4 = {};
  f.clear();
  for (let g = 0; g < h.length; g++) {
    let x2 = h.get(g), b = r5.allowVerticalPlacement && !x2.placedOrientation, w3 = !x2.hidden && x2.crossTileID && !b ? i[x2.crossTileID] : null;
    if (!w3) Si$1(x2.numGlyphs, f);
    else {
      let _ = new vg$1.default(x2.anchorX, x2.anchorY), S4 = bt$1(_, t ? a4 : o4, p4), P4 = _a$1(n4.cameraToCenterDistance, S4.signedDistanceFromCamera), T3 = dn$1(r5.textSizeData, u5, x2) * P4 / Dr;
      t && (T3 *= r5.tilePixelRatio / s5);
      let { width: L3, height: C3, anchor: E4, textOffset: I3, textBoxScale: R3 } = w3, z4 = DL$1(E4, L3, C3, I3, R3, T3), k3 = t ? bt$1(_.add(z4), o4, p4).point : S4.point.add(e ? z4.rotate(-n4.angle) : z4), M3 = r5.allowVerticalPlacement && x2.placedOrientation === 2 ? Math.PI / 2 : 0;
      for (let G3 = 0; G3 < x2.numGlyphs; G3++) xi(f, k3, M3);
      c && x2.associatedIconIndex >= 0 && (y4[x2.associatedIconIndex] = { shiftedAnchor: k3, angle: M3 });
    }
  }
  if (c) {
    m5.clear();
    let g = r5.icon.placedSymbolArray;
    for (let x2 = 0; x2 < g.length; x2++) {
      let b = g.get(x2);
      if (b.hidden) Si$1(b.numGlyphs, m5);
      else {
        let w3 = y4[x2];
        if (!w3) Si$1(b.numGlyphs, m5);
        else for (let _ = 0; _ < b.numGlyphs; _++) xi(m5, w3.shiftedAnchor, w3.angle);
      }
    }
    r5.icon.dynamicLayoutVertexBuffer.updateData(m5);
  }
  r5.text.dynamicLayoutVertexBuffer.updateData(f);
}
H$3(FL$1, "updateVariableAnchorsForBucket");
function RL$1(r5, e, t) {
  return t.iconsInText && e ? "symbolTextAndIcon" : r5 ? "symbolSDF" : "symbolIcon";
}
H$3(RL$1, "getSymbolProgramName");
function IS$1(r5, e, t, i, n4, o4, a4, s5, u5, c, p4, h) {
  let f = r5.context, m5 = f.gl, y4 = r5.transform, g = s5 === "map", x2 = u5 === "map", b = s5 !== "viewport" && t.layout.get("symbol-placement") !== "point", w3 = g && !x2 && !b, _ = !t.layout.get("symbol-sort-key").isConstant(), S4 = false, P4 = r5.depthModeForSublayer(0, ee$1.ReadOnly), T3 = t._unevaluatedLayout.hasValue("text-variable-anchor") || t._unevaluatedLayout.hasValue("text-variable-anchor-offset"), L3 = [];
  for (let C3 of i) {
    let E4 = e.getTile(C3), I3 = E4.getBucket(t);
    if (!I3) continue;
    let R3 = n4 ? I3.text : I3.icon;
    if (!R3 || !R3.segments.get().length || !R3.hasVisibleVertices) continue;
    let z4 = R3.programConfigurations.get(t.id), k3 = n4 || I3.sdfIcons, M3 = n4 ? I3.textSizeData : I3.iconSizeData, G3 = x2 || y4.pitch !== 0, K4 = r5.useProgram(RL$1(k3, n4, I3), z4), ne2 = gi(M3, y4.zoom), J4 = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(C3), W4, Ye2 = [0, 0], Ve3, ce2, Me2 = null, Qe2;
    if (n4) {
      if (Ve3 = E4.glyphAtlasTexture, ce2 = m5.LINEAR, W4 = E4.glyphAtlasTexture.size, I3.iconsInText) {
        Ye2 = E4.imageAtlasTexture.size, Me2 = E4.imageAtlasTexture;
        let Ze2 = M3.kind === "composite" || M3.kind === "camera";
        Qe2 = G3 || r5.options.rotating || r5.options.zooming || Ze2 ? m5.LINEAR : m5.NEAREST;
      }
    } else {
      let Ze2 = t.layout.get("icon-size").constantOr(0) !== 1 || I3.iconsNeedLinear;
      Ve3 = E4.imageAtlasTexture, ce2 = k3 || r5.options.rotating || r5.options.zooming || Ze2 || G3 ? m5.LINEAR : m5.NEAREST, W4 = E4.imageAtlasTexture.size;
    }
    let mr2 = $e$1(E4, 1, r5.transform.zoom), dr2 = ba$1(C3.posMatrix, x2, g, r5.transform, mr2), zt2 = Mu$1(C3.posMatrix, x2, g, r5.transform, mr2), Xt2 = T3 && I3.hasTextData(), Gr2 = t.layout.get("icon-text-fit") !== "none" && Xt2 && I3.hasIconData();
    if (b) {
      let Ze2 = r5.style.map.terrain ? (Yt2, jr2) => r5.style.map.terrain.getElevation(C3, Yt2, jr2) : null, ct2 = t.layout.get("text-rotation-alignment") === "map";
      x1$1(I3, C3.posMatrix, r5, n4, dr2, zt2, x2, c, ct2, Ze2);
    }
    let Kt2 = r5.translatePosMatrix(C3.posMatrix, E4, o4, a4), Jt2 = b || n4 && T3 || Gr2 ? LL$1 : dr2, et2 = r5.translatePosMatrix(zt2, E4, o4, a4, true), ot2 = k3 && t.paint.get(n4 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, tt2;
    k3 ? I3.iconsInText ? tt2 = vS$1(M3.kind, ne2, w3, x2, r5, Kt2, Jt2, et2, W4, Ye2) : tt2 = Iy(M3.kind, ne2, w3, x2, r5, Kt2, Jt2, et2, n4, W4, true) : tt2 = Ay(M3.kind, ne2, w3, x2, r5, Kt2, Jt2, et2, n4, W4);
    let qr2 = { program: K4, buffers: R3, uniformValues: tt2, atlasTexture: Ve3, atlasTextureIcon: Me2, atlasInterpolation: ce2, atlasInterpolationIcon: Qe2, isSDF: k3, hasHalo: ot2 };
    if (_ && I3.canOverlap) {
      S4 = true;
      let Ze2 = R3.segments.get();
      for (let ct2 of Ze2) L3.push({ segments: new me$1([ct2]), sortKey: ct2.sortKey, state: qr2, terrainData: J4 });
    } else L3.push({ segments: R3.segments, sortKey: 0, state: qr2, terrainData: J4 });
  }
  S4 && L3.sort((C3, E4) => C3.sortKey - E4.sortKey);
  for (let C3 of L3) {
    let E4 = C3.state;
    if (f.activeTexture.set(m5.TEXTURE0), E4.atlasTexture.bind(E4.atlasInterpolation, m5.CLAMP_TO_EDGE), E4.atlasTextureIcon && (f.activeTexture.set(m5.TEXTURE1), E4.atlasTextureIcon && E4.atlasTextureIcon.bind(E4.atlasInterpolationIcon, m5.CLAMP_TO_EDGE)), E4.isSDF) {
      let I3 = E4.uniformValues;
      E4.hasHalo && (I3.u_is_halo = 1, CS$1(E4.buffers, C3.segments, t, r5, E4.program, P4, p4, h, I3, C3.terrainData)), I3.u_is_halo = 0;
    }
    CS$1(E4.buffers, C3.segments, t, r5, E4.program, P4, p4, h, E4.uniformValues, C3.terrainData);
  }
}
H$3(IS$1, "drawLayerSymbols");
function CS$1(r5, e, t, i, n4, o4, a4, s5, u5, c) {
  let p4 = i.context, h = p4.gl;
  n4.draw(p4, h.TRIANGLES, o4, a4, s5, ue$1.disabled, u5, c, t.id, r5.layoutVertexBuffer, r5.indexBuffer, e, t.paint, i.transform.zoom, r5.programConfigurations.get(t.id), r5.dynamicLayoutVertexBuffer, r5.opacityVertexBuffer);
}
H$3(CS$1, "drawSymbolElements");
a();
function kS$1(r5, e, t, i) {
  if (r5.renderPass !== "translucent") return;
  let n4 = t.paint.get("circle-opacity"), o4 = t.paint.get("circle-stroke-width"), a4 = t.paint.get("circle-stroke-opacity"), s5 = !t.layout.get("circle-sort-key").isConstant();
  if (n4.constantOr(1) === 0 && (o4.constantOr(1) === 0 || a4.constantOr(1) === 0)) return;
  let u5 = r5.context, c = u5.gl, p4 = r5.depthModeForSublayer(0, ee$1.ReadOnly), h = fe$1.disabled, f = r5.colorModeForRenderPass(), m5 = [];
  for (let y4 = 0; y4 < i.length; y4++) {
    let g = i[y4], x2 = e.getTile(g), b = x2.getBucket(t);
    if (!b) continue;
    let w3 = b.programConfigurations.get(t.id), _ = r5.useProgram("circle", w3), S4 = b.layoutVertexBuffer, P4 = b.indexBuffer, T3 = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(g), L3 = Hw(r5, g, x2, t), C3 = { programConfiguration: w3, program: _, layoutVertexBuffer: S4, indexBuffer: P4, uniformValues: L3, terrainData: T3 };
    if (s5) {
      let E4 = b.segments.get();
      for (let I3 of E4) m5.push({ segments: new me$1([I3]), sortKey: I3.sortKey, state: C3 });
    } else m5.push({ segments: b.segments, sortKey: 0, state: C3 });
  }
  s5 && m5.sort((y4, g) => y4.sortKey - g.sortKey);
  for (let y4 of m5) {
    let { programConfiguration: g, program: x2, layoutVertexBuffer: b, indexBuffer: w3, uniformValues: _, terrainData: S4 } = y4.state, P4 = y4.segments;
    x2.draw(u5, c.TRIANGLES, p4, h, f, ue$1.disabled, _, S4, t.id, b, w3, P4, t.paint, r5.transform.zoom, g);
  }
}
H$3(kS$1, "drawCircles");
a();
function LS$1(r5, e, t, i) {
  if (t.paint.get("heatmap-opacity") !== 0) if (r5.renderPass === "offscreen") {
    let n4 = r5.context, o4 = n4.gl, a4 = fe$1.disabled, s5 = new ke$1([o4.ONE, o4.ONE], X$1.transparent, [true, true, true, true]);
    BL$1(n4, r5, t), n4.clear({ color: X$1.transparent });
    for (let u5 = 0; u5 < i.length; u5++) {
      let c = i[u5];
      if (e.hasRenderableParent(c)) continue;
      let p4 = e.getTile(c), h = p4.getBucket(t);
      if (!h) continue;
      let f = h.programConfigurations.get(t.id), m5 = r5.useProgram("heatmap", f), { zoom: y4 } = r5.transform;
      m5.draw(n4, o4.TRIANGLES, ee$1.disabled, a4, s5, ue$1.disabled, tS$1(c.posMatrix, p4, y4, t.paint.get("heatmap-intensity")), null, t.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, t.paint, r5.transform.zoom, f);
    }
    n4.viewport.set([0, 0, r5.width, r5.height]);
  } else r5.renderPass === "translucent" && (r5.context.setColorMode(r5.colorModeForRenderPass()), VL$1(r5, t));
}
H$3(LS$1, "drawHeatmap");
function BL$1(r5, e, t) {
  let i = r5.gl;
  r5.activeTexture.set(i.TEXTURE1), r5.viewport.set([0, 0, e.width / 4, e.height / 4]);
  let n4 = t.heatmapFbo;
  if (n4) i.bindTexture(i.TEXTURE_2D, n4.colorAttachment.get()), r5.bindFramebuffer.set(n4.framebuffer);
  else {
    let o4 = i.createTexture();
    i.bindTexture(i.TEXTURE_2D, o4), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), n4 = t.heatmapFbo = r5.createFramebuffer(e.width / 4, e.height / 4, false, false), OL$1(r5, e, o4, n4);
  }
}
H$3(BL$1, "bindFramebuffer");
function OL$1(r5, e, t, i) {
  var s5, u5;
  let n4 = r5.gl, o4 = (s5 = r5.HALF_FLOAT) != null ? s5 : n4.UNSIGNED_BYTE, a4 = (u5 = r5.RGBA16F) != null ? u5 : n4.RGBA;
  n4.texImage2D(n4.TEXTURE_2D, 0, a4, e.width / 4, e.height / 4, 0, n4.RGBA, o4, null), i.colorAttachment.set(t);
}
H$3(OL$1, "bindTextureToFramebuffer");
function VL$1(r5, e) {
  let t = r5.context, i = t.gl, n4 = e.heatmapFbo;
  if (!n4) return;
  t.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, n4.colorAttachment.get()), t.activeTexture.set(i.TEXTURE1);
  let o4 = e.colorRampTexture;
  o4 || (o4 = e.colorRampTexture = new ve$2(t, e.colorRamp, i.RGBA)), o4.bind(i.LINEAR, i.CLAMP_TO_EDGE), r5.useProgram("heatmapTexture").draw(t, i.TRIANGLES, ee$1.disabled, fe$1.disabled, r5.colorModeForRenderPass(), ue$1.disabled, rS$1(r5, e, 0, 1), null, e.id, r5.viewportBuffer, r5.quadTriangleIndexBuffer, r5.viewportSegments, e.paint, r5.transform.zoom);
}
H$3(VL$1, "renderTextureToMap");
a();
function DS$1(r5, e, t, i) {
  if (r5.renderPass !== "translucent") return;
  let n4 = t.paint.get("line-opacity"), o4 = t.paint.get("line-width");
  if (n4.constantOr(1) === 0 || o4.constantOr(1) === 0) return;
  let a4 = r5.depthModeForSublayer(0, ee$1.ReadOnly), s5 = r5.colorModeForRenderPass(), u5 = t.paint.get("line-dasharray"), c = t.paint.get("line-pattern"), p4 = c.constantOr(1), h = t.paint.get("line-gradient"), f = t.getCrossfadeParameters(), m5 = p4 ? "linePattern" : u5 ? "lineSDF" : h ? "lineGradient" : "line", y4 = r5.context, g = y4.gl, x2 = true;
  for (let b of i) {
    let w3 = e.getTile(b);
    if (p4 && !w3.patternsLoaded()) continue;
    let _ = w3.getBucket(t);
    if (!_) continue;
    let S4 = _.programConfigurations.get(t.id), P4 = r5.context.program.get(), T3 = r5.useProgram(m5, S4), L3 = x2 || T3.program !== P4, C3 = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(b), E4 = c.constantOr(null);
    if (E4 && w3.imageAtlas) {
      let z4 = w3.imageAtlas, k3 = z4.patternPositions[E4.to.toString()], M3 = z4.patternPositions[E4.from.toString()];
      k3 && M3 && S4.setConstantPatternPositions(k3, M3);
    }
    let I3 = C3 ? b : null, R3 = p4 ? hS$1(r5, w3, t, f, I3) : u5 ? fS$1(r5, w3, t, u5, f, I3) : h ? pS$1(r5, w3, t, _.lineClipsArray.length, I3) : qu$1(r5, w3, t, I3);
    if (p4) y4.activeTexture.set(g.TEXTURE0), w3.imageAtlasTexture.bind(g.LINEAR, g.CLAMP_TO_EDGE), S4.updatePaintBuffers(f);
    else if (u5 && (L3 || r5.lineAtlas.dirty)) y4.activeTexture.set(g.TEXTURE0), r5.lineAtlas.bind(y4);
    else if (h) {
      let z4 = _.gradients[t.id], k3 = z4.texture;
      if (t.gradientVersion !== z4.version) {
        let M3 = 256;
        if (t.stepInterpolant) {
          let G3 = e.getSource().maxzoom, K4 = b.canonical.z === G3 ? Math.ceil(1 << r5.transform.maxZoom - b.canonical.z) : 1, W4 = _.maxLineLength / 8192 * 1024 * K4;
          M3 = Ae$2(Qx$1(W4), 256, y4.maxTextureSize);
        }
        z4.gradient = Rl({ expression: t.gradientExpression(), evaluationKey: "lineProgress", resolution: M3, image: z4.gradient || void 0, clips: _.lineClipsArray }), z4.texture ? z4.texture.update(z4.gradient) : z4.texture = new ve$2(y4, z4.gradient, g.RGBA), z4.version = t.gradientVersion, k3 = z4.texture;
      }
      y4.activeTexture.set(g.TEXTURE0), k3.bind(t.stepInterpolant ? g.NEAREST : g.LINEAR, g.CLAMP_TO_EDGE);
    }
    T3.draw(y4, g.TRIANGLES, a4, r5.stencilModeForClipping(b), s5, ue$1.disabled, R3, C3, t.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, t.paint, r5.transform.zoom, S4, _.layoutVertexBuffer2), x2 = false;
  }
}
H$3(DS$1, "drawLine");
a();
a();
function Cc$1(r5, e, t, i, n4) {
  if (!t || !i || !i.imageAtlas) return;
  let o4 = i.imageAtlas.patternPositions, a4 = o4[t.to.toString()], s5 = o4[t.from.toString()];
  if (!a4 && s5 && (a4 = s5), !s5 && a4 && (s5 = a4), !a4 || !s5) {
    let u5 = n4.getPaintProperty(e);
    a4 = o4[u5], s5 = o4[u5];
  }
  a4 && s5 && r5.setConstantPatternPositions(a4, s5);
}
H$3(Cc$1, "updatePatternPositionsInProgram");
function FS$1(r5, e, t, i) {
  let n4 = t.paint.get("fill-color"), o4 = t.paint.get("fill-opacity");
  if (o4.constantOr(1) === 0) return;
  let a4 = r5.colorModeForRenderPass(), s5 = t.paint.get("fill-pattern"), u5 = r5.opaquePassEnabledForLayer() && !s5.constantOr(1) && n4.constantOr(X$1.transparent).a === 1 && o4.constantOr(0) === 1 ? "opaque" : "translucent";
  if (r5.renderPass === u5) {
    let c = r5.depthModeForSublayer(1, r5.renderPass === "opaque" ? ee$1.ReadWrite : ee$1.ReadOnly);
    zS$1(r5, e, t, i, c, a4, false);
  }
  if (r5.renderPass === "translucent" && t.paint.get("fill-antialias")) {
    let c = r5.depthModeForSublayer(t.getPaintProperty("fill-outline-color") ? 2 : 0, ee$1.ReadOnly);
    zS$1(r5, e, t, i, c, a4, true);
  }
}
H$3(FS$1, "drawFill");
function zS$1(r5, e, t, i, n4, o4, a4) {
  let s5 = r5.context.gl, u5 = "fill-pattern", c = t.paint.get(u5), p4 = c && c.constantOr(1), h = t.getCrossfadeParameters(), f, m5, y4, g, x2;
  a4 ? (m5 = p4 && !t.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", f = s5.LINES) : (m5 = p4 ? "fillPattern" : "fill", f = s5.TRIANGLES);
  let b = c.constantOr(null);
  for (let w3 of i) {
    let _ = e.getTile(w3);
    if (p4 && !_.patternsLoaded()) continue;
    let S4 = _.getBucket(t);
    if (!S4) continue;
    let P4 = S4.programConfigurations.get(t.id), T3 = r5.useProgram(m5, P4), L3 = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(w3);
    p4 && (r5.context.activeTexture.set(s5.TEXTURE0), _.imageAtlasTexture.bind(s5.LINEAR, s5.CLAMP_TO_EDGE), P4.updatePaintBuffers(h)), Cc$1(P4, u5, b, _, t);
    let C3 = L3 ? w3 : null, E4 = C3 ? C3.posMatrix : w3.posMatrix, I3 = r5.translatePosMatrix(E4, _, t.paint.get("fill-translate"), t.paint.get("fill-translate-anchor"));
    if (!a4) g = S4.indexBuffer, x2 = S4.segments, y4 = p4 ? Py$1(I3, r5, h, _) : Sy(I3);
    else {
      g = S4.indexBuffer2, x2 = S4.segments2;
      let R3 = [s5.drawingBufferWidth, s5.drawingBufferHeight];
      y4 = m5 === "fillOutlinePattern" && p4 ? jw(I3, r5, h, _, R3) : qw(I3, R3);
    }
    T3.draw(r5.context, f, n4, r5.stencilModeForClipping(w3), o4, ue$1.disabled, y4, L3, t.id, S4.layoutVertexBuffer, g, x2, t.paint, r5.transform.zoom, P4);
  }
}
H$3(zS$1, "drawFillTiles");
a();
function RS$1(r5, e, t, i) {
  let n4 = t.paint.get("fill-extrusion-opacity");
  if (n4 !== 0 && r5.renderPass === "translucent") {
    let o4 = new ee$1(r5.context.gl.LEQUAL, ee$1.ReadWrite, r5.depthRangeFor3D);
    if (n4 === 1 && !t.paint.get("fill-extrusion-pattern").constantOr(1)) {
      let a4 = r5.colorModeForRenderPass();
      wg(r5, e, t, i, o4, fe$1.disabled, a4);
    } else wg(r5, e, t, i, o4, fe$1.disabled, ke$1.disabled), wg(r5, e, t, i, o4, r5.stencilModeFor3D(), r5.colorModeForRenderPass());
  }
}
H$3(RS$1, "drawFillExtrusion");
function wg(r5, e, t, i, n4, o4, a4) {
  let s5 = r5.context, u5 = s5.gl, c = "fill-extrusion-pattern", p4 = t.paint.get(c), h = p4.constantOr(1), f = t.getCrossfadeParameters(), m5 = t.paint.get("fill-extrusion-opacity"), y4 = p4.constantOr(null);
  for (let g of i) {
    let x2 = e.getTile(g), b = x2.getBucket(t);
    if (!b) continue;
    let w3 = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(g), _ = b.programConfigurations.get(t.id), S4 = r5.useProgram(h ? "fillExtrusionPattern" : "fillExtrusion", _);
    h && (r5.context.activeTexture.set(u5.TEXTURE0), x2.imageAtlasTexture.bind(u5.LINEAR, u5.CLAMP_TO_EDGE), _.updatePaintBuffers(f)), Cc$1(_, c, y4, x2, t);
    let P4 = r5.translatePosMatrix(g.posMatrix, x2, t.paint.get("fill-extrusion-translate"), t.paint.get("fill-extrusion-translate-anchor")), T3 = t.paint.get("fill-extrusion-vertical-gradient"), L3 = h ? Ow(P4, r5, T3, m5, g, f, x2) : wy(P4, r5, T3, m5);
    S4.draw(s5, s5.gl.TRIANGLES, n4, o4, a4, ue$1.backCCW, L3, w3, t.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, t.paint, r5.transform.zoom, _, r5.style.map.terrain && b.centroidVertexBuffer);
  }
}
H$3(wg, "drawExtrusionTiles");
a();
function BS$1(r5, e, t, i) {
  if (r5.renderPass !== "offscreen" && r5.renderPass !== "translucent") return;
  let n4 = r5.context, o4 = r5.depthModeForSublayer(0, ee$1.ReadOnly), a4 = r5.colorModeForRenderPass(), [s5, u5] = r5.renderPass === "translucent" ? r5.stencilConfigForOverlap(i) : [{}, i];
  for (let c of u5) {
    let p4 = e.getTile(c);
    typeof p4.needsHillshadePrepare < "u" && p4.needsHillshadePrepare && r5.renderPass === "offscreen" ? NL$1(r5, p4, t, o4, fe$1.disabled, a4) : r5.renderPass === "translucent" && UL$1(r5, c, p4, t, o4, s5[c.overscaledZ], a4);
  }
  n4.viewport.set([0, 0, r5.width, r5.height]);
}
H$3(BS$1, "drawHillshade");
function UL$1(r5, e, t, i, n4, o4, a4) {
  let s5 = r5.context, u5 = s5.gl, c = t.fbo;
  if (!c) return;
  let p4 = r5.useProgram("hillshade"), h = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(e);
  s5.activeTexture.set(u5.TEXTURE0), u5.bindTexture(u5.TEXTURE_2D, c.colorAttachment.get());
  let f = h ? e : null;
  p4.draw(s5, u5.TRIANGLES, n4, o4, a4, ue$1.disabled, oS$1(r5, t, i, f), h, i.id, r5.rasterBoundsBuffer, r5.quadTriangleIndexBuffer, r5.rasterBoundsSegments);
}
H$3(UL$1, "renderHillshade");
function NL$1(r5, e, t, i, n4, o4) {
  let a4 = r5.context, s5 = a4.gl, u5 = e.dem;
  if (u5 && u5.data) {
    let c = u5.dim, p4 = u5.stride, h = u5.getPixels();
    if (a4.activeTexture.set(s5.TEXTURE1), a4.pixelStoreUnpackPremultiplyAlpha.set(false), e.demTexture = e.demTexture || r5.getTileTexture(p4), e.demTexture) {
      let m5 = e.demTexture;
      m5.update(h, { premultiply: false }), m5.bind(s5.NEAREST, s5.CLAMP_TO_EDGE);
    } else e.demTexture = new ve$2(a4, h, s5.RGBA, { premultiply: false }), e.demTexture.bind(s5.NEAREST, s5.CLAMP_TO_EDGE);
    a4.activeTexture.set(s5.TEXTURE0);
    let f = e.fbo;
    if (!f) {
      let m5 = new ve$2(a4, { width: c, height: c, data: null }, s5.RGBA);
      m5.bind(s5.LINEAR, s5.CLAMP_TO_EDGE), f = e.fbo = a4.createFramebuffer(c, c, true, false), f.colorAttachment.set(m5.texture);
    }
    a4.bindFramebuffer.set(f.framebuffer), a4.viewport.set([0, 0, c, c]), r5.useProgram("hillshadePrepare").draw(a4, s5.TRIANGLES, i, n4, o4, ue$1.disabled, aS$1(e.tileID, u5), null, t.id, r5.rasterBoundsBuffer, r5.quadTriangleIndexBuffer, r5.rasterBoundsSegments), e.needsHillshadePrepare = false;
  }
}
H$3(NL$1, "prepareHillshade");
a();
function OS$1(r5, e, t, i) {
  if (r5.renderPass !== "translucent" || t.paint.get("raster-opacity") === 0 || !i.length) return;
  let n4 = r5.context, o4 = n4.gl, a4 = e.getSource(), s5 = r5.useProgram("raster"), u5 = r5.colorModeForRenderPass(), [c, p4] = a4 instanceof Lt$1 ? [{}, i] : r5.stencilConfigForOverlap(i), h = p4[p4.length - 1].overscaledZ, f = !r5.options.moving;
  for (let m5 of p4) {
    let y4 = r5.depthModeForSublayer(m5.overscaledZ - h, t.paint.get("raster-opacity") === 1 ? ee$1.ReadWrite : ee$1.ReadOnly, o4.LESS), g = e.getTile(m5);
    g.registerFadeDuration(t.paint.get("raster-fade-duration"));
    let x2 = e.findLoadedParent(m5, 0), b = GL$1(g, x2, e, t, r5.transform, r5.style.map.terrain), w3, _, S4 = t.paint.get("raster-resampling") === "nearest" ? o4.NEAREST : o4.LINEAR;
    n4.activeTexture.set(o4.TEXTURE0), g.texture.bind(S4, o4.CLAMP_TO_EDGE, o4.LINEAR_MIPMAP_NEAREST), n4.activeTexture.set(o4.TEXTURE1), x2 ? (x2.texture.bind(S4, o4.CLAMP_TO_EDGE, o4.LINEAR_MIPMAP_NEAREST), w3 = Math.pow(2, x2.tileID.overscaledZ - g.tileID.overscaledZ), _ = [g.tileID.canonical.x * w3 % 1, g.tileID.canonical.y * w3 % 1]) : g.texture.bind(S4, o4.CLAMP_TO_EDGE, o4.LINEAR_MIPMAP_NEAREST);
    let P4 = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(m5), T3 = P4 ? m5 : null, L3 = T3 ? T3.posMatrix : r5.transform.calculatePosMatrix(m5.toUnwrapped(), f), C3 = gS$1(L3, _ || [0, 0], w3 || 1, b, t);
    a4 instanceof Lt$1 ? s5.draw(n4, o4.TRIANGLES, y4, fe$1.disabled, u5, ue$1.disabled, C3, P4, t.id, a4.boundsBuffer, r5.quadTriangleIndexBuffer, a4.boundsSegments) : s5.draw(n4, o4.TRIANGLES, y4, c[m5.overscaledZ], u5, ue$1.disabled, C3, P4, t.id, r5.rasterBoundsBuffer, r5.quadTriangleIndexBuffer, r5.rasterBoundsSegments);
  }
}
H$3(OS$1, "drawRaster");
function GL$1(r5, e, t, i, n4, o4) {
  let a4 = i.paint.get("raster-fade-duration");
  if (!o4 && a4 > 0) {
    let s5 = Y$1.now(), u5 = (s5 - r5.timeAdded) / a4, c = e ? (s5 - e.timeAdded) / a4 : -1, p4 = t.getSource(), h = n4.coveringZoomLevel({ tileSize: p4.tileSize, roundZoom: p4.roundZoom }), f = !e || Math.abs(e.tileID.overscaledZ - h) > Math.abs(r5.tileID.overscaledZ - h), m5 = f && r5.refreshedUponExpiration ? 1 : Ae$2(f ? u5 : 1 - c, 0, 1);
    return r5.refreshedUponExpiration && u5 >= 1 && (r5.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - m5 } : { opacity: m5, mix: 0 };
  } else return { opacity: 1, mix: 0 };
}
H$3(GL$1, "getFadeValues");
a();
function VS$1(r5, e, t, i) {
  let n4 = t.paint.get("background-color"), o4 = t.paint.get("background-opacity");
  if (o4 === 0) return;
  let a4 = r5.context, s5 = a4.gl, u5 = r5.transform, c = u5.tileSize, p4 = t.paint.get("background-pattern");
  if (r5.isPatternMissing(p4)) return;
  let h = !p4 && n4.a === 1 && o4 === 1 && r5.opaquePassEnabledForLayer() ? "opaque" : "translucent";
  if (r5.renderPass !== h) return;
  let f = fe$1.disabled, m5 = r5.depthModeForSublayer(0, h === "opaque" ? ee$1.ReadWrite : ee$1.ReadOnly), y4 = r5.colorModeForRenderPass(), g = r5.useProgram(p4 ? "backgroundPattern" : "background"), x2 = i || u5.coveringTiles({ tileSize: c, terrain: r5.style.map.terrain });
  p4 && (a4.activeTexture.set(s5.TEXTURE0), r5.imageManager.bind(r5.context));
  let b = t.getCrossfadeParameters();
  for (let w3 of x2) {
    let _ = i ? w3.posMatrix : r5.transform.calculatePosMatrix(w3.toUnwrapped()), S4 = p4 ? TS$1(_, o4, r5, p4, { tileID: w3, tileSize: c }, b) : PS$1(_, o4, n4), P4 = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(w3);
    g.draw(a4, s5.TRIANGLES, m5, f, y4, ue$1.disabled, S4, P4, t.id, r5.tileExtentBuffer, r5.quadTriangleIndexBuffer, r5.tileExtentSegments);
  }
}
H$3(VS$1, "drawBackground");
a();
var qL$1 = new X$1(1, 0, 0, 1), jL$1 = new X$1(0, 1, 0, 1), ZL = new X$1(0, 0, 1, 1), HL$1 = new X$1(1, 0, 1, 1), $L = new X$1(0, 1, 1, 1);
function GS(r5) {
  let e = r5.transform.padding, t = 3;
  US$1(r5, r5.transform.height - (e.top || 0), t, qL$1), US$1(r5, e.bottom || 0, t, jL$1), NS$1(r5, e.left || 0, t, ZL), NS$1(r5, r5.transform.width - (e.right || 0), t, HL$1);
  let i = r5.transform.centerPoint;
  WL$1(r5, i.x, r5.transform.height - i.y, $L);
}
H$3(GS, "drawDebugPadding");
function WL$1(r5, e, t, i) {
  Ec$1(r5, e - 2 / 2, t - 20 / 2, 2, 20, i), Ec$1(r5, e - 20 / 2, t - 2 / 2, 20, 2, i);
}
H$3(WL$1, "drawCrosshair");
function US$1(r5, e, t, i) {
  Ec$1(r5, 0, e + t / 2, r5.transform.width, t, i);
}
H$3(US$1, "drawHorizontalLine");
function NS$1(r5, e, t, i) {
  Ec$1(r5, e - t / 2, 0, t, r5.transform.height, i);
}
H$3(NS$1, "drawVerticalLine");
function Ec$1(r5, e, t, i, n4, o4) {
  let a4 = r5.context, s5 = a4.gl;
  s5.enable(s5.SCISSOR_TEST), s5.scissor(e * r5.pixelRatio, t * r5.pixelRatio, i * r5.pixelRatio, n4 * r5.pixelRatio), a4.clear({ color: o4 }), s5.disable(s5.SCISSOR_TEST);
}
H$3(Ec$1, "drawDebugSSRect");
function qS$1(r5, e, t) {
  for (let i = 0; i < t.length; i++) XL$1(r5, e, t[i]);
}
H$3(qS$1, "drawDebug");
function XL$1(r5, e, t) {
  let i = r5.context, n4 = i.gl, o4 = t.posMatrix, a4 = r5.useProgram("debug"), s5 = ee$1.disabled, u5 = fe$1.disabled, c = r5.colorModeForRenderPass(), p4 = "$debug", h = r5.style.map.terrain && r5.style.map.terrain.getTerrainData(t);
  i.activeTexture.set(n4.TEXTURE0);
  let f = e.getTileByID(t.key).latestRawTileData, m5 = f && f.byteLength || 0, y4 = Math.floor(m5 / 1024), g = e.getTile(t).tileSize, x2 = 512 / Math.min(g, 512) * (t.overscaledZ / r5.transform.zoom) * 0.5, b = t.canonical.toString();
  t.overscaledZ !== t.canonical.z && (b += " => ".concat(t.overscaledZ));
  let w3 = "".concat(b, " ").concat(y4, "kB");
  KL(r5, w3), a4.draw(i, n4.TRIANGLES, s5, u5, ke$1.alphaBlended, ue$1.disabled, Ty(o4, X$1.transparent, x2), null, p4, r5.debugBuffer, r5.quadTriangleIndexBuffer, r5.debugSegments), a4.draw(i, n4.LINE_STRIP, s5, u5, c, ue$1.disabled, Ty(o4, X$1.red), h, p4, r5.debugBuffer, r5.tileBorderIndexBuffer, r5.debugSegments);
}
H$3(XL$1, "drawDebugTile");
function KL(r5, e) {
  r5.initDebugOverlayCanvas();
  let t = r5.debugOverlayCanvas, i = r5.context.gl, n4 = r5.debugOverlayCanvas.getContext("2d");
  n4.clearRect(0, 0, t.width, t.height), n4.shadowColor = "white", n4.shadowBlur = 2, n4.lineWidth = 1.5, n4.strokeStyle = "white", n4.textBaseline = "top", n4.font = "bold 36px Open Sans, sans-serif", n4.fillText(e, 5, 5), n4.strokeText(e, 5, 5), r5.debugOverlayTexture.update(t), r5.debugOverlayTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
}
H$3(KL, "drawTextToOverlay");
function jS$1(r5, e) {
  let t = null, n4 = Object.values(r5._layers).flatMap((u5) => u5.source && !u5.isHidden(e) ? [r5.sourceCaches[u5.source]] : []), o4 = n4.filter((u5) => u5.getSource().type === "vector"), a4 = n4.filter((u5) => u5.getSource().type !== "vector"), s5 = H$3((u5) => {
    (!t || t.getSource().maxzoom < u5.getSource().maxzoom) && (t = u5);
  }, "considerSource");
  return o4.forEach((u5) => s5(u5)), t || a4.forEach((u5) => s5(u5)), t;
}
H$3(jS$1, "selectDebugSource");
a();
function ZS$1(r5, e, t) {
  let i = r5.context, n4 = t.implementation;
  if (r5.renderPass === "offscreen") {
    let o4 = n4.prerender;
    o4 && (r5.setCustomLayerDefaults(), i.setColorMode(r5.colorModeForRenderPass()), o4.call(n4, i.gl, r5.transform.customLayerMatrix()), i.setDirty(), r5.setBaseState());
  } else if (r5.renderPass === "translucent") {
    r5.setCustomLayerDefaults(), i.setColorMode(r5.colorModeForRenderPass()), i.setStencilMode(fe$1.disabled);
    let o4 = n4.renderingMode === "3d" ? new ee$1(r5.context.gl.LEQUAL, ee$1.ReadWrite, r5.depthRangeFor3D) : r5.depthModeForSublayer(0, ee$1.ReadOnly);
    i.setDepthMode(o4), n4.render(i.gl, r5.transform.customLayerMatrix()), i.setDirty(), r5.setBaseState(), i.bindFramebuffer.set(null);
  }
}
H$3(ZS$1, "drawCustom");
a();
function HS$1(r5, e) {
  let t = r5.context, i = t.gl, n4 = ke$1.unblended, o4 = new ee$1(i.LEQUAL, ee$1.ReadWrite, [0, 1]), a4 = e.getTerrainMesh(), s5 = e.sourceCache.getRenderableTiles(), u5 = r5.useProgram("terrainDepth");
  t.bindFramebuffer.set(e.getFramebuffer("depth").framebuffer), t.viewport.set([0, 0, r5.width / devicePixelRatio, r5.height / devicePixelRatio]), t.clear({ color: X$1.transparent, depth: 1 });
  for (let c of s5) {
    let p4 = e.getTerrainData(c.tileID), h = r5.transform.calculatePosMatrix(c.tileID.toUnwrapped()), f = Dw(h, e.getMeshFrameDelta(r5.transform.zoom));
    u5.draw(t, i.TRIANGLES, o4, fe$1.disabled, n4, ue$1.backCCW, f, p4, "terrain", a4.vertexBuffer, a4.indexBuffer, a4.segments);
  }
  t.bindFramebuffer.set(null), t.viewport.set([0, 0, r5.width, r5.height]);
}
H$3(HS$1, "drawDepth");
function $S$1(r5, e) {
  let t = r5.context, i = t.gl, n4 = ke$1.unblended, o4 = new ee$1(i.LEQUAL, ee$1.ReadWrite, [0, 1]), a4 = e.getTerrainMesh(), s5 = e.getCoordsTexture(), u5 = e.sourceCache.getRenderableTiles(), c = r5.useProgram("terrainCoords");
  t.bindFramebuffer.set(e.getFramebuffer("coords").framebuffer), t.viewport.set([0, 0, r5.width / devicePixelRatio, r5.height / devicePixelRatio]), t.clear({ color: X$1.transparent, depth: 1 }), e.coordsIndex = [];
  for (let p4 of u5) {
    let h = e.getTerrainData(p4.tileID);
    t.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, s5.texture);
    let f = r5.transform.calculatePosMatrix(p4.tileID.toUnwrapped()), m5 = zw(f, 255 - e.coordsIndex.length, e.getMeshFrameDelta(r5.transform.zoom));
    c.draw(t, i.TRIANGLES, o4, fe$1.disabled, n4, ue$1.backCCW, m5, h, "terrain", a4.vertexBuffer, a4.indexBuffer, a4.segments), e.coordsIndex.push(p4.tileID.key);
  }
  t.bindFramebuffer.set(null), t.viewport.set([0, 0, r5.width, r5.height]);
}
H$3($S$1, "drawCoords");
function Sg$1(r5, e, t) {
  let i = r5.context, n4 = i.gl, o4 = r5.colorModeForRenderPass(), a4 = new ee$1(n4.LEQUAL, ee$1.ReadWrite, r5.depthRangeFor3D), s5 = r5.useProgram("terrain"), u5 = e.getTerrainMesh();
  i.bindFramebuffer.set(null), i.viewport.set([0, 0, r5.width, r5.height]);
  for (let c of t) {
    let p4 = r5.renderToTexture.getTexture(c), h = e.getTerrainData(c.tileID);
    i.activeTexture.set(n4.TEXTURE0), n4.bindTexture(n4.TEXTURE_2D, p4.texture);
    let f = r5.transform.calculatePosMatrix(c.tileID.toUnwrapped()), m5 = Lw(f, e.getMeshFrameDelta(r5.transform.zoom));
    s5.draw(i, n4.TRIANGLES, a4, fe$1.disabled, o4, ue$1.backCCW, m5, h, "terrain", u5.vertexBuffer, u5.indexBuffer, u5.segments);
  }
}
H$3(Sg$1, "drawTerrain");
var Pg = class Pg2 {
  constructor(e, t) {
    this.context = new Ac$1(e), this.transform = t, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: q$2.identity(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = cr.maxUnderzooming + cr.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Pn$2();
  }
  resize(e, t, i) {
    if (this.width = Math.floor(e * i), this.height = Math.floor(t * i), this.pixelRatio = i, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (let n4 of this.style._order) this.style._layers[n4].resize();
  }
  setup() {
    let e = this.context, t = new Ar$1();
    t.emplaceBack(0, 0), t.emplaceBack(8192, 0), t.emplaceBack(0, 8192), t.emplaceBack(8192, 8192), this.tileExtentBuffer = e.createVertexBuffer(t, Ou$1.members), this.tileExtentSegments = me$1.simpleSegment(0, 0, 4, 2);
    let i = new Ar$1();
    i.emplaceBack(0, 0), i.emplaceBack(8192, 0), i.emplaceBack(0, 8192), i.emplaceBack(8192, 8192), this.debugBuffer = e.createVertexBuffer(i, Ou$1.members), this.debugSegments = me$1.simpleSegment(0, 0, 4, 5);
    let n4 = new nn$1();
    n4.emplaceBack(0, 0, 0, 0), n4.emplaceBack(8192, 0, 8192, 0), n4.emplaceBack(0, 8192, 0, 8192), n4.emplaceBack(8192, 8192, 8192, 8192), this.rasterBoundsBuffer = e.createVertexBuffer(n4, Or$2.members), this.rasterBoundsSegments = me$1.simpleSegment(0, 0, 4, 2);
    let o4 = new Ar$1();
    o4.emplaceBack(0, 0), o4.emplaceBack(1, 0), o4.emplaceBack(0, 1), o4.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(o4, Ou$1.members), this.viewportSegments = me$1.simpleSegment(0, 0, 4, 2);
    let a4 = new Fo$1();
    a4.emplaceBack(0), a4.emplaceBack(1), a4.emplaceBack(3), a4.emplaceBack(2), a4.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(a4);
    let s5 = new it$2();
    s5.emplaceBack(0, 1, 2), s5.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s5);
    let u5 = this.context.gl;
    this.stencilClearMode = new fe$1({ func: u5.ALWAYS, mask: 0 }, 0, 255, u5.ZERO, u5.ZERO, u5.ZERO);
  }
  clearStencil() {
    let e = this.context, t = e.gl;
    this.nextStencilID = 1, this.currentStencilSource = void 0;
    let i = q$2.create();
    q$2.ortho(i, 0, this.width, this.height, 0, 0, 1), q$2.scale(i, i, [t.drawingBufferWidth, t.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, t.TRIANGLES, ee$1.disabled, this.stencilClearMode, ke$1.disabled, ue$1.disabled, My(i), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
  }
  _renderTileClippingMasks(e, t) {
    if (this.currentStencilSource === e.source || !e.isTileClipped() || !t || !t.length) return;
    this.currentStencilSource = e.source;
    let i = this.context, n4 = i.gl;
    this.nextStencilID + t.length > 256 && this.clearStencil(), i.setColorMode(ke$1.disabled), i.setDepthMode(ee$1.disabled);
    let o4 = this.useProgram("clippingMask");
    this._tileClippingMaskIDs = {};
    for (let a4 of t) {
      let s5 = this._tileClippingMaskIDs[a4.key] = this.nextStencilID++, u5 = this.style.map.terrain && this.style.map.terrain.getTerrainData(a4);
      o4.draw(i, n4.TRIANGLES, ee$1.disabled, new fe$1({ func: n4.ALWAYS, mask: 0 }, s5, 255, n4.KEEP, n4.KEEP, n4.REPLACE), ke$1.disabled, ue$1.disabled, My(a4.posMatrix), u5, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
    }
  }
  stencilModeFor3D() {
    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
    let e = this.nextStencilID++, t = this.context.gl;
    return new fe$1({ func: t.NOTEQUAL, mask: 255 }, e, 255, t.KEEP, t.KEEP, t.REPLACE);
  }
  stencilModeForClipping(e) {
    let t = this.context.gl;
    return new fe$1({ func: t.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE);
  }
  stencilConfigForOverlap(e) {
    let t = this.context.gl, i = e.sort((a4, s5) => s5.overscaledZ - a4.overscaledZ), n4 = i[i.length - 1].overscaledZ, o4 = i[0].overscaledZ - n4 + 1;
    if (o4 > 1) {
      this.currentStencilSource = void 0, this.nextStencilID + o4 > 256 && this.clearStencil();
      let a4 = {};
      for (let s5 = 0; s5 < o4; s5++) a4[s5 + n4] = new fe$1({ func: t.GEQUAL, mask: 255 }, s5 + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE);
      return this.nextStencilID += o4, [a4, i];
    }
    return [{ [n4]: fe$1.disabled }, i];
  }
  colorModeForRenderPass() {
    let e = this.context.gl;
    return this._showOverdrawInspector ? new ke$1([e.CONSTANT_COLOR, e.ONE], new X$1(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? ke$1.unblended : ke$1.alphaBlended;
  }
  depthModeForSublayer(e, t, i) {
    if (!this.opaquePassEnabledForLayer()) return ee$1.disabled;
    let n4 = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
    return new ee$1(i || this.context.gl.LEQUAL, t, [n4, n4]);
  }
  opaquePassEnabledForLayer() {
    return this.currentLayer < this.opaquePassCutoff;
  }
  render(e, t) {
    this.style = e, this.options = t, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(Y$1.now()), this.imageManager.beginFrame();
    let i = this.style._order, n4 = this.style.sourceCaches, o4 = {}, a4 = {}, s5 = {};
    for (let u5 in n4) {
      let c = n4[u5];
      c.used && c.prepare(this.context), o4[u5] = c.getVisibleCoordinates(), a4[u5] = o4[u5].slice().reverse(), s5[u5] = c.getVisibleCoordinates(true).reverse();
    }
    this.opaquePassCutoff = 1 / 0;
    for (let u5 = 0; u5 < i.length; u5++) {
      let c = i[u5];
      if (this.style._layers[c].is3D()) {
        this.opaquePassCutoff = u5;
        break;
      }
    }
    this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
    for (let u5 of i) {
      let c = this.style._layers[u5];
      if (!c.hasOffscreenPass() || c.isHidden(this.transform.zoom)) continue;
      let p4 = a4[c.source];
      c.type !== "custom" && !p4.length || this.renderLayer(this, n4[c.source], c, p4);
    }
    if (this.context.bindFramebuffer.set(null), this.context.clear({ color: t.showOverdrawInspector ? X$1.black : X$1.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = t.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = i.length - 1; this.currentLayer >= 0; this.currentLayer--) {
      let u5 = this.style._layers[i[this.currentLayer]], c = n4[u5.source], p4 = o4[u5.source];
      this._renderTileClippingMasks(u5, p4), this.renderLayer(this, c, u5, p4);
    }
    for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < i.length; this.currentLayer++) {
      let u5 = this.style._layers[i[this.currentLayer]], c = n4[u5.source];
      if (this.renderToTexture && this.renderToTexture.renderLayer(u5)) continue;
      let p4 = (u5.type === "symbol" ? s5 : a4)[u5.source];
      this._renderTileClippingMasks(u5, o4[u5.source]), this.renderLayer(this, c, u5, p4);
    }
    if (this.options.showTileBoundaries) {
      let u5 = jS$1(this.style, this.transform.zoom);
      u5 && qS$1(this, u5, u5.getVisibleCoordinates());
    }
    this.options.showPadding && GS(this), this.context.setDefault();
  }
  maybeDrawDepthAndCoords(e) {
    if (!this.style || !this.style.map || !this.style.map.terrain) return;
    let t = this.terrainFacilitator.matrix, i = this.transform.projMatrix, n4 = this.terrainFacilitator.dirty;
    n4 || (n4 = e ? !q$2.exactEquals(t, i) : !q$2.equals(t, i)), n4 || (n4 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), n4 && (q$2.copy(t, i), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, HS$1(this, this.style.map.terrain), $S$1(this, this.style.map.terrain));
  }
  renderLayer(e, t, i, n4) {
    if (!i.isHidden(this.transform.zoom) && !(i.type !== "background" && i.type !== "custom" && !(n4 || []).length)) switch (this.id = i.id, i.type) {
      case "symbol":
        ES$1(e, t, i, n4, this.style.placement.variableOffsets);
        break;
      case "circle":
        kS$1(e, t, i, n4);
        break;
      case "heatmap":
        LS$1(e, t, i, n4);
        break;
      case "line":
        DS$1(e, t, i, n4);
        break;
      case "fill":
        FS$1(e, t, i, n4);
        break;
      case "fill-extrusion":
        RS$1(e, t, i, n4);
        break;
      case "hillshade":
        BS$1(e, t, i, n4);
        break;
      case "raster":
        OS$1(e, t, i, n4);
        break;
      case "background":
        VS$1(e, t, i, n4);
        break;
      case "custom":
        ZS$1(e, t, i);
        break;
    }
  }
  translatePosMatrix(e, t, i, n4, o4) {
    if (!i[0] && !i[1]) return e;
    let a4 = o4 ? n4 === "map" ? this.transform.angle : 0 : n4 === "viewport" ? -this.transform.angle : 0;
    if (a4) {
      let c = Math.sin(a4), p4 = Math.cos(a4);
      i = [i[0] * p4 - i[1] * c, i[0] * c + i[1] * p4];
    }
    let s5 = [o4 ? i[0] : $e$1(t, i[0], this.transform.zoom), o4 ? i[1] : $e$1(t, i[1], this.transform.zoom), 0], u5 = new Float32Array(16);
    return q$2.translate(u5, e, s5), u5;
  }
  saveTileTexture(e) {
    let t = this._tileTextures[e.size[0]];
    t ? t.push(e) : this._tileTextures[e.size[0]] = [e];
  }
  getTileTexture(e) {
    let t = this._tileTextures[e];
    return t && t.length > 0 ? t.pop() : null;
  }
  isPatternMissing(e) {
    if (!e) return false;
    if (!e.from || !e.to) return true;
    let t = this.imageManager.getPattern(e.from.toString()), i = this.imageManager.getPattern(e.to.toString());
    return !t || !i;
  }
  useProgram(e, t) {
    this.cache = this.cache || {};
    let i = e + (t ? t.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
    return this.cache[i] || (this.cache[i] = new Nu$1(this.context, Ti$2[e], t, MS$1[e], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i];
  }
  setCustomLayerDefaults() {
    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
  }
  setBaseState() {
    let e = this.context.gl;
    this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
  }
  initDebugOverlayCanvas() {
    if (this.debugOverlayCanvas == null) {
      this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512;
      let e = this.context.gl;
      this.debugOverlayTexture = new ve$2(this.context, this.debugOverlayCanvas, e.RGBA);
    }
  }
  destroy() {
    this.debugOverlayTexture && this.debugOverlayTexture.destroy();
  }
  overLimit() {
    let { drawingBufferWidth: e, drawingBufferHeight: t } = this.context.gl;
    return this.width !== e || this.height !== t;
  }
};
H$3(Pg, "Painter");
var kc$1 = Pg;
a();
var We$1 = N$2(ge(), 1);
a();
var Dc2 = class Dc3 {
  constructor(e, t) {
    this.points = e;
    this.planes = t;
  }
  static fromInvProjectionMatrix(e, t, i) {
    let n4 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]], o4 = Math.pow(2, i), a4 = n4.map((c) => {
      c = qe$1.transformMat4([], c, e);
      let p4 = 1 / c[3] / t * o4;
      return qe$1.mul(c, c, [p4, p4, 1 / c[3], p4]);
    }), u5 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((c) => {
      let p4 = gt$1.sub([], a4[c[0]], a4[c[1]]), h = gt$1.sub([], a4[c[2]], a4[c[1]]), f = gt$1.normalize([], gt$1.cross([], p4, h)), m5 = -gt$1.dot(f, a4[c[1]]);
      return f.concat(m5);
    });
    return new Dc3(a4, u5);
  }
};
H$3(Dc2, "Frustum");
var Lc2 = Dc2, zc$1 = class zc2 {
  constructor(e, t) {
    this.min = e, this.max = t, this.center = gt$1.scale([], gt$1.add([], this.min, this.max), 0.5);
  }
  quadrant(e) {
    let t = [e % 2 === 0, e < 2], i = gt$1.clone(this.min), n4 = gt$1.clone(this.max);
    for (let o4 = 0; o4 < t.length; o4++) i[o4] = t[o4] ? this.min[o4] : this.center[o4], n4[o4] = t[o4] ? this.center[o4] : this.max[o4];
    return n4[2] = this.max[2], new zc2(i, n4);
  }
  distanceX(e) {
    return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
  }
  distanceY(e) {
    return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
  }
  intersects(e) {
    let t = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]], i = true;
    for (let n4 = 0; n4 < e.planes.length; n4++) {
      let o4 = e.planes[n4], a4 = 0;
      for (let s5 = 0; s5 < t.length; s5++) qe$1.dot(o4, t[s5]) >= 0 && a4++;
      if (a4 === 0) return 0;
      a4 !== t.length && (i = false);
    }
    if (i) return 2;
    for (let n4 = 0; n4 < 3; n4++) {
      let o4 = Number.MAX_VALUE, a4 = -Number.MAX_VALUE;
      for (let s5 = 0; s5 < e.points.length; s5++) {
        let u5 = e.points[s5][n4] - this.min[n4];
        o4 = Math.min(o4, u5), a4 = Math.max(a4, u5);
      }
      if (a4 < 0 || o4 > this.max[n4] - this.min[n4]) return 0;
    }
    return 1;
  }
};
H$3(zc$1, "Aabb");
var Ca$1 = zc$1;
a();
var WS$1 = N$2(ge(), 1);
var Fc$1 = class Fc2 {
  constructor(e = 0, t = 0, i = 0, n4 = 0) {
    if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(n4) || n4 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
    this.top = e, this.bottom = t, this.left = i, this.right = n4;
  }
  interpolate(e, t, i) {
    return t.top != null && e.top != null && (this.top = Pe$2.number(e.top, t.top, i)), t.bottom != null && e.bottom != null && (this.bottom = Pe$2.number(e.bottom, t.bottom, i)), t.left != null && e.left != null && (this.left = Pe$2.number(e.left, t.left, i)), t.right != null && e.right != null && (this.right = Pe$2.number(e.right, t.right, i)), this;
  }
  getCenter(e, t) {
    let i = Ae$2((this.left + e - this.right) / 2, 0, e), n4 = Ae$2((this.top + t - this.bottom) / 2, 0, t);
    return new WS$1.default(i, n4);
  }
  equals(e) {
    return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
  }
  clone() {
    return new Fc2(this.top, this.bottom, this.left, this.right);
  }
  toJSON() {
    return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
  }
};
H$3(Fc$1, "EdgeInsets");
var Ea2 = Fc$1;
var Rc$1 = 85.051129, Oc$1 = class Oc2 {
  constructor(e, t, i, n4, o4) {
    this.tileSize = 512, this._renderWorldCopies = o4 === void 0 ? true : !!o4, this._minZoom = e || 0, this._maxZoom = t || 22, this._minPitch = i == null ? 0 : i, this._maxPitch = n4 == null ? 60 : n4, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new ie$1(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new Ea2(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this.minElevationForCurrentTile = 0;
  }
  clone() {
    let e = new Oc2(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
    return e.apply(this), e;
  }
  apply(e) {
    this.tileSize = e.tileSize, this.latRange = e.latRange, this.width = e.width, this.height = e.height, this._center = e._center, this._elevation = e._elevation, this.minElevationForCurrentTile = e.minElevationForCurrentTile, this.zoom = e.zoom, this.angle = e.angle, this._fov = e._fov, this._pitch = e._pitch, this._unmodified = e._unmodified, this._edgeInsets = e._edgeInsets.clone(), this._calcMatrices();
  }
  get minZoom() {
    return this._minZoom;
  }
  set minZoom(e) {
    this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
  }
  get maxZoom() {
    return this._maxZoom;
  }
  set maxZoom(e) {
    this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
  }
  get minPitch() {
    return this._minPitch;
  }
  set minPitch(e) {
    this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
  }
  get maxPitch() {
    return this._maxPitch;
  }
  set maxPitch(e) {
    this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
  }
  get renderWorldCopies() {
    return this._renderWorldCopies;
  }
  set renderWorldCopies(e) {
    e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
  }
  get worldSize() {
    return this.tileSize * this.scale;
  }
  get centerOffset() {
    return this.centerPoint._sub(this.size._div(2));
  }
  get size() {
    return new We$1.default(this.width, this.height);
  }
  get bearing() {
    return -this.angle / Math.PI * 180;
  }
  set bearing(e) {
    let t = -er$1(e, -180, 180) * Math.PI / 180;
    this.angle !== t && (this._unmodified = false, this.angle = t, this._calcMatrices(), this.rotationMatrix = Vo$2.create(), Vo$2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
  }
  get pitch() {
    return this._pitch / Math.PI * 180;
  }
  set pitch(e) {
    let t = Ae$2(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
    this._pitch !== t && (this._unmodified = false, this._pitch = t, this._calcMatrices());
  }
  get fov() {
    return this._fov / Math.PI * 180;
  }
  set fov(e) {
    e = Math.max(0.01, Math.min(60, e)), this._fov !== e && (this._unmodified = false, this._fov = e / 180 * Math.PI, this._calcMatrices());
  }
  get zoom() {
    return this._zoom;
  }
  set zoom(e) {
    let t = Math.min(Math.max(e, this.minZoom), this.maxZoom);
    this._zoom !== t && (this._unmodified = false, this._zoom = t, this.tileZoom = Math.max(0, Math.floor(t)), this.scale = this.zoomScale(t), this._constrain(), this._calcMatrices());
  }
  get center() {
    return this._center;
  }
  set center(e) {
    e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
  }
  get elevation() {
    return this._elevation;
  }
  set elevation(e) {
    e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
  }
  get padding() {
    return this._edgeInsets.toJSON();
  }
  set padding(e) {
    this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
  }
  get centerPoint() {
    return this._edgeInsets.getCenter(this.width, this.height);
  }
  isPaddingEqual(e) {
    return this._edgeInsets.equals(e);
  }
  interpolatePadding(e, t, i) {
    this._unmodified = false, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();
  }
  coveringZoomLevel(e) {
    let t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
    return Math.max(0, t);
  }
  getVisibleUnwrappedCoordinates(e) {
    let t = [new _n$1(0, e)];
    if (this._renderWorldCopies) {
      let i = this.pointCoordinate(new We$1.default(0, 0)), n4 = this.pointCoordinate(new We$1.default(this.width, 0)), o4 = this.pointCoordinate(new We$1.default(this.width, this.height)), a4 = this.pointCoordinate(new We$1.default(0, this.height)), s5 = Math.floor(Math.min(i.x, n4.x, o4.x, a4.x)), u5 = Math.floor(Math.max(i.x, n4.x, o4.x, a4.x)), c = 1;
      for (let p4 = s5 - c; p4 <= u5 + c; p4++) p4 !== 0 && t.push(new _n$1(p4, e));
    }
    return t;
  }
  coveringTiles(e) {
    var b, w3;
    let t = this.coveringZoomLevel(e), i = t;
    if (e.minzoom !== void 0 && t < e.minzoom) return [];
    e.maxzoom !== void 0 && t > e.maxzoom && (t = e.maxzoom);
    let n4 = this.pointCoordinate(this.getCameraPoint()), o4 = Fe$1.fromLngLat(this.center), a4 = Math.pow(2, t), s5 = [a4 * n4.x, a4 * n4.y, 0], u5 = [a4 * o4.x, a4 * o4.y, 0], c = Lc2.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t), p4 = e.minzoom || 0;
    !e.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (p4 = t);
    let h = e.terrain ? 2 / Math.min(this.tileSize, e.tileSize) * this.tileSize : 3, f = H$3((_) => ({ aabb: new Ca$1([_ * a4, 0, 0], [(_ + 1) * a4, a4, 0]), zoom: 0, x: 0, y: 0, wrap: _, fullyVisible: false }), "newRootTile"), m5 = [], y4 = [], g = t, x2 = e.reparseOverscaled ? i : t;
    if (this._renderWorldCopies) for (let _ = 1; _ <= 3; _++) m5.push(f(-_)), m5.push(f(_));
    for (m5.push(f(0)); m5.length > 0; ) {
      let _ = m5.pop(), S4 = _.x, P4 = _.y, T3 = _.fullyVisible;
      if (!T3) {
        let z4 = _.aabb.intersects(c);
        if (z4 === 0) continue;
        T3 = z4 === 2;
      }
      let L3 = e.terrain ? s5 : u5, C3 = _.aabb.distanceX(L3), E4 = _.aabb.distanceY(L3), I3 = Math.max(Math.abs(C3), Math.abs(E4)), R3 = h + (1 << g - _.zoom) - 2;
      if (_.zoom === g || I3 > R3 && _.zoom >= p4) {
        let z4 = g - _.zoom, k3 = s5[0] - 0.5 - (S4 << z4), M3 = s5[1] - 0.5 - (P4 << z4);
        y4.push({ tileID: new Je(_.zoom === g ? x2 : _.zoom, _.wrap, _.zoom, S4, P4), distanceSq: sn.sqrLen([u5[0] - 0.5 - S4, u5[1] - 0.5 - P4]), tileDistanceToCamera: Math.sqrt(k3 * k3 + M3 * M3) });
        continue;
      }
      for (let z4 = 0; z4 < 4; z4++) {
        let k3 = (S4 << 1) + z4 % 2, M3 = (P4 << 1) + (z4 >> 1), G3 = _.zoom + 1, K4 = _.aabb.quadrant(z4);
        if (e.terrain) {
          let ne2 = new Je(G3, _.wrap, G3, k3, M3), J4 = e.terrain.getMinMaxElevation(ne2), W4 = (b = J4.minElevation) != null ? b : this.elevation, Ye2 = (w3 = J4.maxElevation) != null ? w3 : this.elevation;
          K4 = new Ca$1([K4.min[0], K4.min[1], W4], [K4.max[0], K4.max[1], Ye2]);
        }
        m5.push({ aabb: K4, zoom: G3, x: k3, y: M3, wrap: _.wrap, fullyVisible: T3 });
      }
    }
    return y4.sort((_, S4) => _.distanceSq - S4.distanceSq).map((_) => _.tileID);
  }
  resize(e, t) {
    this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();
  }
  get unmodified() {
    return this._unmodified;
  }
  zoomScale(e) {
    return Math.pow(2, e);
  }
  scaleZoom(e) {
    return Math.log(e) / Math.LN2;
  }
  project(e) {
    let t = Ae$2(e.lat, -Rc$1, Rc$1);
    return new We$1.default(Rr(e.lng) * this.worldSize, Br$1(t) * this.worldSize);
  }
  unproject(e) {
    return new Fe$1(e.x / this.worldSize, e.y / this.worldSize).toLngLat();
  }
  get point() {
    return this.project(this.center);
  }
  getCameraPosition() {
    let e = this.pointLocation(this.getCameraPoint()), t = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter;
    return { lngLat: e, altitude: t + this.elevation };
  }
  recalculateZoom(e) {
    let t = this.elevation, i = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, n4 = this.pointLocation(this.centerPoint, e), o4 = e.getElevationForLngLatZoom(n4, this.tileZoom);
    if (!(this.elevation - o4)) return;
    let s5 = i + t - o4, p4 = Math.cos(this._pitch) * this.cameraToCenterDistance / s5 / bu$1(1, n4.lat) / this.tileSize, h = this.scaleZoom(p4);
    this._elevation = o4, this._center = n4, this.zoom = h;
  }
  setLocationAtPoint(e, t) {
    let i = this.pointCoordinate(t), n4 = this.pointCoordinate(this.centerPoint), o4 = this.locationCoordinate(e), a4 = new Fe$1(o4.x - (i.x - n4.x), o4.y - (i.y - n4.y));
    this.center = this.coordinateLocation(a4), this._renderWorldCopies && (this.center = this.center.wrap());
  }
  locationPoint(e, t) {
    return t ? this.coordinatePoint(this.locationCoordinate(e), t.getElevationForLngLatZoom(e, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e));
  }
  pointLocation(e, t) {
    return this.coordinateLocation(this.pointCoordinate(e, t));
  }
  locationCoordinate(e) {
    return Fe$1.fromLngLat(e);
  }
  coordinateLocation(e) {
    return e && e.toLngLat();
  }
  pointCoordinate(e, t) {
    if (t) {
      let g = t.pointCoordinate(e);
      if (g != null) return g;
    }
    let i = 0, n4 = [e.x, e.y, 0, 1], o4 = [e.x, e.y, 1, 1];
    qe$1.transformMat4(n4, n4, this.pixelMatrixInverse), qe$1.transformMat4(o4, o4, this.pixelMatrixInverse);
    let a4 = n4[3], s5 = o4[3], u5 = n4[0] / a4, c = o4[0] / s5, p4 = n4[1] / a4, h = o4[1] / s5, f = n4[2] / a4, m5 = o4[2] / s5, y4 = f === m5 ? 0 : (i - f) / (m5 - f);
    return new Fe$1(Pe$2.number(u5, c, y4) / this.worldSize, Pe$2.number(p4, h, y4) / this.worldSize);
  }
  coordinatePoint(e, t = 0, i = this.pixelMatrix) {
    let n4 = [e.x * this.worldSize, e.y * this.worldSize, t, 1];
    return qe$1.transformMat4(n4, n4, i), new We$1.default(n4[0] / n4[3], n4[1] / n4[3]);
  }
  getBounds() {
    let e = Math.max(0, this.height / 2 - this.getHorizon());
    return new ut$1().extend(this.pointLocation(new We$1.default(0, e))).extend(this.pointLocation(new We$1.default(this.width, e))).extend(this.pointLocation(new We$1.default(this.width, this.height))).extend(this.pointLocation(new We$1.default(0, this.height)));
  }
  getMaxBounds() {
    return !this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2 ? null : new ut$1([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);
  }
  getHorizon() {
    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
  }
  setMaxBounds(e) {
    e ? (this.lngRange = [e.getWest(), e.getEast()], this.latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-Rc$1, Rc$1]);
  }
  calculatePosMatrix(e, t = false) {
    let i = e.key, n4 = t ? this._alignedPosMatrixCache : this._posMatrixCache;
    if (n4[i]) return n4[i];
    let o4 = e.canonical, a4 = this.worldSize / this.zoomScale(o4.z), s5 = o4.x + Math.pow(2, o4.z) * e.wrap, u5 = q$2.identity(new Float64Array(16));
    return q$2.translate(u5, u5, [s5 * a4, o4.y * a4, 0]), q$2.scale(u5, u5, [a4 / 8192, a4 / 8192, 1]), q$2.multiply(u5, t ? this.alignedProjMatrix : this.projMatrix, u5), n4[i] = new Float32Array(u5), n4[i];
  }
  customLayerMatrix() {
    return this.mercatorMatrix.slice();
  }
  getConstrained(e, t) {
    t = Ae$2(+t, this.minZoom, this.maxZoom);
    let i = { center: new ie$1(e.lng, e.lat), zoom: t }, n4 = this.lngRange;
    if (!this._renderWorldCopies && n4 === null) {
      let _ = 179.9999999999;
      n4 = [-_, _];
    }
    let o4 = this.tileSize * this.zoomScale(i.zoom), a4 = 0, s5 = o4, u5 = 0, c = o4, p4 = 0, h = 0, { x: f, y: m5 } = this.size;
    if (this.latRange) {
      let _ = this.latRange;
      a4 = Br$1(_[1]) * o4, s5 = Br$1(_[0]) * o4, s5 - a4 < m5 && (p4 = m5 / (s5 - a4));
    }
    n4 && (u5 = er$1(Rr(n4[0]) * o4, 0, o4), c = er$1(Rr(n4[1]) * o4, 0, o4), c < u5 && (c += o4), c - u5 < f && (h = f / (c - u5)));
    let { x: y4, y: g } = this.project.call({ worldSize: o4 }, e), x2, b, w3 = Math.max(h || 0, p4 || 0);
    if (w3) {
      let _ = new We$1.default(h ? (c + u5) / 2 : y4, p4 ? (s5 + a4) / 2 : g);
      return i.center = this.unproject.call({ worldSize: o4 }, _).wrap(), i.zoom += this.scaleZoom(w3), i;
    }
    if (this.latRange) {
      let _ = m5 / 2;
      g - _ < a4 && (b = a4 + _), g + _ > s5 && (b = s5 - _);
    }
    if (n4) {
      let _ = (u5 + c) / 2, S4 = y4;
      this._renderWorldCopies && (S4 = er$1(y4, _ - o4 / 2, _ + o4 / 2));
      let P4 = f / 2;
      S4 - P4 < u5 && (x2 = u5 + P4), S4 + P4 > c && (x2 = c - P4);
    }
    if (x2 !== void 0 || b !== void 0) {
      let _ = new We$1.default(x2 != null ? x2 : y4, b != null ? b : g);
      i.center = this.unproject.call({ worldSize: o4 }, _).wrap();
    }
    return i;
  }
  _constrain() {
    if (!this.center || !this.width || !this.height || this._constraining) return;
    this._constraining = true;
    let e = this._unmodified, { center: t, zoom: i } = this.getConstrained(this.center, this.zoom);
    this.center = t, this.zoom = i, this._unmodified = e, this._constraining = false;
  }
  _calcMatrices() {
    if (!this.height) return;
    let e = this._fov / 2, t = this.centerOffset, i = this.point.x, n4 = this.point.y;
    this.cameraToCenterDistance = 0.5 / Math.tan(e) * this.height, this._pixelPerMeter = bu$1(1, this.center.lat) * this.worldSize;
    let o4 = q$2.identity(new Float64Array(16));
    q$2.scale(o4, o4, [this.width / 2, -this.height / 2, 1]), q$2.translate(o4, o4, [1, -1, 0]), this.labelPlaneMatrix = o4, o4 = q$2.identity(new Float64Array(16)), q$2.scale(o4, o4, [1, -1, 1]), q$2.translate(o4, o4, [-1, -1, 0]), q$2.scale(o4, o4, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = o4;
    let a4 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), s5 = Math.min(this.elevation, this.minElevationForCurrentTile), u5 = a4 - s5 * this._pixelPerMeter / Math.cos(this._pitch), c = s5 < 0 ? u5 : a4, p4 = Math.PI / 2 + this._pitch, h = this._fov * (0.5 + t.y / this.height), f = Math.sin(h) * c / Math.sin(Ae$2(Math.PI - p4 - h, 0.01, Math.PI - 0.01)), m5 = this.getHorizon(), g = 2 * Math.atan(m5 / this.cameraToCenterDistance) * (0.5 + t.y / (m5 * 2)), x2 = Math.sin(g) * c / Math.sin(Ae$2(Math.PI - p4 - g, 0.01, Math.PI - 0.01)), b = Math.min(f, x2), w3 = (Math.cos(Math.PI / 2 - this._pitch) * b + c) * 1.01, _ = this.height / 50;
    o4 = new Float64Array(16), q$2.perspective(o4, this._fov, this.width / this.height, _, w3), o4[8] = -t.x * 2 / this.width, o4[9] = t.y * 2 / this.height, q$2.scale(o4, o4, [1, -1, 1]), q$2.translate(o4, o4, [0, 0, -this.cameraToCenterDistance]), q$2.rotateX(o4, o4, this._pitch), q$2.rotateZ(o4, o4, this.angle), q$2.translate(o4, o4, [-i, -n4, 0]), this.mercatorMatrix = q$2.scale([], o4, [this.worldSize, this.worldSize, this.worldSize]), q$2.scale(o4, o4, [1, 1, this._pixelPerMeter]), this.pixelMatrix = q$2.multiply(new Float64Array(16), this.labelPlaneMatrix, o4), q$2.translate(o4, o4, [0, 0, -this.elevation]), this.projMatrix = o4, this.invProjMatrix = q$2.invert([], o4), this.pixelMatrix3D = q$2.multiply(new Float64Array(16), this.labelPlaneMatrix, o4);
    let S4 = this.width % 2 / 2, P4 = this.height % 2 / 2, T3 = Math.cos(this.angle), L3 = Math.sin(this.angle), C3 = i - Math.round(i) + T3 * S4 + L3 * P4, E4 = n4 - Math.round(n4) + T3 * P4 + L3 * S4, I3 = new Float64Array(o4);
    if (q$2.translate(I3, I3, [C3 > 0.5 ? C3 - 1 : C3, E4 > 0.5 ? E4 - 1 : E4, 0]), this.alignedProjMatrix = I3, o4 = q$2.invert(new Float64Array(16), this.pixelMatrix), !o4) throw new Error("failed to invert matrix");
    this.pixelMatrixInverse = o4, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
  }
  maxPitchScaleFactor() {
    if (!this.pixelMatrixInverse) return 1;
    let e = this.pointCoordinate(new We$1.default(0, 0)), t = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
    return qe$1.transformMat4(t, t, this.pixelMatrix)[3] / this.cameraToCenterDistance;
  }
  getCameraPoint() {
    let e = this._pitch, t = Math.tan(e) * (this.cameraToCenterDistance || 1);
    return this.centerPoint.add(new We$1.default(0, t));
  }
  getCameraQueryGeometry(e) {
    let t = this.getCameraPoint();
    if (e.length === 1) return [e[0], t];
    {
      let i = t.x, n4 = t.y, o4 = t.x, a4 = t.y;
      for (let s5 of e) i = Math.min(i, s5.x), n4 = Math.min(n4, s5.y), o4 = Math.max(o4, s5.x), a4 = Math.max(a4, s5.y);
      return [new We$1.default(i, n4), new We$1.default(o4, n4), new We$1.default(o4, a4), new We$1.default(i, a4), new We$1.default(i, n4)];
    }
  }
  lngLatToCameraDepth(e, t) {
    let i = this.locationCoordinate(e), n4 = [i.x * this.worldSize, i.y * this.worldSize, t, 1];
    return qe$1.transformMat4(n4, n4, this.projMatrix), n4[2] / n4[3];
  }
};
H$3(Oc$1, "Transform");
var Bc$1 = Oc$1;
a();
a();
function Vc$1(r5, e) {
  let t = false, i = null, n4 = null, o4, a4 = H$3(() => {
    i = null, t && (r5.apply(n4, o4), i = setTimeout(a4, e), t = false);
  }, "later");
  return (...s5) => (t = true, n4 = this, o4 = s5, i || a4(), i);
}
H$3(Vc$1, "throttle");
var Tg = class Tg2 {
  constructor(e) {
    this._getCurrentHash = H$3(() => {
      let e4 = window.location.hash.replace("#", "");
      if (this._hashName) {
        let t;
        return e4.split("&").map((i) => i.split("=")).forEach((i) => {
          i[0] === this._hashName && (t = i);
        }), (t && t[1] || "").split("/");
      }
      return e4.split("/");
    }, "_getCurrentHash");
    this._onHashChange = H$3(() => {
      let e4 = this._getCurrentHash();
      if (e4.length >= 3 && !e4.some((t) => isNaN(t))) {
        let t = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e4[3] || 0) : this._map.getBearing();
        return this._map.jumpTo({ center: [+e4[2], +e4[1]], zoom: +e4[0], bearing: t, pitch: +(e4[4] || 0) }), true;
      }
      return false;
    }, "_onHashChange");
    this._updateHashUnthrottled = H$3(() => {
      let e4 = window.location.href.replace(/(#.+)?$/, this.getHashString());
      try {
        window.history.replaceState(window.history.state, null, e4);
      } catch (t) {
      }
    }, "_updateHashUnthrottled");
    this._updateHash = Vc$1(this._updateHashUnthrottled, 30 * 1e3 / 100);
    this._hashName = e && encodeURIComponent(e);
  }
  addTo(e) {
    return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
  }
  remove() {
    return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
  }
  getHashString(e) {
    let t = this._map.getCenter(), i = Math.round(this._map.getZoom() * 100) / 100, n4 = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o4 = Math.pow(10, n4), a4 = Math.round(t.lng * o4) / o4, s5 = Math.round(t.lat * o4) / o4, u5 = this._map.getBearing(), c = this._map.getPitch(), p4 = "";
    if (e ? p4 += "/".concat(a4, "/").concat(s5, "/").concat(i) : p4 += "".concat(i, "/").concat(s5, "/").concat(a4), (u5 || c) && (p4 += "/".concat(Math.round(u5 * 10) / 10)), c && (p4 += "/".concat(Math.round(c))), this._hashName) {
      let h = this._hashName, f = false, m5 = window.location.hash.slice(1).split("&").map((y4) => {
        let g = y4.split("=")[0];
        return g === h ? (f = true, "".concat(g, "=").concat(p4)) : y4;
      }).filter((y4) => y4);
      return f || m5.push("".concat(h, "=").concat(p4)), "#".concat(m5.join("&"));
    }
    return "#".concat(p4);
  }
};
H$3(Tg, "Hash");
var ka = Tg;
a();
a();
var XS$1 = N$2(ge(), 1);
var qc$1 = { linearity: 0.3, easing: kn(0, 0, 0.3, 1) }, JL = V$1({ deceleration: 2500, maxSpeed: 1400 }, qc$1), YL$1 = V$1({ deceleration: 20, maxSpeed: 1400 }, qc$1), QL = V$1({ deceleration: 1e3, maxSpeed: 360 }, qc$1), eD$1 = V$1({ deceleration: 1e3, maxSpeed: 90 }, qc$1), Mg = class Mg2 {
  constructor(e) {
    this._map = e, this.clear();
  }
  clear() {
    this._inertiaBuffer = [];
  }
  record(e) {
    this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: Y$1.now(), settings: e });
  }
  _drainInertiaBuffer() {
    let e = this._inertiaBuffer, t = Y$1.now(), i = 160;
    for (; e.length > 0 && t - e[0].time > i; ) e.shift();
  }
  _onMoveEnd(e) {
    if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
    let t = { zoom: 0, bearing: 0, pitch: 0, pan: new XS$1.default(0, 0), pinchAround: void 0, around: void 0 };
    for (let { settings: a4 } of this._inertiaBuffer) t.zoom += a4.zoomDelta || 0, t.bearing += a4.bearingDelta || 0, t.pitch += a4.pitchDelta || 0, a4.panDelta && t.pan._add(a4.panDelta), a4.around && (t.around = a4.around), a4.pinchAround && (t.pinchAround = a4.pinchAround);
    let n4 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o4 = {};
    if (t.pan.mag()) {
      let a4 = Nc$1(t.pan.mag(), n4, V$1({}, JL, e || {}));
      o4.offset = t.pan.mult(a4.amount / t.pan.mag()), o4.center = this._map.transform.center, Uc$1(o4, a4);
    }
    if (t.zoom) {
      let a4 = Nc$1(t.zoom, n4, YL$1);
      o4.zoom = this._map.transform.zoom + a4.amount, Uc$1(o4, a4);
    }
    if (t.bearing) {
      let a4 = Nc$1(t.bearing, n4, QL);
      o4.bearing = this._map.transform.bearing + Ae$2(a4.amount, -179, 179), Uc$1(o4, a4);
    }
    if (t.pitch) {
      let a4 = Nc$1(t.pitch, n4, eD$1);
      o4.pitch = this._map.transform.pitch + a4.amount, Uc$1(o4, a4);
    }
    if (o4.zoom || o4.bearing) {
      let a4 = t.pinchAround === void 0 ? t.around : t.pinchAround;
      o4.around = a4 ? this._map.unproject(a4) : this._map.getCenter();
    }
    return this.clear(), V$1(o4, { noMoveStart: true });
  }
};
H$3(Mg, "HandlerInertia");
var Gc$1 = Mg;
function Uc$1(r5, e) {
  (!r5.duration || r5.duration < e.duration) && (r5.duration = e.duration, r5.easing = e.easing);
}
H$3(Uc$1, "extendDuration");
function Nc$1(r5, e, t) {
  let { maxSpeed: i, linearity: n4, deceleration: o4 } = t, a4 = Ae$2(r5 * n4 / (e / 1e3), -i, i), s5 = Math.abs(a4) / (o4 * n4);
  return { easing: t.easing, duration: s5 * 1e3, amount: a4 * (s5 / 2) };
}
H$3(Nc$1, "calculateEasing");
a();
a();
var KS$1 = N$2(ge(), 1);
var Ag$1 = class Ag extends F {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t, i, n4 = {}) {
    let o4 = D$1.mousePos(t.getCanvas(), i), a4 = t.unproject(o4);
    super(e, V$1({ point: o4, lngLat: a4, originalEvent: i }, n4)), this._defaultPrevented = false, this.target = t;
  }
};
H$3(Ag$1, "MapMouseEvent");
var nt$2 = Ag$1, Ig = class Ig2 extends F {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t, i) {
    let n4 = e === "touchend" ? i.changedTouches : i.touches, o4 = D$1.touchPos(t.getCanvasContainer(), n4), a4 = o4.map((c) => t.unproject(c)), s5 = o4.reduce((c, p4, h, f) => c.add(p4.div(f.length)), new KS$1.default(0, 0)), u5 = t.unproject(s5);
    super(e, { points: o4, point: s5, lngLats: a4, lngLat: u5, originalEvent: i }), this._defaultPrevented = false;
  }
};
H$3(Ig, "MapTouchEvent");
var Ur = Ig, Cg = class Cg2 extends F {
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(e, t, i) {
    super(e, { originalEvent: i }), this._defaultPrevented = false;
  }
};
H$3(Cg, "MapWheelEvent");
var La = Cg;
var Eg$1 = class Eg {
  constructor(e, t) {
    this._map = e, this._clickTolerance = t.clickTolerance;
  }
  reset() {
    delete this._mousedownPos;
  }
  wheel(e) {
    return this._firePreventable(new La(e.type, this._map, e));
  }
  mousedown(e, t) {
    return this._mousedownPos = t, this._firePreventable(new nt$2(e.type, this._map, e));
  }
  mouseup(e) {
    this._map.fire(new nt$2(e.type, this._map, e));
  }
  click(e, t) {
    this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || this._map.fire(new nt$2(e.type, this._map, e));
  }
  dblclick(e) {
    return this._firePreventable(new nt$2(e.type, this._map, e));
  }
  mouseover(e) {
    this._map.fire(new nt$2(e.type, this._map, e));
  }
  mouseout(e) {
    this._map.fire(new nt$2(e.type, this._map, e));
  }
  touchstart(e) {
    return this._firePreventable(new Ur(e.type, this._map, e));
  }
  touchmove(e) {
    this._map.fire(new Ur(e.type, this._map, e));
  }
  touchend(e) {
    this._map.fire(new Ur(e.type, this._map, e));
  }
  touchcancel(e) {
    this._map.fire(new Ur(e.type, this._map, e));
  }
  _firePreventable(e) {
    if (this._map.fire(e), e.defaultPrevented) return {};
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
H$3(Eg$1, "MapEventHandler");
var jc$1 = Eg$1, kg$1 = class kg {
  constructor(e) {
    this._map = e;
  }
  reset() {
    this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
  }
  mousemove(e) {
    this._map.fire(new nt$2(e.type, this._map, e));
  }
  mousedown() {
    this._delayContextMenu = true, this._ignoreContextMenu = false;
  }
  mouseup() {
    this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new nt$2("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
  }
  contextmenu(e) {
    this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new nt$2(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
H$3(kg$1, "BlockableMapEventHandler");
var Zc2 = kg$1;
a();
a();
var JS$1 = N$2(ge(), 1);
var Lg$1 = class Lg {
  constructor(e) {
    this._map = e;
  }
  get transform() {
    return this._map._requestedCameraState || this._map.transform;
  }
  get center() {
    return { lng: this.transform.center.lng, lat: this.transform.center.lat };
  }
  get zoom() {
    return this.transform.zoom;
  }
  get pitch() {
    return this.transform.pitch;
  }
  get bearing() {
    return this.transform.bearing;
  }
  unproject(e) {
    return this.transform.pointLocation(JS$1.default.convert(e), this._map.terrain);
  }
};
H$3(Lg$1, "TransformProvider");
var Dt$1 = Lg$1;
var Dg$1 = class Dg {
  constructor(e, t) {
    this._map = e, this._tr = new Dt$1(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
  enable() {
    console.warn("boxZoom will not work. Use SDK interaction events instead.");
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  mousedown(e, t) {
    this.isEnabled() && e.shiftKey && e.button === 0 && (D$1.disableDrag(), this._startPos = this._lastPos = t, this._active = true);
  }
  mousemoveWindow(e, t) {
    if (!this._active) return;
    let i = t;
    if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return;
    let n4 = this._startPos;
    this._lastPos = i, this._box || (this._box = D$1.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
    let o4 = Math.min(n4.x, i.x), a4 = Math.max(n4.x, i.x), s5 = Math.min(n4.y, i.y), u5 = Math.max(n4.y, i.y);
    D$1.setTransform(this._box, "translate(".concat(o4, "px,").concat(s5, "px)")), this._box.style.width = "".concat(a4 - o4, "px"), this._box.style.height = "".concat(u5 - s5, "px");
  }
  mouseupWindow(e, t) {
    if (!this._active || e.button !== 0) return;
    let i = this._startPos, n4 = t;
    if (this.reset(), D$1.suppressClick(), i.x === n4.x && i.y === n4.y) this._fireEvent("boxzoomcancel", e);
    else return this._map.fire(new F("boxzoomend", { originalEvent: e })), { cameraAnimation: H$3((o4) => o4.fitScreenCoordinates(i, n4, this._tr.bearing, { linear: true }), "cameraAnimation") };
  }
  keydown(e) {
    this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
  }
  reset() {
    this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (D$1.remove(this._box), this._box = null), D$1.enableDrag(), delete this._startPos, delete this._lastPos;
  }
  _fireEvent(e, t) {
    return this._map.fire(new F(e, { originalEvent: t }));
  }
};
H$3(Dg$1, "BoxZoomHandler");
var Da = Dg$1;
a();
a();
var YS$1 = N$2(ge(), 1);
a();
function za(r5, e) {
  if (r5.length !== e.length) throw new Error("The number of touches and points are not equal - touches ".concat(r5.length, ", points ").concat(e.length));
  let t = {};
  for (let i = 0; i < r5.length; i++) t[r5[i].identifier] = e[i];
  return t;
}
H$3(za, "indexTouches");
function tD$1(r5) {
  let e = new YS$1.default(0, 0);
  for (let t of r5) e._add(t);
  return e.div(r5.length);
}
H$3(tD$1, "getCentroid");
var Fg$1 = 500, rD$1 = 500, Hc$1 = 30, Rg$1 = class Rg {
  constructor(e) {
    this.reset(), this.numTouches = e.numTouches;
  }
  reset() {
    delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
  }
  touchstart(e, t, i) {
    (this.centroid || i.length > this.numTouches) && (this.aborted = true), !this.aborted && (this.startTime === void 0 && (this.startTime = e.timeStamp), i.length === this.numTouches && (this.centroid = tD$1(t), this.touches = za(i, t)));
  }
  touchmove(e, t, i) {
    if (this.aborted || !this.centroid) return;
    let n4 = za(i, t);
    for (let o4 in this.touches) {
      let a4 = this.touches[o4], s5 = n4[o4];
      (!s5 || s5.dist(a4) > Hc$1) && (this.aborted = true);
    }
  }
  touchend(e, t, i) {
    if ((!this.centroid || e.timeStamp - this.startTime > rD$1) && (this.aborted = true), i.length === 0) {
      let n4 = !this.aborted && this.centroid;
      if (this.reset(), n4) return n4;
    }
  }
};
H$3(Rg$1, "SingleTapRecognizer");
var zg$1 = Rg$1, Bg$1 = class Bg {
  constructor(e) {
    this.singleTap = new zg$1(e), this.numTaps = e.numTaps, this.reset();
  }
  reset() {
    this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
  }
  touchstart(e, t, i) {
    this.singleTap.touchstart(e, t, i);
  }
  touchmove(e, t, i) {
    this.singleTap.touchmove(e, t, i);
  }
  touchend(e, t, i) {
    let n4 = this.singleTap.touchend(e, t, i);
    if (n4) {
      let o4 = e.timeStamp - this.lastTime < Fg$1, a4 = !this.lastTap || this.lastTap.dist(n4) < Hc$1;
      if ((!o4 || !a4) && this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = n4, this.count === this.numTaps) return this.reset(), n4;
    }
  }
};
H$3(Bg$1, "TapRecognizer");
var Mi$2 = Bg$1;
var Og$1 = class Og {
  constructor(e) {
    this._tr = new Dt$1(e), this._zoomIn = new Mi$2({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Mi$2({ numTouches: 2, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
  }
  touchstart(e, t, i) {
    this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);
  }
  touchmove(e, t, i) {
    this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);
  }
  touchend(e, t, i) {
    let n4 = this._zoomIn.touchend(e, t, i), o4 = this._zoomOut.touchend(e, t, i), a4 = this._tr;
    if (n4) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: H$3((s5) => s5.easeTo({ duration: 300, zoom: a4.zoom + 1, around: a4.unproject(n4) }, { originalEvent: e }), "cameraAnimation") };
    if (o4) return this._active = true, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: H$3((s5) => s5.easeTo({ duration: 300, zoom: a4.zoom - 1, around: a4.unproject(o4) }, { originalEvent: e }), "cameraAnimation") };
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
H$3(Og$1, "TapZoomHandler");
var $c$1 = Og$1;
a();
a();
var Vg$1 = class Vg {
  constructor(e) {
    this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
  }
  reset(e) {
    this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
  }
  _move(...e) {
    let t = this._moveFunction(...e);
    if (t.bearingDelta || t.pitchDelta || t.around || t.panDelta) return this._active = true, t;
  }
  dragStart(e, t) {
    !this.isEnabled() || this._lastPoint || this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = t.length ? t[0] : t, this._activateOnStart && this._lastPoint && (this._active = true));
  }
  dragMove(e, t) {
    if (!this.isEnabled()) return;
    let i = this._lastPoint;
    if (!i) return;
    if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) {
      this.reset(e);
      return;
    }
    let n4 = t.length ? t[0] : t;
    if (!(!this._moved && n4.dist(i) < this._clickTolerance)) return this._moved = true, this._lastPoint = n4, this._move(i, n4);
  }
  dragEnd(e) {
    !this.isEnabled() || !this._lastPoint || this._moveStateManager.isValidEndEvent(e) && (this._moved && D$1.suppressClick(), this.reset(e));
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  getClickTolerance() {
    return this._clickTolerance;
  }
};
H$3(Vg$1, "DragHandler");
var hr = Vg$1;
a();
var iD$1 = 0, nD$1 = 2, oD$1 = { [iD$1]: 1, [nD$1]: 2 };
function aD$1(r5, e) {
  let t = oD$1[e];
  return r5.buttons === void 0 || (r5.buttons & t) !== t;
}
H$3(aD$1, "buttonNoLongerPressed");
var Ug$1 = class Ug {
  constructor(e) {
    this._correctEvent = e.checkCorrectEvent;
  }
  startMove(e) {
    let t = D$1.mouseButton(e);
    this._eventButton = t;
  }
  endMove(e) {
    delete this._eventButton;
  }
  isValidStartEvent(e) {
    return this._correctEvent(e);
  }
  isValidMoveEvent(e) {
    return !aD$1(e, this._eventButton);
  }
  isValidEndEvent(e) {
    return D$1.mouseButton(e) === this._eventButton;
  }
};
H$3(Ug$1, "MouseMoveStateManager");
var An$2 = Ug$1, Ng$1 = class Ng {
  constructor() {
    this._firstTouch = void 0;
  }
  _isOneFingerTouch(e) {
    return e.targetTouches.length === 1;
  }
  _isSameTouchEvent(e) {
    return e.targetTouches[0].identifier === this._firstTouch;
  }
  startMove(e) {
    let t = e.targetTouches[0].identifier;
    this._firstTouch = t;
  }
  endMove(e) {
    delete this._firstTouch;
  }
  isValidStartEvent(e) {
    return this._isOneFingerTouch(e);
  }
  isValidMoveEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
  isValidEndEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
};
H$3(Ng$1, "OneFingerTouchMoveStateManager");
var Fa = Ng$1;
var Gg$1 = 0, QS$1 = 2, qg$1 = H$3((r5) => {
  r5.mousedown = r5.dragStart, r5.mousemoveWindow = r5.dragMove, r5.mouseup = r5.dragEnd, r5.contextmenu = function(e) {
    e.preventDefault();
  };
}, "assignEvents"), e2$1 = H$3(({ enable: r5, clickTolerance: e }) => {
  let t = new An$2({ checkCorrectEvent: H$3((i) => D$1.mouseButton(i) === Gg$1 && !i.ctrlKey, "checkCorrectEvent") });
  return new hr({ clickTolerance: e, move: H$3((i, n4) => ({ around: n4, panDelta: n4.sub(i) }), "move"), activateOnStart: true, moveStateManager: t, enable: r5, assignEvents: qg$1 });
}, "generateMousePanHandler"), Wc$1 = H$3(({ enable: r5, clickTolerance: e, bearingDegreesPerPixelMoved: t = 0.8 }) => {
  let i = new An$2({ checkCorrectEvent: H$3((n4) => D$1.mouseButton(n4) === Gg$1 && n4.ctrlKey || D$1.mouseButton(n4) === QS$1, "checkCorrectEvent") });
  return new hr({ clickTolerance: e, move: H$3((n4, o4) => ({ bearingDelta: (o4.x - n4.x) * t }), "move"), moveStateManager: i, enable: r5, assignEvents: qg$1 });
}, "generateMouseRotationHandler"), Xc$1 = H$3(({ enable: r5, clickTolerance: e, pitchDegreesPerPixelMoved: t = -0.5 }) => {
  let i = new An$2({ checkCorrectEvent: H$3((n4) => D$1.mouseButton(n4) === Gg$1 && n4.ctrlKey || D$1.mouseButton(n4) === QS$1, "checkCorrectEvent") });
  return new hr({ clickTolerance: e, move: H$3((n4, o4) => ({ pitchDelta: (o4.y - n4.y) * t }), "move"), moveStateManager: i, enable: r5, assignEvents: qg$1 });
}, "generateMousePitchHandler");
a();
var Kc$1 = N$2(ge(), 1);
var jg$1 = class jg {
  constructor(e, t) {
    this._clickTolerance = e.clickTolerance || 1, this._map = t, this.reset();
  }
  reset() {
    this._active = false, this._touches = {}, this._sum = new Kc$1.default(0, 0);
  }
  minTouchs() {
    return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
  }
  touchstart(e, t, i) {
    return this._calculateTransform(e, t, i);
  }
  touchmove(e, t, i) {
    if (!(!this._active || i.length < this.minTouchs())) return e.preventDefault(), this._calculateTransform(e, t, i);
  }
  touchend(e, t, i) {
    this._calculateTransform(e, t, i), this._active && i.length < this.minTouchs() && this.reset();
  }
  touchcancel() {
    this.reset();
  }
  _calculateTransform(e, t, i) {
    i.length > 0 && (this._active = true);
    let n4 = za(i, t), o4 = new Kc$1.default(0, 0), a4 = new Kc$1.default(0, 0), s5 = 0;
    for (let p4 in n4) {
      let h = n4[p4], f = this._touches[p4];
      f && (o4._add(h), a4._add(h.sub(f)), s5++, n4[p4] = h);
    }
    if (this._touches = n4, s5 < this.minTouchs() || !a4.mag()) return;
    let u5 = a4.div(s5);
    return this._sum._add(u5), this._sum.mag() < this._clickTolerance ? void 0 : { around: o4.div(s5), panDelta: u5 };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
H$3(jg$1, "TouchPanHandler");
var Jc$1 = jg$1;
a();
var Hg$1 = class Hg {
  constructor() {
    this.reset();
  }
  reset() {
    this._active = false, delete this._firstTwoTouches;
  }
  touchstart(e, t, i) {
    this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));
  }
  touchmove(e, t, i) {
    if (!this._firstTwoTouches) return;
    e.preventDefault();
    let [n4, o4] = this._firstTwoTouches, a4 = Yc$1(i, t, n4), s5 = Yc$1(i, t, o4);
    if (!a4 || !s5) return;
    let u5 = this._aroundCenter ? null : a4.add(s5).div(2);
    return this._move([a4, s5], u5, e);
  }
  touchend(e, t, i) {
    if (!this._firstTwoTouches) return;
    let [n4, o4] = this._firstTwoTouches, a4 = Yc$1(i, t, n4), s5 = Yc$1(i, t, o4);
    a4 && s5 || (this._active && D$1.suppressClick(), this.reset());
  }
  touchcancel() {
    this.reset();
  }
  enable(e) {
    this._enabled = true, this._aroundCenter = !!e && e.around === "center";
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active;
  }
};
H$3(Hg$1, "TwoFingersTouchHandler");
var Ra = Hg$1;
function Yc$1(r5, e, t) {
  for (let i = 0; i < r5.length; i++) if (r5[i].identifier === t) return e[i];
}
H$3(Yc$1, "getTouchById");
var sD$1 = 0.1;
function t2$1(r5, e) {
  return Math.log(r5 / e) / Math.LN2;
}
H$3(t2$1, "getZoomDelta");
var $g$1 = class $g extends Ra {
  reset() {
    super.reset(), delete this._distance, delete this._startDistance;
  }
  _start(e) {
    this._startDistance = this._distance = e[0].dist(e[1]);
  }
  _move(e, t) {
    let i = this._distance;
    if (this._distance = e[0].dist(e[1]), !(!this._active && Math.abs(t2$1(this._distance, this._startDistance)) < sD$1)) return this._active = true, { zoomDelta: t2$1(this._distance, i), pinchAround: t };
  }
};
H$3($g$1, "TwoFingersTouchZoomHandler");
var Ba = $g$1, lD$1 = 25;
function r2$1(r5, e) {
  return r5.angleWith(e) * 180 / Math.PI;
}
H$3(r2$1, "getBearingDelta");
var Wg$1 = class Wg extends Ra {
  reset() {
    super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
  }
  _start(e) {
    this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
  }
  _move(e, t, i) {
    let n4 = this._vector;
    if (this._vector = e[0].sub(e[1]), !(!this._active && this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: r2$1(this._vector, n4), pinchAround: t };
  }
  _isBelowThreshold(e) {
    this._minDiameter = Math.min(this._minDiameter, e.mag());
    let t = Math.PI * this._minDiameter, i = lD$1 / t * 360, n4 = r2$1(e, this._startVector);
    return Math.abs(n4) < i;
  }
};
H$3(Wg$1, "TwoFingersTouchRotateHandler");
var Oa = Wg$1;
function Zg$1(r5) {
  return Math.abs(r5.y) > Math.abs(r5.x);
}
H$3(Zg$1, "isVertical");
var uD$1 = 100, Xg$1 = class Xg extends Ra {
  constructor(t) {
    super();
    this._currentTouchCount = 0;
    this._map = t;
  }
  reset() {
    super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
  }
  touchstart(t, i, n4) {
    super.touchstart(t, i, n4), this._currentTouchCount = n4.length;
  }
  _start(t) {
    this._lastPoints = t, Zg$1(t[0].sub(t[1])) && (this._valid = false);
  }
  _move(t, i, n4) {
    if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
    let o4 = t[0].sub(this._lastPoints[0]), a4 = t[1].sub(this._lastPoints[1]);
    return this._valid = this.gestureBeginsVertically(o4, a4, n4.timeStamp), this._valid ? (this._lastPoints = t, this._active = true, { pitchDelta: (o4.y + a4.y) / 2 * -0.5 }) : void 0;
  }
  gestureBeginsVertically(t, i, n4) {
    if (this._valid !== void 0) return this._valid;
    let o4 = 2, a4 = t.mag() >= o4, s5 = i.mag() >= o4;
    if (!a4 && !s5) return;
    if (!a4 || !s5) return this._firstMove === void 0 && (this._firstMove = n4), n4 - this._firstMove < uD$1 ? void 0 : false;
    let u5 = t.y > 0 == i.y > 0;
    return Zg$1(t) && Zg$1(i) && u5;
  }
};
H$3(Xg$1, "TwoFingersTouchPitchHandler");
var Va = Xg$1;
a();
var cD$1 = { panStep: 100, bearingStep: 15, pitchStep: 10 }, Kg$1 = class Kg {
  constructor(e) {
    this._tr = new Dt$1(e);
    let t = cD$1;
    this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = false;
  }
  reset() {
    this._active = false;
  }
  keydown(e) {
    if (e.altKey || e.ctrlKey || e.metaKey) return;
    let t = 0, i = 0, n4 = 0, o4 = 0, a4 = 0;
    switch (e.keyCode) {
      case 61:
      case 107:
      case 171:
      case 187:
        t = 1;
        break;
      case 189:
      case 109:
      case 173:
        t = -1;
        break;
      case 37:
        e.shiftKey ? i = -1 : (e.preventDefault(), o4 = -1);
        break;
      case 39:
        e.shiftKey ? i = 1 : (e.preventDefault(), o4 = 1);
        break;
      case 38:
        e.shiftKey ? n4 = 1 : (e.preventDefault(), a4 = -1);
        break;
      case 40:
        e.shiftKey ? n4 = -1 : (e.preventDefault(), a4 = 1);
        break;
      default:
        return;
    }
    return this._rotationDisabled && (i = 0, n4 = 0), { cameraAnimation: H$3((s5) => {
      let u5 = this._tr;
      s5.easeTo({ duration: 300, easeId: "keyboardHandler", easing: pD$1, zoom: t ? Math.round(u5.zoom) + t * (e.shiftKey ? 2 : 1) : u5.zoom, bearing: u5.bearing + i * this._bearingStep, pitch: u5.pitch + n4 * this._pitchStep, offset: [-o4 * this._panStep, -a4 * this._panStep], center: u5.center }, { originalEvent: e });
    }, "cameraAnimation") };
  }
  enable() {
    console.warn("maplibre keyboard events are not supported, use SDK keyboard events instead.");
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  disableRotation() {
    this._rotationDisabled = true;
  }
  enableRotation() {
    this._rotationDisabled = false;
  }
};
H$3(Kg$1, "KeyboardHandler");
var Ua = Kg$1;
function pD$1(r5) {
  return r5 * (2 - r5);
}
H$3(pD$1, "easeOut");
a();
var i2$1 = 4.000244140625, hD$1 = 1 / 100, fD$1 = 1 / 450, mD$1 = 2, Jg$1 = class Jg {
  constructor(e, t) {
    this._onTimeout = H$3((e4) => {
      this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e4);
    }, "_onTimeout");
    this._map = e, this._tr = new Dt$1(e), this._triggerRenderFrame = t, this._delta = 0, this._defaultZoomRate = hD$1, this._wheelZoomRate = fD$1;
  }
  setZoomRate(e) {
    this._defaultZoomRate = e;
  }
  setWheelZoomRate(e) {
    this._wheelZoomRate = e;
  }
  isEnabled() {
    return !!this._enabled;
  }
  isActive() {
    return !!this._active || this._finishTimeout !== void 0;
  }
  isZooming() {
    return !!this._zooming;
  }
  enable(e) {
    console.log("Enable maplibre scrollZoom events will not work. Use Mappedin SDK interactions events instead.");
  }
  disable() {
    this.isEnabled() && (this._enabled = false);
  }
  wheel(e) {
    if (!this.isEnabled() || this._map.cooperativeGestures.isEnabled() && !e[this._map.cooperativeGestures._bypassKey]) return;
    let t = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? e.deltaY * 40 : e.deltaY, i = Y$1.now(), n4 = i - (this._lastWheelEventTime || 0);
    this._lastWheelEventTime = i, t !== 0 && t % i2$1 === 0 ? this._type = "wheel" : t !== 0 && Math.abs(t) < 4 ? this._type = "trackpad" : n4 > 400 ? (this._type = null, this._lastValue = t, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(n4 * t) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t += this._lastValue)), e.shiftKey && t && (t = t / 4), this._type && (this._lastWheelEvent = e, this._delta -= t, this._active || this._start(e)), e.preventDefault();
  }
  _start(e) {
    if (!this._delta) return;
    this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
    let t = D$1.mousePos(this._map.getCanvas(), e), i = this._tr;
    t.y > i.transform.height / 2 - i.transform.getHorizon() ? this._around = ie$1.convert(this._aroundCenter ? i.center : i.unproject(t)) : this._around = ie$1.convert(i.center), this._aroundPoint = i.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
  }
  renderFrame() {
    if (!this._frameId || (this._frameId = null, !this.isActive())) return;
    let e = this._tr.transform;
    if (this._delta !== 0) {
      let s5 = this._type === "wheel" && Math.abs(this._delta) > i2$1 ? this._wheelZoomRate : this._defaultZoomRate, u5 = mD$1 / (1 + Math.exp(-Math.abs(this._delta * s5)));
      this._delta < 0 && u5 !== 0 && (u5 = 1 / u5);
      let c = typeof this._targetZoom == "number" ? e.zoomScale(this._targetZoom) : e.scale;
      this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(c * u5))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
    }
    let t = typeof this._targetZoom == "number" ? this._targetZoom : e.zoom, i = this._startZoom, n4 = this._easing, o4 = false, a4;
    if (this._type === "wheel" && i && n4) {
      let s5 = Math.min((Y$1.now() - this._lastWheelEventTime) / 200, 1), u5 = n4(s5);
      a4 = Pe$2.number(i, t, u5), s5 < 1 ? this._frameId || (this._frameId = true) : o4 = true;
    } else a4 = t, o4 = true;
    return this._active = true, o4 && (this._active = false, this._finishTimeout = setTimeout(() => {
      this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
    }, 200)), { noInertia: true, needsRenderFrame: !o4, zoomDelta: a4 - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
  }
  _smoothOutEasing(e) {
    let t = Ln$1;
    if (this._prevEase) {
      let i = this._prevEase, n4 = (Y$1.now() - i.start) / i.duration, o4 = i.easing(n4 + 0.01) - i.easing(n4), a4 = 0.27 / Math.sqrt(o4 * o4 + 1e-4) * 0.01, s5 = Math.sqrt(0.27 * 0.27 - a4 * a4);
      t = kn(a4, s5, 0.25, 1);
    }
    return this._prevEase = { start: Y$1.now(), duration: e, easing: t }, t;
  }
  reset() {
    this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
  }
};
H$3(Jg$1, "ScrollZoomHandler");
var Na = Jg$1;
a();
var Yg$1 = class Yg {
  constructor(e, t) {
    this._clickZoom = e, this._tapZoom = t;
  }
  enable() {
    this._clickZoom.enable(), this._tapZoom.enable();
  }
  disable() {
    this._clickZoom.disable(), this._tapZoom.disable();
  }
  isEnabled() {
    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
  }
  isActive() {
    return this._clickZoom.isActive() || this._tapZoom.isActive();
  }
};
H$3(Yg$1, "DoubleClickZoomHandler");
var Ga = Yg$1;
a();
var Qg$1 = class Qg {
  constructor(e) {
    this._tr = new Dt$1(e), this.reset();
  }
  reset() {
    this._active = false;
  }
  dblclick(e, t) {
    return e.preventDefault(), { cameraAnimation: H$3((i) => {
      i.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(t) }, { originalEvent: e });
    }, "cameraAnimation") };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
H$3(Qg$1, "ClickZoomHandler");
var Qc$1 = Qg$1;
a();
var ex$1 = class ex {
  constructor() {
    this._tap = new Mi$2({ numTouches: 1, numTaps: 1 }), this.reset();
  }
  reset() {
    this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
  }
  touchstart(e, t, i) {
    if (!this._swipePoint) if (!this._tapTime) this._tap.touchstart(e, t, i);
    else {
      let n4 = t[0], o4 = e.timeStamp - this._tapTime < Fg$1, a4 = this._tapPoint.dist(n4) < Hc$1;
      !o4 || !a4 ? this.reset() : i.length > 0 && (this._swipePoint = n4, this._swipeTouch = i[0].identifier);
    }
  }
  touchmove(e, t, i) {
    if (!this._tapTime) this._tap.touchmove(e, t, i);
    else if (this._swipePoint) {
      if (i[0].identifier !== this._swipeTouch) return;
      let n4 = t[0], o4 = n4.y - this._swipePoint.y;
      return this._swipePoint = n4, e.preventDefault(), this._active = true, { zoomDelta: o4 / 128 };
    }
  }
  touchend(e, t, i) {
    if (this._tapTime) this._swipePoint && i.length === 0 && this.reset();
    else {
      let n4 = this._tap.touchend(e, t, i);
      n4 && (this._tapTime = e.timeStamp, this._tapPoint = n4);
    }
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};
H$3(ex$1, "TapDragZoomHandler");
var ep$1 = ex$1;
a();
var tx$1 = class tx {
  constructor(e, t, i) {
    this._el = e, this._mousePan = t, this._touchPan = i;
  }
  enable(e) {
    console.log("Maplibre interaction is not supported. Use Mappedin SDK interaction instead");
  }
  disable() {
    this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
  }
  isEnabled() {
    return this._mousePan.isEnabled() && this._touchPan.isEnabled();
  }
  isActive() {
    return this._mousePan.isActive() || this._touchPan.isActive();
  }
};
H$3(tx$1, "DragPanHandler");
var qa$1 = tx$1;
a();
var rx$1 = class rx {
  constructor(e, t, i) {
    this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;
  }
  enable() {
    console.warn("dragRotate does not work. Use SDK interaction events instead.");
  }
  disable() {
    this._mouseRotate.disable(), this._mousePitch.disable();
  }
  isEnabled() {
    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
  }
  isActive() {
    return this._mouseRotate.isActive() || this._mousePitch.isActive();
  }
};
H$3(rx$1, "DragRotateHandler");
var ja = rx$1;
a();
var ix$1 = class ix {
  constructor(e, t, i, n4) {
    this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = n4, this._rotationDisabled = false, this._enabled = true;
  }
  enable(e) {
    this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
  }
  disable() {
    this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
  }
  isEnabled() {
    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
  }
  isActive() {
    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
  }
  disableRotation() {
    this._rotationDisabled = true, this._touchRotate.disable();
  }
  enableRotation() {
    this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
  }
};
H$3(ix$1, "TwoFingersTouchZoomRotateHandler");
var Za$1 = ix$1;
a();
var nx$1 = class nx {
  constructor(e, t) {
    this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey";
    this._map = e, this._options = t, this._enabled = false;
  }
  isActive() {
    return false;
  }
  reset() {
  }
  _setupUI() {
    if (this._container) return;
    let e = this._map.getCanvasContainer();
    e.classList.add("maplibregl-cooperative-gestures"), this._container = D$1.create("div", "maplibregl-cooperative-gesture-screen", e);
    let t = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
    this._bypassKey === "metaKey" && (t = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
    let i = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), n4 = document.createElement("div");
    n4.className = "maplibregl-desktop-message", n4.textContent = t, this._container.appendChild(n4);
    let o4 = document.createElement("div");
    o4.className = "maplibregl-mobile-message", o4.textContent = i, this._container.appendChild(o4), this._container.setAttribute("aria-hidden", "true");
  }
  _destoryUI() {
    this._container && (D$1.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
  }
  enable() {
    this._setupUI(), this._enabled = true;
  }
  disable() {
    this._enabled = false, this._destoryUI();
  }
  isEnabled() {
    return this._enabled;
  }
  touchmove(e) {
    this._onCooperativeGesture(e.touches.length === 1);
  }
  wheel(e) {
    this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!e[this._bypassKey]);
  }
  _onCooperativeGesture(e) {
    !this._enabled || !e || (this._container.classList.add("maplibregl-show"), setTimeout(() => {
      this._container.classList.remove("maplibregl-show");
    }, 100));
  }
};
H$3(nx$1, "CooperativeGesturesHandler");
var Ha = nx$1;
var n2$1 = N$2(ge(), 1);
var tp$1 = H$3((r5) => r5.zoom || r5.drag || r5.pitch || r5.rotate, "isMoving"), sx = class sx2 extends F {
};
H$3(sx, "RenderFrameEvent");
var ax = sx;
function ox$1(r5) {
  return r5.panDelta && r5.panDelta.mag() || r5.zoomDelta || r5.bearingDelta || r5.pitchDelta;
}
H$3(ox$1, "hasChange");
var lx = class lx2 {
  constructor(e, t) {
    this.handleWindowEvent = H$3((e4) => {
      this.handleEvent(e4, "".concat(e4.type, "Window"));
    }, "handleWindowEvent");
    this.handleEvent = H$3((e4, t5) => {
      if (e4.type === "blur") {
        this.stop(true);
        return;
      }
      this._updatingCamera = true;
      let i5 = e4.type === "renderFrame" ? void 0 : e4, n4 = { needsRenderFrame: false }, o4 = {}, a4 = {}, s5 = e4.touches, u5 = s5 ? this._getMapTouches(s5) : void 0, c = u5 ? D$1.touchPos(this._map.getCanvas(), u5) : D$1.mousePos(this._map.getCanvas(), e4);
      for (let { handlerName: f, handler: m5, allowed: y4 } of this._handlers) {
        if (!m5.isEnabled()) continue;
        let g;
        this._blockedByActive(a4, y4, f) ? m5.reset() : m5[t5 || e4.type] && (g = m5[t5 || e4.type](e4, c, u5), this.mergeHandlerResult(n4, o4, g, f, i5), g && g.needsRenderFrame && this._triggerRenderFrame()), (g || m5.isActive()) && (a4[f] = m5);
      }
      let p4 = {};
      for (let f in this._previousActiveHandlers) a4[f] || (p4[f] = i5);
      this._previousActiveHandlers = a4, (Object.keys(p4).length || ox$1(n4)) && (this._changes.push([n4, o4, p4]), this._triggerRenderFrame()), (Object.keys(a4).length || ox$1(n4)) && this._map._stop(true), this._updatingCamera = false;
      let { cameraAnimation: h } = n4;
      h && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h(this._map));
    }, "handleEvent");
    this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Gc$1(e), this._bearingSnap = t.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(t);
    let i = this._el;
    this._listeners = [[i, "touchstart", { passive: true }], [i, "touchmove", { passive: false }], [i, "touchend", void 0], [i, "touchcancel", void 0], [i, "mousedown", void 0], [i, "mousemove", void 0], [i, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [i, "mouseover", void 0], [i, "mouseout", void 0], [i, "dblclick", void 0], [i, "click", void 0], [i, "keydown", { capture: false }], [i, "keyup", void 0], [i, "wheel", { passive: false }], [i, "contextmenu", void 0], [window, "blur", void 0]];
    for (let [n4, o4, a4] of this._listeners) ;
  }
  destroy() {
    for (let [e, t, i] of this._listeners) D$1.removeEventListener(e, t, e === document ? this.handleWindowEvent : this.handleEvent, i);
  }
  _addDefaultHandlers(e) {
    let t = this._map, i = t.getCanvasContainer();
    this._add("mapEvent", new jc$1(t, e));
    let n4 = t.boxZoom = new Da(t, e);
    this._add("boxZoom", n4), e.interactive && e.boxZoom && n4.enable();
    let o4 = t.cooperativeGestures = new Ha(t, e.cooperativeGestures);
    this._add("cooperativeGestures", o4), e.cooperativeGestures && o4.enable();
    let a4 = new $c$1(t), s5 = new Qc$1(t);
    t.doubleClickZoom = new Ga(s5, a4), this._add("tapZoom", a4), this._add("clickZoom", s5), e.interactive && e.doubleClickZoom && t.doubleClickZoom.enable();
    let u5 = new ep$1();
    this._add("tapDragZoom", u5);
    let c = t.touchPitch = new Va(t);
    this._add("touchPitch", c), e.interactive && e.touchPitch && t.touchPitch.enable(e.touchPitch);
    let p4 = Wc$1(e), h = Xc$1(e);
    t.dragRotate = new ja(e, p4, h), this._add("mouseRotate", p4, ["mousePitch"]), this._add("mousePitch", h, ["mouseRotate"]), e.interactive && e.dragRotate && t.dragRotate.enable();
    let f = e2$1(e), m5 = new Jc$1(e, t);
    t.dragPan = new qa$1(i, f, m5), this._add("mousePan", f), this._add("touchPan", m5, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && t.dragPan.enable(e.dragPan);
    let y4 = new Oa(), g = new Ba();
    t.touchZoomRotate = new Za$1(i, g, y4, u5), this._add("touchRotate", y4, ["touchPan", "touchZoom"]), this._add("touchZoom", g, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && t.touchZoomRotate.enable(e.touchZoomRotate);
    let x2 = t.scrollZoom = new Na(t, () => this._triggerRenderFrame());
    this._add("scrollZoom", x2, ["mousePan"]), e.interactive && e.scrollZoom && t.scrollZoom.enable(e.scrollZoom);
    let b = t.keyboard = new Ua(t);
    this._add("keyboard", b), e.interactive && e.keyboard && t.keyboard.enable(), this._add("blockableMapEvent", new Zc2(t));
  }
  _add(e, t, i) {
    this._handlers.push({ handlerName: e, handler: t, allowed: i }), this._handlersById[e] = t;
  }
  stop(e) {
    if (!this._updatingCamera) {
      for (let { handler: t } of this._handlers) t.reset();
      this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
    }
  }
  isActive() {
    for (let { handler: e } of this._handlers) if (e.isActive()) return true;
    return false;
  }
  isZooming() {
    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
  }
  isRotating() {
    return !!this._eventsInProgress.rotate;
  }
  isMoving() {
    return !!tp$1(this._eventsInProgress) || this.isZooming();
  }
  _blockedByActive(e, t, i) {
    for (let n4 in e) if (n4 !== i && (!t || t.indexOf(n4) < 0)) return true;
    return false;
  }
  _getMapTouches(e) {
    let t = [];
    for (let i of e) {
      let n4 = i.target;
      this._el.contains(n4) && t.push(i);
    }
    return t;
  }
  mergeHandlerResult(e, t, i, n4, o4) {
    if (!i) return;
    V$1(e, i);
    let a4 = { handlerName: n4, originalEvent: i.originalEvent || o4 };
    i.zoomDelta !== void 0 && (t.zoom = a4), i.panDelta !== void 0 && (t.drag = a4), i.pitchDelta !== void 0 && (t.pitch = a4), i.bearingDelta !== void 0 && (t.rotate = a4);
  }
  _applyChanges() {
    let e = {}, t = {}, i = {};
    for (let [n4, o4, a4] of this._changes) n4.panDelta && (e.panDelta = (e.panDelta || new n2$1.default(0, 0))._add(n4.panDelta)), n4.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + n4.zoomDelta), n4.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + n4.bearingDelta), n4.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + n4.pitchDelta), n4.around !== void 0 && (e.around = n4.around), n4.pinchAround !== void 0 && (e.pinchAround = n4.pinchAround), n4.noInertia && (e.noInertia = n4.noInertia), V$1(t, o4), V$1(i, a4);
    this._updateMapTransform(e, t, i), this._changes = [];
  }
  _updateMapTransform(e, t, i) {
    let n4 = this._map, o4 = n4._getTransformForUpdate(), a4 = n4.terrain;
    if (!ox$1(e) && !(a4 && this._terrainMovement)) return this._fireEvents(t, i, true);
    let { panDelta: s5, zoomDelta: u5, bearingDelta: c, pitchDelta: p4, around: h, pinchAround: f } = e;
    f !== void 0 && (h = f), n4._stop(true), h = h || n4.transform.centerPoint;
    let m5 = o4.pointLocation(s5 ? h.sub(s5) : h);
    c && (o4.bearing += c), p4 && (o4.pitch += p4), u5 && (o4.zoom += u5), a4 ? !this._terrainMovement && (t.drag || t.zoom) ? (this._terrainMovement = true, this._map._elevationFreeze = true, o4.setLocationAtPoint(m5, h), this._map.once("moveend", () => {
      this._map._elevationFreeze = false, this._terrainMovement = false, o4.recalculateZoom(n4.terrain);
    })) : t.drag && this._terrainMovement ? o4.center = o4.pointLocation(o4.centerPoint.sub(s5)) : o4.setLocationAtPoint(m5, h) : o4.setLocationAtPoint(m5, h), n4._applyUpdatedTransform(o4), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(t, i, true);
  }
  _fireEvents(e, t, i) {
    let n4 = tp$1(this._eventsInProgress), o4 = tp$1(e), a4 = {};
    for (let p4 in e) {
      let { originalEvent: h } = e[p4];
      this._eventsInProgress[p4] || (a4["".concat(p4, "start")] = h), this._eventsInProgress[p4] = e[p4];
    }
    !n4 && o4 && this._fireEvent("movestart", o4.originalEvent);
    for (let p4 in a4) this._fireEvent(p4, a4[p4]);
    o4 && this._fireEvent("move", o4.originalEvent);
    for (let p4 in e) {
      let { originalEvent: h } = e[p4];
      this._fireEvent(p4, h);
    }
    let s5 = {}, u5;
    for (let p4 in this._eventsInProgress) {
      let { handlerName: h, originalEvent: f } = this._eventsInProgress[p4];
      this._handlersById[h].isActive() || (delete this._eventsInProgress[p4], u5 = t[h] || f, s5["".concat(p4, "end")] = u5);
    }
    for (let p4 in s5) this._fireEvent(p4, s5[p4]);
    let c = tp$1(this._eventsInProgress);
    if (i && (n4 || o4) && !c) {
      this._updatingCamera = true;
      let p4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), h = H$3((f) => f !== 0 && -this._bearingSnap < f && f < this._bearingSnap, "shouldSnapToNorth");
      p4 && (p4.essential || !Y$1.prefersReducedMotion) ? (h(p4.bearing || this._map.getBearing()) && (p4.bearing = 0), p4.freezeElevation = true, this._map.easeTo(p4, { originalEvent: u5 })) : (this._map.fire(new F("moveend", { originalEvent: u5 })), h(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
    }
  }
  _fireEvent(e, t) {
    this._map.fire(new F(e, t ? { originalEvent: t } : {}));
  }
  _requestFrame() {
    return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
      delete this._frameId, this.handleEvent(new ax("renderFrame", { timeStamp: e })), this._applyChanges();
    });
  }
  _triggerRenderFrame() {
    this._frameId === void 0 && (this._frameId = this._requestFrame());
  }
};
H$3(lx, "HandlerManager");
var rp = lx;
a();
var Wt$1 = N$2(ge(), 1);
var ux = class ux2 extends de$1 {
  constructor(t, i) {
    super();
    this._renderFrameCallback = H$3(() => {
      let t5 = Math.min((Y$1.now() - this._easeStart) / this._easeOptions.duration, 1);
      this._onEaseFrame(this._easeOptions.easing(t5)), t5 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
    }, "_renderFrameCallback");
    this._moving = false, this._zooming = false, this.transform = t, this._bearingSnap = i.bearingSnap, this.on("moveend", () => {
      delete this._requestedCameraState;
    });
  }
  getCenter() {
    return new ie$1(this.transform.center.lng, this.transform.center.lat);
  }
  setCenter(t, i) {
    return this.jumpTo({ center: t }, i);
  }
  panBy(t, i, n4) {
    return t = Wt$1.default.convert(t).mult(-1), this.panTo(this.transform.center, V$1({ offset: t }, i), n4);
  }
  panTo(t, i, n4) {
    return this.easeTo(V$1({ center: t }, i), n4);
  }
  getZoom() {
    return this.transform.zoom;
  }
  setZoom(t, i) {
    return this.jumpTo({ zoom: t }, i), this;
  }
  zoomTo(t, i, n4) {
    return this.easeTo(V$1({ zoom: t }, i), n4);
  }
  zoomIn(t, i) {
    return this.zoomTo(this.getZoom() + 1, t, i), this;
  }
  zoomOut(t, i) {
    return this.zoomTo(this.getZoom() - 1, t, i), this;
  }
  getBearing() {
    return this.transform.bearing;
  }
  setBearing(t, i) {
    return this.jumpTo({ bearing: t }, i), this;
  }
  getPadding() {
    return this.transform.padding;
  }
  setPadding(t, i) {
    return this.jumpTo({ padding: t }, i), this;
  }
  rotateTo(t, i, n4) {
    return this.easeTo(V$1({ bearing: t }, i), n4);
  }
  resetNorth(t, i) {
    return this.rotateTo(0, V$1({ duration: 1e3 }, t), i), this;
  }
  resetNorthPitch(t, i) {
    return this.easeTo(V$1({ bearing: 0, pitch: 0, duration: 1e3 }, t), i), this;
  }
  snapToNorth(t, i) {
    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, i) : this;
  }
  getPitch() {
    return this.transform.pitch;
  }
  setPitch(t, i) {
    return this.jumpTo({ pitch: t }, i), this;
  }
  cameraForBounds(t, i) {
    t = ut$1.convert(t);
    let n4 = i && i.bearing || 0;
    return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), n4, i);
  }
  _cameraForBoxAndBearing(t, i, n4, o4) {
    let a4 = { top: 0, bottom: 0, right: 0, left: 0 };
    if (o4 = V$1({ padding: a4, offset: [0, 0], maxZoom: this.transform.maxZoom }, o4), typeof o4.padding == "number") {
      let ne2 = o4.padding;
      o4.padding = { top: ne2, bottom: ne2, right: ne2, left: ne2 };
    }
    o4.padding = V$1(a4, o4.padding);
    let s5 = this.transform, u5 = s5.padding, c = new ut$1(t, i), p4 = s5.project(c.getNorthWest()), h = s5.project(c.getNorthEast()), f = s5.project(c.getSouthEast()), m5 = s5.project(c.getSouthWest()), y4 = wp$1(-n4), g = p4.rotate(y4), x2 = h.rotate(y4), b = f.rotate(y4), w3 = m5.rotate(y4), _ = new Wt$1.default(Math.max(g.x, x2.x, w3.x, b.x), Math.max(g.y, x2.y, w3.y, b.y)), S4 = new Wt$1.default(Math.min(g.x, x2.x, w3.x, b.x), Math.min(g.y, x2.y, w3.y, b.y)), P4 = _.sub(S4), T3 = (s5.width - (u5.left + u5.right + o4.padding.left + o4.padding.right)) / P4.x, L3 = (s5.height - (u5.top + u5.bottom + o4.padding.top + o4.padding.bottom)) / P4.y;
    if (L3 < 0 || T3 < 0) {
      Le$1("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
      return;
    }
    let C3 = Math.min(s5.scaleZoom(s5.scale * Math.min(T3, L3)), o4.maxZoom), E4 = Wt$1.default.convert(o4.offset), I3 = (o4.padding.left - o4.padding.right) / 2, R3 = (o4.padding.top - o4.padding.bottom) / 2, k3 = new Wt$1.default(I3, R3).rotate(wp$1(n4)), G3 = E4.add(k3).mult(s5.scale / s5.zoomScale(C3));
    return { center: s5.unproject(p4.add(f).div(2).sub(G3)), zoom: C3, bearing: n4 };
  }
  fitBounds(t, i, n4) {
    return this._fitInternal(this.cameraForBounds(t, i), i, n4);
  }
  fitScreenCoordinates(t, i, n4, o4, a4) {
    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(Wt$1.default.convert(t)), this.transform.pointLocation(Wt$1.default.convert(i)), n4, o4), o4, a4);
  }
  _fitInternal(t, i, n4) {
    return t ? (i = V$1(t, i), delete i.padding, i.linear ? this.easeTo(i, n4) : this.flyTo(i, n4)) : this;
  }
  jumpTo(t, i) {
    this.stop();
    let n4 = this._getTransformForUpdate(), o4 = false, a4 = false, s5 = false;
    return "zoom" in t && n4.zoom !== +t.zoom && (o4 = true, n4.zoom = +t.zoom), t.center !== void 0 && (n4.center = ie$1.convert(t.center)), "bearing" in t && n4.bearing !== +t.bearing && (a4 = true, n4.bearing = +t.bearing), "pitch" in t && n4.pitch !== +t.pitch && (s5 = true, n4.pitch = +t.pitch), t.padding != null && !n4.isPaddingEqual(t.padding) && (n4.padding = t.padding), this._applyUpdatedTransform(n4), this.fire(new F("movestart", i)).fire(new F("move", i)), o4 && this.fire(new F("zoomstart", i)).fire(new F("zoom", i)).fire(new F("zoomend", i)), a4 && this.fire(new F("rotatestart", i)).fire(new F("rotate", i)).fire(new F("rotateend", i)), s5 && this.fire(new F("pitchstart", i)).fire(new F("pitch", i)).fire(new F("pitchend", i)), this.fire(new F("moveend", i));
  }
  calculateCameraOptionsFromTo(t, i, n4, o4 = 0) {
    let a4 = Fe$1.fromLngLat(t, i), s5 = Fe$1.fromLngLat(n4, o4), u5 = s5.x - a4.x, c = s5.y - a4.y, p4 = s5.z - a4.z, h = Math.hypot(u5, c, p4);
    if (h === 0) throw new Error("Can't calculate camera options with same From and To");
    let f = Math.hypot(u5, c), m5 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / h / this.transform.tileSize), y4 = Math.atan2(u5, -c) * 180 / Math.PI, g = Math.acos(f / h) * 180 / Math.PI;
    return g = p4 < 0 ? 90 - g : 90 + g, { center: s5.toLngLat(), zoom: m5, pitch: g, bearing: y4 };
  }
  easeTo(t, i) {
    var L3;
    this._stop(false, t.easeId), t = V$1({ offset: [0, 0], duration: 500, easing: Ln$1 }, t), (t.animate === false || !t.essential && Y$1.prefersReducedMotion) && (t.duration = 0);
    let n4 = this._getTransformForUpdate(), o4 = this.getZoom(), a4 = this.getBearing(), s5 = this.getPitch(), u5 = this.getPadding(), c = "bearing" in t ? this._normalizeBearing(t.bearing, a4) : a4, p4 = "pitch" in t ? +t.pitch : s5, h = "padding" in t ? t.padding : n4.padding, f = Wt$1.default.convert(t.offset), m5 = n4.centerPoint.add(f), y4 = n4.pointLocation(m5), { center: g, zoom: x2 } = n4.getConstrained(ie$1.convert(t.center || y4), (L3 = t.zoom) != null ? L3 : o4);
    this._normalizeCenter(g);
    let b = n4.project(y4), w3 = n4.project(g).sub(b), _ = n4.zoomScale(x2 - o4), S4, P4;
    t.around && (S4 = ie$1.convert(t.around), P4 = n4.locationPoint(S4));
    let T3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
    return this._zooming = this._zooming || x2 !== o4, this._rotating = this._rotating || a4 !== c, this._pitching = this._pitching || p4 !== s5, this._padding = !n4.isPaddingEqual(h), this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, T3), this.terrain && this._prepareElevation(g), this._ease((C3) => {
      if (this._zooming && (n4.zoom = Pe$2.number(o4, x2, C3)), this._rotating && (n4.bearing = Pe$2.number(a4, c, C3)), this._pitching && (n4.pitch = Pe$2.number(s5, p4, C3)), this._padding && (n4.interpolatePadding(u5, h, C3), m5 = n4.centerPoint.add(f)), this.terrain && !t.freezeElevation && this._updateElevation(C3), S4) n4.setLocationAtPoint(S4, P4);
      else {
        let E4 = n4.zoomScale(n4.zoom - o4), I3 = x2 > o4 ? Math.min(2, _) : Math.max(0.5, _), R3 = Math.pow(I3, 1 - C3), z4 = n4.unproject(b.add(w3.mult(C3 * R3)).mult(E4));
        n4.setLocationAtPoint(n4.renderWorldCopies ? z4.wrap() : z4, m5);
      }
      this._applyUpdatedTransform(n4), this._fireMoveEvents(i);
    }, (C3) => {
      this.terrain && this._finalizeElevation(), this._afterEase(i, C3);
    }, t), this;
  }
  _prepareEase(t, i, n4 = {}) {
    this._moving = true, !i && !n4.moving && this.fire(new F("movestart", t)), this._zooming && !n4.zooming && this.fire(new F("zoomstart", t)), this._rotating && !n4.rotating && this.fire(new F("rotatestart", t)), this._pitching && !n4.pitching && this.fire(new F("pitchstart", t));
  }
  _prepareElevation(t) {
    this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = true;
  }
  _updateElevation(t) {
    this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
    let i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
    if (t < 1 && i !== this._elevationTarget) {
      let n4 = this._elevationTarget - this._elevationStart, o4 = (i - (n4 * t + this._elevationStart)) / (1 - t);
      this._elevationStart += t * (n4 - o4), this._elevationTarget = i;
    }
    this.transform.elevation = Pe$2.number(this._elevationStart, this._elevationTarget, t);
  }
  _finalizeElevation() {
    this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
  }
  _getTransformForUpdate() {
    return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
  }
  _applyUpdatedTransform(t) {
    if (!this.transformCameraUpdate) return;
    let i = t.clone(), { center: n4, zoom: o4, pitch: a4, bearing: s5, elevation: u5 } = this.transformCameraUpdate(i);
    n4 && (i.center = n4), o4 !== void 0 && (i.zoom = o4), a4 !== void 0 && (i.pitch = a4), s5 !== void 0 && (i.bearing = s5), u5 !== void 0 && (i.elevation = u5), this.transform.apply(i);
  }
  _fireMoveEvents(t) {
    this.fire(new F("move", t)), this._zooming && this.fire(new F("zoom", t)), this._rotating && this.fire(new F("rotate", t)), this._pitching && this.fire(new F("pitch", t));
  }
  _afterEase(t, i) {
    if (this._easeId && i && this._easeId === i) return;
    delete this._easeId;
    let n4 = this._zooming, o4 = this._rotating, a4 = this._pitching;
    this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, n4 && this.fire(new F("zoomend", t)), o4 && this.fire(new F("rotateend", t)), a4 && this.fire(new F("pitchend", t)), this.fire(new F("moveend", t));
  }
  flyTo(t, i) {
    var ne2;
    if (!t.essential && Y$1.prefersReducedMotion) {
      let J4 = yr$1(t, ["center", "zoom", "bearing", "pitch", "around"]);
      return this.jumpTo(J4, i);
    }
    this.stop(), t = V$1({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: Ln$1 }, t);
    let n4 = this._getTransformForUpdate(), o4 = this.getZoom(), a4 = this.getBearing(), s5 = this.getPitch(), u5 = this.getPadding(), c = "bearing" in t ? this._normalizeBearing(t.bearing, a4) : a4, p4 = "pitch" in t ? +t.pitch : s5, h = "padding" in t ? t.padding : n4.padding, f = Wt$1.default.convert(t.offset), m5 = n4.centerPoint.add(f), y4 = n4.pointLocation(m5), { center: g, zoom: x2 } = n4.getConstrained(ie$1.convert(t.center || y4), (ne2 = t.zoom) != null ? ne2 : o4);
    this._normalizeCenter(g);
    let b = n4.zoomScale(x2 - o4), w3 = n4.project(y4), _ = n4.project(g).sub(w3), S4 = t.curve, P4 = Math.max(n4.width, n4.height), T3 = P4 / b, L3 = _.mag();
    if ("minZoom" in t) {
      let J4 = Ae$2(Math.min(t.minZoom, o4, x2), n4.minZoom, n4.maxZoom), W4 = P4 / n4.zoomScale(J4 - o4);
      S4 = Math.sqrt(W4 / L3 * 2);
    }
    let C3 = S4 * S4;
    function E4(J4) {
      let W4 = (T3 * T3 - P4 * P4 + (J4 ? -1 : 1) * C3 * C3 * L3 * L3) / (2 * (J4 ? T3 : P4) * C3 * L3);
      return Math.log(Math.sqrt(W4 * W4 + 1) - W4);
    }
    H$3(E4, "zoomOutFactor");
    function I3(J4) {
      return (Math.exp(J4) - Math.exp(-J4)) / 2;
    }
    H$3(I3, "sinh");
    function R3(J4) {
      return (Math.exp(J4) + Math.exp(-J4)) / 2;
    }
    H$3(R3, "cosh");
    function z4(J4) {
      return I3(J4) / R3(J4);
    }
    H$3(z4, "tanh");
    let k3 = E4(false), M3 = H$3(function(J4) {
      return R3(k3) / R3(k3 + S4 * J4);
    }, "w"), G3 = H$3(function(J4) {
      return P4 * ((R3(k3) * z4(k3 + S4 * J4) - I3(k3)) / C3) / L3;
    }, "u"), K4 = (E4(true) - k3) / S4;
    if (Math.abs(L3) < 1e-6 || !isFinite(K4)) {
      if (Math.abs(P4 - T3) < 1e-6) return this.easeTo(t, i);
      let J4 = T3 < P4 ? -1 : 1;
      K4 = Math.abs(Math.log(T3 / P4)) / S4, G3 = H$3(function() {
        return 0;
      }, "u"), M3 = H$3(function(W4) {
        return Math.exp(J4 * S4 * W4);
      }, "w");
    }
    if ("duration" in t) t.duration = +t.duration;
    else {
      let J4 = "screenSpeed" in t ? +t.screenSpeed / S4 : +t.speed;
      t.duration = 1e3 * K4 / J4;
    }
    return t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = true, this._rotating = a4 !== c, this._pitching = p4 !== s5, this._padding = !n4.isPaddingEqual(h), this._prepareEase(i, false), this.terrain && this._prepareElevation(g), this._ease((J4) => {
      let W4 = J4 * K4, Ye2 = 1 / M3(W4);
      n4.zoom = J4 === 1 ? x2 : o4 + n4.scaleZoom(Ye2), this._rotating && (n4.bearing = Pe$2.number(a4, c, J4)), this._pitching && (n4.pitch = Pe$2.number(s5, p4, J4)), this._padding && (n4.interpolatePadding(u5, h, J4), m5 = n4.centerPoint.add(f)), this.terrain && !t.freezeElevation && this._updateElevation(J4);
      let Ve3 = J4 === 1 ? g : n4.unproject(w3.add(_.mult(G3(W4))).mult(Ye2));
      n4.setLocationAtPoint(n4.renderWorldCopies ? Ve3.wrap() : Ve3, m5), this._applyUpdatedTransform(n4), this._fireMoveEvents(i);
    }, () => {
      this.terrain && this._finalizeElevation(), this._afterEase(i);
    }, t), this;
  }
  isEasing() {
    return !!this._easeFrameId;
  }
  stop() {
    return this._stop();
  }
  _stop(t, i) {
    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
      let n4 = this._onEaseEnd;
      delete this._onEaseEnd, n4.call(this, i);
    }
    if (!t) {
      let n4 = this.handlers;
      n4 && n4.stop(false);
    }
    return this;
  }
  _ease(t, i, n4) {
    n4.animate === false || n4.duration === 0 ? (t(1), i()) : (this._easeStart = Y$1.now(), this._easeOptions = n4, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
  }
  _normalizeBearing(t, i) {
    t = er$1(t, -180, 180);
    let n4 = Math.abs(t - i);
    return Math.abs(t - 360 - i) < n4 && (t -= 360), Math.abs(t + 360 - i) < n4 && (t += 360), t;
  }
  _normalizeCenter(t) {
    let i = this.transform;
    if (!i.renderWorldCopies || i.lngRange) return;
    let n4 = t.lng - i.center.lng;
    t.lng += n4 > 180 ? -360 : n4 < -180 ? 360 : 0;
  }
  queryTerrainElevation(t) {
    return this.terrain ? this.terrain.getElevationForLngLatZoom(ie$1.convert(t), this.transform.tileZoom) - this.transform.elevation : null;
  }
};
H$3(ux, "Camera");
var ip = ux;
var fr$1 = N$2(ge(), 1);
a();
var cx = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' }, px$1 = class px {
  constructor(e = cx) {
    this._toggleAttribution = H$3(() => {
      this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
    }, "_toggleAttribution");
    this._updateData = H$3((e4) => {
      e4 && (e4.sourceDataType === "metadata" || e4.sourceDataType === "visibility" || e4.dataType === "style" || e4.type === "terrain") && this._updateAttributions();
    }, "_updateData");
    this._updateCompact = H$3(() => {
      this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : !this._container.classList.contains("maplibregl-compact") && !this._container.classList.contains("maplibregl-attrib-empty") && (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
    }, "_updateCompact");
    this._updateCompactMinimize = H$3(() => {
      this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
    }, "_updateCompactMinimize");
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-right";
  }
  onAdd(e) {
    return this._map = e, this._compact = this.options.compact, this._container = D$1.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = D$1.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = D$1.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
  }
  onRemove() {
    D$1.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
  }
  _setElementTitle(e, t) {
    let i = this._map._getUIString("AttributionControl.".concat(t));
    e.title = i, e.setAttribute("aria-label", i);
  }
  _updateAttributions() {
    if (!this._map.style) return;
    let e = [];
    if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((n4) => typeof n4 != "string" ? "" : n4)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
      let n4 = this._map.style.stylesheet;
      this.styleOwner = n4.owner, this.styleId = n4.id;
    }
    let t = this._map.style.sourceCaches;
    for (let n4 in t) {
      let o4 = t[n4];
      if (o4.used || o4.usedForTerrain) {
        let a4 = o4.getSource();
        a4.attribution && e.indexOf(a4.attribution) < 0 && e.push(a4.attribution);
      }
    }
    e = e.filter((n4) => String(n4).trim()), e.sort((n4, o4) => n4.length - o4.length), e = e.filter((n4, o4) => {
      for (let a4 = o4 + 1; a4 < e.length; a4++) if (e[a4].indexOf(n4) >= 0) return false;
      return true;
    });
    let i = e.join(" | ");
    i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
  }
};
H$3(px$1, "AttributionControl");
var $a = px$1;
a();
var hx$1 = class hx {
  constructor(e = {}) {
    this._updateCompact = H$3(() => {
      let e4 = this._container.children;
      if (e4.length) {
        let t = e4[0];
        this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && t.classList.add("maplibregl-compact") : t.classList.remove("maplibregl-compact");
      }
    }, "_updateCompact");
    this.options = e;
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e) {
    this._map = e, this._compact = this.options && this.options.compact, this._container = D$1.create("div", "maplibregl-ctrl");
    let t = D$1.create("a", "maplibregl-ctrl-logo");
    return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://maplibre.org/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
  onRemove() {
    D$1.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
  }
};
H$3(hx$1, "LogoControl");
var Wa = hx$1;
a();
var fx$1 = class fx {
  constructor() {
    this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
  }
  add(e) {
    let t = ++this._id;
    return this._queue.push({ callback: e, id: t, cancelled: false }), t;
  }
  remove(e) {
    let t = this._currentlyRunning, i = t ? this._queue.concat(t) : this._queue;
    for (let n4 of i) if (n4.id === e) {
      n4.cancelled = true;
      return;
    }
  }
  run(e = 0) {
    if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
    let t = this._currentlyRunning = this._queue;
    this._queue = [];
    for (let i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;
    this._cleared = false, this._currentlyRunning = false;
  }
  clear() {
    this._currentlyRunning && (this._cleared = true), this._queue = [];
  }
};
H$3(fx$1, "TaskQueue");
var np = fx$1;
a();
var ap = ((i) => (i.create = "create", i.load = "load", i.fullLoad = "fullLoad", i))(ap || {}), op = null, Xa = [], dD$1 = 60, mx$1 = 1e3 / dD$1, dx$1 = "loadTime", yx$1 = "fullLoadTime", In$1 = { mark(r5) {
  performance.mark(r5);
}, frame(r5) {
  let e = r5;
  if (op != null) {
    let t = e - op;
    Xa.push(t);
  }
  op = e;
}, clearMetrics() {
  op = null, Xa = [], performance.clearMeasures(dx$1), performance.clearMeasures(yx$1);
  for (let r5 in ap) performance.clearMarks(ap[r5]);
}, getPerformanceMetrics() {
  performance.measure(dx$1, "create", "load"), performance.measure(yx$1, "create", "fullLoad");
  let r5 = performance.getEntriesByName(dx$1)[0].duration, e = performance.getEntriesByName(yx$1)[0].duration, t = Xa.length, n4 = 1 / (Xa.reduce((s5, u5) => s5 + u5, 0) / t / 1e3), o4 = Xa.filter((s5) => s5 > mx$1).reduce((s5, u5) => s5 + (u5 - mx$1) / mx$1, 0), a4 = o4 / (t + o4) * 100;
  return { loadTime: r5, fullLoadTime: e, fps: n4, percentDroppedFrames: a4, totalFrames: t };
} };
a();
a();
var o2$1 = _e$1([{ name: "a_pos3d", type: "Int16", components: 3 }]);
a();
var gx$1 = class gx extends de$1 {
  constructor(e) {
    super(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e.usedForTerrain = true, e.tileSize = this.tileSize * 2 ** this.deltaZoom;
  }
  destruct() {
    this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
  }
  update(e, t) {
    this.sourceCache.update(e, t), this._renderableTilesKeys = [];
    let i = {};
    for (let n4 of e.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: t })) i[n4.key] = true, this._renderableTilesKeys.push(n4.key), this._tiles[n4.key] || (n4.posMatrix = new Float64Array(16), q$2.ortho(n4.posMatrix, 0, 8192, 0, 8192, 0, 1), this._tiles[n4.key] = new wn$2(n4, this.tileSize));
    for (let n4 in this._tiles) i[n4] || delete this._tiles[n4];
  }
  freeRtt(e) {
    for (let t in this._tiles) {
      let i = this._tiles[t];
      (!e || i.tileID.equals(e) || i.tileID.isChildOf(e) || e.isChildOf(i.tileID)) && (i.rtt = []);
    }
  }
  getRenderableTiles() {
    return this._renderableTilesKeys.map((e) => this.getTileByID(e));
  }
  getTileByID(e) {
    return this._tiles[e];
  }
  getTerrainCoords(e) {
    let t = {};
    for (let i of this._renderableTilesKeys) {
      let n4 = this._tiles[i].tileID;
      if (n4.canonical.equals(e.canonical)) {
        let o4 = e.clone();
        o4.posMatrix = new Float64Array(16), q$2.ortho(o4.posMatrix, 0, 8192, 0, 8192, 0, 1), t[i] = o4;
      } else if (n4.canonical.isChildOf(e.canonical)) {
        let o4 = e.clone();
        o4.posMatrix = new Float64Array(16);
        let a4 = n4.canonical.z - e.canonical.z, s5 = n4.canonical.x - (n4.canonical.x >> a4 << a4), u5 = n4.canonical.y - (n4.canonical.y >> a4 << a4), c = 8192 >> a4;
        q$2.ortho(o4.posMatrix, 0, c, 0, c, 0, 1), q$2.translate(o4.posMatrix, o4.posMatrix, [-s5 * c, -u5 * c, 0]), t[i] = o4;
      } else if (e.canonical.isChildOf(n4.canonical)) {
        let o4 = e.clone();
        o4.posMatrix = new Float64Array(16);
        let a4 = e.canonical.z - n4.canonical.z, s5 = e.canonical.x - (e.canonical.x >> a4 << a4), u5 = e.canonical.y - (e.canonical.y >> a4 << a4), c = 8192 >> a4;
        q$2.ortho(o4.posMatrix, 0, 8192, 0, 8192, 0, 1), q$2.translate(o4.posMatrix, o4.posMatrix, [s5 * c, u5 * c, 0]), q$2.scale(o4.posMatrix, o4.posMatrix, [1 / 2 ** a4, 1 / 2 ** a4, 0]), t[i] = o4;
      }
    }
    return t;
  }
  getSourceTile(e, t) {
    let i = this.sourceCache._source, n4 = e.overscaledZ - this.deltaZoom;
    if (n4 > i.maxzoom && (n4 = i.maxzoom), n4 < i.minzoom) return null;
    this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(n4).key);
    let o4 = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
    if (!(o4 && o4.dem) && t) for (; n4 >= i.minzoom && !(o4 && o4.dem); ) o4 = this.sourceCache.getTileByID(e.scaledTo(n4--).key);
    return o4;
  }
  tilesAfterTime(e = Date.now()) {
    return Object.values(this._tiles).filter((t) => t.timeAdded >= e);
  }
};
H$3(gx$1, "TerrainSourceCache");
var sp = gx$1;
var xx$1 = class xx {
  constructor(e, t, i) {
    this.painter = e, this.sourceCache = new sp(t), this.options = i, this.exaggeration = typeof i.exaggeration == "number" ? i.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
  }
  getDEMElevation(e, t, i, n4 = 8192) {
    var m5;
    if (!(t >= 0 && t < n4 && i >= 0 && i < n4)) return 0;
    let o4 = this.getTerrainData(e), a4 = (m5 = o4.tile) == null ? void 0 : m5.dem;
    if (!a4) return 0;
    let s5 = sn.transformMat4([], [t / n4 * 8192, i / n4 * 8192], o4.u_terrain_matrix), u5 = [s5[0] * a4.dim, s5[1] * a4.dim], c = Math.floor(u5[0]), p4 = Math.floor(u5[1]), h = u5[0] - c, f = u5[1] - p4;
    return a4.get(c, p4) * (1 - h) * (1 - f) + a4.get(c + 1, p4) * h * (1 - f) + a4.get(c, p4 + 1) * (1 - h) * f + a4.get(c + 1, p4 + 1) * h * f;
  }
  getElevationForLngLatZoom(e, t) {
    let { tileID: i, mercatorX: n4, mercatorY: o4 } = this._getOverscaledTileIDFromLngLatZoom(e, t);
    return this.getElevation(i, n4 % 8192, o4 % 8192, 8192);
  }
  getElevation(e, t, i, n4 = 8192) {
    return this.getDEMElevation(e, t, i, n4) * this.exaggeration;
  }
  getTerrainData(e) {
    if (!this._emptyDemTexture) {
      let n4 = this.painter.context, o4 = new Se$2({ width: 1, height: 1 }, new Uint8Array(1 * 4));
      this._emptyDepthTexture = new ve$2(n4, o4, n4.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new ve$2(n4, new Se$2({ width: 1, height: 1 }), n4.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(n4.gl.NEAREST, n4.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = q$2.identity([]);
    }
    let t = this.sourceCache.getSourceTile(e, true);
    if (t && t.dem && (!t.demTexture || t.needsTerrainPrepare)) {
      let n4 = this.painter.context;
      t.demTexture = this.painter.getTileTexture(t.dem.stride), t.demTexture ? t.demTexture.update(t.dem.getPixels(), { premultiply: false }) : t.demTexture = new ve$2(n4, t.dem.getPixels(), n4.gl.RGBA, { premultiply: false }), t.demTexture.bind(n4.gl.NEAREST, n4.gl.CLAMP_TO_EDGE), t.needsTerrainPrepare = false;
    }
    let i = t && t + t.tileID.key + e.key;
    if (i && !this._demMatrixCache[i]) {
      let n4 = this.sourceCache.sourceCache._source.maxzoom, o4 = e.canonical.z - t.tileID.canonical.z;
      e.overscaledZ > e.canonical.z && (e.canonical.z >= n4 ? o4 = e.canonical.z - n4 : Le$1("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
      let a4 = e.canonical.x - (e.canonical.x >> o4 << o4), s5 = e.canonical.y - (e.canonical.y >> o4 << o4), u5 = q$2.fromScaling(new Float64Array(16), [1 / (8192 << o4), 1 / (8192 << o4), 0]);
      q$2.translate(u5, u5, [a4 * 8192, s5 * 8192, 0]), this._demMatrixCache[e.key] = { matrix: u5, coord: e };
    }
    return { u_depth: 2, u_terrain: 3, u_terrain_dim: t && t.dem && t.dem.dim || 1, u_terrain_matrix: i ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: t && t.dem && t.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (t && t.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: t };
  }
  getFramebuffer(e) {
    let t = this.painter, i = t.width / devicePixelRatio, n4 = t.height / devicePixelRatio;
    return this._fbo && (this._fbo.width !== i || this._fbo.height !== n4) && (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new ve$2(t.context, { width: i, height: n4, data: null }, t.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new ve$2(t.context, { width: i, height: n4, data: null }, t.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t.context.createFramebuffer(i, n4, true, false), this._fbo.depthAttachment.set(t.context.createRenderbuffer(t.context.gl.DEPTH_COMPONENT16, i, n4))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
  }
  getCoordsTexture() {
    let e = this.painter.context;
    if (this._coordsTexture) return this._coordsTexture;
    let t = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
    for (let o4 = 0, a4 = 0; o4 < this._coordsTextureSize; o4++) for (let s5 = 0; s5 < this._coordsTextureSize; s5++, a4 += 4) t[a4 + 0] = s5 & 255, t[a4 + 1] = o4 & 255, t[a4 + 2] = s5 >> 8 << 4 | o4 >> 8, t[a4 + 3] = 0;
    let i = new Se$2({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(t.buffer)), n4 = new ve$2(e, i, e.gl.RGBA, { premultiply: false });
    return n4.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = n4, n4;
  }
  pointCoordinate(e) {
    this.painter.maybeDrawDepthAndCoords(true);
    let t = new Uint8Array(4), i = this.painter.context, n4 = i.gl, o4 = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), a4 = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), s5 = Math.round(this.painter.height / devicePixelRatio);
    i.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), n4.readPixels(o4, s5 - a4 - 1, 1, 1, n4.RGBA, n4.UNSIGNED_BYTE, t), i.bindFramebuffer.set(null);
    let u5 = t[0] + (t[2] >> 4 << 8), c = t[1] + ((t[2] & 15) << 8), p4 = this.coordsIndex[255 - t[3]], h = p4 && this.sourceCache.getTileByID(p4);
    if (!h) return null;
    let f = this._coordsTextureSize, m5 = (1 << h.tileID.canonical.z) * f;
    return new Fe$1((h.tileID.canonical.x * f + u5) / m5 + h.tileID.wrap, (h.tileID.canonical.y * f + c) / m5, this.getElevation(h.tileID, u5, c, f));
  }
  depthAtPoint(e) {
    let t = new Uint8Array(4), i = this.painter.context, n4 = i.gl;
    return i.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), n4.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, n4.RGBA, n4.UNSIGNED_BYTE, t), i.bindFramebuffer.set(null), (t[0] / (256 * 256 * 256) + t[1] / (256 * 256) + t[2] / 256 + t[3]) / 256;
  }
  getTerrainMesh() {
    if (this._mesh) return this._mesh;
    let e = this.painter.context, t = new fl$1(), i = new it$2(), n4 = this.meshSize, o4 = 8192 / n4, a4 = n4 * n4;
    for (let h = 0; h <= n4; h++) for (let f = 0; f <= n4; f++) t.emplaceBack(f * o4, h * o4, 0);
    for (let h = 0; h < a4; h += n4 + 1) for (let f = 0; f < n4; f++) i.emplaceBack(f + h, n4 + f + h + 1, n4 + f + h + 2), i.emplaceBack(f + h, n4 + f + h + 2, f + h + 1);
    let s5 = t.length, u5 = s5 + (n4 + 1) * 2;
    for (let h of [0, 1]) for (let f = 0; f <= n4; f++) for (let m5 of [0, 1]) t.emplaceBack(f * o4, h * 8192, m5);
    for (let h = 0; h < n4 * 2; h += 2) i.emplaceBack(u5 + h, u5 + h + 1, u5 + h + 3), i.emplaceBack(u5 + h, u5 + h + 3, u5 + h + 2), i.emplaceBack(s5 + h, s5 + h + 3, s5 + h + 1), i.emplaceBack(s5 + h, s5 + h + 2, s5 + h + 3);
    let c = t.length, p4 = c + (n4 + 1) * 2;
    for (let h of [0, 1]) for (let f = 0; f <= n4; f++) for (let m5 of [0, 1]) t.emplaceBack(h * 8192, f * o4, m5);
    for (let h = 0; h < n4 * 2; h += 2) i.emplaceBack(c + h, c + h + 1, c + h + 3), i.emplaceBack(c + h, c + h + 3, c + h + 2), i.emplaceBack(p4 + h, p4 + h + 3, p4 + h + 1), i.emplaceBack(p4 + h, p4 + h + 2, p4 + h + 3);
    return this._mesh = { indexBuffer: e.createIndexBuffer(i), vertexBuffer: e.createVertexBuffer(t, o2$1.members), segments: me$1.simpleSegment(0, 0, t.length, i.length) }, this._mesh;
  }
  getMeshFrameDelta(e) {
    return 2 * Math.PI * ca$1 / Math.pow(2, e) / 5;
  }
  getMinTileElevationForLngLatZoom(e, t) {
    var n4;
    let { tileID: i } = this._getOverscaledTileIDFromLngLatZoom(e, t);
    return (n4 = this.getMinMaxElevation(i).minElevation) != null ? n4 : 0;
  }
  getMinMaxElevation(e) {
    let t = this.getTerrainData(e).tile, i = { minElevation: null, maxElevation: null };
    return t && t.dem && (i.minElevation = t.dem.min * this.exaggeration, i.maxElevation = t.dem.max * this.exaggeration), i;
  }
  _getOverscaledTileIDFromLngLatZoom(e, t) {
    let i = Fe$1.fromLngLat(e.wrap()), n4 = (1 << t) * 8192, o4 = i.x * n4, a4 = i.y * n4, s5 = Math.floor(o4 / 8192), u5 = Math.floor(a4 / 8192);
    return { tileID: new Je(t, 0, t, s5, u5), mercatorX: o4, mercatorY: a4 };
  }
};
H$3(xx$1, "Terrain");
var lp = xx$1;
a();
a();
var bx$1 = class bx {
  constructor(e, t, i) {
    this._context = e;
    this._size = t;
    this._tileSize = i;
    this._objects = [], this._recentlyUsed = [], this._stamp = 0;
  }
  destruct() {
    for (let e of this._objects) e.texture.destroy(), e.fbo.destroy();
  }
  _createObject(e) {
    let t = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i = new ve$2(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
    return i.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), t.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t.colorAttachment.set(i.texture), { id: e, fbo: t, texture: i, stamp: -1, inUse: false };
  }
  getObjectForId(e) {
    return this._objects[e];
  }
  useObject(e) {
    e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t) => e.id !== t), this._recentlyUsed.push(e.id);
  }
  stampObject(e) {
    e.stamp = ++this._stamp;
  }
  getOrCreateFreeObject() {
    for (let t of this._recentlyUsed) if (!this._objects[t].inUse) return this._objects[t];
    if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
    let e = this._createObject(this._objects.length);
    return this._objects.push(e), e;
  }
  freeObject(e) {
    e.inUse = false;
  }
  freeAllObjects() {
    for (let e of this._objects) this.freeObject(e);
  }
  isFull() {
    return this._objects.length < this._size ? false : this._objects.some((e) => !e.inUse) === false;
  }
};
H$3(bx$1, "RenderPool");
var up = bx$1;
var Cn$2 = { background: true, fill: true, line: true, raster: true, hillshade: true }, _x$1 = class _x {
  constructor(e, t) {
    this.painter = e, this.terrain = t, this.pool = new up(e.context, 30, t.sourceCache.tileSize * t.qualityFactor);
  }
  destruct() {
    this.pool.destruct();
  }
  getTexture(e) {
    return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
  }
  prepareForRender(e, t) {
    this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((i) => !e._layers[i].isHidden(t)), this._coordsDescendingInv = {};
    for (let i in e.sourceCaches) {
      this._coordsDescendingInv[i] = {};
      let n4 = e.sourceCaches[i].getVisibleCoordinates();
      for (let o4 of n4) {
        let a4 = this.terrain.sourceCache.getTerrainCoords(o4);
        for (let s5 in a4) this._coordsDescendingInv[i][s5] || (this._coordsDescendingInv[i][s5] = []), this._coordsDescendingInv[i][s5].push(a4[s5]);
      }
    }
    this._coordsDescendingInvStr = {};
    for (let i of e._order) {
      let n4 = e._layers[i], o4 = n4.source;
      if (Cn$2[n4.type] && !this._coordsDescendingInvStr[o4]) {
        this._coordsDescendingInvStr[o4] = {};
        for (let a4 in this._coordsDescendingInv[o4]) this._coordsDescendingInvStr[o4][a4] = this._coordsDescendingInv[o4][a4].map((s5) => s5.key).sort().join();
      }
    }
    for (let i of this._renderableTiles) for (let n4 in this._coordsDescendingInvStr) {
      let o4 = this._coordsDescendingInvStr[n4][i.tileID.key];
      o4 && o4 !== i.rttCoords[n4] && (i.rtt = []);
    }
  }
  renderLayer(e) {
    if (e.isHidden(this.painter.transform.zoom)) return false;
    let t = e.type, i = this.painter, n4 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
    if (Cn$2[t] && ((!this._prevType || !Cn$2[this._prevType]) && this._stacks.push([]), this._prevType = t, this._stacks[this._stacks.length - 1].push(e.id), !n4)) return true;
    if (Cn$2[this._prevType] || Cn$2[t] && n4) {
      this._prevType = t;
      let o4 = this._stacks.length - 1, a4 = this._stacks[o4] || [];
      for (let s5 of this._renderableTiles) {
        if (this.pool.isFull() && (Sg$1(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(s5), s5.rtt[o4]) {
          let c = this.pool.getObjectForId(s5.rtt[o4].id);
          if (c.stamp === s5.rtt[o4].stamp) {
            this.pool.useObject(c);
            continue;
          }
        }
        let u5 = this.pool.getOrCreateFreeObject();
        this.pool.useObject(u5), this.pool.stampObject(u5), s5.rtt[o4] = { id: u5.id, stamp: u5.stamp }, i.context.bindFramebuffer.set(u5.fbo.framebuffer), i.context.clear({ color: X$1.transparent, stencil: 0 }), i.currentStencilSource = void 0;
        for (let c = 0; c < a4.length; c++) {
          let p4 = i.style._layers[a4[c]], h = p4.source ? this._coordsDescendingInv[p4.source][s5.tileID.key] : [s5.tileID];
          i.context.viewport.set([0, 0, u5.fbo.width, u5.fbo.height]), i._renderTileClippingMasks(p4, h), i.renderLayer(i, i.style.sourceCaches[p4.source], p4, h), p4.source && (s5.rttCoords[p4.source] = this._coordsDescendingInvStr[p4.source][s5.tileID.key]);
        }
      }
      return Sg$1(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Cn$2[t];
    }
    return false;
  }
};
H$3(_x$1, "RenderToTexture");
var cp = _x$1;
a();
var a2$1 = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" };
var yD$1 = ts.version, hp = -2, s2$1 = 22, Nr$1 = 0, l2$1 = 80, pp = 85, gD$1 = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: hp, maxZoom: s2$1, minPitch: Nr$1, maxPitch: l2$1, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: cx, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: Ke.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, wx$1 = class wx extends ip {
  constructor(t) {
    if (In$1.mark("create"), t = V$1({}, gD$1, t), t.minZoom != null && t.maxZoom != null && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
    if (t.minPitch != null && t.maxPitch != null && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
    if (t.minPitch != null && t.minPitch < Nr$1) throw new Error("minPitch must be greater than or equal to ".concat(Nr$1));
    if (t.maxPitch != null && t.maxPitch > pp) throw new Error("maxPitch must be less than or equal to ".concat(pp));
    let i = new Bc$1(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies);
    super(i, { bearingSnap: t.bearingSnap });
    this._contextLost = H$3((t5) => {
      t5.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new F("webglcontextlost", { originalEvent: t5 }));
    }, "_contextLost");
    this._contextRestored = H$3((t5) => {
      this._setupPainter(), this.resize(), this._update(), this.fire(new F("webglcontextrestored", { originalEvent: t5 }));
    }, "_contextRestored");
    this._onMapScroll = H$3((t5) => {
      if (t5.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
    }, "_onMapScroll");
    this._onWindowOnline = H$3(() => {
      this._update();
    }, "_onWindowOnline");
    if (this._interactive = t.interactive, this._maxTileCacheSize = t.maxTileCacheSize, this._maxTileCacheZoomLevels = t.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._crossSourceCollisions = t.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t.collectResourceTiming, this._renderTaskQueue = new np(), this._controls = [], this._mapId = ns(), this._locale = V$1({}, a2$1, t.locale), this._clickTolerance = t.clickTolerance, this._overridePixelRatio = t.pixelRatio, this._maxCanvasSize = t.maxCanvasSize, this.transformCameraUpdate = t.transformCameraUpdate, this._imageQueueHandle = st$1.addThrottleControl(() => this.isMoving()), this._requestManager = new cs$1(t.transformRequest), typeof t.container == "string") {
      if (this._container = document.getElementById(t.container), !this._container) throw new Error("Container '".concat(t.container, "' not found."));
    } else if (t.container instanceof HTMLElement) this._container = t.container;
    else throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
    if (t.maxBounds && this.setMaxBounds(t.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
      this.painter.terrainFacilitator.dirty = true, this._update(true);
    }), this.once("idle", () => {
      this._idleTriggered = true;
    }), typeof window < "u") {
      addEventListener("online", this._onWindowOnline, false);
      let o4 = false, a4 = Vc$1((s5) => {
        this._trackResize && !this._removed && this.resize(s5)._update();
      }, 50);
      this._resizeObserver = new ResizeObserver((s5) => {
        if (!o4) {
          o4 = true;
          return;
        }
        a4(s5);
      }), this._resizeObserver.observe(this._container);
    }
    this.handlers = new rp(this, t);
    let n4 = typeof t.hash == "string" && t.hash || void 0;
    this._hash = t.hash && new ka(n4).addTo(this), (!this._hash || !this._hash._onHashChange()) && (this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), t.bounds && (this.resize(), this.fitBounds(t.bounds, V$1({}, t.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t.localIdeographFontFamily, this._validateStyle = t.validateStyle, t.style && this.setStyle(t.style, { localIdeographFontFamily: t.localIdeographFontFamily }), t.attributionControl && this.addControl(new $a(typeof t.attributionControl == "boolean" ? void 0 : t.attributionControl)), t.maplibreLogo && this.addControl(new Wa(), t.logoPosition), this.on("style.load", () => {
      this.transform.unmodified && this.jumpTo(this.style.stylesheet);
    }), this.on("data", (o4) => {
      this._update(o4.dataType === "style"), this.fire(new F("".concat(o4.dataType, "data"), o4));
    }), this.on("dataloading", (o4) => {
      this.fire(new F("".concat(o4.dataType, "dataloading"), o4));
    }), this.on("dataabort", (o4) => {
      this.fire(new F("sourcedataabort", o4));
    });
  }
  _getMapId() {
    return this._mapId;
  }
  addControl(t, i) {
    if (i === void 0 && (t.getDefaultPosition ? i = t.getDefaultPosition() : i = "top-right"), !t || !t.onAdd) return this.fire(new H$2(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
    let n4 = t.onAdd(this);
    this._controls.push(t);
    let o4 = this._controlPositions[i];
    return i.indexOf("bottom") !== -1 ? o4.insertBefore(n4, o4.firstChild) : o4.appendChild(n4), this;
  }
  removeControl(t) {
    if (!t || !t.onRemove) return this.fire(new H$2(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
    let i = this._controls.indexOf(t);
    return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;
  }
  hasControl(t) {
    return this._controls.indexOf(t) > -1;
  }
  calculateCameraOptionsFromTo(t, i, n4, o4) {
    return o4 == null && this.terrain && (o4 = this.terrain.getElevationForLngLatZoom(n4, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t, i, n4, o4);
  }
  resize(t) {
    var u5;
    let i = this._containerDimensions(), n4 = i[0], o4 = i[1], a4 = this._getClampedPixelRatio(n4, o4);
    if (this._resizeCanvas(n4, o4, a4), this.painter.resize(n4, o4, a4), this.painter.overLimit()) {
      let c = this.painter.context.gl;
      this._maxCanvasSize = [c.drawingBufferWidth, c.drawingBufferHeight];
      let p4 = this._getClampedPixelRatio(n4, o4);
      this._resizeCanvas(n4, o4, p4), this.painter.resize(n4, o4, p4);
    }
    this.transform.resize(n4, o4), (u5 = this._requestedCameraState) == null || u5.resize(n4, o4);
    let s5 = !this._moving;
    return s5 && (this.stop(), this.fire(new F("movestart", t)).fire(new F("move", t))), this.fire(new F("resize", t)), s5 && this.fire(new F("moveend", t)), this;
  }
  _getClampedPixelRatio(t, i) {
    let { 0: n4, 1: o4 } = this._maxCanvasSize, a4 = this.getPixelRatio(), s5 = t * a4, u5 = i * a4, c = s5 > n4 ? n4 / s5 : 1, p4 = u5 > o4 ? o4 / u5 : 1;
    return Math.min(c, p4) * a4;
  }
  getPixelRatio() {
    var t;
    return (t = this._overridePixelRatio) != null ? t : devicePixelRatio;
  }
  setPixelRatio(t) {
    this._overridePixelRatio = t, this.resize();
  }
  getBounds() {
    return this.transform.getBounds();
  }
  getMaxBounds() {
    return this.transform.getMaxBounds();
  }
  setMaxBounds(t) {
    return this.transform.setMaxBounds(ut$1.convert(t)), this._update();
  }
  setMinZoom(t) {
    if (t = t == null ? hp : t, t >= hp && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this;
    throw new Error("minZoom must be between ".concat(hp, " and the current maxZoom, inclusive"));
  }
  getMinZoom() {
    return this.transform.minZoom;
  }
  setMaxZoom(t) {
    if (t = t == null ? s2$1 : t, t >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this;
    throw new Error("maxZoom must be greater than the current minZoom");
  }
  getMaxZoom() {
    return this.transform.maxZoom;
  }
  setMinPitch(t) {
    if (t = t == null ? Nr$1 : t, t < Nr$1) throw new Error("minPitch must be greater than or equal to ".concat(Nr$1));
    if (t >= Nr$1 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this;
    throw new Error("minPitch must be between ".concat(Nr$1, " and the current maxPitch, inclusive"));
  }
  getMinPitch() {
    return this.transform.minPitch;
  }
  setMaxPitch(t) {
    if (t = t == null ? l2$1 : t, t > pp) throw new Error("maxPitch must be less than or equal to ".concat(pp));
    if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this;
    throw new Error("maxPitch must be greater than the current minPitch");
  }
  getMaxPitch() {
    return this.transform.maxPitch;
  }
  getRenderWorldCopies() {
    return this.transform.renderWorldCopies;
  }
  setRenderWorldCopies(t) {
    return this.transform.renderWorldCopies = t, this._update();
  }
  project(t) {
    return this.transform.locationPoint(ie$1.convert(t), this.style && this.terrain);
  }
  unproject(t) {
    return this.transform.pointLocation(fr$1.default.convert(t), this.terrain);
  }
  isMoving() {
    var t;
    return this._moving || ((t = this.handlers) == null ? void 0 : t.isMoving());
  }
  isZooming() {
    var t;
    return this._zooming || ((t = this.handlers) == null ? void 0 : t.isZooming());
  }
  isRotating() {
    var t;
    return this._rotating || ((t = this.handlers) == null ? void 0 : t.isRotating());
  }
  _createDelegatedListener(t, i, n4) {
    if (t === "mouseenter" || t === "mouseover") {
      let o4 = false;
      return { layer: i, listener: n4, delegates: { mousemove: H$3((u5) => {
        let c = this.getLayer(i) ? this.queryRenderedFeatures(u5.point, { layers: [i] }) : [];
        c.length ? o4 || (o4 = true, n4.call(this, new nt$2(t, this, u5.originalEvent, { features: c }))) : o4 = false;
      }, "mousemove"), mouseout: H$3(() => {
        o4 = false;
      }, "mouseout") } };
    } else if (t === "mouseleave" || t === "mouseout") {
      let o4 = false;
      return { layer: i, listener: n4, delegates: { mousemove: H$3((u5) => {
        (this.getLayer(i) ? this.queryRenderedFeatures(u5.point, { layers: [i] }) : []).length ? o4 = true : o4 && (o4 = false, n4.call(this, new nt$2(t, this, u5.originalEvent)));
      }, "mousemove"), mouseout: H$3((u5) => {
        o4 && (o4 = false, n4.call(this, new nt$2(t, this, u5.originalEvent)));
      }, "mouseout") } };
    } else {
      let o4 = H$3((a4) => {
        let s5 = this.getLayer(i) ? this.queryRenderedFeatures(a4.point, { layers: [i] }) : [];
        s5.length && (a4.features = s5, n4.call(this, a4), delete a4.features);
      }, "delegate");
      return { layer: i, listener: n4, delegates: { [t]: o4 } };
    }
  }
  on(t, i, n4) {
    if (n4 === void 0) return super.on(t, i);
    let o4 = this._createDelegatedListener(t, i, n4);
    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(o4);
    for (let a4 in o4.delegates) this.on(a4, o4.delegates[a4]);
    return this;
  }
  once(t, i, n4) {
    if (n4 === void 0) return super.once(t, i);
    let o4 = this._createDelegatedListener(t, i, n4);
    for (let a4 in o4.delegates) this.once(a4, o4.delegates[a4]);
    return this;
  }
  off(t, i, n4) {
    if (n4 === void 0) return super.off(t, i);
    let o4 = H$3((a4) => {
      let s5 = a4[t];
      for (let u5 = 0; u5 < s5.length; u5++) {
        let c = s5[u5];
        if (c.layer === i && c.listener === n4) {
          for (let p4 in c.delegates) this.off(p4, c.delegates[p4]);
          return s5.splice(u5, 1), this;
        }
      }
    }, "removeDelegatedListener");
    return this._delegatedListeners && this._delegatedListeners[t] && o4(this._delegatedListeners), this;
  }
  queryRenderedFeatures(t, i) {
    if (!this.style) return [];
    let n4, o4 = t instanceof fr$1.default || Array.isArray(t), a4 = o4 ? t : [[0, 0], [this.transform.width, this.transform.height]];
    if (i = i || (o4 ? {} : t) || {}, a4 instanceof fr$1.default || typeof a4[0] == "number") n4 = [fr$1.default.convert(a4)];
    else {
      let s5 = fr$1.default.convert(a4[0]), u5 = fr$1.default.convert(a4[1]);
      n4 = [s5, new fr$1.default(u5.x, s5.y), u5, new fr$1.default(s5.x, u5.y), s5];
    }
    return this.style.queryRenderedFeatures(n4, i, this.transform);
  }
  querySourceFeatures(t, i) {
    return this.style.querySourceFeatures(t, i);
  }
  setStyle(t, i) {
    return i = V$1({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i), i.diff !== false && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(t, i));
  }
  setTransformRequest(t) {
    return this._requestManager.setTransformRequest(t), this;
  }
  _getUIString(t) {
    let i = this._locale[t];
    if (i == null) throw new Error("Missing UI string '".concat(t, "'"));
    return i;
  }
  _updateStyle(t, i) {
    if (i.transformStyle && this.style && !this.style._loaded) {
      this.style.once("style.load", () => this._updateStyle(t, i));
      return;
    }
    let n4 = this.style && i.transformStyle ? this.style.serialize() : void 0;
    if (this.style && (this.style.setEventedParent(null), this.style._remove(!t)), t) this.style = new Tn$1(this, i || {});
    else return delete this.style, this;
    return this.style.setEventedParent(this, { style: this.style }), typeof t == "string" ? this.style.loadURL(t, i, n4) : this.style.loadJSON(t, i, n4), this;
  }
  _lazyInitEmptyStyle() {
    this.style || (this.style = new Tn$1(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
  }
  _diffStyle(t, i) {
    if (typeof t == "string") {
      let n4 = t, o4 = this._requestManager.transformRequest(n4, "Style");
      gr$1(o4, new AbortController()).then((a4) => {
        this._updateDiff(a4.data, i);
      }).catch((a4) => {
        a4 && this.fire(new H$2(a4));
      });
    } else typeof t == "object" && this._updateDiff(t, i);
  }
  _updateDiff(t, i) {
    try {
      this.style.setState(t, i) && this._update(true);
    } catch (n4) {
      Le$1("Unable to perform style diff: ".concat(n4.message || n4.error || n4, ".  Rebuilding the style from scratch.")), this._updateStyle(t, i);
    }
  }
  getStyle() {
    if (this.style) return this.style.serialize();
  }
  isStyleLoaded() {
    return this.style ? this.style.loaded() : Le$1("There is no style added to the map.");
  }
  addSource(t, i) {
    return this._lazyInitEmptyStyle(), this.style.addSource(t, i), this._update(true);
  }
  isSourceLoaded(t) {
    let i = this.style && this.style.sourceCaches[t];
    if (i === void 0) {
      this.fire(new H$2(new Error("There is no source with ID '".concat(t, "'"))));
      return;
    }
    return i.loaded();
  }
  setTerrain(t) {
    if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), !t) this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
    else {
      let i = this.style.sourceCaches[t.source];
      if (!i) throw new Error("cannot load terrain, because there exists no source with ID: ".concat(t.source));
      this.terrain === null && i.reload();
      for (let n4 in this.style._layers) {
        let o4 = this.style._layers[n4];
        o4.type === "hillshade" && o4.source === t.source && Le$1("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
      }
      this.terrain = new lp(this.painter, i, t), this.painter.renderToTexture = new cp(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (n4) => {
        n4.dataType === "style" ? this.terrain.sourceCache.freeRtt() : n4.dataType === "source" && n4.tile && (n4.sourceId === t.source && !this._elevationFreeze && (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(n4.tile.tileID));
      }, this.style.on("data", this._terrainDataCallback);
    }
    return this.fire(new F("terrain", { terrain: t })), this;
  }
  getTerrain() {
    var t, i;
    return (i = (t = this.terrain) == null ? void 0 : t.options) != null ? i : null;
  }
  areTilesLoaded() {
    let t = this.style && this.style.sourceCaches;
    for (let i in t) {
      let o4 = t[i]._tiles;
      for (let a4 in o4) {
        let s5 = o4[a4];
        if (!(s5.state === "loaded" || s5.state === "errored")) return false;
      }
    }
    return true;
  }
  removeSource(t) {
    return this.style.removeSource(t), this._update(true);
  }
  getSource(t) {
    return this.style.getSource(t);
  }
  addImage(t, i, n4 = {}) {
    let { pixelRatio: o4 = 1, sdf: a4 = false, stretchX: s5, stretchY: u5, content: c } = n4;
    this._lazyInitEmptyStyle();
    let p4 = 0;
    if (i instanceof HTMLImageElement || ht$1(i)) {
      let { width: h, height: f, data: m5 } = Y$1.getImageData(i);
      this.style.addImage(t, { data: new Se$2({ width: h, height: f }, m5), pixelRatio: o4, stretchX: s5, stretchY: u5, content: c, sdf: a4, version: p4 });
    } else {
      if (i.width === void 0 || i.height === void 0) return this.fire(new H$2(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
      {
        let { width: h, height: f, data: m5 } = i, y4 = i;
        return this.style.addImage(t, { data: new Se$2({ width: h, height: f }, new Uint8Array(m5)), pixelRatio: o4, stretchX: s5, stretchY: u5, content: c, sdf: a4, version: p4, userImage: y4 }), y4.onAdd && y4.onAdd(this, t), this;
      }
    }
  }
  updateImage(t, i) {
    let n4 = this.style.getImage(t);
    if (!n4) return this.fire(new H$2(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
    let o4 = i instanceof HTMLImageElement || ht$1(i) ? Y$1.getImageData(i) : i, { width: a4, height: s5, data: u5 } = o4;
    if (a4 === void 0 || s5 === void 0) return this.fire(new H$2(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
    if (a4 !== n4.data.width || s5 !== n4.data.height) return this.fire(new H$2(new Error("The width and height of the updated image must be that same as the previous version of the image")));
    let c = !(i instanceof HTMLImageElement || ht$1(i));
    return n4.data.replace(u5, c), this.style.updateImage(t, n4), this;
  }
  getImage(t) {
    return this.style.getImage(t);
  }
  hasImage(t) {
    return t ? !!this.style.getImage(t) : (this.fire(new H$2(new Error("Missing required image id"))), false);
  }
  removeImage(t) {
    this.style.removeImage(t);
  }
  loadImage(t) {
    return st$1.getImage(this._requestManager.transformRequest(t, "Image"), new AbortController());
  }
  listImages() {
    return this.style.listImages();
  }
  addLayer(t, i) {
    return this._lazyInitEmptyStyle(), this.style.addLayer(t, i), this._update(true);
  }
  moveLayer(t, i) {
    return this.style.moveLayer(t, i), this._update(true);
  }
  removeLayer(t) {
    return this.style.removeLayer(t), this._update(true);
  }
  getLayer(t) {
    return this.style.getLayer(t);
  }
  getLayersOrder() {
    return this.style.getLayersOrder();
  }
  setLayerZoomRange(t, i, n4) {
    return this.style.setLayerZoomRange(t, i, n4), this._update(true);
  }
  setFilter(t, i, n4 = {}) {
    return this.style.setFilter(t, i, n4), this._update(true);
  }
  getFilter(t) {
    return this.style.getFilter(t);
  }
  setPaintProperty(t, i, n4, o4 = {}) {
    return this.style.setPaintProperty(t, i, n4, o4), this._update(true);
  }
  getPaintProperty(t, i) {
    return this.style.getPaintProperty(t, i);
  }
  setLayoutProperty(t, i, n4, o4 = {}) {
    return this.style.setLayoutProperty(t, i, n4, o4), this._update(true);
  }
  getLayoutProperty(t, i) {
    return this.style.getLayoutProperty(t, i);
  }
  setGlyphs(t, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setGlyphs(t, i), this._update(true);
  }
  getGlyphs() {
    return this.style.getGlyphsUrl();
  }
  addSprite(t, i, n4 = {}) {
    return this._lazyInitEmptyStyle(), this.style.addSprite(t, i, n4, (o4) => {
      o4 || this._update(true);
    }), this;
  }
  removeSprite(t) {
    return this._lazyInitEmptyStyle(), this.style.removeSprite(t), this._update(true);
  }
  getSprite() {
    return this.style.getSprite();
  }
  setSprite(t, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setSprite(t, i, (n4) => {
      n4 || this._update(true);
    }), this;
  }
  setLight(t, i = {}) {
    return this._lazyInitEmptyStyle(), this.style.setLight(t, i), this._update(true);
  }
  getLight() {
    return this.style.getLight();
  }
  setFeatureState(t, i) {
    return this.style.setFeatureState(t, i), this._update();
  }
  removeFeatureState(t, i) {
    return this.style.removeFeatureState(t, i), this._update();
  }
  getFeatureState(t) {
    return this.style.getFeatureState(t);
  }
  getContainer() {
    return this._container;
  }
  getCanvasContainer() {
    return this._canvasContainer;
  }
  getCanvas() {
    return this._canvas;
  }
  _containerDimensions() {
    let t = 0, i = 0;
    return this._container && (t = this._container.clientWidth || 400, i = this._container.clientHeight || 300), [t, i];
  }
  _setupContainer() {
    let t = this._container;
    t.classList.add("maplibregl-map");
    let i = this._canvasContainer = D$1.create("div", "maplibregl-canvas-container", t);
    this._interactive && i.classList.add("maplibregl-interactive"), this._canvas = D$1.create("canvas", "maplibregl-canvas", i), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
    let n4 = this._containerDimensions(), o4 = this._getClampedPixelRatio(n4[0], n4[1]);
    this._resizeCanvas(n4[0], n4[1], o4);
    let a4 = this._controlContainer = D$1.create("div", "maplibregl-control-container", t), s5 = this._controlPositions = {};
    ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((u5) => {
      s5[u5] = D$1.create("div", "maplibregl-ctrl-".concat(u5, " "), a4);
    });
  }
  _resizeCanvas(t, i, n4) {
    this._canvas.width = Math.floor(n4 * t), this._canvas.height = Math.floor(n4 * i), this._canvas.style.width = "".concat(t, "px"), this._canvas.style.height = "".concat(i, "px");
  }
  _setupPainter() {
    let t = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }, i = null;
    this._canvas.addEventListener("webglcontextcreationerror", (o4) => {
      i = { requestedAttributes: t }, o4 && (i.statusMessage = o4.statusMessage, i.type = o4.type);
    }, { once: true });
    let n4 = this._canvas.getContext("webgl2", t) || this._canvas.getContext("webgl", t);
    if (!n4) {
      let o4 = "Failed to initialize WebGL";
      throw i ? (i.message = o4, new Error(JSON.stringify(i))) : new Error(o4);
    }
    this.painter = new kc$1(n4, this.transform), Fn.testSupport(n4);
  }
  loaded() {
    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
  }
  _update(t) {
    return !this.style || !this.style._loaded ? this : (this._styleDirty = this._styleDirty || t, this._sourcesDirty = true, this.triggerRepaint(), this);
  }
  _requestRenderFrame(t) {
    return this._update(), this._renderTaskQueue.add(t);
  }
  _cancelRenderFrame(t) {
    this._renderTaskQueue.remove(t);
  }
  _render(t) {
    let i = this._idleTriggered ? this._fadeDuration : 0;
    if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t), this._removed) return;
    let n4 = false;
    if (this.style && this._styleDirty) {
      this._styleDirty = false;
      let a4 = this.transform.zoom, s5 = Y$1.now();
      this.style.zoomHistory.update(a4, s5);
      let u5 = new ye(a4, { now: s5, fadeDuration: i, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), c = u5.crossFadingFactor();
      (c !== 1 || c !== this._crossFadingFactor) && (n4 = true, this._crossFadingFactor = c), this.style.update(u5);
    }
    this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain && (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i, showPadding: this.showPadding }), this.fire(new F("render")), this.loaded() && !this._loaded && (this._loaded = true, In$1.mark("load"), this.fire(new F("load"))), this.style && (this.style.hasTransitions() || n4) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
    let o4 = this._sourcesDirty || this._styleDirty || this._placementDirty;
    return o4 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new F("idle")), this._loaded && !this._fullyLoaded && !o4 && (this._fullyLoaded = true, In$1.mark("fullLoad")), this;
  }
  redraw() {
    return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
  }
  remove() {
    var i;
    this._hash && this._hash.remove();
    for (let n4 of this._controls) n4.onRemove(this);
    this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), st$1.removeThrottleControl(this._imageQueueHandle), (i = this._resizeObserver) == null || i.disconnect();
    let t = this.painter.context.gl.getExtension("WEBGL_lose_context");
    t && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), D$1.remove(this._canvasContainer), D$1.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), In$1.clearMetrics(), this._removed = true, this.fire(new F("remove"));
  }
  triggerRepaint() {
    this.style && !this._frameRequest && (this._frameRequest = new AbortController(), Y$1.frameAsync(this._frameRequest).then((t) => {
      In$1.frame(t), this._frameRequest = null, this._render(t);
    }).catch(() => {
    }));
  }
  get showTileBoundaries() {
    return !!this._showTileBoundaries;
  }
  set showTileBoundaries(t) {
    this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update());
  }
  get showPadding() {
    return !!this._showPadding;
  }
  set showPadding(t) {
    this._showPadding !== t && (this._showPadding = t, this._update());
  }
  get showCollisionBoxes() {
    return !!this._showCollisionBoxes;
  }
  set showCollisionBoxes(t) {
    this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update());
  }
  get showOverdrawInspector() {
    return !!this._showOverdrawInspector;
  }
  set showOverdrawInspector(t) {
    this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update());
  }
  get repaint() {
    return !!this._repaint;
  }
  set repaint(t) {
    this._repaint !== t && (this._repaint = t, this.triggerRepaint());
  }
  get vertices() {
    return !!this._vertices;
  }
  set vertices(t) {
    this._vertices = t, this._update();
  }
  get version() {
    return yD$1;
  }
  getCameraTargetElevation() {
    return this.transform.elevation;
  }
};
H$3(wx$1, "Map");
var vx$1 = wx$1;
a();
a();
var u2$1 = H$3((r5) => {
  r5.touchstart = r5.dragStart, r5.touchmoveWindow = r5.dragMove, r5.touchend = r5.dragEnd;
}, "assignEvents"), c2$1 = H$3(({ enable: r5, clickTolerance: e, bearingDegreesPerPixelMoved: t = 0.8 }) => {
  let i = new Fa();
  return new hr({ clickTolerance: e, move: H$3((n4, o4) => ({ bearingDelta: (o4.x - n4.x) * t }), "move"), moveStateManager: i, enable: r5, assignEvents: u2$1 });
}, "generateOneFingerTouchRotationHandler"), p2$1 = H$3(({ enable: r5, clickTolerance: e, pitchDegreesPerPixelMoved: t = -0.5 }) => {
  let i = new Fa();
  return new hr({ clickTolerance: e, move: H$3((n4, o4) => ({ pitchDelta: (o4.y - n4.y) * t }), "move"), moveStateManager: i, enable: r5, assignEvents: u2$1 });
}, "generateOneFingerTouchPitchHandler");
var xD$1 = { showCompass: true, showZoom: true, visualizePitch: false }, Tx$1 = class Tx {
  constructor(e) {
    this._updateZoomButtons = H$3(() => {
      let e4 = this._map.getZoom(), t = e4 === this._map.getMaxZoom(), i = e4 === this._map.getMinZoom();
      this._zoomInButton.disabled = t, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", t.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString());
    }, "_updateZoomButtons");
    this._rotateCompassArrow = H$3(() => {
      let e4 = this.options.visualizePitch ? "scale(".concat(1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5), ") rotateX(").concat(this._map.transform.pitch, "deg) rotateZ(").concat(this._map.transform.angle * (180 / Math.PI), "deg)") : "rotate(".concat(this._map.transform.angle * (180 / Math.PI), "deg)");
      this._compassIcon.style.transform = e4;
    }, "_rotateCompassArrow");
    this._setButtonTitle = H$3((e4, t) => {
      let i = this._map._getUIString("NavigationControl.".concat(t));
      e4.title = i, e4.setAttribute("aria-label", i);
    }, "_setButtonTitle");
    this.options = V$1({}, xD$1, e), this._container = D$1.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t) => this._map.zoomIn({}, { originalEvent: t })), D$1.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t) => this._map.zoomOut({}, { originalEvent: t })), D$1.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t) => {
      this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
    }), this._compassIcon = D$1.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
  }
  onAdd(e) {
    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Px$1(this._map, this._compass, this.options.visualizePitch)), this._container;
  }
  onRemove() {
    D$1.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
  }
  _createButton(e, t) {
    let i = D$1.create("button", e, this._container);
    return i.type = "button", i.addEventListener("click", t), i;
  }
};
H$3(Tx$1, "NavigationControl");
var Mx$1 = class Mx {
  constructor(e, t, i = false) {
    this.mousedown = H$3((e4) => {
      this.startMouse(V$1({}, e4, { ctrlKey: true, preventDefault: H$3(() => e4.preventDefault(), "preventDefault") }), D$1.mousePos(this.element, e4)), D$1.addEventListener(window, "mousemove", this.mousemove), D$1.addEventListener(window, "mouseup", this.mouseup);
    }, "mousedown");
    this.mousemove = H$3((e4) => {
      this.moveMouse(e4, D$1.mousePos(this.element, e4));
    }, "mousemove");
    this.mouseup = H$3((e4) => {
      this.mouseRotate.dragEnd(e4), this.mousePitch && this.mousePitch.dragEnd(e4), this.offTemp();
    }, "mouseup");
    this.touchstart = H$3((e4) => {
      e4.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = D$1.touchPos(this.element, e4.targetTouches)[0], this.startTouch(e4, this._startPos), D$1.addEventListener(window, "touchmove", this.touchmove, { passive: false }), D$1.addEventListener(window, "touchend", this.touchend));
    }, "touchstart");
    this.touchmove = H$3((e4) => {
      e4.targetTouches.length !== 1 ? this.reset() : (this._lastPos = D$1.touchPos(this.element, e4.targetTouches)[0], this.moveTouch(e4, this._lastPos));
    }, "touchmove");
    this.touchend = H$3((e4) => {
      e4.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
    }, "touchend");
    this.reset = H$3(() => {
      this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
    }, "reset");
    this._clickTolerance = 10;
    let n4 = e.dragRotate._mouseRotate.getClickTolerance(), o4 = e.dragRotate._mousePitch.getClickTolerance();
    this.element = t, this.mouseRotate = Wc$1({ clickTolerance: n4, enable: true }), this.touchRotate = c2$1({ clickTolerance: n4, enable: true }), this.map = e, i && (this.mousePitch = Xc$1({ clickTolerance: o4, enable: true }), this.touchPitch = p2$1({ clickTolerance: o4, enable: true })), D$1.addEventListener(t, "mousedown", this.mousedown), D$1.addEventListener(t, "touchstart", this.touchstart, { passive: false }), D$1.addEventListener(t, "touchcancel", this.reset);
  }
  startMouse(e, t) {
    this.mouseRotate.dragStart(e, t), this.mousePitch && this.mousePitch.dragStart(e, t), D$1.disableDrag();
  }
  startTouch(e, t) {
    this.touchRotate.dragStart(e, t), this.touchPitch && this.touchPitch.dragStart(e, t), D$1.disableDrag();
  }
  moveMouse(e, t) {
    let i = this.map, { bearingDelta: n4 } = this.mouseRotate.dragMove(e, t) || {};
    if (n4 && i.setBearing(i.getBearing() + n4), this.mousePitch) {
      let { pitchDelta: o4 } = this.mousePitch.dragMove(e, t) || {};
      o4 && i.setPitch(i.getPitch() + o4);
    }
  }
  moveTouch(e, t) {
    let i = this.map, { bearingDelta: n4 } = this.touchRotate.dragMove(e, t) || {};
    if (n4 && i.setBearing(i.getBearing() + n4), this.touchPitch) {
      let { pitchDelta: o4 } = this.touchPitch.dragMove(e, t) || {};
      o4 && i.setPitch(i.getPitch() + o4);
    }
  }
  off() {
    let e = this.element;
    D$1.removeEventListener(e, "mousedown", this.mousedown), D$1.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), D$1.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), D$1.removeEventListener(window, "touchend", this.touchend), D$1.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
  }
  offTemp() {
    D$1.enableDrag(), D$1.removeEventListener(window, "mousemove", this.mousemove), D$1.removeEventListener(window, "mouseup", this.mouseup), D$1.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), D$1.removeEventListener(window, "touchend", this.touchend);
  }
};
H$3(Mx$1, "MouseRotateWrapper");
var Px$1 = Mx$1;
a();
a();
var Ai$1;
async function h2$1(r5 = false) {
  if (Ai$1 !== void 0 && !r5) return Ai$1;
  if (window.navigator.permissions === void 0) return Ai$1 = !!window.navigator.geolocation, Ai$1;
  try {
    Ai$1 = (await window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
  } catch (e) {
    Ai$1 = !!window.navigator.geolocation;
  }
  return Ai$1;
}
H$3(h2$1, "checkGeolocationSupport");
a();
var Ja = N$2(ge(), 1);
a();
function fp(r5, e, t) {
  let i = new ie$1(r5.lng, r5.lat);
  if (r5 = new ie$1(r5.lng, r5.lat), e) {
    let n4 = new ie$1(r5.lng - 360, r5.lat), o4 = new ie$1(r5.lng + 360, r5.lat), a4 = t.locationPoint(r5).distSqr(e);
    t.locationPoint(n4).distSqr(e) < a4 ? r5 = n4 : t.locationPoint(o4).distSqr(e) < a4 && (r5 = o4);
  }
  for (; Math.abs(r5.lng - t.center.lng) > 180; ) {
    let n4 = t.locationPoint(r5);
    if (n4.x >= 0 && n4.y >= 0 && n4.x <= t.width && n4.y <= t.height) break;
    r5.lng > t.center.lng ? r5.lng -= 360 : r5.lng += 360;
  }
  return r5.lng !== i.lng && t.locationPoint(r5).y > t.height / 2 - t.getHorizon() ? r5 : i;
}
H$3(fp, "smartWrap");
a();
var Ka$1 = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
function mp(r5, e, t) {
  let i = r5.classList;
  for (let n4 in Ka$1) i.remove("maplibregl-".concat(t, "-anchor-").concat(n4));
  i.add("maplibregl-".concat(t, "-anchor-").concat(e));
}
H$3(mp, "applyAnchorClass");
var Ax$1 = class Ax extends de$1 {
  constructor(t) {
    super();
    this._onKeyPress = H$3((t5) => {
      let i = t5.code, n4 = t5.charCode || t5.keyCode;
      (i === "Space" || i === "Enter" || n4 === 32 || n4 === 13) && this.togglePopup();
    }, "_onKeyPress");
    this._onMapClick = H$3((t5) => {
      let i = t5.originalEvent.target, n4 = this._element;
      this._popup && (i === n4 || n4.contains(i)) && this.togglePopup();
    }, "_onMapClick");
    this._update = H$3((t5) => {
      var a4;
      if (!this._map) return;
      let i = this._map.loaded() && !this._map.isMoving();
      ((t5 == null ? void 0 : t5.type) === "terrain" || (t5 == null ? void 0 : t5.type) === "render" && !i) && this._map.once("render", this._update), this._map.transform.renderWorldCopies ? this._lngLat = fp(this._lngLat, this._flatPos, this._map.transform) : this._lngLat = (a4 = this._lngLat) == null ? void 0 : a4.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
      let n4 = "";
      this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? n4 = "rotateZ(".concat(this._rotation, "deg)") : this._rotationAlignment === "map" && (n4 = "rotateZ(".concat(this._rotation - this._map.getBearing(), "deg)"));
      let o4 = "";
      this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? o4 = "rotateX(0deg)" : this._pitchAlignment === "map" && (o4 = "rotateX(".concat(this._map.getPitch(), "deg)")), (!t5 || t5.type === "moveend") && (this._pos = this._pos.round()), D$1.setTransform(this._element, "".concat(Ka$1[this._anchor], " translate(").concat(this._pos.x, "px, ").concat(this._pos.y, "px) ").concat(o4, " ").concat(n4)), Y$1.frameAsync(new AbortController()).then(() => {
        this._updateOpacity(t5 && t5.type === "moveend");
      }).catch(() => {
      });
    }, "_update");
    this._onMove = H$3((t5) => {
      if (!this._isDragging) {
        let i = this._clickTolerance || this._map._clickTolerance;
        this._isDragging = t5.point.dist(this._pointerdownPos) >= i;
      }
      this._isDragging && (this._pos = t5.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new F("dragstart"))), this.fire(new F("drag")));
    }, "_onMove");
    this._onUp = H$3(() => {
      this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new F("dragend")), this._state = "inactive";
    }, "_onUp");
    this._addDragHandler = H$3((t5) => {
      this._element.contains(t5.originalEvent.target) && (t5.preventDefault(), this._positionDelta = t5.point.sub(this._pos).add(this._offset), this._pointerdownPos = t5.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
    }, "_addDragHandler");
    if (this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || false, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t == null ? void 0 : t.opacity, t == null ? void 0 : t.opacityWhenCovered), !t || !t.element) {
      this._defaultMarker = true, this._element = D$1.create("div"), this._element.setAttribute("aria-label", "Map marker");
      let i = D$1.createNS("http://www.w3.org/2000/svg", "svg"), n4 = 41, o4 = 27;
      i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", "".concat(n4, "px")), i.setAttributeNS(null, "width", "".concat(o4, "px")), i.setAttributeNS(null, "viewBox", "0 0 ".concat(o4, " ").concat(n4));
      let a4 = D$1.createNS("http://www.w3.org/2000/svg", "g");
      a4.setAttributeNS(null, "stroke", "none"), a4.setAttributeNS(null, "stroke-width", "1"), a4.setAttributeNS(null, "fill", "none"), a4.setAttributeNS(null, "fill-rule", "evenodd");
      let s5 = D$1.createNS("http://www.w3.org/2000/svg", "g");
      s5.setAttributeNS(null, "fill-rule", "nonzero");
      let u5 = D$1.createNS("http://www.w3.org/2000/svg", "g");
      u5.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), u5.setAttributeNS(null, "fill", "#000000");
      let c = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
      for (let w3 of c) {
        let _ = D$1.createNS("http://www.w3.org/2000/svg", "ellipse");
        _.setAttributeNS(null, "opacity", "0.04"), _.setAttributeNS(null, "cx", "10.5"), _.setAttributeNS(null, "cy", "5.80029008"), _.setAttributeNS(null, "rx", w3.rx), _.setAttributeNS(null, "ry", w3.ry), u5.appendChild(_);
      }
      let p4 = D$1.createNS("http://www.w3.org/2000/svg", "g");
      p4.setAttributeNS(null, "fill", this._color);
      let h = D$1.createNS("http://www.w3.org/2000/svg", "path");
      h.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), p4.appendChild(h);
      let f = D$1.createNS("http://www.w3.org/2000/svg", "g");
      f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "fill", "#000000");
      let m5 = D$1.createNS("http://www.w3.org/2000/svg", "path");
      m5.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f.appendChild(m5);
      let y4 = D$1.createNS("http://www.w3.org/2000/svg", "g");
      y4.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), y4.setAttributeNS(null, "fill", "#FFFFFF");
      let g = D$1.createNS("http://www.w3.org/2000/svg", "g");
      g.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
      let x2 = D$1.createNS("http://www.w3.org/2000/svg", "circle");
      x2.setAttributeNS(null, "fill", "#000000"), x2.setAttributeNS(null, "opacity", "0.25"), x2.setAttributeNS(null, "cx", "5.5"), x2.setAttributeNS(null, "cy", "5.5"), x2.setAttributeNS(null, "r", "5.4999962");
      let b = D$1.createNS("http://www.w3.org/2000/svg", "circle");
      b.setAttributeNS(null, "fill", "#FFFFFF"), b.setAttributeNS(null, "cx", "5.5"), b.setAttributeNS(null, "cy", "5.5"), b.setAttributeNS(null, "r", "5.4999962"), g.appendChild(x2), g.appendChild(b), s5.appendChild(u5), s5.appendChild(p4), s5.appendChild(f), s5.appendChild(y4), s5.appendChild(g), i.appendChild(s5), i.setAttributeNS(null, "height", "".concat(n4 * this._scale, "px")), i.setAttributeNS(null, "width", "".concat(o4 * this._scale, "px")), this._element.appendChild(i), this._offset = Ja.default.convert(t && t.offset || [0, -14]);
    } else this._element = t.element, this._offset = Ja.default.convert(t && t.offset || [0, 0]);
    if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i) => {
      i.preventDefault();
    }), this._element.addEventListener("mousedown", (i) => {
      i.preventDefault();
    }), mp(this._element, this._anchor, "marker"), t && t.className) for (let i of t.className.split(" ")) this._element.classList.add(i);
    this._popup = null;
  }
  addTo(t) {
    return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
  }
  remove() {
    return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), D$1.remove(this._element), this._popup && this._popup.remove(), this;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(t) {
    return this._lngLat = ie$1.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
  }
  getElement() {
    return this._element;
  }
  setPopup(t) {
    if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
      if (!("offset" in t.options)) {
        let o4 = Math.abs(13.5) / Math.SQRT2;
        t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [o4, (38.1 - 13.5 + o4) * -1], "bottom-right": [-o4, (38.1 - 13.5 + o4) * -1], left: [13.5, (38.1 - 13.5) * -1], right: [-13.5, (38.1 - 13.5) * -1] } : this._offset;
      }
      this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
    }
    return this;
  }
  getPopup() {
    return this._popup;
  }
  togglePopup() {
    let t = this._popup;
    if (this._element.style.opacity === this._opacityWhenCovered) return this;
    if (t) t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map));
    else return this;
    return this;
  }
  _updateOpacity(t = false) {
    var y4, g;
    if (!((y4 = this._map) == null ? void 0 : y4.terrain)) {
      this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity);
      return;
    }
    if (t) this._opacityTimeout = null;
    else {
      if (this._opacityTimeout) return;
      this._opacityTimeout = setTimeout(() => {
        this._opacityTimeout = null;
      }, 100);
    }
    let n4 = this._map, o4 = n4.terrain.depthAtPoint(this._pos), a4 = n4.terrain.getElevationForLngLatZoom(this._lngLat, n4.transform.tileZoom), s5 = n4.transform.lngLatToCameraDepth(this._lngLat, a4), u5 = 6e-3;
    if (s5 - o4 < u5) {
      this._element.style.opacity = this._opacity;
      return;
    }
    let c = -this._offset.y / n4.transform._pixelPerMeter, p4 = Math.sin(n4.getPitch() * Math.PI / 180) * c, h = n4.terrain.depthAtPoint(new Ja.default(this._pos.x, this._pos.y - this._offset.y)), m5 = n4.transform.lngLatToCameraDepth(this._lngLat, a4 + p4) - h > u5;
    (g = this._popup) != null && g.isOpen() && m5 && this._popup.remove(), this._element.style.opacity = m5 ? this._opacityWhenCovered : this._opacity;
  }
  getOffset() {
    return this._offset;
  }
  setOffset(t) {
    return this._offset = Ja.default.convert(t), this._update(), this;
  }
  addClassName(t) {
    this._element.classList.add(t);
  }
  removeClassName(t) {
    this._element.classList.remove(t);
  }
  toggleClassName(t) {
    return this._element.classList.toggle(t);
  }
  setDraggable(t) {
    return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
  }
  isDraggable() {
    return this._draggable;
  }
  setRotation(t) {
    return this._rotation = t || 0, this._update(), this;
  }
  getRotation() {
    return this._rotation;
  }
  setRotationAlignment(t) {
    return this._rotationAlignment = t || "auto", this._update(), this;
  }
  getRotationAlignment() {
    return this._rotationAlignment;
  }
  setPitchAlignment(t) {
    return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
  }
  getPitchAlignment() {
    return this._pitchAlignment;
  }
  setOpacity(t, i) {
    return t === void 0 && i === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(true), this;
  }
};
H$3(Ax$1, "Marker");
var En = Ax$1;
var bD$1 = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true }, dp = 0, Ya = false, Cx$1 = class Cx extends de$1 {
  constructor(t) {
    super();
    this._onSuccess = H$3((t5) => {
      if (this._map) {
        if (this._isOutOfMapMaxBounds(t5)) {
          this._setErrorState(), this.fire(new F("outofmaxbounds", t5)), this._updateMarker(), this._finish();
          return;
        }
        if (this.options.trackUserLocation) switch (this._lastKnownPosition = t5, this._watchState) {
          case "WAITING_ACTIVE":
          case "ACTIVE_LOCK":
          case "ACTIVE_ERROR":
            this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
            break;
          case "BACKGROUND":
          case "BACKGROUND_ERROR":
            this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
            break;
          default:
            throw new Error("Unexpected watchState ".concat(this._watchState));
        }
        this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t5), (!this.options.trackUserLocation || this._watchState === "ACTIVE_LOCK") && this._updateCamera(t5), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new F("geolocate", t5)), this._finish();
      }
    }, "_onSuccess");
    this._updateCamera = H$3((t5) => {
      let i = new ie$1(t5.coords.longitude, t5.coords.latitude), n4 = t5.coords.accuracy, o4 = this._map.getBearing(), a4 = V$1({ bearing: o4 }, this.options.fitBoundsOptions), s5 = ut$1.fromLngLat(i, n4);
      this._map.fitBounds(s5, a4, { geolocateSource: true });
    }, "_updateCamera");
    this._updateMarker = H$3((t5) => {
      if (t5) {
        let i = new ie$1(t5.coords.longitude, t5.coords.latitude);
        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t5.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
      } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
    }, "_updateMarker");
    this._onZoom = H$3(() => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    }, "_onZoom");
    this._onError = H$3((t5) => {
      if (this._map) {
        if (this.options.trackUserLocation) if (t5.code === 1) {
          this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
          let i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch();
        } else {
          if (t5.code === 3 && Ya) return;
          this._setErrorState();
        }
        this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new F("error", t5)), this._finish();
      }
    }, "_onError");
    this._finish = H$3(() => {
      this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
    }, "_finish");
    this._setupUI = H$3((t5) => {
      if (this._map) {
        if (this._container.addEventListener("contextmenu", (i) => i.preventDefault()), this._geolocateButton = D$1.create("button", "maplibregl-ctrl-geolocate", this._container), D$1.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", t5 === false) {
          Le$1("Geolocation support is not available so the GeolocateControl will be disabled.");
          let i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.disabled = true, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
        } else {
          let i = this._map._getUIString("GeolocateControl.FindMyLocation");
          this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
        }
        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = D$1.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new En({ element: this._dotElement }), this._circleElement = D$1.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new En({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (i) => {
          let n4 = i.originalEvent && i.originalEvent.type === "resize";
          !i.geolocateSource && this._watchState === "ACTIVE_LOCK" && !n4 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new F("trackuserlocationend")));
        });
      }
    }, "_setupUI");
    this.options = V$1({}, bD$1, t);
  }
  onAdd(t) {
    return this._map = t, this._container = D$1.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), h2$1().then((i) => this._setupUI(i)), this._container;
  }
  onRemove() {
    this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), D$1.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, dp = 0, Ya = false;
  }
  _isOutOfMapMaxBounds(t) {
    let i = this._map.getMaxBounds(), n4 = t.coords;
    return i && (n4.longitude < i.getWest() || n4.longitude > i.getEast() || n4.latitude < i.getSouth() || n4.latitude > i.getNorth());
  }
  _setErrorState() {
    switch (this._watchState) {
      case "WAITING_ACTIVE":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
        break;
      case "ACTIVE_LOCK":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "BACKGROUND":
        this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "ACTIVE_ERROR":
        break;
      default:
        throw new Error("Unexpected watchState ".concat(this._watchState));
    }
  }
  _updateCircleRadius() {
    let t = this._map.getBounds(), i = t.getSouthEast(), n4 = t.getNorthEast(), o4 = i.distanceTo(n4), a4 = this._map._container.clientHeight, s5 = Math.ceil(2 * (this._accuracy / (o4 / a4)));
    this._circleElement.style.width = "".concat(s5, "px"), this._circleElement.style.height = "".concat(s5, "px");
  }
  trigger() {
    if (!this._setup) return Le$1("Geolocate control triggered before added to a map"), false;
    if (this.options.trackUserLocation) {
      switch (this._watchState) {
        case "OFF":
          this._watchState = "WAITING_ACTIVE", this.fire(new F("trackuserlocationstart"));
          break;
        case "WAITING_ACTIVE":
        case "ACTIVE_LOCK":
        case "ACTIVE_ERROR":
        case "BACKGROUND_ERROR":
          dp--, Ya = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new F("trackuserlocationend"));
          break;
        case "BACKGROUND":
          this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new F("trackuserlocationstart"));
          break;
        default:
          throw new Error("Unexpected watchState ".concat(this._watchState));
      }
      switch (this._watchState) {
        case "WAITING_ACTIVE":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "ACTIVE_LOCK":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "OFF":
          break;
        default:
          throw new Error("Unexpected watchState ".concat(this._watchState));
      }
      if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
      else if (this._geolocationWatchID === void 0) {
        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), dp++;
        let t;
        dp > 1 ? (t = { maximumAge: 6e5, timeout: 0 }, Ya = true) : (t = this.options.positionOptions, Ya = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t);
      }
    } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
    return true;
  }
  _clearWatch() {
    window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
  }
};
H$3(Cx$1, "GeolocateControl");
a();
var _D$1 = { maxWidth: 100, unit: "metric" }, kx$1 = class kx {
  constructor(e) {
    this._onMove = H$3(() => {
      f2$1(this._map, this._container, this.options);
    }, "_onMove");
    this.setUnit = H$3((e4) => {
      this.options.unit = e4, f2$1(this._map, this._container, this.options);
    }, "setUnit");
    this.options = F$1(F$1({}, _D$1), e);
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e) {
    return this._map = e, this._container = D$1.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
  }
  onRemove() {
    D$1.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
  }
};
H$3(kx$1, "ScaleControl");
function f2$1(r5, e, t) {
  let i = t && t.maxWidth || 100, n4 = r5._container.clientHeight / 2, o4 = r5.unproject([0, n4]), a4 = r5.unproject([i, n4]), s5 = o4.distanceTo(a4);
  if (t && t.unit === "imperial") {
    let u5 = 3.2808 * s5;
    if (u5 > 5280) {
      let c = u5 / 5280;
      Qa$1(e, i, c, r5._getUIString("ScaleControl.Miles"));
    } else Qa$1(e, i, u5, r5._getUIString("ScaleControl.Feet"));
  } else if (t && t.unit === "nautical") {
    let u5 = s5 / 1852;
    Qa$1(e, i, u5, r5._getUIString("ScaleControl.NauticalMiles"));
  } else s5 >= 1e3 ? Qa$1(e, i, s5 / 1e3, r5._getUIString("ScaleControl.Kilometers")) : Qa$1(e, i, s5, r5._getUIString("ScaleControl.Meters"));
}
H$3(f2$1, "updateScale");
function Qa$1(r5, e, t, i) {
  let n4 = wD$1(t), o4 = n4 / t;
  r5.style.width = "".concat(e * o4, "px"), r5.innerHTML = "".concat(n4, "&nbsp;").concat(i);
}
H$3(Qa$1, "setScale");
function vD$1(r5) {
  let e = Math.pow(10, Math.ceil(-Math.log(r5) / Math.LN10));
  return Math.round(r5 * e) / e;
}
H$3(vD$1, "getDecimalRoundNum");
function wD$1(r5) {
  let e = Math.pow(10, "".concat(Math.floor(r5)).length - 1), t = r5 / e;
  return t = t >= 10 ? 10 : t >= 5 ? 5 : t >= 3 ? 3 : t >= 2 ? 2 : t >= 1 ? 1 : vD$1(t), e * t;
}
H$3(wD$1, "getRoundNum");
a();
var Dx$1 = class Dx extends de$1 {
  constructor(t = {}) {
    super();
    this._onFullscreenChange = H$3(() => {
      var i;
      let t5 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
      for (; (i = t5 == null ? void 0 : t5.shadowRoot) != null && i.fullscreenElement; ) t5 = t5.shadowRoot.fullscreenElement;
      t5 === this._container !== this._fullscreen && this._handleFullscreenChange();
    }, "_onFullscreenChange");
    this._onClickFullscreen = H$3(() => {
      this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
    }, "_onClickFullscreen");
    this._fullscreen = false, t && t.container && (t.container instanceof HTMLElement ? this._container = t.container : Le$1("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
  }
  onAdd(t) {
    return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = D$1.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
  }
  onRemove() {
    D$1.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _setupUI() {
    let t = this._fullscreenButton = D$1.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
    D$1.create("span", "maplibregl-ctrl-icon", t).setAttribute("aria-hidden", "true"), t.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _updateTitle() {
    let t = this._getTitle();
    this._fullscreenButton.setAttribute("aria-label", t), this._fullscreenButton.title = t;
  }
  _getTitle() {
    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
  }
  _isFullscreen() {
    return this._fullscreen;
  }
  _handleFullscreenChange() {
    this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new F("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new F("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
  }
  _exitFullscreen() {
    window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
  }
  _requestFullscreen() {
    this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
  }
  _togglePseudoFullScreen() {
    this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
  }
};
H$3(Dx$1, "FullscreenControl");
a();
var Fx$1 = class Fx {
  constructor(e) {
    this._toggleTerrain = H$3(() => {
      this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
    }, "_toggleTerrain");
    this._updateTerrainIcon = H$3(() => {
      this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
    }, "_updateTerrainIcon");
    this.options = e;
  }
  onAdd(e) {
    return this._map = e, this._container = D$1.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = D$1.create("button", "maplibregl-ctrl-terrain", this._container), D$1.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    D$1.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
};
H$3(Fx$1, "TerrainControl");
a();
var je$1 = N$2(ge(), 1);
var SD$1 = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false }, PD$1 = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Bx$1 = class Bx extends de$1 {
  constructor(t) {
    super();
    this.remove = H$3(() => (this._content && D$1.remove(this._content), this._container && (D$1.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new F("close"))), this), "remove");
    this._onMouseUp = H$3((t5) => {
      this._update(t5.point);
    }, "_onMouseUp");
    this._onMouseMove = H$3((t5) => {
      this._update(t5.point);
    }, "_onMouseMove");
    this._onDrag = H$3((t5) => {
      this._update(t5.point);
    }, "_onDrag");
    this._update = H$3((t5) => {
      var u5;
      let i = this._lngLat || this._trackPointer;
      if (!this._map || !i || !this._content) return;
      if (!this._container) {
        if (this._container = D$1.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = D$1.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (let c of this.options.className.split(" ")) this._container.classList.add(c);
        this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
      }
      if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer ? this._lngLat = fp(this._lngLat, this._flatPos, this._map.transform) : this._lngLat = (u5 = this._lngLat) == null ? void 0 : u5.wrap(), this._trackPointer && !t5) return;
      let n4 = this._flatPos = this._pos = this._trackPointer && t5 ? t5 : this._map.project(this._lngLat);
      this._map.terrain && (this._flatPos = this._trackPointer && t5 ? t5 : this._map.transform.locationPoint(this._lngLat));
      let o4 = this.options.anchor, a4 = m2$1(this.options.offset);
      if (!o4) {
        let c = this._container.offsetWidth, p4 = this._container.offsetHeight, h;
        n4.y + a4.bottom.y < p4 ? h = ["top"] : n4.y > this._map.transform.height - p4 ? h = ["bottom"] : h = [], n4.x < c / 2 ? h.push("left") : n4.x > this._map.transform.width - c / 2 && h.push("right"), h.length === 0 ? o4 = "bottom" : o4 = h.join("-");
      }
      let s5 = n4.add(a4[o4]);
      this.options.subpixelPositioning || (s5 = s5.round()), D$1.setTransform(this._container, "".concat(Ka$1[o4], " translate(").concat(s5.x, "px,").concat(s5.y, "px)")), mp(this._container, o4, "popup");
    }, "_update");
    this._onClose = H$3(() => {
      this.remove();
    }, "_onClose");
    this.options = V$1(Object.create(SD$1), t);
  }
  addTo(t) {
    return this._map && this.remove(), this._map = t, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new F("open")), this;
  }
  isOpen() {
    return !!this._map;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(t) {
    return this._lngLat = ie$1.convert(t), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
  }
  trackPointer() {
    return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
  }
  getElement() {
    return this._container;
  }
  setText(t) {
    return this.setDOMContent(document.createTextNode(t));
  }
  setHTML(t) {
    let i = document.createDocumentFragment(), n4 = document.createElement("body"), o4;
    for (n4.innerHTML = t; o4 = n4.firstChild, !!o4; ) i.appendChild(o4);
    return this.setDOMContent(i);
  }
  getMaxWidth() {
    var t;
    return (t = this._container) == null ? void 0 : t.style.maxWidth;
  }
  setMaxWidth(t) {
    return this.options.maxWidth = t, this._update(), this;
  }
  setDOMContent(t) {
    if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
    else this._content = D$1.create("div", "maplibregl-popup-content", this._container);
    return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
  }
  addClassName(t) {
    this._container && this._container.classList.add(t);
  }
  removeClassName(t) {
    this._container && this._container.classList.remove(t);
  }
  setOffset(t) {
    return this.options.offset = t, this._update(), this;
  }
  toggleClassName(t) {
    if (this._container) return this._container.classList.toggle(t);
  }
  setSubpixelPositioning(t) {
    this.options.subpixelPositioning = t;
  }
  _createCloseButton() {
    this.options.closeButton && (this._closeButton = D$1.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
  }
  _focusFirstElement() {
    if (!this.options.focusAfterOpen || !this._container) return;
    let t = this._container.querySelector(PD$1);
    t && t.focus();
  }
};
H$3(Bx$1, "Popup");
function m2$1(r5) {
  if (r5) if (typeof r5 == "number") {
    let e = Math.round(Math.abs(r5) / Math.SQRT2);
    return { center: new je$1.default(0, 0), top: new je$1.default(0, r5), "top-left": new je$1.default(e, e), "top-right": new je$1.default(-e, e), bottom: new je$1.default(0, -r5), "bottom-left": new je$1.default(e, -e), "bottom-right": new je$1.default(-e, -e), left: new je$1.default(r5, 0), right: new je$1.default(-r5, 0) };
  } else if (r5 instanceof je$1.default || Array.isArray(r5)) {
    let e = je$1.default.convert(r5);
    return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
  } else return { center: je$1.default.convert(r5.center || [0, 0]), top: je$1.default.convert(r5.top || [0, 0]), "top-left": je$1.default.convert(r5["top-left"] || [0, 0]), "top-right": je$1.default.convert(r5["top-right"] || [0, 0]), bottom: je$1.default.convert(r5.bottom || [0, 0]), "bottom-left": je$1.default.convert(r5["bottom-left"] || [0, 0]), "bottom-right": je$1.default.convert(r5["bottom-right"] || [0, 0]), left: je$1.default.convert(r5.left || [0, 0]), right: je$1.default.convert(r5.right || [0, 0]) };
  else return m2$1(new je$1.default(0, 0));
}
H$3(m2$1, "normalizeOffset");
var TD$1 = N$2(ge(), 1);
var MD$1 = ts.version;
function Ole(r5, e) {
  return Vr$1().setRTLTextPlugin(r5, e);
}
H$3(Ole, "setRTLTextPlugin");
function Vle() {
  return Vr$1().getRTLTextPluginStatus();
}
H$3(Vle, "getRTLTextPluginStatus");
function Ule() {
  return MD$1;
}
H$3(Ule, "getVersion");
function Nle() {
  return zr.workerCount;
}
H$3(Nle, "getWorkerCount");
function Gle(r5) {
  zr.workerCount = r5;
}
H$3(Gle, "setWorkerCount");
function qle() {
  return Ke.MAX_PARALLEL_IMAGE_REQUESTS;
}
H$3(qle, "getMaxParallelImageRequests");
function jle(r5) {
  Ke.MAX_PARALLEL_IMAGE_REQUESTS = r5;
}
H$3(jle, "setMaxParallelImageRequests");
function Zle() {
  return Ke.WORKER_URL;
}
H$3(Zle, "getWorkerUrl");
function Hle(r5) {
  Ke.WORKER_URL = r5;
}
H$3(Hle, "setWorkerUrl");
function $le(r5) {
  return yu().broadcast("IS", r5);
}
H$3($le, "importScriptInWorkers");
a();
function or(r5, e, t = false) {
  let n4 = null, o4 = 0;
  return function(...a4) {
    o4++, o4 === 1 && t === true && r5(...a4);
    let u5 = H$3(() => {
      (!t || o4 > 1) && r5(...a4), n4 = null, o4 = 0;
    }, "later");
    clearTimeout(n4), n4 = setTimeout(u5, e);
  };
}
H$3(or, "debounce");
a();
a();
var ae$1 = "[MappedinJS]", Et = ((o4) => (o4[o4.LOG = 0] = "LOG", o4[o4.WARN = 1] = "WARN", o4[o4.ERROR = 2] = "ERROR", o4[o4.SILENT = 3] = "SILENT", o4))(Et || {});
function Dt(r5 = "", { prefix: e = ae$1 } = {}) {
  let t = "".concat(e).concat(r5 ? "-".concat(r5) : ""), n4 = H$3((o4, a4) => {
    if (typeof window < "u" && window.rnDebug) {
      let u5 = a4.map((c) => c instanceof Error && c.stack ? "".concat(c.message, "\n").concat(c.stack) : c);
      window.rnDebug("".concat(r5, " ").concat(o4, ": ").concat(u5.join(" ")));
    }
  }, "rnDebug");
  return { logState: p$1.env.NODE_ENV === "test" ? 3 : 0, log(...o4) {
    this.logState <= 0 && (console.log(t, ...o4), n4("log", o4));
  }, warn(...o4) {
    this.logState <= 1 && (console.warn(t, ...o4), n4("warn", o4));
  }, error(...o4) {
    this.logState <= 2 && (console.error(t, ...o4), n4("error", o4));
  }, assert(...o4) {
    console.assert(...o4);
  }, time(o4) {
    console.time(o4);
  }, timeEnd(o4) {
    console.timeEnd(o4);
  }, setLevel(o4) {
    0 <= o4 && o4 <= 3 && (this.logState = o4);
  } };
}
H$3(Dt, "createLogger");
var qe = Dt();
function ur(r5) {
  0 <= r5 && r5 <= 3 && (qe.logState = r5);
}
H$3(ur, "setLoggerLevel");
var B = qe;
a();
function Tt(r5, e) {
  return "".concat(e, " ").concat(r5);
}
H$3(Tt, "formatMessage");
var ve$1 = class ve extends Error {
  constructor(e, t = ae$1) {
    super(Tt(e, t)), this.name = "MappedinError";
  }
};
H$3(ve$1, "MappedinError");
var Y = ve$1, Ee = class Ee2 extends Y {
  constructor(e, t = ae$1) {
    super(e, t), this.name = "MappedinRenderError";
  }
};
H$3(Ee, "MappedinRenderError");
var Xe = Ee;
a();
a();
var De$1 = class De extends Error {
};
H$3(De$1, "InvalidTokenError");
var V = De$1;
V.prototype.name = "InvalidTokenError";
function Mt(r5) {
  return decodeURIComponent(atob(r5).replace(/(.)/g, (e, t) => {
    let n4 = t.charCodeAt(0).toString(16).toUpperCase();
    return n4.length < 2 && (n4 = "0" + n4), "%" + n4;
  }));
}
H$3(Mt, "b64DecodeUnicode");
function St(r5) {
  let e = r5.replace(/-/g, "+").replace(/_/g, "/");
  switch (e.length % 4) {
    case 0:
      break;
    case 2:
      e += "==";
      break;
    case 3:
      e += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return Mt(e);
  } catch (t) {
    return atob(e);
  }
}
H$3(St, "base64UrlDecode");
function Ze(r5, e) {
  if (typeof r5 != "string") throw new V("Invalid token specified: must be a string");
  e || (e = {});
  let t = e.header === true ? 0 : 1, n4 = r5.split(".")[t];
  if (typeof n4 != "string") throw new V("Invalid token specified: missing part #".concat(t + 1));
  let o4;
  try {
    o4 = St(n4);
  } catch (a4) {
    throw new V("Invalid token specified: invalid base64 for part #".concat(t + 1, " (").concat(a4.message, ")"));
  }
  try {
    return JSON.parse(o4);
  } catch (a4) {
    throw new V("Invalid token specified: invalid json for part #".concat(t + 1, " (").concat(a4.message, ")"));
  }
}
H$3(Ze, "jwtDecode");
a();
var j = 63710088e-1;
function Sr(r5) {
  var t, n4;
  let e = Ze(r5);
  if (e.sub == null) throw new Error("Access token is missing sub claim.");
  return { sub: e.sub, aud: typeof e.aud == "string" ? [e.aud] : (t = e.aud) != null ? t : [], capabilities: (n4 = e.capabilities) != null ? n4 : {} };
}
H$3(Sr, "decodeAccessToken");
function A(r5) {
  return r5 * (Math.PI / 180);
}
H$3(A, "toRadians");
function wt(r5) {
  return r5 * (180 / Math.PI);
}
H$3(wt, "toDegrees");
function wr(r5, e) {
  let t = Math.pow(10, e);
  return Math.sign(r5) * Math.round(Math.abs(r5) * t) / t;
}
H$3(wr, "round");
function Qe(r5, e) {
  return (r5 % e + e) % e;
}
H$3(Qe, "euclideanModulo");
function Pr$1([r5, e], [t, n4]) {
  let o4 = A(n4 - e), a4 = A(t - r5), u5 = A(e), c = A(n4), m5 = Math.sin(o4 / 2) * Math.sin(o4 / 2) + Math.sin(a4 / 2) * Math.sin(a4 / 2) * Math.cos(u5) * Math.cos(c), p4 = 2 * Math.atan2(Math.sqrt(m5), Math.sqrt(1 - m5));
  return j * p4;
}
H$3(Pr$1, "haversineDistance");
function Cr([r5, e], [t, n4]) {
  let o4 = A(e), a4 = A(r5), u5 = A(n4), m5 = A(t) - a4, p4 = Math.sin(m5) * Math.cos(u5), g = Math.cos(o4) * Math.sin(u5) - Math.sin(o4) * Math.cos(u5) * Math.cos(m5);
  return wt((Math.atan2(p4, g) + Math.PI * 2) % (Math.PI * 2));
}
H$3(Cr, "getForwardBearing");
function Ir(r5, e) {
  let t = Qe(r5, Math.PI * 2), n4 = Qe(e, Math.PI * 2), o4 = n4 - t, a4 = n4 + (o4 > Math.PI ? -Math.PI * 2 : o4 < -Math.PI ? Math.PI * 2 : 0);
  return { start: t, end: a4 };
}
H$3(Ir, "shortestTweenRotation");
function Pt$1(r5) {
  return r5 instanceof Jl$2 ? Number.isFinite(r5.min.x) && Number.isFinite(r5.min.y) && Number.isFinite(r5.max.x) && Number.isFinite(r5.max.y) : Number.isFinite(r5.min.x) && Number.isFinite(r5.min.y) && Number.isFinite(r5.max.x) && Number.isFinite(r5.max.y) && Number.isFinite(r5.min.z) && Number.isFinite(r5.max.z);
}
H$3(Pt$1, "isFiniteBox");
function Lr(r5, e, t, n4) {
  return (r5 < e || r5 > t) && B.warn(n4), Math.min(t, Math.max(e, r5));
}
H$3(Lr, "clampWithWarning");
function Or$1(r5, e) {
  if (r5 == null || e == null) return r5 === e;
  if (r5.length !== e.length) return false;
  for (let t = 0; t < r5.length; t++) if (r5[t] !== e[t]) return false;
  return true;
}
H$3(Or$1, "arraysEqual");
function Ar() {
  return typeof window < "u" && window !== null;
}
H$3(Ar, "isBrowser");
a();
var se = class se2 extends Error {
  constructor(t) {
    super(t);
    O(this, "name", "AssertionError");
    Error.captureStackTrace && Error.captureStackTrace(this, se2);
  }
};
H$3(se, "AssertionError");
var Te = se;
function et(r5, e) {
  if (r5 == null) {
    let t;
    if (e != null && e.customMessage) t = e.customMessage;
    else {
      let a4 = e != null && e.valueName ? "'".concat(e.valueName, "'") : "value";
      t = "Expected ".concat(a4, " to be defined, but received ").concat(r5);
    }
    let n4 = (e == null ? void 0 : e.errorClass) || Te, o4 = new n4(t);
    throw (e == null ? void 0 : e.captureStackTrace) !== false && Error.captureStackTrace && Error.captureStackTrace(o4, et), o4;
  }
}
H$3(et, "assertExists");
function _r(r5, e, t) {
  if (et(r5), (r5 == null ? void 0 : r5.type) !== e) {
    let n4 = "Expected type ".concat(e, " but got ").concat(r5 == null ? void 0 : r5.type);
    throw new Error(t != null ? t : n4);
  }
}
H$3(_r, "assertType");
a();
var Me$2 = [0, 4, 6, 8, 10], E = H$3(() => {
  let r5 = new Array(16).fill(0), e = Math.random() * 4294967296;
  for (let n4 = 0; n4 < r5.length; n4++) n4 > 0 && (n4 & 3) === 0 && (e = Math.random() * 4294967296), r5[n4] = e >>> ((n4 & 3) << 3) & 255;
  let t = r5.map((n4) => n4.toString(16).padStart(2, "0"));
  return t[6] = "4" + t[6][1], t[8] = ["8", "9", "a", "b"].includes(t[7][0]) ? t[7] : "a" + t[7][1], Me$2.map((n4, o4) => t.slice(n4, o4 === Me$2.length - 1 ? void 0 : Me$2[o4 + 1]).join("")).join("-");
}, "randomId");
a();
var we = class we2 {
  constructor() {
    O(this, "_subscribers", {});
  }
  publish(e, t) {
    !this._subscribers || !this._subscribers[e] || this._subscribers[e].forEach(function(n4) {
      typeof n4 == "function" && n4(t);
    });
  }
  on(e, t) {
    this._subscribers || (this._subscribers = {}), this._subscribers[e] = this._subscribers[e] || [], this._subscribers[e].push(t);
  }
  off(e, t) {
    if (!this._subscribers || this._subscribers[e] == null) return;
    let n4 = this._subscribers[e].indexOf(t);
    n4 !== -1 && this._subscribers[e].splice(n4, 1);
  }
  destroy() {
    this._subscribers = {};
  }
};
H$3(we, "PubSub");
var Se$1 = we;
a();
var tt = "mi-session-data", rt = "mi-local-data", J = "id", q$1 = "deviceId", U, D, T, X = class X3 {
  constructor() {
    Q$3(this, D);
    Q$3(this, T);
    try {
      let e = sessionStorage.getItem(tt);
      e ? R$1(this, D, JSON.parse(e)) : R$1(this, D, { [J]: E() });
    } catch (e) {
      R$1(this, D, { [J]: E() });
    }
    try {
      let e = localStorage.getItem(rt);
      e ? R$1(this, T, JSON.parse(e)) : R$1(this, T, { [q$1]: E() });
    } catch (e) {
      R$1(this, T, { [q$1]: E() });
    }
    P(this, D)[J] || (P(this, D)[J] = E()), P(this, T)[q$1] || (P(this, T)[q$1] = E());
  }
  static getInstance() {
    return P(this, U) || R$1(this, U, new X3()), P(this, U);
  }
  static ___clearInstance() {
    R$1(this, U, void 0);
  }
  saveSessionData(e, t) {
    P(this, D)[e] = t;
    try {
      return sessionStorage.setItem(tt, JSON.stringify(P(this, D))), true;
    } catch (n4) {
      return false;
    }
  }
  loadSessionData(e) {
    let t = P(this, D)[e];
    if (t != null) return t;
  }
  saveLocalData(e, t) {
    P(this, T)[e] = t;
    try {
      return localStorage.setItem(rt, JSON.stringify(P(this, T))), true;
    } catch (n4) {
      return false;
    }
  }
  loadLocalData(e) {
    let t = P(this, T)[e];
    if (t != null) return t;
  }
};
U = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), H$3(X, "SafeStorage"), Q$3(X, U);
var Pe$1 = X;
a();
var Ct = new Set(Object.keys(Ft$3.NAMES)), Ce$1;
function nt$1() {
  return Ce$1 == null && (Ce$1 = new Ft$3()), Ce$1;
}
H$3(nt$1, "getColorInstance");
var It = H$3((r5) => Ct.has(r5.toLowerCase()), "isX11Color"), Lt = H$3((r5) => {
  if (!r5.startsWith("#")) return false;
  let e = r5.slice(1);
  if (e.length !== 3 && e.length !== 6) return false;
  for (let t = 0; t < e.length; t++) if (!(e[t] >= "0" && e[t] <= "9" || e[t] >= "A" && e[t] <= "F" || e[t] >= "a" && e[t] <= "f")) return false;
  return true;
}, "isHexColor"), Ot = H$3((r5) => {
  if (!r5.startsWith("rgb(") && !r5.startsWith("rgba(")) return false;
  let e = r5.indexOf("("), t = r5.lastIndexOf(")");
  if (e === -1 || t === -1 || t <= e || t !== r5.length - 1) return false;
  let n4 = r5.slice(e + 1, t).split(",");
  if (n4.length !== 3 && n4.length !== 4) return false;
  for (let o4 = 0; o4 < n4.length; o4++) {
    let a4 = n4[o4].trim();
    if (o4 < 3) if (a4.endsWith("%")) {
      let u5 = parseFloat(a4.slice(0, -1));
      if (isNaN(u5) || u5 < 0 || u5 > 100) return false;
    } else {
      let u5 = parseInt(a4, 10);
      if (isNaN(u5) || u5 < 0 || u5 > 255) return false;
    }
    else {
      let u5 = parseFloat(a4);
      if (isNaN(u5) || u5 < 0 || u5 > 1) return false;
    }
  }
  return true;
}, "isRgbColor"), At = H$3((r5) => {
  if (!r5.startsWith("hsl(") && !r5.startsWith("hsla(")) return false;
  let e = r5.indexOf("("), t = r5.lastIndexOf(")");
  if (e === -1 || t === -1 || t <= e || t !== r5.length - 1) return false;
  let n4 = r5.slice(e + 1, t).split(",");
  if (n4.length !== 3 && n4.length !== 4) return false;
  for (let o4 = 0; o4 < n4.length; o4++) {
    let a4 = n4[o4].trim();
    if (o4 === 0) {
      let u5 = parseFloat(a4);
      if (isNaN(u5)) return false;
    } else if (o4 < 3) {
      if (!a4.endsWith("%")) return false;
      let u5 = parseFloat(a4.slice(0, -1));
      if (isNaN(u5) || u5 < 0 || u5 > 100) return false;
    } else {
      let u5 = parseFloat(a4);
      if (isNaN(u5) || u5 < 0 || u5 > 1) return false;
    }
  }
  return true;
}, "isHslColor"), ue = H$3((r5) => r5 == null || typeof r5 != "string" ? false : !!(Lt(r5) || Ot(r5) || At(r5) || It(r5)), "isColor"), Xr$1 = H$3((r5) => {
  let e = nt$1();
  return e.set(r5), [e.r, e.g, e.b];
}, "stringToRgbArray"), Zr = H$3((r5) => {
  let e = nt$1();
  return e.set(r5[0], r5[1], r5[2]), "#" + e.getHexString();
}, "rgbArrayToString");
a();
var ot = H$3((r5) => r5, "linearEase"), Nt = H$3((r5) => r5 * r5, "quadEaseIn"), kt = H$3((r5) => 1 - Math.cos(r5 * Math.PI / 2), "easeIn"), Gt = H$3((r5) => 1 - (1 - r5) * (1 - r5), "quadEaseOut"), it$1 = { linear: ot, "ease-in": Nt, "ease-out": Gt, "ease-in-out": kt };
function nn(r5, e, t, n4, o4, a4 = ot) {
  if (e === t) return o4;
  r5 = Math.max(e, Math.min(r5, t));
  let u5 = (r5 - Math.min(e, t)) / Math.abs(t - e), c = typeof a4 == "function" ? a4(u5) : it$1[a4](u5);
  return n4 + c * (o4 - n4);
}
H$3(nn, "interpolate");
function on$1(r5, e, t, n4 = "ease-in") {
  if (e.length !== t.length) throw new Y("Input and output ranges must have the same number of values.");
  r5 = Math.max(e[0], Math.min(r5, e[e.length - 1]));
  let o4 = 0;
  for (; o4 < e.length - 1 && r5 > e[o4 + 1]; ) o4++;
  let a4 = (r5 - e[o4]) / (e[o4 + 1] - e[o4]), u5 = typeof n4 == "function" ? n4(a4) : it$1[n4](a4);
  return t[o4] + u5 * (t[o4 + 1] - t[o4]);
}
H$3(on$1, "interpolateMulti");
a();
function _t(r5) {
  return (r5 % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
}
H$3(_t, "normalizeAngle");
a();
a();
a();
a();
a();
a();
a();
a();
var x = 63710088e-1, st = { centimeters: x * 100, centimetres: x * 100, degrees: x / 111325, feet: x * 3.28084, inches: x * 39.37, kilometers: x / 1e3, kilometres: x / 1e3, meters: x, metres: x, miles: x / 1609.344, millimeters: x * 1e3, millimetres: x * 1e3, nauticalmiles: x / 1852, radians: 1, yards: x * 1.0936 };
function I(r5, e, t) {
  t === void 0 && (t = {});
  var n4 = { type: "Feature" };
  return (t.id === 0 || t.id) && (n4.id = t.id), t.bbox && (n4.bbox = t.bbox), n4.properties = e || {}, n4.geometry = r5, n4;
}
H$3(I, "feature");
function Ft$1(r5, e, t) {
  if (t === void 0 && (t = {}), !r5) throw new Error("coordinates is required");
  if (!Array.isArray(r5)) throw new Error("coordinates must be an Array");
  if (r5.length < 2) throw new Error("coordinates must be at least 2 numbers long");
  if (!at(r5[0]) || !at(r5[1])) throw new Error("coordinates must contain numbers");
  var n4 = { type: "Point", coordinates: r5 };
  return I(n4, e, t);
}
H$3(Ft$1, "point");
function Sn(r5, e, t) {
  t === void 0 && (t = {});
  for (var n4 = 0, o4 = r5; n4 < o4.length; n4++) {
    var a4 = o4[n4];
    if (a4.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var u5 = 0; u5 < a4[a4.length - 1].length; u5++) if (a4[a4.length - 1][u5] !== a4[0][u5]) throw new Error("First and last Position are not equivalent.");
  }
  var c = { type: "Polygon", coordinates: r5 };
  return I(c, e, t);
}
H$3(Sn, "polygon");
function ut(r5, e, t) {
  if (t === void 0 && (t = {}), r5.length < 2) throw new Error("coordinates must be an array of two or more positions");
  var n4 = { type: "LineString", coordinates: r5 };
  return I(n4, e, t);
}
H$3(ut, "lineString");
function wn$1(r5, e) {
  e === void 0 && (e = {});
  var t = { type: "FeatureCollection" };
  return e.id && (t.id = e.id), e.bbox && (t.bbox = e.bbox), t.features = r5, t;
}
H$3(wn$1, "featureCollection");
function Pn$1(r5, e, t) {
  t === void 0 && (t = {});
  var n4 = { type: "MultiLineString", coordinates: r5 };
  return I(n4, e, t);
}
H$3(Pn$1, "multiLineString");
function Cn$1(r5, e, t) {
  t === void 0 && (t = {});
  var n4 = { type: "MultiPoint", coordinates: r5 };
  return I(n4, e, t);
}
H$3(Cn$1, "multiPoint");
function In(r5, e, t) {
  t === void 0 && (t = {});
  var n4 = { type: "MultiPolygon", coordinates: r5 };
  return I(n4, e, t);
}
H$3(In, "multiPolygon");
function Ln(r5, e) {
  e === void 0 && (e = "kilometers");
  var t = st[e];
  if (!t) throw new Error(e + " units is invalid");
  return r5 * t;
}
H$3(Ln, "radiansToLength");
function On2(r5, e) {
  e === void 0 && (e = "kilometers");
  var t = st[e];
  if (!t) throw new Error(e + " units is invalid");
  return r5 / t;
}
H$3(On2, "lengthToRadians");
function An$1(r5) {
  var e = r5 % (2 * Math.PI);
  return e * 180 / Math.PI;
}
H$3(An$1, "radiansToDegrees");
function Nn2(r5) {
  var e = r5 % 360;
  return e * Math.PI / 180;
}
H$3(Nn2, "degreesToRadians");
function at(r5) {
  return !isNaN(r5) && r5 !== null && !Array.isArray(r5);
}
H$3(at, "isNumber");
function Z$1(r5, e, t) {
  if (r5 !== null) for (var n4, o4, a4, u5, c, m5, p4, g = 0, h = 0, P4, C3 = r5.type, S4 = C3 === "FeatureCollection", _ = C3 === "Feature", de2 = S4 ? r5.features.length : 1, F3 = 0; F3 < de2; F3++) {
    p4 = S4 ? r5.features[F3].geometry : _ ? r5.geometry : r5, P4 = p4 ? p4.type === "GeometryCollection" : false, c = P4 ? p4.geometries.length : 1;
    for (var he2 = 0; he2 < c; he2++) {
      var w3 = 0, R3 = 0;
      if (u5 = P4 ? p4.geometries[he2] : p4, u5 !== null) {
        m5 = u5.coordinates;
        var L3 = u5.type;
        switch (g = t && (L3 === "Polygon" || L3 === "MultiPolygon") ? 1 : 0, L3) {
          case null:
            break;
          case "Point":
            if (e(m5, h, F3, w3, R3) === false) return false;
            h++, w3++;
            break;
          case "LineString":
          case "MultiPoint":
            for (n4 = 0; n4 < m5.length; n4++) {
              if (e(m5[n4], h, F3, w3, R3) === false) return false;
              h++, L3 === "MultiPoint" && w3++;
            }
            L3 === "LineString" && w3++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (n4 = 0; n4 < m5.length; n4++) {
              for (o4 = 0; o4 < m5[n4].length - g; o4++) {
                if (e(m5[n4][o4], h, F3, w3, R3) === false) return false;
                h++;
              }
              L3 === "MultiLineString" && w3++, L3 === "Polygon" && R3++;
            }
            L3 === "Polygon" && w3++;
            break;
          case "MultiPolygon":
            for (n4 = 0; n4 < m5.length; n4++) {
              for (R3 = 0, o4 = 0; o4 < m5[n4].length; o4++) {
                for (a4 = 0; a4 < m5[n4][o4].length - g; a4++) {
                  if (e(m5[n4][o4][a4], h, F3, w3, R3) === false) return false;
                  h++;
                }
                R3++;
              }
              w3++;
            }
            break;
          case "GeometryCollection":
            for (n4 = 0; n4 < u5.geometries.length; n4++) if (Z$1(u5.geometries[n4], e, t) === false) return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
}
H$3(Z$1, "coordEach");
function Bn2(r5, e, t, n4) {
  var o4 = t;
  return Z$1(r5, function(a4, u5, c, m5, p4) {
    u5 === 0 && t === void 0 ? o4 = a4 : o4 = e(o4, a4, u5, c, m5, p4);
  }, n4), o4;
}
H$3(Bn2, "coordReduce");
function Vn$1(r5, e) {
  if (r5.type === "Feature") e(r5, 0);
  else if (r5.type === "FeatureCollection") for (var t = 0; t < r5.features.length && e(r5.features[t], t) !== false; t++) ;
}
H$3(Vn$1, "featureEach");
function Rt(r5, e) {
  var t, n4, o4, a4, u5, c, m5, p4, g, h, P4 = 0, C3 = r5.type === "FeatureCollection", S4 = r5.type === "Feature", _ = C3 ? r5.features.length : 1;
  for (t = 0; t < _; t++) {
    for (c = C3 ? r5.features[t].geometry : S4 ? r5.geometry : r5, p4 = C3 ? r5.features[t].properties : S4 ? r5.properties : {}, g = C3 ? r5.features[t].bbox : S4 ? r5.bbox : void 0, h = C3 ? r5.features[t].id : S4 ? r5.id : void 0, m5 = c ? c.type === "GeometryCollection" : false, u5 = m5 ? c.geometries.length : 1, o4 = 0; o4 < u5; o4++) {
      if (a4 = m5 ? c.geometries[o4] : c, a4 === null) {
        if (e(null, P4, p4, g, h) === false) return false;
        continue;
      }
      switch (a4.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (e(a4, P4, p4, g, h) === false) return false;
          break;
        }
        case "GeometryCollection": {
          for (n4 = 0; n4 < a4.geometries.length; n4++) if (e(a4.geometries[n4], P4, p4, g, h) === false) return false;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    P4++;
  }
}
H$3(Rt, "geomEach");
function Bt(r5, e) {
  Rt(r5, function(t, n4, o4, a4, u5) {
    var c = t === null ? null : t.type;
    switch (c) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return e(I(t, o4, { bbox: a4, id: u5 }), n4, 0) === false ? false : void 0;
    }
    var m5;
    switch (c) {
      case "MultiPoint":
        m5 = "Point";
        break;
      case "MultiLineString":
        m5 = "LineString";
        break;
      case "MultiPolygon":
        m5 = "Polygon";
        break;
    }
    for (var p4 = 0; p4 < t.coordinates.length; p4++) {
      var g = t.coordinates[p4], h = { type: m5, coordinates: g };
      if (e(I(h, o4), n4, p4) === false) return false;
    }
  });
}
H$3(Bt, "flattenEach");
function Vt$1(r5, e) {
  Bt(r5, function(t, n4, o4) {
    var a4 = 0;
    if (t.geometry) {
      var u5 = t.geometry.type;
      if (!(u5 === "Point" || u5 === "MultiPoint")) {
        var c, m5 = 0, p4 = 0, g = 0;
        if (Z$1(t, function(h, P4, C3, S4, _) {
          if (c === void 0 || n4 > m5 || S4 > p4 || _ > g) {
            c = h, m5 = n4, p4 = S4, g = _, a4 = 0;
            return;
          }
          var de2 = ut([c, h], t.properties);
          if (e(de2, n4, o4, _, a4) === false) return false;
          a4++, c = h;
        }) === false) return false;
      }
    }
  });
}
H$3(Vt$1, "segmentEach");
function jn$1(r5, e, t) {
  var n4 = t, o4 = false;
  return Vt$1(r5, function(a4, u5, c, m5, p4) {
    o4 === false && t === void 0 ? n4 = a4 : n4 = e(n4, a4, u5, c, m5, p4), o4 = true;
  }), n4;
}
H$3(jn$1, "segmentReduce");
function Ie2(r5) {
  var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return Z$1(r5, function(t) {
    e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]);
  }), e;
}
H$3(Ie2, "bbox");
Ie2.default = Ie2;
var lt = Ie2;
function ct(r5) {
  return lt(r5);
}
H$3(ct, "getBoundingBoxFromFeature");
a();
var Le = "#ffffff", jt$1 = 0.1, le = 0.1, Q$1, ee, te, Ae$1 = class Ae {
  constructor(e = {}) {
    O(this, "initialColor", Le);
    Q$3(this, Q$1, Le);
    O(this, "initialTopColor");
    Q$3(this, ee);
    O(this, "topTexture");
    O(this, "texture");
    Q$3(this, te);
    O(this, "dirty", true);
    O(this, "visible", true);
    O(this, "opacity", 1);
    O(this, "width", jt$1);
    O(this, "height", le);
    O(this, "initialHeight", le);
    O(this, "altitude", 0);
    O(this, "join", "round");
    O(this, "cap", "round");
    O(this, "showImage", true);
    O(this, "flipImageToFaceCamera", true);
    O(this, "url");
    O(this, "side", "double");
    O(this, "renderOrder", 0);
    this.color = (e == null ? void 0 : e.color) !== void 0 ? e.color : this.color, this.initialColor = this.color, this.width = (e == null ? void 0 : e.width) !== void 0 ? e.width : this.width, this.opacity = (e == null ? void 0 : e.opacity) !== void 0 ? e.opacity : this.opacity, this.visible = (e == null ? void 0 : e.visible) !== void 0 ? e.visible : this.visible, this.height = (e == null ? void 0 : e.height) !== void 0 ? e.height : this.height, this.initialHeight = this.height, this.altitude = (e == null ? void 0 : e.altitude) !== void 0 ? e.altitude : this.altitude, this.join = (e == null ? void 0 : e.join) !== void 0 ? e.join : this.join, this.cap = (e == null ? void 0 : e.cap) !== void 0 ? e.cap : this.cap, this.topColor = e == null ? void 0 : e.topColor, this.initialTopColor = this.topColor, this.texture = e == null ? void 0 : e.texture, this.topTexture = e == null ? void 0 : e.topTexture, this.showImage = (e == null ? void 0 : e.showImage) !== void 0 ? e.showImage : this.showImage, this.flipImageToFaceCamera = (e == null ? void 0 : e.flipImageToFaceCamera) !== void 0 ? e.flipImageToFaceCamera : this.flipImageToFaceCamera, this.url = e == null ? void 0 : e.url, this.side = (e == null ? void 0 : e.side) !== void 0 ? e.side : this.side, this.renderOrder = (e == null ? void 0 : e.renderOrder) !== void 0 ? e.renderOrder : this.renderOrder;
  }
  set color(e) {
    ue(e) ? R$1(this, Q$1, e) : B.warn('Failed to update color. Invalid color "'.concat(e, '".'));
  }
  get color() {
    return P(this, Q$1);
  }
  set topColor(e) {
    e === void 0 || ue(e) ? R$1(this, ee, e) : B.warn('Failed to update top color. Invalid color "'.concat(e, '".'));
  }
  get topColor() {
    return P(this, ee);
  }
  set hoverColor(e) {
    ue(e) ? R$1(this, te, e) : B.warn('Failed to update hover color. Invalid color "'.concat(e, '".'));
  }
  get hoverColor() {
    return P(this, te);
  }
};
Q$1 = /* @__PURE__ */ new WeakMap(), ee = /* @__PURE__ */ new WeakMap(), te = /* @__PURE__ */ new WeakMap(), H$3(Ae$1, "StyleComponent");
var Oe = Ae$1;
var Ne = class Ne2 extends _l$2 {
  constructor() {
    super(...arguments);
    O(this, "type", "entityBatchedMesh");
    O(this, "userData", { entities: {} });
  }
};
H$3(Ne, "EntityBatchedMesh");
var ce$1 = Ne, re$2, W, ke = class ke2 {
  constructor(e) {
    O(this, "mesh");
    O(this, "imageMesh");
    O(this, "textMesh");
    O(this, "textEntityId");
    O(this, "type", "geometry");
    O(this, "dirty", true);
    O(this, "detached", false);
    O(this, "instanceIndex", -1);
    O(this, "geometry");
    O(this, "batchedProps");
    O(this, "material");
    O(this, "feature");
    O(this, "currentHeight", le);
    O(this, "color", new Ft$3());
    O(this, "topColor", new Ft$3());
    O(this, "position", new I$1());
    O(this, "altitude", 0);
    Q$3(this, re$2, 1);
    Q$3(this, W);
    O(this, "texturesVisible", false);
    this.feature = e;
  }
  get visible() {
    return this.mesh && this.instanceIndex !== -1 ? this.mesh.getVisibleAt(this.instanceIndex) : false;
  }
  set visible(e) {
    this.mesh && this.instanceIndex !== -1 && this.mesh.setVisibleAt(this.instanceIndex, e);
  }
  get renderOrder() {
    return this.mesh ? this.mesh.renderOrder : 0;
  }
  set renderOrder(e) {
    this.mesh && (this.mesh.renderOrder = e);
  }
  setColor(e, t) {
    this.color.set(e), this.topColor.set(t), this.material && this.material.setColor(this.instanceIndex, this.color, this.topColor);
  }
  getColor() {
    var e;
    return (e = this.material) == null ? void 0 : e.getColor(this.instanceIndex);
  }
  get opacity() {
    return P(this, re$2);
  }
  set opacity(e) {
    if (this.material && (this.material.opacity = e, this.material.transparent = e < 1, this.material.needsUpdate = true), this.imageMesh) {
      let t = Array.isArray(this.imageMesh.material) ? this.imageMesh.material : [this.imageMesh.material];
      for (let n4 of t) n4.opacity = e, n4.needsUpdate = true;
    }
    R$1(this, re$2, e);
  }
  get texture() {
    var e, t;
    return (t = (e = this.material) == null ? void 0 : e.texture) == null ? void 0 : t.image.src;
  }
  set texture(e) {
    this.material && (this.material.texture = e);
  }
  get textureInstance() {
    var e;
    return (e = this.material) == null ? void 0 : e.texture;
  }
  set topTexture(e) {
    this.material && (this.material.topTexture = e);
  }
  get topTexture() {
    var e, t;
    return (t = (e = this.material) == null ? void 0 : e.topTexture) == null ? void 0 : t.image.src;
  }
  get topTextureInstance() {
    var e;
    return (e = this.material) == null ? void 0 : e.topTexture;
  }
  set blendTexture(e) {
    this.material && (this.material.blendTexture = e);
  }
  get featureBbox() {
    return P(this, W) ? P(this, W) : (R$1(this, W, ct(this.feature)), P(this, W));
  }
  showTextures() {
    this.material && (this.material.showTextures(this.instanceIndex), this.texturesVisible = true);
  }
  hideTextures() {
    this.material && (this.material.hideTextures(this.instanceIndex), this.texturesVisible = false);
  }
  removeSideTexture() {
    this.material && this.material.removeSideTexture(this.instanceIndex);
  }
  removeTopTexture() {
    this.material && this.material.removeTopTexture(this.instanceIndex);
  }
};
re$2 = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), H$3(ke, "MeshComponent");
var mt = ke;
a();
var ft = "#ffffff", N, Ge = class Ge2 {
  constructor(e = {}) {
    O(this, "color", ft);
    O(this, "initialColor", ft);
    O(this, "topColor");
    O(this, "initialTopColor");
    O(this, "opacity", 1);
    O(this, "height");
    Q$3(this, N);
    O(this, "outline", true);
    O(this, "texture");
    O(this, "topTexture");
    O(this, "dirty", true);
    var t, n4;
    this.color = (t = e == null ? void 0 : e.color) != null ? t : this.color, this.initialColor = this.color, this.topColor = e == null ? void 0 : e.topColor, this.initialTopColor = this.topColor, this.opacity = (n4 = e == null ? void 0 : e.opacity) != null ? n4 : this.opacity, this.height = e == null ? void 0 : e.height, this.shading = e == null ? void 0 : e.shading, this.outline = (e == null ? void 0 : e.outline) !== void 0 ? !!e.outline : this.outline;
  }
  get shading() {
    return P(this, N);
  }
  set shading(e) {
    var t;
    if (!e) {
      R$1(this, N, void 0);
      return;
    }
    R$1(this, N, (t = P(this, N)) != null ? t : { start: 0, end: 0, intensity: 0 }), Object.assign(P(this, N), e);
  }
};
N = /* @__PURE__ */ new WeakMap(), H$3(Ge, "GeometryGroupStyleComponent");
var me = Ge;
var _e = class _e2 extends fe$2 {
  constructor(t, n4 = new me()) {
    super();
    O(this, "visible", true);
    O(this, "type", "geometry-group");
    O(this, "components");
    O(this, "userData", { entityId: "", entities3D: /* @__PURE__ */ new Set(), opacity: 1, dirty: true, shadingDirty: true });
    this.components = [n4], this.userData.entityId = t;
  }
  setVisible(t) {
    this.visible !== t && (this.visible = t, this.dispatchEvent({ type: "childremoved", child: this }));
  }
  getOpacity() {
    return this.userData.opacity;
  }
  setOpacity(t) {
    this.userData.opacity = t;
  }
  removeEntity() {
    this.dispatchEvent({ type: "childremoved", child: this });
  }
  getfirstChildEntityId() {
    let t;
    for (let o4 of this.children) if (!o4.userData.detached) {
      t = o4;
      break;
    }
    return t instanceof ce$1 ? Object.values(t.userData.entities)[0] : void 0;
  }
  setAltitude(t) {
    this.position.z !== t && (this.position.z = t, this.dispatchEvent({ type: "childremoved", child: this }));
  }
  get altitude() {
    return this.position.z;
  }
};
H$3(_e, "GeometryGroupObject3D");
var M = _e;
a();
var Fe = class Fe2 extends fe$2 {
};
H$3(Fe, "Geometry2DObject3D");
var k = Fe, Re = class Re2 {
  constructor(e, t, n4 = 0) {
    O(this, "id");
    O(this, "verticalOffset");
    O(this, "occluderId");
    O(this, "object3d", new k());
    O(this, "components");
    O(this, "disposed", false);
    O(this, "worldPosition", new I$1());
    this.id = e.id || E(), this.components = [e], this.verticalOffset = n4, this.object3d = new k(), this.object3d.position.set(t.x, t.y, t.z + n4), this.object3d.userData.entityId = this.id, this.object3d.userData.type = this.type, this.positionDirty = true;
  }
  get type() {
    return this.components[0].type;
  }
  get parentObject3D() {
    return this.object3d.parent;
  }
  get attachedTo() {
    return this.object3d.userData.attachedEntityId;
  }
  get position() {
    return this.positionDirty && (this.object3d.matrixAutoUpdate = true, this.object3d.getWorldPosition(this.worldPosition), this.positionDirty = false, this.object3d.matrixAutoUpdate = false), this.worldPosition;
  }
  get positionDirty() {
    return this.object3d.userData.worldPositionDirty;
  }
  set positionDirty(e) {
    this.object3d.userData.worldPositionDirty = e;
  }
  updatePosition(e) {
    this.object3d.position.copy(e), this.positionDirty = true;
  }
  setAltitude(e) {
    this.object3d.position.z = e, this.positionDirty = true;
  }
};
H$3(Re, "Geometry2D");
var ne = Re;
a();
var Be = class Be2 extends fe$2 {
  constructor() {
    super(...arguments);
    O(this, "type", "geometry");
    O(this, "userData", { entityId: "", type: "geometry" });
  }
  raycast(t, n4) {
    this.userData.type === "model" && this.children[0] && t.intersectObject(this.children[0], true).forEach((o4) => {
      n4.push(o4);
    });
  }
};
H$3(Be, "Geometry3DObject3D");
var fe = Be, Ve = class Ve2 {
  constructor(e, t) {
    O(this, "id", E());
    O(this, "components");
    O(this, "entities2D", /* @__PURE__ */ new Map());
    this.components = [e, t];
  }
  get object3d() {
    return this.components[0].mesh;
  }
  get parentObject3D() {
    var e;
    return (e = this.components[0].mesh) == null ? void 0 : e.parent;
  }
  get type() {
    return this.components[0].type;
  }
  attach(e) {
    this.parentObject3D instanceof M ? e.object3d.userData.attachedEntityId = this.id : this.entities2D.set(e.id, e);
  }
  detach(e) {
    this.parentObject3D instanceof M && (e.object3d.userData.parentEntityId = void 0), this.entities2D.delete(e.id);
  }
  removeAllEntities() {
    for (let e of this.entities2D.values()) this.detach(e);
  }
};
H$3(Ve, "Geometry3D");
var oe = Ve;
var H$1 = class H extends fe$2 {
  constructor(t) {
    super();
    O(this, "childrenIds", /* @__PURE__ */ new Set());
    O(this, "children", []);
    O(this, "type", "group-container");
    O(this, "userData", { entityId: "", entities2D: /* @__PURE__ */ new Set(), dirty: true, occluderDirty: false, opacity: 1, computedOpacity: 1, preloadGeometry: false });
    O(this, "components", []);
    this.userData.entityId = t;
  }
  addOccluderFeature(t, n4) {
    this.userData.occluderFeature = t, this.userData.occluderId = n4, this.userData.occluderDirty = true;
  }
  addEntity(t) {
    t instanceof H ? (this.childrenIds.add(t.userData.entityId), this.add(t)) : t instanceof ne ? (this.childrenIds.add(t.id), this.add(t.object3d), this.userData.entities2D.add(t.id), t.positionDirty = true) : t instanceof M ? (this.childrenIds.add(t.userData.entityId), this.add(t)) : t instanceof oe && t.object3d && (this.childrenIds.add(t.id), this.add(t.object3d)), this.dispatchEvent({ type: "childadded", child: this });
  }
  removeEntity(t) {
    t instanceof H ? (this.childrenIds.delete(t.userData.entityId), this.remove(t)) : t instanceof ne ? (this.childrenIds.delete(t.id), this.userData.entities2D.delete(t.id), this.remove(t.object3d)) : t instanceof M ? (this.childrenIds.delete(t.userData.entityId), this.remove(t)) : t instanceof oe && t.object3d && (this.childrenIds.delete(t.id), this.add(t.object3d)), this.dispatchEvent({ type: "childremoved", child: this });
  }
  setVisible(t) {
    this.visible !== t && (this.visible = t, this.dispatchEvent({ type: "childremoved", child: this }));
  }
  setAltitude(t) {
    this.position.z !== t && (this.position.z = t, this.dispatchEvent({ type: "childremoved", child: this }), this.set2DGeometryChildrenPositionDirty());
  }
  set2DGeometryChildrenPositionDirty() {
    this.children.forEach((t) => {
      t instanceof k ? t.userData.worldPositionDirty = true : t instanceof H && t.set2DGeometryChildrenPositionDirty();
    });
  }
  get altitude() {
    return this.position.z;
  }
  setOpacity(t) {
    this.userData.opacity = t;
  }
  get opacity() {
    return this.userData.opacity;
  }
};
H$3(H$1, "GroupContainerObject3D");
var z = H$1;
a();
var Fo = { top: 0, bottom: 0, left: 0, right: 0, type: "pixel" }, pt = "mappedin";
var Ro = { ALWAYS_ON_TOP: 10 }, Bo$1 = 250, Vo$1 = "collision-worker.csp.js", jo$1 = "maplibre-worker.csp.js";
a();
function Ut(r5) {
  let e = r5.min, t = r5.max, n4 = new I$1(e.x, e.y, e.z), o4 = new I$1(t.x, e.y, e.z), a4 = new I$1(e.x, t.y, e.z), u5 = new I$1(t.x, t.y, e.z);
  return [n4, o4, a4, u5];
}
H$3(Ut, "getCornersOfBoundingBox");
a();
function dt(r5, e) {
  let t;
  return typeof e == "string" || typeof e == "number" ? (t = r5.geometry2DMap.get(e), t == null && (t = r5.geometry3DMap.get(e))) : typeof (e == null ? void 0 : e.id) == "string" || typeof (e == null ? void 0 : e.id) == "number" ? (t = r5.geometry2DMap.get(e.id), t == null && (t = r5.geometry3DMap.get(e.id))) : t = e, t;
}
H$3(dt, "getGeometryByGeometryId");
function Jo(r5, e, t = [], n4 = new Pe$3(), o4) {
  (r5.getSystems().renderSystem.threeDdirty || r5.getSystems().renderSystem.twoDdirty) && r5.renderSync();
  let a4 = dt(r5.getInternalState(), e);
  return ht(a4, t, n4, o4), t;
}
H$3(Jo, "getVerticesOfEntity");
var pe$1 = new I$1();
function ht(r5, e = [], t = new Pe$3(), n4) {
  if (r5.visible) {
    if (r5.isMesh || r5.isLine || r5.isPoints) {
      let o4 = r5.geometry;
      if (o4.isBufferGeometry) {
        let a4 = o4.attributes.position;
        for (let u5 = 0; u5 < a4.count; u5++) pe$1.fromBufferAttribute(a4, u5), n4 !== void 0 && (pe$1.z = n4), e.push(pe$1.clone()), t.expandByPoint(pe$1);
      }
    }
    for (let o4 of r5.children) ht(o4, e, t, n4);
  }
}
H$3(ht, "traverse");
a();
function Wt() {
  return typeof window > "u" ? 1 : Math.min(window.devicePixelRatio, 2);
}
H$3(Wt, "getPixelRatio");
a();
function $t$1(r5, e, t = false) {
  let n4 = null, o4 = 0;
  return function(...a4) {
    o4++, o4 === 1 && t === true && r5(...a4);
    let u5 = H$3(() => {
      (!t || o4 > 1) && r5(...a4), n4 = null, o4 = 0;
    }, "later");
    clearTimeout(n4), n4 = setTimeout(u5, e);
  };
}
H$3($t$1, "debounce");
a();
var Ht$1 = /* @__PURE__ */ (() => {
  let r5;
  return { getDeviceType() {
    if (r5) return r5;
    let { userAgent: e, platform: t, maxTouchPoints: n4 } = window.navigator, o4 = /(iphone|ipod|ipad)/i.test(e), a4 = t === "iPad" || t.indexOf("Mac") === 0 && n4 > 0 && !window.MSStream, u5 = /android/i.test(e);
    return r5 = { isIpad: a4, isMobile: u5 || o4 || a4, isSafari12: /Version\/12.+Safari/.test(e), isFirefox: /Firefox/.test(e), isWindows: /windows/i.test(e) }, r5;
  }, _reset() {
    r5 = void 0;
  } };
})(), gt = Ht$1.getDeviceType, yt = (() => {
  let r5, e, t;
  function n4() {
    if (e !== void 0) return e;
    r5 || (r5 = document.createElement("canvas"));
    let a4 = r5.getContext("webgl") || r5.getContext("experimental-webgl");
    if (!a4) return e;
    try {
      let u5 = gt().isFirefox ? null : a4.getExtension("WEBGL_debug_renderer_info");
      return e = u5 ? a4.getParameter(u5.UNMASKED_RENDERER_WEBGL) : a4.getParameter(a4.RENDERER), e;
    } catch (u5) {
      let c = new Error("Failed getting device info");
      throw c.name = "FailedGettingDeviceInfo", c;
    }
  }
  H$3(n4, "getInfo");
  function o4() {
    var u5, c;
    if (!gt().isWindows) return false;
    if (t !== void 0) return t;
    let a4 = (c = (u5 = zt()) == null ? void 0 : u5.toLowerCase()) != null ? c : "";
    return t = a4.includes("intel") && (a4.includes("uhd") || a4.includes("iris")), t;
  }
  return H$3(o4, "shouldDisableOffscreenCanvas"), { getInfo: n4, shouldDisableOffscreenCanvas: o4, _setCanvas(a4) {
    r5 = a4, e = void 0, t = void 0;
  } };
})(), zt = yt.getInfo, Kt = yt.shouldDisableOffscreenCanvas;
a();
function Yt(r5, e) {
  let t = {};
  for (let n4 = 0; n4 < e.length; n4++) {
    let o4 = e[n4];
    o4 in r5 && (t[o4] = r5[o4]);
  }
  return t;
}
H$3(Yt, "pick");
function Jt(r5) {
  return Object.keys(r5).length === 0;
}
H$3(Jt, "isEmpty");
a();
var qt = H$3((r5) => (e) => {
  if (!e.includes("mappedin")) {
    let t = {};
    for (let n4 in r5) {
      let o4 = r5[n4];
      e.includes("mappedin") || (r5[n4] = o4);
    }
    return { url: e, headers: t };
  }
  return { url: e, headers: r5 };
}, "transformRequest");
function Ti$1(r5, e, t, n4) {
  let o4 = r5 * (Math.PI / 180), a4 = n4 / j, u5 = r5 + a4 * 180 / Math.PI, c = t / j / Math.cos(o4), m5 = e + c * 180 / Math.PI;
  return { lat: u5, lon: m5 };
}
H$3(Ti$1, "cartesianToGeographic");
function Mi$1(r5, e, t, n4) {
  let o4 = t * (Math.PI / 180), a4 = n4 * (Math.PI / 180), u5 = r5 * (Math.PI / 180), c = e * (Math.PI / 180), m5 = o4 - u5, p4 = a4 - c, g = j * p4 * Math.cos(u5), h = j * m5;
  return { x: g, y: h };
}
H$3(Mi$1, "geographicToCartesian");
var Xt$1 = H$3((r5, e, t) => {
  var n4;
  if (r5.children && (r5.visible || r5 instanceof z && r5.userData.preloadGeometry)) for (let o4 of r5.children) {
    if (o4.visible && o4.type) if ("entities3D" in o4.userData && ((n4 = o4.userData) != null && n4.entities3D) && o4 instanceof M) {
      e.add(o4.userData.entityId), o4.userData.dirty && t.add(o4.userData.entityId);
      for (let a4 of o4.userData.entities3D.values()) e.add(a4);
    } else (o4.type === "group-container" || o4.type === "custom-geometry" || o4 instanceof fe) && e.add(o4.userData.entityId);
    Xt$1(o4, e, t);
  }
  return e;
}, "populateGeometry3DIdsInScene"), Zt$1 = H$3((r5, e) => {
  var t;
  if (r5.children && r5.visible && !((t = r5.userData) != null && t.hidden)) for (let n4 of r5.children) n4.visible && n4 instanceof k && e.add(n4.userData.entityId), Zt$1(n4, e);
  return e;
}, "populateGeometry2DIdsInScene");
function Qt(r5, e) {
  for (let t in e) {
    if (e[t] == null) {
      r5[t] = void 0;
      continue;
    }
    typeof e[t] == "object" ? Qt(r5[t], e[t]) : r5[t] = e[t];
  }
  return r5;
}
H$3(Qt, "mergeObjects");
function Si(r5, e, t, n4) {
  let o4 = { translateX: r5.x, translateY: r5.y, translateZ: r5.z, scale: r5.meterInMercatorCoordinateUnits() }, a4 = new Vt$2(), u5 = new I$1(o4.scale, -o4.scale, o4.scale), c = new Vt$2().makeTranslation(o4.translateX, o4.translateY, o4.translateZ).scale(u5), m5 = t.elevation;
  return { id: pt, type: "custom", renderingMode: "3d", render: H$3((p4, g) => {
    if (a4.fromArray(g), m5 !== t.elevation) {
      let h = Fe$1.fromLngLat(r5.toLngLat(), t.elevation);
      c.makeTranslation(o4.translateX, o4.translateY, -h.z).scale(u5);
    }
    e.projectionMatrix = a4.multiply(c), m5 = t.elevation, n4();
  }, "render") };
}
H$3(Si, "createCustomLayer");
function er(r5) {
  return fetch(r5, { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ grant_type: "client_credentials" }) });
}
H$3(er, "fetchToken");
async function wi2(r5) {
  let e = await er(r5), { access_token: t } = await e.json();
  return { "x-mappedin-tiles-key": t };
}
H$3(wi2, "getRequestHeaders");
function Pi$1(r5, e = 0) {
  let t = 3735928559 ^ e, n4 = 1103547991 ^ e;
  for (let o4 = 0, a4; o4 < r5.length; o4++) a4 = r5.charCodeAt(o4), t = Math.imul(t ^ a4, 2654435761), n4 = Math.imul(n4 ^ a4, 1597334677);
  return t = Math.imul(t ^ t >>> 16, 2246822507) ^ Math.imul(n4 ^ n4 >>> 13, 3266489909), n4 = Math.imul(n4 ^ n4 >>> 16, 2246822507) ^ Math.imul(t ^ t >>> 13, 3266489909), 4294967296 * (2097151 & n4) + (t >>> 0);
}
H$3(Pi$1, "cyrb53");
function Ci(r5, e, t) {
  let n4 = r5 * (Math.PI / 180) / 2, o4 = e / 2;
  return t * Math.tan(n4) / o4;
}
H$3(Ci, "getProjectionScaleFactor");
function Ii(r5) {
  return new ut$1(new ie$1(r5[0][0], r5[0][1]), new ie$1(r5[1][0], r5[1][1])).getCenter().toArray();
}
H$3(Ii, "getBoundingBoxCenter");
function Li$1(r5, e) {
  return r5 < e || e <= 12;
}
H$3(Li$1, "shouldExpandZoomLevel");
function Oi$1(r5) {
  let e = 1;
  return r5.type === "geometry-group" && r5.parent != null && r5.parent instanceof z ? e = r5.parent.userData.computedOpacity : (r5.type === "geometry" || r5.type === "custom-geometry" || r5.type === "model") && r5.parentObject3D != null && r5.parentObject3D instanceof M && r5.parentObject3D.parent != null && r5.parentObject3D.parent instanceof z && (e = r5.parentObject3D.parent.userData.computedOpacity), e;
}
H$3(Oi$1, "getGroupContainerOpacity");
function Ai(r5, e, t = 1e-10) {
  if (r5.length !== e.length) return false;
  let n4 = Math.abs(r5[0] - e[0]) < t, o4 = Math.abs(r5[1] - e[1]) < t;
  if (r5.length === 3 && e.length === 3) {
    let a4 = Math.abs(r5[2] - e[2]) < t;
    return n4 && o4 && a4;
  }
  return n4 && o4;
}
H$3(Ai, "coordinatesEqual");
var tr$1 = "maplibre-frustum-culling-hack";
function Ni() {
  let r5 = new Xi$2(0.01, 0.01, 0.01), e = new vs$1({ opacity: 0, depthWrite: false, transparent: true }), t = new ye$1(r5, e);
  return t.position.copy(new I$1(0, 50, 0)), t.frustumCulled = false, t.name = tr$1, t;
}
H$3(Ni, "maplibreFrustrumCullHack");
var G = new I$1(), bt = new ot$1();
function ki(r5, e, t = new Jl$2()) {
  return r5.traverse((n4) => {
    if (n4 instanceof ye$1) {
      let a4 = n4.geometry.attributes.position;
      if (e.position.distanceTo(n4.position) < e.near) return;
      for (let c = 0; c < a4.count; c++) G.fromBufferAttribute(a4, c), G.applyMatrix4(n4.matrixWorld), G.applyMatrix4(e.matrixWorldInverse), G.applyMatrix4(e.projectionMatrix), G.z < 1 && G.z > 0 && (bt.set(G.x, G.y), t.expandByPoint(bt));
    }
  }), t;
}
H$3(ki, "projectToBox2D");
function xt(r5, e) {
  let t = e.clientWidth, n4 = e.clientHeight;
  return new ot$1((r5.x + 1) * t / 2, (1 - r5.y) * n4 / 2);
}
H$3(xt, "ndcToScreen");
function Gi(r5, e, t) {
  let n4 = document.createElement("div");
  n4.style.position = "absolute", n4.style.border = "2px solid ".concat(e), n4.style.pointerEvents = "none";
  let o4 = xt(new ot$1(r5.min.x, r5.min.y), t), a4 = xt(new ot$1(r5.max.x, r5.max.y), t);
  n4.style.left = "".concat(o4.x, "px"), n4.style.top = "".concat(a4.y, "px");
  let u5 = Math.abs(a4.x - o4.x), c = Math.abs(a4.y - o4.y);
  return n4.style.width = "".concat(u5, "px"), n4.style.height = "".concat(c, "px"), t.appendChild(n4), n4;
}
H$3(Gi, "drawProjectedBox");
a();
var Ue = class Ue2 {
  constructor(e) {
    O(this, "visible");
    O(this, "altitude");
    O(this, "color");
    O(this, "dirty", true);
    O(this, "maxWidth");
    O(this, "maxHeight");
    O(this, "hoverByPolygon");
    O(this, "flipToFaceCamera", vt.flipToFaceCamera);
    O(this, "font");
    O(this, "fillOpacity");
    O(this, "fontSize");
    O(this, "margin");
    O(this, "outlineWidth");
    O(this, "outlineBlur");
    O(this, "outlineOffsetX");
    O(this, "strokeColor");
    O(this, "strokeOpacity");
    O(this, "strokeWidth");
    O(this, "hoverColor");
    O(this, "outlineOffsetY");
    O(this, "outlineColor");
    O(this, "outlineOpacity");
    e && Object.assign(this, e);
  }
  getState(e = false) {
    let t = {};
    for (let n4 in this) !e && n4 === "dirty" || this[n4] !== void 0 && (t[n4] = this[n4]);
    return t;
  }
};
H$3(Ue, "Text3DStyleComponent");
var je = Ue, vt = Object.freeze({ visible: true, color: "black", flipToFaceCamera: true, fillOpacity: 1, font: void 0, fontSize: 2, margin: [0.2, 1, 0.2, 1.5], outlineColor: "black", outlineOpacity: 1, outlineWidth: 0, outlineOffsetX: 0, outlineOffsetY: 0, outlineBlur: 0, strokeOpacity: 1, strokeWidth: 0, maxWidth: void 0, maxHeight: void 0, strokeColor: "black", hoverColor: void 0 });
a();
a();
var $e = class $e2 {
  constructor(e) {
    O(this, "dirty", true);
    O(this, "visible", true);
    O(this, "opacity", 1);
    O(this, "verticalOffset", 0);
    O(this, "interactive", false);
    O(this, "color");
    O(this, "material");
    O(this, "rotation");
    O(this, "scale");
    e && Object.assign(this, e);
  }
};
H$3($e, "ModelStyleComponnet");
var We = $e;
a();
var rr = [1, 1, 1], nr = [0, 0, 0];
var nv = L((t$, SP2) => {
  a();
  var CP2 = Object.getOwnPropertySymbols, sA2 = Object.prototype.hasOwnProperty, aA2 = Object.prototype.propertyIsEnumerable;
  function lA2(r5) {
    if (r5 == null) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(r5);
  }
  H$3(lA2, "toObject");
  function uA2() {
    try {
      if (!Object.assign) return false;
      var r5 = new String("abc");
      if (r5[5] = "de", Object.getOwnPropertyNames(r5)[0] === "5") return false;
      for (var t = {}, e = 0; e < 10; e++) t["_" + String.fromCharCode(e)] = e;
      var n4 = Object.getOwnPropertyNames(t).map(function(a4) {
        return t[a4];
      });
      if (n4.join("") !== "0123456789") return false;
      var i = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(a4) {
        i[a4] = a4;
      }), Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst";
    } catch (a4) {
      return false;
    }
  }
  H$3(uA2, "shouldUseNative");
  SP2.exports = uA2() ? Object.assign : function(r5, t) {
    for (var e, n4 = lA2(r5), i, a4 = 1; a4 < arguments.length; a4++) {
      e = Object(arguments[a4]);
      for (var u5 in e) sA2.call(e, u5) && (n4[u5] = e[u5]);
      if (CP2) {
        i = CP2(e);
        for (var h = 0; h < i.length; h++) aA2.call(e, i[h]) && (n4[i[h]] = e[i[h]]);
      }
    }
    return n4;
  };
});
var b_ = L((y_2, v_2) => {
  a();
  (function(r5, t) {
    typeof y_2 == "object" && typeof v_2 < "u" ? v_2.exports = t() : typeof define == "function" && define.amd ? define(t) : (r5 = r5 || self).RBush = t();
  })(y_2, function() {
    function r5(T3, D4, A3, L3, B3) {
      H$3(function j3(W4, $5, F3, J4, ot2) {
        for (; J4 > F3; ) {
          if (J4 - F3 > 600) {
            var K4 = J4 - F3 + 1, H5 = $5 - F3 + 1, _t2 = Math.log(K4), ct2 = 0.5 * Math.exp(2 * _t2 / 3), ft2 = 0.5 * Math.sqrt(_t2 * ct2 * (K4 - ct2) / K4) * (H5 - K4 / 2 < 0 ? -1 : 1), mt2 = Math.max(F3, Math.floor($5 - H5 * ct2 / K4 + ft2)), St2 = Math.min(J4, Math.floor($5 + (K4 - H5) * ct2 / K4 + ft2));
            j3(W4, $5, mt2, St2, ot2);
          }
          var dt2 = W4[$5], xt2 = F3, q4 = J4;
          for (t(W4, F3, $5), ot2(W4[J4], dt2) > 0 && t(W4, F3, J4); xt2 < q4; ) {
            for (t(W4, xt2, q4), xt2++, q4--; ot2(W4[xt2], dt2) < 0; ) xt2++;
            for (; ot2(W4[q4], dt2) > 0; ) q4--;
          }
          ot2(W4[F3], dt2) === 0 ? t(W4, F3, q4) : t(W4, ++q4, J4), q4 <= $5 && (F3 = q4 + 1), $5 <= q4 && (J4 = q4 - 1);
        }
      }, "t")(T3, D4, A3 || 0, L3 || T3.length - 1, B3 || e);
    }
    H$3(r5, "t");
    function t(T3, D4, A3) {
      var L3 = T3[D4];
      T3[D4] = T3[A3], T3[A3] = L3;
    }
    H$3(t, "i");
    function e(T3, D4) {
      return T3 < D4 ? -1 : T3 > D4 ? 1 : 0;
    }
    H$3(e, "n");
    var n4 = H$3(function(T3) {
      T3 === void 0 && (T3 = 9), this._maxEntries = Math.max(4, T3), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    }, "r");
    function i(T3, D4, A3) {
      if (!A3) return D4.indexOf(T3);
      for (var L3 = 0; L3 < D4.length; L3++) if (A3(T3, D4[L3])) return L3;
      return -1;
    }
    H$3(i, "e");
    function a4(T3, D4) {
      u5(T3, 0, T3.children.length, D4, T3);
    }
    H$3(a4, "a");
    function u5(T3, D4, A3, L3, B3) {
      B3 || (B3 = w3(null)), B3.minX = 1 / 0, B3.minY = 1 / 0, B3.maxX = -1 / 0, B3.maxY = -1 / 0;
      for (var j3 = D4; j3 < A3; j3++) {
        var W4 = T3.children[j3];
        h(B3, T3.leaf ? L3(W4) : W4);
      }
      return B3;
    }
    H$3(u5, "h");
    function h(T3, D4) {
      return T3.minX = Math.min(T3.minX, D4.minX), T3.minY = Math.min(T3.minY, D4.minY), T3.maxX = Math.max(T3.maxX, D4.maxX), T3.maxY = Math.max(T3.maxY, D4.maxY), T3;
    }
    H$3(h, "o");
    function d(T3, D4) {
      return T3.minX - D4.minX;
    }
    H$3(d, "s");
    function m5(T3, D4) {
      return T3.minY - D4.minY;
    }
    H$3(m5, "l");
    function v3(T3) {
      return (T3.maxX - T3.minX) * (T3.maxY - T3.minY);
    }
    H$3(v3, "f");
    function x2(T3) {
      return T3.maxX - T3.minX + (T3.maxY - T3.minY);
    }
    H$3(x2, "u");
    function S4(T3, D4) {
      return T3.minX <= D4.minX && T3.minY <= D4.minY && D4.maxX <= T3.maxX && D4.maxY <= T3.maxY;
    }
    H$3(S4, "m");
    function I3(T3, D4) {
      return D4.minX <= T3.maxX && D4.minY <= T3.maxY && D4.maxX >= T3.minX && D4.maxY >= T3.minY;
    }
    H$3(I3, "c");
    function w3(T3) {
      return { children: T3, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    H$3(w3, "p");
    function E4(T3, D4, A3, L3, B3) {
      for (var j3 = [D4, A3]; j3.length; ) if (!((A3 = j3.pop()) - (D4 = j3.pop()) <= L3)) {
        var W4 = D4 + Math.ceil((A3 - D4) / L3 / 2) * L3;
        r5(T3, W4, D4, A3, B3), j3.push(D4, W4, W4, A3);
      }
    }
    return H$3(E4, "d"), n4.prototype.all = function() {
      return this._all(this.data, []);
    }, n4.prototype.search = function(T3) {
      var D4 = this.data, A3 = [];
      if (!I3(T3, D4)) return A3;
      for (var L3 = this.toBBox, B3 = []; D4; ) {
        for (var j3 = 0; j3 < D4.children.length; j3++) {
          var W4 = D4.children[j3], $5 = D4.leaf ? L3(W4) : W4;
          I3(T3, $5) && (D4.leaf ? A3.push(W4) : S4(T3, $5) ? this._all(W4, A3) : B3.push(W4));
        }
        D4 = B3.pop();
      }
      return A3;
    }, n4.prototype.collides = function(T3) {
      var D4 = this.data;
      if (!I3(T3, D4)) return false;
      for (var A3 = []; D4; ) {
        for (var L3 = 0; L3 < D4.children.length; L3++) {
          var B3 = D4.children[L3], j3 = D4.leaf ? this.toBBox(B3) : B3;
          if (I3(T3, j3)) {
            if (D4.leaf || S4(T3, j3)) return true;
            A3.push(B3);
          }
        }
        D4 = A3.pop();
      }
      return false;
    }, n4.prototype.load = function(T3) {
      if (!T3 || !T3.length) return this;
      if (T3.length < this._minEntries) {
        for (var D4 = 0; D4 < T3.length; D4++) this.insert(T3[D4]);
        return this;
      }
      var A3 = this._build(T3.slice(), 0, T3.length - 1, 0);
      if (this.data.children.length) if (this.data.height === A3.height) this._splitRoot(this.data, A3);
      else {
        if (this.data.height < A3.height) {
          var L3 = this.data;
          this.data = A3, A3 = L3;
        }
        this._insert(A3, this.data.height - A3.height - 1, true);
      }
      else this.data = A3;
      return this;
    }, n4.prototype.insert = function(T3) {
      return T3 && this._insert(T3, this.data.height - 1), this;
    }, n4.prototype.clear = function() {
      return this.data = w3([]), this;
    }, n4.prototype.remove = function(T3, D4) {
      if (!T3) return this;
      for (var A3, L3, B3, j3 = this.data, W4 = this.toBBox(T3), $5 = [], F3 = []; j3 || $5.length; ) {
        if (j3 || (j3 = $5.pop(), L3 = $5[$5.length - 1], A3 = F3.pop(), B3 = true), j3.leaf) {
          var J4 = i(T3, j3.children, D4);
          if (J4 !== -1) return j3.children.splice(J4, 1), $5.push(j3), this._condense($5), this;
        }
        B3 || j3.leaf || !S4(j3, W4) ? L3 ? (A3++, j3 = L3.children[A3], B3 = false) : j3 = null : ($5.push(j3), F3.push(A3), A3 = 0, L3 = j3, j3 = j3.children[0]);
      }
      return this;
    }, n4.prototype.toBBox = function(T3) {
      return T3;
    }, n4.prototype.compareMinX = function(T3, D4) {
      return T3.minX - D4.minX;
    }, n4.prototype.compareMinY = function(T3, D4) {
      return T3.minY - D4.minY;
    }, n4.prototype.toJSON = function() {
      return this.data;
    }, n4.prototype.fromJSON = function(T3) {
      return this.data = T3, this;
    }, n4.prototype._all = function(T3, D4) {
      for (var A3 = []; T3; ) T3.leaf ? D4.push.apply(D4, T3.children) : A3.push.apply(A3, T3.children), T3 = A3.pop();
      return D4;
    }, n4.prototype._build = function(T3, D4, A3, L3) {
      var B3, j3 = A3 - D4 + 1, W4 = this._maxEntries;
      if (j3 <= W4) return a4(B3 = w3(T3.slice(D4, A3 + 1)), this.toBBox), B3;
      L3 || (L3 = Math.ceil(Math.log(j3) / Math.log(W4)), W4 = Math.ceil(j3 / Math.pow(W4, L3 - 1))), (B3 = w3([])).leaf = false, B3.height = L3;
      var $5 = Math.ceil(j3 / W4), F3 = $5 * Math.ceil(Math.sqrt(W4));
      E4(T3, D4, A3, F3, this.compareMinX);
      for (var J4 = D4; J4 <= A3; J4 += F3) {
        var ot2 = Math.min(J4 + F3 - 1, A3);
        E4(T3, J4, ot2, $5, this.compareMinY);
        for (var K4 = J4; K4 <= ot2; K4 += $5) {
          var H5 = Math.min(K4 + $5 - 1, ot2);
          B3.children.push(this._build(T3, K4, H5, L3 - 1));
        }
      }
      return a4(B3, this.toBBox), B3;
    }, n4.prototype._chooseSubtree = function(T3, D4, A3, L3) {
      for (; L3.push(D4), !D4.leaf && L3.length - 1 !== A3; ) {
        for (var B3 = 1 / 0, j3 = 1 / 0, W4 = void 0, $5 = 0; $5 < D4.children.length; $5++) {
          var F3 = D4.children[$5], J4 = v3(F3), ot2 = (K4 = T3, H5 = F3, (Math.max(H5.maxX, K4.maxX) - Math.min(H5.minX, K4.minX)) * (Math.max(H5.maxY, K4.maxY) - Math.min(H5.minY, K4.minY)) - J4);
          ot2 < j3 ? (j3 = ot2, B3 = J4 < B3 ? J4 : B3, W4 = F3) : ot2 === j3 && J4 < B3 && (B3 = J4, W4 = F3);
        }
        D4 = W4 || D4.children[0];
      }
      var K4, H5;
      return D4;
    }, n4.prototype._insert = function(T3, D4, A3) {
      var L3 = A3 ? T3 : this.toBBox(T3), B3 = [], j3 = this._chooseSubtree(L3, this.data, D4, B3);
      for (j3.children.push(T3), h(j3, L3); D4 >= 0 && B3[D4].children.length > this._maxEntries; ) this._split(B3, D4), D4--;
      this._adjustParentBBoxes(L3, B3, D4);
    }, n4.prototype._split = function(T3, D4) {
      var A3 = T3[D4], L3 = A3.children.length, B3 = this._minEntries;
      this._chooseSplitAxis(A3, B3, L3);
      var j3 = this._chooseSplitIndex(A3, B3, L3), W4 = w3(A3.children.splice(j3, A3.children.length - j3));
      W4.height = A3.height, W4.leaf = A3.leaf, a4(A3, this.toBBox), a4(W4, this.toBBox), D4 ? T3[D4 - 1].children.push(W4) : this._splitRoot(A3, W4);
    }, n4.prototype._splitRoot = function(T3, D4) {
      this.data = w3([T3, D4]), this.data.height = T3.height + 1, this.data.leaf = false, a4(this.data, this.toBBox);
    }, n4.prototype._chooseSplitIndex = function(T3, D4, A3) {
      for (var L3, B3, j3, W4, $5, F3, J4, ot2 = 1 / 0, K4 = 1 / 0, H5 = D4; H5 <= A3 - D4; H5++) {
        var _t2 = u5(T3, 0, H5, this.toBBox), ct2 = u5(T3, H5, A3, this.toBBox), ft2 = (B3 = _t2, j3 = ct2, W4 = void 0, $5 = void 0, F3 = void 0, J4 = void 0, W4 = Math.max(B3.minX, j3.minX), $5 = Math.max(B3.minY, j3.minY), F3 = Math.min(B3.maxX, j3.maxX), J4 = Math.min(B3.maxY, j3.maxY), Math.max(0, F3 - W4) * Math.max(0, J4 - $5)), mt2 = v3(_t2) + v3(ct2);
        ft2 < ot2 ? (ot2 = ft2, L3 = H5, K4 = mt2 < K4 ? mt2 : K4) : ft2 === ot2 && mt2 < K4 && (K4 = mt2, L3 = H5);
      }
      return L3 || A3 - D4;
    }, n4.prototype._chooseSplitAxis = function(T3, D4, A3) {
      var L3 = T3.leaf ? this.compareMinX : d, B3 = T3.leaf ? this.compareMinY : m5;
      this._allDistMargin(T3, D4, A3, L3) < this._allDistMargin(T3, D4, A3, B3) && T3.children.sort(L3);
    }, n4.prototype._allDistMargin = function(T3, D4, A3, L3) {
      T3.children.sort(L3);
      for (var B3 = this.toBBox, j3 = u5(T3, 0, D4, B3), W4 = u5(T3, A3 - D4, A3, B3), $5 = x2(j3) + x2(W4), F3 = D4; F3 < A3 - D4; F3++) {
        var J4 = T3.children[F3];
        h(j3, T3.leaf ? B3(J4) : J4), $5 += x2(j3);
      }
      for (var ot2 = A3 - D4 - 1; ot2 >= D4; ot2--) {
        var K4 = T3.children[ot2];
        h(W4, T3.leaf ? B3(K4) : K4), $5 += x2(W4);
      }
      return $5;
    }, n4.prototype._adjustParentBBoxes = function(T3, D4, A3) {
      for (var L3 = A3; L3 >= 0; L3--) h(D4[L3], T3);
    }, n4.prototype._condense = function(T3) {
      for (var D4 = T3.length - 1, A3 = void 0; D4 >= 0; D4--) T3[D4].children.length === 0 ? D4 > 0 ? (A3 = T3[D4 - 1].children).splice(A3.indexOf(T3[D4]), 1) : this.clear() : a4(T3[D4], this.toBBox);
    }, n4;
  });
});
var MP = L((h$, IP2) => {
  a();
  IP2.exports = H$3(function(t, e, n4, i) {
    var a4 = t[0], u5 = t[1], h = false;
    n4 === void 0 && (n4 = 0), i === void 0 && (i = e.length);
    for (var d = (i - n4) / 2, m5 = 0, v3 = d - 1; m5 < d; v3 = m5++) {
      var x2 = e[n4 + m5 * 2 + 0], S4 = e[n4 + m5 * 2 + 1], I3 = e[n4 + v3 * 2 + 0], w3 = e[n4 + v3 * 2 + 1], E4 = S4 > u5 != w3 > u5 && a4 < (I3 - x2) * (u5 - S4) / (w3 - S4) + x2;
      E4 && (h = !h);
    }
    return h;
  }, "pointInPolygonFlat");
});
var wP = L((m$, TP2) => {
  a();
  TP2.exports = H$3(function(t, e, n4, i) {
    var a4 = t[0], u5 = t[1], h = false;
    n4 === void 0 && (n4 = 0), i === void 0 && (i = e.length);
    for (var d = i - n4, m5 = 0, v3 = d - 1; m5 < d; v3 = m5++) {
      var x2 = e[m5 + n4][0], S4 = e[m5 + n4][1], I3 = e[v3 + n4][0], w3 = e[v3 + n4][1], E4 = S4 > u5 != w3 > u5 && a4 < (I3 - x2) * (u5 - S4) / (w3 - S4) + x2;
      E4 && (h = !h);
    }
    return h;
  }, "pointInPolygonNested");
});
var OP = L((v$, ov2) => {
  a();
  var PP2 = MP(), EP2 = wP();
  ov2.exports = H$3(function(t, e, n4, i) {
    return e.length > 0 && Array.isArray(e[0]) ? EP2(t, e, n4, i) : PP2(t, e, n4, i);
  }, "pointInPolygon");
  ov2.exports.nested = EP2;
  ov2.exports.flat = PP2;
});
var LP = L((sv2, DP2) => {
  a();
  (function(r5, t) {
    typeof sv2 == "object" && typeof DP2 < "u" ? t(sv2) : typeof define == "function" && define.amd ? define(["exports"], t) : t((r5 = r5 || self).predicates = {});
  })(sv2, function(r5) {
    let e = 33306690738754706e-32;
    function n4(I3, w3, E4, T3, D4) {
      let A3, L3, B3, j3, W4 = w3[0], $5 = T3[0], F3 = 0, J4 = 0;
      $5 > W4 == $5 > -W4 ? (A3 = W4, W4 = w3[++F3]) : (A3 = $5, $5 = T3[++J4]);
      let ot2 = 0;
      if (F3 < I3 && J4 < E4) for ($5 > W4 == $5 > -W4 ? (B3 = A3 - ((L3 = W4 + A3) - W4), W4 = w3[++F3]) : (B3 = A3 - ((L3 = $5 + A3) - $5), $5 = T3[++J4]), A3 = L3, B3 !== 0 && (D4[ot2++] = B3); F3 < I3 && J4 < E4; ) $5 > W4 == $5 > -W4 ? (B3 = A3 - ((L3 = A3 + W4) - (j3 = L3 - A3)) + (W4 - j3), W4 = w3[++F3]) : (B3 = A3 - ((L3 = A3 + $5) - (j3 = L3 - A3)) + ($5 - j3), $5 = T3[++J4]), A3 = L3, B3 !== 0 && (D4[ot2++] = B3);
      for (; F3 < I3; ) B3 = A3 - ((L3 = A3 + W4) - (j3 = L3 - A3)) + (W4 - j3), W4 = w3[++F3], A3 = L3, B3 !== 0 && (D4[ot2++] = B3);
      for (; J4 < E4; ) B3 = A3 - ((L3 = A3 + $5) - (j3 = L3 - A3)) + ($5 - j3), $5 = T3[++J4], A3 = L3, B3 !== 0 && (D4[ot2++] = B3);
      return A3 === 0 && ot2 !== 0 || (D4[ot2++] = A3), ot2;
    }
    H$3(n4, "r");
    function i(I3) {
      return new Float64Array(I3);
    }
    H$3(i, "o");
    let a4 = 33306690738754716e-32, u5 = 22204460492503146e-32, h = 11093356479670487e-47, d = i(4), m5 = i(8), v3 = i(12), x2 = i(16), S4 = i(4);
    r5.orient2d = function(I3, w3, E4, T3, D4, A3) {
      let L3 = (w3 - A3) * (E4 - D4), B3 = (I3 - D4) * (T3 - A3), j3 = L3 - B3;
      if (L3 === 0 || B3 === 0 || L3 > 0 != B3 > 0) return j3;
      let W4 = Math.abs(L3 + B3);
      return Math.abs(j3) >= a4 * W4 ? j3 : -(function($5, F3, J4, ot2, K4, H5, _t2) {
        let ct2, ft2, mt2, St2, dt2, xt2, q4, ee2, Gt2, Kt2, It2, ie2, vr2, Qe2, Nt2, At2, Ct2, _e3, de2 = $5 - K4, qr2 = J4 - K4, me2 = F3 - H5, Se2 = ot2 - H5;
        dt2 = (Nt2 = (ee2 = de2 - (q4 = (xt2 = 134217729 * de2) - (xt2 - de2))) * (Kt2 = Se2 - (Gt2 = (xt2 = 134217729 * Se2) - (xt2 - Se2))) - ((Qe2 = de2 * Se2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2)) - (It2 = Nt2 - (Ct2 = (ee2 = me2 - (q4 = (xt2 = 134217729 * me2) - (xt2 - me2))) * (Kt2 = qr2 - (Gt2 = (xt2 = 134217729 * qr2) - (xt2 - qr2))) - ((At2 = me2 * qr2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2))), d[0] = Nt2 - (It2 + dt2) + (dt2 - Ct2), dt2 = (vr2 = Qe2 - ((ie2 = Qe2 + It2) - (dt2 = ie2 - Qe2)) + (It2 - dt2)) - (It2 = vr2 - At2), d[1] = vr2 - (It2 + dt2) + (dt2 - At2), dt2 = (_e3 = ie2 + It2) - ie2, d[2] = ie2 - (_e3 - dt2) + (It2 - dt2), d[3] = _e3;
        let br2 = (function(co2, Ji2) {
          let po2 = Ji2[0];
          for (let En2 = 1; En2 < co2; En2++) po2 += Ji2[En2];
          return po2;
        })(4, d), Wr2 = u5 * _t2;
        if (br2 >= Wr2 || -br2 >= Wr2 || (ct2 = $5 - (de2 + (dt2 = $5 - de2)) + (dt2 - K4), mt2 = J4 - (qr2 + (dt2 = J4 - qr2)) + (dt2 - K4), ft2 = F3 - (me2 + (dt2 = F3 - me2)) + (dt2 - H5), St2 = ot2 - (Se2 + (dt2 = ot2 - Se2)) + (dt2 - H5), ct2 === 0 && ft2 === 0 && mt2 === 0 && St2 === 0) || (Wr2 = h * _t2 + e * Math.abs(br2), (br2 += de2 * St2 + Se2 * ct2 - (me2 * mt2 + qr2 * ft2)) >= Wr2 || -br2 >= Wr2)) return br2;
        dt2 = (Nt2 = (ee2 = ct2 - (q4 = (xt2 = 134217729 * ct2) - (xt2 - ct2))) * (Kt2 = Se2 - (Gt2 = (xt2 = 134217729 * Se2) - (xt2 - Se2))) - ((Qe2 = ct2 * Se2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2)) - (It2 = Nt2 - (Ct2 = (ee2 = ft2 - (q4 = (xt2 = 134217729 * ft2) - (xt2 - ft2))) * (Kt2 = qr2 - (Gt2 = (xt2 = 134217729 * qr2) - (xt2 - qr2))) - ((At2 = ft2 * qr2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2))), S4[0] = Nt2 - (It2 + dt2) + (dt2 - Ct2), dt2 = (vr2 = Qe2 - ((ie2 = Qe2 + It2) - (dt2 = ie2 - Qe2)) + (It2 - dt2)) - (It2 = vr2 - At2), S4[1] = vr2 - (It2 + dt2) + (dt2 - At2), dt2 = (_e3 = ie2 + It2) - ie2, S4[2] = ie2 - (_e3 - dt2) + (It2 - dt2), S4[3] = _e3;
        let $i2 = n4(4, d, 4, S4, m5);
        dt2 = (Nt2 = (ee2 = de2 - (q4 = (xt2 = 134217729 * de2) - (xt2 - de2))) * (Kt2 = St2 - (Gt2 = (xt2 = 134217729 * St2) - (xt2 - St2))) - ((Qe2 = de2 * St2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2)) - (It2 = Nt2 - (Ct2 = (ee2 = me2 - (q4 = (xt2 = 134217729 * me2) - (xt2 - me2))) * (Kt2 = mt2 - (Gt2 = (xt2 = 134217729 * mt2) - (xt2 - mt2))) - ((At2 = me2 * mt2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2))), S4[0] = Nt2 - (It2 + dt2) + (dt2 - Ct2), dt2 = (vr2 = Qe2 - ((ie2 = Qe2 + It2) - (dt2 = ie2 - Qe2)) + (It2 - dt2)) - (It2 = vr2 - At2), S4[1] = vr2 - (It2 + dt2) + (dt2 - At2), dt2 = (_e3 = ie2 + It2) - ie2, S4[2] = ie2 - (_e3 - dt2) + (It2 - dt2), S4[3] = _e3;
        let Yt2 = n4($i2, m5, 4, S4, v3);
        dt2 = (Nt2 = (ee2 = ct2 - (q4 = (xt2 = 134217729 * ct2) - (xt2 - ct2))) * (Kt2 = St2 - (Gt2 = (xt2 = 134217729 * St2) - (xt2 - St2))) - ((Qe2 = ct2 * St2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2)) - (It2 = Nt2 - (Ct2 = (ee2 = ft2 - (q4 = (xt2 = 134217729 * ft2) - (xt2 - ft2))) * (Kt2 = mt2 - (Gt2 = (xt2 = 134217729 * mt2) - (xt2 - mt2))) - ((At2 = ft2 * mt2) - q4 * Gt2 - ee2 * Gt2 - q4 * Kt2))), S4[0] = Nt2 - (It2 + dt2) + (dt2 - Ct2), dt2 = (vr2 = Qe2 - ((ie2 = Qe2 + It2) - (dt2 = ie2 - Qe2)) + (It2 - dt2)) - (It2 = vr2 - At2), S4[1] = vr2 - (It2 + dt2) + (dt2 - At2), dt2 = (_e3 = ie2 + It2) - ie2, S4[2] = ie2 - (_e3 - dt2) + (It2 - dt2), S4[3] = _e3;
        let mr2 = n4(Yt2, v3, 4, S4, x2);
        return x2[mr2 - 1];
      })(I3, w3, E4, T3, D4, A3, W4);
    }, r5.orient2dfast = function(I3, w3, E4, T3, D4, A3) {
      return (w3 - A3) * (E4 - D4) - (I3 - D4) * (T3 - A3);
    }, Object.defineProperty(r5, "__esModule", { value: true });
  });
});
var BP = L((S$, S_2) => {
  a();
  var AP2 = b_(), lv2 = m$1(), pA2 = OP(), hA2 = LP().orient2d;
  lv2.default && (lv2 = lv2.default);
  S_2.exports = FP2;
  S_2.exports.default = FP2;
  function FP2(r5, t, e) {
    t = Math.max(0, t === void 0 ? 2 : t), e = e || 0;
    var n4 = yA2(r5), i = new AP2(16);
    i.toBBox = function(A3) {
      return { minX: A3[0], minY: A3[1], maxX: A3[0], maxY: A3[1] };
    }, i.compareMinX = function(A3, L3) {
      return A3[0] - L3[0];
    }, i.compareMinY = function(A3, L3) {
      return A3[1] - L3[1];
    }, i.load(r5);
    for (var a4 = [], u5 = 0, h; u5 < n4.length; u5++) {
      var d = n4[u5];
      i.remove(d), h = RP2(d, h), a4.push(h);
    }
    var m5 = new AP2(16);
    for (u5 = 0; u5 < a4.length; u5++) m5.insert(x_2(a4[u5]));
    for (var v3 = t * t, x2 = e * e; a4.length; ) {
      var S4 = a4.shift(), I3 = S4.p, w3 = S4.next.p, E4 = __2(I3, w3);
      if (!(E4 < x2)) {
        var T3 = E4 / v3;
        d = fA2(i, S4.prev.p, I3, w3, S4.next.next.p, T3, m5), d && Math.min(__2(d, I3), __2(d, w3)) <= T3 && (a4.push(S4), a4.push(RP2(d, S4)), i.remove(d), m5.remove(S4), m5.insert(x_2(S4)), m5.insert(x_2(S4.next)));
      }
    }
    S4 = h;
    var D4 = [];
    do
      D4.push(S4.p), S4 = S4.next;
    while (S4 !== h);
    return D4.push(S4.p), D4;
  }
  H$3(FP2, "concaveman");
  function fA2(r5, t, e, n4, i, a4, u5) {
    for (var h = new lv2([], dA2), d = r5.data; d; ) {
      for (var m5 = 0; m5 < d.children.length; m5++) {
        var v3 = d.children[m5], x2 = d.leaf ? C_2(v3, e, n4) : mA2(e, n4, v3);
        x2 > a4 || h.push({ node: v3, dist: x2 });
      }
      for (; h.length && !h.peek().node.children; ) {
        var S4 = h.pop(), I3 = S4.node, w3 = C_2(I3, t, e), E4 = C_2(I3, n4, i);
        if (S4.dist < w3 && S4.dist < E4 && kP2(e, I3, u5) && kP2(n4, I3, u5)) return I3;
      }
      d = h.pop(), d && (d = d.node);
    }
    return null;
  }
  H$3(fA2, "findCandidate");
  function dA2(r5, t) {
    return r5.dist - t.dist;
  }
  H$3(dA2, "compareDist");
  function mA2(r5, t, e) {
    if (NP2(r5, e) || NP2(t, e)) return 0;
    var n4 = av2(r5[0], r5[1], t[0], t[1], e.minX, e.minY, e.maxX, e.minY);
    if (n4 === 0) return 0;
    var i = av2(r5[0], r5[1], t[0], t[1], e.minX, e.minY, e.minX, e.maxY);
    if (i === 0) return 0;
    var a4 = av2(r5[0], r5[1], t[0], t[1], e.maxX, e.minY, e.maxX, e.maxY);
    if (a4 === 0) return 0;
    var u5 = av2(r5[0], r5[1], t[0], t[1], e.minX, e.maxY, e.maxX, e.maxY);
    return u5 === 0 ? 0 : Math.min(n4, i, a4, u5);
  }
  H$3(mA2, "sqSegBoxDist");
  function NP2(r5, t) {
    return r5[0] >= t.minX && r5[0] <= t.maxX && r5[1] >= t.minY && r5[1] <= t.maxY;
  }
  H$3(NP2, "inside");
  function kP2(r5, t, e) {
    for (var n4 = Math.min(r5[0], t[0]), i = Math.min(r5[1], t[1]), a4 = Math.max(r5[0], t[0]), u5 = Math.max(r5[1], t[1]), h = e.search({ minX: n4, minY: i, maxX: a4, maxY: u5 }), d = 0; d < h.length; d++) if (gA2(h[d].p, h[d].next.p, r5, t)) return false;
    return true;
  }
  H$3(kP2, "noIntersections");
  function Zf3(r5, t, e) {
    return hA2(r5[0], r5[1], t[0], t[1], e[0], e[1]);
  }
  H$3(Zf3, "cross");
  function gA2(r5, t, e, n4) {
    return r5 !== n4 && t !== e && Zf3(r5, t, e) > 0 != Zf3(r5, t, n4) > 0 && Zf3(e, n4, r5) > 0 != Zf3(e, n4, t) > 0;
  }
  H$3(gA2, "intersects");
  function x_2(r5) {
    var t = r5.p, e = r5.next.p;
    return r5.minX = Math.min(t[0], e[0]), r5.minY = Math.min(t[1], e[1]), r5.maxX = Math.max(t[0], e[0]), r5.maxY = Math.max(t[1], e[1]), r5;
  }
  H$3(x_2, "updateBBox");
  function yA2(r5) {
    for (var t = r5[0], e = r5[0], n4 = r5[0], i = r5[0], a4 = 0; a4 < r5.length; a4++) {
      var u5 = r5[a4];
      u5[0] < t[0] && (t = u5), u5[0] > n4[0] && (n4 = u5), u5[1] < e[1] && (e = u5), u5[1] > i[1] && (i = u5);
    }
    var h = [t, e, n4, i], d = h.slice();
    for (a4 = 0; a4 < r5.length; a4++) pA2(r5[a4], h) || d.push(r5[a4]);
    return bA2(d);
  }
  H$3(yA2, "fastConvexHull");
  function RP2(r5, t) {
    var e = { p: r5, prev: null, next: null, minX: 0, minY: 0, maxX: 0, maxY: 0 };
    return t ? (e.next = t.next, e.prev = t, t.next.prev = e, t.next = e) : (e.prev = e, e.next = e), e;
  }
  H$3(RP2, "insertNode");
  function __2(r5, t) {
    var e = r5[0] - t[0], n4 = r5[1] - t[1];
    return e * e + n4 * n4;
  }
  H$3(__2, "getSqDist");
  function C_2(r5, t, e) {
    var n4 = t[0], i = t[1], a4 = e[0] - n4, u5 = e[1] - i;
    if (a4 !== 0 || u5 !== 0) {
      var h = ((r5[0] - n4) * a4 + (r5[1] - i) * u5) / (a4 * a4 + u5 * u5);
      h > 1 ? (n4 = e[0], i = e[1]) : h > 0 && (n4 += a4 * h, i += u5 * h);
    }
    return a4 = r5[0] - n4, u5 = r5[1] - i, a4 * a4 + u5 * u5;
  }
  H$3(C_2, "sqSegDist");
  function av2(r5, t, e, n4, i, a4, u5, h) {
    var d = e - r5, m5 = n4 - t, v3 = u5 - i, x2 = h - a4, S4 = r5 - i, I3 = t - a4, w3 = d * d + m5 * m5, E4 = d * v3 + m5 * x2, T3 = v3 * v3 + x2 * x2, D4 = d * S4 + m5 * I3, A3 = v3 * S4 + x2 * I3, L3 = w3 * T3 - E4 * E4, B3, j3, W4, $5, F3 = L3, J4 = L3;
    L3 === 0 ? (j3 = 0, F3 = 1, $5 = A3, J4 = T3) : (j3 = E4 * A3 - T3 * D4, $5 = w3 * A3 - E4 * D4, j3 < 0 ? (j3 = 0, $5 = A3, J4 = T3) : j3 > F3 && (j3 = F3, $5 = A3 + E4, J4 = T3)), $5 < 0 ? ($5 = 0, -D4 < 0 ? j3 = 0 : -D4 > w3 ? j3 = F3 : (j3 = -D4, F3 = w3)) : $5 > J4 && ($5 = J4, -D4 + E4 < 0 ? j3 = 0 : -D4 + E4 > w3 ? j3 = F3 : (j3 = -D4 + E4, F3 = w3)), B3 = j3 === 0 ? 0 : j3 / F3, W4 = $5 === 0 ? 0 : $5 / J4;
    var ot2 = (1 - B3) * r5 + B3 * e, K4 = (1 - B3) * t + B3 * n4, H5 = (1 - W4) * i + W4 * u5, _t2 = (1 - W4) * a4 + W4 * h, ct2 = H5 - ot2, ft2 = _t2 - K4;
    return ct2 * ct2 + ft2 * ft2;
  }
  H$3(av2, "sqSegSegDist");
  function vA2(r5, t) {
    return r5[0] === t[0] ? r5[1] - t[1] : r5[0] - t[0];
  }
  H$3(vA2, "compareByX");
  function bA2(r5) {
    r5.sort(vA2);
    for (var t = [], e = 0; e < r5.length; e++) {
      for (; t.length >= 2 && Zf3(t[t.length - 2], t[t.length - 1], r5[e]) <= 0; ) t.pop();
      t.push(r5[e]);
    }
    for (var n4 = [], i = r5.length - 1; i >= 0; i--) {
      for (; n4.length >= 2 && Zf3(n4[n4.length - 2], n4[n4.length - 1], r5[i]) <= 0; ) n4.pop();
      n4.push(r5[i]);
    }
    return n4.pop(), t.pop(), t.concat(n4);
  }
  H$3(bA2, "convexHull");
});
var zP = L((M_2, T_2) => {
  a();
  (function(r5, t) {
    typeof M_2 == "object" && typeof T_2 < "u" ? T_2.exports = t() : typeof define == "function" && define.amd ? define(t) : r5.quickselect = t();
  })(M_2, function() {
    function r5(i, a4, u5, h, d) {
      t(i, a4, u5 || 0, h || i.length - 1, d || n4);
    }
    H$3(r5, "quickselect");
    function t(i, a4, u5, h, d) {
      for (; h > u5; ) {
        if (h - u5 > 600) {
          var m5 = h - u5 + 1, v3 = a4 - u5 + 1, x2 = Math.log(m5), S4 = 0.5 * Math.exp(2 * x2 / 3), I3 = 0.5 * Math.sqrt(x2 * S4 * (m5 - S4) / m5) * (v3 - m5 / 2 < 0 ? -1 : 1), w3 = Math.max(u5, Math.floor(a4 - v3 * S4 / m5 + I3)), E4 = Math.min(h, Math.floor(a4 + (m5 - v3) * S4 / m5 + I3));
          t(i, a4, w3, E4, d);
        }
        var T3 = i[a4], D4 = u5, A3 = h;
        for (e(i, u5, a4), d(i[h], T3) > 0 && e(i, u5, h); D4 < A3; ) {
          for (e(i, D4, A3), D4++, A3--; d(i[D4], T3) < 0; ) D4++;
          for (; d(i[A3], T3) > 0; ) A3--;
        }
        d(i[u5], T3) === 0 ? e(i, u5, A3) : (A3++, e(i, A3, h)), A3 <= a4 && (u5 = A3 + 1), a4 <= A3 && (h = A3 - 1);
      }
    }
    H$3(t, "quickselectStep");
    function e(i, a4, u5) {
      var h = i[a4];
      i[a4] = i[u5], i[u5] = h;
    }
    H$3(e, "swap");
    function n4(i, a4) {
      return i < a4 ? -1 : i > a4 ? 1 : 0;
    }
    return H$3(n4, "defaultCompare"), r5;
  });
});
var O_ = L((btt, E_2) => {
  a();
  E_2.exports = yg3;
  E_2.exports.default = yg3;
  var AA2 = zP();
  function yg3(r5, t) {
    if (!(this instanceof yg3)) return new yg3(r5, t);
    this._maxEntries = Math.max(4, r5 || 9), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), t && this._initFormat(t), this.clear();
  }
  H$3(yg3, "rbush");
  yg3.prototype = { all: H$3(function() {
    return this._all(this.data, []);
  }, "all"), search: H$3(function(r5) {
    var t = this.data, e = [], n4 = this.toBBox;
    if (!cv2(r5, t)) return e;
    for (var i = [], a4, u5, h, d; t; ) {
      for (a4 = 0, u5 = t.children.length; a4 < u5; a4++) h = t.children[a4], d = t.leaf ? n4(h) : h, cv2(r5, d) && (t.leaf ? e.push(h) : P_2(r5, d) ? this._all(h, e) : i.push(h));
      t = i.pop();
    }
    return e;
  }, "search"), collides: H$3(function(r5) {
    var t = this.data, e = this.toBBox;
    if (!cv2(r5, t)) return false;
    for (var n4 = [], i, a4, u5, h; t; ) {
      for (i = 0, a4 = t.children.length; i < a4; i++) if (u5 = t.children[i], h = t.leaf ? e(u5) : u5, cv2(r5, h)) {
        if (t.leaf || P_2(r5, h)) return true;
        n4.push(u5);
      }
      t = n4.pop();
    }
    return false;
  }, "collides"), load: H$3(function(r5) {
    if (!(r5 && r5.length)) return this;
    if (r5.length < this._minEntries) {
      for (var t = 0, e = r5.length; t < e; t++) this.insert(r5[t]);
      return this;
    }
    var n4 = this._build(r5.slice(), 0, r5.length - 1, 0);
    if (!this.data.children.length) this.data = n4;
    else if (this.data.height === n4.height) this._splitRoot(this.data, n4);
    else {
      if (this.data.height < n4.height) {
        var i = this.data;
        this.data = n4, n4 = i;
      }
      this._insert(n4, this.data.height - n4.height - 1, true);
    }
    return this;
  }, "load"), insert: H$3(function(r5) {
    return r5 && this._insert(r5, this.data.height - 1), this;
  }, "insert"), clear: H$3(function() {
    return this.data = Kf2([]), this;
  }, "clear"), remove: H$3(function(r5, t) {
    if (!r5) return this;
    for (var e = this.data, n4 = this.toBBox(r5), i = [], a4 = [], u5, h, d, m5; e || i.length; ) {
      if (e || (e = i.pop(), h = i[i.length - 1], u5 = a4.pop(), m5 = true), e.leaf && (d = NA2(r5, e.children, t), d !== -1)) return e.children.splice(d, 1), i.push(e), this._condense(i), this;
      !m5 && !e.leaf && P_2(e, n4) ? (i.push(e), a4.push(u5), u5 = 0, h = e, e = e.children[0]) : h ? (u5++, e = h.children[u5], m5 = false) : e = null;
    }
    return this;
  }, "remove"), toBBox: H$3(function(r5) {
    return r5;
  }, "toBBox"), compareMinX: HP2, compareMinY: XP2, toJSON: H$3(function() {
    return this.data;
  }, "toJSON"), fromJSON: H$3(function(r5) {
    return this.data = r5, this;
  }, "fromJSON"), _all: H$3(function(r5, t) {
    for (var e = []; r5; ) r5.leaf ? t.push.apply(t, r5.children) : e.push.apply(e, r5.children), r5 = e.pop();
    return t;
  }, "_all"), _build: H$3(function(r5, t, e, n4) {
    var i = e - t + 1, a4 = this._maxEntries, u5;
    if (i <= a4) return u5 = Kf2(r5.slice(t, e + 1)), Jf2(u5, this.toBBox), u5;
    n4 || (n4 = Math.ceil(Math.log(i) / Math.log(a4)), a4 = Math.ceil(i / Math.pow(a4, n4 - 1))), u5 = Kf2([]), u5.leaf = false, u5.height = n4;
    var h = Math.ceil(i / a4), d = h * Math.ceil(Math.sqrt(a4)), m5, v3, x2, S4;
    for (YP2(r5, t, e, d, this.compareMinX), m5 = t; m5 <= e; m5 += d) for (x2 = Math.min(m5 + d - 1, e), YP2(r5, m5, x2, h, this.compareMinY), v3 = m5; v3 <= x2; v3 += h) S4 = Math.min(v3 + h - 1, x2), u5.children.push(this._build(r5, v3, S4, n4 - 1));
    return Jf2(u5, this.toBBox), u5;
  }, "_build"), _chooseSubtree: H$3(function(r5, t, e, n4) {
    for (var i, a4, u5, h, d, m5, v3, x2; n4.push(t), !(t.leaf || n4.length - 1 === e); ) {
      for (v3 = x2 = 1 / 0, i = 0, a4 = t.children.length; i < a4; i++) u5 = t.children[i], d = w_2(u5), m5 = kA2(r5, u5) - d, m5 < x2 ? (x2 = m5, v3 = d < v3 ? d : v3, h = u5) : m5 === x2 && d < v3 && (v3 = d, h = u5);
      t = h || t.children[0];
    }
    return t;
  }, "_chooseSubtree"), _insert: H$3(function(r5, t, e) {
    var n4 = this.toBBox, i = e ? r5 : n4(r5), a4 = [], u5 = this._chooseSubtree(i, this.data, t, a4);
    for (u5.children.push(r5), gg3(u5, i); t >= 0 && a4[t].children.length > this._maxEntries; ) this._split(a4, t), t--;
    this._adjustParentBBoxes(i, a4, t);
  }, "_insert"), _split: H$3(function(r5, t) {
    var e = r5[t], n4 = e.children.length, i = this._minEntries;
    this._chooseSplitAxis(e, i, n4);
    var a4 = this._chooseSplitIndex(e, i, n4), u5 = Kf2(e.children.splice(a4, e.children.length - a4));
    u5.height = e.height, u5.leaf = e.leaf, Jf2(e, this.toBBox), Jf2(u5, this.toBBox), t ? r5[t - 1].children.push(u5) : this._splitRoot(e, u5);
  }, "_split"), _splitRoot: H$3(function(r5, t) {
    this.data = Kf2([r5, t]), this.data.height = r5.height + 1, this.data.leaf = false, Jf2(this.data, this.toBBox);
  }, "_splitRoot"), _chooseSplitIndex: H$3(function(r5, t, e) {
    var n4, i, a4, u5, h, d, m5, v3;
    for (d = m5 = 1 / 0, n4 = t; n4 <= e - t; n4++) i = mg3(r5, 0, n4, this.toBBox), a4 = mg3(r5, n4, e, this.toBBox), u5 = RA2(i, a4), h = w_2(i) + w_2(a4), u5 < d ? (d = u5, v3 = n4, m5 = h < m5 ? h : m5) : u5 === d && h < m5 && (m5 = h, v3 = n4);
    return v3;
  }, "_chooseSplitIndex"), _chooseSplitAxis: H$3(function(r5, t, e) {
    var n4 = r5.leaf ? this.compareMinX : HP2, i = r5.leaf ? this.compareMinY : XP2, a4 = this._allDistMargin(r5, t, e, n4), u5 = this._allDistMargin(r5, t, e, i);
    a4 < u5 && r5.children.sort(n4);
  }, "_chooseSplitAxis"), _allDistMargin: H$3(function(r5, t, e, n4) {
    r5.children.sort(n4);
    var i = this.toBBox, a4 = mg3(r5, 0, t, i), u5 = mg3(r5, e - t, e, i), h = uv2(a4) + uv2(u5), d, m5;
    for (d = t; d < e - t; d++) m5 = r5.children[d], gg3(a4, r5.leaf ? i(m5) : m5), h += uv2(a4);
    for (d = e - t - 1; d >= t; d--) m5 = r5.children[d], gg3(u5, r5.leaf ? i(m5) : m5), h += uv2(u5);
    return h;
  }, "_allDistMargin"), _adjustParentBBoxes: H$3(function(r5, t, e) {
    for (var n4 = e; n4 >= 0; n4--) gg3(t[n4], r5);
  }, "_adjustParentBBoxes"), _condense: H$3(function(r5) {
    for (var t = r5.length - 1, e; t >= 0; t--) r5[t].children.length === 0 ? t > 0 ? (e = r5[t - 1].children, e.splice(e.indexOf(r5[t]), 1)) : this.clear() : Jf2(r5[t], this.toBBox);
  }, "_condense"), _initFormat: H$3(function(r5) {
    var t = ["return a", " - b", ";"];
    this.compareMinX = new Function("a", "b", t.join(r5[0])), this.compareMinY = new Function("a", "b", t.join(r5[1])), this.toBBox = new Function("a", "return {minX: a" + r5[0] + ", minY: a" + r5[1] + ", maxX: a" + r5[2] + ", maxY: a" + r5[3] + "};");
  }, "_initFormat") };
  function NA2(r5, t, e) {
    if (!e) return t.indexOf(r5);
    for (var n4 = 0; n4 < t.length; n4++) if (e(r5, t[n4])) return n4;
    return -1;
  }
  H$3(NA2, "findItem");
  function Jf2(r5, t) {
    mg3(r5, 0, r5.children.length, t, r5);
  }
  H$3(Jf2, "calcBBox");
  function mg3(r5, t, e, n4, i) {
    i || (i = Kf2(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
    for (var a4 = t, u5; a4 < e; a4++) u5 = r5.children[a4], gg3(i, r5.leaf ? n4(u5) : u5);
    return i;
  }
  H$3(mg3, "distBBox");
  function gg3(r5, t) {
    return r5.minX = Math.min(r5.minX, t.minX), r5.minY = Math.min(r5.minY, t.minY), r5.maxX = Math.max(r5.maxX, t.maxX), r5.maxY = Math.max(r5.maxY, t.maxY), r5;
  }
  H$3(gg3, "extend");
  function HP2(r5, t) {
    return r5.minX - t.minX;
  }
  H$3(HP2, "compareNodeMinX");
  function XP2(r5, t) {
    return r5.minY - t.minY;
  }
  H$3(XP2, "compareNodeMinY");
  function w_2(r5) {
    return (r5.maxX - r5.minX) * (r5.maxY - r5.minY);
  }
  H$3(w_2, "bboxArea");
  function uv2(r5) {
    return r5.maxX - r5.minX + (r5.maxY - r5.minY);
  }
  H$3(uv2, "bboxMargin");
  function kA2(r5, t) {
    return (Math.max(t.maxX, r5.maxX) - Math.min(t.minX, r5.minX)) * (Math.max(t.maxY, r5.maxY) - Math.min(t.minY, r5.minY));
  }
  H$3(kA2, "enlargedArea");
  function RA2(r5, t) {
    var e = Math.max(r5.minX, t.minX), n4 = Math.max(r5.minY, t.minY), i = Math.min(r5.maxX, t.maxX), a4 = Math.min(r5.maxY, t.maxY);
    return Math.max(0, i - e) * Math.max(0, a4 - n4);
  }
  H$3(RA2, "intersectionArea");
  function P_2(r5, t) {
    return r5.minX <= t.minX && r5.minY <= t.minY && t.maxX <= r5.maxX && t.maxY <= r5.maxY;
  }
  H$3(P_2, "contains");
  function cv2(r5, t) {
    return t.minX <= r5.maxX && t.minY <= r5.maxY && t.maxX >= r5.minX && t.maxY >= r5.minY;
  }
  H$3(cv2, "intersects");
  function Kf2(r5) {
    return { children: r5, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
  }
  H$3(Kf2, "createNode");
  function YP2(r5, t, e, n4, i) {
    for (var a4 = [t, e], u5; a4.length; ) e = a4.pop(), t = a4.pop(), !(e - t <= n4) && (u5 = t + Math.ceil((e - t) / n4 / 2) * n4, AA2(r5, u5, t, e, i), a4.push(t, u5, u5, e));
  }
  H$3(YP2, "multiSelect");
});
var R_ = L((se3) => {
  a();
  Object.defineProperty(se3, "__esModule", { value: true });
  se3.earthRadius = 63710088e-1;
  se3.factors = { centimeters: se3.earthRadius * 100, centimetres: se3.earthRadius * 100, degrees: se3.earthRadius / 111325, feet: se3.earthRadius * 3.28084, inches: se3.earthRadius * 39.37, kilometers: se3.earthRadius / 1e3, kilometres: se3.earthRadius / 1e3, meters: se3.earthRadius, metres: se3.earthRadius, miles: se3.earthRadius / 1609.344, millimeters: se3.earthRadius * 1e3, millimetres: se3.earthRadius * 1e3, nauticalmiles: se3.earthRadius / 1852, radians: 1, yards: se3.earthRadius * 1.0936 };
  se3.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: 1 / 1e3, kilometres: 1 / 1e3, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / se3.earthRadius, yards: 1.0936133 };
  se3.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 };
  function ac2(r5, t, e) {
    e === void 0 && (e = {});
    var n4 = { type: "Feature" };
    return (e.id === 0 || e.id) && (n4.id = e.id), e.bbox && (n4.bbox = e.bbox), n4.properties = t || {}, n4.geometry = r5, n4;
  }
  H$3(ac2, "feature");
  se3.feature = ac2;
  function ZA2(r5, t, e) {
    switch (r5) {
      case "Point":
        return L_2(t).geometry;
      case "LineString":
        return N_2(t).geometry;
      case "Polygon":
        return A_2(t).geometry;
      case "MultiPoint":
        return WP2(t).geometry;
      case "MultiLineString":
        return qP2(t).geometry;
      case "MultiPolygon":
        return ZP2(t).geometry;
      default:
        throw new Error(r5 + " is invalid");
    }
  }
  H$3(ZA2, "geometry");
  se3.geometry = ZA2;
  function L_2(r5, t, e) {
    if (e === void 0 && (e = {}), !r5) throw new Error("coordinates is required");
    if (!Array.isArray(r5)) throw new Error("coordinates must be an Array");
    if (r5.length < 2) throw new Error("coordinates must be at least 2 numbers long");
    if (!hv2(r5[0]) || !hv2(r5[1])) throw new Error("coordinates must contain numbers");
    var n4 = { type: "Point", coordinates: r5 };
    return ac2(n4, t, e);
  }
  H$3(L_2, "point");
  se3.point = L_2;
  function $A2(r5, t, e) {
    return e === void 0 && (e = {}), fv2(r5.map(function(n4) {
      return L_2(n4, t);
    }), e);
  }
  H$3($A2, "points");
  se3.points = $A2;
  function A_2(r5, t, e) {
    e === void 0 && (e = {});
    for (var n4 = 0, i = r5; n4 < i.length; n4++) {
      var a4 = i[n4];
      if (a4.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      for (var u5 = 0; u5 < a4[a4.length - 1].length; u5++) if (a4[a4.length - 1][u5] !== a4[0][u5]) throw new Error("First and last Position are not equivalent.");
    }
    var h = { type: "Polygon", coordinates: r5 };
    return ac2(h, t, e);
  }
  H$3(A_2, "polygon");
  se3.polygon = A_2;
  function JA2(r5, t, e) {
    return e === void 0 && (e = {}), fv2(r5.map(function(n4) {
      return A_2(n4, t);
    }), e);
  }
  H$3(JA2, "polygons");
  se3.polygons = JA2;
  function N_2(r5, t, e) {
    if (e === void 0 && (e = {}), r5.length < 2) throw new Error("coordinates must be an array of two or more positions");
    var n4 = { type: "LineString", coordinates: r5 };
    return ac2(n4, t, e);
  }
  H$3(N_2, "lineString");
  se3.lineString = N_2;
  function KA2(r5, t, e) {
    return e === void 0 && (e = {}), fv2(r5.map(function(n4) {
      return N_2(n4, t);
    }), e);
  }
  H$3(KA2, "lineStrings");
  se3.lineStrings = KA2;
  function fv2(r5, t) {
    t === void 0 && (t = {});
    var e = { type: "FeatureCollection" };
    return t.id && (e.id = t.id), t.bbox && (e.bbox = t.bbox), e.features = r5, e;
  }
  H$3(fv2, "featureCollection");
  se3.featureCollection = fv2;
  function qP2(r5, t, e) {
    e === void 0 && (e = {});
    var n4 = { type: "MultiLineString", coordinates: r5 };
    return ac2(n4, t, e);
  }
  H$3(qP2, "multiLineString");
  se3.multiLineString = qP2;
  function WP2(r5, t, e) {
    e === void 0 && (e = {});
    var n4 = { type: "MultiPoint", coordinates: r5 };
    return ac2(n4, t, e);
  }
  H$3(WP2, "multiPoint");
  se3.multiPoint = WP2;
  function ZP2(r5, t, e) {
    e === void 0 && (e = {});
    var n4 = { type: "MultiPolygon", coordinates: r5 };
    return ac2(n4, t, e);
  }
  H$3(ZP2, "multiPolygon");
  se3.multiPolygon = ZP2;
  function QA2(r5, t, e) {
    e === void 0 && (e = {});
    var n4 = { type: "GeometryCollection", geometries: r5 };
    return ac2(n4, t, e);
  }
  H$3(QA2, "geometryCollection");
  se3.geometryCollection = QA2;
  function tN(r5, t) {
    if (t === void 0 && (t = 0), t && !(t >= 0)) throw new Error("precision must be a positive number");
    var e = Math.pow(10, t || 0);
    return Math.round(r5 * e) / e;
  }
  H$3(tN, "round");
  se3.round = tN;
  function $P2(r5, t) {
    t === void 0 && (t = "kilometers");
    var e = se3.factors[t];
    if (!e) throw new Error(t + " units is invalid");
    return r5 * e;
  }
  H$3($P2, "radiansToLength");
  se3.radiansToLength = $P2;
  function k_2(r5, t) {
    t === void 0 && (t = "kilometers");
    var e = se3.factors[t];
    if (!e) throw new Error(t + " units is invalid");
    return r5 / e;
  }
  H$3(k_2, "lengthToRadians");
  se3.lengthToRadians = k_2;
  function eN(r5, t) {
    return JP2(k_2(r5, t));
  }
  H$3(eN, "lengthToDegrees");
  se3.lengthToDegrees = eN;
  function rN(r5) {
    var t = r5 % 360;
    return t < 0 && (t += 360), t;
  }
  H$3(rN, "bearingToAzimuth");
  se3.bearingToAzimuth = rN;
  function JP2(r5) {
    var t = r5 % (2 * Math.PI);
    return t * 180 / Math.PI;
  }
  H$3(JP2, "radiansToDegrees");
  se3.radiansToDegrees = JP2;
  function nN(r5) {
    var t = r5 % 360;
    return t * Math.PI / 180;
  }
  H$3(nN, "degreesToRadians");
  se3.degreesToRadians = nN;
  function iN(r5, t, e) {
    if (t === void 0 && (t = "kilometers"), e === void 0 && (e = "kilometers"), !(r5 >= 0)) throw new Error("length must be a positive number");
    return $P2(k_2(r5, t), e);
  }
  H$3(iN, "convertLength");
  se3.convertLength = iN;
  function oN(r5, t, e) {
    if (t === void 0 && (t = "meters"), e === void 0 && (e = "kilometers"), !(r5 >= 0)) throw new Error("area must be a positive number");
    var n4 = se3.areaFactors[t];
    if (!n4) throw new Error("invalid original units");
    var i = se3.areaFactors[e];
    if (!i) throw new Error("invalid final units");
    return r5 / n4 * i;
  }
  H$3(oN, "convertArea");
  se3.convertArea = oN;
  function hv2(r5) {
    return !isNaN(r5) && r5 !== null && !Array.isArray(r5);
  }
  H$3(hv2, "isNumber");
  se3.isNumber = hv2;
  function sN(r5) {
    return !!r5 && r5.constructor === Object;
  }
  H$3(sN, "isObject");
  se3.isObject = sN;
  function aN(r5) {
    if (!r5) throw new Error("bbox is required");
    if (!Array.isArray(r5)) throw new Error("bbox must be an Array");
    if (r5.length !== 4 && r5.length !== 6) throw new Error("bbox must be an Array of 4 or 6 numbers");
    r5.forEach(function(t) {
      if (!hv2(t)) throw new Error("bbox must only contain numbers");
    });
  }
  H$3(aN, "validateBBox");
  se3.validateBBox = aN;
  function lN(r5) {
    if (!r5) throw new Error("id is required");
    if (["string", "number"].indexOf(typeof r5) === -1) throw new Error("id must be a number or a string");
  }
  H$3(lN, "validateId");
  se3.validateId = lN;
});
var B_ = L((ai2) => {
  a();
  Object.defineProperty(ai2, "__esModule", { value: true });
  var so2 = R_();
  function bg3(r5, t, e) {
    if (r5 !== null) for (var n4, i, a4, u5, h, d, m5, v3 = 0, x2 = 0, S4, I3 = r5.type, w3 = I3 === "FeatureCollection", E4 = I3 === "Feature", T3 = w3 ? r5.features.length : 1, D4 = 0; D4 < T3; D4++) {
      m5 = w3 ? r5.features[D4].geometry : E4 ? r5.geometry : r5, S4 = m5 ? m5.type === "GeometryCollection" : false, h = S4 ? m5.geometries.length : 1;
      for (var A3 = 0; A3 < h; A3++) {
        var L3 = 0, B3 = 0;
        if (u5 = S4 ? m5.geometries[A3] : m5, u5 !== null) {
          d = u5.coordinates;
          var j3 = u5.type;
          switch (v3 = e && (j3 === "Polygon" || j3 === "MultiPolygon") ? 1 : 0, j3) {
            case null:
              break;
            case "Point":
              if (t(d, x2, D4, L3, B3) === false) return false;
              x2++, L3++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n4 = 0; n4 < d.length; n4++) {
                if (t(d[n4], x2, D4, L3, B3) === false) return false;
                x2++, j3 === "MultiPoint" && L3++;
              }
              j3 === "LineString" && L3++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n4 = 0; n4 < d.length; n4++) {
                for (i = 0; i < d[n4].length - v3; i++) {
                  if (t(d[n4][i], x2, D4, L3, B3) === false) return false;
                  x2++;
                }
                j3 === "MultiLineString" && L3++, j3 === "Polygon" && B3++;
              }
              j3 === "Polygon" && L3++;
              break;
            case "MultiPolygon":
              for (n4 = 0; n4 < d.length; n4++) {
                for (B3 = 0, i = 0; i < d[n4].length; i++) {
                  for (a4 = 0; a4 < d[n4][i].length - v3; a4++) {
                    if (t(d[n4][i][a4], x2, D4, L3, B3) === false) return false;
                    x2++;
                  }
                  B3++;
                }
                L3++;
              }
              break;
            case "GeometryCollection":
              for (n4 = 0; n4 < u5.geometries.length; n4++) if (bg3(u5.geometries[n4], t, e) === false) return false;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
  }
  H$3(bg3, "coordEach");
  function uN(r5, t, e, n4) {
    var i = e;
    return bg3(r5, function(a4, u5, h, d, m5) {
      u5 === 0 && e === void 0 ? i = a4 : i = t(i, a4, u5, h, d, m5);
    }, n4), i;
  }
  H$3(uN, "coordReduce");
  function KP2(r5, t) {
    var e;
    switch (r5.type) {
      case "FeatureCollection":
        for (e = 0; e < r5.features.length && t(r5.features[e].properties, e) !== false; e++) ;
        break;
      case "Feature":
        t(r5.properties, 0);
        break;
    }
  }
  H$3(KP2, "propEach");
  function cN(r5, t, e) {
    var n4 = e;
    return KP2(r5, function(i, a4) {
      a4 === 0 && e === void 0 ? n4 = i : n4 = t(n4, i, a4);
    }), n4;
  }
  H$3(cN, "propReduce");
  function QP2(r5, t) {
    if (r5.type === "Feature") t(r5, 0);
    else if (r5.type === "FeatureCollection") for (var e = 0; e < r5.features.length && t(r5.features[e], e) !== false; e++) ;
  }
  H$3(QP2, "featureEach");
  function pN(r5, t, e) {
    var n4 = e;
    return QP2(r5, function(i, a4) {
      a4 === 0 && e === void 0 ? n4 = i : n4 = t(n4, i, a4);
    }), n4;
  }
  H$3(pN, "featureReduce");
  function hN(r5) {
    var t = [];
    return bg3(r5, function(e) {
      t.push(e);
    }), t;
  }
  H$3(hN, "coordAll");
  function F_2(r5, t) {
    var e, n4, i, a4, u5, h, d, m5, v3, x2, S4 = 0, I3 = r5.type === "FeatureCollection", w3 = r5.type === "Feature", E4 = I3 ? r5.features.length : 1;
    for (e = 0; e < E4; e++) {
      for (h = I3 ? r5.features[e].geometry : w3 ? r5.geometry : r5, m5 = I3 ? r5.features[e].properties : w3 ? r5.properties : {}, v3 = I3 ? r5.features[e].bbox : w3 ? r5.bbox : void 0, x2 = I3 ? r5.features[e].id : w3 ? r5.id : void 0, d = h ? h.type === "GeometryCollection" : false, u5 = d ? h.geometries.length : 1, i = 0; i < u5; i++) {
        if (a4 = d ? h.geometries[i] : h, a4 === null) {
          if (t(null, S4, m5, v3, x2) === false) return false;
          continue;
        }
        switch (a4.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (t(a4, S4, m5, v3, x2) === false) return false;
            break;
          }
          case "GeometryCollection": {
            for (n4 = 0; n4 < a4.geometries.length; n4++) if (t(a4.geometries[n4], S4, m5, v3, x2) === false) return false;
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      S4++;
    }
  }
  H$3(F_2, "geomEach");
  function fN(r5, t, e) {
    var n4 = e;
    return F_2(r5, function(i, a4, u5, h, d) {
      a4 === 0 && e === void 0 ? n4 = i : n4 = t(n4, i, a4, u5, h, d);
    }), n4;
  }
  H$3(fN, "geomReduce");
  function dv2(r5, t) {
    F_2(r5, function(e, n4, i, a4, u5) {
      var h = e === null ? null : e.type;
      switch (h) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          return t(so2.feature(e, i, { bbox: a4, id: u5 }), n4, 0) === false ? false : void 0;
      }
      var d;
      switch (h) {
        case "MultiPoint":
          d = "Point";
          break;
        case "MultiLineString":
          d = "LineString";
          break;
        case "MultiPolygon":
          d = "Polygon";
          break;
      }
      for (var m5 = 0; m5 < e.coordinates.length; m5++) {
        var v3 = e.coordinates[m5], x2 = { type: d, coordinates: v3 };
        if (t(so2.feature(x2, i), n4, m5) === false) return false;
      }
    });
  }
  H$3(dv2, "flattenEach");
  function dN(r5, t, e) {
    var n4 = e;
    return dv2(r5, function(i, a4, u5) {
      a4 === 0 && u5 === 0 && e === void 0 ? n4 = i : n4 = t(n4, i, a4, u5);
    }), n4;
  }
  H$3(dN, "flattenReduce");
  function tE2(r5, t) {
    dv2(r5, function(e, n4, i) {
      var a4 = 0;
      if (e.geometry) {
        var u5 = e.geometry.type;
        if (!(u5 === "Point" || u5 === "MultiPoint")) {
          var h, d = 0, m5 = 0, v3 = 0;
          if (bg3(e, function(x2, S4, I3, w3, E4) {
            if (h === void 0 || n4 > d || w3 > m5 || E4 > v3) {
              h = x2, d = n4, m5 = w3, v3 = E4, a4 = 0;
              return;
            }
            var T3 = so2.lineString([h, x2], e.properties);
            if (t(T3, n4, i, E4, a4) === false) return false;
            a4++, h = x2;
          }) === false) return false;
        }
      }
    });
  }
  H$3(tE2, "segmentEach");
  function mN(r5, t, e) {
    var n4 = e, i = false;
    return tE2(r5, function(a4, u5, h, d, m5) {
      i === false && e === void 0 ? n4 = a4 : n4 = t(n4, a4, u5, h, d, m5), i = true;
    }), n4;
  }
  H$3(mN, "segmentReduce");
  function eE2(r5, t) {
    if (!r5) throw new Error("geojson is required");
    dv2(r5, function(e, n4, i) {
      if (e.geometry !== null) {
        var a4 = e.geometry.type, u5 = e.geometry.coordinates;
        switch (a4) {
          case "LineString":
            if (t(e, n4, i, 0, 0) === false) return false;
            break;
          case "Polygon":
            for (var h = 0; h < u5.length; h++) if (t(so2.lineString(u5[h], e.properties), n4, i, h) === false) return false;
            break;
        }
      }
    });
  }
  H$3(eE2, "lineEach");
  function gN(r5, t, e) {
    var n4 = e;
    return eE2(r5, function(i, a4, u5, h) {
      a4 === 0 && e === void 0 ? n4 = i : n4 = t(n4, i, a4, u5, h);
    }), n4;
  }
  H$3(gN, "lineReduce");
  function yN(r5, t) {
    if (t = t || {}, !so2.isObject(t)) throw new Error("options is invalid");
    var e = t.featureIndex || 0, n4 = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, a4 = t.segmentIndex || 0, u5 = t.properties, h;
    switch (r5.type) {
      case "FeatureCollection":
        e < 0 && (e = r5.features.length + e), u5 = u5 || r5.features[e].properties, h = r5.features[e].geometry;
        break;
      case "Feature":
        u5 = u5 || r5.properties, h = r5.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        h = r5;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (h === null) return null;
    var d = h.coordinates;
    switch (h.type) {
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
        return a4 < 0 && (a4 = d.length + a4 - 1), so2.lineString([d[a4], d[a4 + 1]], u5, t);
      case "Polygon":
        return i < 0 && (i = d.length + i), a4 < 0 && (a4 = d[i].length + a4 - 1), so2.lineString([d[i][a4], d[i][a4 + 1]], u5, t);
      case "MultiLineString":
        return n4 < 0 && (n4 = d.length + n4), a4 < 0 && (a4 = d[n4].length + a4 - 1), so2.lineString([d[n4][a4], d[n4][a4 + 1]], u5, t);
      case "MultiPolygon":
        return n4 < 0 && (n4 = d.length + n4), i < 0 && (i = d[n4].length + i), a4 < 0 && (a4 = d[n4][i].length - a4 - 1), so2.lineString([d[n4][i][a4], d[n4][i][a4 + 1]], u5, t);
    }
    throw new Error("geojson is invalid");
  }
  H$3(yN, "findSegment");
  function vN(r5, t) {
    if (t = t || {}, !so2.isObject(t)) throw new Error("options is invalid");
    var e = t.featureIndex || 0, n4 = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, a4 = t.coordIndex || 0, u5 = t.properties, h;
    switch (r5.type) {
      case "FeatureCollection":
        e < 0 && (e = r5.features.length + e), u5 = u5 || r5.features[e].properties, h = r5.features[e].geometry;
        break;
      case "Feature":
        u5 = u5 || r5.properties, h = r5.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        h = r5;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (h === null) return null;
    var d = h.coordinates;
    switch (h.type) {
      case "Point":
        return so2.point(d, u5, t);
      case "MultiPoint":
        return n4 < 0 && (n4 = d.length + n4), so2.point(d[n4], u5, t);
      case "LineString":
        return a4 < 0 && (a4 = d.length + a4), so2.point(d[a4], u5, t);
      case "Polygon":
        return i < 0 && (i = d.length + i), a4 < 0 && (a4 = d[i].length + a4), so2.point(d[i][a4], u5, t);
      case "MultiLineString":
        return n4 < 0 && (n4 = d.length + n4), a4 < 0 && (a4 = d[n4].length + a4), so2.point(d[n4][a4], u5, t);
      case "MultiPolygon":
        return n4 < 0 && (n4 = d.length + n4), i < 0 && (i = d[n4].length + i), a4 < 0 && (a4 = d[n4][i].length - a4), so2.point(d[n4][i][a4], u5, t);
    }
    throw new Error("geojson is invalid");
  }
  H$3(vN, "findPoint");
  ai2.coordAll = hN;
  ai2.coordEach = bg3;
  ai2.coordReduce = uN;
  ai2.featureEach = QP2;
  ai2.featureReduce = pN;
  ai2.findPoint = vN;
  ai2.findSegment = yN;
  ai2.flattenEach = dv2;
  ai2.flattenReduce = dN;
  ai2.geomEach = F_2;
  ai2.geomReduce = fN;
  ai2.lineEach = eE2;
  ai2.lineReduce = gN;
  ai2.propEach = KP2;
  ai2.propReduce = cN;
  ai2.segmentEach = tE2;
  ai2.segmentReduce = mN;
});
var rE = L((V_2) => {
  a();
  Object.defineProperty(V_2, "__esModule", { value: true });
  var bN = B_();
  function G_2(r5) {
    var t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return bN.coordEach(r5, function(e) {
      t[0] > e[0] && (t[0] = e[0]), t[1] > e[1] && (t[1] = e[1]), t[2] < e[0] && (t[2] = e[0]), t[3] < e[1] && (t[3] = e[1]);
    }), t;
  }
  H$3(G_2, "bbox");
  G_2.default = G_2;
  V_2.default = G_2;
});
var mv = L((Zrt, j_2) => {
  a();
  var Wa2 = b_(), iE2 = R_(), oE2 = B_(), td3 = rE().default, xN = oE2.featureEach;
  oE2.coordEach;
  iE2.polygon;
  var nE2 = iE2.featureCollection;
  function sE2(r5) {
    var t = new Wa2(r5);
    return t.insert = function(e) {
      if (e.type !== "Feature") throw new Error("invalid feature");
      return e.bbox = e.bbox ? e.bbox : td3(e), Wa2.prototype.insert.call(this, e);
    }, t.load = function(e) {
      var n4 = [];
      return Array.isArray(e) ? e.forEach(function(i) {
        if (i.type !== "Feature") throw new Error("invalid features");
        i.bbox = i.bbox ? i.bbox : td3(i), n4.push(i);
      }) : xN(e, function(i) {
        if (i.type !== "Feature") throw new Error("invalid features");
        i.bbox = i.bbox ? i.bbox : td3(i), n4.push(i);
      }), Wa2.prototype.load.call(this, n4);
    }, t.remove = function(e, n4) {
      if (e.type !== "Feature") throw new Error("invalid feature");
      return e.bbox = e.bbox ? e.bbox : td3(e), Wa2.prototype.remove.call(this, e, n4);
    }, t.clear = function() {
      return Wa2.prototype.clear.call(this);
    }, t.search = function(e) {
      var n4 = Wa2.prototype.search.call(this, this.toBBox(e));
      return nE2(n4);
    }, t.collides = function(e) {
      return Wa2.prototype.collides.call(this, this.toBBox(e));
    }, t.all = function() {
      var e = Wa2.prototype.all.call(this);
      return nE2(e);
    }, t.toJSON = function() {
      return Wa2.prototype.toJSON.call(this);
    }, t.fromJSON = function(e) {
      return Wa2.prototype.fromJSON.call(this, e);
    }, t.toBBox = function(e) {
      var n4;
      if (e.bbox) n4 = e.bbox;
      else if (Array.isArray(e) && e.length === 4) n4 = e;
      else if (Array.isArray(e) && e.length === 6) n4 = [e[0], e[1], e[3], e[4]];
      else if (e.type === "Feature") n4 = td3(e);
      else if (e.type === "FeatureCollection") n4 = td3(e);
      else throw new Error("invalid geojson");
      return { minX: n4[0], minY: n4[1], maxX: n4[2], maxY: n4[3] };
    }, t;
  }
  H$3(sE2, "geojsonRbush");
  j_2.exports = sE2;
  j_2.exports.default = sE2;
});
var Y_ = L((ost, xE2) => {
  a();
  var bE = Object.prototype.toString;
  xE2.exports = H$3(function(t) {
    var e = bE.call(t), n4 = e === "[object Arguments]";
    return n4 || (n4 = e !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && bE.call(t.callee) === "[object Function]"), n4;
  }, "isArguments");
});
var EE = L((lst, PE) => {
  a();
  var wE;
  Object.keys || (_g2 = Object.prototype.hasOwnProperty, q_2 = Object.prototype.toString, _E = Y_(), W_2 = Object.prototype.propertyIsEnumerable, CE = !W_2.call({ toString: null }, "toString"), SE = W_2.call(function() {
  }, "prototype"), Cg3 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], vv2 = H$3(function(r5) {
    var t = r5.constructor;
    return t && t.prototype === r5;
  }, "equalsConstructorPrototype"), IE = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, ME = (function() {
    if (typeof window > "u") return false;
    for (var r5 in window) try {
      if (!IE["$" + r5] && _g2.call(window, r5) && window[r5] !== null && typeof window[r5] == "object") try {
        vv2(window[r5]);
      } catch (t) {
        return true;
      }
    } catch (t) {
      return true;
    }
    return false;
  })(), TE = H$3(function(r5) {
    if (typeof window > "u" || !ME) return vv2(r5);
    try {
      return vv2(r5);
    } catch (t) {
      return false;
    }
  }, "equalsConstructorPrototypeIfNotBuggy"), wE = H$3(function(t) {
    var e = t !== null && typeof t == "object", n4 = q_2.call(t) === "[object Function]", i = _E(t), a4 = e && q_2.call(t) === "[object String]", u5 = [];
    if (!e && !n4 && !i) throw new TypeError("Object.keys called on a non-object");
    var h = SE && n4;
    if (a4 && t.length > 0 && !_g2.call(t, 0)) for (var d = 0; d < t.length; ++d) u5.push(String(d));
    if (i && t.length > 0) for (var m5 = 0; m5 < t.length; ++m5) u5.push(String(m5));
    else for (var v3 in t) !(h && v3 === "prototype") && _g2.call(t, v3) && u5.push(String(v3));
    if (CE) for (var x2 = TE(t), S4 = 0; S4 < Cg3.length; ++S4) !(x2 && Cg3[S4] === "constructor") && _g2.call(t, Cg3[S4]) && u5.push(Cg3[S4]);
    return u5;
  }, "keys"));
  var _g2, q_2, _E, W_2, CE, SE, Cg3, vv2, IE, ME, TE;
  PE.exports = wE;
});
var Z_ = L((pst, LE) => {
  a();
  var kN = Array.prototype.slice, RN = Y_(), OE2 = Object.keys, bv2 = OE2 ? H$3(function(t) {
    return OE2(t);
  }, "keys") : EE(), DE = Object.keys;
  bv2.shim = H$3(function() {
    if (Object.keys) {
      var t = (function() {
        var e = Object.keys(arguments);
        return e && e.length === arguments.length;
      })(1, 2);
      t || (Object.keys = H$3(function(n4) {
        return RN(n4) ? DE(kN.call(n4)) : DE(n4);
      }, "keys"));
    } else Object.keys = bv2;
    return Object.keys || bv2;
  }, "shimObjectKeys");
  LE.exports = bv2;
});
var $_ = L((dst, AE) => {
  a();
  AE.exports = H$3(function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return false;
    if (typeof Symbol.iterator == "symbol") return true;
    var t = {}, e = Symbol("test"), n4 = Object(e);
    if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(n4) !== "[object Symbol]") return false;
    var i = 42;
    t[e] = i;
    for (var a4 in t) return false;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0) return false;
    var u5 = Object.getOwnPropertySymbols(t);
    if (u5.length !== 1 || u5[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e)) return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var h = Object.getOwnPropertyDescriptor(t, e);
      if (h.value !== i || h.enumerable !== true) return false;
    }
    return true;
  }, "hasSymbols");
});
var xv = L((yst, NE) => {
  a();
  var FN = $_();
  NE.exports = H$3(function() {
    return FN() && !!Symbol.toStringTag;
  }, "hasToStringTagShams");
});
var J_ = L((xst, kE) => {
  a();
  kE.exports = Object;
});
var K_ = L((Cst, RE2) => {
  a();
  RE2.exports = Error;
});
var BE = L((Ist, FE2) => {
  a();
  FE2.exports = EvalError;
});
var VE = L((Tst, GE) => {
  a();
  GE.exports = RangeError;
});
var UE = L((Pst, jE) => {
  a();
  jE.exports = ReferenceError;
});
var Q_ = L((Ost, zE2) => {
  a();
  zE2.exports = SyntaxError;
});
var Sp = L((Lst, HE) => {
  a();
  HE.exports = TypeError;
});
var YE = L((Nst, XE) => {
  a();
  XE.exports = URIError;
});
var WE = L((Rst, qE) => {
  a();
  qE.exports = Math.abs;
});
var $E = L((Bst, ZE) => {
  a();
  ZE.exports = Math.floor;
});
var KE = L((Vst, JE2) => {
  a();
  JE2.exports = Math.max;
});
var t4 = L((Ust, QE2) => {
  a();
  QE2.exports = Math.min;
});
var r4 = L((Hst, e4) => {
  a();
  e4.exports = Math.pow;
});
var i4 = L((Yst, n4) => {
  a();
  n4.exports = Math.round;
});
var s4 = L((Wst, o4) => {
  a();
  o4.exports = Number.isNaN || H$3(function(t) {
    return t !== t;
  }, "isNaN");
});
var l4 = L((Jst, a4) => {
  a();
  var BN = s4();
  a4.exports = H$3(function(t) {
    return BN(t) || t === 0 ? t : t < 0 ? -1 : 1;
  }, "sign");
});
var c4 = L((tat, u42) => {
  a();
  u42.exports = Object.getOwnPropertyDescriptor;
});
var Ip = L((rat, p4) => {
  a();
  var _v2 = c4();
  if (_v2) try {
    _v2([], "length");
  } catch (r5) {
    _v2 = null;
  }
  p4.exports = _v2;
});
var Sg = L((iat, h4) => {
  a();
  var Cv2 = Object.defineProperty || false;
  if (Cv2) try {
    Cv2({}, "a", { value: 1 });
  } catch (r5) {
    Cv2 = false;
  }
  h4.exports = Cv2;
});
var m4 = L((sat, d4) => {
  a();
  var f4 = typeof Symbol < "u" && Symbol, GN = $_();
  d4.exports = H$3(function() {
    return typeof f4 != "function" || typeof Symbol != "function" || typeof f4("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : GN();
  }, "hasNativeSymbols");
});
var tC = L((uat, g4) => {
  a();
  g4.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
});
var eC = L((pat, y4) => {
  a();
  var VN = J_();
  y4.exports = VN.getPrototypeOf || null;
});
var x4 = L((fat, b4) => {
  a();
  var jN = "Function.prototype.bind called on incompatible ", UN = Object.prototype.toString, zN = Math.max, HN = "[object Function]", v4 = H$3(function(t, e) {
    for (var n4 = [], i = 0; i < t.length; i += 1) n4[i] = t[i];
    for (var a4 = 0; a4 < e.length; a4 += 1) n4[a4 + t.length] = e[a4];
    return n4;
  }, "concatty"), XN = H$3(function(t, e) {
    for (var n4 = [], i = e || 0, a4 = 0; i < t.length; i += 1, a4 += 1) n4[a4] = t[i];
    return n4;
  }, "slicy"), YN = H$3(function(r5, t) {
    for (var e = "", n4 = 0; n4 < r5.length; n4 += 1) e += r5[n4], n4 + 1 < r5.length && (e += t);
    return e;
  }, "joiny");
  b4.exports = H$3(function(t) {
    var e = this;
    if (typeof e != "function" || UN.apply(e) !== HN) throw new TypeError(jN + e);
    for (var n4 = XN(arguments, 1), i, a4 = H$3(function() {
      if (this instanceof i) {
        var v3 = e.apply(this, v4(n4, arguments));
        return Object(v3) === v3 ? v3 : this;
      }
      return e.apply(t, v4(n4, arguments));
    }, "binder"), u5 = zN(0, e.length - n4.length), h = [], d = 0; d < u5; d++) h[d] = "$" + d;
    if (i = Function("binder", "return function (" + YN(h, ",") + "){ return binder.apply(this,arguments); }")(a4), e.prototype) {
      var m5 = H$3(function() {
      }, "Empty");
      m5.prototype = e.prototype, i.prototype = new m5(), m5.prototype = null;
    }
    return i;
  }, "bind");
});
var rd2 = L((gat, _4) => {
  a();
  var qN = x4();
  _4.exports = Function.prototype.bind || qN;
});
var Sv = L((vat, C4) => {
  a();
  C4.exports = Function.prototype.call;
});
var Iv = L((xat, S4) => {
  a();
  S4.exports = Function.prototype.apply;
});
var M4 = L((Cat, I4) => {
  a();
  I4.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
});
var rC = L((Iat, T4) => {
  a();
  var WN = rd2(), ZN = Iv(), $N = Sv(), JN = M4();
  T4.exports = JN || WN.call($N, ZN);
});
var Mv = L((Tat, w4) => {
  a();
  var KN = rd2(), QN = Sp(), tk2 = Sv(), ek2 = rC();
  w4.exports = H$3(function(t) {
    if (t.length < 1 || typeof t[0] != "function") throw new QN("a function is required");
    return ek2(KN, tk2, t);
  }, "callBindBasic");
});
var A4 = L((Eat, L4) => {
  a();
  var rk2 = Mv(), P4 = Ip(), O4;
  try {
    O4 = [].__proto__ === Array.prototype;
  } catch (r5) {
    if (!r5 || typeof r5 != "object" || !("code" in r5) || r5.code !== "ERR_PROTO_ACCESS") throw r5;
  }
  var nC2 = !!O4 && P4 && P4(Object.prototype, "__proto__"), D4 = Object, E4 = D4.getPrototypeOf;
  L4.exports = nC2 && typeof nC2.get == "function" ? rk2([nC2.get]) : typeof E4 == "function" ? H$3(function(t) {
    return E4(t == null ? t : D4(t));
  }, "getDunder") : false;
});
var iC = L((Lat, F4) => {
  a();
  var N4 = tC(), k4 = eC(), R4 = A4();
  F4.exports = N4 ? H$3(function(t) {
    return N4(t);
  }, "getProto") : k4 ? H$3(function(t) {
    if (!t || typeof t != "object" && typeof t != "function") throw new TypeError("getProto: not an object");
    return k4(t);
  }, "getProto") : R4 ? H$3(function(t) {
    return R4(t);
  }, "getProto") : null;
});
var oC = L((kat, B4) => {
  a();
  var nk2 = Function.prototype.call, ik2 = Object.prototype.hasOwnProperty, ok2 = rd2();
  B4.exports = ok2.call(nk2, ik2);
});
var lC = L((Fat, H42) => {
  a();
  var nr2, sk2 = J_(), ak2 = K_(), lk2 = BE(), uk2 = VE(), ck2 = UE(), sd3 = Q_(), od3 = Sp(), pk2 = YE(), hk2 = WE(), fk2 = $E(), dk = KE(), mk2 = t4(), gk = r4(), yk = i4(), vk = l4(), U4 = Function, sC2 = H$3(function(r5) {
    try {
      return U4('"use strict"; return (' + r5 + ").constructor;")();
    } catch (t) {
    }
  }, "getEvalledConstructor"), Ig3 = Ip(), bk = Sg(), aC2 = H$3(function() {
    throw new od3();
  }, "throwTypeError"), xk = Ig3 ? (function() {
    try {
      return arguments.callee, aC2;
    } catch (r5) {
      try {
        return Ig3(arguments, "callee").get;
      } catch (t) {
        return aC2;
      }
    }
  })() : aC2, nd3 = m4()(), Ii2 = iC(), _k = eC(), Ck = tC(), z4 = Iv(), Mg3 = Sv(), id3 = {}, Sk = typeof Uint8Array > "u" || !Ii2 ? nr2 : Ii2(Uint8Array), Mp2 = { __proto__: null, "%AggregateError%": typeof AggregateError > "u" ? nr2 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? nr2 : ArrayBuffer, "%ArrayIteratorPrototype%": nd3 && Ii2 ? Ii2([][Symbol.iterator]()) : nr2, "%AsyncFromSyncIteratorPrototype%": nr2, "%AsyncFunction%": id3, "%AsyncGenerator%": id3, "%AsyncGeneratorFunction%": id3, "%AsyncIteratorPrototype%": id3, "%Atomics%": typeof Atomics > "u" ? nr2 : Atomics, "%BigInt%": typeof BigInt > "u" ? nr2 : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? nr2 : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? nr2 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? nr2 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": ak2, "%eval%": eval, "%EvalError%": lk2, "%Float16Array%": typeof Float16Array > "u" ? nr2 : Float16Array, "%Float32Array%": typeof Float32Array > "u" ? nr2 : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? nr2 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? nr2 : FinalizationRegistry, "%Function%": U4, "%GeneratorFunction%": id3, "%Int8Array%": typeof Int8Array > "u" ? nr2 : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? nr2 : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? nr2 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": nd3 && Ii2 ? Ii2(Ii2([][Symbol.iterator]())) : nr2, "%JSON%": typeof JSON == "object" ? JSON : nr2, "%Map%": typeof Map > "u" ? nr2 : Map, "%MapIteratorPrototype%": typeof Map > "u" || !nd3 || !Ii2 ? nr2 : Ii2((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": sk2, "%Object.getOwnPropertyDescriptor%": Ig3, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? nr2 : Promise, "%Proxy%": typeof Proxy > "u" ? nr2 : Proxy, "%RangeError%": uk2, "%ReferenceError%": ck2, "%Reflect%": typeof Reflect > "u" ? nr2 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? nr2 : Set, "%SetIteratorPrototype%": typeof Set > "u" || !nd3 || !Ii2 ? nr2 : Ii2((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? nr2 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": nd3 && Ii2 ? Ii2(""[Symbol.iterator]()) : nr2, "%Symbol%": nd3 ? Symbol : nr2, "%SyntaxError%": sd3, "%ThrowTypeError%": xk, "%TypedArray%": Sk, "%TypeError%": od3, "%Uint8Array%": typeof Uint8Array > "u" ? nr2 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? nr2 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? nr2 : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? nr2 : Uint32Array, "%URIError%": pk2, "%WeakMap%": typeof WeakMap > "u" ? nr2 : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? nr2 : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? nr2 : WeakSet, "%Function.prototype.call%": Mg3, "%Function.prototype.apply%": z4, "%Object.defineProperty%": bk, "%Object.getPrototypeOf%": _k, "%Math.abs%": hk2, "%Math.floor%": fk2, "%Math.max%": dk, "%Math.min%": mk2, "%Math.pow%": gk, "%Math.round%": yk, "%Math.sign%": vk, "%Reflect.getPrototypeOf%": Ck };
  if (Ii2) try {
    null.error;
  } catch (r5) {
    G4 = Ii2(Ii2(r5)), Mp2["%Error.prototype%"] = G4;
  }
  var G4, Ik = H$3(function r5(t) {
    var e;
    if (t === "%AsyncFunction%") e = sC2("async function () {}");
    else if (t === "%GeneratorFunction%") e = sC2("function* () {}");
    else if (t === "%AsyncGeneratorFunction%") e = sC2("async function* () {}");
    else if (t === "%AsyncGenerator%") {
      var n4 = r5("%AsyncGeneratorFunction%");
      n4 && (e = n4.prototype);
    } else if (t === "%AsyncIteratorPrototype%") {
      var i = r5("%AsyncGenerator%");
      i && Ii2 && (e = Ii2(i.prototype));
    }
    return Mp2[t] = e, e;
  }, "doEval"), V4 = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, Tg3 = rd2(), Tv2 = oC(), Mk = Tg3.call(Mg3, Array.prototype.concat), Tk = Tg3.call(z4, Array.prototype.splice), j4 = Tg3.call(Mg3, String.prototype.replace), wv2 = Tg3.call(Mg3, String.prototype.slice), wk = Tg3.call(Mg3, RegExp.prototype.exec), Pk = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Ek = /\\(\\)?/g, Ok2 = H$3(function(t) {
    var e = wv2(t, 0, 1), n4 = wv2(t, -1);
    if (e === "%" && n4 !== "%") throw new sd3("invalid intrinsic syntax, expected closing `%`");
    if (n4 === "%" && e !== "%") throw new sd3("invalid intrinsic syntax, expected opening `%`");
    var i = [];
    return j4(t, Pk, function(a4, u5, h, d) {
      i[i.length] = h ? j4(d, Ek, "$1") : u5 || a4;
    }), i;
  }, "stringToPath"), Dk2 = H$3(function(t, e) {
    var n4 = t, i;
    if (Tv2(V4, n4) && (i = V4[n4], n4 = "%" + i[0] + "%"), Tv2(Mp2, n4)) {
      var a4 = Mp2[n4];
      if (a4 === id3 && (a4 = Ik(n4)), typeof a4 > "u" && !e) throw new od3("intrinsic " + t + " exists, but is not available. Please file an issue!");
      return { alias: i, name: n4, value: a4 };
    }
    throw new sd3("intrinsic " + t + " does not exist!");
  }, "getBaseIntrinsic");
  H42.exports = H$3(function(t, e) {
    if (typeof t != "string" || t.length === 0) throw new od3("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof e != "boolean") throw new od3('"allowMissing" argument must be a boolean');
    if (wk(/^%?[^%]*%?$/, t) === null) throw new sd3("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var n4 = Ok2(t), i = n4.length > 0 ? n4[0] : "", a4 = Dk2("%" + i + "%", e), u5 = a4.name, h = a4.value, d = false, m5 = a4.alias;
    m5 && (i = m5[0], Tk(n4, Mk([0, 1], m5)));
    for (var v3 = 1, x2 = true; v3 < n4.length; v3 += 1) {
      var S4 = n4[v3], I3 = wv2(S4, 0, 1), w3 = wv2(S4, -1);
      if ((I3 === '"' || I3 === "'" || I3 === "`" || w3 === '"' || w3 === "'" || w3 === "`") && I3 !== w3) throw new sd3("property names with quotes must have matching quotes");
      if ((S4 === "constructor" || !x2) && (d = true), i += "." + S4, u5 = "%" + i + "%", Tv2(Mp2, u5)) h = Mp2[u5];
      else if (h != null) {
        if (!(S4 in h)) {
          if (!e) throw new od3("base intrinsic for " + t + " exists, but the property is not available.");
          return;
        }
        if (Ig3 && v3 + 1 >= n4.length) {
          var E4 = Ig3(h, S4);
          x2 = !!E4, x2 && "get" in E4 && !("originalValue" in E4.get) ? h = E4.get : h = h[S4];
        } else x2 = Tv2(h, S4), h = h[S4];
        x2 && !d && (Mp2[u5] = h);
      }
    }
    return h;
  }, "GetIntrinsic");
});
var Pv = L((Vat, q4) => {
  a();
  var X4 = lC(), Y4 = Mv(), Lk2 = Y4([X4("%String.prototype.indexOf%")]);
  q4.exports = H$3(function(t, e) {
    var n4 = X4(t, !!e);
    return typeof n4 == "function" && Lk2(t, ".prototype.") > -1 ? Y4([n4]) : n4;
  }, "callBoundIntrinsic");
});
var $4 = L((zat, Z4) => {
  a();
  var Ak = xv()(), Nk2 = Pv(), uC2 = Nk2("Object.prototype.toString"), Ev2 = H$3(function(t) {
    return Ak && t && typeof t == "object" && Symbol.toStringTag in t ? false : uC2(t) === "[object Arguments]";
  }, "isArguments"), W4 = H$3(function(t) {
    return Ev2(t) ? true : t !== null && typeof t == "object" && "length" in t && typeof t.length == "number" && t.length >= 0 && uC2(t) !== "[object Array]" && "callee" in t && uC2(t.callee) === "[object Function]";
  }, "isArguments"), kk = (function() {
    return Ev2(arguments);
  })();
  Ev2.isLegacyArguments = W4;
  Z4.exports = kk ? Ev2 : W4;
});
var Ov = L((Yat, Q4) => {
  a();
  var J4 = Sg(), Rk2 = Q_(), ad3 = Sp(), K4 = Ip();
  Q4.exports = H$3(function(t, e, n4) {
    if (!t || typeof t != "object" && typeof t != "function") throw new ad3("`obj` must be an object or a function`");
    if (typeof e != "string" && typeof e != "symbol") throw new ad3("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new ad3("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new ad3("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new ad3("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new ad3("`loose`, if provided, must be a boolean");
    var i = arguments.length > 3 ? arguments[3] : null, a4 = arguments.length > 4 ? arguments[4] : null, u5 = arguments.length > 5 ? arguments[5] : null, h = arguments.length > 6 ? arguments[6] : false, d = !!K4 && K4(t, e);
    if (J4) J4(t, e, { configurable: u5 === null && d ? d.configurable : !u5, enumerable: i === null && d ? d.enumerable : !i, value: n4, writable: a4 === null && d ? d.writable : !a4 });
    else if (h || !i && !a4 && !u5) t[e] = n4;
    else throw new Rk2("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, "defineDataProperty");
});
var Dv = L((Zat, e5) => {
  a();
  var cC2 = Sg(), t5 = H$3(function() {
    return !!cC2;
  }, "hasPropertyDescriptors");
  t5.hasArrayLengthDefineBug = H$3(function() {
    if (!cC2) return null;
    try {
      return cC2([], "length", { value: 1 }).length !== 1;
    } catch (t) {
      return true;
    }
  }, "hasArrayLengthDefineBug");
  e5.exports = t5;
});
var ld = L((Kat, o52) => {
  a();
  var Fk = Z_(), Bk2 = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", Gk2 = Object.prototype.toString, Vk2 = Array.prototype.concat, r5 = Ov(), jk2 = H$3(function(r6) {
    return typeof r6 == "function" && Gk2.call(r6) === "[object Function]";
  }, "isFunction"), n5 = Dv()(), Uk2 = H$3(function(r6, t, e, n4) {
    if (t in r6) {
      if (n4 === true) {
        if (r6[t] === e) return;
      } else if (!jk2(n4) || !n4()) return;
    }
    n5 ? r5(r6, t, e, true) : r5(r6, t, e);
  }, "defineProperty"), i5 = H$3(function(r6, t) {
    var e = arguments.length > 2 ? arguments[2] : {}, n4 = Fk(t);
    Bk2 && (n4 = Vk2.call(n4, Object.getOwnPropertySymbols(t)));
    for (var i = 0; i < n4.length; i += 1) Uk2(r6, n4[i], t[n4[i]], e[n4[i]]);
  }, "defineProperties");
  i5.supportsDescriptors = !!n5;
  o52.exports = i5;
});
var c5 = L((elt, u5) => {
  a();
  var zk2 = lC(), s5 = Ov(), Hk2 = Dv()(), a52 = Ip(), l5 = Sp(), Xk2 = zk2("%Math.floor%");
  u5.exports = H$3(function(t, e) {
    if (typeof t != "function") throw new l5("`fn` is not a function");
    if (typeof e != "number" || e < 0 || e > 4294967295 || Xk2(e) !== e) throw new l5("`length` must be a positive 32-bit integer");
    var n4 = arguments.length > 2 && !!arguments[2], i = true, a4 = true;
    if ("length" in t && a52) {
      var u6 = a52(t, "length");
      u6 && !u6.configurable && (i = false), u6 && !u6.writable && (a4 = false);
    }
    return (i || a4 || !n4) && (Hk2 ? s5(t, "length", e, true, true) : s5(t, "length", e)), t;
  }, "setFunctionLength");
});
var h5 = L((ilt, p52) => {
  a();
  var Yk2 = rd2(), qk2 = Iv(), Wk2 = rC();
  p52.exports = H$3(function() {
    return Wk2(Yk2, qk2, arguments);
  }, "applyBind");
});
var pC = L((alt, Lv2) => {
  a();
  var Zk2 = c5(), f5 = Sg(), $k2 = Mv(), d5 = h5();
  Lv2.exports = H$3(function(t) {
    var e = $k2(arguments), n4 = t.length - (arguments.length - 1);
    return Zk2(e, 1 + (n4 > 0 ? n4 : 0), true);
  }, "callBind");
  f5 ? f5(Lv2.exports, "apply", { value: d5 }) : Lv2.exports.apply = d5;
});
var hC = L((clt, g5) => {
  a();
  var m5 = H$3(function(r5) {
    return r5 !== r5;
  }, "numberIsNaN");
  g5.exports = H$3(function(t, e) {
    return t === 0 && e === 0 ? 1 / t === 1 / e : !!(t === e || m5(t) && m5(e));
  }, "is");
});
var fC = L((flt, y5) => {
  a();
  var Jk2 = hC();
  y5.exports = H$3(function() {
    return typeof Object.is == "function" ? Object.is : Jk2;
  }, "getPolyfill");
});
var b5 = L((glt, v5) => {
  a();
  var Kk2 = fC(), Qk2 = ld();
  v5.exports = H$3(function() {
    var t = Kk2();
    return Qk2(Object, { is: t }, { is: H$3(function() {
      return Object.is !== t;
    }, "testObjectIs") }), t;
  }, "shimObjectIs");
});
var S5 = L((blt, C5) => {
  a();
  var tR = ld(), eR = pC(), rR = hC(), x5 = fC(), nR2 = b5(), _5 = eR(x5(), Object);
  tR(_5, { getPolyfill: x5, implementation: rR, shim: nR2 });
  C5.exports = _5;
});
var E5 = L((_lt, P5) => {
  a();
  var I5 = Pv(), iR = xv()(), oR2 = oC(), sR = Ip(), gC2;
  iR ? (M5 = I5("RegExp.prototype.exec"), dC2 = {}, Av2 = H$3(function() {
    throw dC2;
  }, "throwRegexMarker"), mC2 = { toString: Av2, valueOf: Av2 }, typeof Symbol.toPrimitive == "symbol" && (mC2[Symbol.toPrimitive] = Av2), gC2 = H$3(function(t) {
    if (!t || typeof t != "object") return false;
    var e = sR(t, "lastIndex"), n4 = e && oR2(e, "value");
    if (!n4) return false;
    try {
      M5(t, mC2);
    } catch (i) {
      return i === dC2;
    }
  }, "isRegex")) : (T5 = I5("Object.prototype.toString"), w5 = "[object RegExp]", gC2 = H$3(function(t) {
    return !t || typeof t != "object" && typeof t != "function" ? false : T5(t) === w5;
  }, "isRegex"));
  var M5, dC2, Av2, mC2, T5, w5;
  P5.exports = gC2;
});
var D5 = L((Ilt, O5) => {
  a();
  var Pg3 = H$3(function() {
    return typeof H$3(function() {
    }, "f").name == "string";
  }, "functionsHaveNames"), wg2 = Object.getOwnPropertyDescriptor;
  if (wg2) try {
    wg2([], "length");
  } catch (r5) {
    wg2 = null;
  }
  Pg3.functionsHaveConfigurableNames = H$3(function() {
    if (!Pg3() || !wg2) return false;
    var t = wg2(function() {
    }, "name");
    return !!t && !!t.configurable;
  }, "functionsHaveConfigurableNames");
  var aR = Function.prototype.bind;
  Pg3.boundFunctionsHaveNames = H$3(function() {
    return Pg3() && typeof aR == "function" && H$3(function() {
    }, "f").bind().name !== "";
  }, "boundFunctionsHaveNames");
  O5.exports = Pg3;
});
var N5 = L((wlt, A5) => {
  a();
  var L5 = Ov(), lR = Dv()(), uR = D5().functionsHaveConfigurableNames(), cR = Sp();
  A5.exports = H$3(function(t, e) {
    if (typeof t != "function") throw new cR("`fn` is not a function");
    var n4 = arguments.length > 2 && !!arguments[2];
    return (!n4 || uR) && (lR ? L5(t, "name", e, true, true) : L5(t, "name", e)), t;
  }, "setFunctionName");
});
var yC = L((Olt, k5) => {
  a();
  var pR = N5(), hR = Sp(), fR = Object;
  k5.exports = pR(H$3(function() {
    if (this == null || this !== fR(this)) throw new hR("RegExp.prototype.flags getter called on non-object");
    var t = "";
    return this.hasIndices && (t += "d"), this.global && (t += "g"), this.ignoreCase && (t += "i"), this.multiline && (t += "m"), this.dotAll && (t += "s"), this.unicode && (t += "u"), this.unicodeSets && (t += "v"), this.sticky && (t += "y"), t;
  }, "flags"), "get flags", true);
});
var vC = L((Alt, R5) => {
  a();
  var dR = yC(), mR = ld().supportsDescriptors, gR = Object.getOwnPropertyDescriptor;
  R5.exports = H$3(function() {
    if (mR && /a/mig.flags === "gim") {
      var t = gR(RegExp.prototype, "flags");
      if (t && typeof t.get == "function" && "dotAll" in RegExp.prototype && "hasIndices" in RegExp.prototype) {
        var e = "", n4 = {};
        if (Object.defineProperty(n4, "hasIndices", { get: H$3(function() {
          e += "d";
        }, "get") }), Object.defineProperty(n4, "sticky", { get: H$3(function() {
          e += "y";
        }, "get") }), t.get.call(n4), e === "dy") return t.get;
      }
    }
    return dR;
  }, "getPolyfill");
});
var G5 = L((Rlt, B5) => {
  a();
  var yR = ld().supportsDescriptors, vR = vC(), bR = Ip(), xR = Object.defineProperty, _R = K_(), F5 = iC(), CR = /a/;
  B5.exports = H$3(function() {
    if (!yR || !F5) throw new _R("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    var t = vR(), e = F5(CR), n4 = bR(e, "flags");
    return (!n4 || n4.get !== t) && xR(e, "flags", { configurable: true, enumerable: false, get: t }), t;
  }, "shimFlags");
});
var z5 = L((Glt, U5) => {
  a();
  var SR = ld(), IR = pC(), MR = yC(), V5 = vC(), TR = G5(), j5 = IR(V5());
  SR(j5, { getPolyfill: V5, implementation: MR, shim: TR });
  U5.exports = j5;
});
var Y5 = L((jlt, X5) => {
  a();
  var H5 = Pv(), wR = H5("Date.prototype.getDay"), PR = H$3(function(t) {
    try {
      return wR(t), true;
    } catch (e) {
      return false;
    }
  }, "tryDateGetDayCall"), ER = H5("Object.prototype.toString"), OR = "[object Date]", DR = xv()();
  X5.exports = H$3(function(t) {
    return typeof t != "object" || t === null ? false : DR ? PR(t) : ER(t) === OR;
  }, "isDateObject");
});
var bC = L((Hlt, n6) => {
  a();
  var q5 = Z_(), W5 = $4(), Z5 = S5(), $5 = E5(), J5 = z5(), K5 = Y5(), Q5 = Date.prototype.getTime;
  function r6(r5, t, e) {
    var n4 = e || {};
    return (n4.strict ? Z5(r5, t) : r5 === t) ? true : !r5 || !t || typeof r5 != "object" && typeof t != "object" ? n4.strict ? Z5(r5, t) : r5 == t : LR(r5, t, n4);
  }
  H$3(r6, "deepEqual");
  function t6(r5) {
    return r5 == null;
  }
  H$3(t6, "isUndefinedOrNull");
  function e6(r5) {
    return !(!r5 || typeof r5 != "object" || typeof r5.length != "number" || typeof r5.copy != "function" || typeof r5.slice != "function" || r5.length > 0 && typeof r5[0] != "number");
  }
  H$3(e6, "isBuffer");
  function LR(r5, t, e) {
    var n4, i;
    if (typeof r5 != typeof t || t6(r5) || t6(t) || r5.prototype !== t.prototype || W5(r5) !== W5(t)) return false;
    var a4 = $5(r5), u5 = $5(t);
    if (a4 !== u5) return false;
    if (a4 || u5) return r5.source === t.source && J5(r5) === J5(t);
    if (K5(r5) && K5(t)) return Q5.call(r5) === Q5.call(t);
    var h = e6(r5), d = e6(t);
    if (h !== d) return false;
    if (h || d) {
      if (r5.length !== t.length) return false;
      for (n4 = 0; n4 < r5.length; n4++) if (r5[n4] !== t[n4]) return false;
      return true;
    }
    if (typeof r5 != typeof t) return false;
    try {
      var m5 = q5(r5), v3 = q5(t);
    } catch (x2) {
      return false;
    }
    if (m5.length !== v3.length) return false;
    for (m5.sort(), v3.sort(), n4 = m5.length - 1; n4 >= 0; n4--) if (m5[n4] != v3[n4]) return false;
    for (n4 = m5.length - 1; n4 >= 0; n4--) if (i = m5[n4], !r6(r5[i], t[i], e)) return false;
    return true;
  }
  H$3(LR, "objEquiv");
  n6.exports = r6;
});
var LC = L((Gpt, p6) => {
  a();
  var PF = bC(), $a2 = H$3(function(r5) {
    this.precision = r5 && r5.precision ? r5.precision : 17, this.direction = r5 && r5.direction ? r5.direction : false, this.pseudoNode = r5 && r5.pseudoNode ? r5.pseudoNode : false, this.objectComparator = r5 && r5.objectComparator ? r5.objectComparator : EF;
  }, "Equality");
  $a2.prototype.compare = function(r5, t) {
    if (r5.type !== t.type || !c6(r5, t)) return false;
    switch (r5.type) {
      case "Point":
        return this.compareCoord(r5.coordinates, t.coordinates);
      case "LineString":
        return this.compareLine(r5.coordinates, t.coordinates, 0, false);
      case "Polygon":
        return this.comparePolygon(r5, t);
      case "Feature":
        return this.compareFeature(r5, t);
      default:
        if (r5.type.indexOf("Multi") === 0) {
          var e = this, n4 = u6(r5), i = u6(t);
          return n4.every(function(a4) {
            return this.some(function(u5) {
              return e.compare(a4, u5);
            });
          }, i);
        }
    }
    return false;
  };
  function u6(r5) {
    return r5.coordinates.map(function(t) {
      return { type: r5.type.replace("Multi", ""), coordinates: t };
    });
  }
  H$3(u6, "explode");
  function c6(r5, t) {
    return r5.hasOwnProperty("coordinates") ? r5.coordinates.length === t.coordinates.length : r5.length === t.length;
  }
  H$3(c6, "sameLength");
  $a2.prototype.compareCoord = function(r5, t) {
    if (r5.length !== t.length) return false;
    for (var e = 0; e < r5.length; e++) if (r5[e].toFixed(this.precision) !== t[e].toFixed(this.precision)) return false;
    return true;
  };
  $a2.prototype.compareLine = function(r5, t, e, n4) {
    if (!c6(r5, t)) return false;
    var i = this.pseudoNode ? r5 : this.removePseudo(r5), a4 = this.pseudoNode ? t : this.removePseudo(t);
    if (!(n4 && !this.compareCoord(i[0], a4[0]) && (a4 = this.fixStartIndex(a4, i), !a4))) {
      var u5 = this.compareCoord(i[e], a4[e]);
      return this.direction || u5 ? this.comparePath(i, a4) : this.compareCoord(i[e], a4[a4.length - (1 + e)]) ? this.comparePath(i.slice().reverse(), a4) : false;
    }
  };
  $a2.prototype.fixStartIndex = function(r5, t) {
    for (var e, n4 = -1, i = 0; i < r5.length; i++) if (this.compareCoord(r5[i], t[0])) {
      n4 = i;
      break;
    }
    return n4 >= 0 && (e = [].concat(r5.slice(n4, r5.length), r5.slice(1, n4 + 1))), e;
  };
  $a2.prototype.comparePath = function(r5, t) {
    var e = this;
    return r5.every(function(n4, i) {
      return e.compareCoord(n4, this[i]);
    }, t);
  };
  $a2.prototype.comparePolygon = function(r5, t) {
    if (this.compareLine(r5.coordinates[0], t.coordinates[0], 1, true)) {
      var e = r5.coordinates.slice(1, r5.coordinates.length), n4 = t.coordinates.slice(1, t.coordinates.length), i = this;
      return e.every(function(a4) {
        return this.some(function(u5) {
          return i.compareLine(a4, u5, 1, true);
        });
      }, n4);
    } else return false;
  };
  $a2.prototype.compareFeature = function(r5, t) {
    return r5.id !== t.id || !this.objectComparator(r5.properties, t.properties) || !this.compareBBox(r5, t) ? false : this.compare(r5.geometry, t.geometry);
  };
  $a2.prototype.compareBBox = function(r5, t) {
    return !!(!r5.bbox && !t.bbox || r5.bbox && t.bbox && this.compareCoord(r5.bbox, t.bbox));
  };
  $a2.prototype.removePseudo = function(r5) {
    return r5;
  };
  function EF(r5, t) {
    return PF(r5, t, { strict: true });
  }
  H$3(EF, "objectComparator");
  p6.exports = $a2;
});
var h6 = L((oht, Rv2) => {
  a();
  function lc2(r5, t, e, n4) {
    this.dataset = [], this.epsilon = 1, this.minPts = 2, this.distance = this._euclideanDistance, this.clusters = [], this.noise = [], this._visited = [], this._assigned = [], this._datasetLength = 0, this._init(r5, t, e, n4);
  }
  H$3(lc2, "DBSCAN");
  lc2.prototype.run = function(r5, t, e, n4) {
    this._init(r5, t, e, n4);
    for (var i = 0; i < this._datasetLength; i++) if (this._visited[i] !== 1) {
      this._visited[i] = 1;
      var a4 = this._regionQuery(i);
      if (a4.length < this.minPts) this.noise.push(i);
      else {
        var u5 = this.clusters.length;
        this.clusters.push([]), this._addToCluster(i, u5), this._expandCluster(u5, a4);
      }
    }
    return this.clusters;
  };
  lc2.prototype._init = function(r5, t, e, n4) {
    if (r5) {
      if (!(r5 instanceof Array)) throw Error("Dataset must be of type array, " + typeof r5 + " given");
      this.dataset = r5, this.clusters = [], this.noise = [], this._datasetLength = r5.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength);
    }
    t && (this.epsilon = t), e && (this.minPts = e), n4 && (this.distance = n4);
  };
  lc2.prototype._expandCluster = function(r5, t) {
    for (var e = 0; e < t.length; e++) {
      var n4 = t[e];
      if (this._visited[n4] !== 1) {
        this._visited[n4] = 1;
        var i = this._regionQuery(n4);
        i.length >= this.minPts && (t = this._mergeArrays(t, i));
      }
      this._assigned[n4] !== 1 && this._addToCluster(n4, r5);
    }
  };
  lc2.prototype._addToCluster = function(r5, t) {
    this.clusters[t].push(r5), this._assigned[r5] = 1;
  };
  lc2.prototype._regionQuery = function(r5) {
    for (var t = [], e = 0; e < this._datasetLength; e++) {
      var n4 = this.distance(this.dataset[r5], this.dataset[e]);
      n4 < this.epsilon && t.push(e);
    }
    return t;
  };
  lc2.prototype._mergeArrays = function(r5, t) {
    for (var e = t.length, n4 = 0; n4 < e; n4++) {
      var i = t[n4];
      r5.indexOf(i) < 0 && r5.push(i);
    }
    return r5;
  };
  lc2.prototype._euclideanDistance = function(r5, t) {
    for (var e = 0, n4 = Math.min(r5.length, t.length); n4--; ) e += (r5[n4] - t[n4]) * (r5[n4] - t[n4]);
    return Math.sqrt(e);
  };
  typeof Rv2 < "u" && Rv2.exports && (Rv2.exports = lc2);
});
var f6 = L((lht, Fv2) => {
  a();
  function uc2(r5, t, e) {
    this.k = 3, this.dataset = [], this.assignments = [], this.centroids = [], this.init(r5, t, e);
  }
  H$3(uc2, "KMEANS");
  uc2.prototype.init = function(r5, t, e) {
    this.assignments = [], this.centroids = [], typeof r5 < "u" && (this.dataset = r5), typeof t < "u" && (this.k = t), typeof e < "u" && (this.distance = e);
  };
  uc2.prototype.run = function(r5, t) {
    this.init(r5, t);
    for (var e = this.dataset.length, n4 = 0; n4 < this.k; n4++) this.centroids[n4] = this.randomCentroid();
    for (var i = true; i; ) {
      i = this.assign();
      for (var a4 = 0; a4 < this.k; a4++) {
        for (var u5 = new Array(v3), h = 0, d = 0; d < v3; d++) u5[d] = 0;
        for (var m5 = 0; m5 < e; m5++) {
          var v3 = this.dataset[m5].length;
          if (a4 === this.assignments[m5]) {
            for (var d = 0; d < v3; d++) u5[d] += this.dataset[m5][d];
            h++;
          }
        }
        if (h > 0) {
          for (var d = 0; d < v3; d++) u5[d] /= h;
          this.centroids[a4] = u5;
        } else this.centroids[a4] = this.randomCentroid(), i = true;
      }
    }
    return this.getClusters();
  };
  uc2.prototype.randomCentroid = function() {
    var r5 = this.dataset.length - 1, t, e;
    do
      e = Math.round(Math.random() * r5), t = this.dataset[e];
    while (this.centroids.indexOf(t) >= 0);
    return t;
  };
  uc2.prototype.assign = function() {
    for (var r5 = false, t = this.dataset.length, e, n4 = 0; n4 < t; n4++) e = this.argmin(this.dataset[n4], this.centroids, this.distance), e != this.assignments[n4] && (this.assignments[n4] = e, r5 = true);
    return r5;
  };
  uc2.prototype.getClusters = function() {
    for (var r5 = new Array(this.k), t, e = 0; e < this.assignments.length; e++) t = this.assignments[e], typeof r5[t] > "u" && (r5[t] = []), r5[t].push(e);
    return r5;
  };
  uc2.prototype.argmin = function(r5, t, e) {
    for (var n4 = Number.MAX_VALUE, i = 0, a4 = t.length, u5, h = 0; h < a4; h++) u5 = e(r5, t[h]), u5 < n4 && (n4 = u5, i = h);
    return i;
  };
  uc2.prototype.distance = function(r5, t) {
    for (var e = 0, n4 = Math.min(r5.length, t.length); n4--; ) {
      var i = r5[n4] - t[n4];
      e += i * i;
    }
    return Math.sqrt(e);
  };
  typeof Fv2 < "u" && Fv2.exports && (Fv2.exports = uc2);
});
var AC = L((pht, Bv2) => {
  a();
  function Ja2(r5, t, e) {
    this._queue = [], this._priorities = [], this._sorting = "desc", this._init(r5, t, e);
  }
  H$3(Ja2, "PriorityQueue");
  Ja2.prototype.insert = function(r5, t) {
    for (var e = this._queue.length, n4 = e; n4--; ) {
      var i = this._priorities[n4];
      this._sorting === "desc" ? t > i && (e = n4) : t < i && (e = n4);
    }
    this._insertAt(r5, t, e);
  };
  Ja2.prototype.remove = function(r5) {
    for (var t = this._queue.length; t--; ) {
      var e = this._queue[t];
      if (r5 === e) {
        this._queue.splice(t, 1), this._priorities.splice(t, 1);
        break;
      }
    }
  };
  Ja2.prototype.forEach = function(r5) {
    this._queue.forEach(r5);
  };
  Ja2.prototype.getElements = function() {
    return this._queue;
  };
  Ja2.prototype.getElementPriority = function(r5) {
    return this._priorities[r5];
  };
  Ja2.prototype.getPriorities = function() {
    return this._priorities;
  };
  Ja2.prototype.getElementsWithPriorities = function() {
    for (var r5 = [], t = 0, e = this._queue.length; t < e; t++) r5.push([this._queue[t], this._priorities[t]]);
    return r5;
  };
  Ja2.prototype._init = function(r5, t, e) {
    if (r5 && t) {
      if (this._queue = [], this._priorities = [], r5.length !== t.length) throw new Error("Arrays must have the same length");
      for (var n4 = 0; n4 < r5.length; n4++) this.insert(r5[n4], t[n4]);
    }
    e && (this._sorting = e);
  };
  Ja2.prototype._insertAt = function(r5, t, e) {
    this._queue.length === e ? (this._queue.push(r5), this._priorities.push(t)) : (this._queue.splice(e, 0, r5), this._priorities.splice(e, 0, t));
  };
  typeof Bv2 < "u" && Bv2.exports && (Bv2.exports = Ja2);
});
var m6 = L((dht, cd3) => {
  a();
  typeof cd3 < "u" && cd3.exports && (d6 = AC());
  var d6;
  function Wl2(r5, t, e, n4) {
    this.epsilon = 1, this.minPts = 1, this.distance = this._euclideanDistance, this._reachability = [], this._processed = [], this._coreDistance = 0, this._orderedList = [], this._init(r5, t, e, n4);
  }
  H$3(Wl2, "OPTICS");
  Wl2.prototype.run = function(r5, t, e, n4) {
    this._init(r5, t, e, n4);
    for (var i = 0, a4 = this.dataset.length; i < a4; i++) if (this._processed[i] !== 1) {
      this._processed[i] = 1, this.clusters.push([i]);
      var u5 = this.clusters.length - 1;
      this._orderedList.push(i);
      var h = new d6(null, null, "asc"), d = this._regionQuery(i);
      this._distanceToCore(i) !== void 0 && (this._updateQueue(i, d, h), this._expandCluster(u5, h));
    }
    return this.clusters;
  };
  Wl2.prototype.getReachabilityPlot = function() {
    for (var r5 = [], t = 0, e = this._orderedList.length; t < e; t++) {
      var n4 = this._orderedList[t], i = this._reachability[n4];
      r5.push([n4, i]);
    }
    return r5;
  };
  Wl2.prototype._init = function(r5, t, e, n4) {
    if (r5) {
      if (!(r5 instanceof Array)) throw Error("Dataset must be of type array, " + typeof r5 + " given");
      this.dataset = r5, this.clusters = [], this._reachability = new Array(this.dataset.length), this._processed = new Array(this.dataset.length), this._coreDistance = 0, this._orderedList = [];
    }
    t && (this.epsilon = t), e && (this.minPts = e), n4 && (this.distance = n4);
  };
  Wl2.prototype._updateQueue = function(r5, t, e) {
    var n4 = this;
    this._coreDistance = this._distanceToCore(r5), t.forEach(function(i) {
      if (n4._processed[i] === void 0) {
        var a4 = n4.distance(n4.dataset[r5], n4.dataset[i]), u5 = Math.max(n4._coreDistance, a4);
        n4._reachability[i] === void 0 ? (n4._reachability[i] = u5, e.insert(i, u5)) : u5 < n4._reachability[i] && (n4._reachability[i] = u5, e.remove(i), e.insert(i, u5));
      }
    });
  };
  Wl2.prototype._expandCluster = function(r5, t) {
    for (var e = t.getElements(), n4 = 0, i = e.length; n4 < i; n4++) {
      var a4 = e[n4];
      if (this._processed[a4] === void 0) {
        var u5 = this._regionQuery(a4);
        this._processed[a4] = 1, this.clusters[r5].push(a4), this._orderedList.push(a4), this._distanceToCore(a4) !== void 0 && (this._updateQueue(a4, u5, t), this._expandCluster(r5, t));
      }
    }
  };
  Wl2.prototype._distanceToCore = function(r5) {
    for (var t = this.epsilon, e = 0; e < t; e++) {
      var n4 = this._regionQuery(r5, e);
      if (n4.length >= this.minPts) return e;
    }
  };
  Wl2.prototype._regionQuery = function(r5, t) {
    t = t || this.epsilon;
    for (var e = [], n4 = 0, i = this.dataset.length; n4 < i; n4++) this.distance(this.dataset[r5], this.dataset[n4]) < t && e.push(n4);
    return e;
  };
  Wl2.prototype._euclideanDistance = function(r5, t) {
    for (var e = 0, n4 = Math.min(r5.length, t.length); n4--; ) e += (r5[n4] - t[n4]) * (r5[n4] - t[n4]);
    return Math.sqrt(e);
  };
  typeof cd3 < "u" && cd3.exports && (cd3.exports = Wl2);
});
var g6 = L((yht, Gv) => {
  a();
  typeof Gv < "u" && Gv.exports && (Gv.exports = { DBSCAN: h6(), KMEANS: f6(), OPTICS: m6(), PriorityQueue: AC() });
});
var NC = L((Tht, v6) => {
  a();
  v6.exports = { eudist: H$3(function(t, e, n4) {
    for (var i = t.length, a4 = 0, u5 = 0; u5 < i; u5++) {
      var h = (t[u5] || 0) - (e[u5] || 0);
      a4 += h * h;
    }
    return n4 ? Math.sqrt(a4) : a4;
  }, "eudist"), mandist: H$3(function(t, e, n4) {
    for (var i = t.length, a4 = 0, u5 = 0; u5 < i; u5++) a4 += Math.abs((t[u5] || 0) - (e[u5] || 0));
    return n4 ? Math.sqrt(a4) : a4;
  }, "mandist"), dist: H$3(function(t, e, n4) {
    var i = Math.abs(t - e);
    return n4 ? i : i * i;
  }, "dist") };
});
var _6 = L((Eht, x6) => {
  a();
  var b6 = NC(), NF = b6.eudist, kF = b6.dist;
  x6.exports = { kmrand: H$3(function(t, e) {
    for (var n4 = {}, i = [], a4 = e << 2, u5 = t.length, h = t[0].length > 0; i.length < e && a4-- > 0; ) {
      var d = t[Math.floor(Math.random() * u5)], m5 = h ? d.join("_") : "" + d;
      n4[m5] || (n4[m5] = true, i.push(d));
    }
    if (i.length < e) throw new Error("Error initializating clusters");
    return i;
  }, "kmrand"), kmpp: H$3(function(t, e) {
    var n4 = t[0].length ? NF : kF, i = [], a4 = t.length, u5 = t[0].length > 0, d = t[Math.floor(Math.random() * a4)];
    u5 ? d.join("_") : "" + d;
    for (i.push(d), true; i.length < e; ) {
      for (var v3 = [], x2 = i.length, S4 = 0, I3 = [], w3 = 0; w3 < a4; w3++) {
        for (var E4 = 1 / 0, T3 = 0; T3 < x2; T3++) {
          var D4 = n4(t[w3], i[T3]);
          D4 <= E4 && (E4 = D4);
        }
        v3[w3] = E4;
      }
      for (var A3 = 0; A3 < a4; A3++) S4 += v3[A3];
      for (var L3 = 0; L3 < a4; L3++) I3[L3] = { i: L3, v: t[L3], pr: v3[L3] / S4, cs: 0 };
      I3.sort(function($5, F3) {
        return $5.pr - F3.pr;
      }), I3[0].cs = I3[0].pr;
      for (var B3 = 1; B3 < a4; B3++) I3[B3].cs = I3[B3 - 1].cs + I3[B3].pr;
      for (var j3 = Math.random(), W4 = 0; W4 < a4 - 1 && I3[W4++].cs < j3; ) ;
      i.push(I3[W4 - 1].v);
    }
    return i;
  }, "kmpp") };
});
var T6 = L((Nht, M6) => {
  a();
  var kC2 = NC(), I6 = _6(), RF = kC2.eudist;
  kC2.mandist;
  kC2.dist;
  var FF = I6.kmrand, BF = I6.kmpp, C6 = 1e4;
  function S6(r5, t, e) {
    e = e || [];
    for (var n4 = 0; n4 < r5; n4++) e[n4] = t;
    return e;
  }
  H$3(S6, "init");
  function GF(r5, t, e, n4) {
    var i = [], a4 = [], u5 = [], h = [], d = false, m5 = n4 || C6, v3 = r5.length, x2 = r5[0].length, S4 = x2 > 0, I3 = [];
    if (e) e == "kmrand" ? i = FF(r5, t) : e == "kmpp" ? i = BF(r5, t) : i = e;
    else for (var w3 = {}; i.length < t; ) {
      var E4 = Math.floor(Math.random() * v3);
      w3[E4] || (w3[E4] = true, i.push(r5[E4]));
    }
    do {
      S6(t, 0, I3);
      for (var T3 = 0; T3 < v3; T3++) {
        for (var D4 = 1 / 0, A3 = 0, L3 = 0; L3 < t; L3++) {
          var h = S4 ? RF(r5[T3], i[L3]) : Math.abs(r5[T3] - i[L3]);
          h <= D4 && (D4 = h, A3 = L3);
        }
        u5[T3] = A3, I3[A3]++;
      }
      for (var B3 = [], a4 = [], j3 = 0, W4 = 0; W4 < t; W4++) B3[W4] = S4 ? S6(x2, 0, B3[W4]) : 0, a4[W4] = i[W4];
      if (S4) {
        for (var $5 = 0; $5 < t; $5++) i[$5] = [];
        for (var F3 = 0; F3 < v3; F3++) for (var J4 = u5[F3], ot2 = B3[J4], K4 = r5[F3], H5 = 0; H5 < x2; H5++) ot2[H5] += K4[H5];
        d = true;
        for (var _t2 = 0; _t2 < t; _t2++) {
          for (var ct2 = i[_t2], ft2 = B3[_t2], mt2 = a4[_t2], St2 = I3[_t2], dt2 = 0; dt2 < x2; dt2++) ct2[dt2] = ft2[dt2] / St2 || 0;
          if (d) {
            for (var xt2 = 0; xt2 < x2; xt2++) if (mt2[xt2] != ct2[xt2]) {
              d = false;
              break;
            }
          }
        }
      } else {
        for (var q4 = 0; q4 < v3; q4++) {
          var ee2 = u5[q4];
          B3[ee2] += r5[q4];
        }
        for (var Gt2 = 0; Gt2 < t; Gt2++) i[Gt2] = B3[Gt2] / I3[Gt2] || 0;
        d = true;
        for (var Kt2 = 0; Kt2 < t; Kt2++) if (a4[Kt2] != i[Kt2]) {
          d = false;
          break;
        }
      }
      d = d || --m5 <= 0;
    } while (!d);
    return { it: C6 - m5, k: t, idxs: u5, centroids: i };
  }
  H$3(GF, "skmeans");
  M6.exports = GF;
});
var md2 = L((jC2, UC2) => {
  a();
  (function(r5, t) {
    typeof jC2 == "object" && typeof UC2 < "u" ? UC2.exports = t() : typeof define == "function" && define.amd ? define(t) : (r5 = typeof globalThis < "u" ? globalThis : r5 || self, r5.polygonClipping = t());
  })(jC2, function() {
    function r5(et2, O4) {
      var k3 = { label: 0, sent: H$3(function() {
        if (X4[0] & 1) throw X4[1];
        return X4[1];
      }, "sent"), trys: [], ops: [] }, z4, Y3, X4, pt2;
      return pt2 = { next: lt2(0), throw: lt2(1), return: lt2(2) }, typeof Symbol == "function" && (pt2[Symbol.iterator] = function() {
        return this;
      }), pt2;
      function lt2(ht2) {
        return function(Rt2) {
          return vt2([ht2, Rt2]);
        };
      }
      function vt2(ht2) {
        if (z4) throw new TypeError("Generator is already executing.");
        for (; k3; ) try {
          if (z4 = 1, Y3 && (X4 = ht2[0] & 2 ? Y3.return : ht2[0] ? Y3.throw || ((X4 = Y3.return) && X4.call(Y3), 0) : Y3.next) && !(X4 = X4.call(Y3, ht2[1])).done) return X4;
          switch (Y3 = 0, X4 && (ht2 = [ht2[0] & 2, X4.value]), ht2[0]) {
            case 0:
            case 1:
              X4 = ht2;
              break;
            case 4:
              return k3.label++, { value: ht2[1], done: false };
            case 5:
              k3.label++, Y3 = ht2[1], ht2 = [0];
              continue;
            case 7:
              ht2 = k3.ops.pop(), k3.trys.pop();
              continue;
            default:
              if (X4 = k3.trys, !(X4 = X4.length > 0 && X4[X4.length - 1]) && (ht2[0] === 6 || ht2[0] === 2)) {
                k3 = 0;
                continue;
              }
              if (ht2[0] === 3 && (!X4 || ht2[1] > X4[0] && ht2[1] < X4[3])) {
                k3.label = ht2[1];
                break;
              }
              if (ht2[0] === 6 && k3.label < X4[1]) {
                k3.label = X4[1], X4 = ht2;
                break;
              }
              if (X4 && k3.label < X4[2]) {
                k3.label = X4[2], k3.ops.push(ht2);
                break;
              }
              X4[2] && k3.ops.pop(), k3.trys.pop();
              continue;
          }
          ht2 = O4.call(et2, k3);
        } catch (Rt2) {
          ht2 = [6, Rt2], Y3 = 0;
        } finally {
          z4 = X4 = 0;
        }
        if (ht2[0] & 5) throw ht2[1];
        return { value: ht2[0] ? ht2[1] : void 0, done: true };
      }
    }
    H$3(r5, "__generator");
    var t = (function() {
      function et2(O4, k3) {
        this.next = null, this.key = O4, this.data = k3, this.left = null, this.right = null;
      }
      return H$3(et2, "Node"), et2;
    })();
    function e(et2, O4) {
      return et2 > O4 ? 1 : et2 < O4 ? -1 : 0;
    }
    H$3(e, "DEFAULT_COMPARE");
    function n4(et2, O4, k3) {
      for (var z4 = new t(null, null), Y3 = z4, X4 = z4; ; ) {
        var pt2 = k3(et2, O4.key);
        if (pt2 < 0) {
          if (O4.left === null) break;
          if (k3(et2, O4.left.key) < 0) {
            var lt2 = O4.left;
            if (O4.left = lt2.right, lt2.right = O4, O4 = lt2, O4.left === null) break;
          }
          X4.left = O4, X4 = O4, O4 = O4.left;
        } else if (pt2 > 0) {
          if (O4.right === null) break;
          if (k3(et2, O4.right.key) > 0) {
            var lt2 = O4.right;
            if (O4.right = lt2.left, lt2.left = O4, O4 = lt2, O4.right === null) break;
          }
          Y3.right = O4, Y3 = O4, O4 = O4.right;
        } else break;
      }
      return Y3.right = O4.left, X4.left = O4.right, O4.left = z4.right, O4.right = z4.left, O4;
    }
    H$3(n4, "splay");
    function i(et2, O4, k3, z4) {
      var Y3 = new t(et2, O4);
      if (k3 === null) return Y3.left = Y3.right = null, Y3;
      k3 = n4(et2, k3, z4);
      var X4 = z4(et2, k3.key);
      return X4 < 0 ? (Y3.left = k3.left, Y3.right = k3, k3.left = null) : X4 >= 0 && (Y3.right = k3.right, Y3.left = k3, k3.right = null), Y3;
    }
    H$3(i, "insert");
    function a4(et2, O4, k3) {
      var z4 = null, Y3 = null;
      if (O4) {
        O4 = n4(et2, O4, k3);
        var X4 = k3(O4.key, et2);
        X4 === 0 ? (z4 = O4.left, Y3 = O4.right) : X4 < 0 ? (Y3 = O4.right, O4.right = null, z4 = O4) : (z4 = O4.left, O4.left = null, Y3 = O4);
      }
      return { left: z4, right: Y3 };
    }
    H$3(a4, "split");
    function u5(et2, O4, k3) {
      return O4 === null ? et2 : (et2 === null || (O4 = n4(et2.key, O4, k3), O4.left = et2), O4);
    }
    H$3(u5, "merge");
    function h(et2, O4, k3, z4, Y3) {
      if (et2) {
        z4("" + O4 + (k3 ? " " : " ") + Y3(et2) + "\n");
        var X4 = O4 + (k3 ? "    " : "   ");
        et2.left && h(et2.left, X4, false, z4, Y3), et2.right && h(et2.right, X4, true, z4, Y3);
      }
    }
    H$3(h, "printRow");
    var d = (function() {
      function et2(O4) {
        O4 === void 0 && (O4 = e), this._root = null, this._size = 0, this._comparator = O4;
      }
      return H$3(et2, "Tree"), et2.prototype.insert = function(O4, k3) {
        return this._size++, this._root = i(O4, k3, this._root, this._comparator);
      }, et2.prototype.add = function(O4, k3) {
        var z4 = new t(O4, k3);
        this._root === null && (z4.left = z4.right = null, this._size++, this._root = z4);
        var Y3 = this._comparator, X4 = n4(O4, this._root, Y3), pt2 = Y3(O4, X4.key);
        return pt2 === 0 ? this._root = X4 : (pt2 < 0 ? (z4.left = X4.left, z4.right = X4, X4.left = null) : pt2 > 0 && (z4.right = X4.right, z4.left = X4, X4.right = null), this._size++, this._root = z4), this._root;
      }, et2.prototype.remove = function(O4) {
        this._root = this._remove(O4, this._root, this._comparator);
      }, et2.prototype._remove = function(O4, k3, z4) {
        var Y3;
        if (k3 === null) return null;
        k3 = n4(O4, k3, z4);
        var X4 = z4(O4, k3.key);
        return X4 === 0 ? (k3.left === null ? Y3 = k3.right : (Y3 = n4(O4, k3.left, z4), Y3.right = k3.right), this._size--, Y3) : k3;
      }, et2.prototype.pop = function() {
        var O4 = this._root;
        if (O4) {
          for (; O4.left; ) O4 = O4.left;
          return this._root = n4(O4.key, this._root, this._comparator), this._root = this._remove(O4.key, this._root, this._comparator), { key: O4.key, data: O4.data };
        }
        return null;
      }, et2.prototype.findStatic = function(O4) {
        for (var k3 = this._root, z4 = this._comparator; k3; ) {
          var Y3 = z4(O4, k3.key);
          if (Y3 === 0) return k3;
          Y3 < 0 ? k3 = k3.left : k3 = k3.right;
        }
        return null;
      }, et2.prototype.find = function(O4) {
        return this._root && (this._root = n4(O4, this._root, this._comparator), this._comparator(O4, this._root.key) !== 0) ? null : this._root;
      }, et2.prototype.contains = function(O4) {
        for (var k3 = this._root, z4 = this._comparator; k3; ) {
          var Y3 = z4(O4, k3.key);
          if (Y3 === 0) return true;
          Y3 < 0 ? k3 = k3.left : k3 = k3.right;
        }
        return false;
      }, et2.prototype.forEach = function(O4, k3) {
        for (var z4 = this._root, Y3 = [], X4 = false; !X4; ) z4 !== null ? (Y3.push(z4), z4 = z4.left) : Y3.length !== 0 ? (z4 = Y3.pop(), O4.call(k3, z4), z4 = z4.right) : X4 = true;
        return this;
      }, et2.prototype.range = function(O4, k3, z4, Y3) {
        for (var X4 = [], pt2 = this._comparator, lt2 = this._root, vt2; X4.length !== 0 || lt2; ) if (lt2) X4.push(lt2), lt2 = lt2.left;
        else {
          if (lt2 = X4.pop(), vt2 = pt2(lt2.key, k3), vt2 > 0) break;
          if (pt2(lt2.key, O4) >= 0 && z4.call(Y3, lt2)) return this;
          lt2 = lt2.right;
        }
        return this;
      }, et2.prototype.keys = function() {
        var O4 = [];
        return this.forEach(function(k3) {
          var z4 = k3.key;
          return O4.push(z4);
        }), O4;
      }, et2.prototype.values = function() {
        var O4 = [];
        return this.forEach(function(k3) {
          var z4 = k3.data;
          return O4.push(z4);
        }), O4;
      }, et2.prototype.min = function() {
        return this._root ? this.minNode(this._root).key : null;
      }, et2.prototype.max = function() {
        return this._root ? this.maxNode(this._root).key : null;
      }, et2.prototype.minNode = function(O4) {
        if (O4 === void 0 && (O4 = this._root), O4) for (; O4.left; ) O4 = O4.left;
        return O4;
      }, et2.prototype.maxNode = function(O4) {
        if (O4 === void 0 && (O4 = this._root), O4) for (; O4.right; ) O4 = O4.right;
        return O4;
      }, et2.prototype.at = function(O4) {
        for (var k3 = this._root, z4 = false, Y3 = 0, X4 = []; !z4; ) if (k3) X4.push(k3), k3 = k3.left;
        else if (X4.length > 0) {
          if (k3 = X4.pop(), Y3 === O4) return k3;
          Y3++, k3 = k3.right;
        } else z4 = true;
        return null;
      }, et2.prototype.next = function(O4) {
        var k3 = this._root, z4 = null;
        if (O4.right) {
          for (z4 = O4.right; z4.left; ) z4 = z4.left;
          return z4;
        }
        for (var Y3 = this._comparator; k3; ) {
          var X4 = Y3(O4.key, k3.key);
          if (X4 === 0) break;
          X4 < 0 ? (z4 = k3, k3 = k3.left) : k3 = k3.right;
        }
        return z4;
      }, et2.prototype.prev = function(O4) {
        var k3 = this._root, z4 = null;
        if (O4.left !== null) {
          for (z4 = O4.left; z4.right; ) z4 = z4.right;
          return z4;
        }
        for (var Y3 = this._comparator; k3; ) {
          var X4 = Y3(O4.key, k3.key);
          if (X4 === 0) break;
          X4 < 0 ? k3 = k3.left : (z4 = k3, k3 = k3.right);
        }
        return z4;
      }, et2.prototype.clear = function() {
        return this._root = null, this._size = 0, this;
      }, et2.prototype.toList = function() {
        return x2(this._root);
      }, et2.prototype.load = function(O4, k3, z4) {
        k3 === void 0 && (k3 = []), z4 === void 0 && (z4 = false);
        var Y3 = O4.length, X4 = this._comparator;
        if (z4 && w3(O4, k3, 0, Y3 - 1, X4), this._root === null) this._root = m5(O4, k3, 0, Y3), this._size = Y3;
        else {
          var pt2 = I3(this.toList(), v3(O4, k3), X4);
          Y3 = this._size + Y3, this._root = S4({ head: pt2 }, 0, Y3);
        }
        return this;
      }, et2.prototype.isEmpty = function() {
        return this._root === null;
      }, Object.defineProperty(et2.prototype, "size", { get: H$3(function() {
        return this._size;
      }, "get"), enumerable: true, configurable: true }), Object.defineProperty(et2.prototype, "root", { get: H$3(function() {
        return this._root;
      }, "get"), enumerable: true, configurable: true }), et2.prototype.toString = function(O4) {
        O4 === void 0 && (O4 = H$3(function(z4) {
          return String(z4.key);
        }, "printNode"));
        var k3 = [];
        return h(this._root, "", true, function(z4) {
          return k3.push(z4);
        }, O4), k3.join("");
      }, et2.prototype.update = function(O4, k3, z4) {
        var Y3 = this._comparator, X4 = a4(O4, this._root, Y3), pt2 = X4.left, lt2 = X4.right;
        Y3(O4, k3) < 0 ? lt2 = i(k3, z4, lt2, Y3) : pt2 = i(k3, z4, pt2, Y3), this._root = u5(pt2, lt2, Y3);
      }, et2.prototype.split = function(O4) {
        return a4(O4, this._root, this._comparator);
      }, et2.prototype[Symbol.iterator] = function() {
        var O4, k3, z4;
        return r5(this, function(Y3) {
          switch (Y3.label) {
            case 0:
              O4 = this._root, k3 = [], z4 = false, Y3.label = 1;
            case 1:
              return z4 ? [3, 6] : O4 === null ? [3, 2] : (k3.push(O4), O4 = O4.left, [3, 5]);
            case 2:
              return k3.length === 0 ? [3, 4] : (O4 = k3.pop(), [4, O4]);
            case 3:
              return Y3.sent(), O4 = O4.right, [3, 5];
            case 4:
              z4 = true, Y3.label = 5;
            case 5:
              return [3, 1];
            case 6:
              return [2];
          }
        });
      }, et2;
    })();
    function m5(et2, O4, k3, z4) {
      var Y3 = z4 - k3;
      if (Y3 > 0) {
        var X4 = k3 + Math.floor(Y3 / 2), pt2 = et2[X4], lt2 = O4[X4], vt2 = new t(pt2, lt2);
        return vt2.left = m5(et2, O4, k3, X4), vt2.right = m5(et2, O4, X4 + 1, z4), vt2;
      }
      return null;
    }
    H$3(m5, "loadRecursive");
    function v3(et2, O4) {
      for (var k3 = new t(null, null), z4 = k3, Y3 = 0; Y3 < et2.length; Y3++) z4 = z4.next = new t(et2[Y3], O4[Y3]);
      return z4.next = null, k3.next;
    }
    H$3(v3, "createList");
    function x2(et2) {
      for (var O4 = et2, k3 = [], z4 = false, Y3 = new t(null, null), X4 = Y3; !z4; ) O4 ? (k3.push(O4), O4 = O4.left) : k3.length > 0 ? (O4 = X4 = X4.next = k3.pop(), O4 = O4.right) : z4 = true;
      return X4.next = null, Y3.next;
    }
    H$3(x2, "toList");
    function S4(et2, O4, k3) {
      var z4 = k3 - O4;
      if (z4 > 0) {
        var Y3 = O4 + Math.floor(z4 / 2), X4 = S4(et2, O4, Y3), pt2 = et2.head;
        return pt2.left = X4, et2.head = et2.head.next, pt2.right = S4(et2, Y3 + 1, k3), pt2;
      }
      return null;
    }
    H$3(S4, "sortedListToBST");
    function I3(et2, O4, k3) {
      for (var z4 = new t(null, null), Y3 = z4, X4 = et2, pt2 = O4; X4 !== null && pt2 !== null; ) k3(X4.key, pt2.key) < 0 ? (Y3.next = X4, X4 = X4.next) : (Y3.next = pt2, pt2 = pt2.next), Y3 = Y3.next;
      return X4 !== null ? Y3.next = X4 : pt2 !== null && (Y3.next = pt2), z4.next;
    }
    H$3(I3, "mergeLists");
    function w3(et2, O4, k3, z4, Y3) {
      if (!(k3 >= z4)) {
        for (var X4 = et2[k3 + z4 >> 1], pt2 = k3 - 1, lt2 = z4 + 1; ; ) {
          do
            pt2++;
          while (Y3(et2[pt2], X4) < 0);
          do
            lt2--;
          while (Y3(et2[lt2], X4) > 0);
          if (pt2 >= lt2) break;
          var vt2 = et2[pt2];
          et2[pt2] = et2[lt2], et2[lt2] = vt2, vt2 = O4[pt2], O4[pt2] = O4[lt2], O4[lt2] = vt2;
        }
        w3(et2, O4, k3, lt2, Y3), w3(et2, O4, lt2 + 1, z4, Y3);
      }
    }
    H$3(w3, "sort");
    let E4 = H$3((et2, O4) => et2.ll.x <= O4.x && O4.x <= et2.ur.x && et2.ll.y <= O4.y && O4.y <= et2.ur.y, "isInBbox"), T3 = H$3((et2, O4) => {
      if (O4.ur.x < et2.ll.x || et2.ur.x < O4.ll.x || O4.ur.y < et2.ll.y || et2.ur.y < O4.ll.y) return null;
      let k3 = et2.ll.x < O4.ll.x ? O4.ll.x : et2.ll.x, z4 = et2.ur.x < O4.ur.x ? et2.ur.x : O4.ur.x, Y3 = et2.ll.y < O4.ll.y ? O4.ll.y : et2.ll.y, X4 = et2.ur.y < O4.ur.y ? et2.ur.y : O4.ur.y;
      return { ll: { x: k3, y: Y3 }, ur: { x: z4, y: X4 } };
    }, "getBboxOverlap"), D4 = Number.EPSILON;
    D4 === void 0 && (D4 = Math.pow(2, -52));
    let A3 = D4 * D4, L3 = H$3((et2, O4) => {
      if (-D4 < et2 && et2 < D4 && -D4 < O4 && O4 < D4) return 0;
      let k3 = et2 - O4;
      return k3 * k3 < A3 * et2 * O4 ? 0 : et2 < O4 ? -1 : 1;
    }, "cmp"), Ai2 = class Ai {
      constructor() {
        this.reset();
      }
      reset() {
        this.xRounder = new j3(), this.yRounder = new j3();
      }
      round(O4, k3) {
        return { x: this.xRounder.round(O4), y: this.yRounder.round(k3) };
      }
    };
    H$3(Ai2, "PtRounder");
    let B3 = Ai2, Hn2 = class Hn {
      constructor() {
        this.tree = new d(), this.round(0);
      }
      round(O4) {
        let k3 = this.tree.add(O4), z4 = this.tree.prev(k3);
        if (z4 !== null && L3(k3.key, z4.key) === 0) return this.tree.remove(O4), z4.key;
        let Y3 = this.tree.next(k3);
        return Y3 !== null && L3(k3.key, Y3.key) === 0 ? (this.tree.remove(O4), Y3.key) : O4;
      }
    };
    H$3(Hn2, "CoordRounder");
    let j3 = Hn2, W4 = new B3(), $5 = 11102230246251565e-32, F3 = 134217729, J4 = (3 + 8 * $5) * $5;
    function ot2(et2, O4, k3, z4, Y3) {
      let X4, pt2, lt2, vt2, ht2 = O4[0], Rt2 = z4[0], at2 = 0, bt2 = 0;
      Rt2 > ht2 == Rt2 > -ht2 ? (X4 = ht2, ht2 = O4[++at2]) : (X4 = Rt2, Rt2 = z4[++bt2]);
      let gt2 = 0;
      if (at2 < et2 && bt2 < k3) for (Rt2 > ht2 == Rt2 > -ht2 ? (pt2 = ht2 + X4, lt2 = X4 - (pt2 - ht2), ht2 = O4[++at2]) : (pt2 = Rt2 + X4, lt2 = X4 - (pt2 - Rt2), Rt2 = z4[++bt2]), X4 = pt2, lt2 !== 0 && (Y3[gt2++] = lt2); at2 < et2 && bt2 < k3; ) Rt2 > ht2 == Rt2 > -ht2 ? (pt2 = X4 + ht2, vt2 = pt2 - X4, lt2 = X4 - (pt2 - vt2) + (ht2 - vt2), ht2 = O4[++at2]) : (pt2 = X4 + Rt2, vt2 = pt2 - X4, lt2 = X4 - (pt2 - vt2) + (Rt2 - vt2), Rt2 = z4[++bt2]), X4 = pt2, lt2 !== 0 && (Y3[gt2++] = lt2);
      for (; at2 < et2; ) pt2 = X4 + ht2, vt2 = pt2 - X4, lt2 = X4 - (pt2 - vt2) + (ht2 - vt2), ht2 = O4[++at2], X4 = pt2, lt2 !== 0 && (Y3[gt2++] = lt2);
      for (; bt2 < k3; ) pt2 = X4 + Rt2, vt2 = pt2 - X4, lt2 = X4 - (pt2 - vt2) + (Rt2 - vt2), Rt2 = z4[++bt2], X4 = pt2, lt2 !== 0 && (Y3[gt2++] = lt2);
      return (X4 !== 0 || gt2 === 0) && (Y3[gt2++] = X4), gt2;
    }
    H$3(ot2, "sum");
    function K4(et2, O4) {
      let k3 = O4[0];
      for (let z4 = 1; z4 < et2; z4++) k3 += O4[z4];
      return k3;
    }
    H$3(K4, "estimate");
    function H5(et2) {
      return new Float64Array(et2);
    }
    H$3(H5, "vec");
    let _t2 = (3 + 16 * $5) * $5, ct2 = (2 + 12 * $5) * $5, ft2 = (9 + 64 * $5) * $5 * $5, mt2 = H5(4), St2 = H5(8), dt2 = H5(12), xt2 = H5(16), q4 = H5(4);
    function ee2(et2, O4, k3, z4, Y3, X4, pt2) {
      let lt2, vt2, ht2, Rt2, at2, bt2, gt2, Qt2, qt2, fe2, te2, Tr2, Dr2, sn2, Lr2, Xn2, Te2, ye2, Ri3 = et2 - Y3, Ur2 = k3 - Y3, Nn3 = O4 - X4, xr2 = z4 - X4;
      sn2 = Ri3 * xr2, bt2 = F3 * Ri3, gt2 = bt2 - (bt2 - Ri3), Qt2 = Ri3 - gt2, bt2 = F3 * xr2, qt2 = bt2 - (bt2 - xr2), fe2 = xr2 - qt2, Lr2 = Qt2 * fe2 - (sn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), Xn2 = Nn3 * Ur2, bt2 = F3 * Nn3, gt2 = bt2 - (bt2 - Nn3), Qt2 = Nn3 - gt2, bt2 = F3 * Ur2, qt2 = bt2 - (bt2 - Ur2), fe2 = Ur2 - qt2, Te2 = Qt2 * fe2 - (Xn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), te2 = Lr2 - Te2, at2 = Lr2 - te2, mt2[0] = Lr2 - (te2 + at2) + (at2 - Te2), Tr2 = sn2 + te2, at2 = Tr2 - sn2, Dr2 = sn2 - (Tr2 - at2) + (te2 - at2), te2 = Dr2 - Xn2, at2 = Dr2 - te2, mt2[1] = Dr2 - (te2 + at2) + (at2 - Xn2), ye2 = Tr2 + te2, at2 = ye2 - Tr2, mt2[2] = Tr2 - (ye2 - at2) + (te2 - at2), mt2[3] = ye2;
      let Ki2 = K4(4, mt2), Fi3 = ct2 * pt2;
      if (Ki2 >= Fi3 || -Ki2 >= Fi3 || (at2 = et2 - Ri3, lt2 = et2 - (Ri3 + at2) + (at2 - Y3), at2 = k3 - Ur2, ht2 = k3 - (Ur2 + at2) + (at2 - Y3), at2 = O4 - Nn3, vt2 = O4 - (Nn3 + at2) + (at2 - X4), at2 = z4 - xr2, Rt2 = z4 - (xr2 + at2) + (at2 - X4), lt2 === 0 && vt2 === 0 && ht2 === 0 && Rt2 === 0) || (Fi3 = ft2 * pt2 + J4 * Math.abs(Ki2), Ki2 += Ri3 * Rt2 + xr2 * lt2 - (Nn3 * ht2 + Ur2 * vt2), Ki2 >= Fi3 || -Ki2 >= Fi3)) return Ki2;
      sn2 = lt2 * xr2, bt2 = F3 * lt2, gt2 = bt2 - (bt2 - lt2), Qt2 = lt2 - gt2, bt2 = F3 * xr2, qt2 = bt2 - (bt2 - xr2), fe2 = xr2 - qt2, Lr2 = Qt2 * fe2 - (sn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), Xn2 = vt2 * Ur2, bt2 = F3 * vt2, gt2 = bt2 - (bt2 - vt2), Qt2 = vt2 - gt2, bt2 = F3 * Ur2, qt2 = bt2 - (bt2 - Ur2), fe2 = Ur2 - qt2, Te2 = Qt2 * fe2 - (Xn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), te2 = Lr2 - Te2, at2 = Lr2 - te2, q4[0] = Lr2 - (te2 + at2) + (at2 - Te2), Tr2 = sn2 + te2, at2 = Tr2 - sn2, Dr2 = sn2 - (Tr2 - at2) + (te2 - at2), te2 = Dr2 - Xn2, at2 = Dr2 - te2, q4[1] = Dr2 - (te2 + at2) + (at2 - Xn2), ye2 = Tr2 + te2, at2 = ye2 - Tr2, q4[2] = Tr2 - (ye2 - at2) + (te2 - at2), q4[3] = ye2;
      let Jo2 = ot2(4, mt2, 4, q4, St2);
      sn2 = Ri3 * Rt2, bt2 = F3 * Ri3, gt2 = bt2 - (bt2 - Ri3), Qt2 = Ri3 - gt2, bt2 = F3 * Rt2, qt2 = bt2 - (bt2 - Rt2), fe2 = Rt2 - qt2, Lr2 = Qt2 * fe2 - (sn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), Xn2 = Nn3 * ht2, bt2 = F3 * Nn3, gt2 = bt2 - (bt2 - Nn3), Qt2 = Nn3 - gt2, bt2 = F3 * ht2, qt2 = bt2 - (bt2 - ht2), fe2 = ht2 - qt2, Te2 = Qt2 * fe2 - (Xn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), te2 = Lr2 - Te2, at2 = Lr2 - te2, q4[0] = Lr2 - (te2 + at2) + (at2 - Te2), Tr2 = sn2 + te2, at2 = Tr2 - sn2, Dr2 = sn2 - (Tr2 - at2) + (te2 - at2), te2 = Dr2 - Xn2, at2 = Dr2 - te2, q4[1] = Dr2 - (te2 + at2) + (at2 - Xn2), ye2 = Tr2 + te2, at2 = ye2 - Tr2, q4[2] = Tr2 - (ye2 - at2) + (te2 - at2), q4[3] = ye2;
      let Qi2 = ot2(Jo2, St2, 4, q4, dt2);
      sn2 = lt2 * Rt2, bt2 = F3 * lt2, gt2 = bt2 - (bt2 - lt2), Qt2 = lt2 - gt2, bt2 = F3 * Rt2, qt2 = bt2 - (bt2 - Rt2), fe2 = Rt2 - qt2, Lr2 = Qt2 * fe2 - (sn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), Xn2 = vt2 * ht2, bt2 = F3 * vt2, gt2 = bt2 - (bt2 - vt2), Qt2 = vt2 - gt2, bt2 = F3 * ht2, qt2 = bt2 - (bt2 - ht2), fe2 = ht2 - qt2, Te2 = Qt2 * fe2 - (Xn2 - gt2 * qt2 - Qt2 * qt2 - gt2 * fe2), te2 = Lr2 - Te2, at2 = Lr2 - te2, q4[0] = Lr2 - (te2 + at2) + (at2 - Te2), Tr2 = sn2 + te2, at2 = Tr2 - sn2, Dr2 = sn2 - (Tr2 - at2) + (te2 - at2), te2 = Dr2 - Xn2, at2 = Dr2 - te2, q4[1] = Dr2 - (te2 + at2) + (at2 - Xn2), ye2 = Tr2 + te2, at2 = ye2 - Tr2, q4[2] = Tr2 - (ye2 - at2) + (te2 - at2), q4[3] = ye2;
      let Pf3 = ot2(Qi2, dt2, 4, q4, xt2);
      return xt2[Pf3 - 1];
    }
    H$3(ee2, "orient2dadapt");
    function Gt2(et2, O4, k3, z4, Y3, X4) {
      let pt2 = (O4 - X4) * (k3 - Y3), lt2 = (et2 - Y3) * (z4 - X4), vt2 = pt2 - lt2, ht2 = Math.abs(pt2 + lt2);
      return Math.abs(vt2) >= _t2 * ht2 ? vt2 : -ee2(et2, O4, k3, z4, Y3, X4, ht2);
    }
    H$3(Gt2, "orient2d");
    let Kt2 = H$3((et2, O4) => et2.x * O4.y - et2.y * O4.x, "crossProduct"), It2 = H$3((et2, O4) => et2.x * O4.x + et2.y * O4.y, "dotProduct"), ie2 = H$3((et2, O4, k3) => {
      let z4 = Gt2(et2.x, et2.y, O4.x, O4.y, k3.x, k3.y);
      return z4 > 0 ? -1 : z4 < 0 ? 1 : 0;
    }, "compareVectorAngles"), vr2 = H$3((et2) => Math.sqrt(It2(et2, et2)), "length"), Qe2 = H$3((et2, O4, k3) => {
      let z4 = { x: O4.x - et2.x, y: O4.y - et2.y }, Y3 = { x: k3.x - et2.x, y: k3.y - et2.y };
      return Kt2(Y3, z4) / vr2(Y3) / vr2(z4);
    }, "sineOfAngle"), Nt2 = H$3((et2, O4, k3) => {
      let z4 = { x: O4.x - et2.x, y: O4.y - et2.y }, Y3 = { x: k3.x - et2.x, y: k3.y - et2.y };
      return It2(Y3, z4) / vr2(Y3) / vr2(z4);
    }, "cosineOfAngle"), At2 = H$3((et2, O4, k3) => O4.y === 0 ? null : { x: et2.x + O4.x / O4.y * (k3 - et2.y), y: k3 }, "horizontalIntersection"), Ct2 = H$3((et2, O4, k3) => O4.x === 0 ? null : { x: k3, y: et2.y + O4.y / O4.x * (k3 - et2.x) }, "verticalIntersection"), _e3 = H$3((et2, O4, k3, z4) => {
      if (O4.x === 0) return Ct2(k3, z4, et2.x);
      if (z4.x === 0) return Ct2(et2, O4, k3.x);
      if (O4.y === 0) return At2(k3, z4, et2.y);
      if (z4.y === 0) return At2(et2, O4, k3.y);
      let Y3 = Kt2(O4, z4);
      if (Y3 == 0) return null;
      let X4 = { x: k3.x - et2.x, y: k3.y - et2.y }, pt2 = Kt2(X4, O4) / Y3, lt2 = Kt2(X4, z4) / Y3, vt2 = et2.x + lt2 * O4.x, ht2 = k3.x + pt2 * z4.x, Rt2 = et2.y + lt2 * O4.y, at2 = k3.y + pt2 * z4.y, bt2 = (vt2 + ht2) / 2, gt2 = (Rt2 + at2) / 2;
      return { x: bt2, y: gt2 };
    }, "intersection$1"), Ni2 = class Ni3 {
      static compare(O4, k3) {
        let z4 = Ni3.comparePoints(O4.point, k3.point);
        return z4 !== 0 ? z4 : (O4.point !== k3.point && O4.link(k3), O4.isLeft !== k3.isLeft ? O4.isLeft ? 1 : -1 : me2.compare(O4.segment, k3.segment));
      }
      static comparePoints(O4, k3) {
        return O4.x < k3.x ? -1 : O4.x > k3.x ? 1 : O4.y < k3.y ? -1 : O4.y > k3.y ? 1 : 0;
      }
      constructor(O4, k3) {
        O4.events === void 0 ? O4.events = [this] : O4.events.push(this), this.point = O4, this.isLeft = k3;
      }
      link(O4) {
        if (O4.point === this.point) throw new Error("Tried to link already linked events");
        let k3 = O4.point.events;
        for (let z4 = 0, Y3 = k3.length; z4 < Y3; z4++) {
          let X4 = k3[z4];
          this.point.events.push(X4), X4.point = this.point;
        }
        this.checkForConsuming();
      }
      checkForConsuming() {
        let O4 = this.point.events.length;
        for (let k3 = 0; k3 < O4; k3++) {
          let z4 = this.point.events[k3];
          if (z4.segment.consumedBy === void 0) for (let Y3 = k3 + 1; Y3 < O4; Y3++) {
            let X4 = this.point.events[Y3];
            X4.consumedBy === void 0 && z4.otherSE.point.events === X4.otherSE.point.events && z4.segment.consume(X4.segment);
          }
        }
      }
      getAvailableLinkedEvents() {
        let O4 = [];
        for (let k3 = 0, z4 = this.point.events.length; k3 < z4; k3++) {
          let Y3 = this.point.events[k3];
          Y3 !== this && !Y3.segment.ringOut && Y3.segment.isInResult() && O4.push(Y3);
        }
        return O4;
      }
      getLeftmostComparator(O4) {
        let k3 = /* @__PURE__ */ new Map(), z4 = H$3((Y3) => {
          let X4 = Y3.otherSE;
          k3.set(Y3, { sine: Qe2(this.point, O4.point, X4.point), cosine: Nt2(this.point, O4.point, X4.point) });
        }, "fillCache");
        return (Y3, X4) => {
          k3.has(Y3) || z4(Y3), k3.has(X4) || z4(X4);
          let { sine: pt2, cosine: lt2 } = k3.get(Y3), { sine: vt2, cosine: ht2 } = k3.get(X4);
          return pt2 >= 0 && vt2 >= 0 ? lt2 < ht2 ? 1 : lt2 > ht2 ? -1 : 0 : pt2 < 0 && vt2 < 0 ? lt2 < ht2 ? -1 : lt2 > ht2 ? 1 : 0 : vt2 < pt2 ? -1 : vt2 > pt2 ? 1 : 0;
        };
      }
    };
    H$3(Ni2, "SweepEvent");
    let de2 = Ni2, qr2 = 0, $o2 = class $o3 {
      static compare(O4, k3) {
        let z4 = O4.leftSE.point.x, Y3 = k3.leftSE.point.x, X4 = O4.rightSE.point.x, pt2 = k3.rightSE.point.x;
        if (pt2 < z4) return 1;
        if (X4 < Y3) return -1;
        let lt2 = O4.leftSE.point.y, vt2 = k3.leftSE.point.y, ht2 = O4.rightSE.point.y, Rt2 = k3.rightSE.point.y;
        if (z4 < Y3) {
          if (vt2 < lt2 && vt2 < ht2) return 1;
          if (vt2 > lt2 && vt2 > ht2) return -1;
          let at2 = O4.comparePoint(k3.leftSE.point);
          if (at2 < 0) return 1;
          if (at2 > 0) return -1;
          let bt2 = k3.comparePoint(O4.rightSE.point);
          return bt2 !== 0 ? bt2 : -1;
        }
        if (z4 > Y3) {
          if (lt2 < vt2 && lt2 < Rt2) return -1;
          if (lt2 > vt2 && lt2 > Rt2) return 1;
          let at2 = k3.comparePoint(O4.leftSE.point);
          if (at2 !== 0) return at2;
          let bt2 = O4.comparePoint(k3.rightSE.point);
          return bt2 < 0 ? 1 : bt2 > 0 ? -1 : 1;
        }
        if (lt2 < vt2) return -1;
        if (lt2 > vt2) return 1;
        if (X4 < pt2) {
          let at2 = k3.comparePoint(O4.rightSE.point);
          if (at2 !== 0) return at2;
        }
        if (X4 > pt2) {
          let at2 = O4.comparePoint(k3.rightSE.point);
          if (at2 < 0) return 1;
          if (at2 > 0) return -1;
        }
        if (X4 !== pt2) {
          let at2 = ht2 - lt2, bt2 = X4 - z4, gt2 = Rt2 - vt2, Qt2 = pt2 - Y3;
          if (at2 > bt2 && gt2 < Qt2) return 1;
          if (at2 < bt2 && gt2 > Qt2) return -1;
        }
        return X4 > pt2 ? 1 : X4 < pt2 || ht2 < Rt2 ? -1 : ht2 > Rt2 ? 1 : O4.id < k3.id ? -1 : O4.id > k3.id ? 1 : 0;
      }
      constructor(O4, k3, z4, Y3) {
        this.id = ++qr2, this.leftSE = O4, O4.segment = this, O4.otherSE = k3, this.rightSE = k3, k3.segment = this, k3.otherSE = O4, this.rings = z4, this.windings = Y3;
      }
      static fromRing(O4, k3, z4) {
        let Y3, X4, pt2, lt2 = de2.comparePoints(O4, k3);
        if (lt2 < 0) Y3 = O4, X4 = k3, pt2 = 1;
        else if (lt2 > 0) Y3 = k3, X4 = O4, pt2 = -1;
        else throw new Error("Tried to create degenerate segment at [".concat(O4.x, ", ").concat(O4.y, "]"));
        let vt2 = new de2(Y3, true), ht2 = new de2(X4, false);
        return new $o3(vt2, ht2, [z4], [pt2]);
      }
      replaceRightSE(O4) {
        this.rightSE = O4, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
      }
      bbox() {
        let O4 = this.leftSE.point.y, k3 = this.rightSE.point.y;
        return { ll: { x: this.leftSE.point.x, y: O4 < k3 ? O4 : k3 }, ur: { x: this.rightSE.point.x, y: O4 > k3 ? O4 : k3 } };
      }
      vector() {
        return { x: this.rightSE.point.x - this.leftSE.point.x, y: this.rightSE.point.y - this.leftSE.point.y };
      }
      isAnEndpoint(O4) {
        return O4.x === this.leftSE.point.x && O4.y === this.leftSE.point.y || O4.x === this.rightSE.point.x && O4.y === this.rightSE.point.y;
      }
      comparePoint(O4) {
        if (this.isAnEndpoint(O4)) return 0;
        let k3 = this.leftSE.point, z4 = this.rightSE.point, Y3 = this.vector();
        if (k3.x === z4.x) return O4.x === k3.x ? 0 : O4.x < k3.x ? 1 : -1;
        let X4 = (O4.y - k3.y) / Y3.y, pt2 = k3.x + X4 * Y3.x;
        if (O4.x === pt2) return 0;
        let lt2 = (O4.x - k3.x) / Y3.x, vt2 = k3.y + lt2 * Y3.y;
        return O4.y === vt2 ? 0 : O4.y < vt2 ? -1 : 1;
      }
      getIntersection(O4) {
        let k3 = this.bbox(), z4 = O4.bbox(), Y3 = T3(k3, z4);
        if (Y3 === null) return null;
        let X4 = this.leftSE.point, pt2 = this.rightSE.point, lt2 = O4.leftSE.point, vt2 = O4.rightSE.point, ht2 = E4(k3, lt2) && this.comparePoint(lt2) === 0, Rt2 = E4(z4, X4) && O4.comparePoint(X4) === 0, at2 = E4(k3, vt2) && this.comparePoint(vt2) === 0, bt2 = E4(z4, pt2) && O4.comparePoint(pt2) === 0;
        if (Rt2 && ht2) return bt2 && !at2 ? pt2 : !bt2 && at2 ? vt2 : null;
        if (Rt2) return at2 && X4.x === vt2.x && X4.y === vt2.y ? null : X4;
        if (ht2) return bt2 && pt2.x === lt2.x && pt2.y === lt2.y ? null : lt2;
        if (bt2 && at2) return null;
        if (bt2) return pt2;
        if (at2) return vt2;
        let gt2 = _e3(X4, this.vector(), lt2, O4.vector());
        return gt2 === null || !E4(Y3, gt2) ? null : W4.round(gt2.x, gt2.y);
      }
      split(O4) {
        let k3 = [], z4 = O4.events !== void 0, Y3 = new de2(O4, true), X4 = new de2(O4, false), pt2 = this.rightSE;
        this.replaceRightSE(X4), k3.push(X4), k3.push(Y3);
        let lt2 = new $o3(Y3, pt2, this.rings.slice(), this.windings.slice());
        return de2.comparePoints(lt2.leftSE.point, lt2.rightSE.point) > 0 && lt2.swapEvents(), de2.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), z4 && (Y3.checkForConsuming(), X4.checkForConsuming()), k3;
      }
      swapEvents() {
        let O4 = this.rightSE;
        this.rightSE = this.leftSE, this.leftSE = O4, this.leftSE.isLeft = true, this.rightSE.isLeft = false;
        for (let k3 = 0, z4 = this.windings.length; k3 < z4; k3++) this.windings[k3] *= -1;
      }
      consume(O4) {
        let k3 = this, z4 = O4;
        for (; k3.consumedBy; ) k3 = k3.consumedBy;
        for (; z4.consumedBy; ) z4 = z4.consumedBy;
        let Y3 = $o3.compare(k3, z4);
        if (Y3 !== 0) {
          if (Y3 > 0) {
            let X4 = k3;
            k3 = z4, z4 = X4;
          }
          if (k3.prev === z4) {
            let X4 = k3;
            k3 = z4, z4 = X4;
          }
          for (let X4 = 0, pt2 = z4.rings.length; X4 < pt2; X4++) {
            let lt2 = z4.rings[X4], vt2 = z4.windings[X4], ht2 = k3.rings.indexOf(lt2);
            ht2 === -1 ? (k3.rings.push(lt2), k3.windings.push(vt2)) : k3.windings[ht2] += vt2;
          }
          z4.rings = null, z4.windings = null, z4.consumedBy = k3, z4.leftSE.consumedBy = k3.leftSE, z4.rightSE.consumedBy = k3.rightSE;
        }
      }
      prevInResult() {
        return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
      }
      beforeState() {
        if (this._beforeState !== void 0) return this._beforeState;
        if (!this.prev) this._beforeState = { rings: [], windings: [], multiPolys: [] };
        else {
          let O4 = this.prev.consumedBy || this.prev;
          this._beforeState = O4.afterState();
        }
        return this._beforeState;
      }
      afterState() {
        if (this._afterState !== void 0) return this._afterState;
        let O4 = this.beforeState();
        this._afterState = { rings: O4.rings.slice(0), windings: O4.windings.slice(0), multiPolys: [] };
        let k3 = this._afterState.rings, z4 = this._afterState.windings, Y3 = this._afterState.multiPolys;
        for (let lt2 = 0, vt2 = this.rings.length; lt2 < vt2; lt2++) {
          let ht2 = this.rings[lt2], Rt2 = this.windings[lt2], at2 = k3.indexOf(ht2);
          at2 === -1 ? (k3.push(ht2), z4.push(Rt2)) : z4[at2] += Rt2;
        }
        let X4 = [], pt2 = [];
        for (let lt2 = 0, vt2 = k3.length; lt2 < vt2; lt2++) {
          if (z4[lt2] === 0) continue;
          let ht2 = k3[lt2], Rt2 = ht2.poly;
          if (pt2.indexOf(Rt2) === -1) if (ht2.isExterior) X4.push(Rt2);
          else {
            pt2.indexOf(Rt2) === -1 && pt2.push(Rt2);
            let at2 = X4.indexOf(ht2.poly);
            at2 !== -1 && X4.splice(at2, 1);
          }
        }
        for (let lt2 = 0, vt2 = X4.length; lt2 < vt2; lt2++) {
          let ht2 = X4[lt2].multiPoly;
          Y3.indexOf(ht2) === -1 && Y3.push(ht2);
        }
        return this._afterState;
      }
      isInResult() {
        if (this.consumedBy) return false;
        if (this._isInResult !== void 0) return this._isInResult;
        let O4 = this.beforeState().multiPolys, k3 = this.afterState().multiPolys;
        switch (wt2.type) {
          case "union": {
            let z4 = O4.length === 0, Y3 = k3.length === 0;
            this._isInResult = z4 !== Y3;
            break;
          }
          case "intersection": {
            let z4, Y3;
            O4.length < k3.length ? (z4 = O4.length, Y3 = k3.length) : (z4 = k3.length, Y3 = O4.length), this._isInResult = Y3 === wt2.numMultiPolys && z4 < Y3;
            break;
          }
          case "xor": {
            let z4 = Math.abs(O4.length - k3.length);
            this._isInResult = z4 % 2 === 1;
            break;
          }
          case "difference": {
            let z4 = H$3((Y3) => Y3.length === 1 && Y3[0].isSubject, "isJustSubject");
            this._isInResult = z4(O4) !== z4(k3);
            break;
          }
          default:
            throw new Error("Unrecognized operation type found ".concat(wt2.type));
        }
        return this._isInResult;
      }
    };
    H$3($o2, "Segment");
    let me2 = $o2, Ea3 = class Ea {
      constructor(O4, k3, z4) {
        if (!Array.isArray(O4) || O4.length === 0) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        if (this.poly = k3, this.isExterior = z4, this.segments = [], typeof O4[0][0] != "number" || typeof O4[0][1] != "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        let Y3 = W4.round(O4[0][0], O4[0][1]);
        this.bbox = { ll: { x: Y3.x, y: Y3.y }, ur: { x: Y3.x, y: Y3.y } };
        let X4 = Y3;
        for (let pt2 = 1, lt2 = O4.length; pt2 < lt2; pt2++) {
          if (typeof O4[pt2][0] != "number" || typeof O4[pt2][1] != "number") throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
          let vt2 = W4.round(O4[pt2][0], O4[pt2][1]);
          vt2.x === X4.x && vt2.y === X4.y || (this.segments.push(me2.fromRing(X4, vt2, this)), vt2.x < this.bbox.ll.x && (this.bbox.ll.x = vt2.x), vt2.y < this.bbox.ll.y && (this.bbox.ll.y = vt2.y), vt2.x > this.bbox.ur.x && (this.bbox.ur.x = vt2.x), vt2.y > this.bbox.ur.y && (this.bbox.ur.y = vt2.y), X4 = vt2);
        }
        (Y3.x !== X4.x || Y3.y !== X4.y) && this.segments.push(me2.fromRing(X4, Y3, this));
      }
      getSweepEvents() {
        let O4 = [];
        for (let k3 = 0, z4 = this.segments.length; k3 < z4; k3++) {
          let Y3 = this.segments[k3];
          O4.push(Y3.leftSE), O4.push(Y3.rightSE);
        }
        return O4;
      }
    };
    H$3(Ea3, "RingIn");
    let Se2 = Ea3, Oa2 = class Oa {
      constructor(O4, k3) {
        if (!Array.isArray(O4)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        this.exteriorRing = new Se2(O4[0], this, true), this.bbox = { ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y }, ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y } }, this.interiorRings = [];
        for (let z4 = 1, Y3 = O4.length; z4 < Y3; z4++) {
          let X4 = new Se2(O4[z4], this, false);
          X4.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = X4.bbox.ll.x), X4.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = X4.bbox.ll.y), X4.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = X4.bbox.ur.x), X4.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = X4.bbox.ur.y), this.interiorRings.push(X4);
        }
        this.multiPoly = k3;
      }
      getSweepEvents() {
        let O4 = this.exteriorRing.getSweepEvents();
        for (let k3 = 0, z4 = this.interiorRings.length; k3 < z4; k3++) {
          let Y3 = this.interiorRings[k3].getSweepEvents();
          for (let X4 = 0, pt2 = Y3.length; X4 < pt2; X4++) O4.push(Y3[X4]);
        }
        return O4;
      }
    };
    H$3(Oa2, "PolyIn");
    let br2 = Oa2, Da2 = class Da {
      constructor(O4, k3) {
        if (!Array.isArray(O4)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        try {
          typeof O4[0][0][0] == "number" && (O4 = [O4]);
        } catch (z4) {
        }
        this.polys = [], this.bbox = { ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY }, ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY } };
        for (let z4 = 0, Y3 = O4.length; z4 < Y3; z4++) {
          let X4 = new br2(O4[z4], this);
          X4.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = X4.bbox.ll.x), X4.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = X4.bbox.ll.y), X4.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = X4.bbox.ur.x), X4.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = X4.bbox.ur.y), this.polys.push(X4);
        }
        this.isSubject = k3;
      }
      getSweepEvents() {
        let O4 = [];
        for (let k3 = 0, z4 = this.polys.length; k3 < z4; k3++) {
          let Y3 = this.polys[k3].getSweepEvents();
          for (let X4 = 0, pt2 = Y3.length; X4 < pt2; X4++) O4.push(Y3[X4]);
        }
        return O4;
      }
    };
    H$3(Da2, "MultiPolyIn");
    let Wr2 = Da2, Rr2 = class Rr3 {
      static factory(O4) {
        let k3 = [];
        for (let z4 = 0, Y3 = O4.length; z4 < Y3; z4++) {
          let X4 = O4[z4];
          if (!X4.isInResult() || X4.ringOut) continue;
          let pt2 = null, lt2 = X4.leftSE, vt2 = X4.rightSE, ht2 = [lt2], Rt2 = lt2.point, at2 = [];
          for (; pt2 = lt2, lt2 = vt2, ht2.push(lt2), lt2.point !== Rt2; ) for (; ; ) {
            let bt2 = lt2.getAvailableLinkedEvents();
            if (bt2.length === 0) {
              let qt2 = ht2[0].point, fe2 = ht2[ht2.length - 1].point;
              throw new Error("Unable to complete output ring starting at [".concat(qt2.x, ",") + " ".concat(qt2.y, "]. Last matching segment found ends at") + " [".concat(fe2.x, ", ").concat(fe2.y, "]."));
            }
            if (bt2.length === 1) {
              vt2 = bt2[0].otherSE;
              break;
            }
            let gt2 = null;
            for (let qt2 = 0, fe2 = at2.length; qt2 < fe2; qt2++) if (at2[qt2].point === lt2.point) {
              gt2 = qt2;
              break;
            }
            if (gt2 !== null) {
              let qt2 = at2.splice(gt2)[0], fe2 = ht2.splice(qt2.index);
              fe2.unshift(fe2[0].otherSE), k3.push(new Rr3(fe2.reverse()));
              continue;
            }
            at2.push({ index: ht2.length, point: lt2.point });
            let Qt2 = lt2.getLeftmostComparator(pt2);
            vt2 = bt2.sort(Qt2)[0].otherSE;
            break;
          }
          k3.push(new Rr3(ht2));
        }
        return k3;
      }
      constructor(O4) {
        this.events = O4;
        for (let k3 = 0, z4 = O4.length; k3 < z4; k3++) O4[k3].segment.ringOut = this;
        this.poly = null;
      }
      getGeom() {
        let O4 = this.events[0].point, k3 = [O4];
        for (let ht2 = 1, Rt2 = this.events.length - 1; ht2 < Rt2; ht2++) {
          let at2 = this.events[ht2].point, bt2 = this.events[ht2 + 1].point;
          ie2(at2, O4, bt2) !== 0 && (k3.push(at2), O4 = at2);
        }
        if (k3.length === 1) return null;
        let z4 = k3[0], Y3 = k3[1];
        ie2(z4, O4, Y3) === 0 && k3.shift(), k3.push(k3[0]);
        let X4 = this.isExteriorRing() ? 1 : -1, pt2 = this.isExteriorRing() ? 0 : k3.length - 1, lt2 = this.isExteriorRing() ? k3.length : -1, vt2 = [];
        for (let ht2 = pt2; ht2 != lt2; ht2 += X4) vt2.push([k3[ht2].x, k3[ht2].y]);
        return vt2;
      }
      isExteriorRing() {
        if (this._isExteriorRing === void 0) {
          let O4 = this.enclosingRing();
          this._isExteriorRing = O4 ? !O4.isExteriorRing() : true;
        }
        return this._isExteriorRing;
      }
      enclosingRing() {
        return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
      }
      _calcEnclosingRing() {
        let O4 = this.events[0];
        for (let Y3 = 1, X4 = this.events.length; Y3 < X4; Y3++) {
          let pt2 = this.events[Y3];
          de2.compare(O4, pt2) > 0 && (O4 = pt2);
        }
        let k3 = O4.segment.prevInResult(), z4 = k3 ? k3.prevInResult() : null;
        for (; ; ) {
          if (!k3) return null;
          if (!z4) return k3.ringOut;
          if (z4.ringOut !== k3.ringOut) return z4.ringOut.enclosingRing() !== k3.ringOut ? k3.ringOut : k3.ringOut.enclosingRing();
          k3 = z4.prevInResult(), z4 = k3 ? k3.prevInResult() : null;
        }
      }
    };
    H$3(Rr2, "RingOut");
    let $i2 = Rr2, La2 = class La {
      constructor(O4) {
        this.exteriorRing = O4, O4.poly = this, this.interiorRings = [];
      }
      addInterior(O4) {
        this.interiorRings.push(O4), O4.poly = this;
      }
      getGeom() {
        let O4 = [this.exteriorRing.getGeom()];
        if (O4[0] === null) return null;
        for (let k3 = 0, z4 = this.interiorRings.length; k3 < z4; k3++) {
          let Y3 = this.interiorRings[k3].getGeom();
          Y3 !== null && O4.push(Y3);
        }
        return O4;
      }
    };
    H$3(La2, "PolyOut");
    let Yt2 = La2, ki2 = class ki {
      constructor(O4) {
        this.rings = O4, this.polys = this._composePolys(O4);
      }
      getGeom() {
        let O4 = [];
        for (let k3 = 0, z4 = this.polys.length; k3 < z4; k3++) {
          let Y3 = this.polys[k3].getGeom();
          Y3 !== null && O4.push(Y3);
        }
        return O4;
      }
      _composePolys(O4) {
        let k3 = [];
        for (let z4 = 0, Y3 = O4.length; z4 < Y3; z4++) {
          let X4 = O4[z4];
          if (!X4.poly) if (X4.isExteriorRing()) k3.push(new Yt2(X4));
          else {
            let pt2 = X4.enclosingRing();
            pt2.poly || k3.push(new Yt2(pt2)), pt2.poly.addInterior(X4);
          }
        }
        return k3;
      }
    };
    H$3(ki2, "MultiPolyOut");
    let mr2 = ki2, Et2 = class Et {
      constructor(O4) {
        let k3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : me2.compare;
        this.queue = O4, this.tree = new d(k3), this.segments = [];
      }
      process(O4) {
        let k3 = O4.segment, z4 = [];
        if (O4.consumedBy) return O4.isLeft ? this.queue.remove(O4.otherSE) : this.tree.remove(k3), z4;
        let Y3 = O4.isLeft ? this.tree.add(k3) : this.tree.find(k3);
        if (!Y3) throw new Error("Unable to find segment #".concat(k3.id, " ") + "[".concat(k3.leftSE.point.x, ", ").concat(k3.leftSE.point.y, "] -> ") + "[".concat(k3.rightSE.point.x, ", ").concat(k3.rightSE.point.y, "] ") + "in SweepLine tree.");
        let X4 = Y3, pt2 = Y3, lt2, vt2;
        for (; lt2 === void 0; ) X4 = this.tree.prev(X4), X4 === null ? lt2 = null : X4.key.consumedBy === void 0 && (lt2 = X4.key);
        for (; vt2 === void 0; ) pt2 = this.tree.next(pt2), pt2 === null ? vt2 = null : pt2.key.consumedBy === void 0 && (vt2 = pt2.key);
        if (O4.isLeft) {
          let ht2 = null;
          if (lt2) {
            let at2 = lt2.getIntersection(k3);
            if (at2 !== null && (k3.isAnEndpoint(at2) || (ht2 = at2), !lt2.isAnEndpoint(at2))) {
              let bt2 = this._splitSafely(lt2, at2);
              for (let gt2 = 0, Qt2 = bt2.length; gt2 < Qt2; gt2++) z4.push(bt2[gt2]);
            }
          }
          let Rt2 = null;
          if (vt2) {
            let at2 = vt2.getIntersection(k3);
            if (at2 !== null && (k3.isAnEndpoint(at2) || (Rt2 = at2), !vt2.isAnEndpoint(at2))) {
              let bt2 = this._splitSafely(vt2, at2);
              for (let gt2 = 0, Qt2 = bt2.length; gt2 < Qt2; gt2++) z4.push(bt2[gt2]);
            }
          }
          if (ht2 !== null || Rt2 !== null) {
            let at2 = null;
            ht2 === null ? at2 = Rt2 : Rt2 === null ? at2 = ht2 : at2 = de2.comparePoints(ht2, Rt2) <= 0 ? ht2 : Rt2, this.queue.remove(k3.rightSE), z4.push(k3.rightSE);
            let bt2 = k3.split(at2);
            for (let gt2 = 0, Qt2 = bt2.length; gt2 < Qt2; gt2++) z4.push(bt2[gt2]);
          }
          z4.length > 0 ? (this.tree.remove(k3), z4.push(O4)) : (this.segments.push(k3), k3.prev = lt2);
        } else {
          if (lt2 && vt2) {
            let ht2 = lt2.getIntersection(vt2);
            if (ht2 !== null) {
              if (!lt2.isAnEndpoint(ht2)) {
                let Rt2 = this._splitSafely(lt2, ht2);
                for (let at2 = 0, bt2 = Rt2.length; at2 < bt2; at2++) z4.push(Rt2[at2]);
              }
              if (!vt2.isAnEndpoint(ht2)) {
                let Rt2 = this._splitSafely(vt2, ht2);
                for (let at2 = 0, bt2 = Rt2.length; at2 < bt2; at2++) z4.push(Rt2[at2]);
              }
            }
          }
          this.tree.remove(k3);
        }
        return z4;
      }
      _splitSafely(O4, k3) {
        this.tree.remove(O4);
        let z4 = O4.rightSE;
        this.queue.remove(z4);
        let Y3 = O4.split(k3);
        return Y3.push(z4), O4.consumedBy === void 0 && this.tree.add(O4), Y3;
      }
    };
    H$3(Et2, "SweepLine");
    let co2 = Et2, Ji2 = typeof p$1 < "u" && p$1.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, po2 = typeof p$1 < "u" && p$1.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6, $m2 = class $m {
      run(O4, k3, z4) {
        wt2.type = O4, W4.reset();
        let Y3 = [new Wr2(k3, true)];
        for (let at2 = 0, bt2 = z4.length; at2 < bt2; at2++) Y3.push(new Wr2(z4[at2], false));
        if (wt2.numMultiPolys = Y3.length, wt2.type === "difference") {
          let at2 = Y3[0], bt2 = 1;
          for (; bt2 < Y3.length; ) T3(Y3[bt2].bbox, at2.bbox) !== null ? bt2++ : Y3.splice(bt2, 1);
        }
        if (wt2.type === "intersection") for (let at2 = 0, bt2 = Y3.length; at2 < bt2; at2++) {
          let gt2 = Y3[at2];
          for (let Qt2 = at2 + 1, qt2 = Y3.length; Qt2 < qt2; Qt2++) if (T3(gt2.bbox, Y3[Qt2].bbox) === null) return [];
        }
        let X4 = new d(de2.compare);
        for (let at2 = 0, bt2 = Y3.length; at2 < bt2; at2++) {
          let gt2 = Y3[at2].getSweepEvents();
          for (let Qt2 = 0, qt2 = gt2.length; Qt2 < qt2; Qt2++) if (X4.insert(gt2[Qt2]), X4.size > Ji2) throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
        }
        let pt2 = new co2(X4), lt2 = X4.size, vt2 = X4.pop();
        for (; vt2; ) {
          let at2 = vt2.key;
          if (X4.size === lt2) {
            let gt2 = at2.segment;
            throw new Error("Unable to pop() ".concat(at2.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(at2.point.x, ", ").concat(at2.point.y, "] from segment #").concat(gt2.id, " ") + "[".concat(gt2.leftSE.point.x, ", ").concat(gt2.leftSE.point.y, "] -> ") + "[".concat(gt2.rightSE.point.x, ", ").concat(gt2.rightSE.point.y, "] from queue."));
          }
          if (X4.size > Ji2) throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
          if (pt2.segments.length > po2) throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
          let bt2 = pt2.process(at2);
          for (let gt2 = 0, Qt2 = bt2.length; gt2 < Qt2; gt2++) {
            let qt2 = bt2[gt2];
            qt2.consumedBy === void 0 && X4.insert(qt2);
          }
          lt2 = X4.size, vt2 = X4.pop();
        }
        W4.reset();
        let ht2 = $i2.factory(pt2.segments);
        return new mr2(ht2).getGeom();
      }
    };
    H$3($m2, "Operation");
    let En2 = $m2, wt2 = new En2();
    var Pa2 = { union: H$3(function(et2) {
      for (var O4 = arguments.length, k3 = new Array(O4 > 1 ? O4 - 1 : 0), z4 = 1; z4 < O4; z4++) k3[z4 - 1] = arguments[z4];
      return wt2.run("union", et2, k3);
    }, "union"), intersection: H$3(function(et2) {
      for (var O4 = arguments.length, k3 = new Array(O4 > 1 ? O4 - 1 : 0), z4 = 1; z4 < O4; z4++) k3[z4 - 1] = arguments[z4];
      return wt2.run("intersection", et2, k3);
    }, "intersection"), xor: H$3(function(et2) {
      for (var O4 = arguments.length, k3 = new Array(O4 > 1 ? O4 - 1 : 0), z4 = 1; z4 < O4; z4++) k3[z4 - 1] = arguments[z4];
      return wt2.run("xor", et2, k3);
    }, "xor"), difference: H$3(function(et2) {
      for (var O4 = arguments.length, k3 = new Array(O4 > 1 ? O4 - 1 : 0), z4 = 1; z4 < O4; z4++) k3[z4 - 1] = arguments[z4];
      return wt2.run("difference", et2, k3);
    }, "difference") };
    return Pa2;
  });
});
var X6 = L((zv2, H6) => {
  a();
  (function(r5, t) {
    typeof zv2 == "object" && typeof H6 < "u" ? t(zv2) : typeof define == "function" && define.amd ? define(["exports"], t) : t(r5.jsts = {});
  })(zv2, function(r5) {
    function t() {
    }
    H$3(t, "e");
    function e(o4) {
      this.message = o4 || "";
    }
    H$3(e, "n");
    function n4(o4) {
      this.message = o4 || "";
    }
    H$3(n4, "i");
    function i(o4) {
      this.message = o4 || "";
    }
    H$3(i, "r");
    function a4() {
    }
    H$3(a4, "o");
    function u5(o4) {
      return o4 === null ? ht2 : o4.color;
    }
    H$3(u5, "s");
    function h(o4) {
      return o4 === null ? null : o4.parent;
    }
    H$3(h, "a");
    function d(o4, s5) {
      o4 !== null && (o4.color = s5);
    }
    H$3(d, "u");
    function m5(o4) {
      return o4 === null ? null : o4.left;
    }
    H$3(m5, "l");
    function v3(o4) {
      return o4 === null ? null : o4.right;
    }
    H$3(v3, "c");
    function x2() {
      this.root_ = null, this.size_ = 0;
    }
    H$3(x2, "p");
    function S4() {
    }
    H$3(S4, "h");
    function I3() {
      this.array_ = [], arguments[0] instanceof Rr2 && this.addAll(arguments[0]);
    }
    H$3(I3, "f");
    function w3() {
    }
    H$3(w3, "g");
    function E4(o4) {
      this.message = o4 || "";
    }
    H$3(E4, "d");
    function T3() {
      this.array_ = [];
    }
    H$3(T3, "y"), "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: true, value: H$3(function(o4) {
      if (this === void 0 || this === null) throw new TypeError(this + " is not an object");
      var s5 = Object(this), c = Math.max(Math.min(s5.length, 9007199254740991), 0) || 0, f = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0;
      f = f < 0 ? Math.max(c + f, 0) : Math.min(f, c);
      var g = 2 in arguments && arguments[2] !== void 0 ? parseInt(Number(arguments[2]), 10) || 0 : c;
      for (g = g < 0 ? Math.max(c + arguments[2], 0) : Math.min(g, c); f < g; ) s5[f] = o4, ++f;
      return s5;
    }, "value"), writable: true }), Number.isFinite = Number.isFinite || function(o4) {
      return typeof o4 == "number" && isFinite(o4);
    }, Number.isInteger = Number.isInteger || function(o4) {
      return typeof o4 == "number" && isFinite(o4) && Math.floor(o4) === o4;
    }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(o4) {
      return o4 != o4;
    }, Math.trunc = Math.trunc || function(o4) {
      return o4 < 0 ? Math.ceil(o4) : Math.floor(o4);
    };
    var D4 = H$3(function() {
    }, "_");
    D4.prototype.interfaces_ = function() {
      return [];
    }, D4.prototype.getClass = function() {
      return D4;
    }, D4.prototype.equalsWithTolerance = function(o4, s5, c) {
      return Math.abs(o4 - s5) <= c;
    };
    var A3 = (function(o4) {
      function s5(c) {
        o4.call(this, c), this.name = "IllegalArgumentException", this.message = c, this.stack = new o4().stack;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5;
    })(Error), L3 = H$3(function() {
    }, "v"), B3 = { MAX_VALUE: { configurable: true } };
    L3.isNaN = function(o4) {
      return Number.isNaN(o4);
    }, L3.doubleToLongBits = function(o4) {
      return o4;
    }, L3.longBitsToDouble = function(o4) {
      return o4;
    }, L3.isInfinite = function(o4) {
      return !Number.isFinite(o4);
    }, B3.MAX_VALUE.get = function() {
      return Number.MAX_VALUE;
    }, Object.defineProperties(L3, B3);
    var j3 = H$3(function() {
    }, "E"), W4 = H$3(function() {
    }, "x"), $5 = H$3(function() {
    }, "N"), F3 = H$3(function o4() {
      if (this.x = null, this.y = null, this.z = null, arguments.length === 0) this.x = 0, this.y = 0, this.z = o4.NULL_ORDINATE;
      else if (arguments.length === 1) {
        var s5 = arguments[0];
        this.x = s5.x, this.y = s5.y, this.z = s5.z;
      } else arguments.length === 2 ? (this.x = arguments[0], this.y = arguments[1], this.z = o4.NULL_ORDINATE) : arguments.length === 3 && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
    }, "t"), J4 = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
    F3.prototype.setOrdinate = function(o4, s5) {
      switch (o4) {
        case F3.X:
          this.x = s5;
          break;
        case F3.Y:
          this.y = s5;
          break;
        case F3.Z:
          this.z = s5;
          break;
        default:
          throw new A3("Invalid ordinate index: " + o4);
      }
    }, F3.prototype.equals2D = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return this.x === o4.x && this.y === o4.y;
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return !!D4.equalsWithTolerance(this.x, s5.x, c) && !!D4.equalsWithTolerance(this.y, s5.y, c);
      }
    }, F3.prototype.getOrdinate = function(o4) {
      switch (o4) {
        case F3.X:
          return this.x;
        case F3.Y:
          return this.y;
        case F3.Z:
          return this.z;
      }
      throw new A3("Invalid ordinate index: " + o4);
    }, F3.prototype.equals3D = function(o4) {
      return this.x === o4.x && this.y === o4.y && (this.z === o4.z || L3.isNaN(this.z)) && L3.isNaN(o4.z);
    }, F3.prototype.equals = function(o4) {
      return o4 instanceof F3 && this.equals2D(o4);
    }, F3.prototype.equalInZ = function(o4, s5) {
      return D4.equalsWithTolerance(this.z, o4.z, s5);
    }, F3.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this.x < s5.x ? -1 : this.x > s5.x ? 1 : this.y < s5.y ? -1 : this.y > s5.y ? 1 : 0;
    }, F3.prototype.clone = function() {
    }, F3.prototype.copy = function() {
      return new F3(this);
    }, F3.prototype.toString = function() {
      return "(" + this.x + ", " + this.y + ", " + this.z + ")";
    }, F3.prototype.distance3D = function(o4) {
      var s5 = this.x - o4.x, c = this.y - o4.y, f = this.z - o4.z;
      return Math.sqrt(s5 * s5 + c * c + f * f);
    }, F3.prototype.distance = function(o4) {
      var s5 = this.x - o4.x, c = this.y - o4.y;
      return Math.sqrt(s5 * s5 + c * c);
    }, F3.prototype.hashCode = function() {
      var o4 = 17;
      return o4 = 37 * o4 + F3.hashCode(this.x), o4 = 37 * o4 + F3.hashCode(this.y);
    }, F3.prototype.setCoordinate = function(o4) {
      this.x = o4.x, this.y = o4.y, this.z = o4.z;
    }, F3.prototype.interfaces_ = function() {
      return [j3, W4, t];
    }, F3.prototype.getClass = function() {
      return F3;
    }, F3.hashCode = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = L3.doubleToLongBits(o4);
        return Math.trunc((s5 ^ s5) >>> 32);
      }
    }, J4.DimensionalComparator.get = function() {
      return ot2;
    }, J4.serialVersionUID.get = function() {
      return 6683108902428367e3;
    }, J4.NULL_ORDINATE.get = function() {
      return L3.NaN;
    }, J4.X.get = function() {
      return 0;
    }, J4.Y.get = function() {
      return 1;
    }, J4.Z.get = function() {
      return 2;
    }, Object.defineProperties(F3, J4);
    var ot2 = H$3(function(o4) {
      if (this._dimensionsToTest = 2, arguments.length !== 0) {
        if (arguments.length === 1) {
          var s5 = arguments[0];
          if (s5 !== 2 && s5 !== 3) throw new A3("only 2 or 3 dimensions may be specified");
          this._dimensionsToTest = s5;
        }
      }
    }, "L");
    ot2.prototype.compare = function(o4, s5) {
      var c = o4, f = s5, g = ot2.compare(c.x, f.x);
      if (g !== 0) return g;
      var _ = ot2.compare(c.y, f.y);
      return _ !== 0 ? _ : this._dimensionsToTest <= 2 ? 0 : ot2.compare(c.z, f.z);
    }, ot2.prototype.interfaces_ = function() {
      return [$5];
    }, ot2.prototype.getClass = function() {
      return ot2;
    }, ot2.compare = function(o4, s5) {
      return o4 < s5 ? -1 : o4 > s5 ? 1 : L3.isNaN(o4) ? L3.isNaN(s5) ? 0 : -1 : L3.isNaN(s5) ? 1 : 0;
    };
    var K4 = H$3(function() {
    }, "b");
    K4.prototype.create = function() {
    }, K4.prototype.interfaces_ = function() {
      return [];
    }, K4.prototype.getClass = function() {
      return K4;
    };
    var H5 = H$3(function() {
    }, "w"), _t2 = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
    H5.prototype.interfaces_ = function() {
      return [];
    }, H5.prototype.getClass = function() {
      return H5;
    }, H5.toLocationSymbol = function(o4) {
      switch (o4) {
        case H5.EXTERIOR:
          return "e";
        case H5.BOUNDARY:
          return "b";
        case H5.INTERIOR:
          return "i";
        case H5.NONE:
          return "-";
      }
      throw new A3("Unknown location value: " + o4);
    }, _t2.INTERIOR.get = function() {
      return 0;
    }, _t2.BOUNDARY.get = function() {
      return 1;
    }, _t2.EXTERIOR.get = function() {
      return 2;
    }, _t2.NONE.get = function() {
      return -1;
    }, Object.defineProperties(H5, _t2);
    var ct2 = H$3(function(o4, s5) {
      return o4.interfaces_ && o4.interfaces_().indexOf(s5) > -1;
    }, "T"), ft2 = H$3(function() {
    }, "R"), mt2 = { LOG_10: { configurable: true } };
    ft2.prototype.interfaces_ = function() {
      return [];
    }, ft2.prototype.getClass = function() {
      return ft2;
    }, ft2.log10 = function(o4) {
      var s5 = Math.log(o4);
      return L3.isInfinite(s5) || L3.isNaN(s5) ? s5 : s5 / ft2.LOG_10;
    }, ft2.min = function(o4, s5, c, f) {
      var g = o4;
      return s5 < g && (g = s5), c < g && (g = c), f < g && (g = f), g;
    }, ft2.clamp = function() {
      if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
        var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
        return o4 < s5 ? s5 : o4 > c ? c : o4;
      }
      if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
        var f = arguments[0], g = arguments[1], _ = arguments[2];
        return f < g ? g : f > _ ? _ : f;
      }
    }, ft2.wrap = function(o4, s5) {
      return o4 < 0 ? s5 - -o4 % s5 : o4 % s5;
    }, ft2.max = function() {
      if (arguments.length === 3) {
        var o4 = arguments[0], s5 = arguments[1], c = arguments[2], f = o4;
        return s5 > f && (f = s5), c > f && (f = c), f;
      }
      if (arguments.length === 4) {
        var g = arguments[0], _ = arguments[1], M3 = arguments[2], N3 = arguments[3], G3 = g;
        return _ > G3 && (G3 = _), M3 > G3 && (G3 = M3), N3 > G3 && (G3 = N3), G3;
      }
    }, ft2.average = function(o4, s5) {
      return (o4 + s5) / 2;
    }, mt2.LOG_10.get = function() {
      return Math.log(10);
    }, Object.defineProperties(ft2, mt2);
    var St2 = H$3(function(o4) {
      this.str = o4;
    }, "D");
    St2.prototype.append = function(o4) {
      this.str += o4;
    }, St2.prototype.setCharAt = function(o4, s5) {
      this.str = this.str.substr(0, o4) + s5 + this.str.substr(o4 + 1);
    }, St2.prototype.toString = function(o4) {
      return this.str;
    };
    var dt2 = H$3(function(o4) {
      this.value = o4;
    }, "M");
    dt2.prototype.intValue = function() {
      return this.value;
    }, dt2.prototype.compareTo = function(o4) {
      return this.value < o4 ? -1 : this.value > o4 ? 1 : 0;
    }, dt2.isNaN = function(o4) {
      return Number.isNaN(o4);
    };
    var xt2 = H$3(function() {
    }, "A");
    xt2.isWhitespace = function(o4) {
      return o4 <= 32 && o4 >= 0 || o4 === 127;
    }, xt2.toUpperCase = function(o4) {
      return o4.toUpperCase();
    };
    var q4 = H$3(function o4() {
      if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0);
      else if (arguments.length === 1) {
        if (typeof arguments[0] == "number") {
          var s5 = arguments[0];
          this.init(s5);
        } else if (arguments[0] instanceof o4) {
          var c = arguments[0];
          this.init(c);
        } else if (typeof arguments[0] == "string") {
          var f = arguments[0];
          o4.call(this, o4.parse(f));
        }
      } else if (arguments.length === 2) {
        var g = arguments[0], _ = arguments[1];
        this.init(g, _);
      }
    }, "t"), ee2 = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
    q4.prototype.le = function(o4) {
      return (this._hi < o4._hi || this._hi === o4._hi) && this._lo <= o4._lo;
    }, q4.prototype.extractSignificantDigits = function(o4, s5) {
      var c = this.abs(), f = q4.magnitude(c._hi), g = q4.TEN.pow(f);
      (c = c.divide(g)).gt(q4.TEN) ? (c = c.divide(q4.TEN), f += 1) : c.lt(q4.ONE) && (c = c.multiply(q4.TEN), f -= 1);
      for (var _ = f + 1, M3 = new St2(), N3 = q4.MAX_PRINT_DIGITS - 1, G3 = 0; G3 <= N3; G3++) {
        o4 && G3 === _ && M3.append(".");
        var Z4 = Math.trunc(c._hi);
        if (Z4 < 0) break;
        var st2 = false, ut2 = 0;
        Z4 > 9 ? (st2 = true, ut2 = "9") : ut2 = "0" + Z4, M3.append(ut2), c = c.subtract(q4.valueOf(Z4)).multiply(q4.TEN), st2 && c.selfAdd(q4.TEN);
        var Ot2 = true, Dt2 = q4.magnitude(c._hi);
        if (Dt2 < 0 && Math.abs(Dt2) >= N3 - G3 && (Ot2 = false), !Ot2) break;
      }
      return s5[0] = f, M3.toString();
    }, q4.prototype.sqr = function() {
      return this.multiply(this);
    }, q4.prototype.doubleValue = function() {
      return this._hi + this._lo;
    }, q4.prototype.subtract = function() {
      if (arguments[0] instanceof q4) {
        var o4 = arguments[0];
        return this.add(o4.negate());
      }
      if (typeof arguments[0] == "number") {
        var s5 = arguments[0];
        return this.add(-s5);
      }
    }, q4.prototype.equals = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return this._hi === o4._hi && this._lo === o4._lo;
      }
    }, q4.prototype.isZero = function() {
      return this._hi === 0 && this._lo === 0;
    }, q4.prototype.selfSubtract = function() {
      if (arguments[0] instanceof q4) {
        var o4 = arguments[0];
        return this.isNaN() ? this : this.selfAdd(-o4._hi, -o4._lo);
      }
      if (typeof arguments[0] == "number") {
        var s5 = arguments[0];
        return this.isNaN() ? this : this.selfAdd(-s5, 0);
      }
    }, q4.prototype.getSpecialNumberString = function() {
      return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
    }, q4.prototype.min = function(o4) {
      return this.le(o4) ? this : o4;
    }, q4.prototype.selfDivide = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof q4) {
          var o4 = arguments[0];
          return this.selfDivide(o4._hi, o4._lo);
        }
        if (typeof arguments[0] == "number") {
          var s5 = arguments[0];
          return this.selfDivide(s5, 0);
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1], g = null, _ = null, M3 = null, N3 = null, G3 = null, Z4 = null, st2 = null, ut2 = null;
        return G3 = this._hi / c, Z4 = q4.SPLIT * G3, g = Z4 - G3, ut2 = q4.SPLIT * c, g = Z4 - g, _ = G3 - g, M3 = ut2 - c, st2 = G3 * c, M3 = ut2 - M3, N3 = c - M3, ut2 = g * M3 - st2 + g * N3 + _ * M3 + _ * N3, Z4 = (this._hi - st2 - ut2 + this._lo - G3 * f) / c, ut2 = G3 + Z4, this._hi = ut2, this._lo = G3 - ut2 + Z4, this;
      }
    }, q4.prototype.dump = function() {
      return "DD<" + this._hi + ", " + this._lo + ">";
    }, q4.prototype.divide = function() {
      if (arguments[0] instanceof q4) {
        var o4 = arguments[0], s5 = null, c = null, f = null, g = null, _ = null, M3 = null, N3 = null, G3 = null;
        return c = (_ = this._hi / o4._hi) - (s5 = (M3 = q4.SPLIT * _) - (s5 = M3 - _)), G3 = s5 * (f = (G3 = q4.SPLIT * o4._hi) - (f = G3 - o4._hi)) - (N3 = _ * o4._hi) + s5 * (g = o4._hi - f) + c * f + c * g, M3 = (this._hi - N3 - G3 + this._lo - _ * o4._lo) / o4._hi, new q4(G3 = _ + M3, _ - G3 + M3);
      }
      if (typeof arguments[0] == "number") {
        var Z4 = arguments[0];
        return L3.isNaN(Z4) ? q4.createNaN() : q4.copy(this).selfDivide(Z4, 0);
      }
    }, q4.prototype.ge = function(o4) {
      return (this._hi > o4._hi || this._hi === o4._hi) && this._lo >= o4._lo;
    }, q4.prototype.pow = function(o4) {
      if (o4 === 0) return q4.valueOf(1);
      var s5 = new q4(this), c = q4.valueOf(1), f = Math.abs(o4);
      if (f > 1) for (; f > 0; ) f % 2 == 1 && c.selfMultiply(s5), (f /= 2) > 0 && (s5 = s5.sqr());
      else c = s5;
      return o4 < 0 ? c.reciprocal() : c;
    }, q4.prototype.ceil = function() {
      if (this.isNaN()) return q4.NaN;
      var o4 = Math.ceil(this._hi), s5 = 0;
      return o4 === this._hi && (s5 = Math.ceil(this._lo)), new q4(o4, s5);
    }, q4.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this._hi < s5._hi ? -1 : this._hi > s5._hi ? 1 : this._lo < s5._lo ? -1 : this._lo > s5._lo ? 1 : 0;
    }, q4.prototype.rint = function() {
      return this.isNaN() ? this : this.add(0.5).floor();
    }, q4.prototype.setValue = function() {
      if (arguments[0] instanceof q4) {
        var o4 = arguments[0];
        return this.init(o4), this;
      }
      if (typeof arguments[0] == "number") {
        var s5 = arguments[0];
        return this.init(s5), this;
      }
    }, q4.prototype.max = function(o4) {
      return this.ge(o4) ? this : o4;
    }, q4.prototype.sqrt = function() {
      if (this.isZero()) return q4.valueOf(0);
      if (this.isNegative()) return q4.NaN;
      var o4 = 1 / Math.sqrt(this._hi), s5 = this._hi * o4, c = q4.valueOf(s5), f = this.subtract(c.sqr())._hi * (0.5 * o4);
      return c.add(f);
    }, q4.prototype.selfAdd = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof q4) {
          var o4 = arguments[0];
          return this.selfAdd(o4._hi, o4._lo);
        }
        if (typeof arguments[0] == "number") {
          var s5 = arguments[0], c = null, f = null, g = null, _ = null, M3 = null, N3 = null;
          return g = this._hi + s5, M3 = g - this._hi, _ = g - M3, _ = s5 - M3 + (this._hi - _), N3 = _ + this._lo, c = g + N3, f = N3 + (g - c), this._hi = c + f, this._lo = f + (c - this._hi), this;
        }
      } else if (arguments.length === 2) {
        var G3 = arguments[0], Z4 = arguments[1], st2 = null, ut2 = null, Ot2 = null, Dt2 = null, Bt2 = null, Wt2 = null, Cr2 = null;
        Dt2 = this._hi + G3, ut2 = this._lo + Z4, Bt2 = Dt2 - (Wt2 = Dt2 - this._hi), Ot2 = ut2 - (Cr2 = ut2 - this._lo);
        var vn2 = (st2 = Dt2 + (Wt2 = (Bt2 = G3 - Wt2 + (this._hi - Bt2)) + ut2)) + (Wt2 = (Ot2 = Z4 - Cr2 + (this._lo - Ot2)) + (Wt2 + (Dt2 - st2))), _i3 = Wt2 + (st2 - vn2);
        return this._hi = vn2, this._lo = _i3, this;
      }
    }, q4.prototype.selfMultiply = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof q4) {
          var o4 = arguments[0];
          return this.selfMultiply(o4._hi, o4._lo);
        }
        if (typeof arguments[0] == "number") {
          var s5 = arguments[0];
          return this.selfMultiply(s5, 0);
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1], g = null, _ = null, M3 = null, N3 = null, G3 = null, Z4 = null;
        g = (G3 = q4.SPLIT * this._hi) - this._hi, Z4 = q4.SPLIT * c, g = G3 - g, _ = this._hi - g, M3 = Z4 - c;
        var st2 = (G3 = this._hi * c) + (Z4 = g * (M3 = Z4 - M3) - G3 + g * (N3 = c - M3) + _ * M3 + _ * N3 + (this._hi * f + this._lo * c)), ut2 = Z4 + (g = G3 - st2);
        return this._hi = st2, this._lo = ut2, this;
      }
    }, q4.prototype.selfSqr = function() {
      return this.selfMultiply(this);
    }, q4.prototype.floor = function() {
      if (this.isNaN()) return q4.NaN;
      var o4 = Math.floor(this._hi), s5 = 0;
      return o4 === this._hi && (s5 = Math.floor(this._lo)), new q4(o4, s5);
    }, q4.prototype.negate = function() {
      return this.isNaN() ? this : new q4(-this._hi, -this._lo);
    }, q4.prototype.clone = function() {
    }, q4.prototype.multiply = function() {
      if (arguments[0] instanceof q4) {
        var o4 = arguments[0];
        return o4.isNaN() ? q4.createNaN() : q4.copy(this).selfMultiply(o4);
      }
      if (typeof arguments[0] == "number") {
        var s5 = arguments[0];
        return L3.isNaN(s5) ? q4.createNaN() : q4.copy(this).selfMultiply(s5, 0);
      }
    }, q4.prototype.isNaN = function() {
      return L3.isNaN(this._hi);
    }, q4.prototype.intValue = function() {
      return Math.trunc(this._hi);
    }, q4.prototype.toString = function() {
      var o4 = q4.magnitude(this._hi);
      return o4 >= -3 && o4 <= 20 ? this.toStandardNotation() : this.toSciNotation();
    }, q4.prototype.toStandardNotation = function() {
      var o4 = this.getSpecialNumberString();
      if (o4 !== null) return o4;
      var s5 = new Array(1).fill(null), c = this.extractSignificantDigits(true, s5), f = s5[0] + 1, g = c;
      if (c.charAt(0) === ".") g = "0" + c;
      else if (f < 0) g = "0." + q4.stringOfChar("0", -f) + c;
      else if (c.indexOf(".") === -1) {
        var _ = f - c.length;
        g = c + q4.stringOfChar("0", _) + ".0";
      }
      return this.isNegative() ? "-" + g : g;
    }, q4.prototype.reciprocal = function() {
      var o4 = null, s5 = null, c = null, f = null, g = null, _ = null, M3 = null, N3 = null;
      s5 = (g = 1 / this._hi) - (o4 = (_ = q4.SPLIT * g) - (o4 = _ - g)), c = (N3 = q4.SPLIT * this._hi) - this._hi;
      var G3 = g + (_ = (1 - (M3 = g * this._hi) - (N3 = o4 * (c = N3 - c) - M3 + o4 * (f = this._hi - c) + s5 * c + s5 * f) - g * this._lo) / this._hi);
      return new q4(G3, g - G3 + _);
    }, q4.prototype.toSciNotation = function() {
      if (this.isZero()) return q4.SCI_NOT_ZERO;
      var o4 = this.getSpecialNumberString();
      if (o4 !== null) return o4;
      var s5 = new Array(1).fill(null), c = this.extractSignificantDigits(false, s5), f = q4.SCI_NOT_EXPONENT_CHAR + s5[0];
      if (c.charAt(0) === "0") throw new Error("Found leading zero: " + c);
      var g = "";
      c.length > 1 && (g = c.substring(1));
      var _ = c.charAt(0) + "." + g;
      return this.isNegative() ? "-" + _ + f : _ + f;
    }, q4.prototype.abs = function() {
      return this.isNaN() ? q4.NaN : this.isNegative() ? this.negate() : new q4(this);
    }, q4.prototype.isPositive = function() {
      return (this._hi > 0 || this._hi === 0) && this._lo > 0;
    }, q4.prototype.lt = function(o4) {
      return (this._hi < o4._hi || this._hi === o4._hi) && this._lo < o4._lo;
    }, q4.prototype.add = function() {
      if (arguments[0] instanceof q4) {
        var o4 = arguments[0];
        return q4.copy(this).selfAdd(o4);
      }
      if (typeof arguments[0] == "number") {
        var s5 = arguments[0];
        return q4.copy(this).selfAdd(s5);
      }
    }, q4.prototype.init = function() {
      if (arguments.length === 1) {
        if (typeof arguments[0] == "number") {
          var o4 = arguments[0];
          this._hi = o4, this._lo = 0;
        } else if (arguments[0] instanceof q4) {
          var s5 = arguments[0];
          this._hi = s5._hi, this._lo = s5._lo;
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        this._hi = c, this._lo = f;
      }
    }, q4.prototype.gt = function(o4) {
      return (this._hi > o4._hi || this._hi === o4._hi) && this._lo > o4._lo;
    }, q4.prototype.isNegative = function() {
      return (this._hi < 0 || this._hi === 0) && this._lo < 0;
    }, q4.prototype.trunc = function() {
      return this.isNaN() ? q4.NaN : this.isPositive() ? this.floor() : this.ceil();
    }, q4.prototype.signum = function() {
      return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
    }, q4.prototype.interfaces_ = function() {
      return [t, j3, W4];
    }, q4.prototype.getClass = function() {
      return q4;
    }, q4.sqr = function(o4) {
      return q4.valueOf(o4).selfMultiply(o4);
    }, q4.valueOf = function() {
      if (typeof arguments[0] == "string") {
        var o4 = arguments[0];
        return q4.parse(o4);
      }
      if (typeof arguments[0] == "number") {
        var s5 = arguments[0];
        return new q4(s5);
      }
    }, q4.sqrt = function(o4) {
      return q4.valueOf(o4).sqrt();
    }, q4.parse = function(o4) {
      for (var s5 = 0, c = o4.length; xt2.isWhitespace(o4.charAt(s5)); ) s5++;
      var f = false;
      if (s5 < c) {
        var g = o4.charAt(s5);
        g !== "-" && g !== "+" || (s5++, g === "-" && (f = true));
      }
      for (var _ = new q4(), M3 = 0, N3 = 0, G3 = 0; !(s5 >= c); ) {
        var Z4 = o4.charAt(s5);
        if (s5++, xt2.isDigit(Z4)) {
          var st2 = Z4 - "0";
          _.selfMultiply(q4.TEN), _.selfAdd(st2), M3++;
        } else {
          if (Z4 !== ".") {
            if (Z4 === "e" || Z4 === "E") {
              var ut2 = o4.substring(s5);
              try {
                G3 = dt2.parseInt(ut2);
              } catch (Cr2) {
                throw Cr2 instanceof Error ? new Error("Invalid exponent " + ut2 + " in string " + o4) : Cr2;
              }
              break;
            }
            throw new Error("Unexpected character '" + Z4 + "' at position " + s5 + " in string " + o4);
          }
          N3 = M3;
        }
      }
      var Ot2 = _, Dt2 = M3 - N3 - G3;
      if (Dt2 === 0) Ot2 = _;
      else if (Dt2 > 0) {
        var Bt2 = q4.TEN.pow(Dt2);
        Ot2 = _.divide(Bt2);
      } else if (Dt2 < 0) {
        var Wt2 = q4.TEN.pow(-Dt2);
        Ot2 = _.multiply(Wt2);
      }
      return f ? Ot2.negate() : Ot2;
    }, q4.createNaN = function() {
      return new q4(L3.NaN, L3.NaN);
    }, q4.copy = function(o4) {
      return new q4(o4);
    }, q4.magnitude = function(o4) {
      var s5 = Math.abs(o4), c = Math.log(s5) / Math.log(10), f = Math.trunc(Math.floor(c));
      return 10 * Math.pow(10, f) <= s5 && (f += 1), f;
    }, q4.stringOfChar = function(o4, s5) {
      for (var c = new St2(), f = 0; f < s5; f++) c.append(o4);
      return c.toString();
    }, ee2.PI.get = function() {
      return new q4(3.141592653589793, 12246467991473532e-32);
    }, ee2.TWO_PI.get = function() {
      return new q4(6.283185307179586, 24492935982947064e-32);
    }, ee2.PI_2.get = function() {
      return new q4(1.5707963267948966, 6123233995736766e-32);
    }, ee2.E.get = function() {
      return new q4(2.718281828459045, 14456468917292502e-32);
    }, ee2.NaN.get = function() {
      return new q4(L3.NaN, L3.NaN);
    }, ee2.EPS.get = function() {
      return 123259516440783e-46;
    }, ee2.SPLIT.get = function() {
      return 134217729;
    }, ee2.MAX_PRINT_DIGITS.get = function() {
      return 32;
    }, ee2.TEN.get = function() {
      return q4.valueOf(10);
    }, ee2.ONE.get = function() {
      return q4.valueOf(1);
    }, ee2.SCI_NOT_EXPONENT_CHAR.get = function() {
      return "E";
    }, ee2.SCI_NOT_ZERO.get = function() {
      return "0.0E0";
    }, Object.defineProperties(q4, ee2);
    var Gt2 = H$3(function() {
    }, "q"), Kt2 = { DP_SAFE_EPSILON: { configurable: true } };
    Gt2.prototype.interfaces_ = function() {
      return [];
    }, Gt2.prototype.getClass = function() {
      return Gt2;
    }, Gt2.orientationIndex = function(o4, s5, c) {
      var f = Gt2.orientationIndexFilter(o4, s5, c);
      if (f <= 1) return f;
      var g = q4.valueOf(s5.x).selfAdd(-o4.x), _ = q4.valueOf(s5.y).selfAdd(-o4.y), M3 = q4.valueOf(c.x).selfAdd(-s5.x), N3 = q4.valueOf(c.y).selfAdd(-s5.y);
      return g.selfMultiply(N3).selfSubtract(_.selfMultiply(M3)).signum();
    }, Gt2.signOfDet2x2 = function(o4, s5, c, f) {
      return o4.multiply(f).selfSubtract(s5.multiply(c)).signum();
    }, Gt2.intersection = function(o4, s5, c, f) {
      var g = q4.valueOf(f.y).selfSubtract(c.y).selfMultiply(q4.valueOf(s5.x).selfSubtract(o4.x)), _ = q4.valueOf(f.x).selfSubtract(c.x).selfMultiply(q4.valueOf(s5.y).selfSubtract(o4.y)), M3 = g.subtract(_), N3 = q4.valueOf(f.x).selfSubtract(c.x).selfMultiply(q4.valueOf(o4.y).selfSubtract(c.y)), G3 = q4.valueOf(f.y).selfSubtract(c.y).selfMultiply(q4.valueOf(o4.x).selfSubtract(c.x)), Z4 = N3.subtract(G3).selfDivide(M3).doubleValue(), st2 = q4.valueOf(o4.x).selfAdd(q4.valueOf(s5.x).selfSubtract(o4.x).selfMultiply(Z4)).doubleValue(), ut2 = q4.valueOf(s5.x).selfSubtract(o4.x).selfMultiply(q4.valueOf(o4.y).selfSubtract(c.y)), Ot2 = q4.valueOf(s5.y).selfSubtract(o4.y).selfMultiply(q4.valueOf(o4.x).selfSubtract(c.x)), Dt2 = ut2.subtract(Ot2).selfDivide(M3).doubleValue(), Bt2 = q4.valueOf(c.y).selfAdd(q4.valueOf(f.y).selfSubtract(c.y).selfMultiply(Dt2)).doubleValue();
      return new F3(st2, Bt2);
    }, Gt2.orientationIndexFilter = function(o4, s5, c) {
      var f = null, g = (o4.x - c.x) * (s5.y - c.y), _ = (o4.y - c.y) * (s5.x - c.x), M3 = g - _;
      if (g > 0) {
        if (_ <= 0) return Gt2.signum(M3);
        f = g + _;
      } else {
        if (!(g < 0) || _ >= 0) return Gt2.signum(M3);
        f = -g - _;
      }
      var N3 = Gt2.DP_SAFE_EPSILON * f;
      return M3 >= N3 || -M3 >= N3 ? Gt2.signum(M3) : 2;
    }, Gt2.signum = function(o4) {
      return o4 > 0 ? 1 : o4 < 0 ? -1 : 0;
    }, Kt2.DP_SAFE_EPSILON.get = function() {
      return 1e-15;
    }, Object.defineProperties(Gt2, Kt2);
    var It2 = H$3(function() {
    }, "V"), ie2 = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
    ie2.X.get = function() {
      return 0;
    }, ie2.Y.get = function() {
      return 1;
    }, ie2.Z.get = function() {
      return 2;
    }, ie2.M.get = function() {
      return 3;
    }, It2.prototype.setOrdinate = function(o4, s5, c) {
    }, It2.prototype.size = function() {
    }, It2.prototype.getOrdinate = function(o4, s5) {
    }, It2.prototype.getCoordinate = function() {
    }, It2.prototype.getCoordinateCopy = function(o4) {
    }, It2.prototype.getDimension = function() {
    }, It2.prototype.getX = function(o4) {
    }, It2.prototype.clone = function() {
    }, It2.prototype.expandEnvelope = function(o4) {
    }, It2.prototype.copy = function() {
    }, It2.prototype.getY = function(o4) {
    }, It2.prototype.toCoordinateArray = function() {
    }, It2.prototype.interfaces_ = function() {
      return [W4];
    }, It2.prototype.getClass = function() {
      return It2;
    }, Object.defineProperties(It2, ie2);
    var vr2 = H$3(function() {
    }, "z"), Qe2 = (function(o4) {
      function s5() {
        o4.call(this, "Projective point not representable on the Cartesian plane.");
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(vr2), Nt2 = H$3(function() {
    }, "Y");
    Nt2.arraycopy = function(o4, s5, c, f, g) {
      for (var _ = 0, M3 = s5; M3 < s5 + g; M3++) c[f + _] = o4[M3], _++;
    }, Nt2.getProperty = function(o4) {
      return { "line.separator": "\n" }[o4];
    };
    var At2 = H$3(function o4() {
      if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1;
      else if (arguments.length === 1) {
        var s5 = arguments[0];
        this.x = s5.x, this.y = s5.y, this.w = 1;
      } else if (arguments.length === 2) {
        if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
          var c = arguments[0], f = arguments[1];
          this.x = c, this.y = f, this.w = 1;
        } else if (arguments[0] instanceof o4 && arguments[1] instanceof o4) {
          var g = arguments[0], _ = arguments[1];
          this.x = g.y * _.w - _.y * g.w, this.y = _.x * g.w - g.x * _.w, this.w = g.x * _.y - _.x * g.y;
        } else if (arguments[0] instanceof F3 && arguments[1] instanceof F3) {
          var M3 = arguments[0], N3 = arguments[1];
          this.x = M3.y - N3.y, this.y = N3.x - M3.x, this.w = M3.x * N3.y - N3.x * M3.y;
        }
      } else if (arguments.length === 3) {
        var G3 = arguments[0], Z4 = arguments[1], st2 = arguments[2];
        this.x = G3, this.y = Z4, this.w = st2;
      } else if (arguments.length === 4) {
        var ut2 = arguments[0], Ot2 = arguments[1], Dt2 = arguments[2], Bt2 = arguments[3], Wt2 = ut2.y - Ot2.y, Cr2 = Ot2.x - ut2.x, vn2 = ut2.x * Ot2.y - Ot2.x * ut2.y, _i3 = Dt2.y - Bt2.y, ta2 = Bt2.x - Dt2.x, Vl2 = Dt2.x * Bt2.y - Bt2.x * Dt2.y;
        this.x = Cr2 * Vl2 - ta2 * vn2, this.y = _i3 * vn2 - Wt2 * Vl2, this.w = Wt2 * ta2 - _i3 * Cr2;
      }
    }, "t");
    At2.prototype.getY = function() {
      var o4 = this.y / this.w;
      if (L3.isNaN(o4) || L3.isInfinite(o4)) throw new Qe2();
      return o4;
    }, At2.prototype.getX = function() {
      var o4 = this.x / this.w;
      if (L3.isNaN(o4) || L3.isInfinite(o4)) throw new Qe2();
      return o4;
    }, At2.prototype.getCoordinate = function() {
      var o4 = new F3();
      return o4.x = this.getX(), o4.y = this.getY(), o4;
    }, At2.prototype.interfaces_ = function() {
      return [];
    }, At2.prototype.getClass = function() {
      return At2;
    }, At2.intersection = function(o4, s5, c, f) {
      var g = o4.y - s5.y, _ = s5.x - o4.x, M3 = o4.x * s5.y - s5.x * o4.y, N3 = c.y - f.y, G3 = f.x - c.x, Z4 = c.x * f.y - f.x * c.y, st2 = g * G3 - N3 * _, ut2 = (_ * Z4 - G3 * M3) / st2, Ot2 = (N3 * M3 - g * Z4) / st2;
      if (L3.isNaN(ut2) || L3.isInfinite(ut2) || L3.isNaN(Ot2) || L3.isInfinite(Ot2)) throw new Qe2();
      return new F3(ut2, Ot2);
    };
    var Ct2 = H$3(function o4() {
      if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init();
      else if (arguments.length === 1) {
        if (arguments[0] instanceof F3) {
          var s5 = arguments[0];
          this.init(s5.x, s5.x, s5.y, s5.y);
        } else if (arguments[0] instanceof o4) {
          var c = arguments[0];
          this.init(c);
        }
      } else if (arguments.length === 2) {
        var f = arguments[0], g = arguments[1];
        this.init(f.x, g.x, f.y, g.y);
      } else if (arguments.length === 4) {
        var _ = arguments[0], M3 = arguments[1], N3 = arguments[2], G3 = arguments[3];
        this.init(_, M3, N3, G3);
      }
    }, "t"), _e3 = { serialVersionUID: { configurable: true } };
    Ct2.prototype.getArea = function() {
      return this.getWidth() * this.getHeight();
    }, Ct2.prototype.equals = function(o4) {
      if (!(o4 instanceof Ct2)) return false;
      var s5 = o4;
      return this.isNull() ? s5.isNull() : this._maxx === s5.getMaxX() && this._maxy === s5.getMaxY() && this._minx === s5.getMinX() && this._miny === s5.getMinY();
    }, Ct2.prototype.intersection = function(o4) {
      if (this.isNull() || o4.isNull() || !this.intersects(o4)) return new Ct2();
      var s5 = this._minx > o4._minx ? this._minx : o4._minx, c = this._miny > o4._miny ? this._miny : o4._miny, f = this._maxx < o4._maxx ? this._maxx : o4._maxx, g = this._maxy < o4._maxy ? this._maxy : o4._maxy;
      return new Ct2(s5, f, c, g);
    }, Ct2.prototype.isNull = function() {
      return this._maxx < this._minx;
    }, Ct2.prototype.getMaxX = function() {
      return this._maxx;
    }, Ct2.prototype.covers = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof F3) {
          var o4 = arguments[0];
          return this.covers(o4.x, o4.y);
        }
        if (arguments[0] instanceof Ct2) {
          var s5 = arguments[0];
          return !this.isNull() && !s5.isNull() && s5.getMinX() >= this._minx && s5.getMaxX() <= this._maxx && s5.getMinY() >= this._miny && s5.getMaxY() <= this._maxy;
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        return !this.isNull() && c >= this._minx && c <= this._maxx && f >= this._miny && f <= this._maxy;
      }
    }, Ct2.prototype.intersects = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Ct2) {
          var o4 = arguments[0];
          return !this.isNull() && !o4.isNull() && !(o4._minx > this._maxx || o4._maxx < this._minx || o4._miny > this._maxy || o4._maxy < this._miny);
        }
        if (arguments[0] instanceof F3) {
          var s5 = arguments[0];
          return this.intersects(s5.x, s5.y);
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        return !this.isNull() && !(c > this._maxx || c < this._minx || f > this._maxy || f < this._miny);
      }
    }, Ct2.prototype.getMinY = function() {
      return this._miny;
    }, Ct2.prototype.getMinX = function() {
      return this._minx;
    }, Ct2.prototype.expandToInclude = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof F3) {
          var o4 = arguments[0];
          this.expandToInclude(o4.x, o4.y);
        } else if (arguments[0] instanceof Ct2) {
          var s5 = arguments[0];
          if (s5.isNull()) return null;
          this.isNull() ? (this._minx = s5.getMinX(), this._maxx = s5.getMaxX(), this._miny = s5.getMinY(), this._maxy = s5.getMaxY()) : (s5._minx < this._minx && (this._minx = s5._minx), s5._maxx > this._maxx && (this._maxx = s5._maxx), s5._miny < this._miny && (this._miny = s5._miny), s5._maxy > this._maxy && (this._maxy = s5._maxy));
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        this.isNull() ? (this._minx = c, this._maxx = c, this._miny = f, this._maxy = f) : (c < this._minx && (this._minx = c), c > this._maxx && (this._maxx = c), f < this._miny && (this._miny = f), f > this._maxy && (this._maxy = f));
      }
    }, Ct2.prototype.minExtent = function() {
      if (this.isNull()) return 0;
      var o4 = this.getWidth(), s5 = this.getHeight();
      return o4 < s5 ? o4 : s5;
    }, Ct2.prototype.getWidth = function() {
      return this.isNull() ? 0 : this._maxx - this._minx;
    }, Ct2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this.isNull() ? s5.isNull() ? 0 : -1 : s5.isNull() ? 1 : this._minx < s5._minx ? -1 : this._minx > s5._minx ? 1 : this._miny < s5._miny ? -1 : this._miny > s5._miny ? 1 : this._maxx < s5._maxx ? -1 : this._maxx > s5._maxx ? 1 : this._maxy < s5._maxy ? -1 : this._maxy > s5._maxy ? 1 : 0;
    }, Ct2.prototype.translate = function(o4, s5) {
      if (this.isNull()) return null;
      this.init(this.getMinX() + o4, this.getMaxX() + o4, this.getMinY() + s5, this.getMaxY() + s5);
    }, Ct2.prototype.toString = function() {
      return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
    }, Ct2.prototype.setToNull = function() {
      this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
    }, Ct2.prototype.getHeight = function() {
      return this.isNull() ? 0 : this._maxy - this._miny;
    }, Ct2.prototype.maxExtent = function() {
      if (this.isNull()) return 0;
      var o4 = this.getWidth(), s5 = this.getHeight();
      return o4 > s5 ? o4 : s5;
    }, Ct2.prototype.expandBy = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.expandBy(o4, o4);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        if (this.isNull()) return null;
        this._minx -= s5, this._maxx += s5, this._miny -= c, this._maxy += c, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
      }
    }, Ct2.prototype.contains = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Ct2) {
          var o4 = arguments[0];
          return this.covers(o4);
        }
        if (arguments[0] instanceof F3) {
          var s5 = arguments[0];
          return this.covers(s5);
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        return this.covers(c, f);
      }
    }, Ct2.prototype.centre = function() {
      return this.isNull() ? null : new F3((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
    }, Ct2.prototype.init = function() {
      if (arguments.length === 0) this.setToNull();
      else if (arguments.length === 1) {
        if (arguments[0] instanceof F3) {
          var o4 = arguments[0];
          this.init(o4.x, o4.x, o4.y, o4.y);
        } else if (arguments[0] instanceof Ct2) {
          var s5 = arguments[0];
          this._minx = s5._minx, this._maxx = s5._maxx, this._miny = s5._miny, this._maxy = s5._maxy;
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        this.init(c.x, f.x, c.y, f.y);
      } else if (arguments.length === 4) {
        var g = arguments[0], _ = arguments[1], M3 = arguments[2], N3 = arguments[3];
        g < _ ? (this._minx = g, this._maxx = _) : (this._minx = _, this._maxx = g), M3 < N3 ? (this._miny = M3, this._maxy = N3) : (this._miny = N3, this._maxy = M3);
      }
    }, Ct2.prototype.getMaxY = function() {
      return this._maxy;
    }, Ct2.prototype.distance = function(o4) {
      if (this.intersects(o4)) return 0;
      var s5 = 0;
      this._maxx < o4._minx ? s5 = o4._minx - this._maxx : this._minx > o4._maxx && (s5 = this._minx - o4._maxx);
      var c = 0;
      return this._maxy < o4._miny ? c = o4._miny - this._maxy : this._miny > o4._maxy && (c = this._miny - o4._maxy), s5 === 0 ? c : c === 0 ? s5 : Math.sqrt(s5 * s5 + c * c);
    }, Ct2.prototype.hashCode = function() {
      var o4 = 17;
      return o4 = 37 * o4 + F3.hashCode(this._minx), o4 = 37 * o4 + F3.hashCode(this._maxx), o4 = 37 * o4 + F3.hashCode(this._miny), o4 = 37 * o4 + F3.hashCode(this._maxy);
    }, Ct2.prototype.interfaces_ = function() {
      return [j3, t];
    }, Ct2.prototype.getClass = function() {
      return Ct2;
    }, Ct2.intersects = function() {
      if (arguments.length === 3) {
        var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
        return c.x >= (o4.x < s5.x ? o4.x : s5.x) && c.x <= (o4.x > s5.x ? o4.x : s5.x) && c.y >= (o4.y < s5.y ? o4.y : s5.y) && c.y <= (o4.y > s5.y ? o4.y : s5.y);
      }
      if (arguments.length === 4) {
        var f = arguments[0], g = arguments[1], _ = arguments[2], M3 = arguments[3], N3 = Math.min(_.x, M3.x), G3 = Math.max(_.x, M3.x), Z4 = Math.min(f.x, g.x), st2 = Math.max(f.x, g.x);
        return !(Z4 > G3) && !(st2 < N3) && (N3 = Math.min(_.y, M3.y), G3 = Math.max(_.y, M3.y), Z4 = Math.min(f.y, g.y), st2 = Math.max(f.y, g.y), !(Z4 > G3) && !(st2 < N3));
      }
    }, _e3.serialVersionUID.get = function() {
      return 5873921885273102e3;
    }, Object.defineProperties(Ct2, _e3);
    var de2 = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }, qr2 = H$3(function(o4) {
      this.geometryFactory = o4 || new ge2();
    }, "K");
    qr2.prototype.read = function(o4) {
      var s5, c, f;
      o4 = o4.replace(/[\n\r]/g, " ");
      var g = de2.typeStr.exec(o4);
      if (o4.search("EMPTY") !== -1 && ((g = de2.emptyTypeStr.exec(o4))[2] = void 0), g && (c = g[1].toLowerCase(), f = g[2], Se2[c] && (s5 = Se2[c].apply(this, [f]))), s5 === void 0) throw new Error("Could not parse WKT " + o4);
      return s5;
    }, qr2.prototype.write = function(o4) {
      return this.extractGeometry(o4);
    }, qr2.prototype.extractGeometry = function(o4) {
      var s5 = o4.getGeometryType().toLowerCase();
      if (!me2[s5]) return null;
      var c = s5.toUpperCase();
      return o4.isEmpty() ? c + " EMPTY" : c + "(" + me2[s5].apply(this, [o4]) + ")";
    };
    var me2 = { coordinate: H$3(function(o4) {
      return o4.x + " " + o4.y;
    }, "coordinate"), point: H$3(function(o4) {
      return me2.coordinate.call(this, o4._coordinates._coordinates[0]);
    }, "point"), multipoint: H$3(function(o4) {
      for (var s5 = [], c = 0, f = o4._geometries.length; c < f; ++c) s5.push("(" + me2.point.apply(this, [o4._geometries[c]]) + ")");
      return s5.join(",");
    }, "multipoint"), linestring: H$3(function(o4) {
      for (var s5 = [], c = 0, f = o4._points._coordinates.length; c < f; ++c) s5.push(me2.coordinate.apply(this, [o4._points._coordinates[c]]));
      return s5.join(",");
    }, "linestring"), linearring: H$3(function(o4) {
      for (var s5 = [], c = 0, f = o4._points._coordinates.length; c < f; ++c) s5.push(me2.coordinate.apply(this, [o4._points._coordinates[c]]));
      return s5.join(",");
    }, "linearring"), multilinestring: H$3(function(o4) {
      for (var s5 = [], c = 0, f = o4._geometries.length; c < f; ++c) s5.push("(" + me2.linestring.apply(this, [o4._geometries[c]]) + ")");
      return s5.join(",");
    }, "multilinestring"), polygon: H$3(function(o4) {
      var s5 = [];
      s5.push("(" + me2.linestring.apply(this, [o4._shell]) + ")");
      for (var c = 0, f = o4._holes.length; c < f; ++c) s5.push("(" + me2.linestring.apply(this, [o4._holes[c]]) + ")");
      return s5.join(",");
    }, "polygon"), multipolygon: H$3(function(o4) {
      for (var s5 = [], c = 0, f = o4._geometries.length; c < f; ++c) s5.push("(" + me2.polygon.apply(this, [o4._geometries[c]]) + ")");
      return s5.join(",");
    }, "multipolygon"), geometrycollection: H$3(function(o4) {
      for (var s5 = [], c = 0, f = o4._geometries.length; c < f; ++c) s5.push(this.extractGeometry(o4._geometries[c]));
      return s5.join(",");
    }, "geometrycollection") }, Se2 = { point: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createPoint();
      var s5 = o4.trim().split(de2.spaces);
      return this.geometryFactory.createPoint(new F3(Number.parseFloat(s5[0]), Number.parseFloat(s5[1])));
    }, "point"), multipoint: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createMultiPoint();
      for (var s5, c = o4.trim().split(","), f = [], g = 0, _ = c.length; g < _; ++g) s5 = c[g].replace(de2.trimParens, "$1"), f.push(Se2.point.apply(this, [s5]));
      return this.geometryFactory.createMultiPoint(f);
    }, "multipoint"), linestring: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createLineString();
      for (var s5, c = o4.trim().split(","), f = [], g = 0, _ = c.length; g < _; ++g) s5 = c[g].trim().split(de2.spaces), f.push(new F3(Number.parseFloat(s5[0]), Number.parseFloat(s5[1])));
      return this.geometryFactory.createLineString(f);
    }, "linestring"), linearring: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createLinearRing();
      for (var s5, c = o4.trim().split(","), f = [], g = 0, _ = c.length; g < _; ++g) s5 = c[g].trim().split(de2.spaces), f.push(new F3(Number.parseFloat(s5[0]), Number.parseFloat(s5[1])));
      return this.geometryFactory.createLinearRing(f);
    }, "linearring"), multilinestring: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createMultiLineString();
      for (var s5, c = o4.trim().split(de2.parenComma), f = [], g = 0, _ = c.length; g < _; ++g) s5 = c[g].replace(de2.trimParens, "$1"), f.push(Se2.linestring.apply(this, [s5]));
      return this.geometryFactory.createMultiLineString(f);
    }, "multilinestring"), polygon: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createPolygon();
      for (var s5, c, f, g, _ = o4.trim().split(de2.parenComma), M3 = [], N3 = 0, G3 = _.length; N3 < G3; ++N3) s5 = _[N3].replace(de2.trimParens, "$1"), c = Se2.linestring.apply(this, [s5]), f = this.geometryFactory.createLinearRing(c._points), N3 === 0 ? g = f : M3.push(f);
      return this.geometryFactory.createPolygon(g, M3);
    }, "polygon"), multipolygon: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createMultiPolygon();
      for (var s5, c = o4.trim().split(de2.doubleParenComma), f = [], g = 0, _ = c.length; g < _; ++g) s5 = c[g].replace(de2.trimParens, "$1"), f.push(Se2.polygon.apply(this, [s5]));
      return this.geometryFactory.createMultiPolygon(f);
    }, "multipolygon"), geometrycollection: H$3(function(o4) {
      if (o4 === void 0) return this.geometryFactory.createGeometryCollection();
      for (var s5 = (o4 = o4.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), c = [], f = 0, g = s5.length; f < g; ++f) c.push(this.read(s5[f]));
      return this.geometryFactory.createGeometryCollection(c);
    }, "geometrycollection") }, br2 = H$3(function(o4) {
      this.parser = new qr2(o4);
    }, "Z");
    br2.prototype.write = function(o4) {
      return this.parser.write(o4);
    }, br2.toLineString = function(o4, s5) {
      if (arguments.length !== 2) throw new Error("Not implemented");
      return "LINESTRING ( " + o4.x + " " + o4.y + ", " + s5.x + " " + s5.y + " )";
    };
    var Wr2 = (function(o4) {
      function s5(c) {
        o4.call(this, c), this.name = "RuntimeException", this.message = c, this.stack = new o4().stack;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5;
    })(Error), $i2 = (function(o4) {
      function s5() {
        if (o4.call(this), arguments.length === 0) o4.call(this);
        else if (arguments.length === 1) {
          var c = arguments[0];
          o4.call(this, c);
        }
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(Wr2), Yt2 = H$3(function() {
    }, "et");
    Yt2.prototype.interfaces_ = function() {
      return [];
    }, Yt2.prototype.getClass = function() {
      return Yt2;
    }, Yt2.shouldNeverReachHere = function() {
      if (arguments.length === 0) Yt2.shouldNeverReachHere(null);
      else if (arguments.length === 1) {
        var o4 = arguments[0];
        throw new $i2("Should never reach here" + (o4 !== null ? ": " + o4 : ""));
      }
    }, Yt2.isTrue = function() {
      var o4, s5;
      if (arguments.length === 1) o4 = arguments[0], Yt2.isTrue(o4, null);
      else if (arguments.length === 2 && (o4 = arguments[0], s5 = arguments[1], !o4)) throw s5 === null ? new $i2() : new $i2(s5);
    }, Yt2.equals = function() {
      var o4, s5, c;
      if (arguments.length === 2) o4 = arguments[0], s5 = arguments[1], Yt2.equals(o4, s5, null);
      else if (arguments.length === 3 && (o4 = arguments[0], s5 = arguments[1], c = arguments[2], !s5.equals(o4))) throw new $i2("Expected " + o4 + " but encountered " + s5 + (c !== null ? ": " + c : ""));
    };
    var mr2 = H$3(function() {
      this._result = null, this._inputLines = Array(2).fill().map(function() {
        return Array(2);
      }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new F3(), this._intPt[1] = new F3(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
    }, "nt"), co2 = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
    mr2.prototype.getIndexAlongSegment = function(o4, s5) {
      return this.computeIntLineIndex(), this._intLineIndex[o4][s5];
    }, mr2.prototype.getTopologySummary = function() {
      var o4 = new St2();
      return this.isEndPoint() && o4.append(" endpoint"), this._isProper && o4.append(" proper"), this.isCollinear() && o4.append(" collinear"), o4.toString();
    }, mr2.prototype.computeIntersection = function(o4, s5, c, f) {
      this._inputLines[0][0] = o4, this._inputLines[0][1] = s5, this._inputLines[1][0] = c, this._inputLines[1][1] = f, this._result = this.computeIntersect(o4, s5, c, f);
    }, mr2.prototype.getIntersectionNum = function() {
      return this._result;
    }, mr2.prototype.computeIntLineIndex = function() {
      if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function() {
        return Array(2);
      }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
      else if (arguments.length === 1) {
        var o4 = arguments[0];
        this.getEdgeDistance(o4, 0) > this.getEdgeDistance(o4, 1) ? (this._intLineIndex[o4][0] = 0, this._intLineIndex[o4][1] = 1) : (this._intLineIndex[o4][0] = 1, this._intLineIndex[o4][1] = 0);
      }
    }, mr2.prototype.isProper = function() {
      return this.hasIntersection() && this._isProper;
    }, mr2.prototype.setPrecisionModel = function(o4) {
      this._precisionModel = o4;
    }, mr2.prototype.isInteriorIntersection = function() {
      if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
      if (arguments.length === 1) {
        for (var o4 = arguments[0], s5 = 0; s5 < this._result; s5++) if (!this._intPt[s5].equals2D(this._inputLines[o4][0]) && !this._intPt[s5].equals2D(this._inputLines[o4][1])) return true;
        return false;
      }
    }, mr2.prototype.getIntersection = function(o4) {
      return this._intPt[o4];
    }, mr2.prototype.isEndPoint = function() {
      return this.hasIntersection() && !this._isProper;
    }, mr2.prototype.hasIntersection = function() {
      return this._result !== mr2.NO_INTERSECTION;
    }, mr2.prototype.getEdgeDistance = function(o4, s5) {
      return mr2.computeEdgeDistance(this._intPt[s5], this._inputLines[o4][0], this._inputLines[o4][1]);
    }, mr2.prototype.isCollinear = function() {
      return this._result === mr2.COLLINEAR_INTERSECTION;
    }, mr2.prototype.toString = function() {
      return br2.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + br2.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
    }, mr2.prototype.getEndpoint = function(o4, s5) {
      return this._inputLines[o4][s5];
    }, mr2.prototype.isIntersection = function(o4) {
      for (var s5 = 0; s5 < this._result; s5++) if (this._intPt[s5].equals2D(o4)) return true;
      return false;
    }, mr2.prototype.getIntersectionAlongSegment = function(o4, s5) {
      return this.computeIntLineIndex(), this._intPt[this._intLineIndex[o4][s5]];
    }, mr2.prototype.interfaces_ = function() {
      return [];
    }, mr2.prototype.getClass = function() {
      return mr2;
    }, mr2.computeEdgeDistance = function(o4, s5, c) {
      var f = Math.abs(c.x - s5.x), g = Math.abs(c.y - s5.y), _ = -1;
      if (o4.equals(s5)) _ = 0;
      else if (o4.equals(c)) _ = f > g ? f : g;
      else {
        var M3 = Math.abs(o4.x - s5.x), N3 = Math.abs(o4.y - s5.y);
        (_ = f > g ? M3 : N3) !== 0 || o4.equals(s5) || (_ = Math.max(M3, N3));
      }
      return Yt2.isTrue(!(_ === 0 && !o4.equals(s5)), "Bad distance calculation"), _;
    }, mr2.nonRobustComputeEdgeDistance = function(o4, s5, c) {
      var f = o4.x - s5.x, g = o4.y - s5.y, _ = Math.sqrt(f * f + g * g);
      return Yt2.isTrue(!(_ === 0 && !o4.equals(s5)), "Invalid distance calculation"), _;
    }, co2.DONT_INTERSECT.get = function() {
      return 0;
    }, co2.DO_INTERSECT.get = function() {
      return 1;
    }, co2.COLLINEAR.get = function() {
      return 2;
    }, co2.NO_INTERSECTION.get = function() {
      return 0;
    }, co2.POINT_INTERSECTION.get = function() {
      return 1;
    }, co2.COLLINEAR_INTERSECTION.get = function() {
      return 2;
    }, Object.defineProperties(mr2, co2);
    var Ji2 = (function(o4) {
      function s5() {
        o4.apply(this, arguments);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.isInSegmentEnvelopes = function(c) {
        var f = new Ct2(this._inputLines[0][0], this._inputLines[0][1]), g = new Ct2(this._inputLines[1][0], this._inputLines[1][1]);
        return f.contains(c) && g.contains(c);
      }, s5.prototype.computeIntersection = function() {
        if (arguments.length !== 3) return o4.prototype.computeIntersection.apply(this, arguments);
        var c = arguments[0], f = arguments[1], g = arguments[2];
        if (this._isProper = false, Ct2.intersects(f, g, c) && wt2.orientationIndex(f, g, c) === 0 && wt2.orientationIndex(g, f, c) === 0) return this._isProper = true, (c.equals(f) || c.equals(g)) && (this._isProper = false), this._result = o4.POINT_INTERSECTION, null;
        this._result = o4.NO_INTERSECTION;
      }, s5.prototype.normalizeToMinimum = function(c, f, g, _, M3) {
        M3.x = this.smallestInAbsValue(c.x, f.x, g.x, _.x), M3.y = this.smallestInAbsValue(c.y, f.y, g.y, _.y), c.x -= M3.x, c.y -= M3.y, f.x -= M3.x, f.y -= M3.y, g.x -= M3.x, g.y -= M3.y, _.x -= M3.x, _.y -= M3.y;
      }, s5.prototype.safeHCoordinateIntersection = function(c, f, g, _) {
        var M3 = null;
        try {
          M3 = At2.intersection(c, f, g, _);
        } catch (N3) {
          if (!(N3 instanceof Qe2)) throw N3;
          M3 = s5.nearestEndpoint(c, f, g, _);
        }
        return M3;
      }, s5.prototype.intersection = function(c, f, g, _) {
        var M3 = this.intersectionWithNormalization(c, f, g, _);
        return this.isInSegmentEnvelopes(M3) || (M3 = new F3(s5.nearestEndpoint(c, f, g, _))), this._precisionModel !== null && this._precisionModel.makePrecise(M3), M3;
      }, s5.prototype.smallestInAbsValue = function(c, f, g, _) {
        var M3 = c, N3 = Math.abs(M3);
        return Math.abs(f) < N3 && (M3 = f, N3 = Math.abs(f)), Math.abs(g) < N3 && (M3 = g, N3 = Math.abs(g)), Math.abs(_) < N3 && (M3 = _), M3;
      }, s5.prototype.checkDD = function(c, f, g, _, M3) {
        var N3 = Gt2.intersection(c, f, g, _), G3 = this.isInSegmentEnvelopes(N3);
        Nt2.out.println("DD in env = " + G3 + "  --------------------- " + N3), M3.distance(N3) > 1e-4 && Nt2.out.println("Distance = " + M3.distance(N3));
      }, s5.prototype.intersectionWithNormalization = function(c, f, g, _) {
        var M3 = new F3(c), N3 = new F3(f), G3 = new F3(g), Z4 = new F3(_), st2 = new F3();
        this.normalizeToEnvCentre(M3, N3, G3, Z4, st2);
        var ut2 = this.safeHCoordinateIntersection(M3, N3, G3, Z4);
        return ut2.x += st2.x, ut2.y += st2.y, ut2;
      }, s5.prototype.computeCollinearIntersection = function(c, f, g, _) {
        var M3 = Ct2.intersects(c, f, g), N3 = Ct2.intersects(c, f, _), G3 = Ct2.intersects(g, _, c), Z4 = Ct2.intersects(g, _, f);
        return M3 && N3 ? (this._intPt[0] = g, this._intPt[1] = _, o4.COLLINEAR_INTERSECTION) : G3 && Z4 ? (this._intPt[0] = c, this._intPt[1] = f, o4.COLLINEAR_INTERSECTION) : M3 && G3 ? (this._intPt[0] = g, this._intPt[1] = c, !g.equals(c) || N3 || Z4 ? o4.COLLINEAR_INTERSECTION : o4.POINT_INTERSECTION) : M3 && Z4 ? (this._intPt[0] = g, this._intPt[1] = f, !g.equals(f) || N3 || G3 ? o4.COLLINEAR_INTERSECTION : o4.POINT_INTERSECTION) : N3 && G3 ? (this._intPt[0] = _, this._intPt[1] = c, !_.equals(c) || M3 || Z4 ? o4.COLLINEAR_INTERSECTION : o4.POINT_INTERSECTION) : N3 && Z4 ? (this._intPt[0] = _, this._intPt[1] = f, !_.equals(f) || M3 || G3 ? o4.COLLINEAR_INTERSECTION : o4.POINT_INTERSECTION) : o4.NO_INTERSECTION;
      }, s5.prototype.normalizeToEnvCentre = function(c, f, g, _, M3) {
        var N3 = c.x < f.x ? c.x : f.x, G3 = c.y < f.y ? c.y : f.y, Z4 = c.x > f.x ? c.x : f.x, st2 = c.y > f.y ? c.y : f.y, ut2 = g.x < _.x ? g.x : _.x, Ot2 = g.y < _.y ? g.y : _.y, Dt2 = g.x > _.x ? g.x : _.x, Bt2 = g.y > _.y ? g.y : _.y, Wt2 = ((N3 > ut2 ? N3 : ut2) + (Z4 < Dt2 ? Z4 : Dt2)) / 2, Cr2 = ((G3 > Ot2 ? G3 : Ot2) + (st2 < Bt2 ? st2 : Bt2)) / 2;
        M3.x = Wt2, M3.y = Cr2, c.x -= M3.x, c.y -= M3.y, f.x -= M3.x, f.y -= M3.y, g.x -= M3.x, g.y -= M3.y, _.x -= M3.x, _.y -= M3.y;
      }, s5.prototype.computeIntersect = function(c, f, g, _) {
        if (this._isProper = false, !Ct2.intersects(c, f, g, _)) return o4.NO_INTERSECTION;
        var M3 = wt2.orientationIndex(c, f, g), N3 = wt2.orientationIndex(c, f, _);
        if (M3 > 0 && N3 > 0 || M3 < 0 && N3 < 0) return o4.NO_INTERSECTION;
        var G3 = wt2.orientationIndex(g, _, c), Z4 = wt2.orientationIndex(g, _, f);
        return G3 > 0 && Z4 > 0 || G3 < 0 && Z4 < 0 ? o4.NO_INTERSECTION : M3 === 0 && N3 === 0 && G3 === 0 && Z4 === 0 ? this.computeCollinearIntersection(c, f, g, _) : (M3 === 0 || N3 === 0 || G3 === 0 || Z4 === 0 ? (this._isProper = false, c.equals2D(g) || c.equals2D(_) ? this._intPt[0] = c : f.equals2D(g) || f.equals2D(_) ? this._intPt[0] = f : M3 === 0 ? this._intPt[0] = new F3(g) : N3 === 0 ? this._intPt[0] = new F3(_) : G3 === 0 ? this._intPt[0] = new F3(c) : Z4 === 0 && (this._intPt[0] = new F3(f))) : (this._isProper = true, this._intPt[0] = this.intersection(c, f, g, _)), o4.POINT_INTERSECTION);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5.nearestEndpoint = function(c, f, g, _) {
        var M3 = c, N3 = wt2.distancePointLine(c, g, _), G3 = wt2.distancePointLine(f, g, _);
        return G3 < N3 && (N3 = G3, M3 = f), (G3 = wt2.distancePointLine(g, c, f)) < N3 && (N3 = G3, M3 = g), (G3 = wt2.distancePointLine(_, c, f)) < N3 && (N3 = G3, M3 = _), M3;
      }, s5;
    })(mr2), po2 = H$3(function() {
    }, "ot");
    po2.prototype.interfaces_ = function() {
      return [];
    }, po2.prototype.getClass = function() {
      return po2;
    }, po2.orientationIndex = function(o4, s5, c) {
      var f = s5.x - o4.x, g = s5.y - o4.y, _ = c.x - s5.x, M3 = c.y - s5.y;
      return po2.signOfDet2x2(f, g, _, M3);
    }, po2.signOfDet2x2 = function(o4, s5, c, f) {
      var g = null, _ = null, M3 = null;
      if (g = 1, o4 === 0 || f === 0) return s5 === 0 || c === 0 ? 0 : s5 > 0 ? c > 0 ? -g : g : c > 0 ? g : -g;
      if (s5 === 0 || c === 0) return f > 0 ? o4 > 0 ? g : -g : o4 > 0 ? -g : g;
      if (s5 > 0 ? f > 0 ? s5 <= f || (g = -g, _ = o4, o4 = c, c = _, _ = s5, s5 = f, f = _) : s5 <= -f ? (g = -g, c = -c, f = -f) : (_ = o4, o4 = -c, c = _, _ = s5, s5 = -f, f = _) : f > 0 ? -s5 <= f ? (g = -g, o4 = -o4, s5 = -s5) : (_ = -o4, o4 = c, c = _, _ = -s5, s5 = f, f = _) : s5 >= f ? (o4 = -o4, s5 = -s5, c = -c, f = -f) : (g = -g, _ = -o4, o4 = -c, c = _, _ = -s5, s5 = -f, f = _), o4 > 0) {
        if (!(c > 0) || !(o4 <= c)) return g;
      } else {
        if (c > 0 || !(o4 >= c)) return -g;
        g = -g, o4 = -o4, c = -c;
      }
      for (; ; ) {
        if (M3 = Math.floor(c / o4), c -= M3 * o4, (f -= M3 * s5) < 0) return -g;
        if (f > s5) return g;
        if (o4 > c + c) {
          if (s5 < f + f) return g;
        } else {
          if (s5 > f + f) return -g;
          c = o4 - c, f = s5 - f, g = -g;
        }
        if (f === 0) return c === 0 ? 0 : -g;
        if (c === 0 || (M3 = Math.floor(o4 / c), o4 -= M3 * c, (s5 -= M3 * f) < 0)) return g;
        if (s5 > f) return -g;
        if (c > o4 + o4) {
          if (f < s5 + s5) return -g;
        } else {
          if (f > s5 + s5) return g;
          o4 = c - o4, s5 = f - s5, g = -g;
        }
        if (s5 === 0) return o4 === 0 ? 0 : g;
        if (o4 === 0) return -g;
      }
    };
    var En2 = H$3(function() {
      this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
      var o4 = arguments[0];
      this._p = o4;
    }, "st");
    En2.prototype.countSegment = function(o4, s5) {
      if (o4.x < this._p.x && s5.x < this._p.x) return null;
      if (this._p.x === s5.x && this._p.y === s5.y) return this._isPointOnSegment = true, null;
      if (o4.y === this._p.y && s5.y === this._p.y) {
        var c = o4.x, f = s5.x;
        return c > f && (c = s5.x, f = o4.x), this._p.x >= c && this._p.x <= f && (this._isPointOnSegment = true), null;
      }
      if (o4.y > this._p.y && s5.y <= this._p.y || s5.y > this._p.y && o4.y <= this._p.y) {
        var g = o4.x - this._p.x, _ = o4.y - this._p.y, M3 = s5.x - this._p.x, N3 = s5.y - this._p.y, G3 = po2.signOfDet2x2(g, _, M3, N3);
        if (G3 === 0) return this._isPointOnSegment = true, null;
        N3 < _ && (G3 = -G3), G3 > 0 && this._crossingCount++;
      }
    }, En2.prototype.isPointInPolygon = function() {
      return this.getLocation() !== H5.EXTERIOR;
    }, En2.prototype.getLocation = function() {
      return this._isPointOnSegment ? H5.BOUNDARY : this._crossingCount % 2 == 1 ? H5.INTERIOR : H5.EXTERIOR;
    }, En2.prototype.isOnSegment = function() {
      return this._isPointOnSegment;
    }, En2.prototype.interfaces_ = function() {
      return [];
    }, En2.prototype.getClass = function() {
      return En2;
    }, En2.locatePointInRing = function() {
      if (arguments[0] instanceof F3 && ct2(arguments[1], It2)) {
        for (var o4 = arguments[0], s5 = arguments[1], c = new En2(o4), f = new F3(), g = new F3(), _ = 1; _ < s5.size(); _++) if (s5.getCoordinate(_, f), s5.getCoordinate(_ - 1, g), c.countSegment(f, g), c.isOnSegment()) return c.getLocation();
        return c.getLocation();
      }
      if (arguments[0] instanceof F3 && arguments[1] instanceof Array) {
        for (var M3 = arguments[0], N3 = arguments[1], G3 = new En2(M3), Z4 = 1; Z4 < N3.length; Z4++) {
          var st2 = N3[Z4], ut2 = N3[Z4 - 1];
          if (G3.countSegment(st2, ut2), G3.isOnSegment()) return G3.getLocation();
        }
        return G3.getLocation();
      }
    };
    var wt2 = H$3(function() {
    }, "at"), Hs3 = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
    wt2.prototype.interfaces_ = function() {
      return [];
    }, wt2.prototype.getClass = function() {
      return wt2;
    }, wt2.orientationIndex = function(o4, s5, c) {
      return Gt2.orientationIndex(o4, s5, c);
    }, wt2.signedArea = function() {
      if (arguments[0] instanceof Array) {
        var o4 = arguments[0];
        if (o4.length < 3) return 0;
        for (var s5 = 0, c = o4[0].x, f = 1; f < o4.length - 1; f++) {
          var g = o4[f].x - c, _ = o4[f + 1].y;
          s5 += g * (o4[f - 1].y - _);
        }
        return s5 / 2;
      }
      if (ct2(arguments[0], It2)) {
        var M3 = arguments[0], N3 = M3.size();
        if (N3 < 3) return 0;
        var G3 = new F3(), Z4 = new F3(), st2 = new F3();
        M3.getCoordinate(0, Z4), M3.getCoordinate(1, st2);
        var ut2 = Z4.x;
        st2.x -= ut2;
        for (var Ot2 = 0, Dt2 = 1; Dt2 < N3 - 1; Dt2++) G3.y = Z4.y, Z4.x = st2.x, Z4.y = st2.y, M3.getCoordinate(Dt2 + 1, st2), st2.x -= ut2, Ot2 += Z4.x * (G3.y - st2.y);
        return Ot2 / 2;
      }
    }, wt2.distanceLineLine = function(o4, s5, c, f) {
      if (o4.equals(s5)) return wt2.distancePointLine(o4, c, f);
      if (c.equals(f)) return wt2.distancePointLine(f, o4, s5);
      var g = false;
      if (Ct2.intersects(o4, s5, c, f)) {
        var _ = (s5.x - o4.x) * (f.y - c.y) - (s5.y - o4.y) * (f.x - c.x);
        if (_ === 0) g = true;
        else {
          var M3 = (o4.y - c.y) * (f.x - c.x) - (o4.x - c.x) * (f.y - c.y), N3 = ((o4.y - c.y) * (s5.x - o4.x) - (o4.x - c.x) * (s5.y - o4.y)) / _, G3 = M3 / _;
          (G3 < 0 || G3 > 1 || N3 < 0 || N3 > 1) && (g = true);
        }
      } else g = true;
      return g ? ft2.min(wt2.distancePointLine(o4, c, f), wt2.distancePointLine(s5, c, f), wt2.distancePointLine(c, o4, s5), wt2.distancePointLine(f, o4, s5)) : 0;
    }, wt2.isPointInRing = function(o4, s5) {
      return wt2.locatePointInRing(o4, s5) !== H5.EXTERIOR;
    }, wt2.computeLength = function(o4) {
      var s5 = o4.size();
      if (s5 <= 1) return 0;
      var c = 0, f = new F3();
      o4.getCoordinate(0, f);
      for (var g = f.x, _ = f.y, M3 = 1; M3 < s5; M3++) {
        o4.getCoordinate(M3, f);
        var N3 = f.x, G3 = f.y, Z4 = N3 - g, st2 = G3 - _;
        c += Math.sqrt(Z4 * Z4 + st2 * st2), g = N3, _ = G3;
      }
      return c;
    }, wt2.isCCW = function(o4) {
      var s5 = o4.length - 1;
      if (s5 < 3) throw new A3("Ring has fewer than 4 points, so orientation cannot be determined");
      for (var c = o4[0], f = 0, g = 1; g <= s5; g++) {
        var _ = o4[g];
        _.y > c.y && (c = _, f = g);
      }
      var M3 = f;
      do
        (M3 -= 1) < 0 && (M3 = s5);
      while (o4[M3].equals2D(c) && M3 !== f);
      var N3 = f;
      do
        N3 = (N3 + 1) % s5;
      while (o4[N3].equals2D(c) && N3 !== f);
      var G3 = o4[M3], Z4 = o4[N3];
      if (G3.equals2D(c) || Z4.equals2D(c) || G3.equals2D(Z4)) return false;
      var st2 = wt2.computeOrientation(G3, c, Z4), ut2 = false;
      return ut2 = st2 === 0 ? G3.x > Z4.x : st2 > 0, ut2;
    }, wt2.locatePointInRing = function(o4, s5) {
      return En2.locatePointInRing(o4, s5);
    }, wt2.distancePointLinePerpendicular = function(o4, s5, c) {
      var f = (c.x - s5.x) * (c.x - s5.x) + (c.y - s5.y) * (c.y - s5.y), g = ((s5.y - o4.y) * (c.x - s5.x) - (s5.x - o4.x) * (c.y - s5.y)) / f;
      return Math.abs(g) * Math.sqrt(f);
    }, wt2.computeOrientation = function(o4, s5, c) {
      return wt2.orientationIndex(o4, s5, c);
    }, wt2.distancePointLine = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        if (s5.length === 0) throw new A3("Line array must contain at least one vertex");
        for (var c = o4.distance(s5[0]), f = 0; f < s5.length - 1; f++) {
          var g = wt2.distancePointLine(o4, s5[f], s5[f + 1]);
          g < c && (c = g);
        }
        return c;
      }
      if (arguments.length === 3) {
        var _ = arguments[0], M3 = arguments[1], N3 = arguments[2];
        if (M3.x === N3.x && M3.y === N3.y) return _.distance(M3);
        var G3 = (N3.x - M3.x) * (N3.x - M3.x) + (N3.y - M3.y) * (N3.y - M3.y), Z4 = ((_.x - M3.x) * (N3.x - M3.x) + (_.y - M3.y) * (N3.y - M3.y)) / G3;
        if (Z4 <= 0) return _.distance(M3);
        if (Z4 >= 1) return _.distance(N3);
        var st2 = ((M3.y - _.y) * (N3.x - M3.x) - (M3.x - _.x) * (N3.y - M3.y)) / G3;
        return Math.abs(st2) * Math.sqrt(G3);
      }
    }, wt2.isOnLine = function(o4, s5) {
      for (var c = new Ji2(), f = 1; f < s5.length; f++) {
        var g = s5[f - 1], _ = s5[f];
        if (c.computeIntersection(o4, g, _), c.hasIntersection()) return true;
      }
      return false;
    }, Hs3.CLOCKWISE.get = function() {
      return -1;
    }, Hs3.RIGHT.get = function() {
      return wt2.CLOCKWISE;
    }, Hs3.COUNTERCLOCKWISE.get = function() {
      return 1;
    }, Hs3.LEFT.get = function() {
      return wt2.COUNTERCLOCKWISE;
    }, Hs3.COLLINEAR.get = function() {
      return 0;
    }, Hs3.STRAIGHT.get = function() {
      return wt2.COLLINEAR;
    }, Object.defineProperties(wt2, Hs3);
    var Zo2 = H$3(function() {
    }, "lt");
    Zo2.prototype.filter = function(o4) {
    }, Zo2.prototype.interfaces_ = function() {
      return [];
    }, Zo2.prototype.getClass = function() {
      return Zo2;
    };
    var Jt2 = H$3(function() {
      var o4 = arguments[0];
      this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = o4, this._SRID = o4.getSRID();
    }, "ct"), ho2 = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
    Jt2.prototype.isGeometryCollection = function() {
      return this.getSortIndex() === Jt2.SORTINDEX_GEOMETRYCOLLECTION;
    }, Jt2.prototype.getFactory = function() {
      return this._factory;
    }, Jt2.prototype.getGeometryN = function(o4) {
      return this;
    }, Jt2.prototype.getArea = function() {
      return 0;
    }, Jt2.prototype.isRectangle = function() {
      return false;
    }, Jt2.prototype.equals = function() {
      if (arguments[0] instanceof Jt2) {
        var o4 = arguments[0];
        return o4 !== null && this.equalsTopo(o4);
      }
      if (arguments[0] instanceof Object) {
        var s5 = arguments[0];
        if (!(s5 instanceof Jt2)) return false;
        var c = s5;
        return this.equalsExact(c);
      }
    }, Jt2.prototype.equalsExact = function(o4) {
      return this === o4 || this.equalsExact(o4, 0);
    }, Jt2.prototype.geometryChanged = function() {
      this.apply(Jt2.geometryChangedFilter);
    }, Jt2.prototype.geometryChangedAction = function() {
      this._envelope = null;
    }, Jt2.prototype.equalsNorm = function(o4) {
      return o4 !== null && this.norm().equalsExact(o4.norm());
    }, Jt2.prototype.getLength = function() {
      return 0;
    }, Jt2.prototype.getNumGeometries = function() {
      return 1;
    }, Jt2.prototype.compareTo = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = o4;
        return this.getSortIndex() !== s5.getSortIndex() ? this.getSortIndex() - s5.getSortIndex() : this.isEmpty() && s5.isEmpty() ? 0 : this.isEmpty() ? -1 : s5.isEmpty() ? 1 : this.compareToSameClass(o4);
      }
      if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        return this.getSortIndex() !== c.getSortIndex() ? this.getSortIndex() - c.getSortIndex() : this.isEmpty() && c.isEmpty() ? 0 : this.isEmpty() ? -1 : c.isEmpty() ? 1 : this.compareToSameClass(c, f);
      }
    }, Jt2.prototype.getUserData = function() {
      return this._userData;
    }, Jt2.prototype.getSRID = function() {
      return this._SRID;
    }, Jt2.prototype.getEnvelope = function() {
      return this.getFactory().toGeometry(this.getEnvelopeInternal());
    }, Jt2.prototype.checkNotGeometryCollection = function(o4) {
      if (o4.getSortIndex() === Jt2.SORTINDEX_GEOMETRYCOLLECTION) throw new A3("This method does not support GeometryCollection arguments");
    }, Jt2.prototype.equal = function(o4, s5, c) {
      return c === 0 ? o4.equals(s5) : o4.distance(s5) <= c;
    }, Jt2.prototype.norm = function() {
      var o4 = this.copy();
      return o4.normalize(), o4;
    }, Jt2.prototype.getPrecisionModel = function() {
      return this._factory.getPrecisionModel();
    }, Jt2.prototype.getEnvelopeInternal = function() {
      return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new Ct2(this._envelope);
    }, Jt2.prototype.setSRID = function(o4) {
      this._SRID = o4;
    }, Jt2.prototype.setUserData = function(o4) {
      this._userData = o4;
    }, Jt2.prototype.compare = function(o4, s5) {
      for (var c = o4.iterator(), f = s5.iterator(); c.hasNext() && f.hasNext(); ) {
        var g = c.next(), _ = f.next(), M3 = g.compareTo(_);
        if (M3 !== 0) return M3;
      }
      return c.hasNext() ? 1 : f.hasNext() ? -1 : 0;
    }, Jt2.prototype.hashCode = function() {
      return this.getEnvelopeInternal().hashCode();
    }, Jt2.prototype.isGeometryCollectionOrDerived = function() {
      return this.getSortIndex() === Jt2.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Jt2.SORTINDEX_MULTIPOINT || this.getSortIndex() === Jt2.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Jt2.SORTINDEX_MULTIPOLYGON;
    }, Jt2.prototype.interfaces_ = function() {
      return [W4, j3, t];
    }, Jt2.prototype.getClass = function() {
      return Jt2;
    }, Jt2.hasNonEmptyElements = function(o4) {
      for (var s5 = 0; s5 < o4.length; s5++) if (!o4[s5].isEmpty()) return true;
      return false;
    }, Jt2.hasNullElements = function(o4) {
      for (var s5 = 0; s5 < o4.length; s5++) if (o4[s5] === null) return true;
      return false;
    }, ho2.serialVersionUID.get = function() {
      return 8763622679187377e3;
    }, ho2.SORTINDEX_POINT.get = function() {
      return 0;
    }, ho2.SORTINDEX_MULTIPOINT.get = function() {
      return 1;
    }, ho2.SORTINDEX_LINESTRING.get = function() {
      return 2;
    }, ho2.SORTINDEX_LINEARRING.get = function() {
      return 3;
    }, ho2.SORTINDEX_MULTILINESTRING.get = function() {
      return 4;
    }, ho2.SORTINDEX_POLYGON.get = function() {
      return 5;
    }, ho2.SORTINDEX_MULTIPOLYGON.get = function() {
      return 6;
    }, ho2.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
      return 7;
    }, ho2.geometryChangedFilter.get = function() {
      return Pa2;
    }, Object.defineProperties(Jt2, ho2);
    var Pa2 = H$3(function() {
    }, "ht");
    Pa2.interfaces_ = function() {
      return [Zo2];
    }, Pa2.filter = function(o4) {
      o4.geometryChangedAction();
    };
    var Ai2 = H$3(function() {
    }, "ft");
    Ai2.prototype.filter = function(o4) {
    }, Ai2.prototype.interfaces_ = function() {
      return [];
    }, Ai2.prototype.getClass = function() {
      return Ai2;
    };
    var Hn2 = H$3(function() {
    }, "gt"), Ni2 = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
    Hn2.prototype.isInBoundary = function(o4) {
    }, Hn2.prototype.interfaces_ = function() {
      return [];
    }, Hn2.prototype.getClass = function() {
      return Hn2;
    }, Ni2.Mod2BoundaryNodeRule.get = function() {
      return $o2;
    }, Ni2.EndPointBoundaryNodeRule.get = function() {
      return Ea3;
    }, Ni2.MultiValentEndPointBoundaryNodeRule.get = function() {
      return Oa2;
    }, Ni2.MonoValentEndPointBoundaryNodeRule.get = function() {
      return Da2;
    }, Ni2.MOD2_BOUNDARY_RULE.get = function() {
      return new $o2();
    }, Ni2.ENDPOINT_BOUNDARY_RULE.get = function() {
      return new Ea3();
    }, Ni2.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
      return new Oa2();
    }, Ni2.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
      return new Da2();
    }, Ni2.OGC_SFS_BOUNDARY_RULE.get = function() {
      return Hn2.MOD2_BOUNDARY_RULE;
    }, Object.defineProperties(Hn2, Ni2);
    var $o2 = H$3(function() {
    }, "yt");
    $o2.prototype.isInBoundary = function(o4) {
      return o4 % 2 == 1;
    }, $o2.prototype.interfaces_ = function() {
      return [Hn2];
    }, $o2.prototype.getClass = function() {
      return $o2;
    };
    var Ea3 = H$3(function() {
    }, "_t");
    Ea3.prototype.isInBoundary = function(o4) {
      return o4 > 0;
    }, Ea3.prototype.interfaces_ = function() {
      return [Hn2];
    }, Ea3.prototype.getClass = function() {
      return Ea3;
    };
    var Oa2 = H$3(function() {
    }, "mt");
    Oa2.prototype.isInBoundary = function(o4) {
      return o4 > 1;
    }, Oa2.prototype.interfaces_ = function() {
      return [Hn2];
    }, Oa2.prototype.getClass = function() {
      return Oa2;
    };
    var Da2 = H$3(function() {
    }, "vt");
    Da2.prototype.isInBoundary = function(o4) {
      return o4 === 1;
    }, Da2.prototype.interfaces_ = function() {
      return [Hn2];
    }, Da2.prototype.getClass = function() {
      return Da2;
    };
    var Rr2 = H$3(function() {
    }, "It");
    Rr2.prototype.add = function() {
    }, Rr2.prototype.addAll = function() {
    }, Rr2.prototype.isEmpty = function() {
    }, Rr2.prototype.iterator = function() {
    }, Rr2.prototype.size = function() {
    }, Rr2.prototype.toArray = function() {
    }, Rr2.prototype.remove = function() {
    }, (e.prototype = new Error()).name = "IndexOutOfBoundsException";
    var La2 = H$3(function() {
    }, "Et");
    La2.prototype.hasNext = function() {
    }, La2.prototype.next = function() {
    }, La2.prototype.remove = function() {
    };
    var ki2 = (function(o4) {
      function s5() {
        o4.apply(this, arguments);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.get = function() {
      }, s5.prototype.set = function() {
      }, s5.prototype.isEmpty = function() {
      }, s5;
    })(Rr2);
    (n4.prototype = new Error()).name = "NoSuchElementException";
    var Et2 = (function(o4) {
      function s5() {
        o4.call(this), this.array_ = [], arguments[0] instanceof Rr2 && this.addAll(arguments[0]);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.ensureCapacity = function() {
      }, s5.prototype.interfaces_ = function() {
        return [o4, Rr2];
      }, s5.prototype.add = function(c) {
        return arguments.length === 1 ? this.array_.push(c) : this.array_.splice(arguments[0], arguments[1]), true;
      }, s5.prototype.clear = function() {
        this.array_ = [];
      }, s5.prototype.addAll = function(c) {
        for (var f = c.iterator(); f.hasNext(); ) this.add(f.next());
        return true;
      }, s5.prototype.set = function(c, f) {
        var g = this.array_[c];
        return this.array_[c] = f, g;
      }, s5.prototype.iterator = function() {
        return new $m2(this);
      }, s5.prototype.get = function(c) {
        if (c < 0 || c >= this.size()) throw new e();
        return this.array_[c];
      }, s5.prototype.isEmpty = function() {
        return this.array_.length === 0;
      }, s5.prototype.size = function() {
        return this.array_.length;
      }, s5.prototype.toArray = function() {
        for (var c = [], f = 0, g = this.array_.length; f < g; f++) c.push(this.array_[f]);
        return c;
      }, s5.prototype.remove = function(c) {
        for (var f = false, g = 0, _ = this.array_.length; g < _; g++) if (this.array_[g] === c) {
          this.array_.splice(g, 1), f = true;
          break;
        }
        return f;
      }, s5;
    })(ki2), $m2 = (function(o4) {
      function s5(c) {
        o4.call(this), this.arrayList_ = c, this.position_ = 0;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.next = function() {
        if (this.position_ === this.arrayList_.size()) throw new n4();
        return this.arrayList_.get(this.position_++);
      }, s5.prototype.hasNext = function() {
        return this.position_ < this.arrayList_.size();
      }, s5.prototype.set = function(c) {
        return this.arrayList_.set(this.position_ - 1, c);
      }, s5.prototype.remove = function() {
        this.arrayList_.remove(this.arrayList_.get(this.position_));
      }, s5;
    })(La2), et2 = (function(o4) {
      function s5() {
        if (o4.call(this), arguments.length !== 0) {
          if (arguments.length === 1) {
            var f = arguments[0];
            this.ensureCapacity(f.length), this.add(f, true);
          } else if (arguments.length === 2) {
            var g = arguments[0], _ = arguments[1];
            this.ensureCapacity(g.length), this.add(g, _);
          }
        }
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { coordArrayType: { configurable: true } };
      return c.coordArrayType.get = function() {
        return new Array(0).fill(null);
      }, s5.prototype.getCoordinate = function(f) {
        return this.get(f);
      }, s5.prototype.addAll = function() {
        if (arguments.length === 2) {
          for (var f = arguments[0], g = arguments[1], _ = false, M3 = f.iterator(); M3.hasNext(); ) this.add(M3.next(), g), _ = true;
          return _;
        }
        return o4.prototype.addAll.apply(this, arguments);
      }, s5.prototype.clone = function() {
        for (var f = o4.prototype.clone.call(this), g = 0; g < this.size(); g++) f.add(g, this.get(g).copy());
        return f;
      }, s5.prototype.toCoordinateArray = function() {
        return this.toArray(s5.coordArrayType);
      }, s5.prototype.add = function() {
        if (arguments.length === 1) {
          var f = arguments[0];
          o4.prototype.add.call(this, f);
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
            var g = arguments[0], _ = arguments[1];
            return this.add(g, _, true), true;
          }
          if (arguments[0] instanceof F3 && typeof arguments[1] == "boolean") {
            var M3 = arguments[0];
            if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(M3)) return null;
            o4.prototype.add.call(this, M3);
          } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
            var N3 = arguments[0], G3 = arguments[1];
            return this.add(N3, G3), true;
          }
        } else if (arguments.length === 3) {
          if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
            var Z4 = arguments[0], st2 = arguments[1];
            if (arguments[2]) for (var ut2 = 0; ut2 < Z4.length; ut2++) this.add(Z4[ut2], st2);
            else for (var Ot2 = Z4.length - 1; Ot2 >= 0; Ot2--) this.add(Z4[Ot2], st2);
            return true;
          }
          if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof F3) {
            var Dt2 = arguments[0], Bt2 = arguments[1];
            if (!arguments[2]) {
              var Wt2 = this.size();
              if (Wt2 > 0 && (Dt2 > 0 && this.get(Dt2 - 1).equals2D(Bt2) || Dt2 < Wt2 && this.get(Dt2).equals2D(Bt2))) return null;
            }
            o4.prototype.add.call(this, Dt2, Bt2);
          }
        } else if (arguments.length === 4) {
          var Cr2 = arguments[0], vn2 = arguments[1], _i3 = arguments[2], ta2 = arguments[3], Vl2 = 1;
          _i3 > ta2 && (Vl2 = -1);
          for (var J22 = _i3; J22 !== ta2; J22 += Vl2) this.add(Cr2[J22], vn2);
          return true;
        }
      }, s5.prototype.closeRing = function() {
        this.size() > 0 && this.add(new F3(this.get(0)), false);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, Object.defineProperties(s5, c), s5;
    })(Et2), O4 = H$3(function() {
    }, "Lt"), k3 = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
    k3.ForwardComparator.get = function() {
      return z4;
    }, k3.BidirectionalComparator.get = function() {
      return Y3;
    }, k3.coordArrayType.get = function() {
      return new Array(0).fill(null);
    }, O4.prototype.interfaces_ = function() {
      return [];
    }, O4.prototype.getClass = function() {
      return O4;
    }, O4.isRing = function(o4) {
      return !(o4.length < 4) && !!o4[0].equals2D(o4[o4.length - 1]);
    }, O4.ptNotInList = function(o4, s5) {
      for (var c = 0; c < o4.length; c++) {
        var f = o4[c];
        if (O4.indexOf(f, s5) < 0) return f;
      }
      return null;
    }, O4.scroll = function(o4, s5) {
      var c = O4.indexOf(s5, o4);
      if (c < 0) return null;
      var f = new Array(o4.length).fill(null);
      Nt2.arraycopy(o4, c, f, 0, o4.length - c), Nt2.arraycopy(o4, 0, f, o4.length - c, c), Nt2.arraycopy(f, 0, o4, 0, o4.length);
    }, O4.equals = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        if (o4 === s5) return true;
        if (o4 === null || s5 === null || o4.length !== s5.length) return false;
        for (var c = 0; c < o4.length; c++) if (!o4[c].equals(s5[c])) return false;
        return true;
      }
      if (arguments.length === 3) {
        var f = arguments[0], g = arguments[1], _ = arguments[2];
        if (f === g) return true;
        if (f === null || g === null || f.length !== g.length) return false;
        for (var M3 = 0; M3 < f.length; M3++) if (_.compare(f[M3], g[M3]) !== 0) return false;
        return true;
      }
    }, O4.intersection = function(o4, s5) {
      for (var c = new et2(), f = 0; f < o4.length; f++) s5.intersects(o4[f]) && c.add(o4[f], true);
      return c.toCoordinateArray();
    }, O4.hasRepeatedPoints = function(o4) {
      for (var s5 = 1; s5 < o4.length; s5++) if (o4[s5 - 1].equals(o4[s5])) return true;
      return false;
    }, O4.removeRepeatedPoints = function(o4) {
      return O4.hasRepeatedPoints(o4) ? new et2(o4, false).toCoordinateArray() : o4;
    }, O4.reverse = function(o4) {
      for (var s5 = o4.length - 1, c = Math.trunc(s5 / 2), f = 0; f <= c; f++) {
        var g = o4[f];
        o4[f] = o4[s5 - f], o4[s5 - f] = g;
      }
    }, O4.removeNull = function(o4) {
      for (var s5 = 0, c = 0; c < o4.length; c++) o4[c] !== null && s5++;
      var f = new Array(s5).fill(null);
      if (s5 === 0) return f;
      for (var g = 0, _ = 0; _ < o4.length; _++) o4[_] !== null && (f[g++] = o4[_]);
      return f;
    }, O4.copyDeep = function() {
      if (arguments.length === 1) {
        for (var o4 = arguments[0], s5 = new Array(o4.length).fill(null), c = 0; c < o4.length; c++) s5[c] = new F3(o4[c]);
        return s5;
      }
      if (arguments.length === 5) for (var f = arguments[0], g = arguments[1], _ = arguments[2], M3 = arguments[3], N3 = arguments[4], G3 = 0; G3 < N3; G3++) _[M3 + G3] = new F3(f[g + G3]);
    }, O4.isEqualReversed = function(o4, s5) {
      for (var c = 0; c < o4.length; c++) {
        var f = o4[c], g = s5[o4.length - c - 1];
        if (f.compareTo(g) !== 0) return false;
      }
      return true;
    }, O4.envelope = function(o4) {
      for (var s5 = new Ct2(), c = 0; c < o4.length; c++) s5.expandToInclude(o4[c]);
      return s5;
    }, O4.toCoordinateArray = function(o4) {
      return o4.toArray(O4.coordArrayType);
    }, O4.atLeastNCoordinatesOrNothing = function(o4, s5) {
      return s5.length >= o4 ? s5 : [];
    }, O4.indexOf = function(o4, s5) {
      for (var c = 0; c < s5.length; c++) if (o4.equals(s5[c])) return c;
      return -1;
    }, O4.increasingDirection = function(o4) {
      for (var s5 = 0; s5 < Math.trunc(o4.length / 2); s5++) {
        var c = o4.length - 1 - s5, f = o4[s5].compareTo(o4[c]);
        if (f !== 0) return f;
      }
      return 1;
    }, O4.compare = function(o4, s5) {
      for (var c = 0; c < o4.length && c < s5.length; ) {
        var f = o4[c].compareTo(s5[c]);
        if (f !== 0) return f;
        c++;
      }
      return c < s5.length ? -1 : c < o4.length ? 1 : 0;
    }, O4.minCoordinate = function(o4) {
      for (var s5 = null, c = 0; c < o4.length; c++) (s5 === null || s5.compareTo(o4[c]) > 0) && (s5 = o4[c]);
      return s5;
    }, O4.extract = function(o4, s5, c) {
      s5 = ft2.clamp(s5, 0, o4.length);
      var f = (c = ft2.clamp(c, -1, o4.length)) - s5 + 1;
      c < 0 && (f = 0), s5 >= o4.length && (f = 0), c < s5 && (f = 0);
      var g = new Array(f).fill(null);
      if (f === 0) return g;
      for (var _ = 0, M3 = s5; M3 <= c; M3++) g[_++] = o4[M3];
      return g;
    }, Object.defineProperties(O4, k3);
    var z4 = H$3(function() {
    }, "wt");
    z4.prototype.compare = function(o4, s5) {
      return O4.compare(o4, s5);
    }, z4.prototype.interfaces_ = function() {
      return [$5];
    }, z4.prototype.getClass = function() {
      return z4;
    };
    var Y3 = H$3(function() {
    }, "Ot");
    Y3.prototype.compare = function(o4, s5) {
      var c = o4, f = s5;
      if (c.length < f.length) return -1;
      if (c.length > f.length) return 1;
      if (c.length === 0) return 0;
      var g = O4.compare(c, f);
      return O4.isEqualReversed(c, f) ? 0 : g;
    }, Y3.prototype.OLDcompare = function(o4, s5) {
      var c = o4, f = s5;
      if (c.length < f.length) return -1;
      if (c.length > f.length) return 1;
      if (c.length === 0) return 0;
      for (var g = O4.increasingDirection(c), _ = O4.increasingDirection(f), M3 = g > 0 ? 0 : c.length - 1, N3 = _ > 0 ? 0 : c.length - 1, G3 = 0; G3 < c.length; G3++) {
        var Z4 = c[M3].compareTo(f[N3]);
        if (Z4 !== 0) return Z4;
        M3 += g, N3 += _;
      }
      return 0;
    }, Y3.prototype.interfaces_ = function() {
      return [$5];
    }, Y3.prototype.getClass = function() {
      return Y3;
    };
    var X4 = H$3(function() {
    }, "Tt");
    X4.prototype.get = function() {
    }, X4.prototype.put = function() {
    }, X4.prototype.size = function() {
    }, X4.prototype.values = function() {
    }, X4.prototype.entrySet = function() {
    };
    var pt2 = (function(o4) {
      function s5() {
        o4.apply(this, arguments);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5;
    })(X4);
    (i.prototype = new Error()).name = "OperationNotSupported", (a4.prototype = new Rr2()).contains = function() {
    };
    var lt2 = (function(o4) {
      function s5() {
        o4.call(this), this.array_ = [], arguments[0] instanceof Rr2 && this.addAll(arguments[0]);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.contains = function(c) {
        for (var f = 0, g = this.array_.length; f < g; f++) if (this.array_[f] === c) return true;
        return false;
      }, s5.prototype.add = function(c) {
        return !this.contains(c) && (this.array_.push(c), true);
      }, s5.prototype.addAll = function(c) {
        for (var f = c.iterator(); f.hasNext(); ) this.add(f.next());
        return true;
      }, s5.prototype.remove = function(c) {
        throw new Error();
      }, s5.prototype.size = function() {
        return this.array_.length;
      }, s5.prototype.isEmpty = function() {
        return this.array_.length === 0;
      }, s5.prototype.toArray = function() {
        for (var c = [], f = 0, g = this.array_.length; f < g; f++) c.push(this.array_[f]);
        return c;
      }, s5.prototype.iterator = function() {
        return new vt2(this);
      }, s5;
    })(a4), vt2 = (function(o4) {
      function s5(c) {
        o4.call(this), this.hashSet_ = c, this.position_ = 0;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.next = function() {
        if (this.position_ === this.hashSet_.size()) throw new n4();
        return this.hashSet_.array_[this.position_++];
      }, s5.prototype.hasNext = function() {
        return this.position_ < this.hashSet_.size();
      }, s5.prototype.remove = function() {
        throw new i();
      }, s5;
    })(La2), ht2 = 0;
    (x2.prototype = new pt2()).get = function(o4) {
      for (var s5 = this.root_; s5 !== null; ) {
        var c = o4.compareTo(s5.key);
        if (c < 0) s5 = s5.left;
        else {
          if (!(c > 0)) return s5.value;
          s5 = s5.right;
        }
      }
      return null;
    }, x2.prototype.put = function(o4, s5) {
      if (this.root_ === null) return this.root_ = { key: o4, value: s5, left: null, right: null, parent: null, color: ht2, getValue: H$3(function() {
        return this.value;
      }, "getValue"), getKey: H$3(function() {
        return this.key;
      }, "getKey") }, this.size_ = 1, null;
      var c, f, g = this.root_;
      do
        if (c = g, (f = o4.compareTo(g.key)) < 0) g = g.left;
        else {
          if (!(f > 0)) {
            var _ = g.value;
            return g.value = s5, _;
          }
          g = g.right;
        }
      while (g !== null);
      var M3 = { key: o4, left: null, right: null, value: s5, parent: c, color: ht2, getValue: H$3(function() {
        return this.value;
      }, "getValue"), getKey: H$3(function() {
        return this.key;
      }, "getKey") };
      return f < 0 ? c.left = M3 : c.right = M3, this.fixAfterInsertion(M3), this.size_++, null;
    }, x2.prototype.fixAfterInsertion = function(o4) {
      for (o4.color = 1; o4 != null && o4 !== this.root_ && o4.parent.color === 1; ) if (h(o4) === m5(h(h(o4)))) {
        var s5 = v3(h(h(o4)));
        u5(s5) === 1 ? (d(h(o4), ht2), d(s5, ht2), d(h(h(o4)), 1), o4 = h(h(o4))) : (o4 === v3(h(o4)) && (o4 = h(o4), this.rotateLeft(o4)), d(h(o4), ht2), d(h(h(o4)), 1), this.rotateRight(h(h(o4))));
      } else {
        var c = m5(h(h(o4)));
        u5(c) === 1 ? (d(h(o4), ht2), d(c, ht2), d(h(h(o4)), 1), o4 = h(h(o4))) : (o4 === m5(h(o4)) && (o4 = h(o4), this.rotateRight(o4)), d(h(o4), ht2), d(h(h(o4)), 1), this.rotateLeft(h(h(o4))));
      }
      this.root_.color = ht2;
    }, x2.prototype.values = function() {
      var o4 = new Et2(), s5 = this.getFirstEntry();
      if (s5 !== null) for (o4.add(s5.value); (s5 = x2.successor(s5)) !== null; ) o4.add(s5.value);
      return o4;
    }, x2.prototype.entrySet = function() {
      var o4 = new lt2(), s5 = this.getFirstEntry();
      if (s5 !== null) for (o4.add(s5); (s5 = x2.successor(s5)) !== null; ) o4.add(s5);
      return o4;
    }, x2.prototype.rotateLeft = function(o4) {
      if (o4 != null) {
        var s5 = o4.right;
        o4.right = s5.left, s5.left != null && (s5.left.parent = o4), s5.parent = o4.parent, o4.parent === null ? this.root_ = s5 : o4.parent.left === o4 ? o4.parent.left = s5 : o4.parent.right = s5, s5.left = o4, o4.parent = s5;
      }
    }, x2.prototype.rotateRight = function(o4) {
      if (o4 != null) {
        var s5 = o4.left;
        o4.left = s5.right, s5.right != null && (s5.right.parent = o4), s5.parent = o4.parent, o4.parent === null ? this.root_ = s5 : o4.parent.right === o4 ? o4.parent.right = s5 : o4.parent.left = s5, s5.right = o4, o4.parent = s5;
      }
    }, x2.prototype.getFirstEntry = function() {
      var o4 = this.root_;
      if (o4 != null) for (; o4.left != null; ) o4 = o4.left;
      return o4;
    }, x2.successor = function(o4) {
      if (o4 === null) return null;
      if (o4.right !== null) {
        for (var s5 = o4.right; s5.left !== null; ) s5 = s5.left;
        return s5;
      }
      for (var c = o4.parent, f = o4; c !== null && f === c.right; ) f = c, c = c.parent;
      return c;
    }, x2.prototype.size = function() {
      return this.size_;
    };
    var Rt2 = H$3(function() {
    }, "At");
    Rt2.prototype.interfaces_ = function() {
      return [];
    }, Rt2.prototype.getClass = function() {
      return Rt2;
    }, S4.prototype = new a4(), (I3.prototype = new S4()).contains = function(o4) {
      for (var s5 = 0, c = this.array_.length; s5 < c; s5++) if (this.array_[s5].compareTo(o4) === 0) return true;
      return false;
    }, I3.prototype.add = function(o4) {
      if (this.contains(o4)) return false;
      for (var s5 = 0, c = this.array_.length; s5 < c; s5++) if (this.array_[s5].compareTo(o4) === 1) return this.array_.splice(s5, 0, o4), true;
      return this.array_.push(o4), true;
    }, I3.prototype.addAll = function(o4) {
      for (var s5 = o4.iterator(); s5.hasNext(); ) this.add(s5.next());
      return true;
    }, I3.prototype.remove = function(o4) {
      throw new i();
    }, I3.prototype.size = function() {
      return this.array_.length;
    }, I3.prototype.isEmpty = function() {
      return this.array_.length === 0;
    }, I3.prototype.toArray = function() {
      for (var o4 = [], s5 = 0, c = this.array_.length; s5 < c; s5++) o4.push(this.array_[s5]);
      return o4;
    }, I3.prototype.iterator = function() {
      return new at2(this);
    };
    var at2 = H$3(function(o4) {
      this.treeSet_ = o4, this.position_ = 0;
    }, "Ft");
    at2.prototype.next = function() {
      if (this.position_ === this.treeSet_.size()) throw new n4();
      return this.treeSet_.array_[this.position_++];
    }, at2.prototype.hasNext = function() {
      return this.position_ < this.treeSet_.size();
    }, at2.prototype.remove = function() {
      throw new i();
    };
    var bt2 = H$3(function() {
    }, "Gt");
    bt2.sort = function() {
      var o4, s5, c, f, g = arguments[0];
      if (arguments.length === 1) f = H$3(function(M3, N3) {
        return M3.compareTo(N3);
      }, "i"), g.sort(f);
      else if (arguments.length === 2) c = arguments[1], f = H$3(function(M3, N3) {
        return c.compare(M3, N3);
      }, "i"), g.sort(f);
      else if (arguments.length === 3) {
        (s5 = g.slice(arguments[1], arguments[2])).sort();
        var _ = g.slice(0, arguments[1]).concat(s5, g.slice(arguments[2], g.length));
        for (g.splice(0, g.length), o4 = 0; o4 < _.length; o4++) g.push(_[o4]);
      } else if (arguments.length === 4) for (s5 = g.slice(arguments[1], arguments[2]), c = arguments[3], f = H$3(function(M3, N3) {
        return c.compare(M3, N3);
      }, "i"), s5.sort(f), _ = g.slice(0, arguments[1]).concat(s5, g.slice(arguments[2], g.length)), g.splice(0, g.length), o4 = 0; o4 < _.length; o4++) g.push(_[o4]);
    }, bt2.asList = function(o4) {
      for (var s5 = new Et2(), c = 0, f = o4.length; c < f; c++) s5.add(o4[c]);
      return s5;
    };
    var gt2 = H$3(function() {
    }, "qt"), Qt2 = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
    Qt2.P.get = function() {
      return 0;
    }, Qt2.L.get = function() {
      return 1;
    }, Qt2.A.get = function() {
      return 2;
    }, Qt2.FALSE.get = function() {
      return -1;
    }, Qt2.TRUE.get = function() {
      return -2;
    }, Qt2.DONTCARE.get = function() {
      return -3;
    }, Qt2.SYM_FALSE.get = function() {
      return "F";
    }, Qt2.SYM_TRUE.get = function() {
      return "T";
    }, Qt2.SYM_DONTCARE.get = function() {
      return "*";
    }, Qt2.SYM_P.get = function() {
      return "0";
    }, Qt2.SYM_L.get = function() {
      return "1";
    }, Qt2.SYM_A.get = function() {
      return "2";
    }, gt2.prototype.interfaces_ = function() {
      return [];
    }, gt2.prototype.getClass = function() {
      return gt2;
    }, gt2.toDimensionSymbol = function(o4) {
      switch (o4) {
        case gt2.FALSE:
          return gt2.SYM_FALSE;
        case gt2.TRUE:
          return gt2.SYM_TRUE;
        case gt2.DONTCARE:
          return gt2.SYM_DONTCARE;
        case gt2.P:
          return gt2.SYM_P;
        case gt2.L:
          return gt2.SYM_L;
        case gt2.A:
          return gt2.SYM_A;
      }
      throw new A3("Unknown dimension value: " + o4);
    }, gt2.toDimensionValue = function(o4) {
      switch (xt2.toUpperCase(o4)) {
        case gt2.SYM_FALSE:
          return gt2.FALSE;
        case gt2.SYM_TRUE:
          return gt2.TRUE;
        case gt2.SYM_DONTCARE:
          return gt2.DONTCARE;
        case gt2.SYM_P:
          return gt2.P;
        case gt2.SYM_L:
          return gt2.L;
        case gt2.SYM_A:
          return gt2.A;
      }
      throw new A3("Unknown dimension symbol: " + o4);
    }, Object.defineProperties(gt2, Qt2);
    var qt2 = H$3(function() {
    }, "Vt");
    qt2.prototype.filter = function(o4) {
    }, qt2.prototype.interfaces_ = function() {
      return [];
    }, qt2.prototype.getClass = function() {
      return qt2;
    };
    var fe2 = H$3(function() {
    }, "Ut");
    fe2.prototype.filter = function(o4, s5) {
    }, fe2.prototype.isDone = function() {
    }, fe2.prototype.isGeometryChanged = function() {
    }, fe2.prototype.interfaces_ = function() {
      return [];
    }, fe2.prototype.getClass = function() {
      return fe2;
    };
    var te2 = (function(o4) {
      function s5(f, g) {
        if (o4.call(this, g), this._geometries = f || [], o4.hasNullElements(this._geometries)) throw new A3("geometries must not contain null elements");
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { serialVersionUID: { configurable: true } };
      return s5.prototype.computeEnvelopeInternal = function() {
        for (var f = new Ct2(), g = 0; g < this._geometries.length; g++) f.expandToInclude(this._geometries[g].getEnvelopeInternal());
        return f;
      }, s5.prototype.getGeometryN = function(f) {
        return this._geometries[f];
      }, s5.prototype.getSortIndex = function() {
        return o4.SORTINDEX_GEOMETRYCOLLECTION;
      }, s5.prototype.getCoordinates = function() {
        for (var f = new Array(this.getNumPoints()).fill(null), g = -1, _ = 0; _ < this._geometries.length; _++) for (var M3 = this._geometries[_].getCoordinates(), N3 = 0; N3 < M3.length; N3++) f[++g] = M3[N3];
        return f;
      }, s5.prototype.getArea = function() {
        for (var f = 0, g = 0; g < this._geometries.length; g++) f += this._geometries[g].getArea();
        return f;
      }, s5.prototype.equalsExact = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          if (!this.isEquivalentClass(f)) return false;
          var _ = f;
          if (this._geometries.length !== _._geometries.length) return false;
          for (var M3 = 0; M3 < this._geometries.length; M3++) if (!this._geometries[M3].equalsExact(_._geometries[M3], g)) return false;
          return true;
        }
        return o4.prototype.equalsExact.apply(this, arguments);
      }, s5.prototype.normalize = function() {
        for (var f = 0; f < this._geometries.length; f++) this._geometries[f].normalize();
        bt2.sort(this._geometries);
      }, s5.prototype.getCoordinate = function() {
        return this.isEmpty() ? null : this._geometries[0].getCoordinate();
      }, s5.prototype.getBoundaryDimension = function() {
        for (var f = gt2.FALSE, g = 0; g < this._geometries.length; g++) f = Math.max(f, this._geometries[g].getBoundaryDimension());
        return f;
      }, s5.prototype.getDimension = function() {
        for (var f = gt2.FALSE, g = 0; g < this._geometries.length; g++) f = Math.max(f, this._geometries[g].getDimension());
        return f;
      }, s5.prototype.getLength = function() {
        for (var f = 0, g = 0; g < this._geometries.length; g++) f += this._geometries[g].getLength();
        return f;
      }, s5.prototype.getNumPoints = function() {
        for (var f = 0, g = 0; g < this._geometries.length; g++) f += this._geometries[g].getNumPoints();
        return f;
      }, s5.prototype.getNumGeometries = function() {
        return this._geometries.length;
      }, s5.prototype.reverse = function() {
        for (var f = this._geometries.length, g = new Array(f).fill(null), _ = 0; _ < this._geometries.length; _++) g[_] = this._geometries[_].reverse();
        return this.getFactory().createGeometryCollection(g);
      }, s5.prototype.compareToSameClass = function() {
        if (arguments.length === 1) {
          var f = arguments[0], g = new I3(bt2.asList(this._geometries)), _ = new I3(bt2.asList(f._geometries));
          return this.compare(g, _);
        }
        if (arguments.length === 2) {
          for (var M3 = arguments[0], N3 = arguments[1], G3 = M3, Z4 = this.getNumGeometries(), st2 = G3.getNumGeometries(), ut2 = 0; ut2 < Z4 && ut2 < st2; ) {
            var Ot2 = this.getGeometryN(ut2), Dt2 = G3.getGeometryN(ut2), Bt2 = Ot2.compareToSameClass(Dt2, N3);
            if (Bt2 !== 0) return Bt2;
            ut2++;
          }
          return ut2 < Z4 ? 1 : ut2 < st2 ? -1 : 0;
        }
      }, s5.prototype.apply = function() {
        if (ct2(arguments[0], Ai2)) for (var f = arguments[0], g = 0; g < this._geometries.length; g++) this._geometries[g].apply(f);
        else if (ct2(arguments[0], fe2)) {
          var _ = arguments[0];
          if (this._geometries.length === 0) return null;
          for (var M3 = 0; M3 < this._geometries.length && (this._geometries[M3].apply(_), !_.isDone()); M3++) ;
          _.isGeometryChanged() && this.geometryChanged();
        } else if (ct2(arguments[0], qt2)) {
          var N3 = arguments[0];
          N3.filter(this);
          for (var G3 = 0; G3 < this._geometries.length; G3++) this._geometries[G3].apply(N3);
        } else if (ct2(arguments[0], Zo2)) {
          var Z4 = arguments[0];
          Z4.filter(this);
          for (var st2 = 0; st2 < this._geometries.length; st2++) this._geometries[st2].apply(Z4);
        }
      }, s5.prototype.getBoundary = function() {
        return this.checkNotGeometryCollection(this), Yt2.shouldNeverReachHere(), null;
      }, s5.prototype.clone = function() {
        var f = o4.prototype.clone.call(this);
        f._geometries = new Array(this._geometries.length).fill(null);
        for (var g = 0; g < this._geometries.length; g++) f._geometries[g] = this._geometries[g].clone();
        return f;
      }, s5.prototype.getGeometryType = function() {
        return "GeometryCollection";
      }, s5.prototype.copy = function() {
        for (var f = new Array(this._geometries.length).fill(null), g = 0; g < f.length; g++) f[g] = this._geometries[g].copy();
        return new s5(f, this._factory);
      }, s5.prototype.isEmpty = function() {
        for (var f = 0; f < this._geometries.length; f++) if (!this._geometries[f].isEmpty()) return false;
        return true;
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.serialVersionUID.get = function() {
        return -5694727726395021e3;
      }, Object.defineProperties(s5, c), s5;
    })(Jt2), Tr2 = (function(o4) {
      function s5() {
        o4.apply(this, arguments);
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { serialVersionUID: { configurable: true } };
      return s5.prototype.getSortIndex = function() {
        return Jt2.SORTINDEX_MULTILINESTRING;
      }, s5.prototype.equalsExact = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          return !!this.isEquivalentClass(f) && o4.prototype.equalsExact.call(this, f, g);
        }
        return o4.prototype.equalsExact.apply(this, arguments);
      }, s5.prototype.getBoundaryDimension = function() {
        return this.isClosed() ? gt2.FALSE : 0;
      }, s5.prototype.isClosed = function() {
        if (this.isEmpty()) return false;
        for (var f = 0; f < this._geometries.length; f++) if (!this._geometries[f].isClosed()) return false;
        return true;
      }, s5.prototype.getDimension = function() {
        return 1;
      }, s5.prototype.reverse = function() {
        for (var f = this._geometries.length, g = new Array(f).fill(null), _ = 0; _ < this._geometries.length; _++) g[f - 1 - _] = this._geometries[_].reverse();
        return this.getFactory().createMultiLineString(g);
      }, s5.prototype.getBoundary = function() {
        return new Dr2(this).getBoundary();
      }, s5.prototype.getGeometryType = function() {
        return "MultiLineString";
      }, s5.prototype.copy = function() {
        for (var f = new Array(this._geometries.length).fill(null), g = 0; g < f.length; g++) f[g] = this._geometries[g].copy();
        return new s5(f, this._factory);
      }, s5.prototype.interfaces_ = function() {
        return [Rt2];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.serialVersionUID.get = function() {
        return 8166665132445434e3;
      }, Object.defineProperties(s5, c), s5;
    })(te2), Dr2 = H$3(function() {
      if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, arguments.length === 1) {
        var o4 = arguments[0], s5 = Hn2.MOD2_BOUNDARY_RULE;
        this._geom = o4, this._geomFact = o4.getFactory(), this._bnRule = s5;
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        this._geom = c, this._geomFact = c.getFactory(), this._bnRule = f;
      }
    }, "Yt");
    Dr2.prototype.boundaryMultiLineString = function(o4) {
      if (this._geom.isEmpty()) return this.getEmptyMultiPoint();
      var s5 = this.computeBoundaryCoordinates(o4);
      return s5.length === 1 ? this._geomFact.createPoint(s5[0]) : this._geomFact.createMultiPointFromCoords(s5);
    }, Dr2.prototype.getBoundary = function() {
      return this._geom instanceof ye2 ? this.boundaryLineString(this._geom) : this._geom instanceof Tr2 ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
    }, Dr2.prototype.boundaryLineString = function(o4) {
      return this._geom.isEmpty() ? this.getEmptyMultiPoint() : o4.isClosed() ? this._bnRule.isInBoundary(2) ? o4.getStartPoint() : this._geomFact.createMultiPoint() : this._geomFact.createMultiPoint([o4.getStartPoint(), o4.getEndPoint()]);
    }, Dr2.prototype.getEmptyMultiPoint = function() {
      return this._geomFact.createMultiPoint();
    }, Dr2.prototype.computeBoundaryCoordinates = function(o4) {
      var s5 = new Et2();
      this._endpointMap = new x2();
      for (var c = 0; c < o4.getNumGeometries(); c++) {
        var f = o4.getGeometryN(c);
        f.getNumPoints() !== 0 && (this.addEndpoint(f.getCoordinateN(0)), this.addEndpoint(f.getCoordinateN(f.getNumPoints() - 1)));
      }
      for (var g = this._endpointMap.entrySet().iterator(); g.hasNext(); ) {
        var _ = g.next(), M3 = _.getValue().count;
        this._bnRule.isInBoundary(M3) && s5.add(_.getKey());
      }
      return O4.toCoordinateArray(s5);
    }, Dr2.prototype.addEndpoint = function(o4) {
      var s5 = this._endpointMap.get(o4);
      s5 === null && (s5 = new sn2(), this._endpointMap.put(o4, s5)), s5.count++;
    }, Dr2.prototype.interfaces_ = function() {
      return [];
    }, Dr2.prototype.getClass = function() {
      return Dr2;
    }, Dr2.getBoundary = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return new Dr2(o4).getBoundary();
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return new Dr2(s5, c).getBoundary();
      }
    };
    var sn2 = H$3(function() {
      this.count = null;
    }, "kt");
    sn2.prototype.interfaces_ = function() {
      return [];
    }, sn2.prototype.getClass = function() {
      return sn2;
    };
    var Lr2 = H$3(function() {
    }, "jt"), Xn2 = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
    Lr2.prototype.interfaces_ = function() {
      return [];
    }, Lr2.prototype.getClass = function() {
      return Lr2;
    }, Lr2.chars = function(o4, s5) {
      for (var c = new Array(s5).fill(null), f = 0; f < s5; f++) c[f] = o4;
      return String(c);
    }, Lr2.getStackTrace = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = new function() {
        }(), c = new function() {
        }();
        return o4.printStackTrace(c), s5.toString();
      }
      if (arguments.length === 2) {
        for (var f = arguments[0], g = arguments[1], _ = "", M3 = new function() {
        }(new function() {
        }(Lr2.getStackTrace(f))), N3 = 0; N3 < g; N3++) try {
          _ += M3.readLine() + Lr2.NEWLINE;
        } catch (G3) {
          if (!(G3 instanceof w3)) throw G3;
          Yt2.shouldNeverReachHere();
        }
        return _;
      }
    }, Lr2.split = function(o4, s5) {
      for (var c = s5.length, f = new Et2(), g = "" + o4, _ = g.indexOf(s5); _ >= 0; ) {
        var M3 = g.substring(0, _);
        f.add(M3), _ = (g = g.substring(_ + c)).indexOf(s5);
      }
      g.length > 0 && f.add(g);
      for (var N3 = new Array(f.size()).fill(null), G3 = 0; G3 < N3.length; G3++) N3[G3] = f.get(G3);
      return N3;
    }, Lr2.toString = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return Lr2.SIMPLE_ORDINATE_FORMAT.format(o4);
      }
    }, Lr2.spaces = function(o4) {
      return Lr2.chars(" ", o4);
    }, Xn2.NEWLINE.get = function() {
      return Nt2.getProperty("line.separator");
    }, Xn2.SIMPLE_ORDINATE_FORMAT.get = function() {
      return new function() {
      }();
    }, Object.defineProperties(Lr2, Xn2);
    var Te2 = H$3(function() {
    }, "Wt");
    Te2.prototype.interfaces_ = function() {
      return [];
    }, Te2.prototype.getClass = function() {
      return Te2;
    }, Te2.copyCoord = function(o4, s5, c, f) {
      for (var g = Math.min(o4.getDimension(), c.getDimension()), _ = 0; _ < g; _++) c.setOrdinate(f, _, o4.getOrdinate(s5, _));
    }, Te2.isRing = function(o4) {
      var s5 = o4.size();
      return s5 === 0 || !(s5 <= 3) && o4.getOrdinate(0, It2.X) === o4.getOrdinate(s5 - 1, It2.X) && o4.getOrdinate(0, It2.Y) === o4.getOrdinate(s5 - 1, It2.Y);
    }, Te2.isEqual = function(o4, s5) {
      var c = o4.size();
      if (c !== s5.size()) return false;
      for (var f = Math.min(o4.getDimension(), s5.getDimension()), g = 0; g < c; g++) for (var _ = 0; _ < f; _++) {
        var M3 = o4.getOrdinate(g, _), N3 = s5.getOrdinate(g, _);
        if (o4.getOrdinate(g, _) !== s5.getOrdinate(g, _) && (!L3.isNaN(M3) || !L3.isNaN(N3))) return false;
      }
      return true;
    }, Te2.extend = function(o4, s5, c) {
      var f = o4.create(c, s5.getDimension()), g = s5.size();
      if (Te2.copy(s5, 0, f, 0, g), g > 0) for (var _ = g; _ < c; _++) Te2.copy(s5, g - 1, f, _, 1);
      return f;
    }, Te2.reverse = function(o4) {
      for (var s5 = o4.size() - 1, c = Math.trunc(s5 / 2), f = 0; f <= c; f++) Te2.swap(o4, f, s5 - f);
    }, Te2.swap = function(o4, s5, c) {
      if (s5 === c) return null;
      for (var f = 0; f < o4.getDimension(); f++) {
        var g = o4.getOrdinate(s5, f);
        o4.setOrdinate(s5, f, o4.getOrdinate(c, f)), o4.setOrdinate(c, f, g);
      }
    }, Te2.copy = function(o4, s5, c, f, g) {
      for (var _ = 0; _ < g; _++) Te2.copyCoord(o4, s5 + _, c, f + _);
    }, Te2.toString = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = o4.size();
        if (s5 === 0) return "()";
        var c = o4.getDimension(), f = new St2();
        f.append("(");
        for (var g = 0; g < s5; g++) {
          g > 0 && f.append(" ");
          for (var _ = 0; _ < c; _++) _ > 0 && f.append(","), f.append(Lr2.toString(o4.getOrdinate(g, _)));
        }
        return f.append(")"), f.toString();
      }
    }, Te2.ensureValidRing = function(o4, s5) {
      var c = s5.size();
      return c === 0 ? s5 : c <= 3 ? Te2.createClosedRing(o4, s5, 4) : s5.getOrdinate(0, It2.X) === s5.getOrdinate(c - 1, It2.X) && s5.getOrdinate(0, It2.Y) === s5.getOrdinate(c - 1, It2.Y) ? s5 : Te2.createClosedRing(o4, s5, c + 1);
    }, Te2.createClosedRing = function(o4, s5, c) {
      var f = o4.create(c, s5.getDimension()), g = s5.size();
      Te2.copy(s5, 0, f, 0, g);
      for (var _ = g; _ < c; _++) Te2.copy(s5, 0, f, _, 1);
      return f;
    };
    var ye2 = (function(o4) {
      function s5(f, g) {
        o4.call(this, g), this._points = null, this.init(f);
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { serialVersionUID: { configurable: true } };
      return s5.prototype.computeEnvelopeInternal = function() {
        return this.isEmpty() ? new Ct2() : this._points.expandEnvelope(new Ct2());
      }, s5.prototype.isRing = function() {
        return this.isClosed() && this.isSimple();
      }, s5.prototype.getSortIndex = function() {
        return o4.SORTINDEX_LINESTRING;
      }, s5.prototype.getCoordinates = function() {
        return this._points.toCoordinateArray();
      }, s5.prototype.equalsExact = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          if (!this.isEquivalentClass(f)) return false;
          var _ = f;
          if (this._points.size() !== _._points.size()) return false;
          for (var M3 = 0; M3 < this._points.size(); M3++) if (!this.equal(this._points.getCoordinate(M3), _._points.getCoordinate(M3), g)) return false;
          return true;
        }
        return o4.prototype.equalsExact.apply(this, arguments);
      }, s5.prototype.normalize = function() {
        for (var f = 0; f < Math.trunc(this._points.size() / 2); f++) {
          var g = this._points.size() - 1 - f;
          if (!this._points.getCoordinate(f).equals(this._points.getCoordinate(g))) return this._points.getCoordinate(f).compareTo(this._points.getCoordinate(g)) > 0 && Te2.reverse(this._points), null;
        }
      }, s5.prototype.getCoordinate = function() {
        return this.isEmpty() ? null : this._points.getCoordinate(0);
      }, s5.prototype.getBoundaryDimension = function() {
        return this.isClosed() ? gt2.FALSE : 0;
      }, s5.prototype.isClosed = function() {
        return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
      }, s5.prototype.getEndPoint = function() {
        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
      }, s5.prototype.getDimension = function() {
        return 1;
      }, s5.prototype.getLength = function() {
        return wt2.computeLength(this._points);
      }, s5.prototype.getNumPoints = function() {
        return this._points.size();
      }, s5.prototype.reverse = function() {
        var f = this._points.copy();
        return Te2.reverse(f), this.getFactory().createLineString(f);
      }, s5.prototype.compareToSameClass = function() {
        if (arguments.length === 1) {
          for (var f = arguments[0], g = 0, _ = 0; g < this._points.size() && _ < f._points.size(); ) {
            var M3 = this._points.getCoordinate(g).compareTo(f._points.getCoordinate(_));
            if (M3 !== 0) return M3;
            g++, _++;
          }
          return g < this._points.size() ? 1 : _ < f._points.size() ? -1 : 0;
        }
        if (arguments.length === 2) {
          var N3 = arguments[0];
          return arguments[1].compare(this._points, N3._points);
        }
      }, s5.prototype.apply = function() {
        if (ct2(arguments[0], Ai2)) for (var f = arguments[0], g = 0; g < this._points.size(); g++) f.filter(this._points.getCoordinate(g));
        else if (ct2(arguments[0], fe2)) {
          var _ = arguments[0];
          if (this._points.size() === 0) return null;
          for (var M3 = 0; M3 < this._points.size() && (_.filter(this._points, M3), !_.isDone()); M3++) ;
          _.isGeometryChanged() && this.geometryChanged();
        } else ct2(arguments[0], qt2) ? arguments[0].filter(this) : ct2(arguments[0], Zo2) && arguments[0].filter(this);
      }, s5.prototype.getBoundary = function() {
        return new Dr2(this).getBoundary();
      }, s5.prototype.isEquivalentClass = function(f) {
        return f instanceof s5;
      }, s5.prototype.clone = function() {
        var f = o4.prototype.clone.call(this);
        return f._points = this._points.clone(), f;
      }, s5.prototype.getCoordinateN = function(f) {
        return this._points.getCoordinate(f);
      }, s5.prototype.getGeometryType = function() {
        return "LineString";
      }, s5.prototype.copy = function() {
        return new s5(this._points.copy(), this._factory);
      }, s5.prototype.getCoordinateSequence = function() {
        return this._points;
      }, s5.prototype.isEmpty = function() {
        return this._points.size() === 0;
      }, s5.prototype.init = function(f) {
        if (f === null && (f = this.getFactory().getCoordinateSequenceFactory().create([])), f.size() === 1) throw new A3("Invalid number of points in LineString (found " + f.size() + " - must be 0 or >= 2)");
        this._points = f;
      }, s5.prototype.isCoordinate = function(f) {
        for (var g = 0; g < this._points.size(); g++) if (this._points.getCoordinate(g).equals(f)) return true;
        return false;
      }, s5.prototype.getStartPoint = function() {
        return this.isEmpty() ? null : this.getPointN(0);
      }, s5.prototype.getPointN = function(f) {
        return this.getFactory().createPoint(this._points.getCoordinate(f));
      }, s5.prototype.interfaces_ = function() {
        return [Rt2];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.serialVersionUID.get = function() {
        return 3110669828065365500;
      }, Object.defineProperties(s5, c), s5;
    })(Jt2), Ri3 = H$3(function() {
    }, "Jt");
    Ri3.prototype.interfaces_ = function() {
      return [];
    }, Ri3.prototype.getClass = function() {
      return Ri3;
    };
    var Ur2 = (function(o4) {
      function s5(f, g) {
        o4.call(this, g), this._coordinates = f || null, this.init(this._coordinates);
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { serialVersionUID: { configurable: true } };
      return s5.prototype.computeEnvelopeInternal = function() {
        if (this.isEmpty()) return new Ct2();
        var f = new Ct2();
        return f.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), f;
      }, s5.prototype.getSortIndex = function() {
        return o4.SORTINDEX_POINT;
      }, s5.prototype.getCoordinates = function() {
        return this.isEmpty() ? [] : [this.getCoordinate()];
      }, s5.prototype.equalsExact = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          return !!this.isEquivalentClass(f) && (!(!this.isEmpty() || !f.isEmpty()) || this.isEmpty() === f.isEmpty() && this.equal(f.getCoordinate(), this.getCoordinate(), g));
        }
        return o4.prototype.equalsExact.apply(this, arguments);
      }, s5.prototype.normalize = function() {
      }, s5.prototype.getCoordinate = function() {
        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
      }, s5.prototype.getBoundaryDimension = function() {
        return gt2.FALSE;
      }, s5.prototype.getDimension = function() {
        return 0;
      }, s5.prototype.getNumPoints = function() {
        return this.isEmpty() ? 0 : 1;
      }, s5.prototype.reverse = function() {
        return this.copy();
      }, s5.prototype.getX = function() {
        if (this.getCoordinate() === null) throw new Error("getX called on empty Point");
        return this.getCoordinate().x;
      }, s5.prototype.compareToSameClass = function() {
        if (arguments.length === 1) {
          var f = arguments[0];
          return this.getCoordinate().compareTo(f.getCoordinate());
        }
        if (arguments.length === 2) {
          var g = arguments[0];
          return arguments[1].compare(this._coordinates, g._coordinates);
        }
      }, s5.prototype.apply = function() {
        if (ct2(arguments[0], Ai2)) {
          var f = arguments[0];
          if (this.isEmpty()) return null;
          f.filter(this.getCoordinate());
        } else if (ct2(arguments[0], fe2)) {
          var g = arguments[0];
          if (this.isEmpty()) return null;
          g.filter(this._coordinates, 0), g.isGeometryChanged() && this.geometryChanged();
        } else ct2(arguments[0], qt2) ? arguments[0].filter(this) : ct2(arguments[0], Zo2) && arguments[0].filter(this);
      }, s5.prototype.getBoundary = function() {
        return this.getFactory().createGeometryCollection(null);
      }, s5.prototype.clone = function() {
        var f = o4.prototype.clone.call(this);
        return f._coordinates = this._coordinates.clone(), f;
      }, s5.prototype.getGeometryType = function() {
        return "Point";
      }, s5.prototype.copy = function() {
        return new s5(this._coordinates.copy(), this._factory);
      }, s5.prototype.getCoordinateSequence = function() {
        return this._coordinates;
      }, s5.prototype.getY = function() {
        if (this.getCoordinate() === null) throw new Error("getY called on empty Point");
        return this.getCoordinate().y;
      }, s5.prototype.isEmpty = function() {
        return this._coordinates.size() === 0;
      }, s5.prototype.init = function(f) {
        f === null && (f = this.getFactory().getCoordinateSequenceFactory().create([])), Yt2.isTrue(f.size() <= 1), this._coordinates = f;
      }, s5.prototype.isSimple = function() {
        return true;
      }, s5.prototype.interfaces_ = function() {
        return [Ri3];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.serialVersionUID.get = function() {
        return 4902022702746615e3;
      }, Object.defineProperties(s5, c), s5;
    })(Jt2), Nn3 = H$3(function() {
    }, "Zt");
    Nn3.prototype.interfaces_ = function() {
      return [];
    }, Nn3.prototype.getClass = function() {
      return Nn3;
    };
    var xr2 = (function(o4) {
      function s5(f, g, _) {
        if (o4.call(this, _), this._shell = null, this._holes = null, f === null && (f = this.getFactory().createLinearRing()), g === null && (g = []), o4.hasNullElements(g)) throw new A3("holes must not contain null elements");
        if (f.isEmpty() && o4.hasNonEmptyElements(g)) throw new A3("shell is empty but holes are not");
        this._shell = f, this._holes = g;
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { serialVersionUID: { configurable: true } };
      return s5.prototype.computeEnvelopeInternal = function() {
        return this._shell.getEnvelopeInternal();
      }, s5.prototype.getSortIndex = function() {
        return o4.SORTINDEX_POLYGON;
      }, s5.prototype.getCoordinates = function() {
        if (this.isEmpty()) return [];
        for (var f = new Array(this.getNumPoints()).fill(null), g = -1, _ = this._shell.getCoordinates(), M3 = 0; M3 < _.length; M3++) f[++g] = _[M3];
        for (var N3 = 0; N3 < this._holes.length; N3++) for (var G3 = this._holes[N3].getCoordinates(), Z4 = 0; Z4 < G3.length; Z4++) f[++g] = G3[Z4];
        return f;
      }, s5.prototype.getArea = function() {
        var f = 0;
        f += Math.abs(wt2.signedArea(this._shell.getCoordinateSequence()));
        for (var g = 0; g < this._holes.length; g++) f -= Math.abs(wt2.signedArea(this._holes[g].getCoordinateSequence()));
        return f;
      }, s5.prototype.isRectangle = function() {
        if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return false;
        for (var f = this._shell.getCoordinateSequence(), g = this.getEnvelopeInternal(), _ = 0; _ < 5; _++) {
          var M3 = f.getX(_);
          if (M3 !== g.getMinX() && M3 !== g.getMaxX()) return false;
          var N3 = f.getY(_);
          if (N3 !== g.getMinY() && N3 !== g.getMaxY()) return false;
        }
        for (var G3 = f.getX(0), Z4 = f.getY(0), st2 = 1; st2 <= 4; st2++) {
          var ut2 = f.getX(st2), Ot2 = f.getY(st2);
          if (ut2 !== G3 == (Ot2 !== Z4)) return false;
          G3 = ut2, Z4 = Ot2;
        }
        return true;
      }, s5.prototype.equalsExact = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          if (!this.isEquivalentClass(f)) return false;
          var _ = f, M3 = this._shell, N3 = _._shell;
          if (!M3.equalsExact(N3, g) || this._holes.length !== _._holes.length) return false;
          for (var G3 = 0; G3 < this._holes.length; G3++) if (!this._holes[G3].equalsExact(_._holes[G3], g)) return false;
          return true;
        }
        return o4.prototype.equalsExact.apply(this, arguments);
      }, s5.prototype.normalize = function() {
        if (arguments.length === 0) {
          this.normalize(this._shell, true);
          for (var f = 0; f < this._holes.length; f++) this.normalize(this._holes[f], false);
          bt2.sort(this._holes);
        } else if (arguments.length === 2) {
          var g = arguments[0], _ = arguments[1];
          if (g.isEmpty()) return null;
          var M3 = new Array(g.getCoordinates().length - 1).fill(null);
          Nt2.arraycopy(g.getCoordinates(), 0, M3, 0, M3.length);
          var N3 = O4.minCoordinate(g.getCoordinates());
          O4.scroll(M3, N3), Nt2.arraycopy(M3, 0, g.getCoordinates(), 0, M3.length), g.getCoordinates()[M3.length] = M3[0], wt2.isCCW(g.getCoordinates()) === _ && O4.reverse(g.getCoordinates());
        }
      }, s5.prototype.getCoordinate = function() {
        return this._shell.getCoordinate();
      }, s5.prototype.getNumInteriorRing = function() {
        return this._holes.length;
      }, s5.prototype.getBoundaryDimension = function() {
        return 1;
      }, s5.prototype.getDimension = function() {
        return 2;
      }, s5.prototype.getLength = function() {
        var f = 0;
        f += this._shell.getLength();
        for (var g = 0; g < this._holes.length; g++) f += this._holes[g].getLength();
        return f;
      }, s5.prototype.getNumPoints = function() {
        for (var f = this._shell.getNumPoints(), g = 0; g < this._holes.length; g++) f += this._holes[g].getNumPoints();
        return f;
      }, s5.prototype.reverse = function() {
        var f = this.copy();
        f._shell = this._shell.copy().reverse(), f._holes = new Array(this._holes.length).fill(null);
        for (var g = 0; g < this._holes.length; g++) f._holes[g] = this._holes[g].copy().reverse();
        return f;
      }, s5.prototype.convexHull = function() {
        return this.getExteriorRing().convexHull();
      }, s5.prototype.compareToSameClass = function() {
        if (arguments.length === 1) {
          var f = arguments[0], g = this._shell, _ = f._shell;
          return g.compareToSameClass(_);
        }
        if (arguments.length === 2) {
          var M3 = arguments[0], N3 = arguments[1], G3 = M3, Z4 = this._shell, st2 = G3._shell, ut2 = Z4.compareToSameClass(st2, N3);
          if (ut2 !== 0) return ut2;
          for (var Ot2 = this.getNumInteriorRing(), Dt2 = G3.getNumInteriorRing(), Bt2 = 0; Bt2 < Ot2 && Bt2 < Dt2; ) {
            var Wt2 = this.getInteriorRingN(Bt2), Cr2 = G3.getInteriorRingN(Bt2), vn2 = Wt2.compareToSameClass(Cr2, N3);
            if (vn2 !== 0) return vn2;
            Bt2++;
          }
          return Bt2 < Ot2 ? 1 : Bt2 < Dt2 ? -1 : 0;
        }
      }, s5.prototype.apply = function(f) {
        if (ct2(f, Ai2)) {
          this._shell.apply(f);
          for (var g = 0; g < this._holes.length; g++) this._holes[g].apply(f);
        } else if (ct2(f, fe2)) {
          if (this._shell.apply(f), !f.isDone()) for (var _ = 0; _ < this._holes.length && (this._holes[_].apply(f), !f.isDone()); _++) ;
          f.isGeometryChanged() && this.geometryChanged();
        } else if (ct2(f, qt2)) f.filter(this);
        else if (ct2(f, Zo2)) {
          f.filter(this), this._shell.apply(f);
          for (var M3 = 0; M3 < this._holes.length; M3++) this._holes[M3].apply(f);
        }
      }, s5.prototype.getBoundary = function() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        var f = new Array(this._holes.length + 1).fill(null);
        f[0] = this._shell;
        for (var g = 0; g < this._holes.length; g++) f[g + 1] = this._holes[g];
        return f.length <= 1 ? this.getFactory().createLinearRing(f[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(f);
      }, s5.prototype.clone = function() {
        var f = o4.prototype.clone.call(this);
        f._shell = this._shell.clone(), f._holes = new Array(this._holes.length).fill(null);
        for (var g = 0; g < this._holes.length; g++) f._holes[g] = this._holes[g].clone();
        return f;
      }, s5.prototype.getGeometryType = function() {
        return "Polygon";
      }, s5.prototype.copy = function() {
        for (var f = this._shell.copy(), g = new Array(this._holes.length).fill(null), _ = 0; _ < g.length; _++) g[_] = this._holes[_].copy();
        return new s5(f, g, this._factory);
      }, s5.prototype.getExteriorRing = function() {
        return this._shell;
      }, s5.prototype.isEmpty = function() {
        return this._shell.isEmpty();
      }, s5.prototype.getInteriorRingN = function(f) {
        return this._holes[f];
      }, s5.prototype.interfaces_ = function() {
        return [Nn3];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.serialVersionUID.get = function() {
        return -3494792200821764600;
      }, Object.defineProperties(s5, c), s5;
    })(Jt2), Ki2 = (function(o4) {
      function s5() {
        o4.apply(this, arguments);
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { serialVersionUID: { configurable: true } };
      return s5.prototype.getSortIndex = function() {
        return Jt2.SORTINDEX_MULTIPOINT;
      }, s5.prototype.isValid = function() {
        return true;
      }, s5.prototype.equalsExact = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          return !!this.isEquivalentClass(f) && o4.prototype.equalsExact.call(this, f, g);
        }
        return o4.prototype.equalsExact.apply(this, arguments);
      }, s5.prototype.getCoordinate = function() {
        if (arguments.length === 1) {
          var f = arguments[0];
          return this._geometries[f].getCoordinate();
        }
        return o4.prototype.getCoordinate.apply(this, arguments);
      }, s5.prototype.getBoundaryDimension = function() {
        return gt2.FALSE;
      }, s5.prototype.getDimension = function() {
        return 0;
      }, s5.prototype.getBoundary = function() {
        return this.getFactory().createGeometryCollection(null);
      }, s5.prototype.getGeometryType = function() {
        return "MultiPoint";
      }, s5.prototype.copy = function() {
        for (var f = new Array(this._geometries.length).fill(null), g = 0; g < f.length; g++) f[g] = this._geometries[g].copy();
        return new s5(f, this._factory);
      }, s5.prototype.interfaces_ = function() {
        return [Ri3];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.serialVersionUID.get = function() {
        return -8048474874175356e3;
      }, Object.defineProperties(s5, c), s5;
    })(te2), Fi3 = (function(o4) {
      function s5(f, g) {
        f instanceof F3 && g instanceof ge2 && (f = g.getCoordinateSequenceFactory().create(f)), o4.call(this, f, g), this.validateConstruction();
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
      return s5.prototype.getSortIndex = function() {
        return Jt2.SORTINDEX_LINEARRING;
      }, s5.prototype.getBoundaryDimension = function() {
        return gt2.FALSE;
      }, s5.prototype.isClosed = function() {
        return !!this.isEmpty() || o4.prototype.isClosed.call(this);
      }, s5.prototype.reverse = function() {
        var f = this._points.copy();
        return Te2.reverse(f), this.getFactory().createLinearRing(f);
      }, s5.prototype.validateConstruction = function() {
        if (!this.isEmpty() && !o4.prototype.isClosed.call(this)) throw new A3("Points of LinearRing do not form a closed linestring");
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < s5.MINIMUM_VALID_SIZE) throw new A3("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
      }, s5.prototype.getGeometryType = function() {
        return "LinearRing";
      }, s5.prototype.copy = function() {
        return new s5(this._points.copy(), this._factory);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.MINIMUM_VALID_SIZE.get = function() {
        return 4;
      }, c.serialVersionUID.get = function() {
        return -4261142084085851600;
      }, Object.defineProperties(s5, c), s5;
    })(ye2), Jo2 = (function(o4) {
      function s5() {
        o4.apply(this, arguments);
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { serialVersionUID: { configurable: true } };
      return s5.prototype.getSortIndex = function() {
        return Jt2.SORTINDEX_MULTIPOLYGON;
      }, s5.prototype.equalsExact = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          return !!this.isEquivalentClass(f) && o4.prototype.equalsExact.call(this, f, g);
        }
        return o4.prototype.equalsExact.apply(this, arguments);
      }, s5.prototype.getBoundaryDimension = function() {
        return 1;
      }, s5.prototype.getDimension = function() {
        return 2;
      }, s5.prototype.reverse = function() {
        for (var f = this._geometries.length, g = new Array(f).fill(null), _ = 0; _ < this._geometries.length; _++) g[_] = this._geometries[_].reverse();
        return this.getFactory().createMultiPolygon(g);
      }, s5.prototype.getBoundary = function() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        for (var f = new Et2(), g = 0; g < this._geometries.length; g++) for (var _ = this._geometries[g].getBoundary(), M3 = 0; M3 < _.getNumGeometries(); M3++) f.add(_.getGeometryN(M3));
        var N3 = new Array(f.size()).fill(null);
        return this.getFactory().createMultiLineString(f.toArray(N3));
      }, s5.prototype.getGeometryType = function() {
        return "MultiPolygon";
      }, s5.prototype.copy = function() {
        for (var f = new Array(this._geometries.length).fill(null), g = 0; g < f.length; g++) f[g] = this._geometries[g].copy();
        return new s5(f, this._factory);
      }, s5.prototype.interfaces_ = function() {
        return [Nn3];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.serialVersionUID.get = function() {
        return -551033529766975900;
      }, Object.defineProperties(s5, c), s5;
    })(te2), Qi2 = H$3(function(o4) {
      this._factory = o4 || null, this._isUserDataCopied = false;
    }, "ie"), Pf3 = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
    Qi2.prototype.setCopyUserData = function(o4) {
      this._isUserDataCopied = o4;
    }, Qi2.prototype.edit = function(o4, s5) {
      if (o4 === null) return null;
      var c = this.editInternal(o4, s5);
      return this._isUserDataCopied && c.setUserData(o4.getUserData()), c;
    }, Qi2.prototype.editInternal = function(o4, s5) {
      return this._factory === null && (this._factory = o4.getFactory()), o4 instanceof te2 ? this.editGeometryCollection(o4, s5) : o4 instanceof xr2 ? this.editPolygon(o4, s5) : o4 instanceof Ur2 ? s5.edit(o4, this._factory) : o4 instanceof ye2 ? s5.edit(o4, this._factory) : (Yt2.shouldNeverReachHere("Unsupported Geometry class: " + o4.getClass().getName()), null);
    }, Qi2.prototype.editGeometryCollection = function(o4, s5) {
      for (var c = s5.edit(o4, this._factory), f = new Et2(), g = 0; g < c.getNumGeometries(); g++) {
        var _ = this.edit(c.getGeometryN(g), s5);
        _ === null || _.isEmpty() || f.add(_);
      }
      return c.getClass() === Ki2 ? this._factory.createMultiPoint(f.toArray([])) : c.getClass() === Tr2 ? this._factory.createMultiLineString(f.toArray([])) : c.getClass() === Jo2 ? this._factory.createMultiPolygon(f.toArray([])) : this._factory.createGeometryCollection(f.toArray([]));
    }, Qi2.prototype.editPolygon = function(o4, s5) {
      var c = s5.edit(o4, this._factory);
      if (c === null && (c = this._factory.createPolygon(null)), c.isEmpty()) return c;
      var f = this.edit(c.getExteriorRing(), s5);
      if (f === null || f.isEmpty()) return this._factory.createPolygon();
      for (var g = new Et2(), _ = 0; _ < c.getNumInteriorRing(); _++) {
        var M3 = this.edit(c.getInteriorRingN(_), s5);
        M3 === null || M3.isEmpty() || g.add(M3);
      }
      return this._factory.createPolygon(f, g.toArray([]));
    }, Qi2.prototype.interfaces_ = function() {
      return [];
    }, Qi2.prototype.getClass = function() {
      return Qi2;
    }, Qi2.GeometryEditorOperation = function() {
    }, Pf3.NoOpGeometryOperation.get = function() {
      return Jm2;
    }, Pf3.CoordinateOperation.get = function() {
      return Km3;
    }, Pf3.CoordinateSequenceOperation.get = function() {
      return Qm3;
    }, Object.defineProperties(Qi2, Pf3);
    var Jm2 = H$3(function() {
    }, "oe");
    Jm2.prototype.edit = function(o4, s5) {
      return o4;
    }, Jm2.prototype.interfaces_ = function() {
      return [Qi2.GeometryEditorOperation];
    }, Jm2.prototype.getClass = function() {
      return Jm2;
    };
    var Km3 = H$3(function() {
    }, "se");
    Km3.prototype.edit = function(o4, s5) {
      var c = this.editCoordinates(o4.getCoordinates(), o4);
      return c === null ? o4 : o4 instanceof Fi3 ? s5.createLinearRing(c) : o4 instanceof ye2 ? s5.createLineString(c) : o4 instanceof Ur2 ? c.length > 0 ? s5.createPoint(c[0]) : s5.createPoint() : o4;
    }, Km3.prototype.interfaces_ = function() {
      return [Qi2.GeometryEditorOperation];
    }, Km3.prototype.getClass = function() {
      return Km3;
    };
    var Qm3 = H$3(function() {
    }, "ae");
    Qm3.prototype.edit = function(o4, s5) {
      return o4 instanceof Fi3 ? s5.createLinearRing(this.edit(o4.getCoordinateSequence(), o4)) : o4 instanceof ye2 ? s5.createLineString(this.edit(o4.getCoordinateSequence(), o4)) : o4 instanceof Ur2 ? s5.createPoint(this.edit(o4.getCoordinateSequence(), o4)) : o4;
    }, Qm3.prototype.interfaces_ = function() {
      return [Qi2.GeometryEditorOperation];
    }, Qm3.prototype.getClass = function() {
      return Qm3;
    };
    var an2 = H$3(function() {
      if (this._dimension = 3, this._coordinates = null, arguments.length === 1) {
        if (arguments[0] instanceof Array) this._coordinates = arguments[0], this._dimension = 3;
        else if (Number.isInteger(arguments[0])) {
          var o4 = arguments[0];
          this._coordinates = new Array(o4).fill(null);
          for (var s5 = 0; s5 < o4; s5++) this._coordinates[s5] = new F3();
        } else if (ct2(arguments[0], It2)) {
          var c = arguments[0];
          if (c === null) return this._coordinates = new Array(0).fill(null), null;
          this._dimension = c.getDimension(), this._coordinates = new Array(c.size()).fill(null);
          for (var f = 0; f < this._coordinates.length; f++) this._coordinates[f] = c.getCoordinateCopy(f);
        }
      } else if (arguments.length === 2) {
        if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
          var g = arguments[0], _ = arguments[1];
          this._coordinates = g, this._dimension = _, g === null && (this._coordinates = new Array(0).fill(null));
        } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
          var M3 = arguments[0], N3 = arguments[1];
          this._coordinates = new Array(M3).fill(null), this._dimension = N3;
          for (var G3 = 0; G3 < M3; G3++) this._coordinates[G3] = new F3();
        }
      }
    }, "ue"), rw2 = { serialVersionUID: { configurable: true } };
    an2.prototype.setOrdinate = function(o4, s5, c) {
      switch (s5) {
        case It2.X:
          this._coordinates[o4].x = c;
          break;
        case It2.Y:
          this._coordinates[o4].y = c;
          break;
        case It2.Z:
          this._coordinates[o4].z = c;
          break;
        default:
          throw new A3("invalid ordinateIndex");
      }
    }, an2.prototype.size = function() {
      return this._coordinates.length;
    }, an2.prototype.getOrdinate = function(o4, s5) {
      switch (s5) {
        case It2.X:
          return this._coordinates[o4].x;
        case It2.Y:
          return this._coordinates[o4].y;
        case It2.Z:
          return this._coordinates[o4].z;
      }
      return L3.NaN;
    }, an2.prototype.getCoordinate = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return this._coordinates[o4];
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        c.x = this._coordinates[s5].x, c.y = this._coordinates[s5].y, c.z = this._coordinates[s5].z;
      }
    }, an2.prototype.getCoordinateCopy = function(o4) {
      return new F3(this._coordinates[o4]);
    }, an2.prototype.getDimension = function() {
      return this._dimension;
    }, an2.prototype.getX = function(o4) {
      return this._coordinates[o4].x;
    }, an2.prototype.clone = function() {
      for (var o4 = new Array(this.size()).fill(null), s5 = 0; s5 < this._coordinates.length; s5++) o4[s5] = this._coordinates[s5].clone();
      return new an2(o4, this._dimension);
    }, an2.prototype.expandEnvelope = function(o4) {
      for (var s5 = 0; s5 < this._coordinates.length; s5++) o4.expandToInclude(this._coordinates[s5]);
      return o4;
    }, an2.prototype.copy = function() {
      for (var o4 = new Array(this.size()).fill(null), s5 = 0; s5 < this._coordinates.length; s5++) o4[s5] = this._coordinates[s5].copy();
      return new an2(o4, this._dimension);
    }, an2.prototype.toString = function() {
      if (this._coordinates.length > 0) {
        var o4 = new St2(17 * this._coordinates.length);
        o4.append("("), o4.append(this._coordinates[0]);
        for (var s5 = 1; s5 < this._coordinates.length; s5++) o4.append(", "), o4.append(this._coordinates[s5]);
        return o4.append(")"), o4.toString();
      }
      return "()";
    }, an2.prototype.getY = function(o4) {
      return this._coordinates[o4].y;
    }, an2.prototype.toCoordinateArray = function() {
      return this._coordinates;
    }, an2.prototype.interfaces_ = function() {
      return [It2, t];
    }, an2.prototype.getClass = function() {
      return an2;
    }, rw2.serialVersionUID.get = function() {
      return -915438501601840600;
    }, Object.defineProperties(an2, rw2);
    var Xs2 = H$3(function() {
    }, "ce"), B22 = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
    Xs2.prototype.readResolve = function() {
      return Xs2.instance();
    }, Xs2.prototype.create = function() {
      if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var o4 = arguments[0];
          return new an2(o4);
        }
        if (ct2(arguments[0], It2)) {
          var s5 = arguments[0];
          return new an2(s5);
        }
      } else if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        return f > 3 && (f = 3), f < 2 ? new an2(c) : new an2(c, f);
      }
    }, Xs2.prototype.interfaces_ = function() {
      return [K4, t];
    }, Xs2.prototype.getClass = function() {
      return Xs2;
    }, Xs2.instance = function() {
      return Xs2.instanceObject;
    }, B22.serialVersionUID.get = function() {
      return -4099577099607551500;
    }, B22.instanceObject.get = function() {
      return new Xs2();
    }, Object.defineProperties(Xs2, B22);
    var nw2 = (function(o4) {
      function s5() {
        o4.call(this), this.map_ = /* @__PURE__ */ new Map();
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.get = function(c) {
        return this.map_.get(c) || null;
      }, s5.prototype.put = function(c, f) {
        return this.map_.set(c, f), f;
      }, s5.prototype.values = function() {
        for (var c = new Et2(), f = this.map_.values(), g = f.next(); !g.done; ) c.add(g.value), g = f.next();
        return c;
      }, s5.prototype.entrySet = function() {
        var c = new lt2();
        return this.map_.entries().forEach(function(f) {
          return c.add(f);
        }), c;
      }, s5.prototype.size = function() {
        return this.map_.size();
      }, s5;
    })(X4), tr2 = H$3(function o4() {
      if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = o4.FLOATING;
      else if (arguments.length === 1) {
        if (arguments[0] instanceof ds2) {
          var s5 = arguments[0];
          this._modelType = s5, s5 === o4.FIXED && this.setScale(1);
        } else if (typeof arguments[0] == "number") {
          var c = arguments[0];
          this._modelType = o4.FIXED, this.setScale(c);
        } else if (arguments[0] instanceof o4) {
          var f = arguments[0];
          this._modelType = f._modelType, this._scale = f._scale;
        }
      }
    }, "t"), G22 = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
    tr2.prototype.equals = function(o4) {
      if (!(o4 instanceof tr2)) return false;
      var s5 = o4;
      return this._modelType === s5._modelType && this._scale === s5._scale;
    }, tr2.prototype.compareTo = function(o4) {
      var s5 = o4, c = this.getMaximumSignificantDigits(), f = s5.getMaximumSignificantDigits();
      return new dt2(c).compareTo(new dt2(f));
    }, tr2.prototype.getScale = function() {
      return this._scale;
    }, tr2.prototype.isFloating = function() {
      return this._modelType === tr2.FLOATING || this._modelType === tr2.FLOATING_SINGLE;
    }, tr2.prototype.getType = function() {
      return this._modelType;
    }, tr2.prototype.toString = function() {
      var o4 = "UNKNOWN";
      return this._modelType === tr2.FLOATING ? o4 = "Floating" : this._modelType === tr2.FLOATING_SINGLE ? o4 = "Floating-Single" : this._modelType === tr2.FIXED && (o4 = "Fixed (Scale=" + this.getScale() + ")"), o4;
    }, tr2.prototype.makePrecise = function() {
      if (typeof arguments[0] == "number") {
        var o4 = arguments[0];
        return L3.isNaN(o4) || this._modelType === tr2.FLOATING_SINGLE ? o4 : this._modelType === tr2.FIXED ? Math.round(o4 * this._scale) / this._scale : o4;
      }
      if (arguments[0] instanceof F3) {
        var s5 = arguments[0];
        if (this._modelType === tr2.FLOATING) return null;
        s5.x = this.makePrecise(s5.x), s5.y = this.makePrecise(s5.y);
      }
    }, tr2.prototype.getMaximumSignificantDigits = function() {
      var o4 = 16;
      return this._modelType === tr2.FLOATING ? o4 = 16 : this._modelType === tr2.FLOATING_SINGLE ? o4 = 6 : this._modelType === tr2.FIXED && (o4 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), o4;
    }, tr2.prototype.setScale = function(o4) {
      this._scale = Math.abs(o4);
    }, tr2.prototype.interfaces_ = function() {
      return [t, j3];
    }, tr2.prototype.getClass = function() {
      return tr2;
    }, tr2.mostPrecise = function(o4, s5) {
      return o4.compareTo(s5) >= 0 ? o4 : s5;
    }, G22.serialVersionUID.get = function() {
      return 7777263578777804e3;
    }, G22.maximumPreciseValue.get = function() {
      return 9007199254740992;
    }, Object.defineProperties(tr2, G22);
    var ds2 = H$3(function o4(s5) {
      this._name = s5 || null, o4.nameToTypeMap.put(s5, this);
    }, "t"), V22 = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
    ds2.prototype.readResolve = function() {
      return ds2.nameToTypeMap.get(this._name);
    }, ds2.prototype.toString = function() {
      return this._name;
    }, ds2.prototype.interfaces_ = function() {
      return [t];
    }, ds2.prototype.getClass = function() {
      return ds2;
    }, V22.serialVersionUID.get = function() {
      return -552860263173159e4;
    }, V22.nameToTypeMap.get = function() {
      return new nw2();
    }, Object.defineProperties(ds2, V22), tr2.Type = ds2, tr2.FIXED = new ds2("FIXED"), tr2.FLOATING = new ds2("FLOATING"), tr2.FLOATING_SINGLE = new ds2("FLOATING SINGLE");
    var ge2 = H$3(function o4() {
      this._precisionModel = new tr2(), this._SRID = 0, this._coordinateSequenceFactory = o4.getDefaultCoordinateSequenceFactory(), arguments.length === 0 || (arguments.length === 1 ? ct2(arguments[0], K4) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof tr2 && (this._precisionModel = arguments[0]) : arguments.length === 2 ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : arguments.length === 3 && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
    }, "t"), iw2 = { serialVersionUID: { configurable: true } };
    ge2.prototype.toGeometry = function(o4) {
      return o4.isNull() ? this.createPoint(null) : o4.getMinX() === o4.getMaxX() && o4.getMinY() === o4.getMaxY() ? this.createPoint(new F3(o4.getMinX(), o4.getMinY())) : o4.getMinX() === o4.getMaxX() || o4.getMinY() === o4.getMaxY() ? this.createLineString([new F3(o4.getMinX(), o4.getMinY()), new F3(o4.getMaxX(), o4.getMaxY())]) : this.createPolygon(this.createLinearRing([new F3(o4.getMinX(), o4.getMinY()), new F3(o4.getMinX(), o4.getMaxY()), new F3(o4.getMaxX(), o4.getMaxY()), new F3(o4.getMaxX(), o4.getMinY()), new F3(o4.getMinX(), o4.getMinY())]), null);
    }, ge2.prototype.createLineString = function(o4) {
      return o4 ? o4 instanceof Array ? new ye2(this.getCoordinateSequenceFactory().create(o4), this) : ct2(o4, It2) ? new ye2(o4, this) : void 0 : new ye2(this.getCoordinateSequenceFactory().create([]), this);
    }, ge2.prototype.createMultiLineString = function() {
      if (arguments.length === 0) return new Tr2(null, this);
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return new Tr2(o4, this);
      }
    }, ge2.prototype.buildGeometry = function(o4) {
      for (var s5 = null, c = false, f = false, g = o4.iterator(); g.hasNext(); ) {
        var _ = g.next(), M3 = _.getClass();
        s5 === null && (s5 = M3), M3 !== s5 && (c = true), _.isGeometryCollectionOrDerived() && (f = true);
      }
      if (s5 === null) return this.createGeometryCollection();
      if (c || f) return this.createGeometryCollection(ge2.toGeometryArray(o4));
      var N3 = o4.iterator().next();
      if (o4.size() > 1) {
        if (N3 instanceof xr2) return this.createMultiPolygon(ge2.toPolygonArray(o4));
        if (N3 instanceof ye2) return this.createMultiLineString(ge2.toLineStringArray(o4));
        if (N3 instanceof Ur2) return this.createMultiPoint(ge2.toPointArray(o4));
        Yt2.shouldNeverReachHere("Unhandled class: " + N3.getClass().getName());
      }
      return N3;
    }, ge2.prototype.createMultiPointFromCoords = function(o4) {
      return this.createMultiPoint(o4 !== null ? this.getCoordinateSequenceFactory().create(o4) : null);
    }, ge2.prototype.createPoint = function() {
      if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
      if (arguments.length === 1) {
        if (arguments[0] instanceof F3) {
          var o4 = arguments[0];
          return this.createPoint(o4 !== null ? this.getCoordinateSequenceFactory().create([o4]) : null);
        }
        if (ct2(arguments[0], It2)) {
          var s5 = arguments[0];
          return new Ur2(s5, this);
        }
      }
    }, ge2.prototype.getCoordinateSequenceFactory = function() {
      return this._coordinateSequenceFactory;
    }, ge2.prototype.createPolygon = function() {
      if (arguments.length === 0) return new xr2(null, null, this);
      if (arguments.length === 1) {
        if (ct2(arguments[0], It2)) {
          var o4 = arguments[0];
          return this.createPolygon(this.createLinearRing(o4));
        }
        if (arguments[0] instanceof Array) {
          var s5 = arguments[0];
          return this.createPolygon(this.createLinearRing(s5));
        }
        if (arguments[0] instanceof Fi3) {
          var c = arguments[0];
          return this.createPolygon(c, null);
        }
      } else if (arguments.length === 2) {
        var f = arguments[0], g = arguments[1];
        return new xr2(f, g, this);
      }
    }, ge2.prototype.getSRID = function() {
      return this._SRID;
    }, ge2.prototype.createGeometryCollection = function() {
      if (arguments.length === 0) return new te2(null, this);
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return new te2(o4, this);
      }
    }, ge2.prototype.createGeometry = function(o4) {
      return new Qi2(this).edit(o4, { edit: H$3(function() {
        if (arguments.length === 2) {
          var s5 = arguments[0];
          return this._coordinateSequenceFactory.create(s5);
        }
      }, "edit") });
    }, ge2.prototype.getPrecisionModel = function() {
      return this._precisionModel;
    }, ge2.prototype.createLinearRing = function() {
      if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
      if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var o4 = arguments[0];
          return this.createLinearRing(o4 !== null ? this.getCoordinateSequenceFactory().create(o4) : null);
        }
        if (ct2(arguments[0], It2)) {
          var s5 = arguments[0];
          return new Fi3(s5, this);
        }
      }
    }, ge2.prototype.createMultiPolygon = function() {
      if (arguments.length === 0) return new Jo2(null, this);
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return new Jo2(o4, this);
      }
    }, ge2.prototype.createMultiPoint = function() {
      if (arguments.length === 0) return new Ki2(null, this);
      if (arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var o4 = arguments[0];
          return new Ki2(o4, this);
        }
        if (arguments[0] instanceof Array) {
          var s5 = arguments[0];
          return this.createMultiPoint(s5 !== null ? this.getCoordinateSequenceFactory().create(s5) : null);
        }
        if (ct2(arguments[0], It2)) {
          var c = arguments[0];
          if (c === null) return this.createMultiPoint(new Array(0).fill(null));
          for (var f = new Array(c.size()).fill(null), g = 0; g < c.size(); g++) {
            var _ = this.getCoordinateSequenceFactory().create(1, c.getDimension());
            Te2.copy(c, g, _, 0, 1), f[g] = this.createPoint(_);
          }
          return this.createMultiPoint(f);
        }
      }
    }, ge2.prototype.interfaces_ = function() {
      return [t];
    }, ge2.prototype.getClass = function() {
      return ge2;
    }, ge2.toMultiPolygonArray = function(o4) {
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.toGeometryArray = function(o4) {
      if (o4 === null) return null;
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.getDefaultCoordinateSequenceFactory = function() {
      return Xs2.instance();
    }, ge2.toMultiLineStringArray = function(o4) {
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.toLineStringArray = function(o4) {
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.toMultiPointArray = function(o4) {
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.toLinearRingArray = function(o4) {
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.toPointArray = function(o4) {
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.toPolygonArray = function(o4) {
      var s5 = new Array(o4.size()).fill(null);
      return o4.toArray(s5);
    }, ge2.createPointFromInternalCoord = function(o4, s5) {
      return s5.getPrecisionModel().makePrecise(o4), s5.getFactory().createPoint(o4);
    }, iw2.serialVersionUID.get = function() {
      return -6820524753094096e3;
    }, Object.defineProperties(ge2, iw2);
    var ZL2 = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], M02 = H$3(function(o4) {
      this.geometryFactory = o4 || new ge2();
    }, "Ie");
    M02.prototype.read = function(o4) {
      var s5, c = (s5 = typeof o4 == "string" ? JSON.parse(o4) : o4).type;
      if (!ms2[c]) throw new Error("Unknown GeoJSON type: " + s5.type);
      return ZL2.indexOf(c) !== -1 ? ms2[c].apply(this, [s5.coordinates]) : c === "GeometryCollection" ? ms2[c].apply(this, [s5.geometries]) : ms2[c].apply(this, [s5]);
    }, M02.prototype.write = function(o4) {
      var s5 = o4.getGeometryType();
      if (!Aa2[s5]) throw new Error("Geometry is not supported");
      return Aa2[s5].apply(this, [o4]);
    };
    var ms2 = { Feature: H$3(function(o4) {
      var s5 = {};
      for (var c in o4) s5[c] = o4[c];
      if (o4.geometry) {
        var f = o4.geometry.type;
        if (!ms2[f]) throw new Error("Unknown GeoJSON type: " + o4.type);
        s5.geometry = this.read(o4.geometry);
      }
      return o4.bbox && (s5.bbox = ms2.bbox.apply(this, [o4.bbox])), s5;
    }, "Feature"), FeatureCollection: H$3(function(o4) {
      var s5 = {};
      if (o4.features) {
        s5.features = [];
        for (var c = 0; c < o4.features.length; ++c) s5.features.push(this.read(o4.features[c]));
      }
      return o4.bbox && (s5.bbox = this.parse.bbox.apply(this, [o4.bbox])), s5;
    }, "FeatureCollection"), coordinates: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4.length; ++c) {
        var f = o4[c];
        s5.push(new F3(f[0], f[1]));
      }
      return s5;
    }, "coordinates"), bbox: H$3(function(o4) {
      return this.geometryFactory.createLinearRing([new F3(o4[0], o4[1]), new F3(o4[2], o4[1]), new F3(o4[2], o4[3]), new F3(o4[0], o4[3]), new F3(o4[0], o4[1])]);
    }, "bbox"), Point: H$3(function(o4) {
      var s5 = new F3(o4[0], o4[1]);
      return this.geometryFactory.createPoint(s5);
    }, "Point"), MultiPoint: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4.length; ++c) s5.push(ms2.Point.apply(this, [o4[c]]));
      return this.geometryFactory.createMultiPoint(s5);
    }, "MultiPoint"), LineString: H$3(function(o4) {
      var s5 = ms2.coordinates.apply(this, [o4]);
      return this.geometryFactory.createLineString(s5);
    }, "LineString"), MultiLineString: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4.length; ++c) s5.push(ms2.LineString.apply(this, [o4[c]]));
      return this.geometryFactory.createMultiLineString(s5);
    }, "MultiLineString"), Polygon: H$3(function(o4) {
      for (var s5 = ms2.coordinates.apply(this, [o4[0]]), c = this.geometryFactory.createLinearRing(s5), f = [], g = 1; g < o4.length; ++g) {
        var _ = o4[g], M3 = ms2.coordinates.apply(this, [_]), N3 = this.geometryFactory.createLinearRing(M3);
        f.push(N3);
      }
      return this.geometryFactory.createPolygon(c, f);
    }, "Polygon"), MultiPolygon: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4.length; ++c) {
        var f = o4[c];
        s5.push(ms2.Polygon.apply(this, [f]));
      }
      return this.geometryFactory.createMultiPolygon(s5);
    }, "MultiPolygon"), GeometryCollection: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4.length; ++c) {
        var f = o4[c];
        s5.push(this.read(f));
      }
      return this.geometryFactory.createGeometryCollection(s5);
    }, "GeometryCollection") }, Aa2 = { coordinate: H$3(function(o4) {
      return [o4.x, o4.y];
    }, "coordinate"), Point: H$3(function(o4) {
      return { type: "Point", coordinates: Aa2.coordinate.apply(this, [o4.getCoordinate()]) };
    }, "Point"), MultiPoint: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4._geometries.length; ++c) {
        var f = o4._geometries[c], g = Aa2.Point.apply(this, [f]);
        s5.push(g.coordinates);
      }
      return { type: "MultiPoint", coordinates: s5 };
    }, "MultiPoint"), LineString: H$3(function(o4) {
      for (var s5 = [], c = o4.getCoordinates(), f = 0; f < c.length; ++f) {
        var g = c[f];
        s5.push(Aa2.coordinate.apply(this, [g]));
      }
      return { type: "LineString", coordinates: s5 };
    }, "LineString"), MultiLineString: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4._geometries.length; ++c) {
        var f = o4._geometries[c], g = Aa2.LineString.apply(this, [f]);
        s5.push(g.coordinates);
      }
      return { type: "MultiLineString", coordinates: s5 };
    }, "MultiLineString"), Polygon: H$3(function(o4) {
      var s5 = [], c = Aa2.LineString.apply(this, [o4._shell]);
      s5.push(c.coordinates);
      for (var f = 0; f < o4._holes.length; ++f) {
        var g = o4._holes[f], _ = Aa2.LineString.apply(this, [g]);
        s5.push(_.coordinates);
      }
      return { type: "Polygon", coordinates: s5 };
    }, "Polygon"), MultiPolygon: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4._geometries.length; ++c) {
        var f = o4._geometries[c], g = Aa2.Polygon.apply(this, [f]);
        s5.push(g.coordinates);
      }
      return { type: "MultiPolygon", coordinates: s5 };
    }, "MultiPolygon"), GeometryCollection: H$3(function(o4) {
      for (var s5 = [], c = 0; c < o4._geometries.length; ++c) {
        var f = o4._geometries[c], g = f.getGeometryType();
        s5.push(Aa2[g].apply(this, [f]));
      }
      return { type: "GeometryCollection", geometries: s5 };
    }, "GeometryCollection") }, j22 = H$3(function(o4) {
      this.geometryFactory = o4 || new ge2(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new M02(this.geometryFactory);
    }, "Ne");
    j22.prototype.read = function(o4) {
      var s5 = this.parser.read(o4);
      return this.precisionModel.getType() === tr2.FIXED && this.reducePrecision(s5), s5;
    }, j22.prototype.reducePrecision = function(o4) {
      var s5, c;
      if (o4.coordinate) this.precisionModel.makePrecise(o4.coordinate);
      else if (o4.points) for (s5 = 0, c = o4.points.length; s5 < c; s5++) this.precisionModel.makePrecise(o4.points[s5]);
      else if (o4.geometries) for (s5 = 0, c = o4.geometries.length; s5 < c; s5++) this.reducePrecision(o4.geometries[s5]);
    };
    var ow2 = H$3(function() {
      this.parser = new M02(this.geometryFactory);
    }, "Ce");
    ow2.prototype.write = function(o4) {
      return this.parser.write(o4);
    };
    var Tt2 = H$3(function() {
    }, "Se"), T02 = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
    Tt2.prototype.interfaces_ = function() {
      return [];
    }, Tt2.prototype.getClass = function() {
      return Tt2;
    }, Tt2.opposite = function(o4) {
      return o4 === Tt2.LEFT ? Tt2.RIGHT : o4 === Tt2.RIGHT ? Tt2.LEFT : o4;
    }, T02.ON.get = function() {
      return 0;
    }, T02.LEFT.get = function() {
      return 1;
    }, T02.RIGHT.get = function() {
      return 2;
    }, Object.defineProperties(Tt2, T02), (E4.prototype = new Error()).name = "EmptyStackException", (T3.prototype = new ki2()).add = function(o4) {
      return this.array_.push(o4), true;
    }, T3.prototype.get = function(o4) {
      if (o4 < 0 || o4 >= this.size()) throw new Error();
      return this.array_[o4];
    }, T3.prototype.push = function(o4) {
      return this.array_.push(o4), o4;
    }, T3.prototype.pop = function(o4) {
      if (this.array_.length === 0) throw new E4();
      return this.array_.pop();
    }, T3.prototype.peek = function() {
      if (this.array_.length === 0) throw new E4();
      return this.array_[this.array_.length - 1];
    }, T3.prototype.empty = function() {
      return this.array_.length === 0;
    }, T3.prototype.isEmpty = function() {
      return this.empty();
    }, T3.prototype.search = function(o4) {
      return this.array_.indexOf(o4);
    }, T3.prototype.size = function() {
      return this.array_.length;
    }, T3.prototype.toArray = function() {
      for (var o4 = [], s5 = 0, c = this.array_.length; s5 < c; s5++) o4.push(this.array_[s5]);
      return o4;
    };
    var gs2 = H$3(function() {
      this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
    }, "be");
    gs2.prototype.getCoordinate = function() {
      return this._minCoord;
    }, gs2.prototype.getRightmostSide = function(o4, s5) {
      var c = this.getRightmostSideOfSegment(o4, s5);
      return c < 0 && (c = this.getRightmostSideOfSegment(o4, s5 - 1)), c < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(o4)), c;
    }, gs2.prototype.findRightmostEdgeAtVertex = function() {
      var o4 = this._minDe.getEdge().getCoordinates();
      Yt2.isTrue(this._minIndex > 0 && this._minIndex < o4.length, "rightmost point expected to be interior vertex of edge");
      var s5 = o4[this._minIndex - 1], c = o4[this._minIndex + 1], f = wt2.computeOrientation(this._minCoord, c, s5), g = false;
      (s5.y < this._minCoord.y && c.y < this._minCoord.y && f === wt2.COUNTERCLOCKWISE || s5.y > this._minCoord.y && c.y > this._minCoord.y && f === wt2.CLOCKWISE) && (g = true), g && (this._minIndex = this._minIndex - 1);
    }, gs2.prototype.getRightmostSideOfSegment = function(o4, s5) {
      var c = o4.getEdge().getCoordinates();
      if (s5 < 0 || s5 + 1 >= c.length || c[s5].y === c[s5 + 1].y) return -1;
      var f = Tt2.LEFT;
      return c[s5].y < c[s5 + 1].y && (f = Tt2.RIGHT), f;
    }, gs2.prototype.getEdge = function() {
      return this._orientedDe;
    }, gs2.prototype.checkForRightmostCoordinate = function(o4) {
      for (var s5 = o4.getEdge().getCoordinates(), c = 0; c < s5.length - 1; c++) (this._minCoord === null || s5[c].x > this._minCoord.x) && (this._minDe = o4, this._minIndex = c, this._minCoord = s5[c]);
    }, gs2.prototype.findRightmostEdgeAtNode = function() {
      var o4 = this._minDe.getNode().getEdges();
      this._minDe = o4.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
    }, gs2.prototype.findEdge = function(o4) {
      for (var s5 = o4.iterator(); s5.hasNext(); ) {
        var c = s5.next();
        c.isForward() && this.checkForRightmostCoordinate(c);
      }
      Yt2.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === Tt2.LEFT && (this._orientedDe = this._minDe.getSym());
    }, gs2.prototype.interfaces_ = function() {
      return [];
    }, gs2.prototype.getClass = function() {
      return gs2;
    };
    var Na2 = (function(o4) {
      function s5(c, f) {
        o4.call(this, s5.msgWithCoord(c, f)), this.pt = f ? new F3(f) : null, this.name = "TopologyException";
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.getCoordinate = function() {
        return this.pt;
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5.msgWithCoord = function(c, f) {
        return f ? c : c + " [ " + f + " ]";
      }, s5;
    })(Wr2), w02 = H$3(function() {
      this.array_ = [];
    }, "Oe");
    w02.prototype.addLast = function(o4) {
      this.array_.push(o4);
    }, w02.prototype.removeFirst = function() {
      return this.array_.shift();
    }, w02.prototype.isEmpty = function() {
      return this.array_.length === 0;
    };
    var di2 = H$3(function() {
      this._finder = null, this._dirEdgeList = new Et2(), this._nodes = new Et2(), this._rightMostCoord = null, this._env = null, this._finder = new gs2();
    }, "Te");
    di2.prototype.clearVisitedEdges = function() {
      for (var o4 = this._dirEdgeList.iterator(); o4.hasNext(); ) o4.next().setVisited(false);
    }, di2.prototype.getRightmostCoordinate = function() {
      return this._rightMostCoord;
    }, di2.prototype.computeNodeDepth = function(o4) {
      for (var s5 = null, c = o4.getEdges().iterator(); c.hasNext(); ) {
        var f = c.next();
        if (f.isVisited() || f.getSym().isVisited()) {
          s5 = f;
          break;
        }
      }
      if (s5 === null) throw new Na2("unable to find edge to compute depths at " + o4.getCoordinate());
      o4.getEdges().computeDepths(s5);
      for (var g = o4.getEdges().iterator(); g.hasNext(); ) {
        var _ = g.next();
        _.setVisited(true), this.copySymDepths(_);
      }
    }, di2.prototype.computeDepth = function(o4) {
      this.clearVisitedEdges();
      var s5 = this._finder.getEdge();
      s5.setEdgeDepths(Tt2.RIGHT, o4), this.copySymDepths(s5), this.computeDepths(s5);
    }, di2.prototype.create = function(o4) {
      this.addReachable(o4), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
    }, di2.prototype.findResultEdges = function() {
      for (var o4 = this._dirEdgeList.iterator(); o4.hasNext(); ) {
        var s5 = o4.next();
        s5.getDepth(Tt2.RIGHT) >= 1 && s5.getDepth(Tt2.LEFT) <= 0 && !s5.isInteriorAreaEdge() && s5.setInResult(true);
      }
    }, di2.prototype.computeDepths = function(o4) {
      var s5 = new lt2(), c = new w02(), f = o4.getNode();
      for (c.addLast(f), s5.add(f), o4.setVisited(true); !c.isEmpty(); ) {
        var g = c.removeFirst();
        s5.add(g), this.computeNodeDepth(g);
        for (var _ = g.getEdges().iterator(); _.hasNext(); ) {
          var M3 = _.next().getSym();
          if (!M3.isVisited()) {
            var N3 = M3.getNode();
            s5.contains(N3) || (c.addLast(N3), s5.add(N3));
          }
        }
      }
    }, di2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this._rightMostCoord.x < s5._rightMostCoord.x ? -1 : this._rightMostCoord.x > s5._rightMostCoord.x ? 1 : 0;
    }, di2.prototype.getEnvelope = function() {
      if (this._env === null) {
        for (var o4 = new Ct2(), s5 = this._dirEdgeList.iterator(); s5.hasNext(); ) for (var c = s5.next().getEdge().getCoordinates(), f = 0; f < c.length - 1; f++) o4.expandToInclude(c[f]);
        this._env = o4;
      }
      return this._env;
    }, di2.prototype.addReachable = function(o4) {
      var s5 = new T3();
      for (s5.add(o4); !s5.empty(); ) {
        var c = s5.pop();
        this.add(c, s5);
      }
    }, di2.prototype.copySymDepths = function(o4) {
      var s5 = o4.getSym();
      s5.setDepth(Tt2.LEFT, o4.getDepth(Tt2.RIGHT)), s5.setDepth(Tt2.RIGHT, o4.getDepth(Tt2.LEFT));
    }, di2.prototype.add = function(o4, s5) {
      o4.setVisited(true), this._nodes.add(o4);
      for (var c = o4.getEdges().iterator(); c.hasNext(); ) {
        var f = c.next();
        this._dirEdgeList.add(f);
        var g = f.getSym().getNode();
        g.isVisited() || s5.push(g);
      }
    }, di2.prototype.getNodes = function() {
      return this._nodes;
    }, di2.prototype.getDirectedEdges = function() {
      return this._dirEdgeList;
    }, di2.prototype.interfaces_ = function() {
      return [j3];
    }, di2.prototype.getClass = function() {
      return di2;
    };
    var Ar2 = H$3(function o4() {
      if (this.location = null, arguments.length === 1) {
        if (arguments[0] instanceof Array) {
          var s5 = arguments[0];
          this.init(s5.length);
        } else if (Number.isInteger(arguments[0])) {
          var c = arguments[0];
          this.init(1), this.location[Tt2.ON] = c;
        } else if (arguments[0] instanceof o4) {
          var f = arguments[0];
          if (this.init(f.location.length), f !== null) for (var g = 0; g < this.location.length; g++) this.location[g] = f.location[g];
        }
      } else if (arguments.length === 3) {
        var _ = arguments[0], M3 = arguments[1], N3 = arguments[2];
        this.init(3), this.location[Tt2.ON] = _, this.location[Tt2.LEFT] = M3, this.location[Tt2.RIGHT] = N3;
      }
    }, "t");
    Ar2.prototype.setAllLocations = function(o4) {
      for (var s5 = 0; s5 < this.location.length; s5++) this.location[s5] = o4;
    }, Ar2.prototype.isNull = function() {
      for (var o4 = 0; o4 < this.location.length; o4++) if (this.location[o4] !== H5.NONE) return false;
      return true;
    }, Ar2.prototype.setAllLocationsIfNull = function(o4) {
      for (var s5 = 0; s5 < this.location.length; s5++) this.location[s5] === H5.NONE && (this.location[s5] = o4);
    }, Ar2.prototype.isLine = function() {
      return this.location.length === 1;
    }, Ar2.prototype.merge = function(o4) {
      if (o4.location.length > this.location.length) {
        var s5 = new Array(3).fill(null);
        s5[Tt2.ON] = this.location[Tt2.ON], s5[Tt2.LEFT] = H5.NONE, s5[Tt2.RIGHT] = H5.NONE, this.location = s5;
      }
      for (var c = 0; c < this.location.length; c++) this.location[c] === H5.NONE && c < o4.location.length && (this.location[c] = o4.location[c]);
    }, Ar2.prototype.getLocations = function() {
      return this.location;
    }, Ar2.prototype.flip = function() {
      if (this.location.length <= 1) return null;
      var o4 = this.location[Tt2.LEFT];
      this.location[Tt2.LEFT] = this.location[Tt2.RIGHT], this.location[Tt2.RIGHT] = o4;
    }, Ar2.prototype.toString = function() {
      var o4 = new St2();
      return this.location.length > 1 && o4.append(H5.toLocationSymbol(this.location[Tt2.LEFT])), o4.append(H5.toLocationSymbol(this.location[Tt2.ON])), this.location.length > 1 && o4.append(H5.toLocationSymbol(this.location[Tt2.RIGHT])), o4.toString();
    }, Ar2.prototype.setLocations = function(o4, s5, c) {
      this.location[Tt2.ON] = o4, this.location[Tt2.LEFT] = s5, this.location[Tt2.RIGHT] = c;
    }, Ar2.prototype.get = function(o4) {
      return o4 < this.location.length ? this.location[o4] : H5.NONE;
    }, Ar2.prototype.isArea = function() {
      return this.location.length > 1;
    }, Ar2.prototype.isAnyNull = function() {
      for (var o4 = 0; o4 < this.location.length; o4++) if (this.location[o4] === H5.NONE) return true;
      return false;
    }, Ar2.prototype.setLocation = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.setLocation(Tt2.ON, o4);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        this.location[s5] = c;
      }
    }, Ar2.prototype.init = function(o4) {
      this.location = new Array(o4).fill(null), this.setAllLocations(H5.NONE);
    }, Ar2.prototype.isEqualOnSide = function(o4, s5) {
      return this.location[s5] === o4.location[s5];
    }, Ar2.prototype.allPositionsEqual = function(o4) {
      for (var s5 = 0; s5 < this.location.length; s5++) if (this.location[s5] !== o4) return false;
      return true;
    }, Ar2.prototype.interfaces_ = function() {
      return [];
    }, Ar2.prototype.getClass = function() {
      return Ar2;
    };
    var _r2 = H$3(function o4() {
      if (this.elt = new Array(2).fill(null), arguments.length === 1) {
        if (Number.isInteger(arguments[0])) {
          var s5 = arguments[0];
          this.elt[0] = new Ar2(s5), this.elt[1] = new Ar2(s5);
        } else if (arguments[0] instanceof o4) {
          var c = arguments[0];
          this.elt[0] = new Ar2(c.elt[0]), this.elt[1] = new Ar2(c.elt[1]);
        }
      } else if (arguments.length === 2) {
        var f = arguments[0], g = arguments[1];
        this.elt[0] = new Ar2(H5.NONE), this.elt[1] = new Ar2(H5.NONE), this.elt[f].setLocation(g);
      } else if (arguments.length === 3) {
        var _ = arguments[0], M3 = arguments[1], N3 = arguments[2];
        this.elt[0] = new Ar2(_, M3, N3), this.elt[1] = new Ar2(_, M3, N3);
      } else if (arguments.length === 4) {
        var G3 = arguments[0], Z4 = arguments[1], st2 = arguments[2], ut2 = arguments[3];
        this.elt[0] = new Ar2(H5.NONE, H5.NONE, H5.NONE), this.elt[1] = new Ar2(H5.NONE, H5.NONE, H5.NONE), this.elt[G3].setLocations(Z4, st2, ut2);
      }
    }, "t");
    _r2.prototype.getGeometryCount = function() {
      var o4 = 0;
      return this.elt[0].isNull() || o4++, this.elt[1].isNull() || o4++, o4;
    }, _r2.prototype.setAllLocations = function(o4, s5) {
      this.elt[o4].setAllLocations(s5);
    }, _r2.prototype.isNull = function(o4) {
      return this.elt[o4].isNull();
    }, _r2.prototype.setAllLocationsIfNull = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.setAllLocationsIfNull(0, o4), this.setAllLocationsIfNull(1, o4);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        this.elt[s5].setAllLocationsIfNull(c);
      }
    }, _r2.prototype.isLine = function(o4) {
      return this.elt[o4].isLine();
    }, _r2.prototype.merge = function(o4) {
      for (var s5 = 0; s5 < 2; s5++) this.elt[s5] === null && o4.elt[s5] !== null ? this.elt[s5] = new Ar2(o4.elt[s5]) : this.elt[s5].merge(o4.elt[s5]);
    }, _r2.prototype.flip = function() {
      this.elt[0].flip(), this.elt[1].flip();
    }, _r2.prototype.getLocation = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return this.elt[o4].get(Tt2.ON);
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return this.elt[s5].get(c);
      }
    }, _r2.prototype.toString = function() {
      var o4 = new St2();
      return this.elt[0] !== null && (o4.append("A:"), o4.append(this.elt[0].toString())), this.elt[1] !== null && (o4.append(" B:"), o4.append(this.elt[1].toString())), o4.toString();
    }, _r2.prototype.isArea = function() {
      if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return this.elt[o4].isArea();
      }
    }, _r2.prototype.isAnyNull = function(o4) {
      return this.elt[o4].isAnyNull();
    }, _r2.prototype.setLocation = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        this.elt[o4].setLocation(Tt2.ON, s5);
      } else if (arguments.length === 3) {
        var c = arguments[0], f = arguments[1], g = arguments[2];
        this.elt[c].setLocation(f, g);
      }
    }, _r2.prototype.isEqualOnSide = function(o4, s5) {
      return this.elt[0].isEqualOnSide(o4.elt[0], s5) && this.elt[1].isEqualOnSide(o4.elt[1], s5);
    }, _r2.prototype.allPositionsEqual = function(o4, s5) {
      return this.elt[o4].allPositionsEqual(s5);
    }, _r2.prototype.toLine = function(o4) {
      this.elt[o4].isArea() && (this.elt[o4] = new Ar2(this.elt[o4].location[0]));
    }, _r2.prototype.interfaces_ = function() {
      return [];
    }, _r2.prototype.getClass = function() {
      return _r2;
    }, _r2.toLineLabel = function(o4) {
      for (var s5 = new _r2(H5.NONE), c = 0; c < 2; c++) s5.setLocation(c, o4.getLocation(c));
      return s5;
    };
    var mn2 = H$3(function() {
      this._startDe = null, this._maxNodeDegree = -1, this._edges = new Et2(), this._pts = new Et2(), this._label = new _r2(H5.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Et2(), this._geometryFactory = null;
      var o4 = arguments[0], s5 = arguments[1];
      this._geometryFactory = s5, this.computePoints(o4), this.computeRing();
    }, "De");
    mn2.prototype.computeRing = function() {
      if (this._ring !== null) return null;
      for (var o4 = new Array(this._pts.size()).fill(null), s5 = 0; s5 < this._pts.size(); s5++) o4[s5] = this._pts.get(s5);
      this._ring = this._geometryFactory.createLinearRing(o4), this._isHole = wt2.isCCW(this._ring.getCoordinates());
    }, mn2.prototype.isIsolated = function() {
      return this._label.getGeometryCount() === 1;
    }, mn2.prototype.computePoints = function(o4) {
      this._startDe = o4;
      var s5 = o4, c = true;
      do {
        if (s5 === null) throw new Na2("Found null DirectedEdge");
        if (s5.getEdgeRing() === this) throw new Na2("Directed Edge visited twice during ring-building at " + s5.getCoordinate());
        this._edges.add(s5);
        var f = s5.getLabel();
        Yt2.isTrue(f.isArea()), this.mergeLabel(f), this.addPoints(s5.getEdge(), s5.isForward(), c), c = false, this.setEdgeRing(s5, this), s5 = this.getNext(s5);
      } while (s5 !== this._startDe);
    }, mn2.prototype.getLinearRing = function() {
      return this._ring;
    }, mn2.prototype.getCoordinate = function(o4) {
      return this._pts.get(o4);
    }, mn2.prototype.computeMaxNodeDegree = function() {
      this._maxNodeDegree = 0;
      var o4 = this._startDe;
      do {
        var s5 = o4.getNode().getEdges().getOutgoingDegree(this);
        s5 > this._maxNodeDegree && (this._maxNodeDegree = s5), o4 = this.getNext(o4);
      } while (o4 !== this._startDe);
      this._maxNodeDegree *= 2;
    }, mn2.prototype.addPoints = function(o4, s5, c) {
      var f = o4.getCoordinates();
      if (s5) {
        var g = 1;
        c && (g = 0);
        for (var _ = g; _ < f.length; _++) this._pts.add(f[_]);
      } else {
        var M3 = f.length - 2;
        c && (M3 = f.length - 1);
        for (var N3 = M3; N3 >= 0; N3--) this._pts.add(f[N3]);
      }
    }, mn2.prototype.isHole = function() {
      return this._isHole;
    }, mn2.prototype.setInResult = function() {
      var o4 = this._startDe;
      do
        o4.getEdge().setInResult(true), o4 = o4.getNext();
      while (o4 !== this._startDe);
    }, mn2.prototype.containsPoint = function(o4) {
      var s5 = this.getLinearRing();
      if (!s5.getEnvelopeInternal().contains(o4) || !wt2.isPointInRing(o4, s5.getCoordinates())) return false;
      for (var c = this._holes.iterator(); c.hasNext(); ) if (c.next().containsPoint(o4)) return false;
      return true;
    }, mn2.prototype.addHole = function(o4) {
      this._holes.add(o4);
    }, mn2.prototype.isShell = function() {
      return this._shell === null;
    }, mn2.prototype.getLabel = function() {
      return this._label;
    }, mn2.prototype.getEdges = function() {
      return this._edges;
    }, mn2.prototype.getMaxNodeDegree = function() {
      return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
    }, mn2.prototype.getShell = function() {
      return this._shell;
    }, mn2.prototype.mergeLabel = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.mergeLabel(o4, 0), this.mergeLabel(o4, 1);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1], f = s5.getLocation(c, Tt2.RIGHT);
        if (f === H5.NONE) return null;
        if (this._label.getLocation(c) === H5.NONE) return this._label.setLocation(c, f), null;
      }
    }, mn2.prototype.setShell = function(o4) {
      this._shell = o4, o4 !== null && o4.addHole(this);
    }, mn2.prototype.toPolygon = function(o4) {
      for (var s5 = new Array(this._holes.size()).fill(null), c = 0; c < this._holes.size(); c++) s5[c] = this._holes.get(c).getLinearRing();
      return o4.createPolygon(this.getLinearRing(), s5);
    }, mn2.prototype.interfaces_ = function() {
      return [];
    }, mn2.prototype.getClass = function() {
      return mn2;
    };
    var $L2 = (function(o4) {
      function s5() {
        var c = arguments[0], f = arguments[1];
        o4.call(this, c, f);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.setEdgeRing = function(c, f) {
        c.setMinEdgeRing(f);
      }, s5.prototype.getNext = function(c) {
        return c.getNextMin();
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(mn2), JL2 = (function(o4) {
      function s5() {
        var c = arguments[0], f = arguments[1];
        o4.call(this, c, f);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.buildMinimalRings = function() {
        var c = new Et2(), f = this._startDe;
        do {
          if (f.getMinEdgeRing() === null) {
            var g = new $L2(f, this._geometryFactory);
            c.add(g);
          }
          f = f.getNext();
        } while (f !== this._startDe);
        return c;
      }, s5.prototype.setEdgeRing = function(c, f) {
        c.setEdgeRing(f);
      }, s5.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
        var c = this._startDe;
        do
          c.getNode().getEdges().linkMinimalDirectedEdges(this), c = c.getNext();
        while (c !== this._startDe);
      }, s5.prototype.getNext = function(c) {
        return c.getNext();
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(mn2), fo2 = H$3(function() {
      if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, arguments.length !== 0) {
        if (arguments.length === 1) {
          var o4 = arguments[0];
          this._label = o4;
        }
      }
    }, "Fe");
    fo2.prototype.setVisited = function(o4) {
      this._isVisited = o4;
    }, fo2.prototype.setInResult = function(o4) {
      this._isInResult = o4;
    }, fo2.prototype.isCovered = function() {
      return this._isCovered;
    }, fo2.prototype.isCoveredSet = function() {
      return this._isCoveredSet;
    }, fo2.prototype.setLabel = function(o4) {
      this._label = o4;
    }, fo2.prototype.getLabel = function() {
      return this._label;
    }, fo2.prototype.setCovered = function(o4) {
      this._isCovered = o4, this._isCoveredSet = true;
    }, fo2.prototype.updateIM = function(o4) {
      Yt2.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(o4);
    }, fo2.prototype.isInResult = function() {
      return this._isInResult;
    }, fo2.prototype.isVisited = function() {
      return this._isVisited;
    }, fo2.prototype.interfaces_ = function() {
      return [];
    }, fo2.prototype.getClass = function() {
      return fo2;
    };
    var P02 = (function(o4) {
      function s5() {
        o4.call(this), this._coord = null, this._edges = null;
        var c = arguments[0], f = arguments[1];
        this._coord = c, this._edges = f, this._label = new _r2(0, H5.NONE);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.isIncidentEdgeInResult = function() {
        for (var c = this.getEdges().getEdges().iterator(); c.hasNext(); ) if (c.next().getEdge().isInResult()) return true;
        return false;
      }, s5.prototype.isIsolated = function() {
        return this._label.getGeometryCount() === 1;
      }, s5.prototype.getCoordinate = function() {
        return this._coord;
      }, s5.prototype.print = function(c) {
        c.println("node " + this._coord + " lbl: " + this._label);
      }, s5.prototype.computeIM = function(c) {
      }, s5.prototype.computeMergedLocation = function(c, f) {
        var g = H5.NONE;
        if (g = this._label.getLocation(f), !c.isNull(f)) {
          var _ = c.getLocation(f);
          g !== H5.BOUNDARY && (g = _);
        }
        return g;
      }, s5.prototype.setLabel = function() {
        if (arguments.length !== 2) return o4.prototype.setLabel.apply(this, arguments);
        var c = arguments[0], f = arguments[1];
        this._label === null ? this._label = new _r2(c, f) : this._label.setLocation(c, f);
      }, s5.prototype.getEdges = function() {
        return this._edges;
      }, s5.prototype.mergeLabel = function() {
        if (arguments[0] instanceof s5) {
          var c = arguments[0];
          this.mergeLabel(c._label);
        } else if (arguments[0] instanceof _r2) for (var f = arguments[0], g = 0; g < 2; g++) {
          var _ = this.computeMergedLocation(f, g);
          this._label.getLocation(g) === H5.NONE && this._label.setLocation(g, _);
        }
      }, s5.prototype.add = function(c) {
        this._edges.insert(c), c.setNode(this);
      }, s5.prototype.setLabelBoundary = function(c) {
        if (this._label === null) return null;
        var f = H5.NONE;
        this._label !== null && (f = this._label.getLocation(c));
        var g = null;
        switch (f) {
          case H5.BOUNDARY:
            g = H5.INTERIOR;
            break;
          case H5.INTERIOR:
          default:
            g = H5.BOUNDARY;
        }
        this._label.setLocation(c, g);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(fo2), ys2 = H$3(function() {
      this.nodeMap = new x2(), this.nodeFact = null;
      var o4 = arguments[0];
      this.nodeFact = o4;
    }, "qe");
    ys2.prototype.find = function(o4) {
      return this.nodeMap.get(o4);
    }, ys2.prototype.addNode = function() {
      if (arguments[0] instanceof F3) {
        var o4 = arguments[0], s5 = this.nodeMap.get(o4);
        return s5 === null && (s5 = this.nodeFact.createNode(o4), this.nodeMap.put(o4, s5)), s5;
      }
      if (arguments[0] instanceof P02) {
        var c = arguments[0], f = this.nodeMap.get(c.getCoordinate());
        return f === null ? (this.nodeMap.put(c.getCoordinate(), c), c) : (f.mergeLabel(c), f);
      }
    }, ys2.prototype.print = function(o4) {
      for (var s5 = this.iterator(); s5.hasNext(); ) s5.next().print(o4);
    }, ys2.prototype.iterator = function() {
      return this.nodeMap.values().iterator();
    }, ys2.prototype.values = function() {
      return this.nodeMap.values();
    }, ys2.prototype.getBoundaryNodes = function(o4) {
      for (var s5 = new Et2(), c = this.iterator(); c.hasNext(); ) {
        var f = c.next();
        f.getLabel().getLocation(o4) === H5.BOUNDARY && s5.add(f);
      }
      return s5;
    }, ys2.prototype.add = function(o4) {
      var s5 = o4.getCoordinate();
      this.addNode(s5).add(o4);
    }, ys2.prototype.interfaces_ = function() {
      return [];
    }, ys2.prototype.getClass = function() {
      return ys2;
    };
    var wr2 = H$3(function() {
    }, "Be"), tg3 = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
    wr2.prototype.interfaces_ = function() {
      return [];
    }, wr2.prototype.getClass = function() {
      return wr2;
    }, wr2.isNorthern = function(o4) {
      return o4 === wr2.NE || o4 === wr2.NW;
    }, wr2.isOpposite = function(o4, s5) {
      return o4 === s5 ? false : (o4 - s5 + 4) % 4 === 2;
    }, wr2.commonHalfPlane = function(o4, s5) {
      if (o4 === s5) return o4;
      if ((o4 - s5 + 4) % 4 === 2) return -1;
      var c = o4 < s5 ? o4 : s5;
      return c === 0 && (o4 > s5 ? o4 : s5) === 3 ? 3 : c;
    }, wr2.isInHalfPlane = function(o4, s5) {
      return s5 === wr2.SE ? o4 === wr2.SE || o4 === wr2.SW : o4 === s5 || o4 === s5 + 1;
    }, wr2.quadrant = function() {
      if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
        var o4 = arguments[0], s5 = arguments[1];
        if (o4 === 0 && s5 === 0) throw new A3("Cannot compute the quadrant for point ( " + o4 + ", " + s5 + " )");
        return o4 >= 0 ? s5 >= 0 ? wr2.NE : wr2.SE : s5 >= 0 ? wr2.NW : wr2.SW;
      }
      if (arguments[0] instanceof F3 && arguments[1] instanceof F3) {
        var c = arguments[0], f = arguments[1];
        if (f.x === c.x && f.y === c.y) throw new A3("Cannot compute the quadrant for two identical points " + c);
        return f.x >= c.x ? f.y >= c.y ? wr2.NE : wr2.SE : f.y >= c.y ? wr2.NW : wr2.SW;
      }
    }, tg3.NE.get = function() {
      return 0;
    }, tg3.NW.get = function() {
      return 1;
    }, tg3.SW.get = function() {
      return 2;
    }, tg3.SE.get = function() {
      return 3;
    }, Object.defineProperties(wr2, tg3);
    var ri2 = H$3(function() {
      if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
        var o4 = arguments[0];
        this._edge = o4;
      } else if (arguments.length === 3) {
        var s5 = arguments[0], c = arguments[1], f = arguments[2];
        this._edge = s5, this.init(c, f), this._label = null;
      } else if (arguments.length === 4) {
        var g = arguments[0], _ = arguments[1], M3 = arguments[2], N3 = arguments[3];
        this._edge = g, this.init(_, M3), this._label = N3;
      }
    }, "Ue");
    ri2.prototype.compareDirection = function(o4) {
      return this._dx === o4._dx && this._dy === o4._dy ? 0 : this._quadrant > o4._quadrant ? 1 : this._quadrant < o4._quadrant ? -1 : wt2.computeOrientation(o4._p0, o4._p1, this._p1);
    }, ri2.prototype.getDy = function() {
      return this._dy;
    }, ri2.prototype.getCoordinate = function() {
      return this._p0;
    }, ri2.prototype.setNode = function(o4) {
      this._node = o4;
    }, ri2.prototype.print = function(o4) {
      var s5 = Math.atan2(this._dy, this._dx), c = this.getClass().getName(), f = c.lastIndexOf("."), g = c.substring(f + 1);
      o4.print("  " + g + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + s5 + "   " + this._label);
    }, ri2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this.compareDirection(s5);
    }, ri2.prototype.getDirectedCoordinate = function() {
      return this._p1;
    }, ri2.prototype.getDx = function() {
      return this._dx;
    }, ri2.prototype.getLabel = function() {
      return this._label;
    }, ri2.prototype.getEdge = function() {
      return this._edge;
    }, ri2.prototype.getQuadrant = function() {
      return this._quadrant;
    }, ri2.prototype.getNode = function() {
      return this._node;
    }, ri2.prototype.toString = function() {
      var o4 = Math.atan2(this._dy, this._dx), s5 = this.getClass().getName(), c = s5.lastIndexOf(".");
      return "  " + s5.substring(c + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + o4 + "   " + this._label;
    }, ri2.prototype.computeLabel = function(o4) {
    }, ri2.prototype.init = function(o4, s5) {
      this._p0 = o4, this._p1 = s5, this._dx = s5.x - o4.x, this._dy = s5.y - o4.y, this._quadrant = wr2.quadrant(this._dx, this._dy), Yt2.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
    }, ri2.prototype.interfaces_ = function() {
      return [j3];
    }, ri2.prototype.getClass = function() {
      return ri2;
    };
    var U22 = (function(o4) {
      function s5() {
        var c = arguments[0], f = arguments[1];
        if (o4.call(this, c), this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = f, f) this.init(c.getCoordinate(0), c.getCoordinate(1));
        else {
          var g = c.getNumPoints() - 1;
          this.init(c.getCoordinate(g), c.getCoordinate(g - 1));
        }
        this.computeDirectedLabel();
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.getNextMin = function() {
        return this._nextMin;
      }, s5.prototype.getDepth = function(c) {
        return this._depth[c];
      }, s5.prototype.setVisited = function(c) {
        this._isVisited = c;
      }, s5.prototype.computeDirectedLabel = function() {
        this._label = new _r2(this._edge.getLabel()), this._isForward || this._label.flip();
      }, s5.prototype.getNext = function() {
        return this._next;
      }, s5.prototype.setDepth = function(c, f) {
        if (this._depth[c] !== -999 && this._depth[c] !== f) throw new Na2("assigned depths do not match", this.getCoordinate());
        this._depth[c] = f;
      }, s5.prototype.isInteriorAreaEdge = function() {
        for (var c = true, f = 0; f < 2; f++) this._label.isArea(f) && this._label.getLocation(f, Tt2.LEFT) === H5.INTERIOR && this._label.getLocation(f, Tt2.RIGHT) === H5.INTERIOR || (c = false);
        return c;
      }, s5.prototype.setNextMin = function(c) {
        this._nextMin = c;
      }, s5.prototype.print = function(c) {
        o4.prototype.print.call(this, c), c.print(" " + this._depth[Tt2.LEFT] + "/" + this._depth[Tt2.RIGHT]), c.print(" (" + this.getDepthDelta() + ")"), this._isInResult && c.print(" inResult");
      }, s5.prototype.setMinEdgeRing = function(c) {
        this._minEdgeRing = c;
      }, s5.prototype.isLineEdge = function() {
        var c = this._label.isLine(0) || this._label.isLine(1), f = !this._label.isArea(0) || this._label.allPositionsEqual(0, H5.EXTERIOR), g = !this._label.isArea(1) || this._label.allPositionsEqual(1, H5.EXTERIOR);
        return c && f && g;
      }, s5.prototype.setEdgeRing = function(c) {
        this._edgeRing = c;
      }, s5.prototype.getMinEdgeRing = function() {
        return this._minEdgeRing;
      }, s5.prototype.getDepthDelta = function() {
        var c = this._edge.getDepthDelta();
        return this._isForward || (c = -c), c;
      }, s5.prototype.setInResult = function(c) {
        this._isInResult = c;
      }, s5.prototype.getSym = function() {
        return this._sym;
      }, s5.prototype.isForward = function() {
        return this._isForward;
      }, s5.prototype.getEdge = function() {
        return this._edge;
      }, s5.prototype.printEdge = function(c) {
        this.print(c), c.print(" "), this._isForward ? this._edge.print(c) : this._edge.printReverse(c);
      }, s5.prototype.setSym = function(c) {
        this._sym = c;
      }, s5.prototype.setVisitedEdge = function(c) {
        this.setVisited(c), this._sym.setVisited(c);
      }, s5.prototype.setEdgeDepths = function(c, f) {
        var g = this.getEdge().getDepthDelta();
        this._isForward || (g = -g);
        var _ = 1;
        c === Tt2.LEFT && (_ = -1);
        var M3 = Tt2.opposite(c), N3 = f + g * _;
        this.setDepth(c, f), this.setDepth(M3, N3);
      }, s5.prototype.getEdgeRing = function() {
        return this._edgeRing;
      }, s5.prototype.isInResult = function() {
        return this._isInResult;
      }, s5.prototype.setNext = function(c) {
        this._next = c;
      }, s5.prototype.isVisited = function() {
        return this._isVisited;
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5.depthFactor = function(c, f) {
        return c === H5.EXTERIOR && f === H5.INTERIOR ? 1 : c === H5.INTERIOR && f === H5.EXTERIOR ? -1 : 0;
      }, s5;
    })(ri2), Ef3 = H$3(function() {
    }, "Xe");
    Ef3.prototype.createNode = function(o4) {
      return new P02(o4, null);
    }, Ef3.prototype.interfaces_ = function() {
      return [];
    }, Ef3.prototype.getClass = function() {
      return Ef3;
    };
    var Zr2 = H$3(function() {
      if (this._edges = new Et2(), this._nodes = null, this._edgeEndList = new Et2(), arguments.length === 0) this._nodes = new ys2(new Ef3());
      else if (arguments.length === 1) {
        var o4 = arguments[0];
        this._nodes = new ys2(o4);
      }
    }, "Ye");
    Zr2.prototype.printEdges = function(o4) {
      o4.println("Edges:");
      for (var s5 = 0; s5 < this._edges.size(); s5++) {
        o4.println("edge " + s5 + ":");
        var c = this._edges.get(s5);
        c.print(o4), c.eiList.print(o4);
      }
    }, Zr2.prototype.find = function(o4) {
      return this._nodes.find(o4);
    }, Zr2.prototype.addNode = function() {
      if (arguments[0] instanceof P02) {
        var o4 = arguments[0];
        return this._nodes.addNode(o4);
      }
      if (arguments[0] instanceof F3) {
        var s5 = arguments[0];
        return this._nodes.addNode(s5);
      }
    }, Zr2.prototype.getNodeIterator = function() {
      return this._nodes.iterator();
    }, Zr2.prototype.linkResultDirectedEdges = function() {
      for (var o4 = this._nodes.iterator(); o4.hasNext(); ) o4.next().getEdges().linkResultDirectedEdges();
    }, Zr2.prototype.debugPrintln = function(o4) {
      Nt2.out.println(o4);
    }, Zr2.prototype.isBoundaryNode = function(o4, s5) {
      var c = this._nodes.find(s5);
      if (c === null) return false;
      var f = c.getLabel();
      return f !== null && f.getLocation(o4) === H5.BOUNDARY;
    }, Zr2.prototype.linkAllDirectedEdges = function() {
      for (var o4 = this._nodes.iterator(); o4.hasNext(); ) o4.next().getEdges().linkAllDirectedEdges();
    }, Zr2.prototype.matchInSameDirection = function(o4, s5, c, f) {
      return !!o4.equals(c) && wt2.computeOrientation(o4, s5, f) === wt2.COLLINEAR && wr2.quadrant(o4, s5) === wr2.quadrant(c, f);
    }, Zr2.prototype.getEdgeEnds = function() {
      return this._edgeEndList;
    }, Zr2.prototype.debugPrint = function(o4) {
      Nt2.out.print(o4);
    }, Zr2.prototype.getEdgeIterator = function() {
      return this._edges.iterator();
    }, Zr2.prototype.findEdgeInSameDirection = function(o4, s5) {
      for (var c = 0; c < this._edges.size(); c++) {
        var f = this._edges.get(c), g = f.getCoordinates();
        if (this.matchInSameDirection(o4, s5, g[0], g[1]) || this.matchInSameDirection(o4, s5, g[g.length - 1], g[g.length - 2])) return f;
      }
      return null;
    }, Zr2.prototype.insertEdge = function(o4) {
      this._edges.add(o4);
    }, Zr2.prototype.findEdgeEnd = function(o4) {
      for (var s5 = this.getEdgeEnds().iterator(); s5.hasNext(); ) {
        var c = s5.next();
        if (c.getEdge() === o4) return c;
      }
      return null;
    }, Zr2.prototype.addEdges = function(o4) {
      for (var s5 = o4.iterator(); s5.hasNext(); ) {
        var c = s5.next();
        this._edges.add(c);
        var f = new U22(c, true), g = new U22(c, false);
        f.setSym(g), g.setSym(f), this.add(f), this.add(g);
      }
    }, Zr2.prototype.add = function(o4) {
      this._nodes.add(o4), this._edgeEndList.add(o4);
    }, Zr2.prototype.getNodes = function() {
      return this._nodes.values();
    }, Zr2.prototype.findEdge = function(o4, s5) {
      for (var c = 0; c < this._edges.size(); c++) {
        var f = this._edges.get(c), g = f.getCoordinates();
        if (o4.equals(g[0]) && s5.equals(g[1])) return f;
      }
      return null;
    }, Zr2.prototype.interfaces_ = function() {
      return [];
    }, Zr2.prototype.getClass = function() {
      return Zr2;
    }, Zr2.linkResultDirectedEdges = function(o4) {
      for (var s5 = o4.iterator(); s5.hasNext(); ) s5.next().getEdges().linkResultDirectedEdges();
    };
    var to2 = H$3(function() {
      this._geometryFactory = null, this._shellList = new Et2();
      var o4 = arguments[0];
      this._geometryFactory = o4;
    }, "ke");
    to2.prototype.sortShellsAndHoles = function(o4, s5, c) {
      for (var f = o4.iterator(); f.hasNext(); ) {
        var g = f.next();
        g.isHole() ? c.add(g) : s5.add(g);
      }
    }, to2.prototype.computePolygons = function(o4) {
      for (var s5 = new Et2(), c = o4.iterator(); c.hasNext(); ) {
        var f = c.next().toPolygon(this._geometryFactory);
        s5.add(f);
      }
      return s5;
    }, to2.prototype.placeFreeHoles = function(o4, s5) {
      for (var c = s5.iterator(); c.hasNext(); ) {
        var f = c.next();
        if (f.getShell() === null) {
          var g = this.findEdgeRingContaining(f, o4);
          if (g === null) throw new Na2("unable to assign hole to a shell", f.getCoordinate(0));
          f.setShell(g);
        }
      }
    }, to2.prototype.buildMinimalEdgeRings = function(o4, s5, c) {
      for (var f = new Et2(), g = o4.iterator(); g.hasNext(); ) {
        var _ = g.next();
        if (_.getMaxNodeDegree() > 2) {
          _.linkDirectedEdgesForMinimalEdgeRings();
          var M3 = _.buildMinimalRings(), N3 = this.findShell(M3);
          N3 !== null ? (this.placePolygonHoles(N3, M3), s5.add(N3)) : c.addAll(M3);
        } else f.add(_);
      }
      return f;
    }, to2.prototype.containsPoint = function(o4) {
      for (var s5 = this._shellList.iterator(); s5.hasNext(); ) if (s5.next().containsPoint(o4)) return true;
      return false;
    }, to2.prototype.buildMaximalEdgeRings = function(o4) {
      for (var s5 = new Et2(), c = o4.iterator(); c.hasNext(); ) {
        var f = c.next();
        if (f.isInResult() && f.getLabel().isArea() && f.getEdgeRing() === null) {
          var g = new JL2(f, this._geometryFactory);
          s5.add(g), g.setInResult();
        }
      }
      return s5;
    }, to2.prototype.placePolygonHoles = function(o4, s5) {
      for (var c = s5.iterator(); c.hasNext(); ) {
        var f = c.next();
        f.isHole() && f.setShell(o4);
      }
    }, to2.prototype.getPolygons = function() {
      return this.computePolygons(this._shellList);
    }, to2.prototype.findEdgeRingContaining = function(o4, s5) {
      for (var c = o4.getLinearRing(), f = c.getEnvelopeInternal(), g = c.getCoordinateN(0), _ = null, M3 = null, N3 = s5.iterator(); N3.hasNext(); ) {
        var G3 = N3.next(), Z4 = G3.getLinearRing(), st2 = Z4.getEnvelopeInternal();
        _ !== null && (M3 = _.getLinearRing().getEnvelopeInternal());
        var ut2 = false;
        st2.contains(f) && wt2.isPointInRing(g, Z4.getCoordinates()) && (ut2 = true), ut2 && (_ === null || M3.contains(st2)) && (_ = G3);
      }
      return _;
    }, to2.prototype.findShell = function(o4) {
      for (var s5 = 0, c = null, f = o4.iterator(); f.hasNext(); ) {
        var g = f.next();
        g.isHole() || (c = g, s5++);
      }
      return Yt2.isTrue(s5 <= 1, "found two shells in MinimalEdgeRing list"), c;
    }, to2.prototype.add = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.add(o4.getEdgeEnds(), o4.getNodes());
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        Zr2.linkResultDirectedEdges(c);
        var f = this.buildMaximalEdgeRings(s5), g = new Et2(), _ = this.buildMinimalEdgeRings(f, this._shellList, g);
        this.sortShellsAndHoles(_, this._shellList, g), this.placeFreeHoles(this._shellList, g);
      }
    }, to2.prototype.interfaces_ = function() {
      return [];
    }, to2.prototype.getClass = function() {
      return to2;
    };
    var Of3 = H$3(function() {
    }, "je");
    Of3.prototype.getBounds = function() {
    }, Of3.prototype.interfaces_ = function() {
      return [];
    }, Of3.prototype.getClass = function() {
      return Of3;
    };
    var Ko2 = H$3(function() {
      this._bounds = null, this._item = null;
      var o4 = arguments[0], s5 = arguments[1];
      this._bounds = o4, this._item = s5;
    }, "He");
    Ko2.prototype.getItem = function() {
      return this._item;
    }, Ko2.prototype.getBounds = function() {
      return this._bounds;
    }, Ko2.prototype.interfaces_ = function() {
      return [Of3, t];
    }, Ko2.prototype.getClass = function() {
      return Ko2;
    };
    var ka2 = H$3(function() {
      this._size = null, this._items = null, this._size = 0, this._items = new Et2(), this._items.add(null);
    }, "We");
    ka2.prototype.poll = function() {
      if (this.isEmpty()) return null;
      var o4 = this._items.get(1);
      return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), o4;
    }, ka2.prototype.size = function() {
      return this._size;
    }, ka2.prototype.reorder = function(o4) {
      for (var s5 = null, c = this._items.get(o4); 2 * o4 <= this._size && ((s5 = 2 * o4) !== this._size && this._items.get(s5 + 1).compareTo(this._items.get(s5)) < 0 && s5++, this._items.get(s5).compareTo(c) < 0); o4 = s5) this._items.set(o4, this._items.get(s5));
      this._items.set(o4, c);
    }, ka2.prototype.clear = function() {
      this._size = 0, this._items.clear();
    }, ka2.prototype.isEmpty = function() {
      return this._size === 0;
    }, ka2.prototype.add = function(o4) {
      this._items.add(null), this._size += 1;
      var s5 = this._size;
      for (this._items.set(0, o4); o4.compareTo(this._items.get(Math.trunc(s5 / 2))) < 0; s5 /= 2) this._items.set(s5, this._items.get(Math.trunc(s5 / 2)));
      this._items.set(s5, o4);
    }, ka2.prototype.interfaces_ = function() {
      return [];
    }, ka2.prototype.getClass = function() {
      return ka2;
    };
    var Ol2 = H$3(function() {
    }, "Ke");
    Ol2.prototype.visitItem = function(o4) {
    }, Ol2.prototype.interfaces_ = function() {
      return [];
    }, Ol2.prototype.getClass = function() {
      return Ol2;
    };
    var rp2 = H$3(function() {
    }, "Je");
    rp2.prototype.insert = function(o4, s5) {
    }, rp2.prototype.remove = function(o4, s5) {
    }, rp2.prototype.query = function() {
    }, rp2.prototype.interfaces_ = function() {
      return [];
    }, rp2.prototype.getClass = function() {
      return rp2;
    };
    var Sn2 = H$3(function() {
      if (this._childBoundables = new Et2(), this._bounds = null, this._level = null, arguments.length !== 0) {
        if (arguments.length === 1) {
          var o4 = arguments[0];
          this._level = o4;
        }
      }
    }, "Qe"), sw2 = { serialVersionUID: { configurable: true } };
    Sn2.prototype.getLevel = function() {
      return this._level;
    }, Sn2.prototype.size = function() {
      return this._childBoundables.size();
    }, Sn2.prototype.getChildBoundables = function() {
      return this._childBoundables;
    }, Sn2.prototype.addChildBoundable = function(o4) {
      Yt2.isTrue(this._bounds === null), this._childBoundables.add(o4);
    }, Sn2.prototype.isEmpty = function() {
      return this._childBoundables.isEmpty();
    }, Sn2.prototype.getBounds = function() {
      return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
    }, Sn2.prototype.interfaces_ = function() {
      return [Of3, t];
    }, Sn2.prototype.getClass = function() {
      return Sn2;
    }, sw2.serialVersionUID.get = function() {
      return 6493722185909574e3;
    }, Object.defineProperties(Sn2, sw2);
    var Qo2 = H$3(function() {
    }, "$e");
    Qo2.reverseOrder = function() {
      return { compare: H$3(function(o4, s5) {
        return s5.compareTo(o4);
      }, "compare") };
    }, Qo2.min = function(o4) {
      return Qo2.sort(o4), o4.get(0);
    }, Qo2.sort = function(o4, s5) {
      var c = o4.toArray();
      s5 ? bt2.sort(c, s5) : bt2.sort(c);
      for (var f = o4.iterator(), g = 0, _ = c.length; g < _; g++) f.next(), f.set(c[g]);
    }, Qo2.singletonList = function(o4) {
      var s5 = new Et2();
      return s5.add(o4), s5;
    };
    var gn2 = H$3(function() {
      this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
      this._boundable1 = o4, this._boundable2 = s5, this._itemDistance = c, this._distance = this.distance();
    }, "tn");
    gn2.prototype.expandToQueue = function(o4, s5) {
      var c = gn2.isComposite(this._boundable1), f = gn2.isComposite(this._boundable2);
      if (c && f) return gn2.area(this._boundable1) > gn2.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, o4, s5), null) : (this.expand(this._boundable2, this._boundable1, o4, s5), null);
      if (c) return this.expand(this._boundable1, this._boundable2, o4, s5), null;
      if (f) return this.expand(this._boundable2, this._boundable1, o4, s5), null;
      throw new A3("neither boundable is composite");
    }, gn2.prototype.isLeaves = function() {
      return !(gn2.isComposite(this._boundable1) || gn2.isComposite(this._boundable2));
    }, gn2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this._distance < s5._distance ? -1 : this._distance > s5._distance ? 1 : 0;
    }, gn2.prototype.expand = function(o4, s5, c, f) {
      for (var g = o4.getChildBoundables().iterator(); g.hasNext(); ) {
        var _ = g.next(), M3 = new gn2(_, s5, this._itemDistance);
        M3.getDistance() < f && c.add(M3);
      }
    }, gn2.prototype.getBoundable = function(o4) {
      return o4 === 0 ? this._boundable1 : this._boundable2;
    }, gn2.prototype.getDistance = function() {
      return this._distance;
    }, gn2.prototype.distance = function() {
      return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
    }, gn2.prototype.interfaces_ = function() {
      return [j3];
    }, gn2.prototype.getClass = function() {
      return gn2;
    }, gn2.area = function(o4) {
      return o4.getBounds().getArea();
    }, gn2.isComposite = function(o4) {
      return o4 instanceof Sn2;
    };
    var kn2 = H$3(function o4() {
      if (this._root = null, this._built = false, this._itemBoundables = new Et2(), this._nodeCapacity = null, arguments.length === 0) {
        var s5 = o4.DEFAULT_NODE_CAPACITY;
        this._nodeCapacity = s5;
      } else if (arguments.length === 1) {
        var c = arguments[0];
        Yt2.isTrue(c > 1, "Node capacity must be greater than 1"), this._nodeCapacity = c;
      }
    }, "t"), E02 = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
    kn2.prototype.getNodeCapacity = function() {
      return this._nodeCapacity;
    }, kn2.prototype.lastNode = function(o4) {
      return o4.get(o4.size() - 1);
    }, kn2.prototype.size = function() {
      if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
      if (arguments.length === 1) {
        for (var o4 = 0, s5 = arguments[0].getChildBoundables().iterator(); s5.hasNext(); ) {
          var c = s5.next();
          c instanceof Sn2 ? o4 += this.size(c) : c instanceof Ko2 && (o4 += 1);
        }
        return o4;
      }
    }, kn2.prototype.removeItem = function(o4, s5) {
      for (var c = null, f = o4.getChildBoundables().iterator(); f.hasNext(); ) {
        var g = f.next();
        g instanceof Ko2 && g.getItem() === s5 && (c = g);
      }
      return c !== null && (o4.getChildBoundables().remove(c), true);
    }, kn2.prototype.itemsTree = function() {
      if (arguments.length === 0) {
        this.build();
        var o4 = this.itemsTree(this._root);
        return o4 === null ? new Et2() : o4;
      }
      if (arguments.length === 1) {
        for (var s5 = arguments[0], c = new Et2(), f = s5.getChildBoundables().iterator(); f.hasNext(); ) {
          var g = f.next();
          if (g instanceof Sn2) {
            var _ = this.itemsTree(g);
            _ !== null && c.add(_);
          } else g instanceof Ko2 ? c.add(g.getItem()) : Yt2.shouldNeverReachHere();
        }
        return c.size() <= 0 ? null : c;
      }
    }, kn2.prototype.insert = function(o4, s5) {
      Yt2.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new Ko2(o4, s5));
    }, kn2.prototype.boundablesAtLevel = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = new Et2();
        return this.boundablesAtLevel(o4, this._root, s5), s5;
      }
      if (arguments.length === 3) {
        var c = arguments[0], f = arguments[1], g = arguments[2];
        if (Yt2.isTrue(c > -2), f.getLevel() === c) return g.add(f), null;
        for (var _ = f.getChildBoundables().iterator(); _.hasNext(); ) {
          var M3 = _.next();
          M3 instanceof Sn2 ? this.boundablesAtLevel(c, M3, g) : (Yt2.isTrue(M3 instanceof Ko2), c === -1 && g.add(M3));
        }
        return null;
      }
    }, kn2.prototype.query = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.build();
        var s5 = new Et2();
        return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), o4) && this.query(o4, this._root, s5), s5;
      }
      if (arguments.length === 2) {
        var c = arguments[0], f = arguments[1];
        if (this.build(), this.isEmpty()) return null;
        this.getIntersectsOp().intersects(this._root.getBounds(), c) && this.query(c, this._root, f);
      } else if (arguments.length === 3) {
        if (ct2(arguments[2], Ol2) && arguments[0] instanceof Object && arguments[1] instanceof Sn2) for (var g = arguments[0], _ = arguments[1], M3 = arguments[2], N3 = _.getChildBoundables(), G3 = 0; G3 < N3.size(); G3++) {
          var Z4 = N3.get(G3);
          this.getIntersectsOp().intersects(Z4.getBounds(), g) && (Z4 instanceof Sn2 ? this.query(g, Z4, M3) : Z4 instanceof Ko2 ? M3.visitItem(Z4.getItem()) : Yt2.shouldNeverReachHere());
        }
        else if (ct2(arguments[2], ki2) && arguments[0] instanceof Object && arguments[1] instanceof Sn2) for (var st2 = arguments[0], ut2 = arguments[1], Ot2 = arguments[2], Dt2 = ut2.getChildBoundables(), Bt2 = 0; Bt2 < Dt2.size(); Bt2++) {
          var Wt2 = Dt2.get(Bt2);
          this.getIntersectsOp().intersects(Wt2.getBounds(), st2) && (Wt2 instanceof Sn2 ? this.query(st2, Wt2, Ot2) : Wt2 instanceof Ko2 ? Ot2.add(Wt2.getItem()) : Yt2.shouldNeverReachHere());
        }
      }
    }, kn2.prototype.build = function() {
      if (this._built) return null;
      this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
    }, kn2.prototype.getRoot = function() {
      return this.build(), this._root;
    }, kn2.prototype.remove = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), o4) && this.remove(o4, this._root, s5);
      }
      if (arguments.length === 3) {
        var c = arguments[0], f = arguments[1], g = arguments[2], _ = this.removeItem(f, g);
        if (_) return true;
        for (var M3 = null, N3 = f.getChildBoundables().iterator(); N3.hasNext(); ) {
          var G3 = N3.next();
          if (this.getIntersectsOp().intersects(G3.getBounds(), c) && G3 instanceof Sn2 && (_ = this.remove(c, G3, g))) {
            M3 = G3;
            break;
          }
        }
        return M3 !== null && M3.getChildBoundables().isEmpty() && f.getChildBoundables().remove(M3), _;
      }
    }, kn2.prototype.createHigherLevels = function(o4, s5) {
      Yt2.isTrue(!o4.isEmpty());
      var c = this.createParentBoundables(o4, s5 + 1);
      return c.size() === 1 ? c.get(0) : this.createHigherLevels(c, s5 + 1);
    }, kn2.prototype.depth = function() {
      if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
      if (arguments.length === 1) {
        for (var o4 = 0, s5 = arguments[0].getChildBoundables().iterator(); s5.hasNext(); ) {
          var c = s5.next();
          if (c instanceof Sn2) {
            var f = this.depth(c);
            f > o4 && (o4 = f);
          }
        }
        return o4 + 1;
      }
    }, kn2.prototype.createParentBoundables = function(o4, s5) {
      Yt2.isTrue(!o4.isEmpty());
      var c = new Et2();
      c.add(this.createNode(s5));
      var f = new Et2(o4);
      Qo2.sort(f, this.getComparator());
      for (var g = f.iterator(); g.hasNext(); ) {
        var _ = g.next();
        this.lastNode(c).getChildBoundables().size() === this.getNodeCapacity() && c.add(this.createNode(s5)), this.lastNode(c).addChildBoundable(_);
      }
      return c;
    }, kn2.prototype.isEmpty = function() {
      return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
    }, kn2.prototype.interfaces_ = function() {
      return [t];
    }, kn2.prototype.getClass = function() {
      return kn2;
    }, kn2.compareDoubles = function(o4, s5) {
      return o4 > s5 ? 1 : o4 < s5 ? -1 : 0;
    }, E02.IntersectsOp.get = function() {
      return KL2;
    }, E02.serialVersionUID.get = function() {
      return -3886435814360241e3;
    }, E02.DEFAULT_NODE_CAPACITY.get = function() {
      return 10;
    }, Object.defineProperties(kn2, E02);
    var KL2 = H$3(function() {
    }, "rn"), Df3 = H$3(function() {
    }, "on");
    Df3.prototype.distance = function(o4, s5) {
    }, Df3.prototype.interfaces_ = function() {
      return [];
    }, Df3.prototype.getClass = function() {
      return Df3;
    };
    var aw2 = (function(o4) {
      function s5(f) {
        f = f || s5.DEFAULT_NODE_CAPACITY, o4.call(this, f);
      }
      H$3(s5, "n"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
      return s5.prototype.createParentBoundablesFromVerticalSlices = function(f, g) {
        Yt2.isTrue(f.length > 0);
        for (var _ = new Et2(), M3 = 0; M3 < f.length; M3++) _.addAll(this.createParentBoundablesFromVerticalSlice(f[M3], g));
        return _;
      }, s5.prototype.createNode = function(f) {
        return new lw2(f);
      }, s5.prototype.size = function() {
        return arguments.length === 0 ? o4.prototype.size.call(this) : o4.prototype.size.apply(this, arguments);
      }, s5.prototype.insert = function() {
        if (arguments.length !== 2) return o4.prototype.insert.apply(this, arguments);
        var f = arguments[0], g = arguments[1];
        if (f.isNull()) return null;
        o4.prototype.insert.call(this, f, g);
      }, s5.prototype.getIntersectsOp = function() {
        return s5.intersectsOp;
      }, s5.prototype.verticalSlices = function(f, g) {
        for (var _ = Math.trunc(Math.ceil(f.size() / g)), M3 = new Array(g).fill(null), N3 = f.iterator(), G3 = 0; G3 < g; G3++) {
          M3[G3] = new Et2();
          for (var Z4 = 0; N3.hasNext() && Z4 < _; ) {
            var st2 = N3.next();
            M3[G3].add(st2), Z4++;
          }
        }
        return M3;
      }, s5.prototype.query = function() {
        if (arguments.length === 1) {
          var f = arguments[0];
          return o4.prototype.query.call(this, f);
        }
        if (arguments.length === 2) {
          var g = arguments[0], _ = arguments[1];
          o4.prototype.query.call(this, g, _);
        } else if (arguments.length === 3) {
          if (ct2(arguments[2], Ol2) && arguments[0] instanceof Object && arguments[1] instanceof Sn2) {
            var M3 = arguments[0], N3 = arguments[1], G3 = arguments[2];
            o4.prototype.query.call(this, M3, N3, G3);
          } else if (ct2(arguments[2], ki2) && arguments[0] instanceof Object && arguments[1] instanceof Sn2) {
            var Z4 = arguments[0], st2 = arguments[1], ut2 = arguments[2];
            o4.prototype.query.call(this, Z4, st2, ut2);
          }
        }
      }, s5.prototype.getComparator = function() {
        return s5.yComparator;
      }, s5.prototype.createParentBoundablesFromVerticalSlice = function(f, g) {
        return o4.prototype.createParentBoundables.call(this, f, g);
      }, s5.prototype.remove = function() {
        if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          return o4.prototype.remove.call(this, f, g);
        }
        return o4.prototype.remove.apply(this, arguments);
      }, s5.prototype.depth = function() {
        return arguments.length === 0 ? o4.prototype.depth.call(this) : o4.prototype.depth.apply(this, arguments);
      }, s5.prototype.createParentBoundables = function(f, g) {
        Yt2.isTrue(!f.isEmpty());
        var _ = Math.trunc(Math.ceil(f.size() / this.getNodeCapacity())), M3 = new Et2(f);
        Qo2.sort(M3, s5.xComparator);
        var N3 = this.verticalSlices(M3, Math.trunc(Math.ceil(Math.sqrt(_))));
        return this.createParentBoundablesFromVerticalSlices(N3, g);
      }, s5.prototype.nearestNeighbour = function() {
        if (arguments.length === 1) {
          if (ct2(arguments[0], Df3)) {
            var f = arguments[0], g = new gn2(this.getRoot(), this.getRoot(), f);
            return this.nearestNeighbour(g);
          }
          if (arguments[0] instanceof gn2) {
            var _ = arguments[0];
            return this.nearestNeighbour(_, L3.POSITIVE_INFINITY);
          }
        } else if (arguments.length === 2) {
          if (arguments[0] instanceof s5 && ct2(arguments[1], Df3)) {
            var M3 = arguments[0], N3 = arguments[1], G3 = new gn2(this.getRoot(), M3.getRoot(), N3);
            return this.nearestNeighbour(G3);
          }
          if (arguments[0] instanceof gn2 && typeof arguments[1] == "number") {
            var Z4 = arguments[0], st2 = arguments[1], ut2 = null, Ot2 = new ka2();
            for (Ot2.add(Z4); !Ot2.isEmpty() && st2 > 0; ) {
              var Dt2 = Ot2.poll(), Bt2 = Dt2.getDistance();
              if (Bt2 >= st2) break;
              Dt2.isLeaves() ? (st2 = Bt2, ut2 = Dt2) : Dt2.expandToQueue(Ot2, st2);
            }
            return [ut2.getBoundable(0).getItem(), ut2.getBoundable(1).getItem()];
          }
        } else if (arguments.length === 3) {
          var Wt2 = arguments[0], Cr2 = arguments[1], vn2 = arguments[2], _i3 = new Ko2(Wt2, Cr2), ta2 = new gn2(this.getRoot(), _i3, vn2);
          return this.nearestNeighbour(ta2)[0];
        }
      }, s5.prototype.interfaces_ = function() {
        return [rp2, t];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5.centreX = function(f) {
        return s5.avg(f.getMinX(), f.getMaxX());
      }, s5.avg = function(f, g) {
        return (f + g) / 2;
      }, s5.centreY = function(f) {
        return s5.avg(f.getMinY(), f.getMaxY());
      }, c.STRtreeNode.get = function() {
        return lw2;
      }, c.serialVersionUID.get = function() {
        return 259274702368956900;
      }, c.xComparator.get = function() {
        return { interfaces_: H$3(function() {
          return [$5];
        }, "interfaces_"), compare: H$3(function(f, g) {
          return o4.compareDoubles(s5.centreX(f.getBounds()), s5.centreX(g.getBounds()));
        }, "compare") };
      }, c.yComparator.get = function() {
        return { interfaces_: H$3(function() {
          return [$5];
        }, "interfaces_"), compare: H$3(function(f, g) {
          return o4.compareDoubles(s5.centreY(f.getBounds()), s5.centreY(g.getBounds()));
        }, "compare") };
      }, c.intersectsOp.get = function() {
        return { interfaces_: H$3(function() {
          return [o4.IntersectsOp];
        }, "interfaces_"), intersects: H$3(function(f, g) {
          return f.intersects(g);
        }, "intersects") };
      }, c.DEFAULT_NODE_CAPACITY.get = function() {
        return 10;
      }, Object.defineProperties(s5, c), s5;
    })(kn2), lw2 = (function(o4) {
      function s5() {
        var c = arguments[0];
        o4.call(this, c);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.computeBounds = function() {
        for (var c = null, f = this.getChildBoundables().iterator(); f.hasNext(); ) {
          var g = f.next();
          c === null ? c = new Ct2(g.getBounds()) : c.expandToInclude(g.getBounds());
        }
        return c;
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(Sn2), Bi4 = H$3(function() {
    }, "un");
    Bi4.prototype.interfaces_ = function() {
      return [];
    }, Bi4.prototype.getClass = function() {
      return Bi4;
    }, Bi4.relativeSign = function(o4, s5) {
      return o4 < s5 ? -1 : o4 > s5 ? 1 : 0;
    }, Bi4.compare = function(o4, s5, c) {
      if (s5.equals2D(c)) return 0;
      var f = Bi4.relativeSign(s5.x, c.x), g = Bi4.relativeSign(s5.y, c.y);
      switch (o4) {
        case 0:
          return Bi4.compareValue(f, g);
        case 1:
          return Bi4.compareValue(g, f);
        case 2:
          return Bi4.compareValue(g, -f);
        case 3:
          return Bi4.compareValue(-f, g);
        case 4:
          return Bi4.compareValue(-f, -g);
        case 5:
          return Bi4.compareValue(-g, -f);
        case 6:
          return Bi4.compareValue(-g, f);
        case 7:
          return Bi4.compareValue(f, -g);
      }
      return Yt2.shouldNeverReachHere("invalid octant value"), 0;
    }, Bi4.compareValue = function(o4, s5) {
      return o4 < 0 ? -1 : o4 > 0 ? 1 : s5 < 0 ? -1 : s5 > 0 ? 1 : 0;
    };
    var Dl2 = H$3(function() {
      this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2], f = arguments[3];
      this._segString = o4, this.coord = new F3(s5), this.segmentIndex = c, this._segmentOctant = f, this._isInterior = !s5.equals2D(o4.getCoordinate(c));
    }, "ln");
    Dl2.prototype.getCoordinate = function() {
      return this.coord;
    }, Dl2.prototype.print = function(o4) {
      o4.print(this.coord), o4.print(" seg # = " + this.segmentIndex);
    }, Dl2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this.segmentIndex < s5.segmentIndex ? -1 : this.segmentIndex > s5.segmentIndex ? 1 : this.coord.equals2D(s5.coord) ? 0 : Bi4.compare(this._segmentOctant, this.coord, s5.coord);
    }, Dl2.prototype.isEndPoint = function(o4) {
      return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === o4;
    }, Dl2.prototype.isInterior = function() {
      return this._isInterior;
    }, Dl2.prototype.interfaces_ = function() {
      return [j3];
    }, Dl2.prototype.getClass = function() {
      return Dl2;
    };
    var mi2 = H$3(function() {
      this._nodeMap = new x2(), this._edge = null;
      var o4 = arguments[0];
      this._edge = o4;
    }, "cn");
    mi2.prototype.getSplitCoordinates = function() {
      var o4 = new et2();
      this.addEndpoints();
      for (var s5 = this.iterator(), c = s5.next(); s5.hasNext(); ) {
        var f = s5.next();
        this.addEdgeCoordinates(c, f, o4), c = f;
      }
      return o4.toCoordinateArray();
    }, mi2.prototype.addCollapsedNodes = function() {
      var o4 = new Et2();
      this.findCollapsesFromInsertedNodes(o4), this.findCollapsesFromExistingVertices(o4);
      for (var s5 = o4.iterator(); s5.hasNext(); ) {
        var c = s5.next().intValue();
        this.add(this._edge.getCoordinate(c), c);
      }
    }, mi2.prototype.print = function(o4) {
      o4.println("Intersections:");
      for (var s5 = this.iterator(); s5.hasNext(); ) s5.next().print(o4);
    }, mi2.prototype.findCollapsesFromExistingVertices = function(o4) {
      for (var s5 = 0; s5 < this._edge.size() - 2; s5++) {
        var c = this._edge.getCoordinate(s5), f = this._edge.getCoordinate(s5 + 2);
        c.equals2D(f) && o4.add(new dt2(s5 + 1));
      }
    }, mi2.prototype.addEdgeCoordinates = function(o4, s5, c) {
      var f = this._edge.getCoordinate(s5.segmentIndex), g = s5.isInterior() || !s5.coord.equals2D(f);
      c.add(new F3(o4.coord), false);
      for (var _ = o4.segmentIndex + 1; _ <= s5.segmentIndex; _++) c.add(this._edge.getCoordinate(_));
      g && c.add(new F3(s5.coord));
    }, mi2.prototype.iterator = function() {
      return this._nodeMap.values().iterator();
    }, mi2.prototype.addSplitEdges = function(o4) {
      this.addEndpoints(), this.addCollapsedNodes();
      for (var s5 = this.iterator(), c = s5.next(); s5.hasNext(); ) {
        var f = s5.next(), g = this.createSplitEdge(c, f);
        o4.add(g), c = f;
      }
    }, mi2.prototype.findCollapseIndex = function(o4, s5, c) {
      if (!o4.coord.equals2D(s5.coord)) return false;
      var f = s5.segmentIndex - o4.segmentIndex;
      return s5.isInterior() || f--, f === 1 && (c[0] = o4.segmentIndex + 1, true);
    }, mi2.prototype.findCollapsesFromInsertedNodes = function(o4) {
      for (var s5 = new Array(1).fill(null), c = this.iterator(), f = c.next(); c.hasNext(); ) {
        var g = c.next();
        this.findCollapseIndex(f, g, s5) && o4.add(new dt2(s5[0])), f = g;
      }
    }, mi2.prototype.getEdge = function() {
      return this._edge;
    }, mi2.prototype.addEndpoints = function() {
      var o4 = this._edge.size() - 1;
      this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(o4), o4);
    }, mi2.prototype.createSplitEdge = function(o4, s5) {
      var c = s5.segmentIndex - o4.segmentIndex + 2, f = this._edge.getCoordinate(s5.segmentIndex), g = s5.isInterior() || !s5.coord.equals2D(f);
      g || c--;
      var _ = new Array(c).fill(null), M3 = 0;
      _[M3++] = new F3(o4.coord);
      for (var N3 = o4.segmentIndex + 1; N3 <= s5.segmentIndex; N3++) _[M3++] = this._edge.getCoordinate(N3);
      return g && (_[M3] = new F3(s5.coord)), new ln2(_, this._edge.getData());
    }, mi2.prototype.add = function(o4, s5) {
      var c = new Dl2(this._edge, o4, s5, this._edge.getSegmentOctant(s5)), f = this._nodeMap.get(c);
      return f !== null ? (Yt2.isTrue(f.coord.equals2D(o4), "Found equal nodes with different coordinates"), f) : (this._nodeMap.put(c, c), c);
    }, mi2.prototype.checkSplitEdgesCorrectness = function(o4) {
      var s5 = this._edge.getCoordinates(), c = o4.get(0).getCoordinate(0);
      if (!c.equals2D(s5[0])) throw new Wr2("bad split edge start point at " + c);
      var f = o4.get(o4.size() - 1).getCoordinates(), g = f[f.length - 1];
      if (!g.equals2D(s5[s5.length - 1])) throw new Wr2("bad split edge end point at " + g);
    }, mi2.prototype.interfaces_ = function() {
      return [];
    }, mi2.prototype.getClass = function() {
      return mi2;
    };
    var np2 = H$3(function() {
    }, "pn");
    np2.prototype.interfaces_ = function() {
      return [];
    }, np2.prototype.getClass = function() {
      return np2;
    }, np2.octant = function() {
      if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
        var o4 = arguments[0], s5 = arguments[1];
        if (o4 === 0 && s5 === 0) throw new A3("Cannot compute the octant for point ( " + o4 + ", " + s5 + " )");
        var c = Math.abs(o4), f = Math.abs(s5);
        return o4 >= 0 ? s5 >= 0 ? c >= f ? 0 : 1 : c >= f ? 7 : 6 : s5 >= 0 ? c >= f ? 3 : 2 : c >= f ? 4 : 5;
      }
      if (arguments[0] instanceof F3 && arguments[1] instanceof F3) {
        var g = arguments[0], _ = arguments[1], M3 = _.x - g.x, N3 = _.y - g.y;
        if (M3 === 0 && N3 === 0) throw new A3("Cannot compute the octant for two identical points " + g);
        return np2.octant(M3, N3);
      }
    };
    var Ys2 = H$3(function() {
    }, "hn");
    Ys2.prototype.getCoordinates = function() {
    }, Ys2.prototype.size = function() {
    }, Ys2.prototype.getCoordinate = function(o4) {
    }, Ys2.prototype.isClosed = function() {
    }, Ys2.prototype.setData = function(o4) {
    }, Ys2.prototype.getData = function() {
    }, Ys2.prototype.interfaces_ = function() {
      return [];
    }, Ys2.prototype.getClass = function() {
      return Ys2;
    };
    var eg3 = H$3(function() {
    }, "fn");
    eg3.prototype.addIntersection = function(o4, s5) {
    }, eg3.prototype.interfaces_ = function() {
      return [Ys2];
    }, eg3.prototype.getClass = function() {
      return eg3;
    };
    var ln2 = H$3(function() {
      this._nodeList = new mi2(this), this._pts = null, this._data = null;
      var o4 = arguments[0], s5 = arguments[1];
      this._pts = o4, this._data = s5;
    }, "gn");
    ln2.prototype.getCoordinates = function() {
      return this._pts;
    }, ln2.prototype.size = function() {
      return this._pts.length;
    }, ln2.prototype.getCoordinate = function(o4) {
      return this._pts[o4];
    }, ln2.prototype.isClosed = function() {
      return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }, ln2.prototype.getSegmentOctant = function(o4) {
      return o4 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(o4), this.getCoordinate(o4 + 1));
    }, ln2.prototype.setData = function(o4) {
      this._data = o4;
    }, ln2.prototype.safeOctant = function(o4, s5) {
      return o4.equals2D(s5) ? 0 : np2.octant(o4, s5);
    }, ln2.prototype.getData = function() {
      return this._data;
    }, ln2.prototype.addIntersection = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        this.addIntersectionNode(o4, s5);
      } else if (arguments.length === 4) {
        var c = arguments[0], f = arguments[1], g = arguments[3], _ = new F3(c.getIntersection(g));
        this.addIntersection(_, f);
      }
    }, ln2.prototype.toString = function() {
      return br2.toLineString(new an2(this._pts));
    }, ln2.prototype.getNodeList = function() {
      return this._nodeList;
    }, ln2.prototype.addIntersectionNode = function(o4, s5) {
      var c = s5, f = c + 1;
      if (f < this._pts.length) {
        var g = this._pts[f];
        o4.equals2D(g) && (c = f);
      }
      return this._nodeList.add(o4, c);
    }, ln2.prototype.addIntersections = function(o4, s5, c) {
      for (var f = 0; f < o4.getIntersectionNum(); f++) this.addIntersection(o4, s5, c, f);
    }, ln2.prototype.interfaces_ = function() {
      return [eg3];
    }, ln2.prototype.getClass = function() {
      return ln2;
    }, ln2.getNodedSubstrings = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = new Et2();
        return ln2.getNodedSubstrings(o4, s5), s5;
      }
      if (arguments.length === 2) for (var c = arguments[0], f = arguments[1], g = c.iterator(); g.hasNext(); ) g.next().getNodeList().addSplitEdges(f);
    };
    var Ut2 = H$3(function() {
      if (this.p0 = null, this.p1 = null, arguments.length === 0) this.p0 = new F3(), this.p1 = new F3();
      else if (arguments.length === 1) {
        var o4 = arguments[0];
        this.p0 = new F3(o4.p0), this.p1 = new F3(o4.p1);
      } else if (arguments.length === 2) this.p0 = arguments[0], this.p1 = arguments[1];
      else if (arguments.length === 4) {
        var s5 = arguments[0], c = arguments[1], f = arguments[2], g = arguments[3];
        this.p0 = new F3(s5, c), this.p1 = new F3(f, g);
      }
    }, "dn"), uw2 = { serialVersionUID: { configurable: true } };
    Ut2.prototype.minX = function() {
      return Math.min(this.p0.x, this.p1.x);
    }, Ut2.prototype.orientationIndex = function() {
      if (arguments[0] instanceof Ut2) {
        var o4 = arguments[0], s5 = wt2.orientationIndex(this.p0, this.p1, o4.p0), c = wt2.orientationIndex(this.p0, this.p1, o4.p1);
        return s5 >= 0 && c >= 0 || s5 <= 0 && c <= 0 ? Math.max(s5, c) : 0;
      }
      if (arguments[0] instanceof F3) {
        var f = arguments[0];
        return wt2.orientationIndex(this.p0, this.p1, f);
      }
    }, Ut2.prototype.toGeometry = function(o4) {
      return o4.createLineString([this.p0, this.p1]);
    }, Ut2.prototype.isVertical = function() {
      return this.p0.x === this.p1.x;
    }, Ut2.prototype.equals = function(o4) {
      if (!(o4 instanceof Ut2)) return false;
      var s5 = o4;
      return this.p0.equals(s5.p0) && this.p1.equals(s5.p1);
    }, Ut2.prototype.intersection = function(o4) {
      var s5 = new Ji2();
      return s5.computeIntersection(this.p0, this.p1, o4.p0, o4.p1), s5.hasIntersection() ? s5.getIntersection(0) : null;
    }, Ut2.prototype.project = function() {
      if (arguments[0] instanceof F3) {
        var o4 = arguments[0];
        if (o4.equals(this.p0) || o4.equals(this.p1)) return new F3(o4);
        var s5 = this.projectionFactor(o4), c = new F3();
        return c.x = this.p0.x + s5 * (this.p1.x - this.p0.x), c.y = this.p0.y + s5 * (this.p1.y - this.p0.y), c;
      }
      if (arguments[0] instanceof Ut2) {
        var f = arguments[0], g = this.projectionFactor(f.p0), _ = this.projectionFactor(f.p1);
        if (g >= 1 && _ >= 1 || g <= 0 && _ <= 0) return null;
        var M3 = this.project(f.p0);
        g < 0 && (M3 = this.p0), g > 1 && (M3 = this.p1);
        var N3 = this.project(f.p1);
        return _ < 0 && (N3 = this.p0), _ > 1 && (N3 = this.p1), new Ut2(M3, N3);
      }
    }, Ut2.prototype.normalize = function() {
      this.p1.compareTo(this.p0) < 0 && this.reverse();
    }, Ut2.prototype.angle = function() {
      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
    }, Ut2.prototype.getCoordinate = function(o4) {
      return o4 === 0 ? this.p0 : this.p1;
    }, Ut2.prototype.distancePerpendicular = function(o4) {
      return wt2.distancePointLinePerpendicular(o4, this.p0, this.p1);
    }, Ut2.prototype.minY = function() {
      return Math.min(this.p0.y, this.p1.y);
    }, Ut2.prototype.midPoint = function() {
      return Ut2.midPoint(this.p0, this.p1);
    }, Ut2.prototype.projectionFactor = function(o4) {
      if (o4.equals(this.p0)) return 0;
      if (o4.equals(this.p1)) return 1;
      var s5 = this.p1.x - this.p0.x, c = this.p1.y - this.p0.y, f = s5 * s5 + c * c;
      return f <= 0 ? L3.NaN : ((o4.x - this.p0.x) * s5 + (o4.y - this.p0.y) * c) / f;
    }, Ut2.prototype.closestPoints = function(o4) {
      var s5 = this.intersection(o4);
      if (s5 !== null) return [s5, s5];
      var c = new Array(2).fill(null), f = L3.MAX_VALUE, g = null, _ = this.closestPoint(o4.p0);
      f = _.distance(o4.p0), c[0] = _, c[1] = o4.p0;
      var M3 = this.closestPoint(o4.p1);
      (g = M3.distance(o4.p1)) < f && (f = g, c[0] = M3, c[1] = o4.p1);
      var N3 = o4.closestPoint(this.p0);
      (g = N3.distance(this.p0)) < f && (f = g, c[0] = this.p0, c[1] = N3);
      var G3 = o4.closestPoint(this.p1);
      return (g = G3.distance(this.p1)) < f && (f = g, c[0] = this.p1, c[1] = G3), c;
    }, Ut2.prototype.closestPoint = function(o4) {
      var s5 = this.projectionFactor(o4);
      return s5 > 0 && s5 < 1 ? this.project(o4) : this.p0.distance(o4) < this.p1.distance(o4) ? this.p0 : this.p1;
    }, Ut2.prototype.maxX = function() {
      return Math.max(this.p0.x, this.p1.x);
    }, Ut2.prototype.getLength = function() {
      return this.p0.distance(this.p1);
    }, Ut2.prototype.compareTo = function(o4) {
      var s5 = o4, c = this.p0.compareTo(s5.p0);
      return c !== 0 ? c : this.p1.compareTo(s5.p1);
    }, Ut2.prototype.reverse = function() {
      var o4 = this.p0;
      this.p0 = this.p1, this.p1 = o4;
    }, Ut2.prototype.equalsTopo = function(o4) {
      return this.p0.equals(o4.p0) && (this.p1.equals(o4.p1) || this.p0.equals(o4.p1)) && this.p1.equals(o4.p0);
    }, Ut2.prototype.lineIntersection = function(o4) {
      try {
        return At2.intersection(this.p0, this.p1, o4.p0, o4.p1);
      } catch (s5) {
        if (!(s5 instanceof Qe2)) throw s5;
      }
      return null;
    }, Ut2.prototype.maxY = function() {
      return Math.max(this.p0.y, this.p1.y);
    }, Ut2.prototype.pointAlongOffset = function(o4, s5) {
      var c = this.p0.x + o4 * (this.p1.x - this.p0.x), f = this.p0.y + o4 * (this.p1.y - this.p0.y), g = this.p1.x - this.p0.x, _ = this.p1.y - this.p0.y, M3 = Math.sqrt(g * g + _ * _), N3 = 0, G3 = 0;
      if (s5 !== 0) {
        if (M3 <= 0) throw new Error("Cannot compute offset from zero-length line segment");
        N3 = s5 * g / M3, G3 = s5 * _ / M3;
      }
      return new F3(c - G3, f + N3);
    }, Ut2.prototype.setCoordinates = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.setCoordinates(o4.p0, o4.p1);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        this.p0.x = s5.x, this.p0.y = s5.y, this.p1.x = c.x, this.p1.y = c.y;
      }
    }, Ut2.prototype.segmentFraction = function(o4) {
      var s5 = this.projectionFactor(o4);
      return s5 < 0 ? s5 = 0 : (s5 > 1 || L3.isNaN(s5)) && (s5 = 1), s5;
    }, Ut2.prototype.toString = function() {
      return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
    }, Ut2.prototype.isHorizontal = function() {
      return this.p0.y === this.p1.y;
    }, Ut2.prototype.distance = function() {
      if (arguments[0] instanceof Ut2) {
        var o4 = arguments[0];
        return wt2.distanceLineLine(this.p0, this.p1, o4.p0, o4.p1);
      }
      if (arguments[0] instanceof F3) {
        var s5 = arguments[0];
        return wt2.distancePointLine(s5, this.p0, this.p1);
      }
    }, Ut2.prototype.pointAlong = function(o4) {
      var s5 = new F3();
      return s5.x = this.p0.x + o4 * (this.p1.x - this.p0.x), s5.y = this.p0.y + o4 * (this.p1.y - this.p0.y), s5;
    }, Ut2.prototype.hashCode = function() {
      var o4 = L3.doubleToLongBits(this.p0.x);
      o4 ^= 31 * L3.doubleToLongBits(this.p0.y);
      var s5 = Math.trunc(o4) ^ Math.trunc(o4 >> 32), c = L3.doubleToLongBits(this.p1.x);
      return c ^= 31 * L3.doubleToLongBits(this.p1.y), s5 ^ (Math.trunc(c) ^ Math.trunc(c >> 32));
    }, Ut2.prototype.interfaces_ = function() {
      return [j3, t];
    }, Ut2.prototype.getClass = function() {
      return Ut2;
    }, Ut2.midPoint = function(o4, s5) {
      return new F3((o4.x + s5.x) / 2, (o4.y + s5.y) / 2);
    }, uw2.serialVersionUID.get = function() {
      return 3252005833466256400;
    }, Object.defineProperties(Ut2, uw2);
    var rg3 = H$3(function() {
      this.tempEnv1 = new Ct2(), this.tempEnv2 = new Ct2(), this._overlapSeg1 = new Ut2(), this._overlapSeg2 = new Ut2();
    }, "_n");
    rg3.prototype.overlap = function() {
      if (arguments.length !== 2) {
        if (arguments.length === 4) {
          var o4 = arguments[0], s5 = arguments[1], c = arguments[2], f = arguments[3];
          o4.getLineSegment(s5, this._overlapSeg1), c.getLineSegment(f, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
        }
      }
    }, rg3.prototype.interfaces_ = function() {
      return [];
    }, rg3.prototype.getClass = function() {
      return rg3;
    };
    var eo2 = H$3(function() {
      this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2], f = arguments[3];
      this._pts = o4, this._start = s5, this._end = c, this._context = f;
    }, "mn");
    eo2.prototype.getLineSegment = function(o4, s5) {
      s5.p0 = this._pts[o4], s5.p1 = this._pts[o4 + 1];
    }, eo2.prototype.computeSelect = function(o4, s5, c, f) {
      var g = this._pts[s5], _ = this._pts[c];
      if (f.tempEnv1.init(g, _), c - s5 == 1) return f.select(this, s5), null;
      if (!o4.intersects(f.tempEnv1)) return null;
      var M3 = Math.trunc((s5 + c) / 2);
      s5 < M3 && this.computeSelect(o4, s5, M3, f), M3 < c && this.computeSelect(o4, M3, c, f);
    }, eo2.prototype.getCoordinates = function() {
      for (var o4 = new Array(this._end - this._start + 1).fill(null), s5 = 0, c = this._start; c <= this._end; c++) o4[s5++] = this._pts[c];
      return o4;
    }, eo2.prototype.computeOverlaps = function(o4, s5) {
      this.computeOverlapsInternal(this._start, this._end, o4, o4._start, o4._end, s5);
    }, eo2.prototype.setId = function(o4) {
      this._id = o4;
    }, eo2.prototype.select = function(o4, s5) {
      this.computeSelect(o4, this._start, this._end, s5);
    }, eo2.prototype.getEnvelope = function() {
      if (this._env === null) {
        var o4 = this._pts[this._start], s5 = this._pts[this._end];
        this._env = new Ct2(o4, s5);
      }
      return this._env;
    }, eo2.prototype.getEndIndex = function() {
      return this._end;
    }, eo2.prototype.getStartIndex = function() {
      return this._start;
    }, eo2.prototype.getContext = function() {
      return this._context;
    }, eo2.prototype.getId = function() {
      return this._id;
    }, eo2.prototype.computeOverlapsInternal = function(o4, s5, c, f, g, _) {
      var M3 = this._pts[o4], N3 = this._pts[s5], G3 = c._pts[f], Z4 = c._pts[g];
      if (s5 - o4 == 1 && g - f == 1) return _.overlap(this, o4, c, f), null;
      if (_.tempEnv1.init(M3, N3), _.tempEnv2.init(G3, Z4), !_.tempEnv1.intersects(_.tempEnv2)) return null;
      var st2 = Math.trunc((o4 + s5) / 2), ut2 = Math.trunc((f + g) / 2);
      o4 < st2 && (f < ut2 && this.computeOverlapsInternal(o4, st2, c, f, ut2, _), ut2 < g && this.computeOverlapsInternal(o4, st2, c, ut2, g, _)), st2 < s5 && (f < ut2 && this.computeOverlapsInternal(st2, s5, c, f, ut2, _), ut2 < g && this.computeOverlapsInternal(st2, s5, c, ut2, g, _));
    }, eo2.prototype.interfaces_ = function() {
      return [];
    }, eo2.prototype.getClass = function() {
      return eo2;
    };
    var vs2 = H$3(function() {
    }, "vn");
    vs2.prototype.interfaces_ = function() {
      return [];
    }, vs2.prototype.getClass = function() {
      return vs2;
    }, vs2.getChainStartIndices = function(o4) {
      var s5 = 0, c = new Et2();
      c.add(new dt2(s5));
      do {
        var f = vs2.findChainEnd(o4, s5);
        c.add(new dt2(f)), s5 = f;
      } while (s5 < o4.length - 1);
      return vs2.toIntArray(c);
    }, vs2.findChainEnd = function(o4, s5) {
      for (var c = s5; c < o4.length - 1 && o4[c].equals2D(o4[c + 1]); ) c++;
      if (c >= o4.length - 1) return o4.length - 1;
      for (var f = wr2.quadrant(o4[c], o4[c + 1]), g = s5 + 1; g < o4.length && !(!o4[g - 1].equals2D(o4[g]) && wr2.quadrant(o4[g - 1], o4[g]) !== f); ) g++;
      return g - 1;
    }, vs2.getChains = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return vs2.getChains(o4, null);
      }
      if (arguments.length === 2) {
        for (var s5 = arguments[0], c = arguments[1], f = new Et2(), g = vs2.getChainStartIndices(s5), _ = 0; _ < g.length - 1; _++) {
          var M3 = new eo2(s5, g[_], g[_ + 1], c);
          f.add(M3);
        }
        return f;
      }
    }, vs2.toIntArray = function(o4) {
      for (var s5 = new Array(o4.size()).fill(null), c = 0; c < s5.length; c++) s5[c] = o4.get(c).intValue();
      return s5;
    };
    var Wu2 = H$3(function() {
    }, "In");
    Wu2.prototype.computeNodes = function(o4) {
    }, Wu2.prototype.getNodedSubstrings = function() {
    }, Wu2.prototype.interfaces_ = function() {
      return [];
    }, Wu2.prototype.getClass = function() {
      return Wu2;
    };
    var ng3 = H$3(function() {
      if (this._segInt = null, arguments.length !== 0) {
        if (arguments.length === 1) {
          var o4 = arguments[0];
          this.setSegmentIntersector(o4);
        }
      }
    }, "En");
    ng3.prototype.setSegmentIntersector = function(o4) {
      this._segInt = o4;
    }, ng3.prototype.interfaces_ = function() {
      return [Wu2];
    }, ng3.prototype.getClass = function() {
      return ng3;
    };
    var z22 = (function(o4) {
      function s5(f) {
        f ? o4.call(this, f) : o4.call(this), this._monoChains = new Et2(), this._index = new aw2(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
      }
      H$3(s5, "e"), o4 && (s5.__proto__ = o4), (s5.prototype = Object.create(o4 && o4.prototype)).constructor = s5;
      var c = { SegmentOverlapAction: { configurable: true } };
      return s5.prototype.getMonotoneChains = function() {
        return this._monoChains;
      }, s5.prototype.getNodedSubstrings = function() {
        return ln2.getNodedSubstrings(this._nodedSegStrings);
      }, s5.prototype.getIndex = function() {
        return this._index;
      }, s5.prototype.add = function(f) {
        for (var g = vs2.getChains(f.getCoordinates(), f).iterator(); g.hasNext(); ) {
          var _ = g.next();
          _.setId(this._idCounter++), this._index.insert(_.getEnvelope(), _), this._monoChains.add(_);
        }
      }, s5.prototype.computeNodes = function(f) {
        this._nodedSegStrings = f;
        for (var g = f.iterator(); g.hasNext(); ) this.add(g.next());
        this.intersectChains();
      }, s5.prototype.intersectChains = function() {
        for (var f = new cw2(this._segInt), g = this._monoChains.iterator(); g.hasNext(); ) for (var _ = g.next(), M3 = this._index.query(_.getEnvelope()).iterator(); M3.hasNext(); ) {
          var N3 = M3.next();
          if (N3.getId() > _.getId() && (_.computeOverlaps(N3, f), this._nOverlaps++), this._segInt.isDone()) return null;
        }
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, c.SegmentOverlapAction.get = function() {
        return cw2;
      }, Object.defineProperties(s5, c), s5;
    })(ng3), cw2 = (function(o4) {
      function s5() {
        o4.call(this), this._si = null;
        var c = arguments[0];
        this._si = c;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.overlap = function() {
        if (arguments.length !== 4) return o4.prototype.overlap.apply(this, arguments);
        var c = arguments[0], f = arguments[1], g = arguments[2], _ = arguments[3], M3 = c.getContext(), N3 = g.getContext();
        this._si.processIntersections(M3, f, N3, _);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(rg3), er2 = H$3(function o4() {
      if (this._quadrantSegments = o4.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = o4.CAP_ROUND, this._joinStyle = o4.JOIN_ROUND, this._mitreLimit = o4.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = o4.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
        if (arguments.length === 1) {
          var s5 = arguments[0];
          this.setQuadrantSegments(s5);
        } else if (arguments.length === 2) {
          var c = arguments[0], f = arguments[1];
          this.setQuadrantSegments(c), this.setEndCapStyle(f);
        } else if (arguments.length === 4) {
          var g = arguments[0], _ = arguments[1], M3 = arguments[2], N3 = arguments[3];
          this.setQuadrantSegments(g), this.setEndCapStyle(_), this.setJoinStyle(M3), this.setMitreLimit(N3);
        }
      }
    }, "t"), Ra2 = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
    er2.prototype.getEndCapStyle = function() {
      return this._endCapStyle;
    }, er2.prototype.isSingleSided = function() {
      return this._isSingleSided;
    }, er2.prototype.setQuadrantSegments = function(o4) {
      this._quadrantSegments = o4, this._quadrantSegments === 0 && (this._joinStyle = er2.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = er2.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), o4 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== er2.JOIN_ROUND && (this._quadrantSegments = er2.DEFAULT_QUADRANT_SEGMENTS);
    }, er2.prototype.getJoinStyle = function() {
      return this._joinStyle;
    }, er2.prototype.setJoinStyle = function(o4) {
      this._joinStyle = o4;
    }, er2.prototype.setSimplifyFactor = function(o4) {
      this._simplifyFactor = o4 < 0 ? 0 : o4;
    }, er2.prototype.getSimplifyFactor = function() {
      return this._simplifyFactor;
    }, er2.prototype.getQuadrantSegments = function() {
      return this._quadrantSegments;
    }, er2.prototype.setEndCapStyle = function(o4) {
      this._endCapStyle = o4;
    }, er2.prototype.getMitreLimit = function() {
      return this._mitreLimit;
    }, er2.prototype.setMitreLimit = function(o4) {
      this._mitreLimit = o4;
    }, er2.prototype.setSingleSided = function(o4) {
      this._isSingleSided = o4;
    }, er2.prototype.interfaces_ = function() {
      return [];
    }, er2.prototype.getClass = function() {
      return er2;
    }, er2.bufferDistanceError = function(o4) {
      var s5 = Math.PI / 2 / o4;
      return 1 - Math.cos(s5 / 2);
    }, Ra2.CAP_ROUND.get = function() {
      return 1;
    }, Ra2.CAP_FLAT.get = function() {
      return 2;
    }, Ra2.CAP_SQUARE.get = function() {
      return 3;
    }, Ra2.JOIN_ROUND.get = function() {
      return 1;
    }, Ra2.JOIN_MITRE.get = function() {
      return 2;
    }, Ra2.JOIN_BEVEL.get = function() {
      return 3;
    }, Ra2.DEFAULT_QUADRANT_SEGMENTS.get = function() {
      return 8;
    }, Ra2.DEFAULT_MITRE_LIMIT.get = function() {
      return 5;
    }, Ra2.DEFAULT_SIMPLIFY_FACTOR.get = function() {
      return 0.01;
    }, Object.defineProperties(er2, Ra2);
    var en2 = H$3(function(o4) {
      this._distanceTol = null, this._isDeleted = null, this._angleOrientation = wt2.COUNTERCLOCKWISE, this._inputLine = o4 || null;
    }, "Ln"), ig3 = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
    en2.prototype.isDeletable = function(o4, s5, c, f) {
      var g = this._inputLine[o4], _ = this._inputLine[s5], M3 = this._inputLine[c];
      return !!this.isConcave(g, _, M3) && !!this.isShallow(g, _, M3, f) && this.isShallowSampled(g, _, o4, c, f);
    }, en2.prototype.deleteShallowConcavities = function() {
      for (var o4 = 1, s5 = this.findNextNonDeletedIndex(o4), c = this.findNextNonDeletedIndex(s5), f = false; c < this._inputLine.length; ) {
        var g = false;
        this.isDeletable(o4, s5, c, this._distanceTol) && (this._isDeleted[s5] = en2.DELETE, g = true, f = true), o4 = g ? c : s5, s5 = this.findNextNonDeletedIndex(o4), c = this.findNextNonDeletedIndex(s5);
      }
      return f;
    }, en2.prototype.isShallowConcavity = function(o4, s5, c, f) {
      return wt2.computeOrientation(o4, s5, c) !== this._angleOrientation ? false : wt2.distancePointLine(s5, o4, c) < f;
    }, en2.prototype.isShallowSampled = function(o4, s5, c, f, g) {
      var _ = Math.trunc((f - c) / en2.NUM_PTS_TO_CHECK);
      _ <= 0 && (_ = 1);
      for (var M3 = c; M3 < f; M3 += _) if (!this.isShallow(o4, s5, this._inputLine[M3], g)) return false;
      return true;
    }, en2.prototype.isConcave = function(o4, s5, c) {
      var f = wt2.computeOrientation(o4, s5, c) === this._angleOrientation;
      return f;
    }, en2.prototype.simplify = function(o4) {
      this._distanceTol = Math.abs(o4), o4 < 0 && (this._angleOrientation = wt2.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
      var s5 = false;
      do
        s5 = this.deleteShallowConcavities();
      while (s5);
      return this.collapseLine();
    }, en2.prototype.findNextNonDeletedIndex = function(o4) {
      for (var s5 = o4 + 1; s5 < this._inputLine.length && this._isDeleted[s5] === en2.DELETE; ) s5++;
      return s5;
    }, en2.prototype.isShallow = function(o4, s5, c, f) {
      return wt2.distancePointLine(s5, o4, c) < f;
    }, en2.prototype.collapseLine = function() {
      for (var o4 = new et2(), s5 = 0; s5 < this._inputLine.length; s5++) this._isDeleted[s5] !== en2.DELETE && o4.add(this._inputLine[s5]);
      return o4.toCoordinateArray();
    }, en2.prototype.interfaces_ = function() {
      return [];
    }, en2.prototype.getClass = function() {
      return en2;
    }, en2.simplify = function(o4, s5) {
      return new en2(o4).simplify(s5);
    }, ig3.INIT.get = function() {
      return 0;
    }, ig3.DELETE.get = function() {
      return 1;
    }, ig3.KEEP.get = function() {
      return 1;
    }, ig3.NUM_PTS_TO_CHECK.get = function() {
      return 10;
    }, Object.defineProperties(en2, ig3);
    var mo2 = H$3(function() {
      this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Et2();
    }, "wn"), pw2 = { COORDINATE_ARRAY_TYPE: { configurable: true } };
    mo2.prototype.getCoordinates = function() {
      return this._ptList.toArray(mo2.COORDINATE_ARRAY_TYPE);
    }, mo2.prototype.setPrecisionModel = function(o4) {
      this._precisionModel = o4;
    }, mo2.prototype.addPt = function(o4) {
      var s5 = new F3(o4);
      if (this._precisionModel.makePrecise(s5), this.isRedundant(s5)) return null;
      this._ptList.add(s5);
    }, mo2.prototype.revere = function() {
    }, mo2.prototype.addPts = function(o4, s5) {
      if (s5) for (var c = 0; c < o4.length; c++) this.addPt(o4[c]);
      else for (var f = o4.length - 1; f >= 0; f--) this.addPt(o4[f]);
    }, mo2.prototype.isRedundant = function(o4) {
      if (this._ptList.size() < 1) return false;
      var s5 = this._ptList.get(this._ptList.size() - 1);
      return o4.distance(s5) < this._minimimVertexDistance;
    }, mo2.prototype.toString = function() {
      return new ge2().createLineString(this.getCoordinates()).toString();
    }, mo2.prototype.closeRing = function() {
      if (this._ptList.size() < 1) return null;
      var o4 = new F3(this._ptList.get(0)), s5 = this._ptList.get(this._ptList.size() - 1);
      if (o4.equals(s5)) return null;
      this._ptList.add(o4);
    }, mo2.prototype.setMinimumVertexDistance = function(o4) {
      this._minimimVertexDistance = o4;
    }, mo2.prototype.interfaces_ = function() {
      return [];
    }, mo2.prototype.getClass = function() {
      return mo2;
    }, pw2.COORDINATE_ARRAY_TYPE.get = function() {
      return new Array(0).fill(null);
    }, Object.defineProperties(mo2, pw2);
    var xe2 = H$3(function() {
    }, "Tn"), ip2 = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
    xe2.prototype.interfaces_ = function() {
      return [];
    }, xe2.prototype.getClass = function() {
      return xe2;
    }, xe2.toDegrees = function(o4) {
      return 180 * o4 / Math.PI;
    }, xe2.normalize = function(o4) {
      for (; o4 > Math.PI; ) o4 -= xe2.PI_TIMES_2;
      for (; o4 <= -Math.PI; ) o4 += xe2.PI_TIMES_2;
      return o4;
    }, xe2.angle = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return Math.atan2(o4.y, o4.x);
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1], f = c.x - s5.x, g = c.y - s5.y;
        return Math.atan2(g, f);
      }
    }, xe2.isAcute = function(o4, s5, c) {
      var f = o4.x - s5.x, g = o4.y - s5.y;
      return f * (c.x - s5.x) + g * (c.y - s5.y) > 0;
    }, xe2.isObtuse = function(o4, s5, c) {
      var f = o4.x - s5.x, g = o4.y - s5.y;
      return f * (c.x - s5.x) + g * (c.y - s5.y) < 0;
    }, xe2.interiorAngle = function(o4, s5, c) {
      var f = xe2.angle(s5, o4), g = xe2.angle(s5, c);
      return Math.abs(g - f);
    }, xe2.normalizePositive = function(o4) {
      if (o4 < 0) {
        for (; o4 < 0; ) o4 += xe2.PI_TIMES_2;
        o4 >= xe2.PI_TIMES_2 && (o4 = 0);
      } else {
        for (; o4 >= xe2.PI_TIMES_2; ) o4 -= xe2.PI_TIMES_2;
        o4 < 0 && (o4 = 0);
      }
      return o4;
    }, xe2.angleBetween = function(o4, s5, c) {
      var f = xe2.angle(s5, o4), g = xe2.angle(s5, c);
      return xe2.diff(f, g);
    }, xe2.diff = function(o4, s5) {
      var c = null;
      return (c = o4 < s5 ? s5 - o4 : o4 - s5) > Math.PI && (c = 2 * Math.PI - c), c;
    }, xe2.toRadians = function(o4) {
      return o4 * Math.PI / 180;
    }, xe2.getTurn = function(o4, s5) {
      var c = Math.sin(s5 - o4);
      return c > 0 ? xe2.COUNTERCLOCKWISE : c < 0 ? xe2.CLOCKWISE : xe2.NONE;
    }, xe2.angleBetweenOriented = function(o4, s5, c) {
      var f = xe2.angle(s5, o4), g = xe2.angle(s5, c) - f;
      return g <= -Math.PI ? g + xe2.PI_TIMES_2 : g > Math.PI ? g - xe2.PI_TIMES_2 : g;
    }, ip2.PI_TIMES_2.get = function() {
      return 2 * Math.PI;
    }, ip2.PI_OVER_2.get = function() {
      return Math.PI / 2;
    }, ip2.PI_OVER_4.get = function() {
      return Math.PI / 4;
    }, ip2.COUNTERCLOCKWISE.get = function() {
      return wt2.COUNTERCLOCKWISE;
    }, ip2.CLOCKWISE.get = function() {
      return wt2.CLOCKWISE;
    }, ip2.NONE.get = function() {
      return wt2.COLLINEAR;
    }, Object.defineProperties(xe2, ip2);
    var Fr3 = H$3(function o4() {
      this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new Ut2(), this._seg1 = new Ut2(), this._offset0 = new Ut2(), this._offset1 = new Ut2(), this._side = 0, this._hasNarrowConcaveAngle = false;
      var s5 = arguments[0], c = arguments[1], f = arguments[2];
      this._precisionModel = s5, this._bufParams = c, this._li = new Ji2(), this._filletAngleQuantum = Math.PI / 2 / c.getQuadrantSegments(), c.getQuadrantSegments() >= 8 && c.getJoinStyle() === er2.JOIN_ROUND && (this._closingSegLengthFactor = o4.MAX_CLOSING_SEG_LEN_FACTOR), this.init(f);
    }, "t"), og3 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
    Fr3.prototype.addNextSegment = function(o4, s5) {
      if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = o4, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
      var c = wt2.computeOrientation(this._s0, this._s1, this._s2), f = c === wt2.CLOCKWISE && this._side === Tt2.LEFT || c === wt2.COUNTERCLOCKWISE && this._side === Tt2.RIGHT;
      c === 0 ? this.addCollinear(s5) : f ? this.addOutsideTurn(c, s5) : this.addInsideTurn(c, s5);
    }, Fr3.prototype.addLineEndCap = function(o4, s5) {
      var c = new Ut2(o4, s5), f = new Ut2();
      this.computeOffsetSegment(c, Tt2.LEFT, this._distance, f);
      var g = new Ut2();
      this.computeOffsetSegment(c, Tt2.RIGHT, this._distance, g);
      var _ = s5.x - o4.x, M3 = s5.y - o4.y, N3 = Math.atan2(M3, _);
      switch (this._bufParams.getEndCapStyle()) {
        case er2.CAP_ROUND:
          this._segList.addPt(f.p1), this.addFilletArc(s5, N3 + Math.PI / 2, N3 - Math.PI / 2, wt2.CLOCKWISE, this._distance), this._segList.addPt(g.p1);
          break;
        case er2.CAP_FLAT:
          this._segList.addPt(f.p1), this._segList.addPt(g.p1);
          break;
        case er2.CAP_SQUARE:
          var G3 = new F3();
          G3.x = Math.abs(this._distance) * Math.cos(N3), G3.y = Math.abs(this._distance) * Math.sin(N3);
          var Z4 = new F3(f.p1.x + G3.x, f.p1.y + G3.y), st2 = new F3(g.p1.x + G3.x, g.p1.y + G3.y);
          this._segList.addPt(Z4), this._segList.addPt(st2);
      }
    }, Fr3.prototype.getCoordinates = function() {
      return this._segList.getCoordinates();
    }, Fr3.prototype.addMitreJoin = function(o4, s5, c, f) {
      var g = true, _ = null;
      try {
        _ = At2.intersection(s5.p0, s5.p1, c.p0, c.p1), (f <= 0 ? 1 : _.distance(o4) / Math.abs(f)) > this._bufParams.getMitreLimit() && (g = false);
      } catch (M3) {
        if (!(M3 instanceof Qe2)) throw M3;
        _ = new F3(0, 0), g = false;
      }
      g ? this._segList.addPt(_) : this.addLimitedMitreJoin(s5, c, f, this._bufParams.getMitreLimit());
    }, Fr3.prototype.addFilletCorner = function(o4, s5, c, f, g) {
      var _ = s5.x - o4.x, M3 = s5.y - o4.y, N3 = Math.atan2(M3, _), G3 = c.x - o4.x, Z4 = c.y - o4.y, st2 = Math.atan2(Z4, G3);
      f === wt2.CLOCKWISE ? N3 <= st2 && (N3 += 2 * Math.PI) : N3 >= st2 && (N3 -= 2 * Math.PI), this._segList.addPt(s5), this.addFilletArc(o4, N3, st2, f, g), this._segList.addPt(c);
    }, Fr3.prototype.addOutsideTurn = function(o4, s5) {
      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Fr3.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
      this._bufParams.getJoinStyle() === er2.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === er2.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (s5 && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, o4, this._distance), this._segList.addPt(this._offset1.p0));
    }, Fr3.prototype.createSquare = function(o4) {
      this._segList.addPt(new F3(o4.x + this._distance, o4.y + this._distance)), this._segList.addPt(new F3(o4.x + this._distance, o4.y - this._distance)), this._segList.addPt(new F3(o4.x - this._distance, o4.y - this._distance)), this._segList.addPt(new F3(o4.x - this._distance, o4.y + this._distance)), this._segList.closeRing();
    }, Fr3.prototype.addSegments = function(o4, s5) {
      this._segList.addPts(o4, s5);
    }, Fr3.prototype.addFirstSegment = function() {
      this._segList.addPt(this._offset1.p0);
    }, Fr3.prototype.addLastSegment = function() {
      this._segList.addPt(this._offset1.p1);
    }, Fr3.prototype.initSideSegments = function(o4, s5, c) {
      this._s1 = o4, this._s2 = s5, this._side = c, this._seg1.setCoordinates(o4, s5), this.computeOffsetSegment(this._seg1, c, this._distance, this._offset1);
    }, Fr3.prototype.addLimitedMitreJoin = function(o4, s5, c, f) {
      var g = this._seg0.p1, _ = xe2.angle(g, this._seg0.p0), M3 = xe2.angleBetweenOriented(this._seg0.p0, g, this._seg1.p1) / 2, N3 = xe2.normalize(_ + M3), G3 = xe2.normalize(N3 + Math.PI), Z4 = f * c, st2 = c - Z4 * Math.abs(Math.sin(M3)), ut2 = g.x + Z4 * Math.cos(G3), Ot2 = g.y + Z4 * Math.sin(G3), Dt2 = new F3(ut2, Ot2), Bt2 = new Ut2(g, Dt2), Wt2 = Bt2.pointAlongOffset(1, st2), Cr2 = Bt2.pointAlongOffset(1, -st2);
      this._side === Tt2.LEFT ? (this._segList.addPt(Wt2), this._segList.addPt(Cr2)) : (this._segList.addPt(Cr2), this._segList.addPt(Wt2));
    }, Fr3.prototype.computeOffsetSegment = function(o4, s5, c, f) {
      var g = s5 === Tt2.LEFT ? 1 : -1, _ = o4.p1.x - o4.p0.x, M3 = o4.p1.y - o4.p0.y, N3 = Math.sqrt(_ * _ + M3 * M3), G3 = g * c * _ / N3, Z4 = g * c * M3 / N3;
      f.p0.x = o4.p0.x - Z4, f.p0.y = o4.p0.y + G3, f.p1.x = o4.p1.x - Z4, f.p1.y = o4.p1.y + G3;
    }, Fr3.prototype.addFilletArc = function(o4, s5, c, f, g) {
      var _ = f === wt2.CLOCKWISE ? -1 : 1, M3 = Math.abs(s5 - c), N3 = Math.trunc(M3 / this._filletAngleQuantum + 0.5);
      if (N3 < 1) return null;
      for (var G3 = M3 / N3, Z4 = 0, st2 = new F3(); Z4 < M3; ) {
        var ut2 = s5 + _ * Z4;
        st2.x = o4.x + g * Math.cos(ut2), st2.y = o4.y + g * Math.sin(ut2), this._segList.addPt(st2), Z4 += G3;
      }
    }, Fr3.prototype.addInsideTurn = function(o4, s5) {
      if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
      else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * Fr3.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
      else {
        if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
          var c = new F3((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
          this._segList.addPt(c);
          var f = new F3((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
          this._segList.addPt(f);
        } else this._segList.addPt(this._s1);
        this._segList.addPt(this._offset1.p0);
      }
    }, Fr3.prototype.createCircle = function(o4) {
      var s5 = new F3(o4.x + this._distance, o4.y);
      this._segList.addPt(s5), this.addFilletArc(o4, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
    }, Fr3.prototype.addBevelJoin = function(o4, s5) {
      this._segList.addPt(o4.p1), this._segList.addPt(s5.p0);
    }, Fr3.prototype.init = function(o4) {
      this._distance = o4, this._maxCurveSegmentError = o4 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new mo2(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(o4 * Fr3.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
    }, Fr3.prototype.addCollinear = function(o4) {
      this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === er2.JOIN_BEVEL || this._bufParams.getJoinStyle() === er2.JOIN_MITRE ? (o4 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, wt2.CLOCKWISE, this._distance));
    }, Fr3.prototype.closeRing = function() {
      this._segList.closeRing();
    }, Fr3.prototype.hasNarrowConcaveAngle = function() {
      return this._hasNarrowConcaveAngle;
    }, Fr3.prototype.interfaces_ = function() {
      return [];
    }, Fr3.prototype.getClass = function() {
      return Fr3;
    }, og3.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
      return 1e-3;
    }, og3.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
      return 1e-3;
    }, og3.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
      return 1e-6;
    }, og3.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
      return 80;
    }, Object.defineProperties(Fr3, og3);
    var Gi2 = H$3(function() {
      this._distance = 0, this._precisionModel = null, this._bufParams = null;
      var o4 = arguments[0], s5 = arguments[1];
      this._precisionModel = o4, this._bufParams = s5;
    }, "Mn");
    Gi2.prototype.getOffsetCurve = function(o4, s5) {
      if (this._distance = s5, s5 === 0) return null;
      var c = s5 < 0, f = Math.abs(s5), g = this.getSegGen(f);
      o4.length <= 1 ? this.computePointCurve(o4[0], g) : this.computeOffsetCurve(o4, c, g);
      var _ = g.getCoordinates();
      return c && O4.reverse(_), _;
    }, Gi2.prototype.computeSingleSidedBufferCurve = function(o4, s5, c) {
      var f = this.simplifyTolerance(this._distance);
      if (s5) {
        c.addSegments(o4, true);
        var g = en2.simplify(o4, -f), _ = g.length - 1;
        c.initSideSegments(g[_], g[_ - 1], Tt2.LEFT), c.addFirstSegment();
        for (var M3 = _ - 2; M3 >= 0; M3--) c.addNextSegment(g[M3], true);
      } else {
        c.addSegments(o4, false);
        var N3 = en2.simplify(o4, f), G3 = N3.length - 1;
        c.initSideSegments(N3[0], N3[1], Tt2.LEFT), c.addFirstSegment();
        for (var Z4 = 2; Z4 <= G3; Z4++) c.addNextSegment(N3[Z4], true);
      }
      c.addLastSegment(), c.closeRing();
    }, Gi2.prototype.computeRingBufferCurve = function(o4, s5, c) {
      var f = this.simplifyTolerance(this._distance);
      s5 === Tt2.RIGHT && (f = -f);
      var g = en2.simplify(o4, f), _ = g.length - 1;
      c.initSideSegments(g[_ - 1], g[0], s5);
      for (var M3 = 1; M3 <= _; M3++) {
        var N3 = M3 !== 1;
        c.addNextSegment(g[M3], N3);
      }
      c.closeRing();
    }, Gi2.prototype.computeLineBufferCurve = function(o4, s5) {
      var c = this.simplifyTolerance(this._distance), f = en2.simplify(o4, c), g = f.length - 1;
      s5.initSideSegments(f[0], f[1], Tt2.LEFT);
      for (var _ = 2; _ <= g; _++) s5.addNextSegment(f[_], true);
      s5.addLastSegment(), s5.addLineEndCap(f[g - 1], f[g]);
      var M3 = en2.simplify(o4, -c), N3 = M3.length - 1;
      s5.initSideSegments(M3[N3], M3[N3 - 1], Tt2.LEFT);
      for (var G3 = N3 - 2; G3 >= 0; G3--) s5.addNextSegment(M3[G3], true);
      s5.addLastSegment(), s5.addLineEndCap(M3[1], M3[0]), s5.closeRing();
    }, Gi2.prototype.computePointCurve = function(o4, s5) {
      switch (this._bufParams.getEndCapStyle()) {
        case er2.CAP_ROUND:
          s5.createCircle(o4);
          break;
        case er2.CAP_SQUARE:
          s5.createSquare(o4);
      }
    }, Gi2.prototype.getLineCurve = function(o4, s5) {
      if (this._distance = s5, s5 < 0 && !this._bufParams.isSingleSided() || s5 === 0) return null;
      var c = Math.abs(s5), f = this.getSegGen(c);
      if (o4.length <= 1) this.computePointCurve(o4[0], f);
      else if (this._bufParams.isSingleSided()) {
        var g = s5 < 0;
        this.computeSingleSidedBufferCurve(o4, g, f);
      } else this.computeLineBufferCurve(o4, f);
      return f.getCoordinates();
    }, Gi2.prototype.getBufferParameters = function() {
      return this._bufParams;
    }, Gi2.prototype.simplifyTolerance = function(o4) {
      return o4 * this._bufParams.getSimplifyFactor();
    }, Gi2.prototype.getRingCurve = function(o4, s5, c) {
      if (this._distance = c, o4.length <= 2) return this.getLineCurve(o4, c);
      if (c === 0) return Gi2.copyCoordinates(o4);
      var f = this.getSegGen(c);
      return this.computeRingBufferCurve(o4, s5, f), f.getCoordinates();
    }, Gi2.prototype.computeOffsetCurve = function(o4, s5, c) {
      var f = this.simplifyTolerance(this._distance);
      if (s5) {
        var g = en2.simplify(o4, -f), _ = g.length - 1;
        c.initSideSegments(g[_], g[_ - 1], Tt2.LEFT), c.addFirstSegment();
        for (var M3 = _ - 2; M3 >= 0; M3--) c.addNextSegment(g[M3], true);
      } else {
        var N3 = en2.simplify(o4, f), G3 = N3.length - 1;
        c.initSideSegments(N3[0], N3[1], Tt2.LEFT), c.addFirstSegment();
        for (var Z4 = 2; Z4 <= G3; Z4++) c.addNextSegment(N3[Z4], true);
      }
      c.addLastSegment();
    }, Gi2.prototype.getSegGen = function(o4) {
      return new Fr3(this._precisionModel, this._bufParams, o4);
    }, Gi2.prototype.interfaces_ = function() {
      return [];
    }, Gi2.prototype.getClass = function() {
      return Gi2;
    }, Gi2.copyCoordinates = function(o4) {
      for (var s5 = new Array(o4.length).fill(null), c = 0; c < s5.length; c++) s5[c] = new F3(o4[c]);
      return s5;
    };
    var op2 = H$3(function() {
      this._subgraphs = null, this._seg = new Ut2(), this._cga = new wt2();
      var o4 = arguments[0];
      this._subgraphs = o4;
    }, "An"), hw2 = { DepthSegment: { configurable: true } };
    op2.prototype.findStabbedSegments = function() {
      if (arguments.length === 1) {
        for (var o4 = arguments[0], s5 = new Et2(), c = this._subgraphs.iterator(); c.hasNext(); ) {
          var f = c.next(), g = f.getEnvelope();
          o4.y < g.getMinY() || o4.y > g.getMaxY() || this.findStabbedSegments(o4, f.getDirectedEdges(), s5);
        }
        return s5;
      }
      if (arguments.length === 3) {
        if (ct2(arguments[2], ki2) && arguments[0] instanceof F3 && arguments[1] instanceof U22) {
          for (var _ = arguments[0], M3 = arguments[1], N3 = arguments[2], G3 = M3.getEdge().getCoordinates(), Z4 = 0; Z4 < G3.length - 1; Z4++) if (this._seg.p0 = G3[Z4], this._seg.p1 = G3[Z4 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < _.x) && !(this._seg.isHorizontal() || _.y < this._seg.p0.y || _.y > this._seg.p1.y || wt2.computeOrientation(this._seg.p0, this._seg.p1, _) === wt2.RIGHT)) {
            var st2 = M3.getDepth(Tt2.LEFT);
            this._seg.p0.equals(G3[Z4]) || (st2 = M3.getDepth(Tt2.RIGHT));
            var ut2 = new Zu2(this._seg, st2);
            N3.add(ut2);
          }
        } else if (ct2(arguments[2], ki2) && arguments[0] instanceof F3 && ct2(arguments[1], ki2)) for (var Ot2 = arguments[0], Dt2 = arguments[1], Bt2 = arguments[2], Wt2 = Dt2.iterator(); Wt2.hasNext(); ) {
          var Cr2 = Wt2.next();
          Cr2.isForward() && this.findStabbedSegments(Ot2, Cr2, Bt2);
        }
      }
    }, op2.prototype.getDepth = function(o4) {
      var s5 = this.findStabbedSegments(o4);
      return s5.size() === 0 ? 0 : Qo2.min(s5)._leftDepth;
    }, op2.prototype.interfaces_ = function() {
      return [];
    }, op2.prototype.getClass = function() {
      return op2;
    }, hw2.DepthSegment.get = function() {
      return Zu2;
    }, Object.defineProperties(op2, hw2);
    var Zu2 = H$3(function() {
      this._upwardSeg = null, this._leftDepth = null;
      var o4 = arguments[0], s5 = arguments[1];
      this._upwardSeg = new Ut2(o4), this._leftDepth = s5;
    }, "Gn");
    Zu2.prototype.compareTo = function(o4) {
      var s5 = o4;
      if (this._upwardSeg.minX() >= s5._upwardSeg.maxX()) return 1;
      if (this._upwardSeg.maxX() <= s5._upwardSeg.minX()) return -1;
      var c = this._upwardSeg.orientationIndex(s5._upwardSeg);
      return c !== 0 || (c = -1 * s5._upwardSeg.orientationIndex(this._upwardSeg)) != 0 ? c : this._upwardSeg.compareTo(s5._upwardSeg);
    }, Zu2.prototype.compareX = function(o4, s5) {
      var c = o4.p0.compareTo(s5.p0);
      return c !== 0 ? c : o4.p1.compareTo(s5.p1);
    }, Zu2.prototype.toString = function() {
      return this._upwardSeg.toString();
    }, Zu2.prototype.interfaces_ = function() {
      return [j3];
    }, Zu2.prototype.getClass = function() {
      return Zu2;
    };
    var rr2 = H$3(function(o4, s5, c) {
      this.p0 = o4 || null, this.p1 = s5 || null, this.p2 = c || null;
    }, "qn");
    rr2.prototype.area = function() {
      return rr2.area(this.p0, this.p1, this.p2);
    }, rr2.prototype.signedArea = function() {
      return rr2.signedArea(this.p0, this.p1, this.p2);
    }, rr2.prototype.interpolateZ = function(o4) {
      if (o4 === null) throw new A3("Supplied point is null.");
      return rr2.interpolateZ(o4, this.p0, this.p1, this.p2);
    }, rr2.prototype.longestSideLength = function() {
      return rr2.longestSideLength(this.p0, this.p1, this.p2);
    }, rr2.prototype.isAcute = function() {
      return rr2.isAcute(this.p0, this.p1, this.p2);
    }, rr2.prototype.circumcentre = function() {
      return rr2.circumcentre(this.p0, this.p1, this.p2);
    }, rr2.prototype.area3D = function() {
      return rr2.area3D(this.p0, this.p1, this.p2);
    }, rr2.prototype.centroid = function() {
      return rr2.centroid(this.p0, this.p1, this.p2);
    }, rr2.prototype.inCentre = function() {
      return rr2.inCentre(this.p0, this.p1, this.p2);
    }, rr2.prototype.interfaces_ = function() {
      return [];
    }, rr2.prototype.getClass = function() {
      return rr2;
    }, rr2.area = function(o4, s5, c) {
      return Math.abs(((c.x - o4.x) * (s5.y - o4.y) - (s5.x - o4.x) * (c.y - o4.y)) / 2);
    }, rr2.signedArea = function(o4, s5, c) {
      return ((c.x - o4.x) * (s5.y - o4.y) - (s5.x - o4.x) * (c.y - o4.y)) / 2;
    }, rr2.det = function(o4, s5, c, f) {
      return o4 * f - s5 * c;
    }, rr2.interpolateZ = function(o4, s5, c, f) {
      var g = s5.x, _ = s5.y, M3 = c.x - g, N3 = f.x - g, G3 = c.y - _, Z4 = f.y - _, st2 = M3 * Z4 - N3 * G3, ut2 = o4.x - g, Ot2 = o4.y - _, Dt2 = (Z4 * ut2 - N3 * Ot2) / st2, Bt2 = (-G3 * ut2 + M3 * Ot2) / st2;
      return s5.z + Dt2 * (c.z - s5.z) + Bt2 * (f.z - s5.z);
    }, rr2.longestSideLength = function(o4, s5, c) {
      var f = o4.distance(s5), g = s5.distance(c), _ = c.distance(o4), M3 = f;
      return g > M3 && (M3 = g), _ > M3 && (M3 = _), M3;
    }, rr2.isAcute = function(o4, s5, c) {
      return !!xe2.isAcute(o4, s5, c) && !!xe2.isAcute(s5, c, o4) && !!xe2.isAcute(c, o4, s5);
    }, rr2.circumcentre = function(o4, s5, c) {
      var f = c.x, g = c.y, _ = o4.x - f, M3 = o4.y - g, N3 = s5.x - f, G3 = s5.y - g, Z4 = 2 * rr2.det(_, M3, N3, G3), st2 = rr2.det(M3, _ * _ + M3 * M3, G3, N3 * N3 + G3 * G3), ut2 = rr2.det(_, _ * _ + M3 * M3, N3, N3 * N3 + G3 * G3);
      return new F3(f - st2 / Z4, g + ut2 / Z4);
    }, rr2.perpendicularBisector = function(o4, s5) {
      var c = s5.x - o4.x, f = s5.y - o4.y, g = new At2(o4.x + c / 2, o4.y + f / 2, 1), _ = new At2(o4.x - f + c / 2, o4.y + c + f / 2, 1);
      return new At2(g, _);
    }, rr2.angleBisector = function(o4, s5, c) {
      var f = s5.distance(o4), g = f / (f + s5.distance(c)), _ = c.x - o4.x, M3 = c.y - o4.y;
      return new F3(o4.x + g * _, o4.y + g * M3);
    }, rr2.area3D = function(o4, s5, c) {
      var f = s5.x - o4.x, g = s5.y - o4.y, _ = s5.z - o4.z, M3 = c.x - o4.x, N3 = c.y - o4.y, G3 = c.z - o4.z, Z4 = g * G3 - _ * N3, st2 = _ * M3 - f * G3, ut2 = f * N3 - g * M3, Ot2 = Z4 * Z4 + st2 * st2 + ut2 * ut2, Dt2 = Math.sqrt(Ot2) / 2;
      return Dt2;
    }, rr2.centroid = function(o4, s5, c) {
      var f = (o4.x + s5.x + c.x) / 3, g = (o4.y + s5.y + c.y) / 3;
      return new F3(f, g);
    }, rr2.inCentre = function(o4, s5, c) {
      var f = s5.distance(c), g = o4.distance(c), _ = o4.distance(s5), M3 = f + g + _, N3 = (f * o4.x + g * s5.x + _ * c.x) / M3, G3 = (f * o4.y + g * s5.y + _ * c.y) / M3;
      return new F3(N3, G3);
    };
    var No2 = H$3(function() {
      this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Et2();
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
      this._inputGeom = o4, this._distance = s5, this._curveBuilder = c;
    }, "Bn");
    No2.prototype.addPoint = function(o4) {
      if (this._distance <= 0) return null;
      var s5 = o4.getCoordinates(), c = this._curveBuilder.getLineCurve(s5, this._distance);
      this.addCurve(c, H5.EXTERIOR, H5.INTERIOR);
    }, No2.prototype.addPolygon = function(o4) {
      var s5 = this._distance, c = Tt2.LEFT;
      this._distance < 0 && (s5 = -this._distance, c = Tt2.RIGHT);
      var f = o4.getExteriorRing(), g = O4.removeRepeatedPoints(f.getCoordinates());
      if (this._distance < 0 && this.isErodedCompletely(f, this._distance) || this._distance <= 0 && g.length < 3) return null;
      this.addPolygonRing(g, s5, c, H5.EXTERIOR, H5.INTERIOR);
      for (var _ = 0; _ < o4.getNumInteriorRing(); _++) {
        var M3 = o4.getInteriorRingN(_), N3 = O4.removeRepeatedPoints(M3.getCoordinates());
        this._distance > 0 && this.isErodedCompletely(M3, -this._distance) || this.addPolygonRing(N3, s5, Tt2.opposite(c), H5.INTERIOR, H5.EXTERIOR);
      }
    }, No2.prototype.isTriangleErodedCompletely = function(o4, s5) {
      var c = new rr2(o4[0], o4[1], o4[2]), f = c.inCentre();
      return wt2.distancePointLine(f, c.p0, c.p1) < Math.abs(s5);
    }, No2.prototype.addLineString = function(o4) {
      if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;
      var s5 = O4.removeRepeatedPoints(o4.getCoordinates()), c = this._curveBuilder.getLineCurve(s5, this._distance);
      this.addCurve(c, H5.EXTERIOR, H5.INTERIOR);
    }, No2.prototype.addCurve = function(o4, s5, c) {
      if (o4 === null || o4.length < 2) return null;
      var f = new ln2(o4, new _r2(0, H5.BOUNDARY, s5, c));
      this._curveList.add(f);
    }, No2.prototype.getCurves = function() {
      return this.add(this._inputGeom), this._curveList;
    }, No2.prototype.addPolygonRing = function(o4, s5, c, f, g) {
      if (s5 === 0 && o4.length < Fi3.MINIMUM_VALID_SIZE) return null;
      var _ = f, M3 = g;
      o4.length >= Fi3.MINIMUM_VALID_SIZE && wt2.isCCW(o4) && (_ = g, M3 = f, c = Tt2.opposite(c));
      var N3 = this._curveBuilder.getRingCurve(o4, c, s5);
      this.addCurve(N3, _, M3);
    }, No2.prototype.add = function(o4) {
      if (o4.isEmpty()) return null;
      o4 instanceof xr2 ? this.addPolygon(o4) : o4 instanceof ye2 ? this.addLineString(o4) : o4 instanceof Ur2 ? this.addPoint(o4) : o4 instanceof Ki2 ? this.addCollection(o4) : o4 instanceof Tr2 ? this.addCollection(o4) : o4 instanceof Jo2 ? this.addCollection(o4) : o4 instanceof te2 && this.addCollection(o4);
    }, No2.prototype.isErodedCompletely = function(o4, s5) {
      var c = o4.getCoordinates();
      if (c.length < 4) return s5 < 0;
      if (c.length === 4) return this.isTriangleErodedCompletely(c, s5);
      var f = o4.getEnvelopeInternal(), g = Math.min(f.getHeight(), f.getWidth());
      return s5 < 0 && 2 * Math.abs(s5) > g;
    }, No2.prototype.addCollection = function(o4) {
      for (var s5 = 0; s5 < o4.getNumGeometries(); s5++) {
        var c = o4.getGeometryN(s5);
        this.add(c);
      }
    }, No2.prototype.interfaces_ = function() {
      return [];
    }, No2.prototype.getClass = function() {
      return No2;
    };
    var Lf3 = H$3(function() {
    }, "Vn");
    Lf3.prototype.locate = function(o4) {
    }, Lf3.prototype.interfaces_ = function() {
      return [];
    }, Lf3.prototype.getClass = function() {
      return Lf3;
    };
    var qs3 = H$3(function() {
      this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
      var o4 = arguments[0];
      this._parent = o4, this._atStart = true, this._index = 0, this._max = o4.getNumGeometries();
    }, "Un");
    qs3.prototype.next = function() {
      if (this._atStart) return this._atStart = false, qs3.isAtomic(this._parent) && this._index++, this._parent;
      if (this._subcollectionIterator !== null) {
        if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
        this._subcollectionIterator = null;
      }
      if (this._index >= this._max) throw new n4();
      var o4 = this._parent.getGeometryN(this._index++);
      return o4 instanceof te2 ? (this._subcollectionIterator = new qs3(o4), this._subcollectionIterator.next()) : o4;
    }, qs3.prototype.remove = function() {
      throw new Error(this.getClass().getName());
    }, qs3.prototype.hasNext = function() {
      if (this._atStart) return true;
      if (this._subcollectionIterator !== null) {
        if (this._subcollectionIterator.hasNext()) return true;
        this._subcollectionIterator = null;
      }
      return !(this._index >= this._max);
    }, qs3.prototype.interfaces_ = function() {
      return [La2];
    }, qs3.prototype.getClass = function() {
      return qs3;
    }, qs3.isAtomic = function(o4) {
      return !(o4 instanceof te2);
    };
    var go2 = H$3(function() {
      this._geom = null;
      var o4 = arguments[0];
      this._geom = o4;
    }, "zn");
    go2.prototype.locate = function(o4) {
      return go2.locate(o4, this._geom);
    }, go2.prototype.interfaces_ = function() {
      return [Lf3];
    }, go2.prototype.getClass = function() {
      return go2;
    }, go2.isPointInRing = function(o4, s5) {
      return !!s5.getEnvelopeInternal().intersects(o4) && wt2.isPointInRing(o4, s5.getCoordinates());
    }, go2.containsPointInPolygon = function(o4, s5) {
      if (s5.isEmpty()) return false;
      var c = s5.getExteriorRing();
      if (!go2.isPointInRing(o4, c)) return false;
      for (var f = 0; f < s5.getNumInteriorRing(); f++) {
        var g = s5.getInteriorRingN(f);
        if (go2.isPointInRing(o4, g)) return false;
      }
      return true;
    }, go2.containsPoint = function(o4, s5) {
      if (s5 instanceof xr2) return go2.containsPointInPolygon(o4, s5);
      if (s5 instanceof te2) for (var c = new qs3(s5); c.hasNext(); ) {
        var f = c.next();
        if (f !== s5 && go2.containsPoint(o4, f)) return true;
      }
      return false;
    }, go2.locate = function(o4, s5) {
      return s5.isEmpty() ? H5.EXTERIOR : go2.containsPoint(o4, s5) ? H5.INTERIOR : H5.EXTERIOR;
    };
    var ni2 = H$3(function() {
      this._edgeMap = new x2(), this._edgeList = null, this._ptInAreaLocation = [H5.NONE, H5.NONE];
    }, "Xn");
    ni2.prototype.getNextCW = function(o4) {
      this.getEdges();
      var s5 = this._edgeList.indexOf(o4), c = s5 - 1;
      return s5 === 0 && (c = this._edgeList.size() - 1), this._edgeList.get(c);
    }, ni2.prototype.propagateSideLabels = function(o4) {
      for (var s5 = H5.NONE, c = this.iterator(); c.hasNext(); ) {
        var f = c.next().getLabel();
        f.isArea(o4) && f.getLocation(o4, Tt2.LEFT) !== H5.NONE && (s5 = f.getLocation(o4, Tt2.LEFT));
      }
      if (s5 === H5.NONE) return null;
      for (var g = s5, _ = this.iterator(); _.hasNext(); ) {
        var M3 = _.next(), N3 = M3.getLabel();
        if (N3.getLocation(o4, Tt2.ON) === H5.NONE && N3.setLocation(o4, Tt2.ON, g), N3.isArea(o4)) {
          var G3 = N3.getLocation(o4, Tt2.LEFT), Z4 = N3.getLocation(o4, Tt2.RIGHT);
          if (Z4 !== H5.NONE) {
            if (Z4 !== g) throw new Na2("side location conflict", M3.getCoordinate());
            G3 === H5.NONE && Yt2.shouldNeverReachHere("found single null side (at " + M3.getCoordinate() + ")"), g = G3;
          } else Yt2.isTrue(N3.getLocation(o4, Tt2.LEFT) === H5.NONE, "found single null side"), N3.setLocation(o4, Tt2.RIGHT, g), N3.setLocation(o4, Tt2.LEFT, g);
        }
      }
    }, ni2.prototype.getCoordinate = function() {
      var o4 = this.iterator();
      return o4.hasNext() ? o4.next().getCoordinate() : null;
    }, ni2.prototype.print = function(o4) {
      Nt2.out.println("EdgeEndStar:   " + this.getCoordinate());
      for (var s5 = this.iterator(); s5.hasNext(); ) s5.next().print(o4);
    }, ni2.prototype.isAreaLabelsConsistent = function(o4) {
      return this.computeEdgeEndLabels(o4.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
    }, ni2.prototype.checkAreaLabelsConsistent = function(o4) {
      var s5 = this.getEdges();
      if (s5.size() <= 0) return true;
      var c = s5.size() - 1, f = s5.get(c).getLabel().getLocation(o4, Tt2.LEFT);
      Yt2.isTrue(f !== H5.NONE, "Found unlabelled area edge");
      for (var g = f, _ = this.iterator(); _.hasNext(); ) {
        var M3 = _.next().getLabel();
        Yt2.isTrue(M3.isArea(o4), "Found non-area edge");
        var N3 = M3.getLocation(o4, Tt2.LEFT), G3 = M3.getLocation(o4, Tt2.RIGHT);
        if (N3 === G3 || G3 !== g) return false;
        g = N3;
      }
      return true;
    }, ni2.prototype.findIndex = function(o4) {
      this.iterator();
      for (var s5 = 0; s5 < this._edgeList.size(); s5++) if (this._edgeList.get(s5) === o4) return s5;
      return -1;
    }, ni2.prototype.iterator = function() {
      return this.getEdges().iterator();
    }, ni2.prototype.getEdges = function() {
      return this._edgeList === null && (this._edgeList = new Et2(this._edgeMap.values())), this._edgeList;
    }, ni2.prototype.getLocation = function(o4, s5, c) {
      return this._ptInAreaLocation[o4] === H5.NONE && (this._ptInAreaLocation[o4] = go2.locate(s5, c[o4].getGeometry())), this._ptInAreaLocation[o4];
    }, ni2.prototype.toString = function() {
      var o4 = new St2();
      o4.append("EdgeEndStar:   " + this.getCoordinate()), o4.append("\n");
      for (var s5 = this.iterator(); s5.hasNext(); ) {
        var c = s5.next();
        o4.append(c), o4.append("\n");
      }
      return o4.toString();
    }, ni2.prototype.computeEdgeEndLabels = function(o4) {
      for (var s5 = this.iterator(); s5.hasNext(); ) s5.next().computeLabel(o4);
    }, ni2.prototype.computeLabelling = function(o4) {
      this.computeEdgeEndLabels(o4[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
      for (var s5 = [false, false], c = this.iterator(); c.hasNext(); ) for (var f = c.next().getLabel(), g = 0; g < 2; g++) f.isLine(g) && f.getLocation(g) === H5.BOUNDARY && (s5[g] = true);
      for (var _ = this.iterator(); _.hasNext(); ) for (var M3 = _.next(), N3 = M3.getLabel(), G3 = 0; G3 < 2; G3++) if (N3.isAnyNull(G3)) {
        var Z4 = H5.NONE;
        if (s5[G3]) Z4 = H5.EXTERIOR;
        else {
          var st2 = M3.getCoordinate();
          Z4 = this.getLocation(G3, st2, o4);
        }
        N3.setAllLocationsIfNull(G3, Z4);
      }
    }, ni2.prototype.getDegree = function() {
      return this._edgeMap.size();
    }, ni2.prototype.insertEdgeEnd = function(o4, s5) {
      this._edgeMap.put(o4, s5), this._edgeList = null;
    }, ni2.prototype.interfaces_ = function() {
      return [];
    }, ni2.prototype.getClass = function() {
      return ni2;
    };
    var QL2 = (function(o4) {
      function s5() {
        o4.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.linkResultDirectedEdges = function() {
        this.getResultAreaEdges();
        for (var c = null, f = null, g = this._SCANNING_FOR_INCOMING, _ = 0; _ < this._resultAreaEdgeList.size(); _++) {
          var M3 = this._resultAreaEdgeList.get(_), N3 = M3.getSym();
          if (M3.getLabel().isArea()) switch (c === null && M3.isInResult() && (c = M3), g) {
            case this._SCANNING_FOR_INCOMING:
              if (!N3.isInResult()) continue;
              f = N3, g = this._LINKING_TO_OUTGOING;
              break;
            case this._LINKING_TO_OUTGOING:
              if (!M3.isInResult()) continue;
              f.setNext(M3), g = this._SCANNING_FOR_INCOMING;
          }
        }
        if (g === this._LINKING_TO_OUTGOING) {
          if (c === null) throw new Na2("no outgoing dirEdge found", this.getCoordinate());
          Yt2.isTrue(c.isInResult(), "unable to link last incoming dirEdge"), f.setNext(c);
        }
      }, s5.prototype.insert = function(c) {
        var f = c;
        this.insertEdgeEnd(f, f);
      }, s5.prototype.getRightmostEdge = function() {
        var c = this.getEdges(), f = c.size();
        if (f < 1) return null;
        var g = c.get(0);
        if (f === 1) return g;
        var _ = c.get(f - 1), M3 = g.getQuadrant(), N3 = _.getQuadrant();
        return wr2.isNorthern(M3) && wr2.isNorthern(N3) ? g : wr2.isNorthern(M3) || wr2.isNorthern(N3) ? g.getDy() !== 0 ? g : _.getDy() !== 0 ? _ : (Yt2.shouldNeverReachHere("found two horizontal edges incident on node"), null) : _;
      }, s5.prototype.print = function(c) {
        Nt2.out.println("DirectedEdgeStar: " + this.getCoordinate());
        for (var f = this.iterator(); f.hasNext(); ) {
          var g = f.next();
          c.print("out "), g.print(c), c.println(), c.print("in "), g.getSym().print(c), c.println();
        }
      }, s5.prototype.getResultAreaEdges = function() {
        if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new Et2();
        for (var c = this.iterator(); c.hasNext(); ) {
          var f = c.next();
          (f.isInResult() || f.getSym().isInResult()) && this._resultAreaEdgeList.add(f);
        }
        return this._resultAreaEdgeList;
      }, s5.prototype.updateLabelling = function(c) {
        for (var f = this.iterator(); f.hasNext(); ) {
          var g = f.next().getLabel();
          g.setAllLocationsIfNull(0, c.getLocation(0)), g.setAllLocationsIfNull(1, c.getLocation(1));
        }
      }, s5.prototype.linkAllDirectedEdges = function() {
        this.getEdges();
        for (var c = null, f = null, g = this._edgeList.size() - 1; g >= 0; g--) {
          var _ = this._edgeList.get(g), M3 = _.getSym();
          f === null && (f = M3), c !== null && M3.setNext(c), c = _;
        }
        f.setNext(c);
      }, s5.prototype.computeDepths = function() {
        if (arguments.length === 1) {
          var c = arguments[0], f = this.findIndex(c), g = c.getDepth(Tt2.LEFT), _ = c.getDepth(Tt2.RIGHT), M3 = this.computeDepths(f + 1, this._edgeList.size(), g);
          if (this.computeDepths(0, f, M3) !== _) throw new Na2("depth mismatch at " + c.getCoordinate());
        } else if (arguments.length === 3) {
          for (var N3 = arguments[0], G3 = arguments[1], Z4 = arguments[2], st2 = N3; st2 < G3; st2++) {
            var ut2 = this._edgeList.get(st2);
            ut2.setEdgeDepths(Tt2.RIGHT, Z4), Z4 = ut2.getDepth(Tt2.LEFT);
          }
          return Z4;
        }
      }, s5.prototype.mergeSymLabels = function() {
        for (var c = this.iterator(); c.hasNext(); ) {
          var f = c.next();
          f.getLabel().merge(f.getSym().getLabel());
        }
      }, s5.prototype.linkMinimalDirectedEdges = function(c) {
        for (var f = null, g = null, _ = this._SCANNING_FOR_INCOMING, M3 = this._resultAreaEdgeList.size() - 1; M3 >= 0; M3--) {
          var N3 = this._resultAreaEdgeList.get(M3), G3 = N3.getSym();
          switch (f === null && N3.getEdgeRing() === c && (f = N3), _) {
            case this._SCANNING_FOR_INCOMING:
              if (G3.getEdgeRing() !== c) continue;
              g = G3, _ = this._LINKING_TO_OUTGOING;
              break;
            case this._LINKING_TO_OUTGOING:
              if (N3.getEdgeRing() !== c) continue;
              g.setNextMin(N3), _ = this._SCANNING_FOR_INCOMING;
          }
        }
        _ === this._LINKING_TO_OUTGOING && (Yt2.isTrue(f !== null, "found null for first outgoing dirEdge"), Yt2.isTrue(f.getEdgeRing() === c, "unable to link last incoming dirEdge"), g.setNextMin(f));
      }, s5.prototype.getOutgoingDegree = function() {
        if (arguments.length === 0) {
          for (var c = 0, f = this.iterator(); f.hasNext(); ) f.next().isInResult() && c++;
          return c;
        }
        if (arguments.length === 1) {
          for (var g = arguments[0], _ = 0, M3 = this.iterator(); M3.hasNext(); ) M3.next().getEdgeRing() === g && _++;
          return _;
        }
      }, s5.prototype.getLabel = function() {
        return this._label;
      }, s5.prototype.findCoveredLineEdges = function() {
        for (var c = H5.NONE, f = this.iterator(); f.hasNext(); ) {
          var g = f.next(), _ = g.getSym();
          if (!g.isLineEdge()) {
            if (g.isInResult()) {
              c = H5.INTERIOR;
              break;
            }
            if (_.isInResult()) {
              c = H5.EXTERIOR;
              break;
            }
          }
        }
        if (c === H5.NONE) return null;
        for (var M3 = c, N3 = this.iterator(); N3.hasNext(); ) {
          var G3 = N3.next(), Z4 = G3.getSym();
          G3.isLineEdge() ? G3.getEdge().setCovered(M3 === H5.INTERIOR) : (G3.isInResult() && (M3 = H5.EXTERIOR), Z4.isInResult() && (M3 = H5.INTERIOR));
        }
      }, s5.prototype.computeLabelling = function(c) {
        o4.prototype.computeLabelling.call(this, c), this._label = new _r2(H5.NONE);
        for (var f = this.iterator(); f.hasNext(); ) for (var g = f.next().getEdge().getLabel(), _ = 0; _ < 2; _++) {
          var M3 = g.getLocation(_);
          M3 !== H5.INTERIOR && M3 !== H5.BOUNDARY || this._label.setLocation(_, H5.INTERIOR);
        }
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(ni2), fw2 = (function(o4) {
      function s5() {
        o4.apply(this, arguments);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.createNode = function(c) {
        return new P02(c, new QL2());
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(Ef3), Ll2 = H$3(function o4() {
      this._pts = null, this._orientation = null;
      var s5 = arguments[0];
      this._pts = s5, this._orientation = o4.orientation(s5);
    }, "t");
    Ll2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return Ll2.compareOriented(this._pts, this._orientation, s5._pts, s5._orientation);
    }, Ll2.prototype.interfaces_ = function() {
      return [j3];
    }, Ll2.prototype.getClass = function() {
      return Ll2;
    }, Ll2.orientation = function(o4) {
      return O4.increasingDirection(o4) === 1;
    }, Ll2.compareOriented = function(o4, s5, c, f) {
      for (var g = s5 ? 1 : -1, _ = f ? 1 : -1, M3 = s5 ? o4.length : -1, N3 = f ? c.length : -1, G3 = s5 ? 0 : o4.length - 1, Z4 = f ? 0 : c.length - 1; ; ) {
        var st2 = o4[G3].compareTo(c[Z4]);
        if (st2 !== 0) return st2;
        var ut2 = (G3 += g) === M3, Ot2 = (Z4 += _) === N3;
        if (ut2 && !Ot2) return -1;
        if (!ut2 && Ot2) return 1;
        if (ut2 && Ot2) return 0;
      }
    };
    var ts2 = H$3(function() {
      this._edges = new Et2(), this._ocaMap = new x2();
    }, "Hn");
    ts2.prototype.print = function(o4) {
      o4.print("MULTILINESTRING ( ");
      for (var s5 = 0; s5 < this._edges.size(); s5++) {
        var c = this._edges.get(s5);
        s5 > 0 && o4.print(","), o4.print("(");
        for (var f = c.getCoordinates(), g = 0; g < f.length; g++) g > 0 && o4.print(","), o4.print(f[g].x + " " + f[g].y);
        o4.println(")");
      }
      o4.print(")  ");
    }, ts2.prototype.addAll = function(o4) {
      for (var s5 = o4.iterator(); s5.hasNext(); ) this.add(s5.next());
    }, ts2.prototype.findEdgeIndex = function(o4) {
      for (var s5 = 0; s5 < this._edges.size(); s5++) if (this._edges.get(s5).equals(o4)) return s5;
      return -1;
    }, ts2.prototype.iterator = function() {
      return this._edges.iterator();
    }, ts2.prototype.getEdges = function() {
      return this._edges;
    }, ts2.prototype.get = function(o4) {
      return this._edges.get(o4);
    }, ts2.prototype.findEqualEdge = function(o4) {
      var s5 = new Ll2(o4.getCoordinates());
      return this._ocaMap.get(s5);
    }, ts2.prototype.add = function(o4) {
      this._edges.add(o4);
      var s5 = new Ll2(o4.getCoordinates());
      this._ocaMap.put(s5, o4);
    }, ts2.prototype.interfaces_ = function() {
      return [];
    }, ts2.prototype.getClass = function() {
      return ts2;
    };
    var $u2 = H$3(function() {
    }, "Wn");
    $u2.prototype.processIntersections = function(o4, s5, c, f) {
    }, $u2.prototype.isDone = function() {
    }, $u2.prototype.interfaces_ = function() {
      return [];
    }, $u2.prototype.getClass = function() {
      return $u2;
    };
    var yo2 = H$3(function() {
      this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
      var o4 = arguments[0];
      this._li = o4;
    }, "Kn");
    yo2.prototype.isTrivialIntersection = function(o4, s5, c, f) {
      if (o4 === c && this._li.getIntersectionNum() === 1) {
        if (yo2.isAdjacentSegments(s5, f)) return true;
        if (o4.isClosed()) {
          var g = o4.size() - 1;
          if (s5 === 0 && f === g || f === 0 && s5 === g) return true;
        }
      }
      return false;
    }, yo2.prototype.getProperIntersectionPoint = function() {
      return this._properIntersectionPoint;
    }, yo2.prototype.hasProperInteriorIntersection = function() {
      return this._hasProperInterior;
    }, yo2.prototype.getLineIntersector = function() {
      return this._li;
    }, yo2.prototype.hasProperIntersection = function() {
      return this._hasProper;
    }, yo2.prototype.processIntersections = function(o4, s5, c, f) {
      if (o4 === c && s5 === f) return null;
      this.numTests++;
      var g = o4.getCoordinates()[s5], _ = o4.getCoordinates()[s5 + 1], M3 = c.getCoordinates()[f], N3 = c.getCoordinates()[f + 1];
      this._li.computeIntersection(g, _, M3, N3), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(o4, s5, c, f) || (this._hasIntersection = true, o4.addIntersections(this._li, s5, 0), c.addIntersections(this._li, f, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
    }, yo2.prototype.hasIntersection = function() {
      return this._hasIntersection;
    }, yo2.prototype.isDone = function() {
      return false;
    }, yo2.prototype.hasInteriorIntersection = function() {
      return this._hasInterior;
    }, yo2.prototype.interfaces_ = function() {
      return [$u2];
    }, yo2.prototype.getClass = function() {
      return yo2;
    }, yo2.isAdjacentSegments = function(o4, s5) {
      return Math.abs(o4 - s5) === 1;
    };
    var bs2 = H$3(function() {
      this.coord = null, this.segmentIndex = null, this.dist = null;
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
      this.coord = new F3(o4), this.segmentIndex = s5, this.dist = c;
    }, "Jn");
    bs2.prototype.getSegmentIndex = function() {
      return this.segmentIndex;
    }, bs2.prototype.getCoordinate = function() {
      return this.coord;
    }, bs2.prototype.print = function(o4) {
      o4.print(this.coord), o4.print(" seg # = " + this.segmentIndex), o4.println(" dist = " + this.dist);
    }, bs2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this.compare(s5.segmentIndex, s5.dist);
    }, bs2.prototype.isEndPoint = function(o4) {
      return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === o4;
    }, bs2.prototype.toString = function() {
      return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
    }, bs2.prototype.getDistance = function() {
      return this.dist;
    }, bs2.prototype.compare = function(o4, s5) {
      return this.segmentIndex < o4 ? -1 : this.segmentIndex > o4 ? 1 : this.dist < s5 ? -1 : this.dist > s5 ? 1 : 0;
    }, bs2.prototype.interfaces_ = function() {
      return [j3];
    }, bs2.prototype.getClass = function() {
      return bs2;
    };
    var Ws3 = H$3(function() {
      this._nodeMap = new x2(), this.edge = null;
      var o4 = arguments[0];
      this.edge = o4;
    }, "Qn");
    Ws3.prototype.print = function(o4) {
      o4.println("Intersections:");
      for (var s5 = this.iterator(); s5.hasNext(); ) s5.next().print(o4);
    }, Ws3.prototype.iterator = function() {
      return this._nodeMap.values().iterator();
    }, Ws3.prototype.addSplitEdges = function(o4) {
      this.addEndpoints();
      for (var s5 = this.iterator(), c = s5.next(); s5.hasNext(); ) {
        var f = s5.next(), g = this.createSplitEdge(c, f);
        o4.add(g), c = f;
      }
    }, Ws3.prototype.addEndpoints = function() {
      var o4 = this.edge.pts.length - 1;
      this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[o4], o4, 0);
    }, Ws3.prototype.createSplitEdge = function(o4, s5) {
      var c = s5.segmentIndex - o4.segmentIndex + 2, f = this.edge.pts[s5.segmentIndex], g = s5.dist > 0 || !s5.coord.equals2D(f);
      g || c--;
      var _ = new Array(c).fill(null), M3 = 0;
      _[M3++] = new F3(o4.coord);
      for (var N3 = o4.segmentIndex + 1; N3 <= s5.segmentIndex; N3++) _[M3++] = this.edge.pts[N3];
      return g && (_[M3] = s5.coord), new O02(_, new _r2(this.edge._label));
    }, Ws3.prototype.add = function(o4, s5, c) {
      var f = new bs2(o4, s5, c), g = this._nodeMap.get(f);
      return g !== null ? g : (this._nodeMap.put(f, f), f);
    }, Ws3.prototype.isIntersection = function(o4) {
      for (var s5 = this.iterator(); s5.hasNext(); ) if (s5.next().coord.equals(o4)) return true;
      return false;
    }, Ws3.prototype.interfaces_ = function() {
      return [];
    }, Ws3.prototype.getClass = function() {
      return Ws3;
    };
    var Ju2 = H$3(function() {
    }, "Zn");
    Ju2.prototype.getChainStartIndices = function(o4) {
      var s5 = 0, c = new Et2();
      c.add(new dt2(s5));
      do {
        var f = this.findChainEnd(o4, s5);
        c.add(new dt2(f)), s5 = f;
      } while (s5 < o4.length - 1);
      return Ju2.toIntArray(c);
    }, Ju2.prototype.findChainEnd = function(o4, s5) {
      for (var c = wr2.quadrant(o4[s5], o4[s5 + 1]), f = s5 + 1; f < o4.length && wr2.quadrant(o4[f - 1], o4[f]) === c; ) f++;
      return f - 1;
    }, Ju2.prototype.interfaces_ = function() {
      return [];
    }, Ju2.prototype.getClass = function() {
      return Ju2;
    }, Ju2.toIntArray = function(o4) {
      for (var s5 = new Array(o4.size()).fill(null), c = 0; c < s5.length; c++) s5[c] = o4.get(c).intValue();
      return s5;
    };
    var Fa2 = H$3(function() {
      this.e = null, this.pts = null, this.startIndex = null, this.env1 = new Ct2(), this.env2 = new Ct2();
      var o4 = arguments[0];
      this.e = o4, this.pts = o4.getCoordinates();
      var s5 = new Ju2();
      this.startIndex = s5.getChainStartIndices(this.pts);
    }, "$n");
    Fa2.prototype.getCoordinates = function() {
      return this.pts;
    }, Fa2.prototype.getMaxX = function(o4) {
      var s5 = this.pts[this.startIndex[o4]].x, c = this.pts[this.startIndex[o4 + 1]].x;
      return s5 > c ? s5 : c;
    }, Fa2.prototype.getMinX = function(o4) {
      var s5 = this.pts[this.startIndex[o4]].x, c = this.pts[this.startIndex[o4 + 1]].x;
      return s5 < c ? s5 : c;
    }, Fa2.prototype.computeIntersectsForChain = function() {
      if (arguments.length === 4) {
        var o4 = arguments[0], s5 = arguments[1], c = arguments[2], f = arguments[3];
        this.computeIntersectsForChain(this.startIndex[o4], this.startIndex[o4 + 1], s5, s5.startIndex[c], s5.startIndex[c + 1], f);
      } else if (arguments.length === 6) {
        var g = arguments[0], _ = arguments[1], M3 = arguments[2], N3 = arguments[3], G3 = arguments[4], Z4 = arguments[5], st2 = this.pts[g], ut2 = this.pts[_], Ot2 = M3.pts[N3], Dt2 = M3.pts[G3];
        if (_ - g == 1 && G3 - N3 == 1) return Z4.addIntersections(this.e, g, M3.e, N3), null;
        if (this.env1.init(st2, ut2), this.env2.init(Ot2, Dt2), !this.env1.intersects(this.env2)) return null;
        var Bt2 = Math.trunc((g + _) / 2), Wt2 = Math.trunc((N3 + G3) / 2);
        g < Bt2 && (N3 < Wt2 && this.computeIntersectsForChain(g, Bt2, M3, N3, Wt2, Z4), Wt2 < G3 && this.computeIntersectsForChain(g, Bt2, M3, Wt2, G3, Z4)), Bt2 < _ && (N3 < Wt2 && this.computeIntersectsForChain(Bt2, _, M3, N3, Wt2, Z4), Wt2 < G3 && this.computeIntersectsForChain(Bt2, _, M3, Wt2, G3, Z4));
      }
    }, Fa2.prototype.getStartIndexes = function() {
      return this.startIndex;
    }, Fa2.prototype.computeIntersects = function(o4, s5) {
      for (var c = 0; c < this.startIndex.length - 1; c++) for (var f = 0; f < o4.startIndex.length - 1; f++) this.computeIntersectsForChain(c, o4, f, s5);
    }, Fa2.prototype.interfaces_ = function() {
      return [];
    }, Fa2.prototype.getClass = function() {
      return Fa2;
    };
    var Yn2 = H$3(function o4() {
      this._depth = Array(2).fill().map(function() {
        return Array(3);
      });
      for (var s5 = 0; s5 < 2; s5++) for (var c = 0; c < 3; c++) this._depth[s5][c] = o4.NULL_VALUE;
    }, "t"), dw2 = { NULL_VALUE: { configurable: true } };
    Yn2.prototype.getDepth = function(o4, s5) {
      return this._depth[o4][s5];
    }, Yn2.prototype.setDepth = function(o4, s5, c) {
      this._depth[o4][s5] = c;
    }, Yn2.prototype.isNull = function() {
      if (arguments.length === 0) {
        for (var o4 = 0; o4 < 2; o4++) for (var s5 = 0; s5 < 3; s5++) if (this._depth[o4][s5] !== Yn2.NULL_VALUE) return false;
        return true;
      }
      if (arguments.length === 1) {
        var c = arguments[0];
        return this._depth[c][1] === Yn2.NULL_VALUE;
      }
      if (arguments.length === 2) {
        var f = arguments[0], g = arguments[1];
        return this._depth[f][g] === Yn2.NULL_VALUE;
      }
    }, Yn2.prototype.normalize = function() {
      for (var o4 = 0; o4 < 2; o4++) if (!this.isNull(o4)) {
        var s5 = this._depth[o4][1];
        this._depth[o4][2] < s5 && (s5 = this._depth[o4][2]), s5 < 0 && (s5 = 0);
        for (var c = 1; c < 3; c++) {
          var f = 0;
          this._depth[o4][c] > s5 && (f = 1), this._depth[o4][c] = f;
        }
      }
    }, Yn2.prototype.getDelta = function(o4) {
      return this._depth[o4][Tt2.RIGHT] - this._depth[o4][Tt2.LEFT];
    }, Yn2.prototype.getLocation = function(o4, s5) {
      return this._depth[o4][s5] <= 0 ? H5.EXTERIOR : H5.INTERIOR;
    }, Yn2.prototype.toString = function() {
      return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
    }, Yn2.prototype.add = function() {
      if (arguments.length === 1) for (var o4 = arguments[0], s5 = 0; s5 < 2; s5++) for (var c = 1; c < 3; c++) {
        var f = o4.getLocation(s5, c);
        f !== H5.EXTERIOR && f !== H5.INTERIOR || (this.isNull(s5, c) ? this._depth[s5][c] = Yn2.depthAtLocation(f) : this._depth[s5][c] += Yn2.depthAtLocation(f));
      }
      else if (arguments.length === 3) {
        var g = arguments[0], _ = arguments[1];
        arguments[2] === H5.INTERIOR && this._depth[g][_]++;
      }
    }, Yn2.prototype.interfaces_ = function() {
      return [];
    }, Yn2.prototype.getClass = function() {
      return Yn2;
    }, Yn2.depthAtLocation = function(o4) {
      return o4 === H5.EXTERIOR ? 0 : o4 === H5.INTERIOR ? 1 : Yn2.NULL_VALUE;
    }, dw2.NULL_VALUE.get = function() {
      return -1;
    }, Object.defineProperties(Yn2, dw2);
    var O02 = (function(o4) {
      function s5() {
        if (o4.call(this), this.pts = null, this._env = null, this.eiList = new Ws3(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new Yn2(), this._depthDelta = 0, arguments.length === 1) {
          var c = arguments[0];
          s5.call(this, c, null);
        } else if (arguments.length === 2) {
          var f = arguments[0], g = arguments[1];
          this.pts = f, this._label = g;
        }
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.getDepth = function() {
        return this._depth;
      }, s5.prototype.getCollapsedEdge = function() {
        var c = new Array(2).fill(null);
        return c[0] = this.pts[0], c[1] = this.pts[1], new s5(c, _r2.toLineLabel(this._label));
      }, s5.prototype.isIsolated = function() {
        return this._isIsolated;
      }, s5.prototype.getCoordinates = function() {
        return this.pts;
      }, s5.prototype.setIsolated = function(c) {
        this._isIsolated = c;
      }, s5.prototype.setName = function(c) {
        this._name = c;
      }, s5.prototype.equals = function(c) {
        if (!(c instanceof s5)) return false;
        var f = c;
        if (this.pts.length !== f.pts.length) return false;
        for (var g = true, _ = true, M3 = this.pts.length, N3 = 0; N3 < this.pts.length; N3++) if (this.pts[N3].equals2D(f.pts[N3]) || (g = false), this.pts[N3].equals2D(f.pts[--M3]) || (_ = false), !g && !_) return false;
        return true;
      }, s5.prototype.getCoordinate = function() {
        if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
        if (arguments.length === 1) {
          var c = arguments[0];
          return this.pts[c];
        }
      }, s5.prototype.print = function(c) {
        c.print("edge " + this._name + ": "), c.print("LINESTRING (");
        for (var f = 0; f < this.pts.length; f++) f > 0 && c.print(","), c.print(this.pts[f].x + " " + this.pts[f].y);
        c.print(")  " + this._label + " " + this._depthDelta);
      }, s5.prototype.computeIM = function(c) {
        s5.updateIM(this._label, c);
      }, s5.prototype.isCollapsed = function() {
        return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]);
      }, s5.prototype.isClosed = function() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
      }, s5.prototype.getMaximumSegmentIndex = function() {
        return this.pts.length - 1;
      }, s5.prototype.getDepthDelta = function() {
        return this._depthDelta;
      }, s5.prototype.getNumPoints = function() {
        return this.pts.length;
      }, s5.prototype.printReverse = function(c) {
        c.print("edge " + this._name + ": ");
        for (var f = this.pts.length - 1; f >= 0; f--) c.print(this.pts[f] + " ");
        c.println("");
      }, s5.prototype.getMonotoneChainEdge = function() {
        return this._mce === null && (this._mce = new Fa2(this)), this._mce;
      }, s5.prototype.getEnvelope = function() {
        if (this._env === null) {
          this._env = new Ct2();
          for (var c = 0; c < this.pts.length; c++) this._env.expandToInclude(this.pts[c]);
        }
        return this._env;
      }, s5.prototype.addIntersection = function(c, f, g, _) {
        var M3 = new F3(c.getIntersection(_)), N3 = f, G3 = c.getEdgeDistance(g, _), Z4 = N3 + 1;
        if (Z4 < this.pts.length) {
          var st2 = this.pts[Z4];
          M3.equals2D(st2) && (N3 = Z4, G3 = 0);
        }
        this.eiList.add(M3, N3, G3);
      }, s5.prototype.toString = function() {
        var c = new St2();
        c.append("edge " + this._name + ": "), c.append("LINESTRING (");
        for (var f = 0; f < this.pts.length; f++) f > 0 && c.append(","), c.append(this.pts[f].x + " " + this.pts[f].y);
        return c.append(")  " + this._label + " " + this._depthDelta), c.toString();
      }, s5.prototype.isPointwiseEqual = function(c) {
        if (this.pts.length !== c.pts.length) return false;
        for (var f = 0; f < this.pts.length; f++) if (!this.pts[f].equals2D(c.pts[f])) return false;
        return true;
      }, s5.prototype.setDepthDelta = function(c) {
        this._depthDelta = c;
      }, s5.prototype.getEdgeIntersectionList = function() {
        return this.eiList;
      }, s5.prototype.addIntersections = function(c, f, g) {
        for (var _ = 0; _ < c.getIntersectionNum(); _++) this.addIntersection(c, f, g, _);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5.updateIM = function() {
        if (arguments.length !== 2) return o4.prototype.updateIM.apply(this, arguments);
        var c = arguments[0], f = arguments[1];
        f.setAtLeastIfValid(c.getLocation(0, Tt2.ON), c.getLocation(1, Tt2.ON), 1), c.isArea() && (f.setAtLeastIfValid(c.getLocation(0, Tt2.LEFT), c.getLocation(1, Tt2.LEFT), 2), f.setAtLeastIfValid(c.getLocation(0, Tt2.RIGHT), c.getLocation(1, Tt2.RIGHT), 2));
      }, s5;
    })(fo2), gi2 = H$3(function(o4) {
      this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new ts2(), this._bufParams = o4 || null;
    }, "ii");
    gi2.prototype.setWorkingPrecisionModel = function(o4) {
      this._workingPrecisionModel = o4;
    }, gi2.prototype.insertUniqueEdge = function(o4) {
      var s5 = this._edgeList.findEqualEdge(o4);
      if (s5 !== null) {
        var c = s5.getLabel(), f = o4.getLabel();
        s5.isPointwiseEqual(o4) || (f = new _r2(o4.getLabel())).flip(), c.merge(f);
        var g = gi2.depthDelta(f), _ = s5.getDepthDelta() + g;
        s5.setDepthDelta(_);
      } else this._edgeList.add(o4), o4.setDepthDelta(gi2.depthDelta(o4.getLabel()));
    }, gi2.prototype.buildSubgraphs = function(o4, s5) {
      for (var c = new Et2(), f = o4.iterator(); f.hasNext(); ) {
        var g = f.next(), _ = g.getRightmostCoordinate(), M3 = new op2(c).getDepth(_);
        g.computeDepth(M3), g.findResultEdges(), c.add(g), s5.add(g.getDirectedEdges(), g.getNodes());
      }
    }, gi2.prototype.createSubgraphs = function(o4) {
      for (var s5 = new Et2(), c = o4.getNodes().iterator(); c.hasNext(); ) {
        var f = c.next();
        if (!f.isVisited()) {
          var g = new di2();
          g.create(f), s5.add(g);
        }
      }
      return Qo2.sort(s5, Qo2.reverseOrder()), s5;
    }, gi2.prototype.createEmptyResultGeometry = function() {
      return this._geomFact.createPolygon();
    }, gi2.prototype.getNoder = function(o4) {
      if (this._workingNoder !== null) return this._workingNoder;
      var s5 = new z22(), c = new Ji2();
      return c.setPrecisionModel(o4), s5.setSegmentIntersector(new yo2(c)), s5;
    }, gi2.prototype.buffer = function(o4, s5) {
      var c = this._workingPrecisionModel;
      c === null && (c = o4.getPrecisionModel()), this._geomFact = o4.getFactory();
      var f = new Gi2(c, this._bufParams), g = new No2(o4, s5, f).getCurves();
      if (g.size() <= 0) return this.createEmptyResultGeometry();
      this.computeNodedEdges(g, c), this._graph = new Zr2(new fw2()), this._graph.addEdges(this._edgeList.getEdges());
      var _ = this.createSubgraphs(this._graph), M3 = new to2(this._geomFact);
      this.buildSubgraphs(_, M3);
      var N3 = M3.getPolygons();
      return N3.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(N3);
    }, gi2.prototype.computeNodedEdges = function(o4, s5) {
      var c = this.getNoder(s5);
      c.computeNodes(o4);
      for (var f = c.getNodedSubstrings().iterator(); f.hasNext(); ) {
        var g = f.next(), _ = g.getCoordinates();
        if (_.length !== 2 || !_[0].equals2D(_[1])) {
          var M3 = g.getData(), N3 = new O02(g.getCoordinates(), new _r2(M3));
          this.insertUniqueEdge(N3);
        }
      }
    }, gi2.prototype.setNoder = function(o4) {
      this._workingNoder = o4;
    }, gi2.prototype.interfaces_ = function() {
      return [];
    }, gi2.prototype.getClass = function() {
      return gi2;
    }, gi2.depthDelta = function(o4) {
      var s5 = o4.getLocation(0, Tt2.LEFT), c = o4.getLocation(0, Tt2.RIGHT);
      return s5 === H5.INTERIOR && c === H5.EXTERIOR ? 1 : s5 === H5.EXTERIOR && c === H5.INTERIOR ? -1 : 0;
    }, gi2.convertSegStrings = function(o4) {
      for (var s5 = new ge2(), c = new Et2(); o4.hasNext(); ) {
        var f = o4.next(), g = s5.createLineString(f.getCoordinates());
        c.add(g);
      }
      return s5.buildGeometry(c);
    };
    var Al3 = H$3(function() {
      if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        this._noder = o4, this._scaleFactor = s5, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
      } else if (arguments.length === 4) {
        var c = arguments[0], f = arguments[1], g = arguments[2], _ = arguments[3];
        this._noder = c, this._scaleFactor = f, this._offsetX = g, this._offsetY = _, this._isScaled = !this.isIntegerPrecision();
      }
    }, "ri");
    Al3.prototype.rescale = function() {
      if (ct2(arguments[0], Rr2)) for (var o4 = arguments[0].iterator(); o4.hasNext(); ) {
        var s5 = o4.next();
        this.rescale(s5.getCoordinates());
      }
      else if (arguments[0] instanceof Array) {
        for (var c = arguments[0], f = 0; f < c.length; f++) c[f].x = c[f].x / this._scaleFactor + this._offsetX, c[f].y = c[f].y / this._scaleFactor + this._offsetY;
        c.length === 2 && c[0].equals2D(c[1]) && Nt2.out.println(c);
      }
    }, Al3.prototype.scale = function() {
      if (ct2(arguments[0], Rr2)) {
        for (var o4 = arguments[0], s5 = new Et2(), c = o4.iterator(); c.hasNext(); ) {
          var f = c.next();
          s5.add(new ln2(this.scale(f.getCoordinates()), f.getData()));
        }
        return s5;
      }
      if (arguments[0] instanceof Array) {
        for (var g = arguments[0], _ = new Array(g.length).fill(null), M3 = 0; M3 < g.length; M3++) _[M3] = new F3(Math.round((g[M3].x - this._offsetX) * this._scaleFactor), Math.round((g[M3].y - this._offsetY) * this._scaleFactor), g[M3].z);
        return O4.removeRepeatedPoints(_);
      }
    }, Al3.prototype.isIntegerPrecision = function() {
      return this._scaleFactor === 1;
    }, Al3.prototype.getNodedSubstrings = function() {
      var o4 = this._noder.getNodedSubstrings();
      return this._isScaled && this.rescale(o4), o4;
    }, Al3.prototype.computeNodes = function(o4) {
      var s5 = o4;
      this._isScaled && (s5 = this.scale(o4)), this._noder.computeNodes(s5);
    }, Al3.prototype.interfaces_ = function() {
      return [Wu2];
    }, Al3.prototype.getClass = function() {
      return Al3;
    };
    var xs2 = H$3(function() {
      this._li = new Ji2(), this._segStrings = null;
      var o4 = arguments[0];
      this._segStrings = o4;
    }, "oi"), mw2 = { fact: { configurable: true } };
    xs2.prototype.checkEndPtVertexIntersections = function() {
      if (arguments.length === 0) for (var o4 = this._segStrings.iterator(); o4.hasNext(); ) {
        var s5 = o4.next().getCoordinates();
        this.checkEndPtVertexIntersections(s5[0], this._segStrings), this.checkEndPtVertexIntersections(s5[s5.length - 1], this._segStrings);
      }
      else if (arguments.length === 2) {
        for (var c = arguments[0], f = arguments[1].iterator(); f.hasNext(); ) for (var g = f.next().getCoordinates(), _ = 1; _ < g.length - 1; _++) if (g[_].equals(c)) throw new Wr2("found endpt/interior pt intersection at index " + _ + " :pt " + c);
      }
    }, xs2.prototype.checkInteriorIntersections = function() {
      if (arguments.length === 0) for (var o4 = this._segStrings.iterator(); o4.hasNext(); ) for (var s5 = o4.next(), c = this._segStrings.iterator(); c.hasNext(); ) {
        var f = c.next();
        this.checkInteriorIntersections(s5, f);
      }
      else if (arguments.length === 2) for (var g = arguments[0], _ = arguments[1], M3 = g.getCoordinates(), N3 = _.getCoordinates(), G3 = 0; G3 < M3.length - 1; G3++) for (var Z4 = 0; Z4 < N3.length - 1; Z4++) this.checkInteriorIntersections(g, G3, _, Z4);
      else if (arguments.length === 4) {
        var st2 = arguments[0], ut2 = arguments[1], Ot2 = arguments[2], Dt2 = arguments[3];
        if (st2 === Ot2 && ut2 === Dt2) return null;
        var Bt2 = st2.getCoordinates()[ut2], Wt2 = st2.getCoordinates()[ut2 + 1], Cr2 = Ot2.getCoordinates()[Dt2], vn2 = Ot2.getCoordinates()[Dt2 + 1];
        if (this._li.computeIntersection(Bt2, Wt2, Cr2, vn2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, Bt2, Wt2) || this.hasInteriorIntersection(this._li, Cr2, vn2))) throw new Wr2("found non-noded intersection at " + Bt2 + "-" + Wt2 + " and " + Cr2 + "-" + vn2);
      }
    }, xs2.prototype.checkValid = function() {
      this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
    }, xs2.prototype.checkCollapses = function() {
      if (arguments.length === 0) for (var o4 = this._segStrings.iterator(); o4.hasNext(); ) {
        var s5 = o4.next();
        this.checkCollapses(s5);
      }
      else if (arguments.length === 1) for (var c = arguments[0].getCoordinates(), f = 0; f < c.length - 2; f++) this.checkCollapse(c[f], c[f + 1], c[f + 2]);
    }, xs2.prototype.hasInteriorIntersection = function(o4, s5, c) {
      for (var f = 0; f < o4.getIntersectionNum(); f++) {
        var g = o4.getIntersection(f);
        if (!g.equals(s5) && !g.equals(c)) return true;
      }
      return false;
    }, xs2.prototype.checkCollapse = function(o4, s5, c) {
      if (o4.equals(c)) throw new Wr2("found non-noded collapse at " + xs2.fact.createLineString([o4, s5, c]));
    }, xs2.prototype.interfaces_ = function() {
      return [];
    }, xs2.prototype.getClass = function() {
      return xs2;
    }, mw2.fact.get = function() {
      return new ge2();
    }, Object.defineProperties(xs2, mw2);
    var Vi2 = H$3(function() {
      this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
      if (this._originalPt = o4, this._pt = o4, this._scaleFactor = s5, this._li = c, s5 <= 0) throw new A3("Scale factor must be non-zero");
      s5 !== 1 && (this._pt = new F3(this.scale(o4.x), this.scale(o4.y)), this._p0Scaled = new F3(), this._p1Scaled = new F3()), this.initCorners(this._pt);
    }, "ai"), gw2 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
    Vi2.prototype.intersectsScaled = function(o4, s5) {
      var c = Math.min(o4.x, s5.x), f = Math.max(o4.x, s5.x), g = Math.min(o4.y, s5.y), _ = Math.max(o4.y, s5.y), M3 = this._maxx < c || this._minx > f || this._maxy < g || this._miny > _;
      if (M3) return false;
      var N3 = this.intersectsToleranceSquare(o4, s5);
      return Yt2.isTrue(!(M3 && N3), "Found bad envelope test"), N3;
    }, Vi2.prototype.initCorners = function(o4) {
      this._minx = o4.x - 0.5, this._maxx = o4.x + 0.5, this._miny = o4.y - 0.5, this._maxy = o4.y + 0.5, this._corner[0] = new F3(this._maxx, this._maxy), this._corner[1] = new F3(this._minx, this._maxy), this._corner[2] = new F3(this._minx, this._miny), this._corner[3] = new F3(this._maxx, this._miny);
    }, Vi2.prototype.intersects = function(o4, s5) {
      return this._scaleFactor === 1 ? this.intersectsScaled(o4, s5) : (this.copyScaled(o4, this._p0Scaled), this.copyScaled(s5, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
    }, Vi2.prototype.scale = function(o4) {
      return Math.round(o4 * this._scaleFactor);
    }, Vi2.prototype.getCoordinate = function() {
      return this._originalPt;
    }, Vi2.prototype.copyScaled = function(o4, s5) {
      s5.x = this.scale(o4.x), s5.y = this.scale(o4.y);
    }, Vi2.prototype.getSafeEnvelope = function() {
      if (this._safeEnv === null) {
        var o4 = Vi2.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
        this._safeEnv = new Ct2(this._originalPt.x - o4, this._originalPt.x + o4, this._originalPt.y - o4, this._originalPt.y + o4);
      }
      return this._safeEnv;
    }, Vi2.prototype.intersectsPixelClosure = function(o4, s5) {
      return this._li.computeIntersection(o4, s5, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(o4, s5, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(o4, s5, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(o4, s5, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
    }, Vi2.prototype.intersectsToleranceSquare = function(o4, s5) {
      var c = false, f = false;
      return this._li.computeIntersection(o4, s5, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(o4, s5, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (c = true), this._li.computeIntersection(o4, s5, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (f = true), this._li.computeIntersection(o4, s5, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!c || !f) || !!o4.equals(this._pt) || !!s5.equals(this._pt))));
    }, Vi2.prototype.addSnappedNode = function(o4, s5) {
      var c = o4.getCoordinate(s5), f = o4.getCoordinate(s5 + 1);
      return !!this.intersects(c, f) && (o4.addIntersection(this.getCoordinate(), s5), true);
    }, Vi2.prototype.interfaces_ = function() {
      return [];
    }, Vi2.prototype.getClass = function() {
      return Vi2;
    }, gw2.SAFE_ENV_EXPANSION_FACTOR.get = function() {
      return 0.75;
    }, Object.defineProperties(Vi2, gw2);
    var sg3 = H$3(function() {
      this.tempEnv1 = new Ct2(), this.selectedSegment = new Ut2();
    }, "li");
    sg3.prototype.select = function() {
      if (arguments.length !== 1) {
        if (arguments.length === 2) {
          var o4 = arguments[0], s5 = arguments[1];
          o4.getLineSegment(s5, this.selectedSegment), this.select(this.selectedSegment);
        }
      }
    }, sg3.prototype.interfaces_ = function() {
      return [];
    }, sg3.prototype.getClass = function() {
      return sg3;
    };
    var Af3 = H$3(function() {
      this._index = null;
      var o4 = arguments[0];
      this._index = o4;
    }, "ci"), yw2 = { HotPixelSnapAction: { configurable: true } };
    Af3.prototype.snap = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return this.snap(o4, null, -1);
      }
      if (arguments.length === 3) {
        var s5 = arguments[0], c = arguments[1], f = arguments[2], g = s5.getSafeEnvelope(), _ = new vw2(s5, c, f);
        return this._index.query(g, { interfaces_: H$3(function() {
          return [Ol2];
        }, "interfaces_"), visitItem: H$3(function(M3) {
          M3.select(g, _);
        }, "visitItem") }), _.isNodeAdded();
      }
    }, Af3.prototype.interfaces_ = function() {
      return [];
    }, Af3.prototype.getClass = function() {
      return Af3;
    }, yw2.HotPixelSnapAction.get = function() {
      return vw2;
    }, Object.defineProperties(Af3, yw2);
    var vw2 = (function(o4) {
      function s5() {
        o4.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
        var c = arguments[0], f = arguments[1], g = arguments[2];
        this._hotPixel = c, this._parentEdge = f, this._hotPixelVertexIndex = g;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.isNodeAdded = function() {
        return this._isNodeAdded;
      }, s5.prototype.select = function() {
        if (arguments.length !== 2) return o4.prototype.select.apply(this, arguments);
        var c = arguments[0], f = arguments[1], g = c.getContext();
        if (this._parentEdge !== null && g === this._parentEdge && f === this._hotPixelVertexIndex) return null;
        this._isNodeAdded = this._hotPixel.addSnappedNode(g, f);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(sg3), sp2 = H$3(function() {
      this._li = null, this._interiorIntersections = null;
      var o4 = arguments[0];
      this._li = o4, this._interiorIntersections = new Et2();
    }, "fi");
    sp2.prototype.processIntersections = function(o4, s5, c, f) {
      if (o4 === c && s5 === f) return null;
      var g = o4.getCoordinates()[s5], _ = o4.getCoordinates()[s5 + 1], M3 = c.getCoordinates()[f], N3 = c.getCoordinates()[f + 1];
      if (this._li.computeIntersection(g, _, M3, N3), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
        for (var G3 = 0; G3 < this._li.getIntersectionNum(); G3++) this._interiorIntersections.add(this._li.getIntersection(G3));
        o4.addIntersections(this._li, s5, 0), c.addIntersections(this._li, f, 1);
      }
    }, sp2.prototype.isDone = function() {
      return false;
    }, sp2.prototype.getInteriorIntersections = function() {
      return this._interiorIntersections;
    }, sp2.prototype.interfaces_ = function() {
      return [$u2];
    }, sp2.prototype.getClass = function() {
      return sp2;
    };
    var Zs3 = H$3(function() {
      this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
      var o4 = arguments[0];
      this._pm = o4, this._li = new Ji2(), this._li.setPrecisionModel(o4), this._scaleFactor = o4.getScale();
    }, "gi");
    Zs3.prototype.checkCorrectness = function(o4) {
      var s5 = ln2.getNodedSubstrings(o4), c = new xs2(s5);
      try {
        c.checkValid();
      } catch (f) {
        if (!(f instanceof vr2)) throw f;
        f.printStackTrace();
      }
    }, Zs3.prototype.getNodedSubstrings = function() {
      return ln2.getNodedSubstrings(this._nodedSegStrings);
    }, Zs3.prototype.snapRound = function(o4, s5) {
      var c = this.findInteriorIntersections(o4, s5);
      this.computeIntersectionSnaps(c), this.computeVertexSnaps(o4);
    }, Zs3.prototype.findInteriorIntersections = function(o4, s5) {
      var c = new sp2(s5);
      return this._noder.setSegmentIntersector(c), this._noder.computeNodes(o4), c.getInteriorIntersections();
    }, Zs3.prototype.computeVertexSnaps = function() {
      if (ct2(arguments[0], Rr2)) for (var o4 = arguments[0].iterator(); o4.hasNext(); ) {
        var s5 = o4.next();
        this.computeVertexSnaps(s5);
      }
      else if (arguments[0] instanceof ln2) for (var c = arguments[0], f = c.getCoordinates(), g = 0; g < f.length; g++) {
        var _ = new Vi2(f[g], this._scaleFactor, this._li);
        this._pointSnapper.snap(_, c, g) && c.addIntersection(f[g], g);
      }
    }, Zs3.prototype.computeNodes = function(o4) {
      this._nodedSegStrings = o4, this._noder = new z22(), this._pointSnapper = new Af3(this._noder.getIndex()), this.snapRound(o4, this._li);
    }, Zs3.prototype.computeIntersectionSnaps = function(o4) {
      for (var s5 = o4.iterator(); s5.hasNext(); ) {
        var c = s5.next(), f = new Vi2(c, this._scaleFactor, this._li);
        this._pointSnapper.snap(f);
      }
    }, Zs3.prototype.interfaces_ = function() {
      return [Wu2];
    }, Zs3.prototype.getClass = function() {
      return Zs3;
    };
    var qn3 = H$3(function() {
      if (this._argGeom = null, this._distance = null, this._bufParams = new er2(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
        var o4 = arguments[0];
        this._argGeom = o4;
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        this._argGeom = s5, this._bufParams = c;
      }
    }, "di"), Nf3 = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
    qn3.prototype.bufferFixedPrecision = function(o4) {
      var s5 = new Al3(new Zs3(new tr2(1)), o4.getScale()), c = new gi2(this._bufParams);
      c.setWorkingPrecisionModel(o4), c.setNoder(s5), this._resultGeometry = c.buffer(this._argGeom, this._distance);
    }, qn3.prototype.bufferReducedPrecision = function() {
      var o4 = this;
      if (arguments.length === 0) {
        for (var s5 = qn3.MAX_PRECISION_DIGITS; s5 >= 0; s5--) {
          try {
            o4.bufferReducedPrecision(s5);
          } catch (_) {
            if (!(_ instanceof Na2)) throw _;
            o4._saveException = _;
          }
          if (o4._resultGeometry !== null) return null;
        }
        throw this._saveException;
      }
      if (arguments.length === 1) {
        var c = arguments[0], f = qn3.precisionScaleFactor(this._argGeom, this._distance, c), g = new tr2(f);
        this.bufferFixedPrecision(g);
      }
    }, qn3.prototype.computeGeometry = function() {
      if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
      var o4 = this._argGeom.getFactory().getPrecisionModel();
      o4.getType() === tr2.FIXED ? this.bufferFixedPrecision(o4) : this.bufferReducedPrecision();
    }, qn3.prototype.setQuadrantSegments = function(o4) {
      this._bufParams.setQuadrantSegments(o4);
    }, qn3.prototype.bufferOriginalPrecision = function() {
      try {
        var o4 = new gi2(this._bufParams);
        this._resultGeometry = o4.buffer(this._argGeom, this._distance);
      } catch (s5) {
        if (!(s5 instanceof Wr2)) throw s5;
        this._saveException = s5;
      }
    }, qn3.prototype.getResultGeometry = function(o4) {
      return this._distance = o4, this.computeGeometry(), this._resultGeometry;
    }, qn3.prototype.setEndCapStyle = function(o4) {
      this._bufParams.setEndCapStyle(o4);
    }, qn3.prototype.interfaces_ = function() {
      return [];
    }, qn3.prototype.getClass = function() {
      return qn3;
    }, qn3.bufferOp = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        return new qn3(o4).getResultGeometry(s5);
      }
      if (arguments.length === 3) {
        if (Number.isInteger(arguments[2]) && arguments[0] instanceof Jt2 && typeof arguments[1] == "number") {
          var c = arguments[0], f = arguments[1], g = arguments[2], _ = new qn3(c);
          return _.setQuadrantSegments(g), _.getResultGeometry(f);
        }
        if (arguments[2] instanceof er2 && arguments[0] instanceof Jt2 && typeof arguments[1] == "number") {
          var M3 = arguments[0], N3 = arguments[1], G3 = arguments[2];
          return new qn3(M3, G3).getResultGeometry(N3);
        }
      } else if (arguments.length === 4) {
        var Z4 = arguments[0], st2 = arguments[1], ut2 = arguments[2], Ot2 = arguments[3], Dt2 = new qn3(Z4);
        return Dt2.setQuadrantSegments(ut2), Dt2.setEndCapStyle(Ot2), Dt2.getResultGeometry(st2);
      }
    }, qn3.precisionScaleFactor = function(o4, s5, c) {
      var f = o4.getEnvelopeInternal(), g = ft2.max(Math.abs(f.getMaxX()), Math.abs(f.getMaxY()), Math.abs(f.getMinX()), Math.abs(f.getMinY())) + 2 * (s5 > 0 ? s5 : 0), _ = c - Math.trunc(Math.log(g) / Math.log(10) + 1);
      return Math.pow(10, _);
    }, Nf3.CAP_ROUND.get = function() {
      return er2.CAP_ROUND;
    }, Nf3.CAP_BUTT.get = function() {
      return er2.CAP_FLAT;
    }, Nf3.CAP_FLAT.get = function() {
      return er2.CAP_FLAT;
    }, Nf3.CAP_SQUARE.get = function() {
      return er2.CAP_SQUARE;
    }, Nf3.MAX_PRECISION_DIGITS.get = function() {
      return 12;
    }, Object.defineProperties(qn3, Nf3);
    var yi2 = H$3(function() {
      this._pt = [new F3(), new F3()], this._distance = L3.NaN, this._isNull = true;
    }, "_i");
    yi2.prototype.getCoordinates = function() {
      return this._pt;
    }, yi2.prototype.getCoordinate = function(o4) {
      return this._pt[o4];
    }, yi2.prototype.setMinimum = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.setMinimum(o4._pt[0], o4._pt[1]);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        if (this._isNull) return this.initialize(s5, c), null;
        var f = s5.distance(c);
        f < this._distance && this.initialize(s5, c, f);
      }
    }, yi2.prototype.initialize = function() {
      if (arguments.length === 0) this._isNull = true;
      else if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        this._pt[0].setCoordinate(o4), this._pt[1].setCoordinate(s5), this._distance = o4.distance(s5), this._isNull = false;
      } else if (arguments.length === 3) {
        var c = arguments[0], f = arguments[1], g = arguments[2];
        this._pt[0].setCoordinate(c), this._pt[1].setCoordinate(f), this._distance = g, this._isNull = false;
      }
    }, yi2.prototype.getDistance = function() {
      return this._distance;
    }, yi2.prototype.setMaximum = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.setMaximum(o4._pt[0], o4._pt[1]);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        if (this._isNull) return this.initialize(s5, c), null;
        var f = s5.distance(c);
        f > this._distance && this.initialize(s5, c, f);
      }
    }, yi2.prototype.interfaces_ = function() {
      return [];
    }, yi2.prototype.getClass = function() {
      return yi2;
    };
    var $s3 = H$3(function() {
    }, "mi");
    $s3.prototype.interfaces_ = function() {
      return [];
    }, $s3.prototype.getClass = function() {
      return $s3;
    }, $s3.computeDistance = function() {
      if (arguments[2] instanceof yi2 && arguments[0] instanceof ye2 && arguments[1] instanceof F3) for (var o4 = arguments[0], s5 = arguments[1], c = arguments[2], f = o4.getCoordinates(), g = new Ut2(), _ = 0; _ < f.length - 1; _++) {
        g.setCoordinates(f[_], f[_ + 1]);
        var M3 = g.closestPoint(s5);
        c.setMinimum(M3, s5);
      }
      else if (arguments[2] instanceof yi2 && arguments[0] instanceof xr2 && arguments[1] instanceof F3) {
        var N3 = arguments[0], G3 = arguments[1], Z4 = arguments[2];
        $s3.computeDistance(N3.getExteriorRing(), G3, Z4);
        for (var st2 = 0; st2 < N3.getNumInteriorRing(); st2++) $s3.computeDistance(N3.getInteriorRingN(st2), G3, Z4);
      } else if (arguments[2] instanceof yi2 && arguments[0] instanceof Jt2 && arguments[1] instanceof F3) {
        var ut2 = arguments[0], Ot2 = arguments[1], Dt2 = arguments[2];
        if (ut2 instanceof ye2) $s3.computeDistance(ut2, Ot2, Dt2);
        else if (ut2 instanceof xr2) $s3.computeDistance(ut2, Ot2, Dt2);
        else if (ut2 instanceof te2) for (var Bt2 = ut2, Wt2 = 0; Wt2 < Bt2.getNumGeometries(); Wt2++) {
          var Cr2 = Bt2.getGeometryN(Wt2);
          $s3.computeDistance(Cr2, Ot2, Dt2);
        }
        else Dt2.setMinimum(ut2.getCoordinate(), Ot2);
      } else if (arguments[2] instanceof yi2 && arguments[0] instanceof Ut2 && arguments[1] instanceof F3) {
        var vn2 = arguments[0], _i3 = arguments[1], ta2 = arguments[2], Vl2 = vn2.closestPoint(_i3);
        ta2.setMinimum(Vl2, _i3);
      }
    };
    var Ku2 = H$3(function(o4) {
      this._maxPtDist = new yi2(), this._inputGeom = o4 || null;
    }, "vi"), H22 = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
    Ku2.prototype.computeMaxMidpointDistance = function(o4) {
      var s5 = new Nl2(this._inputGeom);
      o4.apply(s5), this._maxPtDist.setMaximum(s5.getMaxPointDistance());
    }, Ku2.prototype.computeMaxVertexDistance = function(o4) {
      var s5 = new ap2(this._inputGeom);
      o4.apply(s5), this._maxPtDist.setMaximum(s5.getMaxPointDistance());
    }, Ku2.prototype.findDistance = function(o4) {
      return this.computeMaxVertexDistance(o4), this.computeMaxMidpointDistance(o4), this._maxPtDist.getDistance();
    }, Ku2.prototype.getDistancePoints = function() {
      return this._maxPtDist;
    }, Ku2.prototype.interfaces_ = function() {
      return [];
    }, Ku2.prototype.getClass = function() {
      return Ku2;
    }, H22.MaxPointDistanceFilter.get = function() {
      return ap2;
    }, H22.MaxMidpointDistanceFilter.get = function() {
      return Nl2;
    }, Object.defineProperties(Ku2, H22);
    var ap2 = H$3(function(o4) {
      this._maxPtDist = new yi2(), this._minPtDist = new yi2(), this._geom = o4 || null;
    }, "Ei");
    ap2.prototype.filter = function(o4) {
      this._minPtDist.initialize(), $s3.computeDistance(this._geom, o4, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
    }, ap2.prototype.getMaxPointDistance = function() {
      return this._maxPtDist;
    }, ap2.prototype.interfaces_ = function() {
      return [Ai2];
    }, ap2.prototype.getClass = function() {
      return ap2;
    };
    var Nl2 = H$3(function(o4) {
      this._maxPtDist = new yi2(), this._minPtDist = new yi2(), this._geom = o4 || null;
    }, "xi");
    Nl2.prototype.filter = function(o4, s5) {
      if (s5 === 0) return null;
      var c = o4.getCoordinate(s5 - 1), f = o4.getCoordinate(s5), g = new F3((c.x + f.x) / 2, (c.y + f.y) / 2);
      this._minPtDist.initialize(), $s3.computeDistance(this._geom, g, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
    }, Nl2.prototype.isDone = function() {
      return false;
    }, Nl2.prototype.isGeometryChanged = function() {
      return false;
    }, Nl2.prototype.getMaxPointDistance = function() {
      return this._maxPtDist;
    }, Nl2.prototype.interfaces_ = function() {
      return [fe2];
    }, Nl2.prototype.getClass = function() {
      return Nl2;
    };
    var Ba2 = H$3(function(o4) {
      this._comps = o4 || null;
    }, "Ni");
    Ba2.prototype.filter = function(o4) {
      o4 instanceof xr2 && this._comps.add(o4);
    }, Ba2.prototype.interfaces_ = function() {
      return [qt2];
    }, Ba2.prototype.getClass = function() {
      return Ba2;
    }, Ba2.getPolygons = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return Ba2.getPolygons(o4, new Et2());
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return s5 instanceof xr2 ? c.add(s5) : s5 instanceof te2 && s5.apply(new Ba2(c)), c;
      }
    };
    var Wn2 = H$3(function() {
      if (this._lines = null, this._isForcedToLineString = false, arguments.length === 1) {
        var o4 = arguments[0];
        this._lines = o4;
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        this._lines = s5, this._isForcedToLineString = c;
      }
    }, "Ci");
    Wn2.prototype.filter = function(o4) {
      if (this._isForcedToLineString && o4 instanceof Fi3) {
        var s5 = o4.getFactory().createLineString(o4.getCoordinateSequence());
        return this._lines.add(s5), null;
      }
      o4 instanceof ye2 && this._lines.add(o4);
    }, Wn2.prototype.setForceToLineString = function(o4) {
      this._isForcedToLineString = o4;
    }, Wn2.prototype.interfaces_ = function() {
      return [Zo2];
    }, Wn2.prototype.getClass = function() {
      return Wn2;
    }, Wn2.getGeometry = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return o4.getFactory().buildGeometry(Wn2.getLines(o4));
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return s5.getFactory().buildGeometry(Wn2.getLines(s5, c));
      }
    }, Wn2.getLines = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return Wn2.getLines(o4, false);
      }
      if (arguments.length === 2) {
        if (ct2(arguments[0], Rr2) && ct2(arguments[1], Rr2)) {
          for (var s5 = arguments[0], c = arguments[1], f = s5.iterator(); f.hasNext(); ) {
            var g = f.next();
            Wn2.getLines(g, c);
          }
          return c;
        }
        if (arguments[0] instanceof Jt2 && typeof arguments[1] == "boolean") {
          var _ = arguments[0], M3 = arguments[1], N3 = new Et2();
          return _.apply(new Wn2(N3, M3)), N3;
        }
        if (arguments[0] instanceof Jt2 && ct2(arguments[1], Rr2)) {
          var G3 = arguments[0], Z4 = arguments[1];
          return G3 instanceof ye2 ? Z4.add(G3) : G3.apply(new Wn2(Z4)), Z4;
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[2] == "boolean" && ct2(arguments[0], Rr2) && ct2(arguments[1], Rr2)) {
          for (var st2 = arguments[0], ut2 = arguments[1], Ot2 = arguments[2], Dt2 = st2.iterator(); Dt2.hasNext(); ) {
            var Bt2 = Dt2.next();
            Wn2.getLines(Bt2, ut2, Ot2);
          }
          return ut2;
        }
        if (typeof arguments[2] == "boolean" && arguments[0] instanceof Jt2 && ct2(arguments[1], Rr2)) {
          var Wt2 = arguments[0], Cr2 = arguments[1], vn2 = arguments[2];
          return Wt2.apply(new Wn2(Cr2, vn2)), Cr2;
        }
      }
    };
    var es2 = H$3(function() {
      if (this._boundaryRule = Hn2.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, arguments.length !== 0) {
        if (arguments.length === 1) {
          var o4 = arguments[0];
          if (o4 === null) throw new A3("Rule must be non-null");
          this._boundaryRule = o4;
        }
      }
    }, "Si");
    es2.prototype.locateInternal = function() {
      if (arguments[0] instanceof F3 && arguments[1] instanceof xr2) {
        var o4 = arguments[0], s5 = arguments[1];
        if (s5.isEmpty()) return H5.EXTERIOR;
        var c = s5.getExteriorRing(), f = this.locateInPolygonRing(o4, c);
        if (f === H5.EXTERIOR) return H5.EXTERIOR;
        if (f === H5.BOUNDARY) return H5.BOUNDARY;
        for (var g = 0; g < s5.getNumInteriorRing(); g++) {
          var _ = s5.getInteriorRingN(g), M3 = this.locateInPolygonRing(o4, _);
          if (M3 === H5.INTERIOR) return H5.EXTERIOR;
          if (M3 === H5.BOUNDARY) return H5.BOUNDARY;
        }
        return H5.INTERIOR;
      }
      if (arguments[0] instanceof F3 && arguments[1] instanceof ye2) {
        var N3 = arguments[0], G3 = arguments[1];
        if (!G3.getEnvelopeInternal().intersects(N3)) return H5.EXTERIOR;
        var Z4 = G3.getCoordinates();
        return G3.isClosed() || !N3.equals(Z4[0]) && !N3.equals(Z4[Z4.length - 1]) ? wt2.isOnLine(N3, Z4) ? H5.INTERIOR : H5.EXTERIOR : H5.BOUNDARY;
      }
      if (arguments[0] instanceof F3 && arguments[1] instanceof Ur2) {
        var st2 = arguments[0];
        return arguments[1].getCoordinate().equals2D(st2) ? H5.INTERIOR : H5.EXTERIOR;
      }
    }, es2.prototype.locateInPolygonRing = function(o4, s5) {
      return s5.getEnvelopeInternal().intersects(o4) ? wt2.locatePointInRing(o4, s5.getCoordinates()) : H5.EXTERIOR;
    }, es2.prototype.intersects = function(o4, s5) {
      return this.locate(o4, s5) !== H5.EXTERIOR;
    }, es2.prototype.updateLocationInfo = function(o4) {
      o4 === H5.INTERIOR && (this._isIn = true), o4 === H5.BOUNDARY && this._numBoundaries++;
    }, es2.prototype.computeLocation = function(o4, s5) {
      if (s5 instanceof Ur2 && this.updateLocationInfo(this.locateInternal(o4, s5)), s5 instanceof ye2) this.updateLocationInfo(this.locateInternal(o4, s5));
      else if (s5 instanceof xr2) this.updateLocationInfo(this.locateInternal(o4, s5));
      else if (s5 instanceof Tr2) for (var c = s5, f = 0; f < c.getNumGeometries(); f++) {
        var g = c.getGeometryN(f);
        this.updateLocationInfo(this.locateInternal(o4, g));
      }
      else if (s5 instanceof Jo2) for (var _ = s5, M3 = 0; M3 < _.getNumGeometries(); M3++) {
        var N3 = _.getGeometryN(M3);
        this.updateLocationInfo(this.locateInternal(o4, N3));
      }
      else if (s5 instanceof te2) for (var G3 = new qs3(s5); G3.hasNext(); ) {
        var Z4 = G3.next();
        Z4 !== s5 && this.computeLocation(o4, Z4);
      }
    }, es2.prototype.locate = function(o4, s5) {
      return s5.isEmpty() ? H5.EXTERIOR : s5 instanceof ye2 ? this.locateInternal(o4, s5) : s5 instanceof xr2 ? this.locateInternal(o4, s5) : (this._isIn = false, this._numBoundaries = 0, this.computeLocation(o4, s5), this._boundaryRule.isInBoundary(this._numBoundaries) ? H5.BOUNDARY : this._numBoundaries > 0 || this._isIn ? H5.INTERIOR : H5.EXTERIOR);
    }, es2.prototype.interfaces_ = function() {
      return [];
    }, es2.prototype.getClass = function() {
      return es2;
    };
    var vi2 = H$3(function o4() {
      if (this._component = null, this._segIndex = null, this._pt = null, arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        o4.call(this, s5, o4.INSIDE_AREA, c);
      } else if (arguments.length === 3) {
        var f = arguments[0], g = arguments[1], _ = arguments[2];
        this._component = f, this._segIndex = g, this._pt = _;
      }
    }, "t"), bw2 = { INSIDE_AREA: { configurable: true } };
    vi2.prototype.isInsideArea = function() {
      return this._segIndex === vi2.INSIDE_AREA;
    }, vi2.prototype.getCoordinate = function() {
      return this._pt;
    }, vi2.prototype.getGeometryComponent = function() {
      return this._component;
    }, vi2.prototype.getSegmentIndex = function() {
      return this._segIndex;
    }, vi2.prototype.interfaces_ = function() {
      return [];
    }, vi2.prototype.getClass = function() {
      return vi2;
    }, bw2.INSIDE_AREA.get = function() {
      return -1;
    }, Object.defineProperties(vi2, bw2);
    var kl2 = H$3(function(o4) {
      this._pts = o4 || null;
    }, "wi");
    kl2.prototype.filter = function(o4) {
      o4 instanceof Ur2 && this._pts.add(o4);
    }, kl2.prototype.interfaces_ = function() {
      return [qt2];
    }, kl2.prototype.getClass = function() {
      return kl2;
    }, kl2.getPoints = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return o4 instanceof Ur2 ? Qo2.singletonList(o4) : kl2.getPoints(o4, new Et2());
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return s5 instanceof Ur2 ? c.add(s5) : s5 instanceof te2 && s5.apply(new kl2(c)), c;
      }
    };
    var lp2 = H$3(function() {
      this._locations = null;
      var o4 = arguments[0];
      this._locations = o4;
    }, "Oi");
    lp2.prototype.filter = function(o4) {
      (o4 instanceof Ur2 || o4 instanceof ye2 || o4 instanceof xr2) && this._locations.add(new vi2(o4, 0, o4.getCoordinate()));
    }, lp2.prototype.interfaces_ = function() {
      return [qt2];
    }, lp2.prototype.getClass = function() {
      return lp2;
    }, lp2.getLocations = function(o4) {
      var s5 = new Et2();
      return o4.apply(new lp2(s5)), s5;
    };
    var Zn3 = H$3(function() {
      if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new es2(), this._minDistanceLocation = null, this._minDistance = L3.MAX_VALUE, arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        this._geom = [o4, s5], this._terminateDistance = 0;
      } else if (arguments.length === 3) {
        var c = arguments[0], f = arguments[1], g = arguments[2];
        this._geom = new Array(2).fill(null), this._geom[0] = c, this._geom[1] = f, this._terminateDistance = g;
      }
    }, "Ti");
    Zn3.prototype.computeContainmentDistance = function() {
      if (arguments.length === 0) {
        var o4 = new Array(2).fill(null);
        if (this.computeContainmentDistance(0, o4), this._minDistance <= this._terminateDistance) return null;
        this.computeContainmentDistance(1, o4);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1], f = 1 - s5, g = Ba2.getPolygons(this._geom[s5]);
        if (g.size() > 0) {
          var _ = lp2.getLocations(this._geom[f]);
          if (this.computeContainmentDistance(_, g, c), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[f] = c[0], this._minDistanceLocation[s5] = c[1], null;
        }
      } else if (arguments.length === 3) {
        if (arguments[2] instanceof Array && ct2(arguments[0], ki2) && ct2(arguments[1], ki2)) {
          for (var M3 = arguments[0], N3 = arguments[1], G3 = arguments[2], Z4 = 0; Z4 < M3.size(); Z4++) for (var st2 = M3.get(Z4), ut2 = 0; ut2 < N3.size(); ut2++) if (this.computeContainmentDistance(st2, N3.get(ut2), G3), this._minDistance <= this._terminateDistance) return null;
        } else if (arguments[2] instanceof Array && arguments[0] instanceof vi2 && arguments[1] instanceof xr2) {
          var Ot2 = arguments[0], Dt2 = arguments[1], Bt2 = arguments[2], Wt2 = Ot2.getCoordinate();
          if (H5.EXTERIOR !== this._ptLocator.locate(Wt2, Dt2)) return this._minDistance = 0, Bt2[0] = Ot2, Bt2[1] = new vi2(Dt2, Wt2), null;
        }
      }
    }, Zn3.prototype.computeMinDistanceLinesPoints = function(o4, s5, c) {
      for (var f = 0; f < o4.size(); f++) for (var g = o4.get(f), _ = 0; _ < s5.size(); _++) {
        var M3 = s5.get(_);
        if (this.computeMinDistance(g, M3, c), this._minDistance <= this._terminateDistance) return null;
      }
    }, Zn3.prototype.computeFacetDistance = function() {
      var o4 = new Array(2).fill(null), s5 = Wn2.getLines(this._geom[0]), c = Wn2.getLines(this._geom[1]), f = kl2.getPoints(this._geom[0]), g = kl2.getPoints(this._geom[1]);
      return this.computeMinDistanceLines(s5, c, o4), this.updateMinDistance(o4, false), this._minDistance <= this._terminateDistance ? null : (o4[0] = null, o4[1] = null, this.computeMinDistanceLinesPoints(s5, g, o4), this.updateMinDistance(o4, false), this._minDistance <= this._terminateDistance ? null : (o4[0] = null, o4[1] = null, this.computeMinDistanceLinesPoints(c, f, o4), this.updateMinDistance(o4, true), this._minDistance <= this._terminateDistance ? null : (o4[0] = null, o4[1] = null, this.computeMinDistancePoints(f, g, o4), void this.updateMinDistance(o4, false))));
    }, Zn3.prototype.nearestLocations = function() {
      return this.computeMinDistance(), this._minDistanceLocation;
    }, Zn3.prototype.updateMinDistance = function(o4, s5) {
      if (o4[0] === null) return null;
      s5 ? (this._minDistanceLocation[0] = o4[1], this._minDistanceLocation[1] = o4[0]) : (this._minDistanceLocation[0] = o4[0], this._minDistanceLocation[1] = o4[1]);
    }, Zn3.prototype.nearestPoints = function() {
      return this.computeMinDistance(), [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
    }, Zn3.prototype.computeMinDistance = function() {
      if (arguments.length === 0) {
        if (this._minDistanceLocation !== null || (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)) return null;
        this.computeFacetDistance();
      } else if (arguments.length === 3) {
        if (arguments[2] instanceof Array && arguments[0] instanceof ye2 && arguments[1] instanceof Ur2) {
          var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
          if (o4.getEnvelopeInternal().distance(s5.getEnvelopeInternal()) > this._minDistance) return null;
          for (var f = o4.getCoordinates(), g = s5.getCoordinate(), _ = 0; _ < f.length - 1; _++) {
            var M3 = wt2.distancePointLine(g, f[_], f[_ + 1]);
            if (M3 < this._minDistance) {
              this._minDistance = M3;
              var N3 = new Ut2(f[_], f[_ + 1]).closestPoint(g);
              c[0] = new vi2(o4, _, N3), c[1] = new vi2(s5, 0, g);
            }
            if (this._minDistance <= this._terminateDistance) return null;
          }
        } else if (arguments[2] instanceof Array && arguments[0] instanceof ye2 && arguments[1] instanceof ye2) {
          var G3 = arguments[0], Z4 = arguments[1], st2 = arguments[2];
          if (G3.getEnvelopeInternal().distance(Z4.getEnvelopeInternal()) > this._minDistance) return null;
          for (var ut2 = G3.getCoordinates(), Ot2 = Z4.getCoordinates(), Dt2 = 0; Dt2 < ut2.length - 1; Dt2++) for (var Bt2 = 0; Bt2 < Ot2.length - 1; Bt2++) {
            var Wt2 = wt2.distanceLineLine(ut2[Dt2], ut2[Dt2 + 1], Ot2[Bt2], Ot2[Bt2 + 1]);
            if (Wt2 < this._minDistance) {
              this._minDistance = Wt2;
              var Cr2 = new Ut2(ut2[Dt2], ut2[Dt2 + 1]), vn2 = new Ut2(Ot2[Bt2], Ot2[Bt2 + 1]), _i3 = Cr2.closestPoints(vn2);
              st2[0] = new vi2(G3, Dt2, _i3[0]), st2[1] = new vi2(Z4, Bt2, _i3[1]);
            }
            if (this._minDistance <= this._terminateDistance) return null;
          }
        }
      }
    }, Zn3.prototype.computeMinDistancePoints = function(o4, s5, c) {
      for (var f = 0; f < o4.size(); f++) for (var g = o4.get(f), _ = 0; _ < s5.size(); _++) {
        var M3 = s5.get(_), N3 = g.getCoordinate().distance(M3.getCoordinate());
        if (N3 < this._minDistance && (this._minDistance = N3, c[0] = new vi2(g, 0, g.getCoordinate()), c[1] = new vi2(M3, 0, M3.getCoordinate())), this._minDistance <= this._terminateDistance) return null;
      }
    }, Zn3.prototype.distance = function() {
      if (this._geom[0] === null || this._geom[1] === null) throw new A3("null geometries are not supported");
      return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
    }, Zn3.prototype.computeMinDistanceLines = function(o4, s5, c) {
      for (var f = 0; f < o4.size(); f++) for (var g = o4.get(f), _ = 0; _ < s5.size(); _++) {
        var M3 = s5.get(_);
        if (this.computeMinDistance(g, M3, c), this._minDistance <= this._terminateDistance) return null;
      }
    }, Zn3.prototype.interfaces_ = function() {
      return [];
    }, Zn3.prototype.getClass = function() {
      return Zn3;
    }, Zn3.distance = function(o4, s5) {
      return new Zn3(o4, s5).distance();
    }, Zn3.isWithinDistance = function(o4, s5, c) {
      return new Zn3(o4, s5, c).distance() <= c;
    }, Zn3.nearestPoints = function(o4, s5) {
      return new Zn3(o4, s5).nearestPoints();
    };
    var ii2 = H$3(function() {
      this._pt = [new F3(), new F3()], this._distance = L3.NaN, this._isNull = true;
    }, "Ri");
    ii2.prototype.getCoordinates = function() {
      return this._pt;
    }, ii2.prototype.getCoordinate = function(o4) {
      return this._pt[o4];
    }, ii2.prototype.setMinimum = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.setMinimum(o4._pt[0], o4._pt[1]);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        if (this._isNull) return this.initialize(s5, c), null;
        var f = s5.distance(c);
        f < this._distance && this.initialize(s5, c, f);
      }
    }, ii2.prototype.initialize = function() {
      if (arguments.length === 0) this._isNull = true;
      else if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        this._pt[0].setCoordinate(o4), this._pt[1].setCoordinate(s5), this._distance = o4.distance(s5), this._isNull = false;
      } else if (arguments.length === 3) {
        var c = arguments[0], f = arguments[1], g = arguments[2];
        this._pt[0].setCoordinate(c), this._pt[1].setCoordinate(f), this._distance = g, this._isNull = false;
      }
    }, ii2.prototype.toString = function() {
      return br2.toLineString(this._pt[0], this._pt[1]);
    }, ii2.prototype.getDistance = function() {
      return this._distance;
    }, ii2.prototype.setMaximum = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        this.setMaximum(o4._pt[0], o4._pt[1]);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        if (this._isNull) return this.initialize(s5, c), null;
        var f = s5.distance(c);
        f > this._distance && this.initialize(s5, c, f);
      }
    }, ii2.prototype.interfaces_ = function() {
      return [];
    }, ii2.prototype.getClass = function() {
      return ii2;
    };
    var _s2 = H$3(function() {
    }, "Pi");
    _s2.prototype.interfaces_ = function() {
      return [];
    }, _s2.prototype.getClass = function() {
      return _s2;
    }, _s2.computeDistance = function() {
      if (arguments[2] instanceof ii2 && arguments[0] instanceof ye2 && arguments[1] instanceof F3) for (var o4 = arguments[0], s5 = arguments[1], c = arguments[2], f = new Ut2(), g = o4.getCoordinates(), _ = 0; _ < g.length - 1; _++) {
        f.setCoordinates(g[_], g[_ + 1]);
        var M3 = f.closestPoint(s5);
        c.setMinimum(M3, s5);
      }
      else if (arguments[2] instanceof ii2 && arguments[0] instanceof xr2 && arguments[1] instanceof F3) {
        var N3 = arguments[0], G3 = arguments[1], Z4 = arguments[2];
        _s2.computeDistance(N3.getExteriorRing(), G3, Z4);
        for (var st2 = 0; st2 < N3.getNumInteriorRing(); st2++) _s2.computeDistance(N3.getInteriorRingN(st2), G3, Z4);
      } else if (arguments[2] instanceof ii2 && arguments[0] instanceof Jt2 && arguments[1] instanceof F3) {
        var ut2 = arguments[0], Ot2 = arguments[1], Dt2 = arguments[2];
        if (ut2 instanceof ye2) _s2.computeDistance(ut2, Ot2, Dt2);
        else if (ut2 instanceof xr2) _s2.computeDistance(ut2, Ot2, Dt2);
        else if (ut2 instanceof te2) for (var Bt2 = ut2, Wt2 = 0; Wt2 < Bt2.getNumGeometries(); Wt2++) {
          var Cr2 = Bt2.getGeometryN(Wt2);
          _s2.computeDistance(Cr2, Ot2, Dt2);
        }
        else Dt2.setMinimum(ut2.getCoordinate(), Ot2);
      } else if (arguments[2] instanceof ii2 && arguments[0] instanceof Ut2 && arguments[1] instanceof F3) {
        var vn2 = arguments[0], _i3 = arguments[1], ta2 = arguments[2], Vl2 = vn2.closestPoint(_i3);
        ta2.setMinimum(Vl2, _i3);
      }
    };
    var ko2 = H$3(function() {
      this._g0 = null, this._g1 = null, this._ptDist = new ii2(), this._densifyFrac = 0;
      var o4 = arguments[0], s5 = arguments[1];
      this._g0 = o4, this._g1 = s5;
    }, "Di"), X22 = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
    ko2.prototype.getCoordinates = function() {
      return this._ptDist.getCoordinates();
    }, ko2.prototype.setDensifyFraction = function(o4) {
      if (o4 > 1 || o4 <= 0) throw new A3("Fraction is not in range (0.0 - 1.0]");
      this._densifyFrac = o4;
    }, ko2.prototype.compute = function(o4, s5) {
      this.computeOrientedDistance(o4, s5, this._ptDist), this.computeOrientedDistance(s5, o4, this._ptDist);
    }, ko2.prototype.distance = function() {
      return this.compute(this._g0, this._g1), this._ptDist.getDistance();
    }, ko2.prototype.computeOrientedDistance = function(o4, s5, c) {
      var f = new up2(s5);
      if (o4.apply(f), c.setMaximum(f.getMaxPointDistance()), this._densifyFrac > 0) {
        var g = new Rl2(s5, this._densifyFrac);
        o4.apply(g), c.setMaximum(g.getMaxPointDistance());
      }
    }, ko2.prototype.orientedDistance = function() {
      return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
    }, ko2.prototype.interfaces_ = function() {
      return [];
    }, ko2.prototype.getClass = function() {
      return ko2;
    }, ko2.distance = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1];
        return new ko2(o4, s5).distance();
      }
      if (arguments.length === 3) {
        var c = arguments[0], f = arguments[1], g = arguments[2], _ = new ko2(c, f);
        return _.setDensifyFraction(g), _.distance();
      }
    }, X22.MaxPointDistanceFilter.get = function() {
      return up2;
    }, X22.MaxDensifiedByFractionDistanceFilter.get = function() {
      return Rl2;
    }, Object.defineProperties(ko2, X22);
    var up2 = H$3(function() {
      this._maxPtDist = new ii2(), this._minPtDist = new ii2(), this._euclideanDist = new _s2(), this._geom = null;
      var o4 = arguments[0];
      this._geom = o4;
    }, "Ai");
    up2.prototype.filter = function(o4) {
      this._minPtDist.initialize(), _s2.computeDistance(this._geom, o4, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
    }, up2.prototype.getMaxPointDistance = function() {
      return this._maxPtDist;
    }, up2.prototype.interfaces_ = function() {
      return [Ai2];
    }, up2.prototype.getClass = function() {
      return up2;
    };
    var Rl2 = H$3(function() {
      this._maxPtDist = new ii2(), this._minPtDist = new ii2(), this._geom = null, this._numSubSegs = 0;
      var o4 = arguments[0], s5 = arguments[1];
      this._geom = o4, this._numSubSegs = Math.trunc(Math.round(1 / s5));
    }, "Fi");
    Rl2.prototype.filter = function(o4, s5) {
      if (s5 === 0) return null;
      for (var c = o4.getCoordinate(s5 - 1), f = o4.getCoordinate(s5), g = (f.x - c.x) / this._numSubSegs, _ = (f.y - c.y) / this._numSubSegs, M3 = 0; M3 < this._numSubSegs; M3++) {
        var N3 = c.x + M3 * g, G3 = c.y + M3 * _, Z4 = new F3(N3, G3);
        this._minPtDist.initialize(), _s2.computeDistance(this._geom, Z4, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
      }
    }, Rl2.prototype.isDone = function() {
      return false;
    }, Rl2.prototype.isGeometryChanged = function() {
      return false;
    }, Rl2.prototype.getMaxPointDistance = function() {
      return this._maxPtDist;
    }, Rl2.prototype.interfaces_ = function() {
      return [fe2];
    }, Rl2.prototype.getClass = function() {
      return Rl2;
    };
    var ro2 = H$3(function(o4, s5, c) {
      this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = true, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = o4 || null, this._bufDistance = s5 || null, this._result = c || null;
    }, "Gi"), Y22 = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
    ro2.prototype.checkMaximumDistance = function(o4, s5, c) {
      var f = new ko2(s5, o4);
      if (f.setDensifyFraction(0.25), this._maxDistanceFound = f.orientedDistance(), this._maxDistanceFound > c) {
        this._isValid = false;
        var g = f.getCoordinates();
        this._errorLocation = g[1], this._errorIndicator = o4.getFactory().createLineString(g), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + br2.toLineString(g[0], g[1]) + ")";
      }
    }, ro2.prototype.isValid = function() {
      var o4 = Math.abs(this._bufDistance), s5 = ro2.MAX_DISTANCE_DIFF_FRAC * o4;
      return this._minValidDistance = o4 - s5, this._maxValidDistance = o4 + s5, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), ro2.VERBOSE && Nt2.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
    }, ro2.prototype.checkNegativeValid = function() {
      if (!(this._input instanceof xr2 || this._input instanceof Jo2 || this._input instanceof te2)) return null;
      var o4 = this.getPolygonLines(this._input);
      if (this.checkMinimumDistance(o4, this._result, this._minValidDistance), !this._isValid) return null;
      this.checkMaximumDistance(o4, this._result, this._maxValidDistance);
    }, ro2.prototype.getErrorIndicator = function() {
      return this._errorIndicator;
    }, ro2.prototype.checkMinimumDistance = function(o4, s5, c) {
      var f = new Zn3(o4, s5, c);
      if (this._minDistanceFound = f.distance(), this._minDistanceFound < c) {
        this._isValid = false;
        var g = f.nearestPoints();
        this._errorLocation = f.nearestPoints()[1], this._errorIndicator = o4.getFactory().createLineString(g), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + br2.toLineString(g[0], g[1]) + " )";
      }
    }, ro2.prototype.checkPositiveValid = function() {
      var o4 = this._result.getBoundary();
      if (this.checkMinimumDistance(this._input, o4, this._minValidDistance), !this._isValid) return null;
      this.checkMaximumDistance(this._input, o4, this._maxValidDistance);
    }, ro2.prototype.getErrorLocation = function() {
      return this._errorLocation;
    }, ro2.prototype.getPolygonLines = function(o4) {
      for (var s5 = new Et2(), c = new Wn2(s5), f = Ba2.getPolygons(o4).iterator(); f.hasNext(); ) f.next().apply(c);
      return o4.getFactory().buildGeometry(s5);
    }, ro2.prototype.getErrorMessage = function() {
      return this._errMsg;
    }, ro2.prototype.interfaces_ = function() {
      return [];
    }, ro2.prototype.getClass = function() {
      return ro2;
    }, Y22.VERBOSE.get = function() {
      return false;
    }, Y22.MAX_DISTANCE_DIFF_FRAC.get = function() {
      return 0.012;
    }, Object.defineProperties(ro2, Y22);
    var $n2 = H$3(function(o4, s5, c) {
      this._isValid = true, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = o4 || null, this._distance = s5 || null, this._result = c || null;
    }, "Bi"), q22 = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
    $n2.prototype.isValid = function() {
      return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
    }, $n2.prototype.checkEnvelope = function() {
      if (this._distance < 0) return null;
      var o4 = this._distance * $n2.MAX_ENV_DIFF_FRAC;
      o4 === 0 && (o4 = 1e-3);
      var s5 = new Ct2(this._input.getEnvelopeInternal());
      s5.expandBy(this._distance);
      var c = new Ct2(this._result.getEnvelopeInternal());
      c.expandBy(o4), c.contains(s5) || (this._isValid = false, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(c)), this.report("Envelope");
    }, $n2.prototype.checkDistance = function() {
      var o4 = new ro2(this._input, this._distance, this._result);
      o4.isValid() || (this._isValid = false, this._errorMsg = o4.getErrorMessage(), this._errorLocation = o4.getErrorLocation(), this._errorIndicator = o4.getErrorIndicator()), this.report("Distance");
    }, $n2.prototype.checkArea = function() {
      var o4 = this._input.getArea(), s5 = this._result.getArea();
      this._distance > 0 && o4 > s5 && (this._isValid = false, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && o4 < s5 && (this._isValid = false, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
    }, $n2.prototype.checkPolygonal = function() {
      this._result instanceof xr2 || this._result instanceof Jo2 || (this._isValid = false), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
    }, $n2.prototype.getErrorIndicator = function() {
      return this._errorIndicator;
    }, $n2.prototype.getErrorLocation = function() {
      return this._errorLocation;
    }, $n2.prototype.checkExpectedEmpty = function() {
      return this._input.getDimension() >= 2 || this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = false, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
    }, $n2.prototype.report = function(o4) {
      if (!$n2.VERBOSE) return null;
      Nt2.out.println("Check " + o4 + ": " + (this._isValid ? "passed" : "FAILED"));
    }, $n2.prototype.getErrorMessage = function() {
      return this._errorMsg;
    }, $n2.prototype.interfaces_ = function() {
      return [];
    }, $n2.prototype.getClass = function() {
      return $n2;
    }, $n2.isValidMsg = function(o4, s5, c) {
      var f = new $n2(o4, s5, c);
      return f.isValid() ? null : f.getErrorMessage();
    }, $n2.isValid = function(o4, s5, c) {
      return !!new $n2(o4, s5, c).isValid();
    }, q22.VERBOSE.get = function() {
      return false;
    }, q22.MAX_ENV_DIFF_FRAC.get = function() {
      return 0.012;
    }, Object.defineProperties($n2, q22);
    var Cs2 = H$3(function() {
      this._pts = null, this._data = null;
      var o4 = arguments[0], s5 = arguments[1];
      this._pts = o4, this._data = s5;
    }, "Ui");
    Cs2.prototype.getCoordinates = function() {
      return this._pts;
    }, Cs2.prototype.size = function() {
      return this._pts.length;
    }, Cs2.prototype.getCoordinate = function(o4) {
      return this._pts[o4];
    }, Cs2.prototype.isClosed = function() {
      return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }, Cs2.prototype.getSegmentOctant = function(o4) {
      return o4 === this._pts.length - 1 ? -1 : np2.octant(this.getCoordinate(o4), this.getCoordinate(o4 + 1));
    }, Cs2.prototype.setData = function(o4) {
      this._data = o4;
    }, Cs2.prototype.getData = function() {
      return this._data;
    }, Cs2.prototype.toString = function() {
      return br2.toLineString(new an2(this._pts));
    }, Cs2.prototype.interfaces_ = function() {
      return [Ys2];
    }, Cs2.prototype.getClass = function() {
      return Cs2;
    };
    var Rn2 = H$3(function() {
      this._findAllIntersections = false, this._isCheckEndSegmentsOnly = false, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Et2(), this._intersectionCount = 0, this._keepIntersections = true;
      var o4 = arguments[0];
      this._li = o4, this._interiorIntersection = null;
    }, "zi");
    Rn2.prototype.getInteriorIntersection = function() {
      return this._interiorIntersection;
    }, Rn2.prototype.setCheckEndSegmentsOnly = function(o4) {
      this._isCheckEndSegmentsOnly = o4;
    }, Rn2.prototype.getIntersectionSegments = function() {
      return this._intSegments;
    }, Rn2.prototype.count = function() {
      return this._intersectionCount;
    }, Rn2.prototype.getIntersections = function() {
      return this._intersections;
    }, Rn2.prototype.setFindAllIntersections = function(o4) {
      this._findAllIntersections = o4;
    }, Rn2.prototype.setKeepIntersections = function(o4) {
      this._keepIntersections = o4;
    }, Rn2.prototype.processIntersections = function(o4, s5, c, f) {
      if (!this._findAllIntersections && this.hasIntersection() || o4 === c && s5 === f || this._isCheckEndSegmentsOnly && !(this.isEndSegment(o4, s5) || this.isEndSegment(c, f))) return null;
      var g = o4.getCoordinates()[s5], _ = o4.getCoordinates()[s5 + 1], M3 = c.getCoordinates()[f], N3 = c.getCoordinates()[f + 1];
      this._li.computeIntersection(g, _, M3, N3), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = g, this._intSegments[1] = _, this._intSegments[2] = M3, this._intSegments[3] = N3, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
    }, Rn2.prototype.isEndSegment = function(o4, s5) {
      return s5 === 0 || s5 >= o4.size() - 2;
    }, Rn2.prototype.hasIntersection = function() {
      return this._interiorIntersection !== null;
    }, Rn2.prototype.isDone = function() {
      return !this._findAllIntersections && this._interiorIntersection !== null;
    }, Rn2.prototype.interfaces_ = function() {
      return [$u2];
    }, Rn2.prototype.getClass = function() {
      return Rn2;
    }, Rn2.createAllIntersectionsFinder = function(o4) {
      var s5 = new Rn2(o4);
      return s5.setFindAllIntersections(true), s5;
    }, Rn2.createAnyIntersectionFinder = function(o4) {
      return new Rn2(o4);
    }, Rn2.createIntersectionCounter = function(o4) {
      var s5 = new Rn2(o4);
      return s5.setFindAllIntersections(true), s5.setKeepIntersections(false), s5;
    };
    var rs2 = H$3(function() {
      this._li = new Ji2(), this._segStrings = null, this._findAllIntersections = false, this._segInt = null, this._isValid = true;
      var o4 = arguments[0];
      this._segStrings = o4;
    }, "Xi");
    rs2.prototype.execute = function() {
      if (this._segInt !== null) return null;
      this.checkInteriorIntersections();
    }, rs2.prototype.getIntersections = function() {
      return this._segInt.getIntersections();
    }, rs2.prototype.isValid = function() {
      return this.execute(), this._isValid;
    }, rs2.prototype.setFindAllIntersections = function(o4) {
      this._findAllIntersections = o4;
    }, rs2.prototype.checkInteriorIntersections = function() {
      this._isValid = true, this._segInt = new Rn2(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
      var o4 = new z22();
      if (o4.setSegmentIntersector(this._segInt), o4.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = false, null;
    }, rs2.prototype.checkValid = function() {
      if (this.execute(), !this._isValid) throw new Na2(this.getErrorMessage(), this._segInt.getInteriorIntersection());
    }, rs2.prototype.getErrorMessage = function() {
      if (this._isValid) return "no intersections found";
      var o4 = this._segInt.getIntersectionSegments();
      return "found non-noded intersection between " + br2.toLineString(o4[0], o4[1]) + " and " + br2.toLineString(o4[2], o4[3]);
    }, rs2.prototype.interfaces_ = function() {
      return [];
    }, rs2.prototype.getClass = function() {
      return rs2;
    }, rs2.computeIntersections = function(o4) {
      var s5 = new rs2(o4);
      return s5.setFindAllIntersections(true), s5.isValid(), s5.getIntersections();
    };
    var Qu2 = H$3(function o4() {
      this._nv = null;
      var s5 = arguments[0];
      this._nv = new rs2(o4.toSegmentStrings(s5));
    }, "t");
    Qu2.prototype.checkValid = function() {
      this._nv.checkValid();
    }, Qu2.prototype.interfaces_ = function() {
      return [];
    }, Qu2.prototype.getClass = function() {
      return Qu2;
    }, Qu2.toSegmentStrings = function(o4) {
      for (var s5 = new Et2(), c = o4.iterator(); c.hasNext(); ) {
        var f = c.next();
        s5.add(new Cs2(f.getCoordinates(), f));
      }
      return s5;
    }, Qu2.checkValid = function(o4) {
      new Qu2(o4).checkValid();
    };
    var cp2 = H$3(function(o4) {
      this._mapOp = o4;
    }, "ki");
    cp2.prototype.map = function(o4) {
      for (var s5 = new Et2(), c = 0; c < o4.getNumGeometries(); c++) {
        var f = this._mapOp.map(o4.getGeometryN(c));
        f.isEmpty() || s5.add(f);
      }
      return o4.getFactory().createGeometryCollection(ge2.toGeometryArray(s5));
    }, cp2.prototype.interfaces_ = function() {
      return [];
    }, cp2.prototype.getClass = function() {
      return cp2;
    }, cp2.map = function(o4, s5) {
      return new cp2(s5).map(o4);
    };
    var Ss2 = H$3(function() {
      this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Et2(), this._resultLineList = new Et2();
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
      this._op = o4, this._geometryFactory = s5, this._ptLocator = c;
    }, "ji");
    Ss2.prototype.collectLines = function(o4) {
      for (var s5 = this._op.getGraph().getEdgeEnds().iterator(); s5.hasNext(); ) {
        var c = s5.next();
        this.collectLineEdge(c, o4, this._lineEdgesList), this.collectBoundaryTouchEdge(c, o4, this._lineEdgesList);
      }
    }, Ss2.prototype.labelIsolatedLine = function(o4, s5) {
      var c = this._ptLocator.locate(o4.getCoordinate(), this._op.getArgGeometry(s5));
      o4.getLabel().setLocation(s5, c);
    }, Ss2.prototype.build = function(o4) {
      return this.findCoveredLineEdges(), this.collectLines(o4), this.buildLines(o4), this._resultLineList;
    }, Ss2.prototype.collectLineEdge = function(o4, s5, c) {
      var f = o4.getLabel(), g = o4.getEdge();
      o4.isLineEdge() && (o4.isVisited() || !oe2.isResultOfOp(f, s5) || g.isCovered() || (c.add(g), o4.setVisitedEdge(true)));
    }, Ss2.prototype.findCoveredLineEdges = function() {
      for (var o4 = this._op.getGraph().getNodes().iterator(); o4.hasNext(); ) o4.next().getEdges().findCoveredLineEdges();
      for (var s5 = this._op.getGraph().getEdgeEnds().iterator(); s5.hasNext(); ) {
        var c = s5.next(), f = c.getEdge();
        if (c.isLineEdge() && !f.isCoveredSet()) {
          var g = this._op.isCoveredByA(c.getCoordinate());
          f.setCovered(g);
        }
      }
    }, Ss2.prototype.labelIsolatedLines = function(o4) {
      for (var s5 = o4.iterator(); s5.hasNext(); ) {
        var c = s5.next(), f = c.getLabel();
        c.isIsolated() && (f.isNull(0) ? this.labelIsolatedLine(c, 0) : this.labelIsolatedLine(c, 1));
      }
    }, Ss2.prototype.buildLines = function(o4) {
      for (var s5 = this._lineEdgesList.iterator(); s5.hasNext(); ) {
        var c = s5.next(), f = this._geometryFactory.createLineString(c.getCoordinates());
        this._resultLineList.add(f), c.setInResult(true);
      }
    }, Ss2.prototype.collectBoundaryTouchEdge = function(o4, s5, c) {
      var f = o4.getLabel();
      return o4.isLineEdge() || o4.isVisited() || o4.isInteriorAreaEdge() || o4.getEdge().isInResult() ? null : (Yt2.isTrue(!(o4.isInResult() || o4.getSym().isInResult()) || !o4.getEdge().isInResult()), void (oe2.isResultOfOp(f, s5) && s5 === oe2.INTERSECTION && (c.add(o4.getEdge()), o4.setVisitedEdge(true))));
    }, Ss2.prototype.interfaces_ = function() {
      return [];
    }, Ss2.prototype.getClass = function() {
      return Ss2;
    };
    var pp2 = H$3(function() {
      this._op = null, this._geometryFactory = null, this._resultPointList = new Et2();
      var o4 = arguments[0], s5 = arguments[1];
      this._op = o4, this._geometryFactory = s5;
    }, "Hi");
    pp2.prototype.filterCoveredNodeToPoint = function(o4) {
      var s5 = o4.getCoordinate();
      if (!this._op.isCoveredByLA(s5)) {
        var c = this._geometryFactory.createPoint(s5);
        this._resultPointList.add(c);
      }
    }, pp2.prototype.extractNonCoveredResultNodes = function(o4) {
      for (var s5 = this._op.getGraph().getNodes().iterator(); s5.hasNext(); ) {
        var c = s5.next();
        if (!c.isInResult() && !c.isIncidentEdgeInResult() && (c.getEdges().getDegree() === 0 || o4 === oe2.INTERSECTION)) {
          var f = c.getLabel();
          oe2.isResultOfOp(f, o4) && this.filterCoveredNodeToPoint(c);
        }
      }
    }, pp2.prototype.build = function(o4) {
      return this.extractNonCoveredResultNodes(o4), this._resultPointList;
    }, pp2.prototype.interfaces_ = function() {
      return [];
    }, pp2.prototype.getClass = function() {
      return pp2;
    };
    var ji2 = H$3(function() {
      this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = true, this._preserveGeometryCollectionType = true, this._preserveCollections = false, this._preserveType = false;
    }, "Wi");
    ji2.prototype.transformPoint = function(o4, s5) {
      return this._factory.createPoint(this.transformCoordinates(o4.getCoordinateSequence(), o4));
    }, ji2.prototype.transformPolygon = function(o4, s5) {
      var c = true, f = this.transformLinearRing(o4.getExteriorRing(), o4);
      f !== null && f instanceof Fi3 && !f.isEmpty() || (c = false);
      for (var g = new Et2(), _ = 0; _ < o4.getNumInteriorRing(); _++) {
        var M3 = this.transformLinearRing(o4.getInteriorRingN(_), o4);
        M3 === null || M3.isEmpty() || (M3 instanceof Fi3 || (c = false), g.add(M3));
      }
      if (c) return this._factory.createPolygon(f, g.toArray([]));
      var N3 = new Et2();
      return f !== null && N3.add(f), N3.addAll(g), this._factory.buildGeometry(N3);
    }, ji2.prototype.createCoordinateSequence = function(o4) {
      return this._factory.getCoordinateSequenceFactory().create(o4);
    }, ji2.prototype.getInputGeometry = function() {
      return this._inputGeom;
    }, ji2.prototype.transformMultiLineString = function(o4, s5) {
      for (var c = new Et2(), f = 0; f < o4.getNumGeometries(); f++) {
        var g = this.transformLineString(o4.getGeometryN(f), o4);
        g !== null && (g.isEmpty() || c.add(g));
      }
      return this._factory.buildGeometry(c);
    }, ji2.prototype.transformCoordinates = function(o4, s5) {
      return this.copy(o4);
    }, ji2.prototype.transformLineString = function(o4, s5) {
      return this._factory.createLineString(this.transformCoordinates(o4.getCoordinateSequence(), o4));
    }, ji2.prototype.transformMultiPoint = function(o4, s5) {
      for (var c = new Et2(), f = 0; f < o4.getNumGeometries(); f++) {
        var g = this.transformPoint(o4.getGeometryN(f), o4);
        g !== null && (g.isEmpty() || c.add(g));
      }
      return this._factory.buildGeometry(c);
    }, ji2.prototype.transformMultiPolygon = function(o4, s5) {
      for (var c = new Et2(), f = 0; f < o4.getNumGeometries(); f++) {
        var g = this.transformPolygon(o4.getGeometryN(f), o4);
        g !== null && (g.isEmpty() || c.add(g));
      }
      return this._factory.buildGeometry(c);
    }, ji2.prototype.copy = function(o4) {
      return o4.copy();
    }, ji2.prototype.transformGeometryCollection = function(o4, s5) {
      for (var c = new Et2(), f = 0; f < o4.getNumGeometries(); f++) {
        var g = this.transform(o4.getGeometryN(f));
        g !== null && (this._pruneEmptyGeometry && g.isEmpty() || c.add(g));
      }
      return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(ge2.toGeometryArray(c)) : this._factory.buildGeometry(c);
    }, ji2.prototype.transform = function(o4) {
      if (this._inputGeom = o4, this._factory = o4.getFactory(), o4 instanceof Ur2) return this.transformPoint(o4, null);
      if (o4 instanceof Ki2) return this.transformMultiPoint(o4, null);
      if (o4 instanceof Fi3) return this.transformLinearRing(o4, null);
      if (o4 instanceof ye2) return this.transformLineString(o4, null);
      if (o4 instanceof Tr2) return this.transformMultiLineString(o4, null);
      if (o4 instanceof xr2) return this.transformPolygon(o4, null);
      if (o4 instanceof Jo2) return this.transformMultiPolygon(o4, null);
      if (o4 instanceof te2) return this.transformGeometryCollection(o4, null);
      throw new A3("Unknown Geometry subtype: " + o4.getClass().getName());
    }, ji2.prototype.transformLinearRing = function(o4, s5) {
      var c = this.transformCoordinates(o4.getCoordinateSequence(), o4);
      if (c === null) return this._factory.createLinearRing(null);
      var f = c.size();
      return f > 0 && f < 4 && !this._preserveType ? this._factory.createLineString(c) : this._factory.createLinearRing(c);
    }, ji2.prototype.interfaces_ = function() {
      return [];
    }, ji2.prototype.getClass = function() {
      return ji2;
    };
    var Js2 = H$3(function o4() {
      if (this._snapTolerance = 0, this._srcPts = null, this._seg = new Ut2(), this._allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof ye2 && typeof arguments[1] == "number") {
        var s5 = arguments[0], c = arguments[1];
        o4.call(this, s5.getCoordinates(), c);
      } else if (arguments[0] instanceof Array && typeof arguments[1] == "number") {
        var f = arguments[0], g = arguments[1];
        this._srcPts = f, this._isClosed = o4.isClosed(f), this._snapTolerance = g;
      }
    }, "t");
    Js2.prototype.snapVertices = function(o4, s5) {
      for (var c = this._isClosed ? o4.size() - 1 : o4.size(), f = 0; f < c; f++) {
        var g = o4.get(f), _ = this.findSnapForVertex(g, s5);
        _ !== null && (o4.set(f, new F3(_)), f === 0 && this._isClosed && o4.set(o4.size() - 1, new F3(_)));
      }
    }, Js2.prototype.findSnapForVertex = function(o4, s5) {
      for (var c = 0; c < s5.length; c++) {
        if (o4.equals2D(s5[c])) return null;
        if (o4.distance(s5[c]) < this._snapTolerance) return s5[c];
      }
      return null;
    }, Js2.prototype.snapTo = function(o4) {
      var s5 = new et2(this._srcPts);
      return this.snapVertices(s5, o4), this.snapSegments(s5, o4), s5.toCoordinateArray();
    }, Js2.prototype.snapSegments = function(o4, s5) {
      if (s5.length === 0) return null;
      var c = s5.length;
      s5[0].equals2D(s5[s5.length - 1]) && (c = s5.length - 1);
      for (var f = 0; f < c; f++) {
        var g = s5[f], _ = this.findSegmentIndexToSnap(g, o4);
        _ >= 0 && o4.add(_ + 1, new F3(g), false);
      }
    }, Js2.prototype.findSegmentIndexToSnap = function(o4, s5) {
      for (var c = L3.MAX_VALUE, f = -1, g = 0; g < s5.size() - 1; g++) {
        if (this._seg.p0 = s5.get(g), this._seg.p1 = s5.get(g + 1), this._seg.p0.equals2D(o4) || this._seg.p1.equals2D(o4)) {
          if (this._allowSnappingToSourceVertices) continue;
          return -1;
        }
        var _ = this._seg.distance(o4);
        _ < this._snapTolerance && _ < c && (c = _, f = g);
      }
      return f;
    }, Js2.prototype.setAllowSnappingToSourceVertices = function(o4) {
      this._allowSnappingToSourceVertices = o4;
    }, Js2.prototype.interfaces_ = function() {
      return [];
    }, Js2.prototype.getClass = function() {
      return Js2;
    }, Js2.isClosed = function(o4) {
      return !(o4.length <= 1) && o4[0].equals2D(o4[o4.length - 1]);
    };
    var un2 = H$3(function(o4) {
      this._srcGeom = o4 || null;
    }, "Ji"), xw2 = { SNAP_PRECISION_FACTOR: { configurable: true } };
    un2.prototype.snapTo = function(o4, s5) {
      var c = this.extractTargetCoordinates(o4);
      return new _w2(s5, c).transform(this._srcGeom);
    }, un2.prototype.snapToSelf = function(o4, s5) {
      var c = this.extractTargetCoordinates(this._srcGeom), f = new _w2(o4, c, true).transform(this._srcGeom), g = f;
      return s5 && ct2(g, Nn3) && (g = f.buffer(0)), g;
    }, un2.prototype.computeSnapTolerance = function(o4) {
      return this.computeMinimumSegmentLength(o4) / 10;
    }, un2.prototype.extractTargetCoordinates = function(o4) {
      for (var s5 = new I3(), c = o4.getCoordinates(), f = 0; f < c.length; f++) s5.add(c[f]);
      return s5.toArray(new Array(0).fill(null));
    }, un2.prototype.computeMinimumSegmentLength = function(o4) {
      for (var s5 = L3.MAX_VALUE, c = 0; c < o4.length - 1; c++) {
        var f = o4[c].distance(o4[c + 1]);
        f < s5 && (s5 = f);
      }
      return s5;
    }, un2.prototype.interfaces_ = function() {
      return [];
    }, un2.prototype.getClass = function() {
      return un2;
    }, un2.snap = function(o4, s5, c) {
      var f = new Array(2).fill(null), g = new un2(o4);
      f[0] = g.snapTo(s5, c);
      var _ = new un2(s5);
      return f[1] = _.snapTo(f[0], c), f;
    }, un2.computeOverlaySnapTolerance = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = un2.computeSizeBasedSnapTolerance(o4), c = o4.getPrecisionModel();
        if (c.getType() === tr2.FIXED) {
          var f = 1 / c.getScale() * 2 / 1.415;
          f > s5 && (s5 = f);
        }
        return s5;
      }
      if (arguments.length === 2) {
        var g = arguments[0], _ = arguments[1];
        return Math.min(un2.computeOverlaySnapTolerance(g), un2.computeOverlaySnapTolerance(_));
      }
    }, un2.computeSizeBasedSnapTolerance = function(o4) {
      var s5 = o4.getEnvelopeInternal();
      return Math.min(s5.getHeight(), s5.getWidth()) * un2.SNAP_PRECISION_FACTOR;
    }, un2.snapToSelf = function(o4, s5, c) {
      return new un2(o4).snapToSelf(s5, c);
    }, xw2.SNAP_PRECISION_FACTOR.get = function() {
      return 1e-9;
    }, Object.defineProperties(un2, xw2);
    var _w2 = (function(o4) {
      function s5(c, f, g) {
        o4.call(this), this._snapTolerance = c || null, this._snapPts = f || null, this._isSelfSnap = g !== void 0 && g;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.snapLine = function(c, f) {
        var g = new Js2(c, this._snapTolerance);
        return g.setAllowSnappingToSourceVertices(this._isSelfSnap), g.snapTo(f);
      }, s5.prototype.transformCoordinates = function(c, f) {
        var g = c.toCoordinateArray(), _ = this.snapLine(g, this._snapPts);
        return this._factory.getCoordinateSequenceFactory().create(_);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(ji2), bi3 = H$3(function() {
      this._isFirst = true, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
    }, "$i");
    bi3.prototype.getCommon = function() {
      return L3.longBitsToDouble(this._commonBits);
    }, bi3.prototype.add = function(o4) {
      var s5 = L3.doubleToLongBits(o4);
      if (this._isFirst) return this._commonBits = s5, this._commonSignExp = bi3.signExpBits(this._commonBits), this._isFirst = false, null;
      if (bi3.signExpBits(s5) !== this._commonSignExp) return this._commonBits = 0, null;
      this._commonMantissaBitsCount = bi3.numCommonMostSigMantissaBits(this._commonBits, s5), this._commonBits = bi3.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
    }, bi3.prototype.toString = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0], s5 = L3.longBitsToDouble(o4), c = "0000000000000000000000000000000000000000000000000000000000000000" + L3.toBinaryString(o4), f = c.substring(c.length - 64);
        return f.substring(0, 1) + "  " + f.substring(1, 12) + "(exp) " + f.substring(12) + " [ " + s5 + " ]";
      }
    }, bi3.prototype.interfaces_ = function() {
      return [];
    }, bi3.prototype.getClass = function() {
      return bi3;
    }, bi3.getBit = function(o4, s5) {
      return (o4 & 1 << s5) != 0 ? 1 : 0;
    }, bi3.signExpBits = function(o4) {
      return o4 >> 52;
    }, bi3.zeroLowerBits = function(o4, s5) {
      return o4 & ~((1 << s5) - 1);
    }, bi3.numCommonMostSigMantissaBits = function(o4, s5) {
      for (var c = 0, f = 52; f >= 0; f--) {
        if (bi3.getBit(o4, f) !== bi3.getBit(s5, f)) return c;
        c++;
      }
      return 52;
    };
    var Fl3 = H$3(function() {
      this._commonCoord = null, this._ccFilter = new hp2();
    }, "tr"), W22 = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
    Fl3.prototype.addCommonBits = function(o4) {
      var s5 = new Bl2(this._commonCoord);
      o4.apply(s5), o4.geometryChanged();
    }, Fl3.prototype.removeCommonBits = function(o4) {
      if (this._commonCoord.x === 0 && this._commonCoord.y === 0) return o4;
      var s5 = new F3(this._commonCoord);
      s5.x = -s5.x, s5.y = -s5.y;
      var c = new Bl2(s5);
      return o4.apply(c), o4.geometryChanged(), o4;
    }, Fl3.prototype.getCommonCoordinate = function() {
      return this._commonCoord;
    }, Fl3.prototype.add = function(o4) {
      o4.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
    }, Fl3.prototype.interfaces_ = function() {
      return [];
    }, Fl3.prototype.getClass = function() {
      return Fl3;
    }, W22.CommonCoordinateFilter.get = function() {
      return hp2;
    }, W22.Translater.get = function() {
      return Bl2;
    }, Object.defineProperties(Fl3, W22);
    var hp2 = H$3(function() {
      this._commonBitsX = new bi3(), this._commonBitsY = new bi3();
    }, "nr");
    hp2.prototype.filter = function(o4) {
      this._commonBitsX.add(o4.x), this._commonBitsY.add(o4.y);
    }, hp2.prototype.getCommonCoordinate = function() {
      return new F3(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
    }, hp2.prototype.interfaces_ = function() {
      return [Ai2];
    }, hp2.prototype.getClass = function() {
      return hp2;
    };
    var Bl2 = H$3(function() {
      this.trans = null;
      var o4 = arguments[0];
      this.trans = o4;
    }, "ir");
    Bl2.prototype.filter = function(o4, s5) {
      var c = o4.getOrdinate(s5, 0) + this.trans.x, f = o4.getOrdinate(s5, 1) + this.trans.y;
      o4.setOrdinate(s5, 0, c), o4.setOrdinate(s5, 1, f);
    }, Bl2.prototype.isDone = function() {
      return false;
    }, Bl2.prototype.isGeometryChanged = function() {
      return true;
    }, Bl2.prototype.interfaces_ = function() {
      return [fe2];
    }, Bl2.prototype.getClass = function() {
      return Bl2;
    };
    var Fn2 = H$3(function(o4, s5) {
      this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = o4, this._geom[1] = s5, this.computeSnapTolerance();
    }, "rr");
    Fn2.prototype.selfSnap = function(o4) {
      return new un2(o4).snapTo(o4, this._snapTolerance);
    }, Fn2.prototype.removeCommonBits = function(o4) {
      this._cbr = new Fl3(), this._cbr.add(o4[0]), this._cbr.add(o4[1]);
      var s5 = new Array(2).fill(null);
      return s5[0] = this._cbr.removeCommonBits(o4[0].copy()), s5[1] = this._cbr.removeCommonBits(o4[1].copy()), s5;
    }, Fn2.prototype.prepareResult = function(o4) {
      return this._cbr.addCommonBits(o4), o4;
    }, Fn2.prototype.getResultGeometry = function(o4) {
      var s5 = this.snap(this._geom), c = oe2.overlayOp(s5[0], s5[1], o4);
      return this.prepareResult(c);
    }, Fn2.prototype.checkValid = function(o4) {
      o4.isValid() || Nt2.out.println("Snapped geometry is invalid");
    }, Fn2.prototype.computeSnapTolerance = function() {
      this._snapTolerance = un2.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
    }, Fn2.prototype.snap = function(o4) {
      var s5 = this.removeCommonBits(o4);
      return un2.snap(s5[0], s5[1], this._snapTolerance);
    }, Fn2.prototype.interfaces_ = function() {
      return [];
    }, Fn2.prototype.getClass = function() {
      return Fn2;
    }, Fn2.overlayOp = function(o4, s5, c) {
      return new Fn2(o4, s5).getResultGeometry(c);
    }, Fn2.union = function(o4, s5) {
      return Fn2.overlayOp(o4, s5, oe2.UNION);
    }, Fn2.intersection = function(o4, s5) {
      return Fn2.overlayOp(o4, s5, oe2.INTERSECTION);
    }, Fn2.symDifference = function(o4, s5) {
      return Fn2.overlayOp(o4, s5, oe2.SYMDIFFERENCE);
    }, Fn2.difference = function(o4, s5) {
      return Fn2.overlayOp(o4, s5, oe2.DIFFERENCE);
    };
    var xi2 = H$3(function(o4, s5) {
      this._geom = new Array(2).fill(null), this._geom[0] = o4, this._geom[1] = s5;
    }, "or");
    xi2.prototype.getResultGeometry = function(o4) {
      var s5 = null, c = false, f = null;
      try {
        s5 = oe2.overlayOp(this._geom[0], this._geom[1], o4), c = true;
      } catch (g) {
        if (!(g instanceof Wr2)) throw g;
        f = g;
      }
      if (!c) try {
        s5 = Fn2.overlayOp(this._geom[0], this._geom[1], o4);
      } catch (g) {
        throw g instanceof Wr2 ? f : g;
      }
      return s5;
    }, xi2.prototype.interfaces_ = function() {
      return [];
    }, xi2.prototype.getClass = function() {
      return xi2;
    }, xi2.overlayOp = function(o4, s5, c) {
      return new xi2(o4, s5).getResultGeometry(c);
    }, xi2.union = function(o4, s5) {
      return xi2.overlayOp(o4, s5, oe2.UNION);
    }, xi2.intersection = function(o4, s5) {
      return xi2.overlayOp(o4, s5, oe2.INTERSECTION);
    }, xi2.symDifference = function(o4, s5) {
      return xi2.overlayOp(o4, s5, oe2.SYMDIFFERENCE);
    }, xi2.difference = function(o4, s5) {
      return xi2.overlayOp(o4, s5, oe2.DIFFERENCE);
    };
    var ag3 = H$3(function() {
      this.mce = null, this.chainIndex = null;
      var o4 = arguments[0], s5 = arguments[1];
      this.mce = o4, this.chainIndex = s5;
    }, "sr");
    ag3.prototype.computeIntersections = function(o4, s5) {
      this.mce.computeIntersectsForChain(this.chainIndex, o4.mce, o4.chainIndex, s5);
    }, ag3.prototype.interfaces_ = function() {
      return [];
    }, ag3.prototype.getClass = function() {
      return ag3;
    };
    var no2 = H$3(function o4() {
      if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        this._eventType = o4.DELETE, this._xValue = s5, this._insertEvent = c;
      } else if (arguments.length === 3) {
        var f = arguments[0], g = arguments[1], _ = arguments[2];
        this._eventType = o4.INSERT, this._label = f, this._xValue = g, this._obj = _;
      }
    }, "t"), Z22 = { INSERT: { configurable: true }, DELETE: { configurable: true } };
    no2.prototype.isDelete = function() {
      return this._eventType === no2.DELETE;
    }, no2.prototype.setDeleteEventIndex = function(o4) {
      this._deleteEventIndex = o4;
    }, no2.prototype.getObject = function() {
      return this._obj;
    }, no2.prototype.compareTo = function(o4) {
      var s5 = o4;
      return this._xValue < s5._xValue ? -1 : this._xValue > s5._xValue ? 1 : this._eventType < s5._eventType ? -1 : this._eventType > s5._eventType ? 1 : 0;
    }, no2.prototype.getInsertEvent = function() {
      return this._insertEvent;
    }, no2.prototype.isInsert = function() {
      return this._eventType === no2.INSERT;
    }, no2.prototype.isSameLabel = function(o4) {
      return this._label !== null && this._label === o4._label;
    }, no2.prototype.getDeleteEventIndex = function() {
      return this._deleteEventIndex;
    }, no2.prototype.interfaces_ = function() {
      return [j3];
    }, no2.prototype.getClass = function() {
      return no2;
    }, Z22.INSERT.get = function() {
      return 1;
    }, Z22.DELETE.get = function() {
      return 2;
    }, Object.defineProperties(no2, Z22);
    var D02 = H$3(function() {
    }, "lr");
    D02.prototype.interfaces_ = function() {
      return [];
    }, D02.prototype.getClass = function() {
      return D02;
    };
    var Jn2 = H$3(function() {
      this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = false, this._isDoneWhenProperInt = false;
      var o4 = arguments[0], s5 = arguments[1], c = arguments[2];
      this._li = o4, this._includeProper = s5, this._recordIsolated = c;
    }, "cr");
    Jn2.prototype.isTrivialIntersection = function(o4, s5, c, f) {
      if (o4 === c && this._li.getIntersectionNum() === 1) {
        if (Jn2.isAdjacentSegments(s5, f)) return true;
        if (o4.isClosed()) {
          var g = o4.getNumPoints() - 1;
          if (s5 === 0 && f === g || f === 0 && s5 === g) return true;
        }
      }
      return false;
    }, Jn2.prototype.getProperIntersectionPoint = function() {
      return this._properIntersectionPoint;
    }, Jn2.prototype.setIsDoneIfProperInt = function(o4) {
      this._isDoneWhenProperInt = o4;
    }, Jn2.prototype.hasProperInteriorIntersection = function() {
      return this._hasProperInterior;
    }, Jn2.prototype.isBoundaryPointInternal = function(o4, s5) {
      for (var c = s5.iterator(); c.hasNext(); ) {
        var f = c.next().getCoordinate();
        if (o4.isIntersection(f)) return true;
      }
      return false;
    }, Jn2.prototype.hasProperIntersection = function() {
      return this._hasProper;
    }, Jn2.prototype.hasIntersection = function() {
      return this._hasIntersection;
    }, Jn2.prototype.isDone = function() {
      return this._isDone;
    }, Jn2.prototype.isBoundaryPoint = function(o4, s5) {
      return s5 !== null && (!!this.isBoundaryPointInternal(o4, s5[0]) || !!this.isBoundaryPointInternal(o4, s5[1]));
    }, Jn2.prototype.setBoundaryNodes = function(o4, s5) {
      this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = o4, this._bdyNodes[1] = s5;
    }, Jn2.prototype.addIntersections = function(o4, s5, c, f) {
      if (o4 === c && s5 === f) return null;
      this.numTests++;
      var g = o4.getCoordinates()[s5], _ = o4.getCoordinates()[s5 + 1], M3 = c.getCoordinates()[f], N3 = c.getCoordinates()[f + 1];
      this._li.computeIntersection(g, _, M3, N3), this._li.hasIntersection() && (this._recordIsolated && (o4.setIsolated(false), c.setIsolated(false)), this._numIntersections++, this.isTrivialIntersection(o4, s5, c, f) || (this._hasIntersection = true, !this._includeProper && this._li.isProper() || (o4.addIntersections(this._li, s5, 0), c.addIntersections(this._li, f, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = true, this._isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = true))));
    }, Jn2.prototype.interfaces_ = function() {
      return [];
    }, Jn2.prototype.getClass = function() {
      return Jn2;
    }, Jn2.isAdjacentSegments = function(o4, s5) {
      return Math.abs(o4 - s5) === 1;
    };
    var tA2 = (function(o4) {
      function s5() {
        o4.call(this), this.events = new Et2(), this.nOverlaps = null;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.prepareEvents = function() {
        Qo2.sort(this.events);
        for (var c = 0; c < this.events.size(); c++) {
          var f = this.events.get(c);
          f.isDelete() && f.getInsertEvent().setDeleteEventIndex(c);
        }
      }, s5.prototype.computeIntersections = function() {
        if (arguments.length === 1) {
          var c = arguments[0];
          this.nOverlaps = 0, this.prepareEvents();
          for (var f = 0; f < this.events.size(); f++) {
            var g = this.events.get(f);
            if (g.isInsert() && this.processOverlaps(f, g.getDeleteEventIndex(), g, c), c.isDone()) break;
          }
        } else if (arguments.length === 3) {
          if (arguments[2] instanceof Jn2 && ct2(arguments[0], ki2) && ct2(arguments[1], ki2)) {
            var _ = arguments[0], M3 = arguments[1], N3 = arguments[2];
            this.addEdges(_, _), this.addEdges(M3, M3), this.computeIntersections(N3);
          } else if (typeof arguments[2] == "boolean" && ct2(arguments[0], ki2) && arguments[1] instanceof Jn2) {
            var G3 = arguments[0], Z4 = arguments[1];
            arguments[2] ? this.addEdges(G3, null) : this.addEdges(G3), this.computeIntersections(Z4);
          }
        }
      }, s5.prototype.addEdge = function(c, f) {
        for (var g = c.getMonotoneChainEdge(), _ = g.getStartIndexes(), M3 = 0; M3 < _.length - 1; M3++) {
          var N3 = new ag3(g, M3), G3 = new no2(f, g.getMinX(M3), N3);
          this.events.add(G3), this.events.add(new no2(g.getMaxX(M3), G3));
        }
      }, s5.prototype.processOverlaps = function(c, f, g, _) {
        for (var M3 = g.getObject(), N3 = c; N3 < f; N3++) {
          var G3 = this.events.get(N3);
          if (G3.isInsert()) {
            var Z4 = G3.getObject();
            g.isSameLabel(G3) || (M3.computeIntersections(Z4, _), this.nOverlaps++);
          }
        }
      }, s5.prototype.addEdges = function() {
        if (arguments.length === 1) for (var c = arguments[0].iterator(); c.hasNext(); ) {
          var f = c.next();
          this.addEdge(f, f);
        }
        else if (arguments.length === 2) for (var g = arguments[0], _ = arguments[1], M3 = g.iterator(); M3.hasNext(); ) {
          var N3 = M3.next();
          this.addEdge(N3, _);
        }
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(D02), Ks2 = H$3(function() {
      this._min = L3.POSITIVE_INFINITY, this._max = L3.NEGATIVE_INFINITY;
    }, "hr"), Cw2 = { NodeComparator: { configurable: true } };
    Ks2.prototype.getMin = function() {
      return this._min;
    }, Ks2.prototype.intersects = function(o4, s5) {
      return !(this._min > s5 || this._max < o4);
    }, Ks2.prototype.getMax = function() {
      return this._max;
    }, Ks2.prototype.toString = function() {
      return br2.toLineString(new F3(this._min, 0), new F3(this._max, 0));
    }, Ks2.prototype.interfaces_ = function() {
      return [];
    }, Ks2.prototype.getClass = function() {
      return Ks2;
    }, Cw2.NodeComparator.get = function() {
      return lg3;
    }, Object.defineProperties(Ks2, Cw2);
    var lg3 = H$3(function() {
    }, "gr");
    lg3.prototype.compare = function(o4, s5) {
      var c = o4, f = s5, g = (c._min + c._max) / 2, _ = (f._min + f._max) / 2;
      return g < _ ? -1 : g > _ ? 1 : 0;
    }, lg3.prototype.interfaces_ = function() {
      return [$5];
    }, lg3.prototype.getClass = function() {
      return lg3;
    };
    var eA2 = (function(o4) {
      function s5() {
        o4.call(this), this._item = null;
        var c = arguments[0], f = arguments[1], g = arguments[2];
        this._min = c, this._max = f, this._item = g;
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.query = function(c, f, g) {
        if (!this.intersects(c, f)) return null;
        g.visitItem(this._item);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(Ks2), rA2 = (function(o4) {
      function s5() {
        o4.call(this), this._node1 = null, this._node2 = null;
        var c = arguments[0], f = arguments[1];
        this._node1 = c, this._node2 = f, this.buildExtent(this._node1, this._node2);
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.buildExtent = function(c, f) {
        this._min = Math.min(c._min, f._min), this._max = Math.max(c._max, f._max);
      }, s5.prototype.query = function(c, f, g) {
        if (!this.intersects(c, f)) return null;
        this._node1 !== null && this._node1.query(c, f, g), this._node2 !== null && this._node2.query(c, f, g);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(Ks2), Qs2 = H$3(function() {
      this._leaves = new Et2(), this._root = null, this._level = 0;
    }, "_r");
    Qs2.prototype.buildTree = function() {
      Qo2.sort(this._leaves, new Ks2.NodeComparator());
      for (var o4 = this._leaves, s5 = null, c = new Et2(); ; ) {
        if (this.buildLevel(o4, c), c.size() === 1) return c.get(0);
        s5 = o4, o4 = c, c = s5;
      }
    }, Qs2.prototype.insert = function(o4, s5, c) {
      if (this._root !== null) throw new Error("Index cannot be added to once it has been queried");
      this._leaves.add(new eA2(o4, s5, c));
    }, Qs2.prototype.query = function(o4, s5, c) {
      this.init(), this._root.query(o4, s5, c);
    }, Qs2.prototype.buildRoot = function() {
      if (this._root !== null) return null;
      this._root = this.buildTree();
    }, Qs2.prototype.printNode = function(o4) {
      Nt2.out.println(br2.toLineString(new F3(o4._min, this._level), new F3(o4._max, this._level)));
    }, Qs2.prototype.init = function() {
      if (this._root !== null) return null;
      this.buildRoot();
    }, Qs2.prototype.buildLevel = function(o4, s5) {
      this._level++, s5.clear();
      for (var c = 0; c < o4.size(); c += 2) {
        var f = o4.get(c);
        if ((c + 1 < o4.size() ? o4.get(c) : null) === null) s5.add(f);
        else {
          var g = new rA2(o4.get(c), o4.get(c + 1));
          s5.add(g);
        }
      }
    }, Qs2.prototype.interfaces_ = function() {
      return [];
    }, Qs2.prototype.getClass = function() {
      return Qs2;
    };
    var kf3 = H$3(function() {
      this._items = new Et2();
    }, "mr");
    kf3.prototype.visitItem = function(o4) {
      this._items.add(o4);
    }, kf3.prototype.getItems = function() {
      return this._items;
    }, kf3.prototype.interfaces_ = function() {
      return [Ol2];
    }, kf3.prototype.getClass = function() {
      return kf3;
    };
    var Rf3 = H$3(function() {
      this._index = null;
      var o4 = arguments[0];
      if (!ct2(o4, Nn3)) throw new A3("Argument must be Polygonal");
      this._index = new tc2(o4);
    }, "vr"), $22 = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
    Rf3.prototype.locate = function(o4) {
      var s5 = new En2(o4), c = new Ff3(s5);
      return this._index.query(o4.y, o4.y, c), s5.getLocation();
    }, Rf3.prototype.interfaces_ = function() {
      return [Lf3];
    }, Rf3.prototype.getClass = function() {
      return Rf3;
    }, $22.SegmentVisitor.get = function() {
      return Ff3;
    }, $22.IntervalIndexedGeometry.get = function() {
      return tc2;
    }, Object.defineProperties(Rf3, $22);
    var Ff3 = H$3(function() {
      this._counter = null;
      var o4 = arguments[0];
      this._counter = o4;
    }, "Er");
    Ff3.prototype.visitItem = function(o4) {
      var s5 = o4;
      this._counter.countSegment(s5.getCoordinate(0), s5.getCoordinate(1));
    }, Ff3.prototype.interfaces_ = function() {
      return [Ol2];
    }, Ff3.prototype.getClass = function() {
      return Ff3;
    };
    var tc2 = H$3(function() {
      this._index = new Qs2();
      var o4 = arguments[0];
      this.init(o4);
    }, "xr");
    tc2.prototype.init = function(o4) {
      for (var s5 = Wn2.getLines(o4).iterator(); s5.hasNext(); ) {
        var c = s5.next().getCoordinates();
        this.addLine(c);
      }
    }, tc2.prototype.addLine = function(o4) {
      for (var s5 = 1; s5 < o4.length; s5++) {
        var c = new Ut2(o4[s5 - 1], o4[s5]), f = Math.min(c.p0.y, c.p1.y), g = Math.max(c.p0.y, c.p1.y);
        this._index.insert(f, g, c);
      }
    }, tc2.prototype.query = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1], c = new kf3();
        return this._index.query(o4, s5, c), c.getItems();
      }
      if (arguments.length === 3) {
        var f = arguments[0], g = arguments[1], _ = arguments[2];
        this._index.query(f, g, _);
      }
    }, tc2.prototype.interfaces_ = function() {
      return [];
    }, tc2.prototype.getClass = function() {
      return tc2;
    };
    var ug3 = (function(o4) {
      function s5() {
        if (o4.call(this), this._parentGeom = null, this._lineEdgeMap = new nw2(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = true, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = false, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new es2(), arguments.length === 2) {
          var c = arguments[0], f = arguments[1], g = Hn2.OGC_SFS_BOUNDARY_RULE;
          this._argIndex = c, this._parentGeom = f, this._boundaryNodeRule = g, f !== null && this.add(f);
        } else if (arguments.length === 3) {
          var _ = arguments[0], M3 = arguments[1], N3 = arguments[2];
          this._argIndex = _, this._parentGeom = M3, this._boundaryNodeRule = N3, M3 !== null && this.add(M3);
        }
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.insertBoundaryPoint = function(c, f) {
        var g = this._nodes.addNode(f).getLabel(), _ = 1;
        H5.NONE, g.getLocation(c, Tt2.ON) === H5.BOUNDARY && _++;
        var M3 = s5.determineBoundary(this._boundaryNodeRule, _);
        g.setLocation(c, M3);
      }, s5.prototype.computeSelfNodes = function() {
        if (arguments.length === 2) {
          var c = arguments[0], f = arguments[1];
          return this.computeSelfNodes(c, f, false);
        }
        if (arguments.length === 3) {
          var g = arguments[0], _ = arguments[1], M3 = arguments[2], N3 = new Jn2(g, true, false);
          N3.setIsDoneIfProperInt(M3);
          var G3 = this.createEdgeSetIntersector(), Z4 = this._parentGeom instanceof Fi3 || this._parentGeom instanceof xr2 || this._parentGeom instanceof Jo2, st2 = _ || !Z4;
          return G3.computeIntersections(this._edges, N3, st2), this.addSelfIntersectionNodes(this._argIndex), N3;
        }
      }, s5.prototype.computeSplitEdges = function(c) {
        for (var f = this._edges.iterator(); f.hasNext(); ) f.next().eiList.addSplitEdges(c);
      }, s5.prototype.computeEdgeIntersections = function(c, f, g) {
        var _ = new Jn2(f, g, true);
        return _.setBoundaryNodes(this.getBoundaryNodes(), c.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this._edges, c._edges, _), _;
      }, s5.prototype.getGeometry = function() {
        return this._parentGeom;
      }, s5.prototype.getBoundaryNodeRule = function() {
        return this._boundaryNodeRule;
      }, s5.prototype.hasTooFewPoints = function() {
        return this._hasTooFewPoints;
      }, s5.prototype.addPoint = function() {
        if (arguments[0] instanceof Ur2) {
          var c = arguments[0].getCoordinate();
          this.insertPoint(this._argIndex, c, H5.INTERIOR);
        } else if (arguments[0] instanceof F3) {
          var f = arguments[0];
          this.insertPoint(this._argIndex, f, H5.INTERIOR);
        }
      }, s5.prototype.addPolygon = function(c) {
        this.addPolygonRing(c.getExteriorRing(), H5.EXTERIOR, H5.INTERIOR);
        for (var f = 0; f < c.getNumInteriorRing(); f++) {
          var g = c.getInteriorRingN(f);
          this.addPolygonRing(g, H5.INTERIOR, H5.EXTERIOR);
        }
      }, s5.prototype.addEdge = function(c) {
        this.insertEdge(c);
        var f = c.getCoordinates();
        this.insertPoint(this._argIndex, f[0], H5.BOUNDARY), this.insertPoint(this._argIndex, f[f.length - 1], H5.BOUNDARY);
      }, s5.prototype.addLineString = function(c) {
        var f = O4.removeRepeatedPoints(c.getCoordinates());
        if (f.length < 2) return this._hasTooFewPoints = true, this._invalidPoint = f[0], null;
        var g = new O02(f, new _r2(this._argIndex, H5.INTERIOR));
        this._lineEdgeMap.put(c, g), this.insertEdge(g), Yt2.isTrue(f.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, f[0]), this.insertBoundaryPoint(this._argIndex, f[f.length - 1]);
      }, s5.prototype.getInvalidPoint = function() {
        return this._invalidPoint;
      }, s5.prototype.getBoundaryPoints = function() {
        for (var c = this.getBoundaryNodes(), f = new Array(c.size()).fill(null), g = 0, _ = c.iterator(); _.hasNext(); ) {
          var M3 = _.next();
          f[g++] = M3.getCoordinate().copy();
        }
        return f;
      }, s5.prototype.getBoundaryNodes = function() {
        return this._boundaryNodes === null && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
      }, s5.prototype.addSelfIntersectionNode = function(c, f, g) {
        if (this.isBoundaryNode(c, f)) return null;
        g === H5.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(c, f) : this.insertPoint(c, f, g);
      }, s5.prototype.addPolygonRing = function(c, f, g) {
        if (c.isEmpty()) return null;
        var _ = O4.removeRepeatedPoints(c.getCoordinates());
        if (_.length < 4) return this._hasTooFewPoints = true, this._invalidPoint = _[0], null;
        var M3 = f, N3 = g;
        wt2.isCCW(_) && (M3 = g, N3 = f);
        var G3 = new O02(_, new _r2(this._argIndex, H5.BOUNDARY, M3, N3));
        this._lineEdgeMap.put(c, G3), this.insertEdge(G3), this.insertPoint(this._argIndex, _[0], H5.BOUNDARY);
      }, s5.prototype.insertPoint = function(c, f, g) {
        var _ = this._nodes.addNode(f), M3 = _.getLabel();
        M3 === null ? _._label = new _r2(c, g) : M3.setLocation(c, g);
      }, s5.prototype.createEdgeSetIntersector = function() {
        return new tA2();
      }, s5.prototype.addSelfIntersectionNodes = function(c) {
        for (var f = this._edges.iterator(); f.hasNext(); ) for (var g = f.next(), _ = g.getLabel().getLocation(c), M3 = g.eiList.iterator(); M3.hasNext(); ) {
          var N3 = M3.next();
          this.addSelfIntersectionNode(c, N3.coord, _);
        }
      }, s5.prototype.add = function() {
        if (arguments.length !== 1) return o4.prototype.add.apply(this, arguments);
        var c = arguments[0];
        if (c.isEmpty()) return null;
        if (c instanceof Jo2 && (this._useBoundaryDeterminationRule = false), c instanceof xr2) this.addPolygon(c);
        else if (c instanceof ye2) this.addLineString(c);
        else if (c instanceof Ur2) this.addPoint(c);
        else if (c instanceof Ki2) this.addCollection(c);
        else if (c instanceof Tr2) this.addCollection(c);
        else if (c instanceof Jo2) this.addCollection(c);
        else {
          if (!(c instanceof te2)) throw new Error(c.getClass().getName());
          this.addCollection(c);
        }
      }, s5.prototype.addCollection = function(c) {
        for (var f = 0; f < c.getNumGeometries(); f++) {
          var g = c.getGeometryN(f);
          this.add(g);
        }
      }, s5.prototype.locate = function(c) {
        return ct2(this._parentGeom, Nn3) && this._parentGeom.getNumGeometries() > 50 ? (this._areaPtLocator === null && (this._areaPtLocator = new Rf3(this._parentGeom)), this._areaPtLocator.locate(c)) : this._ptLocator.locate(c, this._parentGeom);
      }, s5.prototype.findEdge = function() {
        if (arguments.length === 1) {
          var c = arguments[0];
          return this._lineEdgeMap.get(c);
        }
        return o4.prototype.findEdge.apply(this, arguments);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5.determineBoundary = function(c, f) {
        return c.isInBoundary(f) ? H5.BOUNDARY : H5.INTERIOR;
      }, s5;
    })(Zr2), Bf3 = H$3(function() {
      if (this._li = new Ji2(), this._resultPrecisionModel = null, this._arg = null, arguments.length === 1) {
        var o4 = arguments[0];
        this.setComputationPrecision(o4.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new ug3(0, o4);
      } else if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1], f = Hn2.OGC_SFS_BOUNDARY_RULE;
        s5.getPrecisionModel().compareTo(c.getPrecisionModel()) >= 0 ? this.setComputationPrecision(s5.getPrecisionModel()) : this.setComputationPrecision(c.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new ug3(0, s5, f), this._arg[1] = new ug3(1, c, f);
      } else if (arguments.length === 3) {
        var g = arguments[0], _ = arguments[1], M3 = arguments[2];
        g.getPrecisionModel().compareTo(_.getPrecisionModel()) >= 0 ? this.setComputationPrecision(g.getPrecisionModel()) : this.setComputationPrecision(_.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new ug3(0, g, M3), this._arg[1] = new ug3(1, _, M3);
      }
    }, "Cr");
    Bf3.prototype.getArgGeometry = function(o4) {
      return this._arg[o4].getGeometry();
    }, Bf3.prototype.setComputationPrecision = function(o4) {
      this._resultPrecisionModel = o4, this._li.setPrecisionModel(this._resultPrecisionModel);
    }, Bf3.prototype.interfaces_ = function() {
      return [];
    }, Bf3.prototype.getClass = function() {
      return Bf3;
    };
    var ec2 = H$3(function() {
    }, "Sr");
    ec2.prototype.interfaces_ = function() {
      return [];
    }, ec2.prototype.getClass = function() {
      return ec2;
    }, ec2.map = function() {
      if (arguments[0] instanceof Jt2 && ct2(arguments[1], ec2.MapOp)) {
        for (var o4 = arguments[0], s5 = arguments[1], c = new Et2(), f = 0; f < o4.getNumGeometries(); f++) {
          var g = s5.map(o4.getGeometryN(f));
          g !== null && c.add(g);
        }
        return o4.getFactory().buildGeometry(c);
      }
      if (ct2(arguments[0], Rr2) && ct2(arguments[1], ec2.MapOp)) {
        for (var _ = arguments[0], M3 = arguments[1], N3 = new Et2(), G3 = _.iterator(); G3.hasNext(); ) {
          var Z4 = G3.next(), st2 = M3.map(Z4);
          st2 !== null && N3.add(st2);
        }
        return N3;
      }
    }, ec2.MapOp = function() {
    };
    var oe2 = (function(o4) {
      function s5() {
        var c = arguments[0], f = arguments[1];
        o4.call(this, c, f), this._ptLocator = new es2(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new ts2(), this._resultPolyList = new Et2(), this._resultLineList = new Et2(), this._resultPointList = new Et2(), this._graph = new Zr2(new fw2()), this._geomFact = c.getFactory();
      }
      return H$3(s5, "e"), o4 && (s5.__proto__ = o4), s5.prototype = Object.create(o4 && o4.prototype), s5.prototype.constructor = s5, s5.prototype.insertUniqueEdge = function(c) {
        var f = this._edgeList.findEqualEdge(c);
        if (f !== null) {
          var g = f.getLabel(), _ = c.getLabel();
          f.isPointwiseEqual(c) || (_ = new _r2(c.getLabel())).flip();
          var M3 = f.getDepth();
          M3.isNull() && M3.add(g), M3.add(_), g.merge(_);
        } else this._edgeList.add(c);
      }, s5.prototype.getGraph = function() {
        return this._graph;
      }, s5.prototype.cancelDuplicateResultEdges = function() {
        for (var c = this._graph.getEdgeEnds().iterator(); c.hasNext(); ) {
          var f = c.next(), g = f.getSym();
          f.isInResult() && g.isInResult() && (f.setInResult(false), g.setInResult(false));
        }
      }, s5.prototype.isCoveredByLA = function(c) {
        return !!this.isCovered(c, this._resultLineList) || !!this.isCovered(c, this._resultPolyList);
      }, s5.prototype.computeGeometry = function(c, f, g, _) {
        var M3 = new Et2();
        return M3.addAll(c), M3.addAll(f), M3.addAll(g), M3.isEmpty() ? s5.createEmptyResult(_, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(M3);
      }, s5.prototype.mergeSymLabels = function() {
        for (var c = this._graph.getNodes().iterator(); c.hasNext(); ) c.next().getEdges().mergeSymLabels();
      }, s5.prototype.isCovered = function(c, f) {
        for (var g = f.iterator(); g.hasNext(); ) {
          var _ = g.next();
          if (this._ptLocator.locate(c, _) !== H5.EXTERIOR) return true;
        }
        return false;
      }, s5.prototype.replaceCollapsedEdges = function() {
        for (var c = new Et2(), f = this._edgeList.iterator(); f.hasNext(); ) {
          var g = f.next();
          g.isCollapsed() && (f.remove(), c.add(g.getCollapsedEdge()));
        }
        this._edgeList.addAll(c);
      }, s5.prototype.updateNodeLabelling = function() {
        for (var c = this._graph.getNodes().iterator(); c.hasNext(); ) {
          var f = c.next(), g = f.getEdges().getLabel();
          f.getLabel().merge(g);
        }
      }, s5.prototype.getResultGeometry = function(c) {
        return this.computeOverlay(c), this._resultGeom;
      }, s5.prototype.insertUniqueEdges = function(c) {
        for (var f = c.iterator(); f.hasNext(); ) {
          var g = f.next();
          this.insertUniqueEdge(g);
        }
      }, s5.prototype.computeOverlay = function(c) {
        this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, false), this._arg[1].computeSelfNodes(this._li, false), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
        var f = new Et2();
        this._arg[0].computeSplitEdges(f), this._arg[1].computeSplitEdges(f), this.insertUniqueEdges(f), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Qu2.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(c), this.cancelDuplicateResultEdges();
        var g = new to2(this._geomFact);
        g.add(this._graph), this._resultPolyList = g.getPolygons();
        var _ = new Ss2(this, this._geomFact, this._ptLocator);
        this._resultLineList = _.build(c);
        var M3 = new pp2(this, this._geomFact, this._ptLocator);
        this._resultPointList = M3.build(c), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, c);
      }, s5.prototype.labelIncompleteNode = function(c, f) {
        var g = this._ptLocator.locate(c.getCoordinate(), this._arg[f].getGeometry());
        c.getLabel().setLocation(f, g);
      }, s5.prototype.copyPoints = function(c) {
        for (var f = this._arg[c].getNodeIterator(); f.hasNext(); ) {
          var g = f.next();
          this._graph.addNode(g.getCoordinate()).setLabel(c, g.getLabel().getLocation(c));
        }
      }, s5.prototype.findResultAreaEdges = function(c) {
        for (var f = this._graph.getEdgeEnds().iterator(); f.hasNext(); ) {
          var g = f.next(), _ = g.getLabel();
          _.isArea() && !g.isInteriorAreaEdge() && s5.isResultOfOp(_.getLocation(0, Tt2.RIGHT), _.getLocation(1, Tt2.RIGHT), c) && g.setInResult(true);
        }
      }, s5.prototype.computeLabelsFromDepths = function() {
        for (var c = this._edgeList.iterator(); c.hasNext(); ) {
          var f = c.next(), g = f.getLabel(), _ = f.getDepth();
          if (!_.isNull()) {
            _.normalize();
            for (var M3 = 0; M3 < 2; M3++) g.isNull(M3) || !g.isArea() || _.isNull(M3) || (_.getDelta(M3) === 0 ? g.toLine(M3) : (Yt2.isTrue(!_.isNull(M3, Tt2.LEFT), "depth of LEFT side has not been initialized"), g.setLocation(M3, Tt2.LEFT, _.getLocation(M3, Tt2.LEFT)), Yt2.isTrue(!_.isNull(M3, Tt2.RIGHT), "depth of RIGHT side has not been initialized"), g.setLocation(M3, Tt2.RIGHT, _.getLocation(M3, Tt2.RIGHT))));
          }
        }
      }, s5.prototype.computeLabelling = function() {
        for (var c = this._graph.getNodes().iterator(); c.hasNext(); ) c.next().getEdges().computeLabelling(this._arg);
        this.mergeSymLabels(), this.updateNodeLabelling();
      }, s5.prototype.labelIncompleteNodes = function() {
        for (var c = this._graph.getNodes().iterator(); c.hasNext(); ) {
          var f = c.next(), g = f.getLabel();
          f.isIsolated() && (g.isNull(0) ? this.labelIncompleteNode(f, 0) : this.labelIncompleteNode(f, 1)), f.getEdges().updateLabelling(g);
        }
      }, s5.prototype.isCoveredByA = function(c) {
        return !!this.isCovered(c, this._resultPolyList);
      }, s5.prototype.interfaces_ = function() {
        return [];
      }, s5.prototype.getClass = function() {
        return s5;
      }, s5;
    })(Bf3);
    oe2.overlayOp = function(o4, s5, c) {
      return new oe2(o4, s5).getResultGeometry(c);
    }, oe2.intersection = function(o4, s5) {
      if (o4.isEmpty() || s5.isEmpty()) return oe2.createEmptyResult(oe2.INTERSECTION, o4, s5, o4.getFactory());
      if (o4.isGeometryCollection()) {
        var c = s5;
        return cp2.map(o4, { interfaces_: H$3(function() {
          return [ec2.MapOp];
        }, "interfaces_"), map: H$3(function(f) {
          return f.intersection(c);
        }, "map") });
      }
      return o4.checkNotGeometryCollection(o4), o4.checkNotGeometryCollection(s5), xi2.overlayOp(o4, s5, oe2.INTERSECTION);
    }, oe2.symDifference = function(o4, s5) {
      if (o4.isEmpty() || s5.isEmpty()) {
        if (o4.isEmpty() && s5.isEmpty()) return oe2.createEmptyResult(oe2.SYMDIFFERENCE, o4, s5, o4.getFactory());
        if (o4.isEmpty()) return s5.copy();
        if (s5.isEmpty()) return o4.copy();
      }
      return o4.checkNotGeometryCollection(o4), o4.checkNotGeometryCollection(s5), xi2.overlayOp(o4, s5, oe2.SYMDIFFERENCE);
    }, oe2.resultDimension = function(o4, s5, c) {
      var f = s5.getDimension(), g = c.getDimension(), _ = -1;
      switch (o4) {
        case oe2.INTERSECTION:
          _ = Math.min(f, g);
          break;
        case oe2.UNION:
          _ = Math.max(f, g);
          break;
        case oe2.DIFFERENCE:
          _ = f;
          break;
        case oe2.SYMDIFFERENCE:
          _ = Math.max(f, g);
      }
      return _;
    }, oe2.createEmptyResult = function(o4, s5, c, f) {
      var g = null;
      switch (oe2.resultDimension(o4, s5, c)) {
        case -1:
          g = f.createGeometryCollection(new Array(0).fill(null));
          break;
        case 0:
          g = f.createPoint();
          break;
        case 1:
          g = f.createLineString();
          break;
        case 2:
          g = f.createPolygon();
      }
      return g;
    }, oe2.difference = function(o4, s5) {
      return o4.isEmpty() ? oe2.createEmptyResult(oe2.DIFFERENCE, o4, s5, o4.getFactory()) : s5.isEmpty() ? o4.copy() : (o4.checkNotGeometryCollection(o4), o4.checkNotGeometryCollection(s5), xi2.overlayOp(o4, s5, oe2.DIFFERENCE));
    }, oe2.isResultOfOp = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1], c = o4.getLocation(0), f = o4.getLocation(1);
        return oe2.isResultOfOp(c, f, s5);
      }
      if (arguments.length === 3) {
        var g = arguments[0], _ = arguments[1], M3 = arguments[2];
        switch (g === H5.BOUNDARY && (g = H5.INTERIOR), _ === H5.BOUNDARY && (_ = H5.INTERIOR), M3) {
          case oe2.INTERSECTION:
            return g === H5.INTERIOR && _ === H5.INTERIOR;
          case oe2.UNION:
            return g === H5.INTERIOR || _ === H5.INTERIOR;
          case oe2.DIFFERENCE:
            return g === H5.INTERIOR && _ !== H5.INTERIOR;
          case oe2.SYMDIFFERENCE:
            return g === H5.INTERIOR && _ !== H5.INTERIOR || g !== H5.INTERIOR && _ === H5.INTERIOR;
        }
        return false;
      }
    }, oe2.INTERSECTION = 1, oe2.UNION = 2, oe2.DIFFERENCE = 3, oe2.SYMDIFFERENCE = 4;
    var Gl2 = H$3(function() {
      this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new es2(), this._seg = new Ut2();
      var o4 = arguments[0], s5 = arguments[1];
      this._g = o4, this._boundaryDistanceTolerance = s5, this._linework = this.extractLinework(o4);
    }, "br");
    Gl2.prototype.isWithinToleranceOfBoundary = function(o4) {
      for (var s5 = 0; s5 < this._linework.getNumGeometries(); s5++) for (var c = this._linework.getGeometryN(s5).getCoordinateSequence(), f = 0; f < c.size() - 1; f++) if (c.getCoordinate(f, this._seg.p0), c.getCoordinate(f + 1, this._seg.p1), this._seg.distance(o4) <= this._boundaryDistanceTolerance) return true;
      return false;
    }, Gl2.prototype.getLocation = function(o4) {
      return this.isWithinToleranceOfBoundary(o4) ? H5.BOUNDARY : this._ptLocator.locate(o4, this._g);
    }, Gl2.prototype.extractLinework = function(o4) {
      var s5 = new Gf3();
      o4.apply(s5);
      var c = s5.getLinework(), f = ge2.toLineStringArray(c);
      return o4.getFactory().createMultiLineString(f);
    }, Gl2.prototype.interfaces_ = function() {
      return [];
    }, Gl2.prototype.getClass = function() {
      return Gl2;
    };
    var Gf3 = H$3(function() {
      this._linework = null, this._linework = new Et2();
    }, "wr");
    Gf3.prototype.getLinework = function() {
      return this._linework;
    }, Gf3.prototype.filter = function(o4) {
      if (o4 instanceof xr2) {
        var s5 = o4;
        this._linework.add(s5.getExteriorRing());
        for (var c = 0; c < s5.getNumInteriorRing(); c++) this._linework.add(s5.getInteriorRingN(c));
      }
    }, Gf3.prototype.interfaces_ = function() {
      return [qt2];
    }, Gf3.prototype.getClass = function() {
      return Gf3;
    };
    var rc2 = H$3(function() {
      this._g = null, this._doLeft = true, this._doRight = true;
      var o4 = arguments[0];
      this._g = o4;
    }, "Or");
    rc2.prototype.extractPoints = function(o4, s5, c) {
      for (var f = o4.getCoordinates(), g = 0; g < f.length - 1; g++) this.computeOffsetPoints(f[g], f[g + 1], s5, c);
    }, rc2.prototype.setSidesToGenerate = function(o4, s5) {
      this._doLeft = o4, this._doRight = s5;
    }, rc2.prototype.getPoints = function(o4) {
      for (var s5 = new Et2(), c = Wn2.getLines(this._g).iterator(); c.hasNext(); ) {
        var f = c.next();
        this.extractPoints(f, o4, s5);
      }
      return s5;
    }, rc2.prototype.computeOffsetPoints = function(o4, s5, c, f) {
      var g = s5.x - o4.x, _ = s5.y - o4.y, M3 = Math.sqrt(g * g + _ * _), N3 = c * g / M3, G3 = c * _ / M3, Z4 = (s5.x + o4.x) / 2, st2 = (s5.y + o4.y) / 2;
      if (this._doLeft) {
        var ut2 = new F3(Z4 - G3, st2 + N3);
        f.add(ut2);
      }
      if (this._doRight) {
        var Ot2 = new F3(Z4 + G3, st2 - N3);
        f.add(Ot2);
      }
    }, rc2.prototype.interfaces_ = function() {
      return [];
    }, rc2.prototype.getClass = function() {
      return rc2;
    };
    var vo2 = H$3(function o4() {
      this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = o4.TOLERANCE, this._testCoords = new Et2();
      var s5 = arguments[0], c = arguments[1], f = arguments[2];
      this._boundaryDistanceTolerance = o4.computeBoundaryDistanceTolerance(s5, c), this._geom = [s5, c, f], this._locFinder = [new Gl2(this._geom[0], this._boundaryDistanceTolerance), new Gl2(this._geom[1], this._boundaryDistanceTolerance), new Gl2(this._geom[2], this._boundaryDistanceTolerance)];
    }, "t"), Sw2 = { TOLERANCE: { configurable: true } };
    vo2.prototype.reportResult = function(o4, s5, c) {
      Nt2.out.println("Overlay result invalid - A:" + H5.toLocationSymbol(s5[0]) + " B:" + H5.toLocationSymbol(s5[1]) + " expected:" + (c ? "i" : "e") + " actual:" + H5.toLocationSymbol(s5[2]));
    }, vo2.prototype.isValid = function(o4) {
      this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
      var s5 = this.checkValid(o4);
      return s5;
    }, vo2.prototype.checkValid = function() {
      if (arguments.length === 1) {
        for (var o4 = arguments[0], s5 = 0; s5 < this._testCoords.size(); s5++) {
          var c = this._testCoords.get(s5);
          if (!this.checkValid(o4, c)) return this._invalidLocation = c, false;
        }
        return true;
      }
      if (arguments.length === 2) {
        var f = arguments[0], g = arguments[1];
        return this._location[0] = this._locFinder[0].getLocation(g), this._location[1] = this._locFinder[1].getLocation(g), this._location[2] = this._locFinder[2].getLocation(g), !!vo2.hasLocation(this._location, H5.BOUNDARY) || this.isValidResult(f, this._location);
      }
    }, vo2.prototype.addTestPts = function(o4) {
      var s5 = new rc2(o4);
      this._testCoords.addAll(s5.getPoints(5 * this._boundaryDistanceTolerance));
    }, vo2.prototype.isValidResult = function(o4, s5) {
      var c = oe2.isResultOfOp(s5[0], s5[1], o4), f = !(c ^ s5[2] === H5.INTERIOR);
      return f || this.reportResult(o4, s5, c), f;
    }, vo2.prototype.getInvalidLocation = function() {
      return this._invalidLocation;
    }, vo2.prototype.interfaces_ = function() {
      return [];
    }, vo2.prototype.getClass = function() {
      return vo2;
    }, vo2.hasLocation = function(o4, s5) {
      for (var c = 0; c < 3; c++) if (o4[c] === s5) return true;
      return false;
    }, vo2.computeBoundaryDistanceTolerance = function(o4, s5) {
      return Math.min(un2.computeSizeBasedSnapTolerance(o4), un2.computeSizeBasedSnapTolerance(s5));
    }, vo2.isValid = function(o4, s5, c, f) {
      return new vo2(o4, s5, f).isValid(c);
    }, Sw2.TOLERANCE.get = function() {
      return 1e-6;
    }, Object.defineProperties(vo2, Sw2);
    var bo2 = H$3(function o4(s5) {
      this._geomFactory = null, this._skipEmpty = false, this._inputGeoms = null, this._geomFactory = o4.extractFactory(s5), this._inputGeoms = s5;
    }, "t");
    bo2.prototype.extractElements = function(o4, s5) {
      if (o4 === null) return null;
      for (var c = 0; c < o4.getNumGeometries(); c++) {
        var f = o4.getGeometryN(c);
        this._skipEmpty && f.isEmpty() || s5.add(f);
      }
    }, bo2.prototype.combine = function() {
      for (var o4 = new Et2(), s5 = this._inputGeoms.iterator(); s5.hasNext(); ) {
        var c = s5.next();
        this.extractElements(c, o4);
      }
      return o4.size() === 0 ? this._geomFactory !== null ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(o4);
    }, bo2.prototype.interfaces_ = function() {
      return [];
    }, bo2.prototype.getClass = function() {
      return bo2;
    }, bo2.combine = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return new bo2(o4).combine();
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return new bo2(bo2.createList(s5, c)).combine();
      }
      if (arguments.length === 3) {
        var f = arguments[0], g = arguments[1], _ = arguments[2];
        return new bo2(bo2.createList(f, g, _)).combine();
      }
    }, bo2.extractFactory = function(o4) {
      return o4.isEmpty() ? null : o4.iterator().next().getFactory();
    }, bo2.createList = function() {
      if (arguments.length === 2) {
        var o4 = arguments[0], s5 = arguments[1], c = new Et2();
        return c.add(o4), c.add(s5), c;
      }
      if (arguments.length === 3) {
        var f = arguments[0], g = arguments[1], _ = arguments[2], M3 = new Et2();
        return M3.add(f), M3.add(g), M3.add(_), M3;
      }
    };
    var yn2 = H$3(function() {
      this._inputPolys = null, this._geomFactory = null;
      var o4 = arguments[0];
      this._inputPolys = o4, this._inputPolys === null && (this._inputPolys = new Et2());
    }, "Dr"), Iw2 = { STRTREE_NODE_CAPACITY: { configurable: true } };
    yn2.prototype.reduceToGeometries = function(o4) {
      for (var s5 = new Et2(), c = o4.iterator(); c.hasNext(); ) {
        var f = c.next(), g = null;
        ct2(f, ki2) ? g = this.unionTree(f) : f instanceof Jt2 && (g = f), s5.add(g);
      }
      return s5;
    }, yn2.prototype.extractByEnvelope = function(o4, s5, c) {
      for (var f = new Et2(), g = 0; g < s5.getNumGeometries(); g++) {
        var _ = s5.getGeometryN(g);
        _.getEnvelopeInternal().intersects(o4) ? f.add(_) : c.add(_);
      }
      return this._geomFactory.buildGeometry(f);
    }, yn2.prototype.unionOptimized = function(o4, s5) {
      var c = o4.getEnvelopeInternal(), f = s5.getEnvelopeInternal();
      if (!c.intersects(f)) return bo2.combine(o4, s5);
      if (o4.getNumGeometries() <= 1 && s5.getNumGeometries() <= 1) return this.unionActual(o4, s5);
      var g = c.intersection(f);
      return this.unionUsingEnvelopeIntersection(o4, s5, g);
    }, yn2.prototype.union = function() {
      if (this._inputPolys === null) throw new Error("union() method cannot be called twice");
      if (this._inputPolys.isEmpty()) return null;
      this._geomFactory = this._inputPolys.iterator().next().getFactory();
      for (var o4 = new aw2(yn2.STRTREE_NODE_CAPACITY), s5 = this._inputPolys.iterator(); s5.hasNext(); ) {
        var c = s5.next();
        o4.insert(c.getEnvelopeInternal(), c);
      }
      this._inputPolys = null;
      var f = o4.itemsTree();
      return this.unionTree(f);
    }, yn2.prototype.binaryUnion = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return this.binaryUnion(o4, 0, o4.size());
      }
      if (arguments.length === 3) {
        var s5 = arguments[0], c = arguments[1], f = arguments[2];
        if (f - c <= 1) {
          var g = yn2.getGeometry(s5, c);
          return this.unionSafe(g, null);
        }
        if (f - c == 2) return this.unionSafe(yn2.getGeometry(s5, c), yn2.getGeometry(s5, c + 1));
        var _ = Math.trunc((f + c) / 2), M3 = this.binaryUnion(s5, c, _), N3 = this.binaryUnion(s5, _, f);
        return this.unionSafe(M3, N3);
      }
    }, yn2.prototype.repeatedUnion = function(o4) {
      for (var s5 = null, c = o4.iterator(); c.hasNext(); ) {
        var f = c.next();
        s5 = s5 === null ? f.copy() : s5.union(f);
      }
      return s5;
    }, yn2.prototype.unionSafe = function(o4, s5) {
      return o4 === null && s5 === null ? null : o4 === null ? s5.copy() : s5 === null ? o4.copy() : this.unionOptimized(o4, s5);
    }, yn2.prototype.unionActual = function(o4, s5) {
      return yn2.restrictToPolygons(o4.union(s5));
    }, yn2.prototype.unionTree = function(o4) {
      var s5 = this.reduceToGeometries(o4);
      return this.binaryUnion(s5);
    }, yn2.prototype.unionUsingEnvelopeIntersection = function(o4, s5, c) {
      var f = new Et2(), g = this.extractByEnvelope(c, o4, f), _ = this.extractByEnvelope(c, s5, f), M3 = this.unionActual(g, _);
      return f.add(M3), bo2.combine(f);
    }, yn2.prototype.bufferUnion = function() {
      if (arguments.length === 1) {
        var o4 = arguments[0];
        return o4.get(0).getFactory().buildGeometry(o4).buffer(0);
      }
      if (arguments.length === 2) {
        var s5 = arguments[0], c = arguments[1];
        return s5.getFactory().createGeometryCollection([s5, c]).buffer(0);
      }
    }, yn2.prototype.interfaces_ = function() {
      return [];
    }, yn2.prototype.getClass = function() {
      return yn2;
    }, yn2.restrictToPolygons = function(o4) {
      if (ct2(o4, Nn3)) return o4;
      var s5 = Ba2.getPolygons(o4);
      return s5.size() === 1 ? s5.get(0) : o4.getFactory().createMultiPolygon(ge2.toPolygonArray(s5));
    }, yn2.getGeometry = function(o4, s5) {
      return s5 >= o4.size() ? null : o4.get(s5);
    }, yn2.union = function(o4) {
      return new yn2(o4).union();
    }, Iw2.STRTREE_NODE_CAPACITY.get = function() {
      return 4;
    }, Object.defineProperties(yn2, Iw2);
    var cg3 = H$3(function() {
    }, "Ar");
    cg3.prototype.interfaces_ = function() {
      return [];
    }, cg3.prototype.getClass = function() {
      return cg3;
    }, cg3.union = function(o4, s5) {
      if (o4.isEmpty() || s5.isEmpty()) {
        if (o4.isEmpty() && s5.isEmpty()) return oe2.createEmptyResult(oe2.UNION, o4, s5, o4.getFactory());
        if (o4.isEmpty()) return s5.copy();
        if (s5.isEmpty()) return o4.copy();
      }
      return o4.checkNotGeometryCollection(o4), o4.checkNotGeometryCollection(s5), xi2.overlayOp(o4, s5, oe2.UNION);
    }, r5.GeoJSONReader = j22, r5.GeoJSONWriter = ow2, r5.OverlayOp = oe2, r5.UnionOp = cg3, r5.BufferOp = qn3, Object.defineProperty(r5, "__esModule", { value: true });
  });
});
var P3 = L((Sy2, zd2) => {
  a();
  var uj = 200, L9 = "__lodash_hash_undefined__", cj = 800, pj = 16, A9 = 9007199254740991, N9 = "[object Arguments]", hj = "[object Array]", fj = "[object AsyncFunction]", dj = "[object Boolean]", mj = "[object Date]", gj = "[object Error]", k9 = "[object Function]", yj = "[object GeneratorFunction]", vj = "[object Map]", bj = "[object Number]", xj = "[object Null]", R9 = "[object Object]", _j = "[object Proxy]", Cj = "[object RegExp]", Sj = "[object Set]", Ij = "[object String]", Mj = "[object Undefined]", Tj = "[object WeakMap]", wj = "[object ArrayBuffer]", Pj = "[object DataView]", Ej = "[object Float32Array]", Oj = "[object Float64Array]", Dj = "[object Int8Array]", Lj = "[object Int16Array]", Aj = "[object Int32Array]", Nj = "[object Uint8Array]", kj = "[object Uint8ClampedArray]", Rj = "[object Uint16Array]", Fj = "[object Uint32Array]", Bj = /[\\^$.*+?()[\]{}|]/g, Gj = /^\[object .+?Constructor\]$/, Vj = /^(?:0|[1-9]\d*)$/, pn2 = {};
  pn2[Ej] = pn2[Oj] = pn2[Dj] = pn2[Lj] = pn2[Aj] = pn2[Nj] = pn2[kj] = pn2[Rj] = pn2[Fj] = true;
  pn2[N9] = pn2[hj] = pn2[wj] = pn2[dj] = pn2[Pj] = pn2[mj] = pn2[gj] = pn2[k9] = pn2[vj] = pn2[bj] = pn2[R9] = pn2[Cj] = pn2[Sj] = pn2[Ij] = pn2[Tj] = false;
  var F9 = typeof global == "object" && global && global.Object === Object && global, jj = typeof self == "object" && self && self.Object === Object && self, Ty2 = F9 || jj || Function("return this")(), B9 = typeof Sy2 == "object" && Sy2 && !Sy2.nodeType && Sy2, Iy2 = B9 && typeof zd2 == "object" && zd2 && !zd2.nodeType && zd2, G9 = Iy2 && Iy2.exports === B9, v3 = G9 && F9.process, S9 = (function() {
    try {
      var r5 = Iy2 && Iy2.require && Iy2.require("util").types;
      return r5 || v3 && v3.binding && v3.binding("util");
    } catch (t) {
    }
  })(), I9 = S9 && S9.isTypedArray;
  function Uj(r5, t, e) {
    switch (e.length) {
      case 0:
        return r5.call(t);
      case 1:
        return r5.call(t, e[0]);
      case 2:
        return r5.call(t, e[0], e[1]);
      case 3:
        return r5.call(t, e[0], e[1], e[2]);
    }
    return r5.apply(t, e);
  }
  H$3(Uj, "apply");
  function zj(r5, t) {
    for (var e = -1, n4 = Array(r5); ++e < r5; ) n4[e] = t(e);
    return n4;
  }
  H$3(zj, "baseTimes");
  function Hj(r5) {
    return function(t) {
      return r5(t);
    };
  }
  H$3(Hj, "baseUnary");
  function Xj(r5, t) {
    return r5 == null ? void 0 : r5[t];
  }
  H$3(Xj, "getValue");
  function Yj(r5, t) {
    return function(e) {
      return r5(t(e));
    };
  }
  H$3(Yj, "overArg");
  var qj = Array.prototype, Wj = Function.prototype, Nb2 = Object.prototype, b3 = Ty2["__core-js_shared__"], kb2 = Wj.toString, hu3 = Nb2.hasOwnProperty, M9 = (function() {
    var r5 = /[^.]+$/.exec(b3 && b3.keys && b3.keys.IE_PROTO || "");
    return r5 ? "Symbol(src)_1." + r5 : "";
  })(), V9 = Nb2.toString, Zj = kb2.call(Object), $j = RegExp("^" + kb2.call(hu3).replace(Bj, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Lb2 = G9 ? Ty2.Buffer : void 0, T9 = Ty2.Symbol, w9 = Ty2.Uint8Array, P9 = Lb2 ? Lb2.allocUnsafe : void 0, j9 = Yj(Object.getPrototypeOf, Object), E9 = Object.create, Jj = Nb2.propertyIsEnumerable, Kj = qj.splice, Oh4 = T9 ? T9.toStringTag : void 0, Ab2 = (function() {
    try {
      var r5 = M3(Object, "defineProperty");
      return r5({}, "", {}), r5;
    } catch (t) {
    }
  })(), Qj = Lb2 ? Lb2.isBuffer : void 0, O9 = Math.max, tU = Date.now, U9 = M3(Ty2, "Map"), My2 = M3(Object, "create"), eU = (function() {
    function r5() {
    }
    return H$3(r5, "object"), function(t) {
      if (!Lh4(t)) return {};
      if (E9) return E9(t);
      r5.prototype = t;
      var e = new r5();
      return r5.prototype = void 0, e;
    };
  })();
  function Dh4(r5) {
    var t = -1, e = r5 == null ? 0 : r5.length;
    for (this.clear(); ++t < e; ) {
      var n4 = r5[t];
      this.set(n4[0], n4[1]);
    }
  }
  H$3(Dh4, "Hash");
  function rU() {
    this.__data__ = My2 ? My2(null) : {}, this.size = 0;
  }
  H$3(rU, "hashClear");
  function nU(r5) {
    var t = this.has(r5) && delete this.__data__[r5];
    return this.size -= t ? 1 : 0, t;
  }
  H$3(nU, "hashDelete");
  function iU(r5) {
    var t = this.__data__;
    if (My2) {
      var e = t[r5];
      return e === L9 ? void 0 : e;
    }
    return hu3.call(t, r5) ? t[r5] : void 0;
  }
  H$3(iU, "hashGet");
  function oU(r5) {
    var t = this.__data__;
    return My2 ? t[r5] !== void 0 : hu3.call(t, r5);
  }
  H$3(oU, "hashHas");
  function sU(r5, t) {
    var e = this.__data__;
    return this.size += this.has(r5) ? 0 : 1, e[r5] = My2 && t === void 0 ? L9 : t, this;
  }
  H$3(sU, "hashSet");
  Dh4.prototype.clear = rU;
  Dh4.prototype.delete = nU;
  Dh4.prototype.get = iU;
  Dh4.prototype.has = oU;
  Dh4.prototype.set = sU;
  function fu4(r5) {
    var t = -1, e = r5 == null ? 0 : r5.length;
    for (this.clear(); ++t < e; ) {
      var n4 = r5[t];
      this.set(n4[0], n4[1]);
    }
  }
  H$3(fu4, "ListCache");
  function aU() {
    this.__data__ = [], this.size = 0;
  }
  H$3(aU, "listCacheClear");
  function lU(r5) {
    var t = this.__data__, e = Rb2(t, r5);
    if (e < 0) return false;
    var n4 = t.length - 1;
    return e == n4 ? t.pop() : Kj.call(t, e, 1), --this.size, true;
  }
  H$3(lU, "listCacheDelete");
  function uU(r5) {
    var t = this.__data__, e = Rb2(t, r5);
    return e < 0 ? void 0 : t[e][1];
  }
  H$3(uU, "listCacheGet");
  function cU(r5) {
    return Rb2(this.__data__, r5) > -1;
  }
  H$3(cU, "listCacheHas");
  function pU(r5, t) {
    var e = this.__data__, n4 = Rb2(e, r5);
    return n4 < 0 ? (++this.size, e.push([r5, t])) : e[n4][1] = t, this;
  }
  H$3(pU, "listCacheSet");
  fu4.prototype.clear = aU;
  fu4.prototype.delete = lU;
  fu4.prototype.get = uU;
  fu4.prototype.has = cU;
  fu4.prototype.set = pU;
  function Hd2(r5) {
    var t = -1, e = r5 == null ? 0 : r5.length;
    for (this.clear(); ++t < e; ) {
      var n4 = r5[t];
      this.set(n4[0], n4[1]);
    }
  }
  H$3(Hd2, "MapCache");
  function hU() {
    this.size = 0, this.__data__ = { hash: new Dh4(), map: new (U9 || fu4)(), string: new Dh4() };
  }
  H$3(hU, "mapCacheClear");
  function fU(r5) {
    var t = Bb2(this, r5).delete(r5);
    return this.size -= t ? 1 : 0, t;
  }
  H$3(fU, "mapCacheDelete");
  function dU(r5) {
    return Bb2(this, r5).get(r5);
  }
  H$3(dU, "mapCacheGet");
  function mU(r5) {
    return Bb2(this, r5).has(r5);
  }
  H$3(mU, "mapCacheHas");
  function gU(r5, t) {
    var e = Bb2(this, r5), n4 = e.size;
    return e.set(r5, t), this.size += e.size == n4 ? 0 : 1, this;
  }
  H$3(gU, "mapCacheSet");
  Hd2.prototype.clear = hU;
  Hd2.prototype.delete = fU;
  Hd2.prototype.get = dU;
  Hd2.prototype.has = mU;
  Hd2.prototype.set = gU;
  function Xd2(r5) {
    var t = this.__data__ = new fu4(r5);
    this.size = t.size;
  }
  H$3(Xd2, "Stack");
  function yU() {
    this.__data__ = new fu4(), this.size = 0;
  }
  H$3(yU, "stackClear");
  function vU(r5) {
    var t = this.__data__, e = t.delete(r5);
    return this.size = t.size, e;
  }
  H$3(vU, "stackDelete");
  function bU(r5) {
    return this.__data__.get(r5);
  }
  H$3(bU, "stackGet");
  function xU(r5) {
    return this.__data__.has(r5);
  }
  H$3(xU, "stackHas");
  function _U(r5, t) {
    var e = this.__data__;
    if (e instanceof fu4) {
      var n4 = e.__data__;
      if (!U9 || n4.length < uj - 1) return n4.push([r5, t]), this.size = ++e.size, this;
      e = this.__data__ = new Hd2(n4);
    }
    return e.set(r5, t), this.size = e.size, this;
  }
  H$3(_U, "stackSet");
  Xd2.prototype.clear = yU;
  Xd2.prototype.delete = vU;
  Xd2.prototype.get = bU;
  Xd2.prototype.has = xU;
  Xd2.prototype.set = _U;
  function CU(r5, t) {
    var e = S32(r5), n4 = !e && C3(r5), i = !e && !n4 && Y9(r5), a4 = !e && !n4 && !i && W9(r5), u5 = e || n4 || i || a4, h = u5 ? zj(r5.length, String) : [], d = h.length;
    for (var m5 in r5) (t || hu3.call(r5, m5)) && !(u5 && (m5 == "length" || i && (m5 == "offset" || m5 == "parent") || a4 && (m5 == "buffer" || m5 == "byteLength" || m5 == "byteOffset") || H9(m5, d))) && h.push(m5);
    return h;
  }
  H$3(CU, "arrayLikeKeys");
  function x3(r5, t, e) {
    (e !== void 0 && !Gb2(r5[t], e) || e === void 0 && !(t in r5)) && I3(r5, t, e);
  }
  H$3(x3, "assignMergeValue");
  function SU(r5, t, e) {
    var n4 = r5[t];
    (!(hu3.call(r5, t) && Gb2(n4, e)) || e === void 0 && !(t in r5)) && I3(r5, t, e);
  }
  H$3(SU, "assignValue");
  function Rb2(r5, t) {
    for (var e = r5.length; e--; ) if (Gb2(r5[e][0], t)) return e;
    return -1;
  }
  H$3(Rb2, "assocIndexOf");
  function I3(r5, t, e) {
    t == "__proto__" && Ab2 ? Ab2(r5, t, { configurable: true, enumerable: true, value: e, writable: true }) : r5[t] = e;
  }
  H$3(I3, "baseAssignValue");
  var IU = FU();
  function Fb2(r5) {
    return r5 == null ? r5 === void 0 ? Mj : xj : Oh4 && Oh4 in Object(r5) ? BU(r5) : HU(r5);
  }
  H$3(Fb2, "baseGetTag");
  function D9(r5) {
    return wy2(r5) && Fb2(r5) == N9;
  }
  H$3(D9, "baseIsArguments");
  function MU(r5) {
    if (!Lh4(r5) || UU(r5)) return false;
    var t = w3(r5) ? $j : Gj;
    return t.test(WU(r5));
  }
  H$3(MU, "baseIsNative");
  function TU(r5) {
    return wy2(r5) && q9(r5.length) && !!pn2[Fb2(r5)];
  }
  H$3(TU, "baseIsTypedArray");
  function wU(r5) {
    if (!Lh4(r5)) return zU(r5);
    var t = X9(r5), e = [];
    for (var n4 in r5) n4 == "constructor" && (t || !hu3.call(r5, n4)) || e.push(n4);
    return e;
  }
  H$3(wU, "baseKeysIn");
  function z9(r5, t, e, n4, i) {
    r5 !== t && IU(t, function(a4, u5) {
      if (i || (i = new Xd2()), Lh4(a4)) PU(r5, t, u5, e, z9, n4, i);
      else {
        var h = n4 ? n4(_3(r5, u5), a4, u5 + "", r5, t, i) : void 0;
        h === void 0 && (h = a4), x3(r5, u5, h);
      }
    }, Z9);
  }
  H$3(z9, "baseMerge");
  function PU(r5, t, e, n4, i, a4, u5) {
    var h = _3(r5, e), d = _3(t, e), m5 = u5.get(d);
    if (m5) {
      x3(r5, e, m5);
      return;
    }
    var v4 = a4 ? a4(h, d, e + "", r5, t, u5) : void 0, x2 = v4 === void 0;
    if (x2) {
      var S4 = S32(d), I4 = !S4 && Y9(d), w4 = !S4 && !I4 && W9(d);
      v4 = d, S4 || I4 || w4 ? S32(h) ? v4 = h : ZU(h) ? v4 = NU(h) : I4 ? (x2 = false, v4 = DU(d, true)) : w4 ? (x2 = false, v4 = AU(d, true)) : v4 = [] : $U(d) || C3(d) ? (v4 = h, C3(h) ? v4 = JU(h) : (!Lh4(h) || w3(h)) && (v4 = GU(d))) : x2 = false;
    }
    x2 && (u5.set(d, v4), i(v4, d, n4, a4, u5), u5.delete(d)), x3(r5, e, v4);
  }
  H$3(PU, "baseMergeDeep");
  function EU(r5, t) {
    return YU(XU(r5, t, $9), r5 + "");
  }
  H$3(EU, "baseRest");
  var OU = Ab2 ? function(r5, t) {
    return Ab2(r5, "toString", { configurable: true, enumerable: false, value: QU(t), writable: true });
  } : $9;
  function DU(r5, t) {
    if (t) return r5.slice();
    var e = r5.length, n4 = P9 ? P9(e) : new r5.constructor(e);
    return r5.copy(n4), n4;
  }
  H$3(DU, "cloneBuffer");
  function LU(r5) {
    var t = new r5.constructor(r5.byteLength);
    return new w9(t).set(new w9(r5)), t;
  }
  H$3(LU, "cloneArrayBuffer");
  function AU(r5, t) {
    var e = t ? LU(r5.buffer) : r5.buffer;
    return new r5.constructor(e, r5.byteOffset, r5.length);
  }
  H$3(AU, "cloneTypedArray");
  function NU(r5, t) {
    var e = -1, n4 = r5.length;
    for (t || (t = Array(n4)); ++e < n4; ) t[e] = r5[e];
    return t;
  }
  H$3(NU, "copyArray");
  function kU(r5, t, e, n4) {
    var i = !e;
    e || (e = {});
    for (var a4 = -1, u5 = t.length; ++a4 < u5; ) {
      var h = t[a4], d = n4 ? n4(e[h], r5[h], h, e, r5) : void 0;
      d === void 0 && (d = r5[h]), i ? I3(e, h, d) : SU(e, h, d);
    }
    return e;
  }
  H$3(kU, "copyObject");
  function RU(r5) {
    return EU(function(t, e) {
      var n4 = -1, i = e.length, a4 = i > 1 ? e[i - 1] : void 0, u5 = i > 2 ? e[2] : void 0;
      for (a4 = r5.length > 3 && typeof a4 == "function" ? (i--, a4) : void 0, u5 && VU(e[0], e[1], u5) && (a4 = i < 3 ? void 0 : a4, i = 1), t = Object(t); ++n4 < i; ) {
        var h = e[n4];
        h && r5(t, h, n4, a4);
      }
      return t;
    });
  }
  H$3(RU, "createAssigner");
  function FU(r5) {
    return function(t, e, n4) {
      for (var i = -1, a4 = Object(t), u5 = n4(t), h = u5.length; h--; ) {
        var d = u5[r5 ? h : ++i];
        if (e(a4[d], d, a4) === false) break;
      }
      return t;
    };
  }
  H$3(FU, "createBaseFor");
  function Bb2(r5, t) {
    var e = r5.__data__;
    return jU(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
  }
  H$3(Bb2, "getMapData");
  function M3(r5, t) {
    var e = Xj(r5, t);
    return MU(e) ? e : void 0;
  }
  H$3(M3, "getNative");
  function BU(r5) {
    var t = hu3.call(r5, Oh4), e = r5[Oh4];
    try {
      r5[Oh4] = void 0;
      var n4 = true;
    } catch (a4) {
    }
    var i = V9.call(r5);
    return n4 && (t ? r5[Oh4] = e : delete r5[Oh4]), i;
  }
  H$3(BU, "getRawTag");
  function GU(r5) {
    return typeof r5.constructor == "function" && !X9(r5) ? eU(j9(r5)) : {};
  }
  H$3(GU, "initCloneObject");
  function H9(r5, t) {
    var e = typeof r5;
    return t = t == null ? A9 : t, !!t && (e == "number" || e != "symbol" && Vj.test(r5)) && r5 > -1 && r5 % 1 == 0 && r5 < t;
  }
  H$3(H9, "isIndex");
  function VU(r5, t, e) {
    if (!Lh4(e)) return false;
    var n4 = typeof t;
    return (n4 == "number" ? T3(e) && H9(t, e.length) : n4 == "string" && t in e) ? Gb2(e[t], r5) : false;
  }
  H$3(VU, "isIterateeCall");
  function jU(r5) {
    var t = typeof r5;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? r5 !== "__proto__" : r5 === null;
  }
  H$3(jU, "isKeyable");
  function UU(r5) {
    return !!M9 && M9 in r5;
  }
  H$3(UU, "isMasked");
  function X9(r5) {
    var t = r5 && r5.constructor, e = typeof t == "function" && t.prototype || Nb2;
    return r5 === e;
  }
  H$3(X9, "isPrototype");
  function zU(r5) {
    var t = [];
    if (r5 != null) for (var e in Object(r5)) t.push(e);
    return t;
  }
  H$3(zU, "nativeKeysIn");
  function HU(r5) {
    return V9.call(r5);
  }
  H$3(HU, "objectToString");
  function XU(r5, t, e) {
    return t = O9(t === void 0 ? r5.length - 1 : t, 0), function() {
      for (var n4 = arguments, i = -1, a4 = O9(n4.length - t, 0), u5 = Array(a4); ++i < a4; ) u5[i] = n4[t + i];
      i = -1;
      for (var h = Array(t + 1); ++i < t; ) h[i] = n4[i];
      return h[t] = e(u5), Uj(r5, this, h);
    };
  }
  H$3(XU, "overRest");
  function _3(r5, t) {
    if (!(t === "constructor" && typeof r5[t] == "function") && t != "__proto__") return r5[t];
  }
  H$3(_3, "safeGet");
  var YU = qU(OU);
  function qU(r5) {
    var t = 0, e = 0;
    return function() {
      var n4 = tU(), i = pj - (n4 - e);
      if (e = n4, i > 0) {
        if (++t >= cj) return arguments[0];
      } else t = 0;
      return r5.apply(void 0, arguments);
    };
  }
  H$3(qU, "shortOut");
  function WU(r5) {
    if (r5 != null) {
      try {
        return kb2.call(r5);
      } catch (t) {
      }
      try {
        return r5 + "";
      } catch (t) {
      }
    }
    return "";
  }
  H$3(WU, "toSource");
  function Gb2(r5, t) {
    return r5 === t || r5 !== r5 && t !== t;
  }
  H$3(Gb2, "eq");
  var C3 = D9(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? D9 : function(r5) {
    return wy2(r5) && hu3.call(r5, "callee") && !Jj.call(r5, "callee");
  }, S32 = Array.isArray;
  function T3(r5) {
    return r5 != null && q9(r5.length) && !w3(r5);
  }
  H$3(T3, "isArrayLike");
  function ZU(r5) {
    return wy2(r5) && T3(r5);
  }
  H$3(ZU, "isArrayLikeObject");
  var Y9 = Qj || tz;
  function w3(r5) {
    if (!Lh4(r5)) return false;
    var t = Fb2(r5);
    return t == k9 || t == yj || t == fj || t == _j;
  }
  H$3(w3, "isFunction");
  function q9(r5) {
    return typeof r5 == "number" && r5 > -1 && r5 % 1 == 0 && r5 <= A9;
  }
  H$3(q9, "isLength");
  function Lh4(r5) {
    var t = typeof r5;
    return r5 != null && (t == "object" || t == "function");
  }
  H$3(Lh4, "isObject");
  function wy2(r5) {
    return r5 != null && typeof r5 == "object";
  }
  H$3(wy2, "isObjectLike");
  function $U(r5) {
    if (!wy2(r5) || Fb2(r5) != R9) return false;
    var t = j9(r5);
    if (t === null) return true;
    var e = hu3.call(t, "constructor") && t.constructor;
    return typeof e == "function" && e instanceof e && kb2.call(e) == Zj;
  }
  H$3($U, "isPlainObject");
  var W9 = I9 ? Hj(I9) : TU;
  function JU(r5) {
    return kU(r5, Z9(r5));
  }
  H$3(JU, "toPlainObject");
  function Z9(r5) {
    return T3(r5) ? CU(r5, true) : wU(r5);
  }
  H$3(Z9, "keysIn");
  var KU = RU(function(r5, t, e) {
    z9(r5, t, e);
  });
  function QU(r5) {
    return function() {
      return r5;
    };
  }
  H$3(QU, "constant");
  function $9(r5) {
    return r5;
  }
  H$3($9, "identity");
  function tz() {
    return false;
  }
  H$3(tz, "stubFalse");
  zd2.exports = KU;
});
var z3 = L((Oy3, qd2) => {
  a();
  var Pz = 200, y8 = "__lodash_hash_undefined__", Ez = 800, Oz = 16, v8 = 9007199254740991, b8 = "[object Arguments]", Dz = "[object Array]", Lz = "[object AsyncFunction]", Az = "[object Boolean]", Nz = "[object Date]", kz = "[object Error]", x8 = "[object Function]", Rz = "[object GeneratorFunction]", Fz = "[object Map]", Bz = "[object Number]", Gz = "[object Null]", _8 = "[object Object]", Vz = "[object Proxy]", jz = "[object RegExp]", Uz = "[object Set]", zz = "[object String]", Hz = "[object Undefined]", Xz = "[object WeakMap]", Yz = "[object ArrayBuffer]", qz = "[object DataView]", Wz = "[object Float32Array]", Zz = "[object Float64Array]", $z = "[object Int8Array]", Jz = "[object Int16Array]", Kz = "[object Int32Array]", Qz = "[object Uint8Array]", tH = "[object Uint8ClampedArray]", eH = "[object Uint16Array]", rH = "[object Uint32Array]", nH = /[\\^$.*+?()[\]{}|]/g, iH = /^\[object .+?Constructor\]$/, oH = /^(?:0|[1-9]\d*)$/, hn2 = {};
  hn2[Wz] = hn2[Zz] = hn2[$z] = hn2[Jz] = hn2[Kz] = hn2[Qz] = hn2[tH] = hn2[eH] = hn2[rH] = true;
  hn2[b8] = hn2[Dz] = hn2[Yz] = hn2[Az] = hn2[qz] = hn2[Nz] = hn2[kz] = hn2[x8] = hn2[Fz] = hn2[Bz] = hn2[_8] = hn2[jz] = hn2[Uz] = hn2[zz] = hn2[Xz] = false;
  var C8 = typeof global == "object" && global && global.Object === Object && global, sH = typeof self == "object" && self && self.Object === Object && self, Ay2 = C8 || sH || Function("return this")(), S8 = typeof Oy3 == "object" && Oy3 && !Oy3.nodeType && Oy3, Dy3 = S8 && typeof qd2 == "object" && qd2 && !qd2.nodeType && qd2, I8 = Dy3 && Dy3.exports === S8, L3 = I8 && C8.process, l8 = (function() {
    try {
      var r5 = Dy3 && Dy3.require && Dy3.require("util").types;
      return r5 || L3 && L3.binding && L3.binding("util");
    } catch (t) {
    }
  })(), u8 = l8 && l8.isTypedArray;
  function M8(r5, t, e) {
    switch (e.length) {
      case 0:
        return r5.call(t);
      case 1:
        return r5.call(t, e[0]);
      case 2:
        return r5.call(t, e[0], e[1]);
      case 3:
        return r5.call(t, e[0], e[1], e[2]);
    }
    return r5.apply(t, e);
  }
  H$3(M8, "apply");
  function aH(r5, t) {
    for (var e = -1, n4 = Array(r5); ++e < r5; ) n4[e] = t(e);
    return n4;
  }
  H$3(aH, "baseTimes");
  function lH(r5) {
    return function(t) {
      return r5(t);
    };
  }
  H$3(lH, "baseUnary");
  function uH(r5, t) {
    return r5 == null ? void 0 : r5[t];
  }
  H$3(uH, "getValue");
  function cH(r5, t) {
    return function(e) {
      return r5(t(e));
    };
  }
  H$3(cH, "overArg");
  var pH = Array.prototype, hH = Function.prototype, Hb2 = Object.prototype, A3 = Ay2["__core-js_shared__"], Xb2 = hH.toString, gu3 = Hb2.hasOwnProperty, c8 = (function() {
    var r5 = /[^.]+$/.exec(A3 && A3.keys && A3.keys.IE_PROTO || "");
    return r5 ? "Symbol(src)_1." + r5 : "";
  })(), T8 = Hb2.toString, fH = Xb2.call(Object), dH = RegExp("^" + Xb2.call(gu3).replace(nH, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ub2 = I8 ? Ay2.Buffer : void 0, p8 = Ay2.Symbol, h8 = Ay2.Uint8Array, f8 = Ub2 ? Ub2.allocUnsafe : void 0, w8 = cH(Object.getPrototypeOf, Object), d8 = Object.create, mH = Hb2.propertyIsEnumerable, gH = pH.splice, Nh4 = p8 ? p8.toStringTag : void 0, zb2 = (function() {
    try {
      var r5 = V3(Object, "defineProperty");
      return r5({}, "", {}), r5;
    } catch (t) {
    }
  })(), yH = Ub2 ? Ub2.isBuffer : void 0, m8 = Math.max, vH = Date.now, P8 = V3(Ay2, "Map"), Ly3 = V3(Object, "create"), bH = (function() {
    function r5() {
    }
    return H$3(r5, "object"), function(t) {
      if (!mu3(t)) return {};
      if (d8) return d8(t);
      r5.prototype = t;
      var e = new r5();
      return r5.prototype = void 0, e;
    };
  })();
  function kh4(r5) {
    var t = -1, e = r5 == null ? 0 : r5.length;
    for (this.clear(); ++t < e; ) {
      var n4 = r5[t];
      this.set(n4[0], n4[1]);
    }
  }
  H$3(kh4, "Hash");
  function xH() {
    this.__data__ = Ly3 ? Ly3(null) : {}, this.size = 0;
  }
  H$3(xH, "hashClear");
  function _H(r5) {
    var t = this.has(r5) && delete this.__data__[r5];
    return this.size -= t ? 1 : 0, t;
  }
  H$3(_H, "hashDelete");
  function CH(r5) {
    var t = this.__data__;
    if (Ly3) {
      var e = t[r5];
      return e === y8 ? void 0 : e;
    }
    return gu3.call(t, r5) ? t[r5] : void 0;
  }
  H$3(CH, "hashGet");
  function SH(r5) {
    var t = this.__data__;
    return Ly3 ? t[r5] !== void 0 : gu3.call(t, r5);
  }
  H$3(SH, "hashHas");
  function IH(r5, t) {
    var e = this.__data__;
    return this.size += this.has(r5) ? 0 : 1, e[r5] = Ly3 && t === void 0 ? y8 : t, this;
  }
  H$3(IH, "hashSet");
  kh4.prototype.clear = xH;
  kh4.prototype.delete = _H;
  kh4.prototype.get = CH;
  kh4.prototype.has = SH;
  kh4.prototype.set = IH;
  function yu2(r5) {
    var t = -1, e = r5 == null ? 0 : r5.length;
    for (this.clear(); ++t < e; ) {
      var n4 = r5[t];
      this.set(n4[0], n4[1]);
    }
  }
  H$3(yu2, "ListCache");
  function MH() {
    this.__data__ = [], this.size = 0;
  }
  H$3(MH, "listCacheClear");
  function TH(r5) {
    var t = this.__data__, e = Yb2(t, r5);
    if (e < 0) return false;
    var n4 = t.length - 1;
    return e == n4 ? t.pop() : gH.call(t, e, 1), --this.size, true;
  }
  H$3(TH, "listCacheDelete");
  function wH(r5) {
    var t = this.__data__, e = Yb2(t, r5);
    return e < 0 ? void 0 : t[e][1];
  }
  H$3(wH, "listCacheGet");
  function PH(r5) {
    return Yb2(this.__data__, r5) > -1;
  }
  H$3(PH, "listCacheHas");
  function EH(r5, t) {
    var e = this.__data__, n4 = Yb2(e, r5);
    return n4 < 0 ? (++this.size, e.push([r5, t])) : e[n4][1] = t, this;
  }
  H$3(EH, "listCacheSet");
  yu2.prototype.clear = MH;
  yu2.prototype.delete = TH;
  yu2.prototype.get = wH;
  yu2.prototype.has = PH;
  yu2.prototype.set = EH;
  function Wd2(r5) {
    var t = -1, e = r5 == null ? 0 : r5.length;
    for (this.clear(); ++t < e; ) {
      var n4 = r5[t];
      this.set(n4[0], n4[1]);
    }
  }
  H$3(Wd2, "MapCache");
  function OH() {
    this.size = 0, this.__data__ = { hash: new kh4(), map: new (P8 || yu2)(), string: new kh4() };
  }
  H$3(OH, "mapCacheClear");
  function DH(r5) {
    var t = Wb2(this, r5).delete(r5);
    return this.size -= t ? 1 : 0, t;
  }
  H$3(DH, "mapCacheDelete");
  function LH(r5) {
    return Wb2(this, r5).get(r5);
  }
  H$3(LH, "mapCacheGet");
  function AH(r5) {
    return Wb2(this, r5).has(r5);
  }
  H$3(AH, "mapCacheHas");
  function NH(r5, t) {
    var e = Wb2(this, r5), n4 = e.size;
    return e.set(r5, t), this.size += e.size == n4 ? 0 : 1, this;
  }
  H$3(NH, "mapCacheSet");
  Wd2.prototype.clear = OH;
  Wd2.prototype.delete = DH;
  Wd2.prototype.get = LH;
  Wd2.prototype.has = AH;
  Wd2.prototype.set = NH;
  function Zd2(r5) {
    var t = this.__data__ = new yu2(r5);
    this.size = t.size;
  }
  H$3(Zd2, "Stack");
  function kH() {
    this.__data__ = new yu2(), this.size = 0;
  }
  H$3(kH, "stackClear");
  function RH(r5) {
    var t = this.__data__, e = t.delete(r5);
    return this.size = t.size, e;
  }
  H$3(RH, "stackDelete");
  function FH(r5) {
    return this.__data__.get(r5);
  }
  H$3(FH, "stackGet");
  function BH(r5) {
    return this.__data__.has(r5);
  }
  H$3(BH, "stackHas");
  function GH(r5, t) {
    var e = this.__data__;
    if (e instanceof yu2) {
      var n4 = e.__data__;
      if (!P8 || n4.length < Pz - 1) return n4.push([r5, t]), this.size = ++e.size, this;
      e = this.__data__ = new Wd2(n4);
    }
    return e.set(r5, t), this.size = e.size, this;
  }
  H$3(GH, "stackSet");
  Zd2.prototype.clear = kH;
  Zd2.prototype.delete = RH;
  Zd2.prototype.get = FH;
  Zd2.prototype.has = BH;
  Zd2.prototype.set = GH;
  function VH(r5, t) {
    var e = F3(r5), n4 = !e && R3(r5), i = !e && !n4 && A8(r5), a4 = !e && !n4 && !i && k8(r5), u5 = e || n4 || i || a4, h = u5 ? aH(r5.length, String) : [], d = h.length;
    for (var m5 in r5) (t || gu3.call(r5, m5)) && !(u5 && (m5 == "length" || i && (m5 == "offset" || m5 == "parent") || a4 && (m5 == "buffer" || m5 == "byteLength" || m5 == "byteOffset") || D8(m5, d))) && h.push(m5);
    return h;
  }
  H$3(VH, "arrayLikeKeys");
  function N3(r5, t, e) {
    (e !== void 0 && !Zb2(r5[t], e) || e === void 0 && !(t in r5)) && B3(r5, t, e);
  }
  H$3(N3, "assignMergeValue");
  function jH(r5, t, e) {
    var n4 = r5[t];
    (!(gu3.call(r5, t) && Zb2(n4, e)) || e === void 0 && !(t in r5)) && B3(r5, t, e);
  }
  H$3(jH, "assignValue");
  function Yb2(r5, t) {
    for (var e = r5.length; e--; ) if (Zb2(r5[e][0], t)) return e;
    return -1;
  }
  H$3(Yb2, "assocIndexOf");
  function B3(r5, t, e) {
    t == "__proto__" && zb2 ? zb2(r5, t, { configurable: true, enumerable: true, value: e, writable: true }) : r5[t] = e;
  }
  H$3(B3, "baseAssignValue");
  var UH = tX();
  function qb2(r5) {
    return r5 == null ? r5 === void 0 ? Hz : Gz : Nh4 && Nh4 in Object(r5) ? eX(r5) : aX(r5);
  }
  H$3(qb2, "baseGetTag");
  function g8(r5) {
    return Ny3(r5) && qb2(r5) == b8;
  }
  H$3(g8, "baseIsArguments");
  function zH(r5) {
    if (!mu3(r5) || oX(r5)) return false;
    var t = U3(r5) ? dH : iH;
    return t.test(pX(r5));
  }
  H$3(zH, "baseIsNative");
  function HH(r5) {
    return Ny3(r5) && N8(r5.length) && !!hn2[qb2(r5)];
  }
  H$3(HH, "baseIsTypedArray");
  function XH(r5) {
    if (!mu3(r5)) return sX(r5);
    var t = L8(r5), e = [];
    for (var n4 in r5) n4 == "constructor" && (t || !gu3.call(r5, n4)) || e.push(n4);
    return e;
  }
  H$3(XH, "baseKeysIn");
  function G3(r5, t, e, n4, i) {
    r5 !== t && UH(t, function(a4, u5) {
      if (i || (i = new Zd2()), mu3(a4)) YH(r5, t, u5, e, G3, n4, i);
      else {
        var h = n4 ? n4(k3(r5, u5), a4, u5 + "", r5, t, i) : void 0;
        h === void 0 && (h = a4), N3(r5, u5, h);
      }
    }, R8);
  }
  H$3(G3, "baseMerge");
  function YH(r5, t, e, n4, i, a4, u5) {
    var h = k3(r5, e), d = k3(t, e), m5 = u5.get(d);
    if (m5) {
      N3(r5, e, m5);
      return;
    }
    var v3 = a4 ? a4(h, d, e + "", r5, t, u5) : void 0, x2 = v3 === void 0;
    if (x2) {
      var S4 = F3(d), I3 = !S4 && A8(d), w3 = !S4 && !I3 && k8(d);
      v3 = d, S4 || I3 || w3 ? F3(h) ? v3 = h : hX(h) ? v3 = JH(h) : I3 ? (x2 = false, v3 = WH(d, true)) : w3 ? (x2 = false, v3 = $H(d, true)) : v3 = [] : fX(d) || R3(d) ? (v3 = h, R3(h) ? v3 = dX(h) : (!mu3(h) || U3(h)) && (v3 = rX(d))) : x2 = false;
    }
    x2 && (u5.set(d, v3), i(v3, d, n4, a4, u5), u5.delete(d)), N3(r5, e, v3);
  }
  H$3(YH, "baseMergeDeep");
  function E8(r5, t) {
    return uX(lX(r5, t, F8), r5 + "");
  }
  H$3(E8, "baseRest");
  var qH = zb2 ? function(r5, t) {
    return zb2(r5, "toString", { configurable: true, enumerable: false, value: yX(t), writable: true });
  } : F8;
  function WH(r5, t) {
    if (t) return r5.slice();
    var e = r5.length, n4 = f8 ? f8(e) : new r5.constructor(e);
    return r5.copy(n4), n4;
  }
  H$3(WH, "cloneBuffer");
  function ZH(r5) {
    var t = new r5.constructor(r5.byteLength);
    return new h8(t).set(new h8(r5)), t;
  }
  H$3(ZH, "cloneArrayBuffer");
  function $H(r5, t) {
    var e = t ? ZH(r5.buffer) : r5.buffer;
    return new r5.constructor(e, r5.byteOffset, r5.length);
  }
  H$3($H, "cloneTypedArray");
  function JH(r5, t) {
    var e = -1, n4 = r5.length;
    for (t || (t = Array(n4)); ++e < n4; ) t[e] = r5[e];
    return t;
  }
  H$3(JH, "copyArray");
  function KH(r5, t, e, n4) {
    var i = !e;
    e || (e = {});
    for (var a4 = -1, u5 = t.length; ++a4 < u5; ) {
      var h = t[a4], d = n4 ? n4(e[h], r5[h], h, e, r5) : void 0;
      d === void 0 && (d = r5[h]), i ? B3(e, h, d) : jH(e, h, d);
    }
    return e;
  }
  H$3(KH, "copyObject");
  function QH(r5) {
    return E8(function(t, e) {
      var n4 = -1, i = e.length, a4 = i > 1 ? e[i - 1] : void 0, u5 = i > 2 ? e[2] : void 0;
      for (a4 = r5.length > 3 && typeof a4 == "function" ? (i--, a4) : void 0, u5 && nX(e[0], e[1], u5) && (a4 = i < 3 ? void 0 : a4, i = 1), t = Object(t); ++n4 < i; ) {
        var h = e[n4];
        h && r5(t, h, n4, a4);
      }
      return t;
    });
  }
  H$3(QH, "createAssigner");
  function tX(r5) {
    return function(t, e, n4) {
      for (var i = -1, a4 = Object(t), u5 = n4(t), h = u5.length; h--; ) {
        var d = u5[r5 ? h : ++i];
        if (e(a4[d], d, a4) === false) break;
      }
      return t;
    };
  }
  H$3(tX, "createBaseFor");
  function O8(r5, t, e, n4, i, a4) {
    return mu3(r5) && mu3(t) && (a4.set(t, r5), G3(r5, t, void 0, O8, a4), a4.delete(t)), r5;
  }
  H$3(O8, "customDefaultsMerge");
  function Wb2(r5, t) {
    var e = r5.__data__;
    return iX(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
  }
  H$3(Wb2, "getMapData");
  function V3(r5, t) {
    var e = uH(r5, t);
    return zH(e) ? e : void 0;
  }
  H$3(V3, "getNative");
  function eX(r5) {
    var t = gu3.call(r5, Nh4), e = r5[Nh4];
    try {
      r5[Nh4] = void 0;
      var n4 = true;
    } catch (a4) {
    }
    var i = T8.call(r5);
    return n4 && (t ? r5[Nh4] = e : delete r5[Nh4]), i;
  }
  H$3(eX, "getRawTag");
  function rX(r5) {
    return typeof r5.constructor == "function" && !L8(r5) ? bH(w8(r5)) : {};
  }
  H$3(rX, "initCloneObject");
  function D8(r5, t) {
    var e = typeof r5;
    return t = t == null ? v8 : t, !!t && (e == "number" || e != "symbol" && oH.test(r5)) && r5 > -1 && r5 % 1 == 0 && r5 < t;
  }
  H$3(D8, "isIndex");
  function nX(r5, t, e) {
    if (!mu3(e)) return false;
    var n4 = typeof t;
    return (n4 == "number" ? j3(e) && D8(t, e.length) : n4 == "string" && t in e) ? Zb2(e[t], r5) : false;
  }
  H$3(nX, "isIterateeCall");
  function iX(r5) {
    var t = typeof r5;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? r5 !== "__proto__" : r5 === null;
  }
  H$3(iX, "isKeyable");
  function oX(r5) {
    return !!c8 && c8 in r5;
  }
  H$3(oX, "isMasked");
  function L8(r5) {
    var t = r5 && r5.constructor, e = typeof t == "function" && t.prototype || Hb2;
    return r5 === e;
  }
  H$3(L8, "isPrototype");
  function sX(r5) {
    var t = [];
    if (r5 != null) for (var e in Object(r5)) t.push(e);
    return t;
  }
  H$3(sX, "nativeKeysIn");
  function aX(r5) {
    return T8.call(r5);
  }
  H$3(aX, "objectToString");
  function lX(r5, t, e) {
    return t = m8(t === void 0 ? r5.length - 1 : t, 0), function() {
      for (var n4 = arguments, i = -1, a4 = m8(n4.length - t, 0), u5 = Array(a4); ++i < a4; ) u5[i] = n4[t + i];
      i = -1;
      for (var h = Array(t + 1); ++i < t; ) h[i] = n4[i];
      return h[t] = e(u5), M8(r5, this, h);
    };
  }
  H$3(lX, "overRest");
  function k3(r5, t) {
    if (!(t === "constructor" && typeof r5[t] == "function") && t != "__proto__") return r5[t];
  }
  H$3(k3, "safeGet");
  var uX = cX(qH);
  function cX(r5) {
    var t = 0, e = 0;
    return function() {
      var n4 = vH(), i = Oz - (n4 - e);
      if (e = n4, i > 0) {
        if (++t >= Ez) return arguments[0];
      } else t = 0;
      return r5.apply(void 0, arguments);
    };
  }
  H$3(cX, "shortOut");
  function pX(r5) {
    if (r5 != null) {
      try {
        return Xb2.call(r5);
      } catch (t) {
      }
      try {
        return r5 + "";
      } catch (t) {
      }
    }
    return "";
  }
  H$3(pX, "toSource");
  function Zb2(r5, t) {
    return r5 === t || r5 !== r5 && t !== t;
  }
  H$3(Zb2, "eq");
  var R3 = g8(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? g8 : function(r5) {
    return Ny3(r5) && gu3.call(r5, "callee") && !mH.call(r5, "callee");
  }, F3 = Array.isArray;
  function j3(r5) {
    return r5 != null && N8(r5.length) && !U3(r5);
  }
  H$3(j3, "isArrayLike");
  function hX(r5) {
    return Ny3(r5) && j3(r5);
  }
  H$3(hX, "isArrayLikeObject");
  var A8 = yH || vX;
  function U3(r5) {
    if (!mu3(r5)) return false;
    var t = qb2(r5);
    return t == x8 || t == Rz || t == Lz || t == Vz;
  }
  H$3(U3, "isFunction");
  function N8(r5) {
    return typeof r5 == "number" && r5 > -1 && r5 % 1 == 0 && r5 <= v8;
  }
  H$3(N8, "isLength");
  function mu3(r5) {
    var t = typeof r5;
    return r5 != null && (t == "object" || t == "function");
  }
  H$3(mu3, "isObject");
  function Ny3(r5) {
    return r5 != null && typeof r5 == "object";
  }
  H$3(Ny3, "isObjectLike");
  function fX(r5) {
    if (!Ny3(r5) || qb2(r5) != _8) return false;
    var t = w8(r5);
    if (t === null) return true;
    var e = gu3.call(t, "constructor") && t.constructor;
    return typeof e == "function" && e instanceof e && Xb2.call(e) == fH;
  }
  H$3(fX, "isPlainObject");
  var k8 = u8 ? lH(u8) : HH;
  function dX(r5) {
    return KH(r5, R8(r5));
  }
  H$3(dX, "toPlainObject");
  var mX = E8(function(r5) {
    return r5.push(void 0, O8), M8(gX, void 0, r5);
  });
  function R8(r5) {
    return j3(r5) ? VH(r5, true) : XH(r5);
  }
  H$3(R8, "keysIn");
  var gX = QH(function(r5, t, e, n4) {
    G3(r5, t, e, n4);
  });
  function yX(r5) {
    return function() {
      return r5;
    };
  }
  H$3(yX, "constant");
  function F8(r5) {
    return r5;
  }
  H$3(F8, "identity");
  function vX() {
    return false;
  }
  H$3(vX, "stubFalse");
  qd2.exports = mX;
});
var EO = L((T9t, jy3) => {
  a();
  var Gh4 = false, C3 = {}, IO = false;
  typeof jy3 < "u" && jy3.exports ? (jy3.exports = C3, IO = true) : typeof document < "u" ? window.ClipperLib = C3 : self.ClipperLib = C3;
  var ax2;
  IO ? (ci3 = "chrome", ax2 = "Netscape") : (ci3 = navigator.userAgent.toString().toLowerCase(), ax2 = navigator.appName);
  var ci3, dr2 = {};
  ci3.indexOf("chrome") != -1 && ci3.indexOf("chromium") == -1 ? dr2.chrome = 1 : dr2.chrome = 0;
  ci3.indexOf("chromium") != -1 ? dr2.chromium = 1 : dr2.chromium = 0;
  ci3.indexOf("safari") != -1 && ci3.indexOf("chrome") == -1 && ci3.indexOf("chromium") == -1 ? dr2.safari = 1 : dr2.safari = 0;
  ci3.indexOf("firefox") != -1 ? dr2.firefox = 1 : dr2.firefox = 0;
  ci3.indexOf("firefox/17") != -1 ? dr2.firefox17 = 1 : dr2.firefox17 = 0;
  ci3.indexOf("firefox/15") != -1 ? dr2.firefox15 = 1 : dr2.firefox15 = 0;
  ci3.indexOf("firefox/3") != -1 ? dr2.firefox3 = 1 : dr2.firefox3 = 0;
  ci3.indexOf("opera") != -1 ? dr2.opera = 1 : dr2.opera = 0;
  ci3.indexOf("msie 10") != -1 ? dr2.msie10 = 1 : dr2.msie10 = 0;
  ci3.indexOf("msie 9") != -1 ? dr2.msie9 = 1 : dr2.msie9 = 0;
  ci3.indexOf("msie 8") != -1 ? dr2.msie8 = 1 : dr2.msie8 = 0;
  ci3.indexOf("msie 7") != -1 ? dr2.msie7 = 1 : dr2.msie7 = 0;
  ci3.indexOf("msie ") != -1 ? dr2.msie = 1 : dr2.msie = 0;
  C3.biginteger_used = null;
  var Lc3;
  function Mt2(r5, t, e) {
    C3.biginteger_used = 1, r5 != null && (typeof r5 == "number" && typeof t > "u" ? this.fromInt(r5) : typeof r5 == "number" ? this.fromNumber(r5, t, e) : t == null && typeof r5 != "string" ? this.fromString(r5, 256) : this.fromString(r5, t));
  }
  H$3(Mt2, "BigInteger");
  function Ir2() {
    return new Mt2(null);
  }
  H$3(Ir2, "nbi");
  function FX(r5, t, e, n4, i, a4) {
    for (; --a4 >= 0; ) {
      var u5 = t * this[r5++] + e[n4] + i;
      i = Math.floor(u5 / 67108864), e[n4++] = u5 & 67108863;
    }
    return i;
  }
  H$3(FX, "am1");
  function BX(r5, t, e, n4, i, a4) {
    for (var u5 = t & 32767, h = t >> 15; --a4 >= 0; ) {
      var d = this[r5] & 32767, m5 = this[r5++] >> 15, v3 = h * d + m5 * u5;
      d = u5 * d + ((v3 & 32767) << 15) + e[n4] + (i & 1073741823), i = (d >>> 30) + (v3 >>> 15) + h * m5 + (i >>> 30), e[n4++] = d & 1073741823;
    }
    return i;
  }
  H$3(BX, "am2");
  function GX(r5, t, e, n4, i, a4) {
    for (var u5 = t & 16383, h = t >> 14; --a4 >= 0; ) {
      var d = this[r5] & 16383, m5 = this[r5++] >> 14, v3 = h * d + m5 * u5;
      d = u5 * d + ((v3 & 16383) << 14) + e[n4] + i, i = (d >> 28) + (v3 >> 14) + h * m5, e[n4++] = d & 268435455;
    }
    return i;
  }
  H$3(GX, "am3");
  ax2 == "Microsoft Internet Explorer" ? (Mt2.prototype.am = BX, Lc3 = 30) : ax2 != "Netscape" ? (Mt2.prototype.am = FX, Lc3 = 26) : (Mt2.prototype.am = GX, Lc3 = 28);
  Mt2.prototype.DB = Lc3;
  Mt2.prototype.DM = (1 << Lc3) - 1;
  Mt2.prototype.DV = 1 << Lc3;
  var fI2 = 52;
  Mt2.prototype.FV = Math.pow(2, fI2);
  Mt2.prototype.F1 = fI2 - Lc3;
  Mt2.prototype.F2 = 2 * Lc3 - fI2;
  var VX = "0123456789abcdefghijklmnopqrstuvwxyz", ux3 = new Array(), em3, Rs3;
  em3 = 48;
  for (Rs3 = 0; Rs3 <= 9; ++Rs3) ux3[em3++] = Rs3;
  em3 = 97;
  for (Rs3 = 10; Rs3 < 36; ++Rs3) ux3[em3++] = Rs3;
  em3 = 65;
  for (Rs3 = 10; Rs3 < 36; ++Rs3) ux3[em3++] = Rs3;
  function _O(r5) {
    return VX.charAt(r5);
  }
  H$3(_O, "int2char");
  function MO(r5, t) {
    var e = ux3[r5.charCodeAt(t)];
    return e == null ? -1 : e;
  }
  H$3(MO, "intAt");
  function jX(r5) {
    for (var t = this.t - 1; t >= 0; --t) r5[t] = this[t];
    r5.t = this.t, r5.s = this.s;
  }
  H$3(jX, "bnpCopyTo");
  function UX(r5) {
    this.t = 1, this.s = r5 < 0 ? -1 : 0, r5 > 0 ? this[0] = r5 : r5 < -1 ? this[0] = r5 + this.DV : this.t = 0;
  }
  H$3(UX, "bnpFromInt");
  function Dc4(r5) {
    var t = Ir2();
    return t.fromInt(r5), t;
  }
  H$3(Dc4, "nbv");
  function zX(r5, t) {
    var e;
    if (t == 16) e = 4;
    else if (t == 8) e = 3;
    else if (t == 256) e = 8;
    else if (t == 2) e = 1;
    else if (t == 32) e = 5;
    else if (t == 4) e = 2;
    else {
      this.fromRadix(r5, t);
      return;
    }
    this.t = 0, this.s = 0;
    for (var n4 = r5.length, i = false, a4 = 0; --n4 >= 0; ) {
      var u5 = e == 8 ? r5[n4] & 255 : MO(r5, n4);
      if (u5 < 0) {
        r5.charAt(n4) == "-" && (i = true);
        continue;
      }
      i = false, a4 == 0 ? this[this.t++] = u5 : a4 + e > this.DB ? (this[this.t - 1] |= (u5 & (1 << this.DB - a4) - 1) << a4, this[this.t++] = u5 >> this.DB - a4) : this[this.t - 1] |= u5 << a4, a4 += e, a4 >= this.DB && (a4 -= this.DB);
    }
    e == 8 && (r5[0] & 128) != 0 && (this.s = -1, a4 > 0 && (this[this.t - 1] |= (1 << this.DB - a4) - 1 << a4)), this.clamp(), i && Mt2.ZERO.subTo(this, this);
  }
  H$3(zX, "bnpFromString");
  function HX() {
    for (var r5 = this.s & this.DM; this.t > 0 && this[this.t - 1] == r5; ) --this.t;
  }
  H$3(HX, "bnpClamp");
  function XX(r5) {
    if (this.s < 0) return "-" + this.negate().toString(r5);
    var t;
    if (r5 == 16) t = 4;
    else if (r5 == 8) t = 3;
    else if (r5 == 2) t = 1;
    else if (r5 == 32) t = 5;
    else if (r5 == 4) t = 2;
    else return this.toRadix(r5);
    var e = (1 << t) - 1, n4, i = false, a4 = "", u5 = this.t, h = this.DB - u5 * this.DB % t;
    if (u5-- > 0) for (h < this.DB && (n4 = this[u5] >> h) > 0 && (i = true, a4 = _O(n4)); u5 >= 0; ) h < t ? (n4 = (this[u5] & (1 << h) - 1) << t - h, n4 |= this[--u5] >> (h += this.DB - t)) : (n4 = this[u5] >> (h -= t) & e, h <= 0 && (h += this.DB, --u5)), n4 > 0 && (i = true), i && (a4 += _O(n4));
    return i ? a4 : "0";
  }
  H$3(XX, "bnToString");
  function YX() {
    var r5 = Ir2();
    return Mt2.ZERO.subTo(this, r5), r5;
  }
  H$3(YX, "bnNegate");
  function qX() {
    return this.s < 0 ? this.negate() : this;
  }
  H$3(qX, "bnAbs");
  function WX(r5) {
    var t = this.s - r5.s;
    if (t != 0) return t;
    var e = this.t;
    if (t = e - r5.t, t != 0) return this.s < 0 ? -t : t;
    for (; --e >= 0; ) if ((t = this[e] - r5[e]) != 0) return t;
    return 0;
  }
  H$3(WX, "bnCompareTo");
  function cx2(r5) {
    var t = 1, e;
    return (e = r5 >>> 16) != 0 && (r5 = e, t += 16), (e = r5 >> 8) != 0 && (r5 = e, t += 8), (e = r5 >> 4) != 0 && (r5 = e, t += 4), (e = r5 >> 2) != 0 && (r5 = e, t += 2), (e = r5 >> 1) != 0 && (r5 = e, t += 1), t;
  }
  H$3(cx2, "nbits");
  function ZX() {
    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + cx2(this[this.t - 1] ^ this.s & this.DM);
  }
  H$3(ZX, "bnBitLength");
  function $X(r5, t) {
    var e;
    for (e = this.t - 1; e >= 0; --e) t[e + r5] = this[e];
    for (e = r5 - 1; e >= 0; --e) t[e] = 0;
    t.t = this.t + r5, t.s = this.s;
  }
  H$3($X, "bnpDLShiftTo");
  function JX(r5, t) {
    for (var e = r5; e < this.t; ++e) t[e - r5] = this[e];
    t.t = Math.max(this.t - r5, 0), t.s = this.s;
  }
  H$3(JX, "bnpDRShiftTo");
  function KX(r5, t) {
    var e = r5 % this.DB, n4 = this.DB - e, i = (1 << n4) - 1, a4 = Math.floor(r5 / this.DB), u5 = this.s << e & this.DM, h;
    for (h = this.t - 1; h >= 0; --h) t[h + a4 + 1] = this[h] >> n4 | u5, u5 = (this[h] & i) << e;
    for (h = a4 - 1; h >= 0; --h) t[h] = 0;
    t[a4] = u5, t.t = this.t + a4 + 1, t.s = this.s, t.clamp();
  }
  H$3(KX, "bnpLShiftTo");
  function QX(r5, t) {
    t.s = this.s;
    var e = Math.floor(r5 / this.DB);
    if (e >= this.t) {
      t.t = 0;
      return;
    }
    var n4 = r5 % this.DB, i = this.DB - n4, a4 = (1 << n4) - 1;
    t[0] = this[e] >> n4;
    for (var u5 = e + 1; u5 < this.t; ++u5) t[u5 - e - 1] |= (this[u5] & a4) << i, t[u5 - e] = this[u5] >> n4;
    n4 > 0 && (t[this.t - e - 1] |= (this.s & a4) << i), t.t = this.t - e, t.clamp();
  }
  H$3(QX, "bnpRShiftTo");
  function tY(r5, t) {
    for (var e = 0, n4 = 0, i = Math.min(r5.t, this.t); e < i; ) n4 += this[e] - r5[e], t[e++] = n4 & this.DM, n4 >>= this.DB;
    if (r5.t < this.t) {
      for (n4 -= r5.s; e < this.t; ) n4 += this[e], t[e++] = n4 & this.DM, n4 >>= this.DB;
      n4 += this.s;
    } else {
      for (n4 += this.s; e < r5.t; ) n4 -= r5[e], t[e++] = n4 & this.DM, n4 >>= this.DB;
      n4 -= r5.s;
    }
    t.s = n4 < 0 ? -1 : 0, n4 < -1 ? t[e++] = this.DV + n4 : n4 > 0 && (t[e++] = n4), t.t = e, t.clamp();
  }
  H$3(tY, "bnpSubTo");
  function eY(r5, t) {
    var e = this.abs(), n4 = r5.abs(), i = e.t;
    for (t.t = i + n4.t; --i >= 0; ) t[i] = 0;
    for (i = 0; i < n4.t; ++i) t[i + e.t] = e.am(0, n4[i], t, i, 0, e.t);
    t.s = 0, t.clamp(), this.s != r5.s && Mt2.ZERO.subTo(t, t);
  }
  H$3(eY, "bnpMultiplyTo");
  function rY(r5) {
    for (var t = this.abs(), e = r5.t = 2 * t.t; --e >= 0; ) r5[e] = 0;
    for (e = 0; e < t.t - 1; ++e) {
      var n4 = t.am(e, t[e], r5, 2 * e, 0, 1);
      (r5[e + t.t] += t.am(e + 1, 2 * t[e], r5, 2 * e + 1, n4, t.t - e - 1)) >= t.DV && (r5[e + t.t] -= t.DV, r5[e + t.t + 1] = 1);
    }
    r5.t > 0 && (r5[r5.t - 1] += t.am(e, t[e], r5, 2 * e, 0, 1)), r5.s = 0, r5.clamp();
  }
  H$3(rY, "bnpSquareTo");
  function nY(r5, t, e) {
    var n4 = r5.abs();
    if (!(n4.t <= 0)) {
      var i = this.abs();
      if (i.t < n4.t) {
        t != null && t.fromInt(0), e != null && this.copyTo(e);
        return;
      }
      e == null && (e = Ir2());
      var a4 = Ir2(), u5 = this.s, h = r5.s, d = this.DB - cx2(n4[n4.t - 1]);
      d > 0 ? (n4.lShiftTo(d, a4), i.lShiftTo(d, e)) : (n4.copyTo(a4), i.copyTo(e));
      var m5 = a4.t, v3 = a4[m5 - 1];
      if (v3 != 0) {
        var x2 = v3 * (1 << this.F1) + (m5 > 1 ? a4[m5 - 2] >> this.F2 : 0), S4 = this.FV / x2, I3 = (1 << this.F1) / x2, w3 = 1 << this.F2, E4 = e.t, T3 = E4 - m5, D4 = t == null ? Ir2() : t;
        for (a4.dlShiftTo(T3, D4), e.compareTo(D4) >= 0 && (e[e.t++] = 1, e.subTo(D4, e)), Mt2.ONE.dlShiftTo(m5, D4), D4.subTo(a4, a4); a4.t < m5; ) a4[a4.t++] = 0;
        for (; --T3 >= 0; ) {
          var A3 = e[--E4] == v3 ? this.DM : Math.floor(e[E4] * S4 + (e[E4 - 1] + w3) * I3);
          if ((e[E4] += a4.am(0, A3, e, T3, 0, m5)) < A3) for (a4.dlShiftTo(T3, D4), e.subTo(D4, e); e[E4] < --A3; ) e.subTo(D4, e);
        }
        t != null && (e.drShiftTo(m5, t), u5 != h && Mt2.ZERO.subTo(t, t)), e.t = m5, e.clamp(), d > 0 && e.rShiftTo(d, e), u5 < 0 && Mt2.ZERO.subTo(e, e);
      }
    }
  }
  H$3(nY, "bnpDivRemTo");
  function iY(r5) {
    var t = Ir2();
    return this.abs().divRemTo(r5, null, t), this.s < 0 && t.compareTo(Mt2.ZERO) > 0 && r5.subTo(t, t), t;
  }
  H$3(iY, "bnMod");
  function Vh4(r5) {
    this.m = r5;
  }
  H$3(Vh4, "Classic");
  function oY(r5) {
    return r5.s < 0 || r5.compareTo(this.m) >= 0 ? r5.mod(this.m) : r5;
  }
  H$3(oY, "cConvert");
  function sY(r5) {
    return r5;
  }
  H$3(sY, "cRevert");
  function aY(r5) {
    r5.divRemTo(this.m, null, r5);
  }
  H$3(aY, "cReduce");
  function lY(r5, t, e) {
    r5.multiplyTo(t, e), this.reduce(e);
  }
  H$3(lY, "cMulTo");
  function uY(r5, t) {
    r5.squareTo(t), this.reduce(t);
  }
  H$3(uY, "cSqrTo");
  Vh4.prototype.convert = oY;
  Vh4.prototype.revert = sY;
  Vh4.prototype.reduce = aY;
  Vh4.prototype.mulTo = lY;
  Vh4.prototype.sqrTo = uY;
  function cY() {
    if (this.t < 1) return 0;
    var r5 = this[0];
    if ((r5 & 1) == 0) return 0;
    var t = r5 & 3;
    return t = t * (2 - (r5 & 15) * t) & 15, t = t * (2 - (r5 & 255) * t) & 255, t = t * (2 - ((r5 & 65535) * t & 65535)) & 65535, t = t * (2 - r5 * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
  }
  H$3(cY, "bnpInvDigit");
  function jh4(r5) {
    this.m = r5, this.mp = r5.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << r5.DB - 15) - 1, this.mt2 = 2 * r5.t;
  }
  H$3(jh4, "Montgomery");
  function pY(r5) {
    var t = Ir2();
    return r5.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), r5.s < 0 && t.compareTo(Mt2.ZERO) > 0 && this.m.subTo(t, t), t;
  }
  H$3(pY, "montConvert");
  function hY(r5) {
    var t = Ir2();
    return r5.copyTo(t), this.reduce(t), t;
  }
  H$3(hY, "montRevert");
  function fY(r5) {
    for (; r5.t <= this.mt2; ) r5[r5.t++] = 0;
    for (var t = 0; t < this.m.t; ++t) {
      var e = r5[t] & 32767, n4 = e * this.mpl + ((e * this.mph + (r5[t] >> 15) * this.mpl & this.um) << 15) & r5.DM;
      for (e = t + this.m.t, r5[e] += this.m.am(0, n4, r5, t, 0, this.m.t); r5[e] >= r5.DV; ) r5[e] -= r5.DV, r5[++e]++;
    }
    r5.clamp(), r5.drShiftTo(this.m.t, r5), r5.compareTo(this.m) >= 0 && r5.subTo(this.m, r5);
  }
  H$3(fY, "montReduce");
  function dY(r5, t) {
    r5.squareTo(t), this.reduce(t);
  }
  H$3(dY, "montSqrTo");
  function mY(r5, t, e) {
    r5.multiplyTo(t, e), this.reduce(e);
  }
  H$3(mY, "montMulTo");
  jh4.prototype.convert = pY;
  jh4.prototype.revert = hY;
  jh4.prototype.reduce = fY;
  jh4.prototype.mulTo = mY;
  jh4.prototype.sqrTo = dY;
  function gY() {
    return (this.t > 0 ? this[0] & 1 : this.s) == 0;
  }
  H$3(gY, "bnpIsEven");
  function yY(r5, t) {
    if (r5 > 4294967295 || r5 < 1) return Mt2.ONE;
    var e = Ir2(), n4 = Ir2(), i = t.convert(this), a4 = cx2(r5) - 1;
    for (i.copyTo(e); --a4 >= 0; ) if (t.sqrTo(e, n4), (r5 & 1 << a4) > 0) t.mulTo(n4, i, e);
    else {
      var u5 = e;
      e = n4, n4 = u5;
    }
    return t.revert(e);
  }
  H$3(yY, "bnpExp");
  function vY(r5, t) {
    var e;
    return r5 < 256 || t.isEven() ? e = new Vh4(t) : e = new jh4(t), this.exp(r5, e);
  }
  H$3(vY, "bnModPowInt");
  Mt2.prototype.copyTo = jX;
  Mt2.prototype.fromInt = UX;
  Mt2.prototype.fromString = zX;
  Mt2.prototype.clamp = HX;
  Mt2.prototype.dlShiftTo = $X;
  Mt2.prototype.drShiftTo = JX;
  Mt2.prototype.lShiftTo = KX;
  Mt2.prototype.rShiftTo = QX;
  Mt2.prototype.subTo = tY;
  Mt2.prototype.multiplyTo = eY;
  Mt2.prototype.squareTo = rY;
  Mt2.prototype.divRemTo = nY;
  Mt2.prototype.invDigit = cY;
  Mt2.prototype.isEven = gY;
  Mt2.prototype.exp = yY;
  Mt2.prototype.toString = XX;
  Mt2.prototype.negate = YX;
  Mt2.prototype.abs = qX;
  Mt2.prototype.compareTo = WX;
  Mt2.prototype.bitLength = ZX;
  Mt2.prototype.mod = iY;
  Mt2.prototype.modPowInt = vY;
  Mt2.ZERO = Dc4(0);
  Mt2.ONE = Dc4(1);
  function bY() {
    var r5 = Ir2();
    return this.copyTo(r5), r5;
  }
  H$3(bY, "bnClone");
  function xY() {
    if (this.s < 0) {
      if (this.t == 1) return this[0] - this.DV;
      if (this.t == 0) return -1;
    } else {
      if (this.t == 1) return this[0];
      if (this.t == 0) return 0;
    }
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
  }
  H$3(xY, "bnIntValue");
  function _Y() {
    return this.t == 0 ? this.s : this[0] << 24 >> 24;
  }
  H$3(_Y, "bnByteValue");
  function CY() {
    return this.t == 0 ? this.s : this[0] << 16 >> 16;
  }
  H$3(CY, "bnShortValue");
  function SY(r5) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r5));
  }
  H$3(SY, "bnpChunkSize");
  function IY() {
    return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
  }
  H$3(IY, "bnSigNum");
  function MY(r5) {
    if (r5 == null && (r5 = 10), this.signum() == 0 || r5 < 2 || r5 > 36) return "0";
    var t = this.chunkSize(r5), e = Math.pow(r5, t), n4 = Dc4(e), i = Ir2(), a4 = Ir2(), u5 = "";
    for (this.divRemTo(n4, i, a4); i.signum() > 0; ) u5 = (e + a4.intValue()).toString(r5).substr(1) + u5, i.divRemTo(n4, i, a4);
    return a4.intValue().toString(r5) + u5;
  }
  H$3(MY, "bnpToRadix");
  function TY(r5, t) {
    this.fromInt(0), t == null && (t = 10);
    for (var e = this.chunkSize(t), n4 = Math.pow(t, e), i = false, a4 = 0, u5 = 0, h = 0; h < r5.length; ++h) {
      var d = MO(r5, h);
      if (d < 0) {
        r5.charAt(h) == "-" && this.signum() == 0 && (i = true);
        continue;
      }
      u5 = t * u5 + d, ++a4 >= e && (this.dMultiply(n4), this.dAddOffset(u5, 0), a4 = 0, u5 = 0);
    }
    a4 > 0 && (this.dMultiply(Math.pow(t, a4)), this.dAddOffset(u5, 0)), i && Mt2.ZERO.subTo(this, this);
  }
  H$3(TY, "bnpFromRadix");
  function wY(r5, t, e) {
    if (typeof t == "number") if (r5 < 2) this.fromInt(1);
    else for (this.fromNumber(r5, e), this.testBit(r5 - 1) || this.bitwiseTo(Mt2.ONE.shiftLeft(r5 - 1), dI2, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t); ) this.dAddOffset(2, 0), this.bitLength() > r5 && this.subTo(Mt2.ONE.shiftLeft(r5 - 1), this);
    else {
      var n4 = new Array(), i = r5 & 7;
      n4.length = (r5 >> 3) + 1, t.nextBytes(n4), i > 0 ? n4[0] &= (1 << i) - 1 : n4[0] = 0, this.fromString(n4, 256);
    }
  }
  H$3(wY, "bnpFromNumber");
  function PY() {
    var r5 = this.t, t = new Array();
    t[0] = this.s;
    var e = this.DB - r5 * this.DB % 8, n4, i = 0;
    if (r5-- > 0) for (e < this.DB && (n4 = this[r5] >> e) != (this.s & this.DM) >> e && (t[i++] = n4 | this.s << this.DB - e); r5 >= 0; ) e < 8 ? (n4 = (this[r5] & (1 << e) - 1) << 8 - e, n4 |= this[--r5] >> (e += this.DB - 8)) : (n4 = this[r5] >> (e -= 8) & 255, e <= 0 && (e += this.DB, --r5)), (n4 & 128) != 0 && (n4 |= -256), i == 0 && (this.s & 128) != (n4 & 128) && ++i, (i > 0 || n4 != this.s) && (t[i++] = n4);
    return t;
  }
  H$3(PY, "bnToByteArray");
  function EY(r5) {
    return this.compareTo(r5) == 0;
  }
  H$3(EY, "bnEquals");
  function OY(r5) {
    return this.compareTo(r5) < 0 ? this : r5;
  }
  H$3(OY, "bnMin");
  function DY(r5) {
    return this.compareTo(r5) > 0 ? this : r5;
  }
  H$3(DY, "bnMax");
  function LY(r5, t, e) {
    var n4, i, a4 = Math.min(r5.t, this.t);
    for (n4 = 0; n4 < a4; ++n4) e[n4] = t(this[n4], r5[n4]);
    if (r5.t < this.t) {
      for (i = r5.s & this.DM, n4 = a4; n4 < this.t; ++n4) e[n4] = t(this[n4], i);
      e.t = this.t;
    } else {
      for (i = this.s & this.DM, n4 = a4; n4 < r5.t; ++n4) e[n4] = t(i, r5[n4]);
      e.t = r5.t;
    }
    e.s = t(this.s, r5.s), e.clamp();
  }
  H$3(LY, "bnpBitwiseTo");
  function AY(r5, t) {
    return r5 & t;
  }
  H$3(AY, "op_and");
  function NY(r5) {
    var t = Ir2();
    return this.bitwiseTo(r5, AY, t), t;
  }
  H$3(NY, "bnAnd");
  function dI2(r5, t) {
    return r5 | t;
  }
  H$3(dI2, "op_or");
  function kY(r5) {
    var t = Ir2();
    return this.bitwiseTo(r5, dI2, t), t;
  }
  H$3(kY, "bnOr");
  function TO(r5, t) {
    return r5 ^ t;
  }
  H$3(TO, "op_xor");
  function RY(r5) {
    var t = Ir2();
    return this.bitwiseTo(r5, TO, t), t;
  }
  H$3(RY, "bnXor");
  function wO(r5, t) {
    return r5 & ~t;
  }
  H$3(wO, "op_andnot");
  function FY(r5) {
    var t = Ir2();
    return this.bitwiseTo(r5, wO, t), t;
  }
  H$3(FY, "bnAndNot");
  function BY() {
    for (var r5 = Ir2(), t = 0; t < this.t; ++t) r5[t] = this.DM & ~this[t];
    return r5.t = this.t, r5.s = ~this.s, r5;
  }
  H$3(BY, "bnNot");
  function GY(r5) {
    var t = Ir2();
    return r5 < 0 ? this.rShiftTo(-r5, t) : this.lShiftTo(r5, t), t;
  }
  H$3(GY, "bnShiftLeft");
  function VY(r5) {
    var t = Ir2();
    return r5 < 0 ? this.lShiftTo(-r5, t) : this.rShiftTo(r5, t), t;
  }
  H$3(VY, "bnShiftRight");
  function jY(r5) {
    if (r5 == 0) return -1;
    var t = 0;
    return (r5 & 65535) == 0 && (r5 >>= 16, t += 16), (r5 & 255) == 0 && (r5 >>= 8, t += 8), (r5 & 15) == 0 && (r5 >>= 4, t += 4), (r5 & 3) == 0 && (r5 >>= 2, t += 2), (r5 & 1) == 0 && ++t, t;
  }
  H$3(jY, "lbit");
  function UY() {
    for (var r5 = 0; r5 < this.t; ++r5) if (this[r5] != 0) return r5 * this.DB + jY(this[r5]);
    return this.s < 0 ? this.t * this.DB : -1;
  }
  H$3(UY, "bnGetLowestSetBit");
  function zY(r5) {
    for (var t = 0; r5 != 0; ) r5 &= r5 - 1, ++t;
    return t;
  }
  H$3(zY, "cbit");
  function HY() {
    for (var r5 = 0, t = this.s & this.DM, e = 0; e < this.t; ++e) r5 += zY(this[e] ^ t);
    return r5;
  }
  H$3(HY, "bnBitCount");
  function XY(r5) {
    var t = Math.floor(r5 / this.DB);
    return t >= this.t ? this.s != 0 : (this[t] & 1 << r5 % this.DB) != 0;
  }
  H$3(XY, "bnTestBit");
  function YY(r5, t) {
    var e = Mt2.ONE.shiftLeft(r5);
    return this.bitwiseTo(e, t, e), e;
  }
  H$3(YY, "bnpChangeBit");
  function qY(r5) {
    return this.changeBit(r5, dI2);
  }
  H$3(qY, "bnSetBit");
  function WY(r5) {
    return this.changeBit(r5, wO);
  }
  H$3(WY, "bnClearBit");
  function ZY(r5) {
    return this.changeBit(r5, TO);
  }
  H$3(ZY, "bnFlipBit");
  function $Y(r5, t) {
    for (var e = 0, n4 = 0, i = Math.min(r5.t, this.t); e < i; ) n4 += this[e] + r5[e], t[e++] = n4 & this.DM, n4 >>= this.DB;
    if (r5.t < this.t) {
      for (n4 += r5.s; e < this.t; ) n4 += this[e], t[e++] = n4 & this.DM, n4 >>= this.DB;
      n4 += this.s;
    } else {
      for (n4 += this.s; e < r5.t; ) n4 += r5[e], t[e++] = n4 & this.DM, n4 >>= this.DB;
      n4 += r5.s;
    }
    t.s = n4 < 0 ? -1 : 0, n4 > 0 ? t[e++] = n4 : n4 < -1 && (t[e++] = this.DV + n4), t.t = e, t.clamp();
  }
  H$3($Y, "bnpAddTo");
  function JY(r5) {
    var t = Ir2();
    return this.addTo(r5, t), t;
  }
  H$3(JY, "bnAdd");
  function KY(r5) {
    var t = Ir2();
    return this.subTo(r5, t), t;
  }
  H$3(KY, "bnSubtract");
  function QY(r5) {
    var t = Ir2();
    return this.multiplyTo(r5, t), t;
  }
  H$3(QY, "bnMultiply");
  function tq() {
    var r5 = Ir2();
    return this.squareTo(r5), r5;
  }
  H$3(tq, "bnSquare");
  function eq(r5) {
    var t = Ir2();
    return this.divRemTo(r5, t, null), t;
  }
  H$3(eq, "bnDivide");
  function rq(r5) {
    var t = Ir2();
    return this.divRemTo(r5, null, t), t;
  }
  H$3(rq, "bnRemainder");
  function nq(r5) {
    var t = Ir2(), e = Ir2();
    return this.divRemTo(r5, t, e), new Array(t, e);
  }
  H$3(nq, "bnDivideAndRemainder");
  function iq(r5) {
    this[this.t] = this.am(0, r5 - 1, this, 0, 0, this.t), ++this.t, this.clamp();
  }
  H$3(iq, "bnpDMultiply");
  function oq(r5, t) {
    if (r5 != 0) {
      for (; this.t <= t; ) this[this.t++] = 0;
      for (this[t] += r5; this[t] >= this.DV; ) this[t] -= this.DV, ++t >= this.t && (this[this.t++] = 0), ++this[t];
    }
  }
  H$3(oq, "bnpDAddOffset");
  function Uy3() {
  }
  H$3(Uy3, "NullExp");
  function PO(r5) {
    return r5;
  }
  H$3(PO, "nNop");
  function sq(r5, t, e) {
    r5.multiplyTo(t, e);
  }
  H$3(sq, "nMulTo");
  function aq(r5, t) {
    r5.squareTo(t);
  }
  H$3(aq, "nSqrTo");
  Uy3.prototype.convert = PO;
  Uy3.prototype.revert = PO;
  Uy3.prototype.mulTo = sq;
  Uy3.prototype.sqrTo = aq;
  function lq(r5) {
    return this.exp(r5, new Uy3());
  }
  H$3(lq, "bnPow");
  function uq(r5, t, e) {
    var n4 = Math.min(this.t + r5.t, t);
    for (e.s = 0, e.t = n4; n4 > 0; ) e[--n4] = 0;
    var i;
    for (i = e.t - this.t; n4 < i; ++n4) e[n4 + this.t] = this.am(0, r5[n4], e, n4, 0, this.t);
    for (i = Math.min(r5.t, t); n4 < i; ++n4) this.am(0, r5[n4], e, n4, 0, t - n4);
    e.clamp();
  }
  H$3(uq, "bnpMultiplyLowerTo");
  function cq(r5, t, e) {
    --t;
    var n4 = e.t = this.t + r5.t - t;
    for (e.s = 0; --n4 >= 0; ) e[n4] = 0;
    for (n4 = Math.max(t - this.t, 0); n4 < r5.t; ++n4) e[this.t + n4 - t] = this.am(t - n4, r5[n4], e, 0, 0, this.t + n4 - t);
    e.clamp(), e.drShiftTo(1, e);
  }
  H$3(cq, "bnpMultiplyUpperTo");
  function rm3(r5) {
    this.r2 = Ir2(), this.q3 = Ir2(), Mt2.ONE.dlShiftTo(2 * r5.t, this.r2), this.mu = this.r2.divide(r5), this.m = r5;
  }
  H$3(rm3, "Barrett");
  function pq(r5) {
    if (r5.s < 0 || r5.t > 2 * this.m.t) return r5.mod(this.m);
    if (r5.compareTo(this.m) < 0) return r5;
    var t = Ir2();
    return r5.copyTo(t), this.reduce(t), t;
  }
  H$3(pq, "barrettConvert");
  function hq(r5) {
    return r5;
  }
  H$3(hq, "barrettRevert");
  function fq(r5) {
    for (r5.drShiftTo(this.m.t - 1, this.r2), r5.t > this.m.t + 1 && (r5.t = this.m.t + 1, r5.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); r5.compareTo(this.r2) < 0; ) r5.dAddOffset(1, this.m.t + 1);
    for (r5.subTo(this.r2, r5); r5.compareTo(this.m) >= 0; ) r5.subTo(this.m, r5);
  }
  H$3(fq, "barrettReduce");
  function dq(r5, t) {
    r5.squareTo(t), this.reduce(t);
  }
  H$3(dq, "barrettSqrTo");
  function mq(r5, t, e) {
    r5.multiplyTo(t, e), this.reduce(e);
  }
  H$3(mq, "barrettMulTo");
  rm3.prototype.convert = pq;
  rm3.prototype.revert = hq;
  rm3.prototype.reduce = fq;
  rm3.prototype.mulTo = mq;
  rm3.prototype.sqrTo = dq;
  function gq(r5, t) {
    var e = r5.bitLength(), n4, i = Dc4(1), a4;
    if (e <= 0) return i;
    e < 18 ? n4 = 1 : e < 48 ? n4 = 3 : e < 144 ? n4 = 4 : e < 768 ? n4 = 5 : n4 = 6, e < 8 ? a4 = new Vh4(t) : t.isEven() ? a4 = new rm3(t) : a4 = new jh4(t);
    var u5 = new Array(), h = 3, d = n4 - 1, m5 = (1 << n4) - 1;
    if (u5[1] = a4.convert(this), n4 > 1) {
      var v3 = Ir2();
      for (a4.sqrTo(u5[1], v3); h <= m5; ) u5[h] = Ir2(), a4.mulTo(v3, u5[h - 2], u5[h]), h += 2;
    }
    var x2 = r5.t - 1, S4, I3 = true, w3 = Ir2(), E4;
    for (e = cx2(r5[x2]) - 1; x2 >= 0; ) {
      for (e >= d ? S4 = r5[x2] >> e - d & m5 : (S4 = (r5[x2] & (1 << e + 1) - 1) << d - e, x2 > 0 && (S4 |= r5[x2 - 1] >> this.DB + e - d)), h = n4; (S4 & 1) == 0; ) S4 >>= 1, --h;
      if ((e -= h) < 0 && (e += this.DB, --x2), I3) u5[S4].copyTo(i), I3 = false;
      else {
        for (; h > 1; ) a4.sqrTo(i, w3), a4.sqrTo(w3, i), h -= 2;
        h > 0 ? a4.sqrTo(i, w3) : (E4 = i, i = w3, w3 = E4), a4.mulTo(w3, u5[S4], i);
      }
      for (; x2 >= 0 && (r5[x2] & 1 << e) == 0; ) a4.sqrTo(i, w3), E4 = i, i = w3, w3 = E4, --e < 0 && (e = this.DB - 1, --x2);
    }
    return a4.revert(i);
  }
  H$3(gq, "bnModPow");
  function yq(r5) {
    var t = this.s < 0 ? this.negate() : this.clone(), e = r5.s < 0 ? r5.negate() : r5.clone();
    if (t.compareTo(e) < 0) {
      var n4 = t;
      t = e, e = n4;
    }
    var i = t.getLowestSetBit(), a4 = e.getLowestSetBit();
    if (a4 < 0) return t;
    for (i < a4 && (a4 = i), a4 > 0 && (t.rShiftTo(a4, t), e.rShiftTo(a4, e)); t.signum() > 0; ) (i = t.getLowestSetBit()) > 0 && t.rShiftTo(i, t), (i = e.getLowestSetBit()) > 0 && e.rShiftTo(i, e), t.compareTo(e) >= 0 ? (t.subTo(e, t), t.rShiftTo(1, t)) : (e.subTo(t, e), e.rShiftTo(1, e));
    return a4 > 0 && e.lShiftTo(a4, e), e;
  }
  H$3(yq, "bnGCD");
  function vq(r5) {
    if (r5 <= 0) return 0;
    var t = this.DV % r5, e = this.s < 0 ? r5 - 1 : 0;
    if (this.t > 0) if (t == 0) e = this[0] % r5;
    else for (var n4 = this.t - 1; n4 >= 0; --n4) e = (t * e + this[n4]) % r5;
    return e;
  }
  H$3(vq, "bnpModInt");
  function bq(r5) {
    var t = r5.isEven();
    if (this.isEven() && t || r5.signum() == 0) return Mt2.ZERO;
    for (var e = r5.clone(), n4 = this.clone(), i = Dc4(1), a4 = Dc4(0), u5 = Dc4(0), h = Dc4(1); e.signum() != 0; ) {
      for (; e.isEven(); ) e.rShiftTo(1, e), t ? ((!i.isEven() || !a4.isEven()) && (i.addTo(this, i), a4.subTo(r5, a4)), i.rShiftTo(1, i)) : a4.isEven() || a4.subTo(r5, a4), a4.rShiftTo(1, a4);
      for (; n4.isEven(); ) n4.rShiftTo(1, n4), t ? ((!u5.isEven() || !h.isEven()) && (u5.addTo(this, u5), h.subTo(r5, h)), u5.rShiftTo(1, u5)) : h.isEven() || h.subTo(r5, h), h.rShiftTo(1, h);
      e.compareTo(n4) >= 0 ? (e.subTo(n4, e), t && i.subTo(u5, i), a4.subTo(h, a4)) : (n4.subTo(e, n4), t && u5.subTo(i, u5), h.subTo(a4, h));
    }
    if (n4.compareTo(Mt2.ONE) != 0) return Mt2.ZERO;
    if (h.compareTo(r5) >= 0) return h.subtract(r5);
    if (h.signum() < 0) h.addTo(r5, h);
    else return h;
    return h.signum() < 0 ? h.add(r5) : h;
  }
  H$3(bq, "bnModInverse");
  var To2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], xq = (1 << 26) / To2[To2.length - 1];
  function _q(r5) {
    var t, e = this.abs();
    if (e.t == 1 && e[0] <= To2[To2.length - 1]) {
      for (t = 0; t < To2.length; ++t) if (e[0] == To2[t]) return true;
      return false;
    }
    if (e.isEven()) return false;
    for (t = 1; t < To2.length; ) {
      for (var n4 = To2[t], i = t + 1; i < To2.length && n4 < xq; ) n4 *= To2[i++];
      for (n4 = e.modInt(n4); t < i; ) if (n4 % To2[t++] == 0) return false;
    }
    return e.millerRabin(r5);
  }
  H$3(_q, "bnIsProbablePrime");
  function Cq(r5) {
    var t = this.subtract(Mt2.ONE), e = t.getLowestSetBit();
    if (e <= 0) return false;
    var n4 = t.shiftRight(e);
    r5 = r5 + 1 >> 1, r5 > To2.length && (r5 = To2.length);
    for (var i = Ir2(), a4 = 0; a4 < r5; ++a4) {
      i.fromInt(To2[Math.floor(Math.random() * To2.length)]);
      var u5 = i.modPow(n4, this);
      if (u5.compareTo(Mt2.ONE) != 0 && u5.compareTo(t) != 0) {
        for (var h = 1; h++ < e && u5.compareTo(t) != 0; ) if (u5 = u5.modPowInt(2, this), u5.compareTo(Mt2.ONE) == 0) return false;
        if (u5.compareTo(t) != 0) return false;
      }
    }
    return true;
  }
  H$3(Cq, "bnpMillerRabin");
  Mt2.prototype.chunkSize = SY;
  Mt2.prototype.toRadix = MY;
  Mt2.prototype.fromRadix = TY;
  Mt2.prototype.fromNumber = wY;
  Mt2.prototype.bitwiseTo = LY;
  Mt2.prototype.changeBit = YY;
  Mt2.prototype.addTo = $Y;
  Mt2.prototype.dMultiply = iq;
  Mt2.prototype.dAddOffset = oq;
  Mt2.prototype.multiplyLowerTo = uq;
  Mt2.prototype.multiplyUpperTo = cq;
  Mt2.prototype.modInt = vq;
  Mt2.prototype.millerRabin = Cq;
  Mt2.prototype.clone = bY;
  Mt2.prototype.intValue = xY;
  Mt2.prototype.byteValue = _Y;
  Mt2.prototype.shortValue = CY;
  Mt2.prototype.signum = IY;
  Mt2.prototype.toByteArray = PY;
  Mt2.prototype.equals = EY;
  Mt2.prototype.min = OY;
  Mt2.prototype.max = DY;
  Mt2.prototype.and = NY;
  Mt2.prototype.or = kY;
  Mt2.prototype.xor = RY;
  Mt2.prototype.andNot = FY;
  Mt2.prototype.not = BY;
  Mt2.prototype.shiftLeft = GY;
  Mt2.prototype.shiftRight = VY;
  Mt2.prototype.getLowestSetBit = UY;
  Mt2.prototype.bitCount = HY;
  Mt2.prototype.testBit = XY;
  Mt2.prototype.setBit = qY;
  Mt2.prototype.clearBit = WY;
  Mt2.prototype.flipBit = ZY;
  Mt2.prototype.add = JY;
  Mt2.prototype.subtract = KY;
  Mt2.prototype.multiply = QY;
  Mt2.prototype.divide = eq;
  Mt2.prototype.remainder = rq;
  Mt2.prototype.divideAndRemainder = nq;
  Mt2.prototype.modPow = gq;
  Mt2.prototype.modInverse = bq;
  Mt2.prototype.pow = lq;
  Mt2.prototype.gcd = yq;
  Mt2.prototype.isProbablePrime = _q;
  Mt2.prototype.square = tq;
  var Ke2 = Mt2;
  Ke2.prototype.IsNegative = function() {
    return this.compareTo(Ke2.ZERO) == -1;
  };
  Ke2.op_Equality = function(r5, t) {
    return r5.compareTo(t) == 0;
  };
  Ke2.op_Inequality = function(r5, t) {
    return r5.compareTo(t) != 0;
  };
  Ke2.op_GreaterThan = function(r5, t) {
    return r5.compareTo(t) > 0;
  };
  Ke2.op_LessThan = function(r5, t) {
    return r5.compareTo(t) < 0;
  };
  Ke2.op_Addition = function(r5, t) {
    return new Ke2(r5).add(new Ke2(t));
  };
  Ke2.op_Subtraction = function(r5, t) {
    return new Ke2(r5).subtract(new Ke2(t));
  };
  Ke2.Int128Mul = function(r5, t) {
    return new Ke2(r5).multiply(new Ke2(t));
  };
  Ke2.op_Division = function(r5, t) {
    return r5.divide(t);
  };
  Ke2.prototype.ToDouble = function() {
    return parseFloat(this.toString());
  };
  typeof lx3 > "u" && (lx3 = H$3(function(r5, t) {
    var e;
    if (typeof Object.getOwnPropertyNames > "u") {
      for (e in t.prototype) (typeof r5.prototype[e] > "u" || r5.prototype[e] == Object.prototype[e]) && (r5.prototype[e] = t.prototype[e]);
      for (e in t) typeof r5[e] > "u" && (r5[e] = t[e]);
      r5.$baseCtor = t;
    } else {
      for (var n4 = Object.getOwnPropertyNames(t.prototype), i = 0; i < n4.length; i++) typeof Object.getOwnPropertyDescriptor(r5.prototype, n4[i]) > "u" && Object.defineProperty(r5.prototype, n4[i], Object.getOwnPropertyDescriptor(t.prototype, n4[i]));
      for (e in t) typeof r5[e] > "u" && (r5[e] = t[e]);
      r5.$baseCtor = t;
    }
  }, "Inherit"));
  var lx3;
  C3.Path = function() {
    return [];
  };
  C3.Paths = function() {
    return [];
  };
  C3.DoublePoint = function() {
    var r5 = arguments;
    this.X = 0, this.Y = 0, r5.length == 1 ? (this.X = r5[0].X, this.Y = r5[0].Y) : r5.length == 2 && (this.X = r5[0], this.Y = r5[1]);
  };
  C3.DoublePoint0 = function() {
    this.X = 0, this.Y = 0;
  };
  C3.DoublePoint1 = function(r5) {
    this.X = r5.X, this.Y = r5.Y;
  };
  C3.DoublePoint2 = function(r5, t) {
    this.X = r5, this.Y = t;
  };
  C3.PolyNode = function() {
    this.m_Parent = null, this.m_polygon = new C3.Path(), this.m_Index = 0, this.m_jointype = 0, this.m_endtype = 0, this.m_Childs = [], this.IsOpen = false;
  };
  C3.PolyNode.prototype.IsHoleNode = function() {
    for (var r5 = true, t = this.m_Parent; t !== null; ) r5 = !r5, t = t.m_Parent;
    return r5;
  };
  C3.PolyNode.prototype.ChildCount = function() {
    return this.m_Childs.length;
  };
  C3.PolyNode.prototype.Contour = function() {
    return this.m_polygon;
  };
  C3.PolyNode.prototype.AddChild = function(r5) {
    var t = this.m_Childs.length;
    this.m_Childs.push(r5), r5.m_Parent = this, r5.m_Index = t;
  };
  C3.PolyNode.prototype.GetNext = function() {
    return this.m_Childs.length > 0 ? this.m_Childs[0] : this.GetNextSiblingUp();
  };
  C3.PolyNode.prototype.GetNextSiblingUp = function() {
    return this.m_Parent === null ? null : this.m_Index == this.m_Parent.m_Childs.length - 1 ? this.m_Parent.GetNextSiblingUp() : this.m_Parent.m_Childs[this.m_Index + 1];
  };
  C3.PolyNode.prototype.Childs = function() {
    return this.m_Childs;
  };
  C3.PolyNode.prototype.Parent = function() {
    return this.m_Parent;
  };
  C3.PolyNode.prototype.IsHole = function() {
    return this.IsHoleNode();
  };
  C3.PolyTree = function() {
    this.m_AllPolys = [], C3.PolyNode.call(this);
  };
  C3.PolyTree.prototype.Clear = function() {
    for (var r5 = 0, t = this.m_AllPolys.length; r5 < t; r5++) this.m_AllPolys[r5] = null;
    this.m_AllPolys.length = 0, this.m_Childs.length = 0;
  };
  C3.PolyTree.prototype.GetFirst = function() {
    return this.m_Childs.length > 0 ? this.m_Childs[0] : null;
  };
  C3.PolyTree.prototype.Total = function() {
    return this.m_AllPolys.length;
  };
  lx3(C3.PolyTree, C3.PolyNode);
  C3.Math_Abs_Int64 = C3.Math_Abs_Int32 = C3.Math_Abs_Double = function(r5) {
    return Math.abs(r5);
  };
  C3.Math_Max_Int32_Int32 = function(r5, t) {
    return Math.max(r5, t);
  };
  dr2.msie || dr2.opera || dr2.safari ? C3.Cast_Int32 = function(r5) {
    return r5 | 0;
  } : C3.Cast_Int32 = function(r5) {
    return ~~r5;
  };
  dr2.chrome ? C3.Cast_Int64 = function(r5) {
    return r5 < -2147483648 || r5 > 2147483647 ? r5 < 0 ? Math.ceil(r5) : Math.floor(r5) : ~~r5;
  } : dr2.firefox && typeof Number.toInteger == "function" ? C3.Cast_Int64 = function(r5) {
    return Number.toInteger(r5);
  } : dr2.msie7 || dr2.msie8 ? C3.Cast_Int64 = function(r5) {
    return parseInt(r5, 10);
  } : dr2.msie ? C3.Cast_Int64 = function(r5) {
    return r5 < -2147483648 || r5 > 2147483647 ? r5 < 0 ? Math.ceil(r5) : Math.floor(r5) : r5 | 0;
  } : C3.Cast_Int64 = function(r5) {
    return r5 < 0 ? Math.ceil(r5) : Math.floor(r5);
  };
  C3.Clear = function(r5) {
    r5.length = 0;
  };
  C3.PI = 3.141592653589793;
  C3.PI2 = 2 * 3.141592653589793;
  C3.IntPoint = function() {
    var r5 = arguments, t = r5.length;
    var e, n4;
    if (this.X = 0, this.Y = 0, Gh4) ;
    else if (t == 2) this.X = r5[0], this.Y = r5[1];
    else if (t == 1) if (r5[0] instanceof C3.DoublePoint) {
      var e = r5[0];
      this.X = C3.Clipper.Round(e.X), this.Y = C3.Clipper.Round(e.Y);
    } else {
      var n4 = r5[0];
      this.X = n4.X, this.Y = n4.Y;
    }
    else this.X = 0, this.Y = 0;
  };
  C3.IntPoint.op_Equality = function(r5, t) {
    return r5.X == t.X && r5.Y == t.Y;
  };
  C3.IntPoint.op_Inequality = function(r5, t) {
    return r5.X != t.X || r5.Y != t.Y;
  };
  C3.IntPoint0 = function() {
    this.X = 0, this.Y = 0;
  }, C3.IntPoint1 = function(r5) {
    this.X = r5.X, this.Y = r5.Y;
  }, C3.IntPoint1dp = function(r5) {
    this.X = C3.Clipper.Round(r5.X), this.Y = C3.Clipper.Round(r5.Y);
  }, C3.IntPoint2 = function(r5, t) {
    this.X = r5, this.Y = t;
  };
  C3.IntRect = function() {
    var r5 = arguments, t = r5.length;
    t == 4 ? (this.left = r5[0], this.top = r5[1], this.right = r5[2], this.bottom = r5[3]) : t == 1 ? (this.left = ir.left, this.top = ir.top, this.right = ir.right, this.bottom = ir.bottom) : (this.left = 0, this.top = 0, this.right = 0, this.bottom = 0);
  };
  C3.IntRect0 = function() {
    this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  };
  C3.IntRect1 = function(r5) {
    this.left = r5.left, this.top = r5.top, this.right = r5.right, this.bottom = r5.bottom;
  };
  C3.IntRect4 = function(r5, t, e, n4) {
    this.left = r5, this.top = t, this.right = e, this.bottom = n4;
  };
  C3.ClipType = { ctIntersection: 0, ctUnion: 1, ctDifference: 2, ctXor: 3 };
  C3.PolyType = { ptSubject: 0, ptClip: 1 };
  C3.PolyFillType = { pftEvenOdd: 0, pftNonZero: 1, pftPositive: 2, pftNegative: 3 };
  C3.JoinType = { jtSquare: 0, jtRound: 1, jtMiter: 2 };
  C3.EndType = { etOpenSquare: 0, etOpenRound: 1, etOpenButt: 2, etClosedLine: 3, etClosedPolygon: 4 };
  C3.EdgeSide = { esLeft: 0, esRight: 1 };
  C3.Direction = { dRightToLeft: 0, dLeftToRight: 1 };
  C3.TEdge = function() {
    this.Bot = new C3.IntPoint(), this.Curr = new C3.IntPoint(), this.Top = new C3.IntPoint(), this.Delta = new C3.IntPoint(), this.Dx = 0, this.PolyTyp = C3.PolyType.ptSubject, this.Side = C3.EdgeSide.esLeft, this.WindDelta = 0, this.WindCnt = 0, this.WindCnt2 = 0, this.OutIdx = 0, this.Next = null, this.Prev = null, this.NextInLML = null, this.NextInAEL = null, this.PrevInAEL = null, this.NextInSEL = null, this.PrevInSEL = null;
  };
  C3.IntersectNode = function() {
    this.Edge1 = null, this.Edge2 = null, this.Pt = new C3.IntPoint();
  };
  C3.MyIntersectNodeSort = function() {
  };
  C3.MyIntersectNodeSort.Compare = function(r5, t) {
    return t.Pt.Y - r5.Pt.Y;
  };
  C3.LocalMinima = function() {
    this.Y = 0, this.LeftBound = null, this.RightBound = null, this.Next = null;
  };
  C3.Scanbeam = function() {
    this.Y = 0, this.Next = null;
  };
  C3.OutRec = function() {
    this.Idx = 0, this.IsHole = false, this.IsOpen = false, this.FirstLeft = null, this.Pts = null, this.BottomPt = null, this.PolyNode = null;
  };
  C3.OutPt = function() {
    this.Idx = 0, this.Pt = new C3.IntPoint(), this.Next = null, this.Prev = null;
  };
  C3.Join = function() {
    this.OutPt1 = null, this.OutPt2 = null, this.OffPt = new C3.IntPoint();
  };
  C3.ClipperBase = function() {
    this.m_MinimaList = null, this.m_CurrentLM = null, this.m_edges = new Array(), this.m_UseFullRange = false, this.m_HasOpenPaths = false, this.PreserveCollinear = false, this.m_MinimaList = null, this.m_CurrentLM = null, this.m_UseFullRange = false, this.m_HasOpenPaths = false;
  };
  C3.ClipperBase.horizontal = -9007199254740992;
  C3.ClipperBase.Skip = -2;
  C3.ClipperBase.Unassigned = -1;
  C3.ClipperBase.tolerance = 1e-20;
  C3.ClipperBase.loRange = 47453132, C3.ClipperBase.hiRange = 4503599627370495;
  C3.ClipperBase.near_zero = function(r5) {
    return r5 > -C3.ClipperBase.tolerance && r5 < C3.ClipperBase.tolerance;
  };
  C3.ClipperBase.IsHorizontal = function(r5) {
    return r5.Delta.Y === 0;
  };
  C3.ClipperBase.prototype.PointIsVertex = function(r5, t) {
    var e = t;
    do {
      if (C3.IntPoint.op_Equality(e.Pt, r5)) return true;
      e = e.Next;
    } while (e != t);
    return false;
  };
  C3.ClipperBase.prototype.PointOnLineSegment = function(r5, t, e, n4) {
    return n4 ? r5.X == t.X && r5.Y == t.Y || r5.X == e.X && r5.Y == e.Y || r5.X > t.X == r5.X < e.X && r5.Y > t.Y == r5.Y < e.Y && Ke2.op_Equality(Ke2.Int128Mul(r5.X - t.X, e.Y - t.Y), Ke2.Int128Mul(e.X - t.X, r5.Y - t.Y)) : r5.X == t.X && r5.Y == t.Y || r5.X == e.X && r5.Y == e.Y || r5.X > t.X == r5.X < e.X && r5.Y > t.Y == r5.Y < e.Y && (r5.X - t.X) * (e.Y - t.Y) == (e.X - t.X) * (r5.Y - t.Y);
  };
  C3.ClipperBase.prototype.PointOnPolygon = function(r5, t, e) {
    for (var n4 = t; ; ) {
      if (this.PointOnLineSegment(r5, n4.Pt, n4.Next.Pt, e)) return true;
      if (n4 = n4.Next, n4 == t) break;
    }
    return false;
  };
  C3.ClipperBase.prototype.SlopesEqual = C3.ClipperBase.SlopesEqual = function() {
    var r5 = arguments, t = r5.length, e, n4, i, a4, u5, h, d;
    return t == 3 ? (e = r5[0], n4 = r5[1], d = r5[2], d ? Ke2.op_Equality(Ke2.Int128Mul(e.Delta.Y, n4.Delta.X), Ke2.Int128Mul(e.Delta.X, n4.Delta.Y)) : C3.Cast_Int64(e.Delta.Y * n4.Delta.X) == C3.Cast_Int64(e.Delta.X * n4.Delta.Y)) : t == 4 ? (i = r5[0], a4 = r5[1], u5 = r5[2], d = r5[3], d ? Ke2.op_Equality(Ke2.Int128Mul(i.Y - a4.Y, a4.X - u5.X), Ke2.Int128Mul(i.X - a4.X, a4.Y - u5.Y)) : C3.Cast_Int64((i.Y - a4.Y) * (a4.X - u5.X)) - C3.Cast_Int64((i.X - a4.X) * (a4.Y - u5.Y)) === 0) : (i = r5[0], a4 = r5[1], u5 = r5[2], h = r5[3], d = r5[4], d ? Ke2.op_Equality(Ke2.Int128Mul(i.Y - a4.Y, u5.X - h.X), Ke2.Int128Mul(i.X - a4.X, u5.Y - h.Y)) : C3.Cast_Int64((i.Y - a4.Y) * (u5.X - h.X)) - C3.Cast_Int64((i.X - a4.X) * (u5.Y - h.Y)) === 0);
  };
  C3.ClipperBase.SlopesEqual3 = function(r5, t, e) {
    return e ? Ke2.op_Equality(Ke2.Int128Mul(r5.Delta.Y, t.Delta.X), Ke2.Int128Mul(r5.Delta.X, t.Delta.Y)) : C3.Cast_Int64(r5.Delta.Y * t.Delta.X) == C3.Cast_Int64(r5.Delta.X * t.Delta.Y);
  };
  C3.ClipperBase.SlopesEqual4 = function(r5, t, e, n4) {
    return n4 ? Ke2.op_Equality(Ke2.Int128Mul(r5.Y - t.Y, t.X - e.X), Ke2.Int128Mul(r5.X - t.X, t.Y - e.Y)) : C3.Cast_Int64((r5.Y - t.Y) * (t.X - e.X)) - C3.Cast_Int64((r5.X - t.X) * (t.Y - e.Y)) === 0;
  };
  C3.ClipperBase.SlopesEqual5 = function(r5, t, e, n4, i) {
    return i ? Ke2.op_Equality(Ke2.Int128Mul(r5.Y - t.Y, e.X - n4.X), Ke2.Int128Mul(r5.X - t.X, e.Y - n4.Y)) : C3.Cast_Int64((r5.Y - t.Y) * (e.X - n4.X)) - C3.Cast_Int64((r5.X - t.X) * (e.Y - n4.Y)) === 0;
  };
  C3.ClipperBase.prototype.Clear = function() {
    this.DisposeLocalMinimaList();
    for (var r5 = 0, t = this.m_edges.length; r5 < t; ++r5) {
      for (var e = 0, n4 = this.m_edges[r5].length; e < n4; ++e) this.m_edges[r5][e] = null;
      C3.Clear(this.m_edges[r5]);
    }
    C3.Clear(this.m_edges), this.m_UseFullRange = false, this.m_HasOpenPaths = false;
  };
  C3.ClipperBase.prototype.DisposeLocalMinimaList = function() {
    for (; this.m_MinimaList !== null; ) {
      var r5 = this.m_MinimaList.Next;
      this.m_MinimaList = null, this.m_MinimaList = r5;
    }
    this.m_CurrentLM = null;
  };
  C3.ClipperBase.prototype.RangeTest = function(r5, t) {
    t.Value ? (r5.X > C3.ClipperBase.hiRange || r5.Y > C3.ClipperBase.hiRange || -r5.X > C3.ClipperBase.hiRange || -r5.Y > C3.ClipperBase.hiRange) && C3.Error("Coordinate outside allowed range in RangeTest().") : (r5.X > C3.ClipperBase.loRange || r5.Y > C3.ClipperBase.loRange || -r5.X > C3.ClipperBase.loRange || -r5.Y > C3.ClipperBase.loRange) && (t.Value = true, this.RangeTest(r5, t));
  };
  C3.ClipperBase.prototype.InitEdge = function(r5, t, e, n4) {
    r5.Next = t, r5.Prev = e, r5.Curr.X = n4.X, r5.Curr.Y = n4.Y, r5.OutIdx = -1;
  };
  C3.ClipperBase.prototype.InitEdge2 = function(r5, t) {
    r5.Curr.Y >= r5.Next.Curr.Y ? (r5.Bot.X = r5.Curr.X, r5.Bot.Y = r5.Curr.Y, r5.Top.X = r5.Next.Curr.X, r5.Top.Y = r5.Next.Curr.Y) : (r5.Top.X = r5.Curr.X, r5.Top.Y = r5.Curr.Y, r5.Bot.X = r5.Next.Curr.X, r5.Bot.Y = r5.Next.Curr.Y), this.SetDx(r5), r5.PolyTyp = t;
  };
  C3.ClipperBase.prototype.FindNextLocMin = function(r5) {
    for (var t; ; ) {
      for (; C3.IntPoint.op_Inequality(r5.Bot, r5.Prev.Bot) || C3.IntPoint.op_Equality(r5.Curr, r5.Top); ) r5 = r5.Next;
      if (r5.Dx != C3.ClipperBase.horizontal && r5.Prev.Dx != C3.ClipperBase.horizontal) break;
      for (; r5.Prev.Dx == C3.ClipperBase.horizontal; ) r5 = r5.Prev;
      for (t = r5; r5.Dx == C3.ClipperBase.horizontal; ) r5 = r5.Next;
      if (r5.Top.Y != r5.Prev.Bot.Y) {
        t.Prev.Bot.X < r5.Bot.X && (r5 = t);
        break;
      }
    }
    return r5;
  };
  C3.ClipperBase.prototype.ProcessBound = function(r5, t) {
    var e = r5, n4 = r5, i, a4;
    if (r5.Dx == C3.ClipperBase.horizontal && (t ? a4 = r5.Prev.Bot.X : a4 = r5.Next.Bot.X, r5.Bot.X != a4 && this.ReverseHorizontal(r5)), n4.OutIdx != C3.ClipperBase.Skip) if (t) {
      for (; n4.Top.Y == n4.Next.Bot.Y && n4.Next.OutIdx != C3.ClipperBase.Skip; ) n4 = n4.Next;
      if (n4.Dx == C3.ClipperBase.horizontal && n4.Next.OutIdx != C3.ClipperBase.Skip) {
        for (i = n4; i.Prev.Dx == C3.ClipperBase.horizontal; ) i = i.Prev;
        i.Prev.Top.X == n4.Next.Top.X ? t || (n4 = i.Prev) : i.Prev.Top.X > n4.Next.Top.X && (n4 = i.Prev);
      }
      for (; r5 != n4; ) r5.NextInLML = r5.Next, r5.Dx == C3.ClipperBase.horizontal && r5 != e && r5.Bot.X != r5.Prev.Top.X && this.ReverseHorizontal(r5), r5 = r5.Next;
      r5.Dx == C3.ClipperBase.horizontal && r5 != e && r5.Bot.X != r5.Prev.Top.X && this.ReverseHorizontal(r5), n4 = n4.Next;
    } else {
      for (; n4.Top.Y == n4.Prev.Bot.Y && n4.Prev.OutIdx != C3.ClipperBase.Skip; ) n4 = n4.Prev;
      if (n4.Dx == C3.ClipperBase.horizontal && n4.Prev.OutIdx != C3.ClipperBase.Skip) {
        for (i = n4; i.Next.Dx == C3.ClipperBase.horizontal; ) i = i.Next;
        i.Next.Top.X == n4.Prev.Top.X ? t || (n4 = i.Next) : i.Next.Top.X > n4.Prev.Top.X && (n4 = i.Next);
      }
      for (; r5 != n4; ) r5.NextInLML = r5.Prev, r5.Dx == C3.ClipperBase.horizontal && r5 != e && r5.Bot.X != r5.Next.Top.X && this.ReverseHorizontal(r5), r5 = r5.Prev;
      r5.Dx == C3.ClipperBase.horizontal && r5 != e && r5.Bot.X != r5.Next.Top.X && this.ReverseHorizontal(r5), n4 = n4.Prev;
    }
    if (n4.OutIdx == C3.ClipperBase.Skip) {
      if (r5 = n4, t) {
        for (; r5.Top.Y == r5.Next.Bot.Y; ) r5 = r5.Next;
        for (; r5 != n4 && r5.Dx == C3.ClipperBase.horizontal; ) r5 = r5.Prev;
      } else {
        for (; r5.Top.Y == r5.Prev.Bot.Y; ) r5 = r5.Prev;
        for (; r5 != n4 && r5.Dx == C3.ClipperBase.horizontal; ) r5 = r5.Next;
      }
      if (r5 == n4) t ? n4 = r5.Next : n4 = r5.Prev;
      else {
        t ? r5 = n4.Next : r5 = n4.Prev;
        var u5 = new C3.LocalMinima();
        u5.Next = null, u5.Y = r5.Bot.Y, u5.LeftBound = null, u5.RightBound = r5, u5.RightBound.WindDelta = 0, n4 = this.ProcessBound(u5.RightBound, t), this.InsertLocalMinima(u5);
      }
    }
    return n4;
  };
  C3.ClipperBase.prototype.AddPath = function(r5, t, e) {
    !e && t == C3.PolyType.ptClip && C3.Error("AddPath: Open paths must be subject.");
    var n4 = r5.length - 1;
    if (e) for (; n4 > 0 && C3.IntPoint.op_Equality(r5[n4], r5[0]); ) --n4;
    for (; n4 > 0 && C3.IntPoint.op_Equality(r5[n4], r5[n4 - 1]); ) --n4;
    if (e && n4 < 2 || !e && n4 < 1) return false;
    for (var i = new Array(), a4 = 0; a4 <= n4; a4++) i.push(new C3.TEdge());
    var u5 = true;
    i[1].Curr.X = r5[1].X, i[1].Curr.Y = r5[1].Y;
    var h = { Value: this.m_UseFullRange };
    this.RangeTest(r5[0], h), this.m_UseFullRange = h.Value, h.Value = this.m_UseFullRange, this.RangeTest(r5[n4], h), this.m_UseFullRange = h.Value, this.InitEdge(i[0], i[1], i[n4], r5[0]), this.InitEdge(i[n4], i[0], i[n4 - 1], r5[n4]);
    for (var a4 = n4 - 1; a4 >= 1; --a4) h.Value = this.m_UseFullRange, this.RangeTest(r5[a4], h), this.m_UseFullRange = h.Value, this.InitEdge(i[a4], i[a4 + 1], i[a4 - 1], r5[a4]);
    for (var d = i[0], m5 = d, v3 = d; ; ) {
      if (C3.IntPoint.op_Equality(m5.Curr, m5.Next.Curr)) {
        if (m5 == m5.Next) break;
        m5 == d && (d = m5.Next), m5 = this.RemoveEdge(m5), v3 = m5;
        continue;
      }
      if (m5.Prev == m5.Next) break;
      if (e && C3.ClipperBase.SlopesEqual(m5.Prev.Curr, m5.Curr, m5.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(m5.Prev.Curr, m5.Curr, m5.Next.Curr))) {
        m5 == d && (d = m5.Next), m5 = this.RemoveEdge(m5), m5 = m5.Prev, v3 = m5;
        continue;
      }
      if (m5 = m5.Next, m5 == v3) break;
    }
    if (!e && m5 == m5.Next || e && m5.Prev == m5.Next) return false;
    e || (this.m_HasOpenPaths = true, d.Prev.OutIdx = C3.ClipperBase.Skip);
    m5 = d;
    do
      this.InitEdge2(m5, t), m5 = m5.Next, u5 && m5.Curr.Y != d.Curr.Y && (u5 = false);
    while (m5 != d);
    if (u5) {
      if (e) return false;
      m5.Prev.OutIdx = C3.ClipperBase.Skip, m5.Prev.Bot.X < m5.Prev.Top.X && this.ReverseHorizontal(m5.Prev);
      var S4 = new C3.LocalMinima();
      for (S4.Next = null, S4.Y = m5.Bot.Y, S4.LeftBound = null, S4.RightBound = m5, S4.RightBound.Side = C3.EdgeSide.esRight, S4.RightBound.WindDelta = 0; m5.Next.OutIdx != C3.ClipperBase.Skip; ) m5.NextInLML = m5.Next, m5.Bot.X != m5.Prev.Top.X && this.ReverseHorizontal(m5), m5 = m5.Next;
      return this.InsertLocalMinima(S4), this.m_edges.push(i), true;
    }
    this.m_edges.push(i);
    for (var I3, w3 = null; m5 = this.FindNextLocMin(m5), m5 != w3; ) {
      w3 == null && (w3 = m5);
      var S4 = new C3.LocalMinima();
      S4.Next = null, S4.Y = m5.Bot.Y, m5.Dx < m5.Prev.Dx ? (S4.LeftBound = m5.Prev, S4.RightBound = m5, I3 = false) : (S4.LeftBound = m5, S4.RightBound = m5.Prev, I3 = true), S4.LeftBound.Side = C3.EdgeSide.esLeft, S4.RightBound.Side = C3.EdgeSide.esRight, e ? S4.LeftBound.Next == S4.RightBound ? S4.LeftBound.WindDelta = -1 : S4.LeftBound.WindDelta = 1 : S4.LeftBound.WindDelta = 0, S4.RightBound.WindDelta = -S4.LeftBound.WindDelta, m5 = this.ProcessBound(S4.LeftBound, I3);
      var E4 = this.ProcessBound(S4.RightBound, !I3);
      S4.LeftBound.OutIdx == C3.ClipperBase.Skip ? S4.LeftBound = null : S4.RightBound.OutIdx == C3.ClipperBase.Skip && (S4.RightBound = null), this.InsertLocalMinima(S4), I3 || (m5 = E4);
    }
    return true;
  };
  C3.ClipperBase.prototype.AddPaths = function(r5, t, e) {
    for (var n4 = false, i = 0, a4 = r5.length; i < a4; ++i) this.AddPath(r5[i], t, e) && (n4 = true);
    return n4;
  };
  C3.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function(r5, t, e) {
    return C3.IntPoint.op_Equality(r5, e) || C3.IntPoint.op_Equality(r5, t) || C3.IntPoint.op_Equality(e, t) ? false : r5.X != e.X ? t.X > r5.X == t.X < e.X : t.Y > r5.Y == t.Y < e.Y;
  };
  C3.ClipperBase.prototype.RemoveEdge = function(r5) {
    r5.Prev.Next = r5.Next, r5.Next.Prev = r5.Prev;
    var t = r5.Next;
    return r5.Prev = null, t;
  };
  C3.ClipperBase.prototype.SetDx = function(r5) {
    r5.Delta.X = r5.Top.X - r5.Bot.X, r5.Delta.Y = r5.Top.Y - r5.Bot.Y, r5.Delta.Y === 0 ? r5.Dx = C3.ClipperBase.horizontal : r5.Dx = r5.Delta.X / r5.Delta.Y;
  };
  C3.ClipperBase.prototype.InsertLocalMinima = function(r5) {
    if (this.m_MinimaList === null) this.m_MinimaList = r5;
    else if (r5.Y >= this.m_MinimaList.Y) r5.Next = this.m_MinimaList, this.m_MinimaList = r5;
    else {
      for (var t = this.m_MinimaList; t.Next !== null && r5.Y < t.Next.Y; ) t = t.Next;
      r5.Next = t.Next, t.Next = r5;
    }
  };
  C3.ClipperBase.prototype.PopLocalMinima = function() {
    this.m_CurrentLM !== null && (this.m_CurrentLM = this.m_CurrentLM.Next);
  };
  C3.ClipperBase.prototype.ReverseHorizontal = function(r5) {
    var t = r5.Top.X;
    r5.Top.X = r5.Bot.X, r5.Bot.X = t;
  };
  C3.ClipperBase.prototype.Reset = function() {
    if (this.m_CurrentLM = this.m_MinimaList, this.m_CurrentLM != null) for (var r5 = this.m_MinimaList; r5 != null; ) {
      var t = r5.LeftBound;
      t != null && (t.Curr.X = t.Bot.X, t.Curr.Y = t.Bot.Y, t.Side = C3.EdgeSide.esLeft, t.OutIdx = C3.ClipperBase.Unassigned), t = r5.RightBound, t != null && (t.Curr.X = t.Bot.X, t.Curr.Y = t.Bot.Y, t.Side = C3.EdgeSide.esRight, t.OutIdx = C3.ClipperBase.Unassigned), r5 = r5.Next;
    }
  };
  C3.Clipper = function(r5) {
    typeof r5 > "u" && (r5 = 0), this.m_PolyOuts = null, this.m_ClipType = C3.ClipType.ctIntersection, this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null, this.m_IntersectList = null, this.m_IntersectNodeComparer = null, this.m_ExecuteLocked = false, this.m_ClipFillType = C3.PolyFillType.pftEvenOdd, this.m_SubjFillType = C3.PolyFillType.pftEvenOdd, this.m_Joins = null, this.m_GhostJoins = null, this.m_UsingPolyTree = false, this.ReverseSolution = false, this.StrictlySimple = false, C3.ClipperBase.call(this), this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null, this.m_IntersectList = new Array(), this.m_IntersectNodeComparer = C3.MyIntersectNodeSort.Compare, this.m_ExecuteLocked = false, this.m_UsingPolyTree = false, this.m_PolyOuts = new Array(), this.m_Joins = new Array(), this.m_GhostJoins = new Array(), this.ReverseSolution = (1 & r5) !== 0, this.StrictlySimple = (2 & r5) !== 0, this.PreserveCollinear = (4 & r5) !== 0;
  };
  C3.Clipper.ioReverseSolution = 1;
  C3.Clipper.ioStrictlySimple = 2;
  C3.Clipper.ioPreserveCollinear = 4;
  C3.Clipper.prototype.Clear = function() {
    this.m_edges.length !== 0 && (this.DisposeAllPolyPts(), C3.ClipperBase.prototype.Clear.call(this));
  };
  C3.Clipper.prototype.DisposeScanbeamList = function() {
    for (; this.m_Scanbeam !== null; ) {
      var r5 = this.m_Scanbeam.Next;
      this.m_Scanbeam = null, this.m_Scanbeam = r5;
    }
  };
  C3.Clipper.prototype.Reset = function() {
    C3.ClipperBase.prototype.Reset.call(this), this.m_Scanbeam = null, this.m_ActiveEdges = null, this.m_SortedEdges = null;
    for (var r5 = this.m_MinimaList; r5 !== null; ) this.InsertScanbeam(r5.Y), r5 = r5.Next;
  };
  C3.Clipper.prototype.InsertScanbeam = function(r5) {
    if (this.m_Scanbeam === null) this.m_Scanbeam = new C3.Scanbeam(), this.m_Scanbeam.Next = null, this.m_Scanbeam.Y = r5;
    else if (r5 > this.m_Scanbeam.Y) {
      var t = new C3.Scanbeam();
      t.Y = r5, t.Next = this.m_Scanbeam, this.m_Scanbeam = t;
    } else {
      for (var e = this.m_Scanbeam; e.Next !== null && r5 <= e.Next.Y; ) e = e.Next;
      if (r5 == e.Y) return;
      var t = new C3.Scanbeam();
      t.Y = r5, t.Next = e.Next, e.Next = t;
    }
  };
  C3.Clipper.prototype.Execute = function() {
    var r5 = arguments, t = r5.length, e = r5[1] instanceof C3.PolyTree;
    if (t == 4 && !e) {
      var n4 = r5[0], i = r5[1], a4 = r5[2], u5 = r5[3];
      if (this.m_ExecuteLocked) return false;
      this.m_HasOpenPaths && C3.Error("Error: PolyTree struct is need for open path clipping."), this.m_ExecuteLocked = true, C3.Clear(i), this.m_SubjFillType = a4, this.m_ClipFillType = u5, this.m_ClipType = n4, this.m_UsingPolyTree = false;
      try {
        var h = this.ExecuteInternal();
        h && this.BuildResult(i);
      } finally {
        this.DisposeAllPolyPts(), this.m_ExecuteLocked = false;
      }
      return h;
    } else if (t == 4 && e) {
      var n4 = r5[0], d = r5[1], a4 = r5[2], u5 = r5[3];
      if (this.m_ExecuteLocked) return false;
      this.m_ExecuteLocked = true, this.m_SubjFillType = a4, this.m_ClipFillType = u5, this.m_ClipType = n4, this.m_UsingPolyTree = true;
      try {
        var h = this.ExecuteInternal();
        h && this.BuildResult2(d);
      } finally {
        this.DisposeAllPolyPts(), this.m_ExecuteLocked = false;
      }
      return h;
    } else if (t == 2 && !e) {
      var n4 = r5[0], i = r5[1];
      return this.Execute(n4, i, C3.PolyFillType.pftEvenOdd, C3.PolyFillType.pftEvenOdd);
    } else if (t == 2 && e) {
      var n4 = r5[0], d = r5[1];
      return this.Execute(n4, d, C3.PolyFillType.pftEvenOdd, C3.PolyFillType.pftEvenOdd);
    }
  };
  C3.Clipper.prototype.FixHoleLinkage = function(r5) {
    if (!(r5.FirstLeft === null || r5.IsHole != r5.FirstLeft.IsHole && r5.FirstLeft.Pts !== null)) {
      for (var t = r5.FirstLeft; t !== null && (t.IsHole == r5.IsHole || t.Pts === null); ) t = t.FirstLeft;
      r5.FirstLeft = t;
    }
  };
  C3.Clipper.prototype.ExecuteInternal = function() {
    try {
      if (this.Reset(), this.m_CurrentLM === null) return false;
      var r5 = this.PopScanbeam();
      do {
        if (this.InsertLocalMinimaIntoAEL(r5), C3.Clear(this.m_GhostJoins), this.ProcessHorizontals(false), this.m_Scanbeam === null) break;
        var t = this.PopScanbeam();
        if (!this.ProcessIntersections(r5, t)) return false;
        this.ProcessEdgesAtTopOfScanbeam(t), r5 = t;
      } while (this.m_Scanbeam !== null || this.m_CurrentLM !== null);
      for (var e = 0, n4 = this.m_PolyOuts.length; e < n4; e++) {
        var i = this.m_PolyOuts[e];
        i.Pts === null || i.IsOpen || (i.IsHole ^ this.ReverseSolution) == this.Area(i) > 0 && this.ReversePolyPtLinks(i.Pts);
      }
      this.JoinCommonEdges();
      for (var e = 0, n4 = this.m_PolyOuts.length; e < n4; e++) {
        var i = this.m_PolyOuts[e];
        i.Pts !== null && !i.IsOpen && this.FixupOutPolygon(i);
      }
      return this.StrictlySimple && this.DoSimplePolygons(), true;
    } finally {
      C3.Clear(this.m_Joins), C3.Clear(this.m_GhostJoins);
    }
  };
  C3.Clipper.prototype.PopScanbeam = function() {
    var r5 = this.m_Scanbeam.Y;
    this.m_Scanbeam;
    return this.m_Scanbeam = this.m_Scanbeam.Next, r5;
  };
  C3.Clipper.prototype.DisposeAllPolyPts = function() {
    for (var r5 = 0, t = this.m_PolyOuts.length; r5 < t; ++r5) this.DisposeOutRec(r5);
    C3.Clear(this.m_PolyOuts);
  };
  C3.Clipper.prototype.DisposeOutRec = function(r5) {
    var t = this.m_PolyOuts[r5];
    t.Pts !== null && this.DisposeOutPts(t.Pts), t = null, this.m_PolyOuts[r5] = null;
  };
  C3.Clipper.prototype.DisposeOutPts = function(r5) {
    if (r5 !== null) {
      for (r5.Prev.Next = null; r5 !== null; ) r5 = r5.Next;
    }
  };
  C3.Clipper.prototype.AddJoin = function(r5, t, e) {
    var n4 = new C3.Join();
    n4.OutPt1 = r5, n4.OutPt2 = t, n4.OffPt.X = e.X, n4.OffPt.Y = e.Y, this.m_Joins.push(n4);
  };
  C3.Clipper.prototype.AddGhostJoin = function(r5, t) {
    var e = new C3.Join();
    e.OutPt1 = r5, e.OffPt.X = t.X, e.OffPt.Y = t.Y, this.m_GhostJoins.push(e);
  };
  C3.Clipper.prototype.InsertLocalMinimaIntoAEL = function(r5) {
    for (; this.m_CurrentLM !== null && this.m_CurrentLM.Y == r5; ) {
      var t = this.m_CurrentLM.LeftBound, e = this.m_CurrentLM.RightBound;
      this.PopLocalMinima();
      var n4 = null;
      if (t === null ? (this.InsertEdgeIntoAEL(e, null), this.SetWindingCount(e), this.IsContributing(e) && (n4 = this.AddOutPt(e, e.Bot))) : e == null ? (this.InsertEdgeIntoAEL(t, null), this.SetWindingCount(t), this.IsContributing(t) && (n4 = this.AddOutPt(t, t.Bot)), this.InsertScanbeam(t.Top.Y)) : (this.InsertEdgeIntoAEL(t, null), this.InsertEdgeIntoAEL(e, t), this.SetWindingCount(t), e.WindCnt = t.WindCnt, e.WindCnt2 = t.WindCnt2, this.IsContributing(t) && (n4 = this.AddLocalMinPoly(t, e, t.Bot)), this.InsertScanbeam(t.Top.Y)), e != null && (C3.ClipperBase.IsHorizontal(e) ? this.AddEdgeToSEL(e) : this.InsertScanbeam(e.Top.Y)), !(t == null || e == null)) {
        if (n4 !== null && C3.ClipperBase.IsHorizontal(e) && this.m_GhostJoins.length > 0 && e.WindDelta !== 0) for (var i = 0, a4 = this.m_GhostJoins.length; i < a4; i++) {
          var u5 = this.m_GhostJoins[i];
          this.HorzSegmentsOverlap(u5.OutPt1.Pt, u5.OffPt, e.Bot, e.Top) && this.AddJoin(u5.OutPt1, n4, u5.OffPt);
        }
        if (t.OutIdx >= 0 && t.PrevInAEL !== null && t.PrevInAEL.Curr.X == t.Bot.X && t.PrevInAEL.OutIdx >= 0 && C3.ClipperBase.SlopesEqual(t.PrevInAEL, t, this.m_UseFullRange) && t.WindDelta !== 0 && t.PrevInAEL.WindDelta !== 0) {
          var h = this.AddOutPt(t.PrevInAEL, t.Bot);
          this.AddJoin(n4, h, t.Top);
        }
        if (t.NextInAEL != e) {
          if (e.OutIdx >= 0 && e.PrevInAEL.OutIdx >= 0 && C3.ClipperBase.SlopesEqual(e.PrevInAEL, e, this.m_UseFullRange) && e.WindDelta !== 0 && e.PrevInAEL.WindDelta !== 0) {
            var h = this.AddOutPt(e.PrevInAEL, e.Bot);
            this.AddJoin(n4, h, e.Top);
          }
          var d = t.NextInAEL;
          if (d !== null) for (; d != e; ) this.IntersectEdges(e, d, t.Curr, false), d = d.NextInAEL;
        }
      }
    }
  };
  C3.Clipper.prototype.InsertEdgeIntoAEL = function(r5, t) {
    if (this.m_ActiveEdges === null) r5.PrevInAEL = null, r5.NextInAEL = null, this.m_ActiveEdges = r5;
    else if (t === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, r5)) r5.PrevInAEL = null, r5.NextInAEL = this.m_ActiveEdges, this.m_ActiveEdges.PrevInAEL = r5, this.m_ActiveEdges = r5;
    else {
      for (t === null && (t = this.m_ActiveEdges); t.NextInAEL !== null && !this.E2InsertsBeforeE1(t.NextInAEL, r5); ) t = t.NextInAEL;
      r5.NextInAEL = t.NextInAEL, t.NextInAEL !== null && (t.NextInAEL.PrevInAEL = r5), r5.PrevInAEL = t, t.NextInAEL = r5;
    }
  };
  C3.Clipper.prototype.E2InsertsBeforeE1 = function(r5, t) {
    return t.Curr.X == r5.Curr.X ? t.Top.Y > r5.Top.Y ? t.Top.X < C3.Clipper.TopX(r5, t.Top.Y) : r5.Top.X > C3.Clipper.TopX(t, r5.Top.Y) : t.Curr.X < r5.Curr.X;
  };
  C3.Clipper.prototype.IsEvenOddFillType = function(r5) {
    return r5.PolyTyp == C3.PolyType.ptSubject ? this.m_SubjFillType == C3.PolyFillType.pftEvenOdd : this.m_ClipFillType == C3.PolyFillType.pftEvenOdd;
  };
  C3.Clipper.prototype.IsEvenOddAltFillType = function(r5) {
    return r5.PolyTyp == C3.PolyType.ptSubject ? this.m_ClipFillType == C3.PolyFillType.pftEvenOdd : this.m_SubjFillType == C3.PolyFillType.pftEvenOdd;
  };
  C3.Clipper.prototype.IsContributing = function(r5) {
    var t, e;
    switch (r5.PolyTyp == C3.PolyType.ptSubject ? (t = this.m_SubjFillType, e = this.m_ClipFillType) : (t = this.m_ClipFillType, e = this.m_SubjFillType), t) {
      case C3.PolyFillType.pftEvenOdd:
        if (r5.WindDelta === 0 && r5.WindCnt != 1) return false;
        break;
      case C3.PolyFillType.pftNonZero:
        if (Math.abs(r5.WindCnt) != 1) return false;
        break;
      case C3.PolyFillType.pftPositive:
        if (r5.WindCnt != 1) return false;
        break;
      default:
        if (r5.WindCnt != -1) return false;
        break;
    }
    switch (this.m_ClipType) {
      case C3.ClipType.ctIntersection:
        switch (e) {
          case C3.PolyFillType.pftEvenOdd:
          case C3.PolyFillType.pftNonZero:
            return r5.WindCnt2 !== 0;
          case C3.PolyFillType.pftPositive:
            return r5.WindCnt2 > 0;
          default:
            return r5.WindCnt2 < 0;
        }
      case C3.ClipType.ctUnion:
        switch (e) {
          case C3.PolyFillType.pftEvenOdd:
          case C3.PolyFillType.pftNonZero:
            return r5.WindCnt2 === 0;
          case C3.PolyFillType.pftPositive:
            return r5.WindCnt2 <= 0;
          default:
            return r5.WindCnt2 >= 0;
        }
      case C3.ClipType.ctDifference:
        if (r5.PolyTyp == C3.PolyType.ptSubject) switch (e) {
          case C3.PolyFillType.pftEvenOdd:
          case C3.PolyFillType.pftNonZero:
            return r5.WindCnt2 === 0;
          case C3.PolyFillType.pftPositive:
            return r5.WindCnt2 <= 0;
          default:
            return r5.WindCnt2 >= 0;
        }
        else switch (e) {
          case C3.PolyFillType.pftEvenOdd:
          case C3.PolyFillType.pftNonZero:
            return r5.WindCnt2 !== 0;
          case C3.PolyFillType.pftPositive:
            return r5.WindCnt2 > 0;
          default:
            return r5.WindCnt2 < 0;
        }
      case C3.ClipType.ctXor:
        if (r5.WindDelta === 0) switch (e) {
          case C3.PolyFillType.pftEvenOdd:
          case C3.PolyFillType.pftNonZero:
            return r5.WindCnt2 === 0;
          case C3.PolyFillType.pftPositive:
            return r5.WindCnt2 <= 0;
          default:
            return r5.WindCnt2 >= 0;
        }
        else return true;
    }
    return true;
  };
  C3.Clipper.prototype.SetWindingCount = function(r5) {
    for (var t = r5.PrevInAEL; t !== null && (t.PolyTyp != r5.PolyTyp || t.WindDelta === 0); ) t = t.PrevInAEL;
    if (t === null) r5.WindCnt = r5.WindDelta === 0 ? 1 : r5.WindDelta, r5.WindCnt2 = 0, t = this.m_ActiveEdges;
    else if (r5.WindDelta === 0 && this.m_ClipType != C3.ClipType.ctUnion) r5.WindCnt = 1, r5.WindCnt2 = t.WindCnt2, t = t.NextInAEL;
    else if (this.IsEvenOddFillType(r5)) {
      if (r5.WindDelta === 0) {
        for (var e = true, n4 = t.PrevInAEL; n4 !== null; ) n4.PolyTyp == t.PolyTyp && n4.WindDelta !== 0 && (e = !e), n4 = n4.PrevInAEL;
        r5.WindCnt = e ? 0 : 1;
      } else r5.WindCnt = r5.WindDelta;
      r5.WindCnt2 = t.WindCnt2, t = t.NextInAEL;
    } else t.WindCnt * t.WindDelta < 0 ? Math.abs(t.WindCnt) > 1 ? t.WindDelta * r5.WindDelta < 0 ? r5.WindCnt = t.WindCnt : r5.WindCnt = t.WindCnt + r5.WindDelta : r5.WindCnt = r5.WindDelta === 0 ? 1 : r5.WindDelta : r5.WindDelta === 0 ? r5.WindCnt = t.WindCnt < 0 ? t.WindCnt - 1 : t.WindCnt + 1 : t.WindDelta * r5.WindDelta < 0 ? r5.WindCnt = t.WindCnt : r5.WindCnt = t.WindCnt + r5.WindDelta, r5.WindCnt2 = t.WindCnt2, t = t.NextInAEL;
    if (this.IsEvenOddAltFillType(r5)) for (; t != r5; ) t.WindDelta !== 0 && (r5.WindCnt2 = r5.WindCnt2 === 0 ? 1 : 0), t = t.NextInAEL;
    else for (; t != r5; ) r5.WindCnt2 += t.WindDelta, t = t.NextInAEL;
  };
  C3.Clipper.prototype.AddEdgeToSEL = function(r5) {
    this.m_SortedEdges === null ? (this.m_SortedEdges = r5, r5.PrevInSEL = null, r5.NextInSEL = null) : (r5.NextInSEL = this.m_SortedEdges, r5.PrevInSEL = null, this.m_SortedEdges.PrevInSEL = r5, this.m_SortedEdges = r5);
  };
  C3.Clipper.prototype.CopyAELToSEL = function() {
    var r5 = this.m_ActiveEdges;
    for (this.m_SortedEdges = r5; r5 !== null; ) r5.PrevInSEL = r5.PrevInAEL, r5.NextInSEL = r5.NextInAEL, r5 = r5.NextInAEL;
  };
  C3.Clipper.prototype.SwapPositionsInAEL = function(r5, t) {
    if (!(r5.NextInAEL == r5.PrevInAEL || t.NextInAEL == t.PrevInAEL)) {
      if (r5.NextInAEL == t) {
        var e = t.NextInAEL;
        e !== null && (e.PrevInAEL = r5);
        var n4 = r5.PrevInAEL;
        n4 !== null && (n4.NextInAEL = t), t.PrevInAEL = n4, t.NextInAEL = r5, r5.PrevInAEL = t, r5.NextInAEL = e;
      } else if (t.NextInAEL == r5) {
        var e = r5.NextInAEL;
        e !== null && (e.PrevInAEL = t);
        var n4 = t.PrevInAEL;
        n4 !== null && (n4.NextInAEL = r5), r5.PrevInAEL = n4, r5.NextInAEL = t, t.PrevInAEL = r5, t.NextInAEL = e;
      } else {
        var e = r5.NextInAEL, n4 = r5.PrevInAEL;
        r5.NextInAEL = t.NextInAEL, r5.NextInAEL !== null && (r5.NextInAEL.PrevInAEL = r5), r5.PrevInAEL = t.PrevInAEL, r5.PrevInAEL !== null && (r5.PrevInAEL.NextInAEL = r5), t.NextInAEL = e, t.NextInAEL !== null && (t.NextInAEL.PrevInAEL = t), t.PrevInAEL = n4, t.PrevInAEL !== null && (t.PrevInAEL.NextInAEL = t);
      }
      r5.PrevInAEL === null ? this.m_ActiveEdges = r5 : t.PrevInAEL === null && (this.m_ActiveEdges = t);
    }
  };
  C3.Clipper.prototype.SwapPositionsInSEL = function(r5, t) {
    if (!(r5.NextInSEL === null && r5.PrevInSEL === null) && !(t.NextInSEL === null && t.PrevInSEL === null)) {
      if (r5.NextInSEL == t) {
        var e = t.NextInSEL;
        e !== null && (e.PrevInSEL = r5);
        var n4 = r5.PrevInSEL;
        n4 !== null && (n4.NextInSEL = t), t.PrevInSEL = n4, t.NextInSEL = r5, r5.PrevInSEL = t, r5.NextInSEL = e;
      } else if (t.NextInSEL == r5) {
        var e = r5.NextInSEL;
        e !== null && (e.PrevInSEL = t);
        var n4 = t.PrevInSEL;
        n4 !== null && (n4.NextInSEL = r5), r5.PrevInSEL = n4, r5.NextInSEL = t, t.PrevInSEL = r5, t.NextInSEL = e;
      } else {
        var e = r5.NextInSEL, n4 = r5.PrevInSEL;
        r5.NextInSEL = t.NextInSEL, r5.NextInSEL !== null && (r5.NextInSEL.PrevInSEL = r5), r5.PrevInSEL = t.PrevInSEL, r5.PrevInSEL !== null && (r5.PrevInSEL.NextInSEL = r5), t.NextInSEL = e, t.NextInSEL !== null && (t.NextInSEL.PrevInSEL = t), t.PrevInSEL = n4, t.PrevInSEL !== null && (t.PrevInSEL.NextInSEL = t);
      }
      r5.PrevInSEL === null ? this.m_SortedEdges = r5 : t.PrevInSEL === null && (this.m_SortedEdges = t);
    }
  };
  C3.Clipper.prototype.AddLocalMaxPoly = function(r5, t, e) {
    this.AddOutPt(r5, e), t.WindDelta == 0 && this.AddOutPt(t, e), r5.OutIdx == t.OutIdx ? (r5.OutIdx = -1, t.OutIdx = -1) : r5.OutIdx < t.OutIdx ? this.AppendPolygon(r5, t) : this.AppendPolygon(t, r5);
  };
  C3.Clipper.prototype.AddLocalMinPoly = function(r5, t, e) {
    var n4, i, a4;
    if (C3.ClipperBase.IsHorizontal(t) || r5.Dx > t.Dx ? (n4 = this.AddOutPt(r5, e), t.OutIdx = r5.OutIdx, r5.Side = C3.EdgeSide.esLeft, t.Side = C3.EdgeSide.esRight, i = r5, i.PrevInAEL == t ? a4 = t.PrevInAEL : a4 = i.PrevInAEL) : (n4 = this.AddOutPt(t, e), r5.OutIdx = t.OutIdx, r5.Side = C3.EdgeSide.esRight, t.Side = C3.EdgeSide.esLeft, i = t, i.PrevInAEL == r5 ? a4 = r5.PrevInAEL : a4 = i.PrevInAEL), a4 !== null && a4.OutIdx >= 0 && C3.Clipper.TopX(a4, e.Y) == C3.Clipper.TopX(i, e.Y) && C3.ClipperBase.SlopesEqual(i, a4, this.m_UseFullRange) && i.WindDelta !== 0 && a4.WindDelta !== 0) {
      var u5 = this.AddOutPt(a4, e);
      this.AddJoin(n4, u5, i.Top);
    }
    return n4;
  };
  C3.Clipper.prototype.CreateOutRec = function() {
    var r5 = new C3.OutRec();
    return r5.Idx = -1, r5.IsHole = false, r5.IsOpen = false, r5.FirstLeft = null, r5.Pts = null, r5.BottomPt = null, r5.PolyNode = null, this.m_PolyOuts.push(r5), r5.Idx = this.m_PolyOuts.length - 1, r5;
  };
  C3.Clipper.prototype.AddOutPt = function(r5, t) {
    var e = r5.Side == C3.EdgeSide.esLeft;
    if (r5.OutIdx < 0) {
      var n4 = this.CreateOutRec();
      n4.IsOpen = r5.WindDelta === 0;
      var i = new C3.OutPt();
      return n4.Pts = i, i.Idx = n4.Idx, i.Pt.X = t.X, i.Pt.Y = t.Y, i.Next = i, i.Prev = i, n4.IsOpen || this.SetHoleState(r5, n4), r5.OutIdx = n4.Idx, i;
    } else {
      var n4 = this.m_PolyOuts[r5.OutIdx], a4 = n4.Pts;
      if (e && C3.IntPoint.op_Equality(t, a4.Pt)) return a4;
      if (!e && C3.IntPoint.op_Equality(t, a4.Prev.Pt)) return a4.Prev;
      var i = new C3.OutPt();
      return i.Idx = n4.Idx, i.Pt.X = t.X, i.Pt.Y = t.Y, i.Next = a4, i.Prev = a4.Prev, i.Prev.Next = i, a4.Prev = i, e && (n4.Pts = i), i;
    }
  };
  C3.Clipper.prototype.SwapPoints = function(r5, t) {
    var e = new C3.IntPoint(r5.Value);
    r5.Value.X = t.Value.X, r5.Value.Y = t.Value.Y, t.Value.X = e.X, t.Value.Y = e.Y;
  };
  C3.Clipper.prototype.HorzSegmentsOverlap = function(r5, t, e, n4) {
    return r5.X > e.X == r5.X < n4.X || t.X > e.X == t.X < n4.X || e.X > r5.X == e.X < t.X || n4.X > r5.X == n4.X < t.X || r5.X == e.X && t.X == n4.X ? true : r5.X == n4.X && t.X == e.X;
  };
  C3.Clipper.prototype.InsertPolyPtBetween = function(r5, t, e) {
    var n4 = new C3.OutPt();
    return n4.Pt.X = e.X, n4.Pt.Y = e.Y, t == r5.Next ? (r5.Next = n4, t.Prev = n4, n4.Next = t, n4.Prev = r5) : (t.Next = n4, r5.Prev = n4, n4.Next = r5, n4.Prev = t), n4;
  };
  C3.Clipper.prototype.SetHoleState = function(r5, t) {
    for (var e = false, n4 = r5.PrevInAEL; n4 !== null; ) n4.OutIdx >= 0 && n4.WindDelta != 0 && (e = !e, t.FirstLeft === null && (t.FirstLeft = this.m_PolyOuts[n4.OutIdx])), n4 = n4.PrevInAEL;
    e && (t.IsHole = true);
  };
  C3.Clipper.prototype.GetDx = function(r5, t) {
    return r5.Y == t.Y ? C3.ClipperBase.horizontal : (t.X - r5.X) / (t.Y - r5.Y);
  };
  C3.Clipper.prototype.FirstIsBottomPt = function(r5, t) {
    for (var e = r5.Prev; C3.IntPoint.op_Equality(e.Pt, r5.Pt) && e != r5; ) e = e.Prev;
    var n4 = Math.abs(this.GetDx(r5.Pt, e.Pt));
    for (e = r5.Next; C3.IntPoint.op_Equality(e.Pt, r5.Pt) && e != r5; ) e = e.Next;
    var i = Math.abs(this.GetDx(r5.Pt, e.Pt));
    for (e = t.Prev; C3.IntPoint.op_Equality(e.Pt, t.Pt) && e != t; ) e = e.Prev;
    var a4 = Math.abs(this.GetDx(t.Pt, e.Pt));
    for (e = t.Next; C3.IntPoint.op_Equality(e.Pt, t.Pt) && e != t; ) e = e.Next;
    var u5 = Math.abs(this.GetDx(t.Pt, e.Pt));
    return n4 >= a4 && n4 >= u5 || i >= a4 && i >= u5;
  };
  C3.Clipper.prototype.GetBottomPt = function(r5) {
    for (var t = null, e = r5.Next; e != r5; ) e.Pt.Y > r5.Pt.Y ? (r5 = e, t = null) : e.Pt.Y == r5.Pt.Y && e.Pt.X <= r5.Pt.X && (e.Pt.X < r5.Pt.X ? (t = null, r5 = e) : e.Next != r5 && e.Prev != r5 && (t = e)), e = e.Next;
    if (t !== null) for (; t != e; ) for (this.FirstIsBottomPt(e, t) || (r5 = t), t = t.Next; C3.IntPoint.op_Inequality(t.Pt, r5.Pt); ) t = t.Next;
    return r5;
  };
  C3.Clipper.prototype.GetLowermostRec = function(r5, t) {
    r5.BottomPt === null && (r5.BottomPt = this.GetBottomPt(r5.Pts)), t.BottomPt === null && (t.BottomPt = this.GetBottomPt(t.Pts));
    var e = r5.BottomPt, n4 = t.BottomPt;
    return e.Pt.Y > n4.Pt.Y ? r5 : e.Pt.Y < n4.Pt.Y ? t : e.Pt.X < n4.Pt.X ? r5 : e.Pt.X > n4.Pt.X || e.Next == e ? t : n4.Next == n4 || this.FirstIsBottomPt(e, n4) ? r5 : t;
  };
  C3.Clipper.prototype.Param1RightOfParam2 = function(r5, t) {
    do
      if (r5 = r5.FirstLeft, r5 == t) return true;
    while (r5 !== null);
    return false;
  };
  C3.Clipper.prototype.GetOutRec = function(r5) {
    for (var t = this.m_PolyOuts[r5]; t != this.m_PolyOuts[t.Idx]; ) t = this.m_PolyOuts[t.Idx];
    return t;
  };
  C3.Clipper.prototype.AppendPolygon = function(r5, t) {
    var e = this.m_PolyOuts[r5.OutIdx], n4 = this.m_PolyOuts[t.OutIdx], i;
    this.Param1RightOfParam2(e, n4) ? i = n4 : this.Param1RightOfParam2(n4, e) ? i = e : i = this.GetLowermostRec(e, n4);
    var a4 = e.Pts, u5 = a4.Prev, h = n4.Pts, d = h.Prev, m5;
    r5.Side == C3.EdgeSide.esLeft ? (t.Side == C3.EdgeSide.esLeft ? (this.ReversePolyPtLinks(h), h.Next = a4, a4.Prev = h, u5.Next = d, d.Prev = u5, e.Pts = d) : (d.Next = a4, a4.Prev = d, h.Prev = u5, u5.Next = h, e.Pts = h), m5 = C3.EdgeSide.esLeft) : (t.Side == C3.EdgeSide.esRight ? (this.ReversePolyPtLinks(h), u5.Next = d, d.Prev = u5, h.Next = a4, a4.Prev = h) : (u5.Next = h, h.Prev = u5, a4.Prev = d, d.Next = a4), m5 = C3.EdgeSide.esRight), e.BottomPt = null, i == n4 && (n4.FirstLeft != e && (e.FirstLeft = n4.FirstLeft), e.IsHole = n4.IsHole), n4.Pts = null, n4.BottomPt = null, n4.FirstLeft = e;
    var v3 = r5.OutIdx, x2 = t.OutIdx;
    r5.OutIdx = -1, t.OutIdx = -1;
    for (var S4 = this.m_ActiveEdges; S4 !== null; ) {
      if (S4.OutIdx == x2) {
        S4.OutIdx = v3, S4.Side = m5;
        break;
      }
      S4 = S4.NextInAEL;
    }
    n4.Idx = e.Idx;
  };
  C3.Clipper.prototype.ReversePolyPtLinks = function(r5) {
    if (r5 !== null) {
      var t, e;
      t = r5;
      do
        e = t.Next, t.Next = t.Prev, t.Prev = e, t = e;
      while (t != r5);
    }
  };
  C3.Clipper.SwapSides = function(r5, t) {
    var e = r5.Side;
    r5.Side = t.Side, t.Side = e;
  };
  C3.Clipper.SwapPolyIndexes = function(r5, t) {
    var e = r5.OutIdx;
    r5.OutIdx = t.OutIdx, t.OutIdx = e;
  };
  C3.Clipper.prototype.IntersectEdges = function(r5, t, e, n4) {
    var i = !n4 && r5.NextInLML === null && r5.Top.X == e.X && r5.Top.Y == e.Y, a4 = !n4 && t.NextInLML === null && t.Top.X == e.X && t.Top.Y == e.Y, u5 = r5.OutIdx >= 0, h = t.OutIdx >= 0;
    if (r5.WindDelta === 0 || t.WindDelta === 0) {
      r5.WindDelta === 0 && t.WindDelta === 0 ? (i || a4) && u5 && h && this.AddLocalMaxPoly(r5, t, e) : r5.PolyTyp == t.PolyTyp && r5.WindDelta != t.WindDelta && this.m_ClipType == C3.ClipType.ctUnion ? r5.WindDelta === 0 ? h && (this.AddOutPt(r5, e), u5 && (r5.OutIdx = -1)) : u5 && (this.AddOutPt(t, e), h && (t.OutIdx = -1)) : r5.PolyTyp != t.PolyTyp && (r5.WindDelta === 0 && Math.abs(t.WindCnt) == 1 && (this.m_ClipType != C3.ClipType.ctUnion || t.WindCnt2 === 0) ? (this.AddOutPt(r5, e), u5 && (r5.OutIdx = -1)) : t.WindDelta === 0 && Math.abs(r5.WindCnt) == 1 && (this.m_ClipType != C3.ClipType.ctUnion || r5.WindCnt2 === 0) && (this.AddOutPt(t, e), h && (t.OutIdx = -1))), i && (r5.OutIdx < 0 ? this.DeleteFromAEL(r5) : C3.Error("Error intersecting polylines")), a4 && (t.OutIdx < 0 ? this.DeleteFromAEL(t) : C3.Error("Error intersecting polylines"));
      return;
    }
    if (r5.PolyTyp == t.PolyTyp) if (this.IsEvenOddFillType(r5)) {
      var d = r5.WindCnt;
      r5.WindCnt = t.WindCnt, t.WindCnt = d;
    } else r5.WindCnt + t.WindDelta === 0 ? r5.WindCnt = -r5.WindCnt : r5.WindCnt += t.WindDelta, t.WindCnt - r5.WindDelta === 0 ? t.WindCnt = -t.WindCnt : t.WindCnt -= r5.WindDelta;
    else this.IsEvenOddFillType(t) ? r5.WindCnt2 = r5.WindCnt2 === 0 ? 1 : 0 : r5.WindCnt2 += t.WindDelta, this.IsEvenOddFillType(r5) ? t.WindCnt2 = t.WindCnt2 === 0 ? 1 : 0 : t.WindCnt2 -= r5.WindDelta;
    var m5, v3, x2, S4;
    r5.PolyTyp == C3.PolyType.ptSubject ? (m5 = this.m_SubjFillType, x2 = this.m_ClipFillType) : (m5 = this.m_ClipFillType, x2 = this.m_SubjFillType), t.PolyTyp == C3.PolyType.ptSubject ? (v3 = this.m_SubjFillType, S4 = this.m_ClipFillType) : (v3 = this.m_ClipFillType, S4 = this.m_SubjFillType);
    var I3, w3;
    switch (m5) {
      case C3.PolyFillType.pftPositive:
        I3 = r5.WindCnt;
        break;
      case C3.PolyFillType.pftNegative:
        I3 = -r5.WindCnt;
        break;
      default:
        I3 = Math.abs(r5.WindCnt);
        break;
    }
    switch (v3) {
      case C3.PolyFillType.pftPositive:
        w3 = t.WindCnt;
        break;
      case C3.PolyFillType.pftNegative:
        w3 = -t.WindCnt;
        break;
      default:
        w3 = Math.abs(t.WindCnt);
        break;
    }
    if (u5 && h) i || a4 || I3 !== 0 && I3 != 1 || w3 !== 0 && w3 != 1 || r5.PolyTyp != t.PolyTyp && this.m_ClipType != C3.ClipType.ctXor ? this.AddLocalMaxPoly(r5, t, e) : (this.AddOutPt(r5, e), this.AddOutPt(t, e), C3.Clipper.SwapSides(r5, t), C3.Clipper.SwapPolyIndexes(r5, t));
    else if (u5) (w3 === 0 || w3 == 1) && (this.AddOutPt(r5, e), C3.Clipper.SwapSides(r5, t), C3.Clipper.SwapPolyIndexes(r5, t));
    else if (h) (I3 === 0 || I3 == 1) && (this.AddOutPt(t, e), C3.Clipper.SwapSides(r5, t), C3.Clipper.SwapPolyIndexes(r5, t));
    else if ((I3 === 0 || I3 == 1) && (w3 === 0 || w3 == 1) && !i && !a4) {
      var E4, T3;
      switch (x2) {
        case C3.PolyFillType.pftPositive:
          E4 = r5.WindCnt2;
          break;
        case C3.PolyFillType.pftNegative:
          E4 = -r5.WindCnt2;
          break;
        default:
          E4 = Math.abs(r5.WindCnt2);
          break;
      }
      switch (S4) {
        case C3.PolyFillType.pftPositive:
          T3 = t.WindCnt2;
          break;
        case C3.PolyFillType.pftNegative:
          T3 = -t.WindCnt2;
          break;
        default:
          T3 = Math.abs(t.WindCnt2);
          break;
      }
      if (r5.PolyTyp != t.PolyTyp) this.AddLocalMinPoly(r5, t, e);
      else if (I3 == 1 && w3 == 1) switch (this.m_ClipType) {
        case C3.ClipType.ctIntersection:
          E4 > 0 && T3 > 0 && this.AddLocalMinPoly(r5, t, e);
          break;
        case C3.ClipType.ctUnion:
          E4 <= 0 && T3 <= 0 && this.AddLocalMinPoly(r5, t, e);
          break;
        case C3.ClipType.ctDifference:
          (r5.PolyTyp == C3.PolyType.ptClip && E4 > 0 && T3 > 0 || r5.PolyTyp == C3.PolyType.ptSubject && E4 <= 0 && T3 <= 0) && this.AddLocalMinPoly(r5, t, e);
          break;
        case C3.ClipType.ctXor:
          this.AddLocalMinPoly(r5, t, e);
          break;
      }
      else C3.Clipper.SwapSides(r5, t);
    }
    i != a4 && (i && r5.OutIdx >= 0 || a4 && t.OutIdx >= 0) && (C3.Clipper.SwapSides(r5, t), C3.Clipper.SwapPolyIndexes(r5, t)), i && this.DeleteFromAEL(r5), a4 && this.DeleteFromAEL(t);
  };
  C3.Clipper.prototype.DeleteFromAEL = function(r5) {
    var t = r5.PrevInAEL, e = r5.NextInAEL;
    t === null && e === null && r5 != this.m_ActiveEdges || (t !== null ? t.NextInAEL = e : this.m_ActiveEdges = e, e !== null && (e.PrevInAEL = t), r5.NextInAEL = null, r5.PrevInAEL = null);
  };
  C3.Clipper.prototype.DeleteFromSEL = function(r5) {
    var t = r5.PrevInSEL, e = r5.NextInSEL;
    t === null && e === null && r5 != this.m_SortedEdges || (t !== null ? t.NextInSEL = e : this.m_SortedEdges = e, e !== null && (e.PrevInSEL = t), r5.NextInSEL = null, r5.PrevInSEL = null);
  };
  C3.Clipper.prototype.UpdateEdgeIntoAEL = function(r5) {
    r5.NextInLML === null && C3.Error("UpdateEdgeIntoAEL: invalid call");
    var t = r5.PrevInAEL, e = r5.NextInAEL;
    return r5.NextInLML.OutIdx = r5.OutIdx, t !== null ? t.NextInAEL = r5.NextInLML : this.m_ActiveEdges = r5.NextInLML, e !== null && (e.PrevInAEL = r5.NextInLML), r5.NextInLML.Side = r5.Side, r5.NextInLML.WindDelta = r5.WindDelta, r5.NextInLML.WindCnt = r5.WindCnt, r5.NextInLML.WindCnt2 = r5.WindCnt2, r5 = r5.NextInLML, r5.Curr.X = r5.Bot.X, r5.Curr.Y = r5.Bot.Y, r5.PrevInAEL = t, r5.NextInAEL = e, C3.ClipperBase.IsHorizontal(r5) || this.InsertScanbeam(r5.Top.Y), r5;
  };
  C3.Clipper.prototype.ProcessHorizontals = function(r5) {
    for (var t = this.m_SortedEdges; t !== null; ) this.DeleteFromSEL(t), this.ProcessHorizontal(t, r5), t = this.m_SortedEdges;
  };
  C3.Clipper.prototype.GetHorzDirection = function(r5, t) {
    r5.Bot.X < r5.Top.X ? (t.Left = r5.Bot.X, t.Right = r5.Top.X, t.Dir = C3.Direction.dLeftToRight) : (t.Left = r5.Top.X, t.Right = r5.Bot.X, t.Dir = C3.Direction.dRightToLeft);
  };
  C3.Clipper.prototype.PrepareHorzJoins = function(r5, t) {
    var e = this.m_PolyOuts[r5.OutIdx].Pts;
    r5.Side != C3.EdgeSide.esLeft && (e = e.Prev), t && (C3.IntPoint.op_Equality(e.Pt, r5.Top) ? this.AddGhostJoin(e, r5.Bot) : this.AddGhostJoin(e, r5.Top));
  };
  C3.Clipper.prototype.ProcessHorizontal = function(r5, t) {
    var e = { Dir: null, Left: null, Right: null };
    this.GetHorzDirection(r5, e);
    for (var n4 = e.Dir, i = e.Left, a4 = e.Right, u5 = r5, h = null; u5.NextInLML !== null && C3.ClipperBase.IsHorizontal(u5.NextInLML); ) u5 = u5.NextInLML;
    for (u5.NextInLML === null && (h = this.GetMaximaPair(u5)); ; ) {
      for (var d = r5 == u5, m5 = this.GetNextInAEL(r5, n4); m5 !== null && !(m5.Curr.X == r5.Top.X && r5.NextInLML !== null && m5.Dx < r5.NextInLML.Dx); ) {
        var v3 = this.GetNextInAEL(m5, n4);
        if (n4 == C3.Direction.dLeftToRight && m5.Curr.X <= a4 || n4 == C3.Direction.dRightToLeft && m5.Curr.X >= i) {
          if (r5.OutIdx >= 0 && r5.WindDelta != 0 && this.PrepareHorzJoins(r5, t), m5 == h && d) {
            n4 == C3.Direction.dLeftToRight ? this.IntersectEdges(r5, m5, m5.Top, false) : this.IntersectEdges(m5, r5, m5.Top, false), h.OutIdx >= 0 && C3.Error("ProcessHorizontal error");
            return;
          } else if (n4 == C3.Direction.dLeftToRight) {
            var x2 = new C3.IntPoint(m5.Curr.X, r5.Curr.Y);
            this.IntersectEdges(r5, m5, x2, true);
          } else {
            var x2 = new C3.IntPoint(m5.Curr.X, r5.Curr.Y);
            this.IntersectEdges(m5, r5, x2, true);
          }
          this.SwapPositionsInAEL(r5, m5);
        } else if (n4 == C3.Direction.dLeftToRight && m5.Curr.X >= a4 || n4 == C3.Direction.dRightToLeft && m5.Curr.X <= i) break;
        m5 = v3;
      }
      if (r5.OutIdx >= 0 && r5.WindDelta !== 0 && this.PrepareHorzJoins(r5, t), r5.NextInLML !== null && C3.ClipperBase.IsHorizontal(r5.NextInLML)) {
        r5 = this.UpdateEdgeIntoAEL(r5), r5.OutIdx >= 0 && this.AddOutPt(r5, r5.Bot);
        var e = { Dir: n4, Left: i, Right: a4 };
        this.GetHorzDirection(r5, e), n4 = e.Dir, i = e.Left, a4 = e.Right;
      } else break;
    }
    if (r5.NextInLML !== null) if (r5.OutIdx >= 0) {
      var S4 = this.AddOutPt(r5, r5.Top);
      if (r5 = this.UpdateEdgeIntoAEL(r5), r5.WindDelta === 0) return;
      var I3 = r5.PrevInAEL, v3 = r5.NextInAEL;
      if (I3 !== null && I3.Curr.X == r5.Bot.X && I3.Curr.Y == r5.Bot.Y && I3.WindDelta !== 0 && I3.OutIdx >= 0 && I3.Curr.Y > I3.Top.Y && C3.ClipperBase.SlopesEqual(r5, I3, this.m_UseFullRange)) {
        var w3 = this.AddOutPt(I3, r5.Bot);
        this.AddJoin(S4, w3, r5.Top);
      } else if (v3 !== null && v3.Curr.X == r5.Bot.X && v3.Curr.Y == r5.Bot.Y && v3.WindDelta !== 0 && v3.OutIdx >= 0 && v3.Curr.Y > v3.Top.Y && C3.ClipperBase.SlopesEqual(r5, v3, this.m_UseFullRange)) {
        var w3 = this.AddOutPt(v3, r5.Bot);
        this.AddJoin(S4, w3, r5.Top);
      }
    } else r5 = this.UpdateEdgeIntoAEL(r5);
    else h !== null ? h.OutIdx >= 0 ? (n4 == C3.Direction.dLeftToRight ? this.IntersectEdges(r5, h, r5.Top, false) : this.IntersectEdges(h, r5, r5.Top, false), h.OutIdx >= 0 && C3.Error("ProcessHorizontal error")) : (this.DeleteFromAEL(r5), this.DeleteFromAEL(h)) : (r5.OutIdx >= 0 && this.AddOutPt(r5, r5.Top), this.DeleteFromAEL(r5));
  };
  C3.Clipper.prototype.GetNextInAEL = function(r5, t) {
    return t == C3.Direction.dLeftToRight ? r5.NextInAEL : r5.PrevInAEL;
  };
  C3.Clipper.prototype.IsMinima = function(r5) {
    return r5 !== null && r5.Prev.NextInLML != r5 && r5.Next.NextInLML != r5;
  };
  C3.Clipper.prototype.IsMaxima = function(r5, t) {
    return r5 !== null && r5.Top.Y == t && r5.NextInLML === null;
  };
  C3.Clipper.prototype.IsIntermediate = function(r5, t) {
    return r5.Top.Y == t && r5.NextInLML !== null;
  };
  C3.Clipper.prototype.GetMaximaPair = function(r5) {
    var t = null;
    return C3.IntPoint.op_Equality(r5.Next.Top, r5.Top) && r5.Next.NextInLML === null ? t = r5.Next : C3.IntPoint.op_Equality(r5.Prev.Top, r5.Top) && r5.Prev.NextInLML === null && (t = r5.Prev), t !== null && (t.OutIdx == -2 || t.NextInAEL == t.PrevInAEL && !C3.ClipperBase.IsHorizontal(t)) ? null : t;
  };
  C3.Clipper.prototype.ProcessIntersections = function(r5, t) {
    if (this.m_ActiveEdges == null) return true;
    try {
      if (this.BuildIntersectList(r5, t), this.m_IntersectList.length == 0) return true;
      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder()) this.ProcessIntersectList();
      else return false;
    } catch (e) {
      this.m_SortedEdges = null, this.m_IntersectList.length = 0, C3.Error("ProcessIntersections error");
    }
    return this.m_SortedEdges = null, true;
  };
  C3.Clipper.prototype.BuildIntersectList = function(r5, t) {
    if (this.m_ActiveEdges !== null) {
      var e = this.m_ActiveEdges;
      for (this.m_SortedEdges = e; e !== null; ) e.PrevInSEL = e.PrevInAEL, e.NextInSEL = e.NextInAEL, e.Curr.X = C3.Clipper.TopX(e, t), e = e.NextInAEL;
      for (var n4 = true; n4 && this.m_SortedEdges !== null; ) {
        for (n4 = false, e = this.m_SortedEdges; e.NextInSEL !== null; ) {
          var i = e.NextInSEL, a4 = new C3.IntPoint();
          if (e.Curr.X > i.Curr.X) {
            !this.IntersectPoint(e, i, a4) && e.Curr.X > i.Curr.X + 1 && C3.Error("Intersection error"), a4.Y > r5 && (a4.Y = r5, Math.abs(e.Dx) > Math.abs(i.Dx) ? a4.X = C3.Clipper.TopX(i, r5) : a4.X = C3.Clipper.TopX(e, r5));
            var u5 = new C3.IntersectNode();
            u5.Edge1 = e, u5.Edge2 = i, u5.Pt.X = a4.X, u5.Pt.Y = a4.Y, this.m_IntersectList.push(u5), this.SwapPositionsInSEL(e, i), n4 = true;
          } else e = i;
        }
        if (e.PrevInSEL !== null) e.PrevInSEL.NextInSEL = null;
        else break;
      }
      this.m_SortedEdges = null;
    }
  };
  C3.Clipper.prototype.EdgesAdjacent = function(r5) {
    return r5.Edge1.NextInSEL == r5.Edge2 || r5.Edge1.PrevInSEL == r5.Edge2;
  };
  C3.Clipper.IntersectNodeSort = function(r5, t) {
    return t.Pt.Y - r5.Pt.Y;
  };
  C3.Clipper.prototype.FixupIntersectionOrder = function() {
    this.m_IntersectList.sort(this.m_IntersectNodeComparer), this.CopyAELToSEL();
    for (var r5 = this.m_IntersectList.length, t = 0; t < r5; t++) {
      if (!this.EdgesAdjacent(this.m_IntersectList[t])) {
        for (var e = t + 1; e < r5 && !this.EdgesAdjacent(this.m_IntersectList[e]); ) e++;
        if (e == r5) return false;
        var n4 = this.m_IntersectList[t];
        this.m_IntersectList[t] = this.m_IntersectList[e], this.m_IntersectList[e] = n4;
      }
      this.SwapPositionsInSEL(this.m_IntersectList[t].Edge1, this.m_IntersectList[t].Edge2);
    }
    return true;
  };
  C3.Clipper.prototype.ProcessIntersectList = function() {
    for (var r5 = 0, t = this.m_IntersectList.length; r5 < t; r5++) {
      var e = this.m_IntersectList[r5];
      this.IntersectEdges(e.Edge1, e.Edge2, e.Pt, true), this.SwapPositionsInAEL(e.Edge1, e.Edge2);
    }
    this.m_IntersectList.length = 0;
  };
  var Sq = H$3(function(r5) {
    return r5 < 0 ? Math.ceil(r5 - 0.5) : Math.round(r5);
  }, "R1"), Iq = H$3(function(r5) {
    return r5 < 0 ? Math.ceil(r5 - 0.5) : Math.floor(r5 + 0.5);
  }, "R2"), Mq = H$3(function(r5) {
    return r5 < 0 ? -Math.round(Math.abs(r5)) : Math.round(r5);
  }, "R3"), Tq = H$3(function(r5) {
    return r5 < 0 ? (r5 -= 0.5, r5 < -2147483648 ? Math.ceil(r5) : r5 | 0) : (r5 += 0.5, r5 > 2147483647 ? Math.floor(r5) : r5 | 0);
  }, "R4");
  dr2.msie ? C3.Clipper.Round = Sq : dr2.chromium ? C3.Clipper.Round = Mq : dr2.safari ? C3.Clipper.Round = Tq : C3.Clipper.Round = Iq;
  C3.Clipper.TopX = function(r5, t) {
    return t == r5.Top.Y ? r5.Top.X : r5.Bot.X + C3.Clipper.Round(r5.Dx * (t - r5.Bot.Y));
  };
  C3.Clipper.prototype.IntersectPoint = function(r5, t, e) {
    e.X = 0, e.Y = 0;
    var n4, i;
    if (C3.ClipperBase.SlopesEqual(r5, t, this.m_UseFullRange) || r5.Dx == t.Dx) return t.Bot.Y > r5.Bot.Y ? (e.X = t.Bot.X, e.Y = t.Bot.Y) : (e.X = r5.Bot.X, e.Y = r5.Bot.Y), false;
    if (r5.Delta.X === 0) e.X = r5.Bot.X, C3.ClipperBase.IsHorizontal(t) ? e.Y = t.Bot.Y : (i = t.Bot.Y - t.Bot.X / t.Dx, e.Y = C3.Clipper.Round(e.X / t.Dx + i));
    else if (t.Delta.X === 0) e.X = t.Bot.X, C3.ClipperBase.IsHorizontal(r5) ? e.Y = r5.Bot.Y : (n4 = r5.Bot.Y - r5.Bot.X / r5.Dx, e.Y = C3.Clipper.Round(e.X / r5.Dx + n4));
    else {
      n4 = r5.Bot.X - r5.Bot.Y * r5.Dx, i = t.Bot.X - t.Bot.Y * t.Dx;
      var a4 = (i - n4) / (r5.Dx - t.Dx);
      e.Y = C3.Clipper.Round(a4), Math.abs(r5.Dx) < Math.abs(t.Dx) ? e.X = C3.Clipper.Round(r5.Dx * a4 + n4) : e.X = C3.Clipper.Round(t.Dx * a4 + i);
    }
    if (e.Y < r5.Top.Y || e.Y < t.Top.Y) {
      if (r5.Top.Y > t.Top.Y) return e.Y = r5.Top.Y, e.X = C3.Clipper.TopX(t, r5.Top.Y), e.X < r5.Top.X;
      e.Y = t.Top.Y, Math.abs(r5.Dx) < Math.abs(t.Dx) ? e.X = C3.Clipper.TopX(r5, e.Y) : e.X = C3.Clipper.TopX(t, e.Y);
    }
    return true;
  };
  C3.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function(r5) {
    for (var t = this.m_ActiveEdges; t !== null; ) {
      var e = this.IsMaxima(t, r5);
      if (e) {
        var n4 = this.GetMaximaPair(t);
        e = n4 === null || !C3.ClipperBase.IsHorizontal(n4);
      }
      if (e) {
        var i = t.PrevInAEL;
        this.DoMaxima(t), i === null ? t = this.m_ActiveEdges : t = i.NextInAEL;
      } else {
        if (this.IsIntermediate(t, r5) && C3.ClipperBase.IsHorizontal(t.NextInLML) ? (t = this.UpdateEdgeIntoAEL(t), t.OutIdx >= 0 && this.AddOutPt(t, t.Bot), this.AddEdgeToSEL(t)) : (t.Curr.X = C3.Clipper.TopX(t, r5), t.Curr.Y = r5), this.StrictlySimple) {
          var i = t.PrevInAEL;
          if (t.OutIdx >= 0 && t.WindDelta !== 0 && i !== null && i.OutIdx >= 0 && i.Curr.X == t.Curr.X && i.WindDelta !== 0) {
            var a4 = this.AddOutPt(i, t.Curr), u5 = this.AddOutPt(t, t.Curr);
            this.AddJoin(a4, u5, t.Curr);
          }
        }
        t = t.NextInAEL;
      }
    }
    for (this.ProcessHorizontals(true), t = this.m_ActiveEdges; t !== null; ) {
      if (this.IsIntermediate(t, r5)) {
        var a4 = null;
        t.OutIdx >= 0 && (a4 = this.AddOutPt(t, t.Top)), t = this.UpdateEdgeIntoAEL(t);
        var i = t.PrevInAEL, h = t.NextInAEL;
        if (i !== null && i.Curr.X == t.Bot.X && i.Curr.Y == t.Bot.Y && a4 !== null && i.OutIdx >= 0 && i.Curr.Y > i.Top.Y && C3.ClipperBase.SlopesEqual(t, i, this.m_UseFullRange) && t.WindDelta !== 0 && i.WindDelta !== 0) {
          var u5 = this.AddOutPt(i, t.Bot);
          this.AddJoin(a4, u5, t.Top);
        } else if (h !== null && h.Curr.X == t.Bot.X && h.Curr.Y == t.Bot.Y && a4 !== null && h.OutIdx >= 0 && h.Curr.Y > h.Top.Y && C3.ClipperBase.SlopesEqual(t, h, this.m_UseFullRange) && t.WindDelta !== 0 && h.WindDelta !== 0) {
          var u5 = this.AddOutPt(h, t.Bot);
          this.AddJoin(a4, u5, t.Top);
        }
      }
      t = t.NextInAEL;
    }
  };
  C3.Clipper.prototype.DoMaxima = function(r5) {
    var t = this.GetMaximaPair(r5);
    if (t === null) {
      r5.OutIdx >= 0 && this.AddOutPt(r5, r5.Top), this.DeleteFromAEL(r5);
      return;
    }
    for (var e = r5.NextInAEL, n4 = true; e !== null && e != t; ) this.IntersectEdges(r5, e, r5.Top, true), this.SwapPositionsInAEL(r5, e), e = r5.NextInAEL;
    r5.OutIdx == -1 && t.OutIdx == -1 ? (this.DeleteFromAEL(r5), this.DeleteFromAEL(t)) : r5.OutIdx >= 0 && t.OutIdx >= 0 ? this.IntersectEdges(r5, t, r5.Top, false) : n4 && r5.WindDelta === 0 ? (r5.OutIdx >= 0 && (this.AddOutPt(r5, r5.Top), r5.OutIdx = -1), this.DeleteFromAEL(r5), t.OutIdx >= 0 && (this.AddOutPt(t, r5.Top), t.OutIdx = -1), this.DeleteFromAEL(t)) : C3.Error("DoMaxima error");
  };
  C3.Clipper.ReversePaths = function(r5) {
    for (var t = 0, e = r5.length; t < e; t++) r5[t].reverse();
  };
  C3.Clipper.Orientation = function(r5) {
    return C3.Clipper.Area(r5) >= 0;
  };
  C3.Clipper.prototype.PointCount = function(r5) {
    if (r5 === null) return 0;
    var t = 0, e = r5;
    do
      t++, e = e.Next;
    while (e != r5);
    return t;
  };
  C3.Clipper.prototype.BuildResult = function(r5) {
    C3.Clear(r5);
    for (var t = 0, e = this.m_PolyOuts.length; t < e; t++) {
      var n4 = this.m_PolyOuts[t];
      if (n4.Pts !== null) {
        var i = n4.Pts.Prev, a4 = this.PointCount(i);
        if (!(a4 < 2)) {
          for (var u5 = new Array(a4), h = 0; h < a4; h++) u5[h] = i.Pt, i = i.Prev;
          r5.push(u5);
        }
      }
    }
  };
  C3.Clipper.prototype.BuildResult2 = function(r5) {
    r5.Clear();
    for (var t = 0, e = this.m_PolyOuts.length; t < e; t++) {
      var n4 = this.m_PolyOuts[t], i = this.PointCount(n4.Pts);
      if (!(n4.IsOpen && i < 2 || !n4.IsOpen && i < 3)) {
        this.FixHoleLinkage(n4);
        var a4 = new C3.PolyNode();
        r5.m_AllPolys.push(a4), n4.PolyNode = a4, a4.m_polygon.length = i;
        for (var u5 = n4.Pts.Prev, h = 0; h < i; h++) a4.m_polygon[h] = u5.Pt, u5 = u5.Prev;
      }
    }
    for (var t = 0, e = this.m_PolyOuts.length; t < e; t++) {
      var n4 = this.m_PolyOuts[t];
      n4.PolyNode !== null && (n4.IsOpen ? (n4.PolyNode.IsOpen = true, r5.AddChild(n4.PolyNode)) : n4.FirstLeft !== null && n4.FirstLeft.PolyNode != null ? n4.FirstLeft.PolyNode.AddChild(n4.PolyNode) : r5.AddChild(n4.PolyNode));
    }
  };
  C3.Clipper.prototype.FixupOutPolygon = function(r5) {
    var t = null;
    r5.BottomPt = null;
    for (var e = r5.Pts; ; ) {
      if (e.Prev == e || e.Prev == e.Next) {
        this.DisposeOutPts(e), r5.Pts = null;
        return;
      }
      if (C3.IntPoint.op_Equality(e.Pt, e.Next.Pt) || C3.IntPoint.op_Equality(e.Pt, e.Prev.Pt) || C3.ClipperBase.SlopesEqual(e.Prev.Pt, e.Pt, e.Next.Pt, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(e.Prev.Pt, e.Pt, e.Next.Pt))) {
        t = null;
        e.Prev.Next = e.Next, e.Next.Prev = e.Prev, e = e.Prev;
      } else {
        if (e == t) break;
        t === null && (t = e), e = e.Next;
      }
    }
    r5.Pts = e;
  };
  C3.Clipper.prototype.DupOutPt = function(r5, t) {
    var e = new C3.OutPt();
    return e.Pt.X = r5.Pt.X, e.Pt.Y = r5.Pt.Y, e.Idx = r5.Idx, t ? (e.Next = r5.Next, e.Prev = r5, r5.Next.Prev = e, r5.Next = e) : (e.Prev = r5.Prev, e.Next = r5, r5.Prev.Next = e, r5.Prev = e), e;
  };
  C3.Clipper.prototype.GetOverlap = function(r5, t, e, n4, i) {
    return r5 < t ? e < n4 ? (i.Left = Math.max(r5, e), i.Right = Math.min(t, n4)) : (i.Left = Math.max(r5, n4), i.Right = Math.min(t, e)) : e < n4 ? (i.Left = Math.max(t, e), i.Right = Math.min(r5, n4)) : (i.Left = Math.max(t, n4), i.Right = Math.min(r5, e)), i.Left < i.Right;
  };
  C3.Clipper.prototype.JoinHorz = function(r5, t, e, n4, i, a4) {
    var u5 = r5.Pt.X > t.Pt.X ? C3.Direction.dRightToLeft : C3.Direction.dLeftToRight, h = e.Pt.X > n4.Pt.X ? C3.Direction.dRightToLeft : C3.Direction.dLeftToRight;
    if (u5 == h) return false;
    if (u5 == C3.Direction.dLeftToRight) {
      for (; r5.Next.Pt.X <= i.X && r5.Next.Pt.X >= r5.Pt.X && r5.Next.Pt.Y == i.Y; ) r5 = r5.Next;
      a4 && r5.Pt.X != i.X && (r5 = r5.Next), t = this.DupOutPt(r5, !a4), C3.IntPoint.op_Inequality(t.Pt, i) && (r5 = t, r5.Pt.X = i.X, r5.Pt.Y = i.Y, t = this.DupOutPt(r5, !a4));
    } else {
      for (; r5.Next.Pt.X >= i.X && r5.Next.Pt.X <= r5.Pt.X && r5.Next.Pt.Y == i.Y; ) r5 = r5.Next;
      !a4 && r5.Pt.X != i.X && (r5 = r5.Next), t = this.DupOutPt(r5, a4), C3.IntPoint.op_Inequality(t.Pt, i) && (r5 = t, r5.Pt.X = i.X, r5.Pt.Y = i.Y, t = this.DupOutPt(r5, a4));
    }
    if (h == C3.Direction.dLeftToRight) {
      for (; e.Next.Pt.X <= i.X && e.Next.Pt.X >= e.Pt.X && e.Next.Pt.Y == i.Y; ) e = e.Next;
      a4 && e.Pt.X != i.X && (e = e.Next), n4 = this.DupOutPt(e, !a4), C3.IntPoint.op_Inequality(n4.Pt, i) && (e = n4, e.Pt.X = i.X, e.Pt.Y = i.Y, n4 = this.DupOutPt(e, !a4));
    } else {
      for (; e.Next.Pt.X >= i.X && e.Next.Pt.X <= e.Pt.X && e.Next.Pt.Y == i.Y; ) e = e.Next;
      !a4 && e.Pt.X != i.X && (e = e.Next), n4 = this.DupOutPt(e, a4), C3.IntPoint.op_Inequality(n4.Pt, i) && (e = n4, e.Pt.X = i.X, e.Pt.Y = i.Y, n4 = this.DupOutPt(e, a4));
    }
    return u5 == C3.Direction.dLeftToRight == a4 ? (r5.Prev = e, e.Next = r5, t.Next = n4, n4.Prev = t) : (r5.Next = e, e.Prev = r5, t.Prev = n4, n4.Next = t), true;
  };
  C3.Clipper.prototype.JoinPoints = function(r5, t, e) {
    var n4 = r5.OutPt1, i = new C3.OutPt(), a4 = r5.OutPt2, u5 = new C3.OutPt(), h = r5.OutPt1.Pt.Y == r5.OffPt.Y;
    if (h && C3.IntPoint.op_Equality(r5.OffPt, r5.OutPt1.Pt) && C3.IntPoint.op_Equality(r5.OffPt, r5.OutPt2.Pt)) {
      for (i = r5.OutPt1.Next; i != n4 && C3.IntPoint.op_Equality(i.Pt, r5.OffPt); ) i = i.Next;
      var d = i.Pt.Y > r5.OffPt.Y;
      for (u5 = r5.OutPt2.Next; u5 != a4 && C3.IntPoint.op_Equality(u5.Pt, r5.OffPt); ) u5 = u5.Next;
      var m5 = u5.Pt.Y > r5.OffPt.Y;
      return d == m5 ? false : d ? (i = this.DupOutPt(n4, false), u5 = this.DupOutPt(a4, true), n4.Prev = a4, a4.Next = n4, i.Next = u5, u5.Prev = i, r5.OutPt1 = n4, r5.OutPt2 = i, true) : (i = this.DupOutPt(n4, true), u5 = this.DupOutPt(a4, false), n4.Next = a4, a4.Prev = n4, i.Prev = u5, u5.Next = i, r5.OutPt1 = n4, r5.OutPt2 = i, true);
    } else if (h) {
      for (i = n4; n4.Prev.Pt.Y == n4.Pt.Y && n4.Prev != i && n4.Prev != a4; ) n4 = n4.Prev;
      for (; i.Next.Pt.Y == i.Pt.Y && i.Next != n4 && i.Next != a4; ) i = i.Next;
      if (i.Next == n4 || i.Next == a4) return false;
      for (u5 = a4; a4.Prev.Pt.Y == a4.Pt.Y && a4.Prev != u5 && a4.Prev != i; ) a4 = a4.Prev;
      for (; u5.Next.Pt.Y == u5.Pt.Y && u5.Next != a4 && u5.Next != n4; ) u5 = u5.Next;
      if (u5.Next == a4 || u5.Next == n4) return false;
      var v3 = { Left: null, Right: null };
      if (!this.GetOverlap(n4.Pt.X, i.Pt.X, a4.Pt.X, u5.Pt.X, v3)) return false;
      var x2 = v3.Left, S4 = v3.Right, I3 = new C3.IntPoint(), w3;
      return n4.Pt.X >= x2 && n4.Pt.X <= S4 ? (I3.X = n4.Pt.X, I3.Y = n4.Pt.Y, w3 = n4.Pt.X > i.Pt.X) : a4.Pt.X >= x2 && a4.Pt.X <= S4 ? (I3.X = a4.Pt.X, I3.Y = a4.Pt.Y, w3 = a4.Pt.X > u5.Pt.X) : i.Pt.X >= x2 && i.Pt.X <= S4 ? (I3.X = i.Pt.X, I3.Y = i.Pt.Y, w3 = i.Pt.X > n4.Pt.X) : (I3.X = u5.Pt.X, I3.Y = u5.Pt.Y, w3 = u5.Pt.X > a4.Pt.X), r5.OutPt1 = n4, r5.OutPt2 = a4, this.JoinHorz(n4, i, a4, u5, I3, w3);
    } else {
      for (i = n4.Next; C3.IntPoint.op_Equality(i.Pt, n4.Pt) && i != n4; ) i = i.Next;
      var E4 = i.Pt.Y > n4.Pt.Y || !C3.ClipperBase.SlopesEqual(n4.Pt, i.Pt, r5.OffPt, this.m_UseFullRange);
      if (E4) {
        for (i = n4.Prev; C3.IntPoint.op_Equality(i.Pt, n4.Pt) && i != n4; ) i = i.Prev;
        if (i.Pt.Y > n4.Pt.Y || !C3.ClipperBase.SlopesEqual(n4.Pt, i.Pt, r5.OffPt, this.m_UseFullRange)) return false;
      }
      for (u5 = a4.Next; C3.IntPoint.op_Equality(u5.Pt, a4.Pt) && u5 != a4; ) u5 = u5.Next;
      var T3 = u5.Pt.Y > a4.Pt.Y || !C3.ClipperBase.SlopesEqual(a4.Pt, u5.Pt, r5.OffPt, this.m_UseFullRange);
      if (T3) {
        for (u5 = a4.Prev; C3.IntPoint.op_Equality(u5.Pt, a4.Pt) && u5 != a4; ) u5 = u5.Prev;
        if (u5.Pt.Y > a4.Pt.Y || !C3.ClipperBase.SlopesEqual(a4.Pt, u5.Pt, r5.OffPt, this.m_UseFullRange)) return false;
      }
      return i == n4 || u5 == a4 || i == u5 || t == e && E4 == T3 ? false : E4 ? (i = this.DupOutPt(n4, false), u5 = this.DupOutPt(a4, true), n4.Prev = a4, a4.Next = n4, i.Next = u5, u5.Prev = i, r5.OutPt1 = n4, r5.OutPt2 = i, true) : (i = this.DupOutPt(n4, true), u5 = this.DupOutPt(a4, false), n4.Next = a4, a4.Prev = n4, i.Prev = u5, u5.Next = i, r5.OutPt1 = n4, r5.OutPt2 = i, true);
    }
  };
  C3.Clipper.GetBounds = function(r5) {
    for (var t = 0, e = r5.length; t < e && r5[t].length == 0; ) t++;
    if (t == e) return new C3.IntRect(0, 0, 0, 0);
    var n4 = new C3.IntRect();
    for (n4.left = r5[t][0].X, n4.right = n4.left, n4.top = r5[t][0].Y, n4.bottom = n4.top; t < e; t++) for (var i = 0, a4 = r5[t].length; i < a4; i++) r5[t][i].X < n4.left ? n4.left = r5[t][i].X : r5[t][i].X > n4.right && (n4.right = r5[t][i].X), r5[t][i].Y < n4.top ? n4.top = r5[t][i].Y : r5[t][i].Y > n4.bottom && (n4.bottom = r5[t][i].Y);
    return n4;
  };
  C3.Clipper.prototype.GetBounds2 = function(r5) {
    var t = r5, e = new C3.IntRect();
    for (e.left = r5.Pt.X, e.right = r5.Pt.X, e.top = r5.Pt.Y, e.bottom = r5.Pt.Y, r5 = r5.Next; r5 != t; ) r5.Pt.X < e.left && (e.left = r5.Pt.X), r5.Pt.X > e.right && (e.right = r5.Pt.X), r5.Pt.Y < e.top && (e.top = r5.Pt.Y), r5.Pt.Y > e.bottom && (e.bottom = r5.Pt.Y), r5 = r5.Next;
    return e;
  };
  C3.Clipper.PointInPolygon = function(r5, t) {
    var e = 0, n4 = t.length;
    if (n4 < 3) return 0;
    for (var i = t[0], a4 = 1; a4 <= n4; ++a4) {
      var u5 = a4 == n4 ? t[0] : t[a4];
      if (u5.Y == r5.Y && (u5.X == r5.X || i.Y == r5.Y && u5.X > r5.X == i.X < r5.X)) return -1;
      if (i.Y < r5.Y != u5.Y < r5.Y) {
        if (i.X >= r5.X) if (u5.X > r5.X) e = 1 - e;
        else {
          var h = (i.X - r5.X) * (u5.Y - r5.Y) - (u5.X - r5.X) * (i.Y - r5.Y);
          if (h == 0) return -1;
          h > 0 == u5.Y > i.Y && (e = 1 - e);
        }
        else if (u5.X > r5.X) {
          var h = (i.X - r5.X) * (u5.Y - r5.Y) - (u5.X - r5.X) * (i.Y - r5.Y);
          if (h == 0) return -1;
          h > 0 == u5.Y > i.Y && (e = 1 - e);
        }
      }
      i = u5;
    }
    return e;
  };
  C3.Clipper.prototype.PointInPolygon = function(r5, t) {
    for (var e = 0, n4 = t; ; ) {
      var i = t.Pt.X, a4 = t.Pt.Y, u5 = t.Next.Pt.X, h = t.Next.Pt.Y;
      if (h == r5.Y && (u5 == r5.X || a4 == r5.Y && u5 > r5.X == i < r5.X)) return -1;
      if (a4 < r5.Y != h < r5.Y) {
        if (i >= r5.X) if (u5 > r5.X) e = 1 - e;
        else {
          var d = (i - r5.X) * (h - r5.Y) - (u5 - r5.X) * (a4 - r5.Y);
          if (d == 0) return -1;
          d > 0 == h > a4 && (e = 1 - e);
        }
        else if (u5 > r5.X) {
          var d = (i - r5.X) * (h - r5.Y) - (u5 - r5.X) * (a4 - r5.Y);
          if (d == 0) return -1;
          d > 0 == h > a4 && (e = 1 - e);
        }
      }
      if (t = t.Next, n4 == t) break;
    }
    return e;
  };
  C3.Clipper.prototype.Poly2ContainsPoly1 = function(r5, t) {
    var e = r5;
    do {
      var n4 = this.PointInPolygon(e.Pt, t);
      if (n4 >= 0) return n4 != 0;
      e = e.Next;
    } while (e != r5);
    return true;
  };
  C3.Clipper.prototype.FixupFirstLefts1 = function(r5, t) {
    for (var e = 0, n4 = this.m_PolyOuts.length; e < n4; e++) {
      var i = this.m_PolyOuts[e];
      i.Pts !== null && i.FirstLeft == r5 && this.Poly2ContainsPoly1(i.Pts, t.Pts) && (i.FirstLeft = t);
    }
  };
  C3.Clipper.prototype.FixupFirstLefts2 = function(r5, t) {
    for (var e = 0, n4 = this.m_PolyOuts, i = n4.length, a4 = n4[e]; e < i; e++, a4 = n4[e]) a4.FirstLeft == r5 && (a4.FirstLeft = t);
  };
  C3.Clipper.ParseFirstLeft = function(r5) {
    for (; r5 != null && r5.Pts == null; ) r5 = r5.FirstLeft;
    return r5;
  };
  C3.Clipper.prototype.JoinCommonEdges = function() {
    for (var r5 = 0, t = this.m_Joins.length; r5 < t; r5++) {
      var e = this.m_Joins[r5], n4 = this.GetOutRec(e.OutPt1.Idx), i = this.GetOutRec(e.OutPt2.Idx);
      if (!(n4.Pts == null || i.Pts == null)) {
        var a4;
        if (n4 == i ? a4 = n4 : this.Param1RightOfParam2(n4, i) ? a4 = i : this.Param1RightOfParam2(i, n4) ? a4 = n4 : a4 = this.GetLowermostRec(n4, i), !!this.JoinPoints(e, n4, i)) if (n4 == i) {
          if (n4.Pts = e.OutPt1, n4.BottomPt = null, i = this.CreateOutRec(), i.Pts = e.OutPt2, this.UpdateOutPtIdxs(i), this.m_UsingPolyTree) for (var u5 = 0, h = this.m_PolyOuts.length; u5 < h - 1; u5++) {
            var d = this.m_PolyOuts[u5];
            d.Pts == null || C3.Clipper.ParseFirstLeft(d.FirstLeft) != n4 || d.IsHole == n4.IsHole || this.Poly2ContainsPoly1(d.Pts, e.OutPt2) && (d.FirstLeft = i);
          }
          this.Poly2ContainsPoly1(i.Pts, n4.Pts) ? (i.IsHole = !n4.IsHole, i.FirstLeft = n4, this.m_UsingPolyTree && this.FixupFirstLefts2(i, n4), (i.IsHole ^ this.ReverseSolution) == this.Area(i) > 0 && this.ReversePolyPtLinks(i.Pts)) : this.Poly2ContainsPoly1(n4.Pts, i.Pts) ? (i.IsHole = n4.IsHole, n4.IsHole = !i.IsHole, i.FirstLeft = n4.FirstLeft, n4.FirstLeft = i, this.m_UsingPolyTree && this.FixupFirstLefts2(n4, i), (n4.IsHole ^ this.ReverseSolution) == this.Area(n4) > 0 && this.ReversePolyPtLinks(n4.Pts)) : (i.IsHole = n4.IsHole, i.FirstLeft = n4.FirstLeft, this.m_UsingPolyTree && this.FixupFirstLefts1(n4, i));
        } else i.Pts = null, i.BottomPt = null, i.Idx = n4.Idx, n4.IsHole = a4.IsHole, a4 == i && (n4.FirstLeft = i.FirstLeft), i.FirstLeft = n4, this.m_UsingPolyTree && this.FixupFirstLefts2(i, n4);
      }
    }
  };
  C3.Clipper.prototype.UpdateOutPtIdxs = function(r5) {
    var t = r5.Pts;
    do
      t.Idx = r5.Idx, t = t.Prev;
    while (t != r5.Pts);
  };
  C3.Clipper.prototype.DoSimplePolygons = function() {
    for (var r5 = 0; r5 < this.m_PolyOuts.length; ) {
      var t = this.m_PolyOuts[r5++], e = t.Pts;
      if (e !== null) do {
        for (var n4 = e.Next; n4 != t.Pts; ) {
          if (C3.IntPoint.op_Equality(e.Pt, n4.Pt) && n4.Next != e && n4.Prev != e) {
            var i = e.Prev, a4 = n4.Prev;
            e.Prev = a4, a4.Next = e, n4.Prev = i, i.Next = n4, t.Pts = e;
            var u5 = this.CreateOutRec();
            u5.Pts = n4, this.UpdateOutPtIdxs(u5), this.Poly2ContainsPoly1(u5.Pts, t.Pts) ? (u5.IsHole = !t.IsHole, u5.FirstLeft = t) : this.Poly2ContainsPoly1(t.Pts, u5.Pts) ? (u5.IsHole = t.IsHole, t.IsHole = !u5.IsHole, u5.FirstLeft = t.FirstLeft, t.FirstLeft = u5) : (u5.IsHole = t.IsHole, u5.FirstLeft = t.FirstLeft), n4 = e;
          }
          n4 = n4.Next;
        }
        e = e.Next;
      } while (e != t.Pts);
    }
  };
  C3.Clipper.Area = function(r5) {
    var t = r5.length;
    if (t < 3) return 0;
    for (var e = 0, n4 = 0, i = t - 1; n4 < t; ++n4) e += (r5[i].X + r5[n4].X) * (r5[i].Y - r5[n4].Y), i = n4;
    return -e * 0.5;
  };
  C3.Clipper.prototype.Area = function(r5) {
    var t = r5.Pts;
    if (t == null) return 0;
    var e = 0;
    do
      e = e + (t.Prev.Pt.X + t.Pt.X) * (t.Prev.Pt.Y - t.Pt.Y), t = t.Next;
    while (t != r5.Pts);
    return e * 0.5;
  };
  C3.Clipper.SimplifyPolygon = function(r5, t) {
    var e = new Array(), n4 = new C3.Clipper(0);
    return n4.StrictlySimple = true, n4.AddPath(r5, C3.PolyType.ptSubject, true), n4.Execute(C3.ClipType.ctUnion, e, t, t), e;
  };
  C3.Clipper.SimplifyPolygons = function(r5, t) {
    typeof t > "u" && (t = C3.PolyFillType.pftEvenOdd);
    var e = new Array(), n4 = new C3.Clipper(0);
    return n4.StrictlySimple = true, n4.AddPaths(r5, C3.PolyType.ptSubject, true), n4.Execute(C3.ClipType.ctUnion, e, t, t), e;
  };
  C3.Clipper.DistanceSqrd = function(r5, t) {
    var e = r5.X - t.X, n4 = r5.Y - t.Y;
    return e * e + n4 * n4;
  };
  C3.Clipper.DistanceFromLineSqrd = function(r5, t, e) {
    var n4 = t.Y - e.Y, i = e.X - t.X, a4 = n4 * t.X + i * t.Y;
    return a4 = n4 * r5.X + i * r5.Y - a4, a4 * a4 / (n4 * n4 + i * i);
  };
  C3.Clipper.SlopesNearCollinear = function(r5, t, e, n4) {
    return C3.Clipper.DistanceFromLineSqrd(t, r5, e) < n4;
  };
  C3.Clipper.PointsAreClose = function(r5, t, e) {
    var n4 = r5.X - t.X, i = r5.Y - t.Y;
    return n4 * n4 + i * i <= e;
  };
  C3.Clipper.ExcludeOp = function(r5) {
    var t = r5.Prev;
    return t.Next = r5.Next, r5.Next.Prev = t, t.Idx = 0, t;
  };
  C3.Clipper.CleanPolygon = function(r5, t) {
    typeof t > "u" && (t = 1.415);
    var e = r5.length;
    if (e == 0) return new Array();
    for (var n4 = new Array(e), i = 0; i < e; ++i) n4[i] = new C3.OutPt();
    for (var i = 0; i < e; ++i) n4[i].Pt = r5[i], n4[i].Next = n4[(i + 1) % e], n4[i].Next.Prev = n4[i], n4[i].Idx = 0;
    for (var a4 = t * t, u5 = n4[0]; u5.Idx == 0 && u5.Next != u5.Prev; ) C3.Clipper.PointsAreClose(u5.Pt, u5.Prev.Pt, a4) ? (u5 = C3.Clipper.ExcludeOp(u5), e--) : C3.Clipper.PointsAreClose(u5.Prev.Pt, u5.Next.Pt, a4) ? (C3.Clipper.ExcludeOp(u5.Next), u5 = C3.Clipper.ExcludeOp(u5), e -= 2) : C3.Clipper.SlopesNearCollinear(u5.Prev.Pt, u5.Pt, u5.Next.Pt, a4) ? (u5 = C3.Clipper.ExcludeOp(u5), e--) : (u5.Idx = 1, u5 = u5.Next);
    e < 3 && (e = 0);
    for (var h = new Array(e), i = 0; i < e; ++i) h[i] = new C3.IntPoint(u5.Pt), u5 = u5.Next;
    return n4 = null, h;
  };
  C3.Clipper.CleanPolygons = function(r5, t) {
    for (var e = new Array(r5.length), n4 = 0, i = r5.length; n4 < i; n4++) e[n4] = C3.Clipper.CleanPolygon(r5[n4], t);
    return e;
  };
  C3.Clipper.Minkowski = function(r5, t, e, n4) {
    var i = n4 ? 1 : 0, a4 = r5.length, u5 = t.length, h = new Array();
    if (e) for (var d = 0; d < u5; d++) {
      for (var m5 = new Array(a4), v3 = 0, x2 = r5.length, S4 = r5[v3]; v3 < x2; v3++, S4 = r5[v3]) m5[v3] = new C3.IntPoint(t[d].X + S4.X, t[d].Y + S4.Y);
      h.push(m5);
    }
    else for (var d = 0; d < u5; d++) {
      for (var m5 = new Array(a4), v3 = 0, x2 = r5.length, S4 = r5[v3]; v3 < x2; v3++, S4 = r5[v3]) m5[v3] = new C3.IntPoint(t[d].X - S4.X, t[d].Y - S4.Y);
      h.push(m5);
    }
    for (var I3 = new Array(), d = 0; d < u5 - 1 + i; d++) for (var v3 = 0; v3 < a4; v3++) {
      var w3 = new Array();
      w3.push(h[d % u5][v3 % a4]), w3.push(h[(d + 1) % u5][v3 % a4]), w3.push(h[(d + 1) % u5][(v3 + 1) % a4]), w3.push(h[d % u5][(v3 + 1) % a4]), C3.Clipper.Orientation(w3) || w3.reverse(), I3.push(w3);
    }
    var E4 = new C3.Clipper(0);
    return E4.AddPaths(I3, C3.PolyType.ptSubject, true), E4.Execute(C3.ClipType.ctUnion, h, C3.PolyFillType.pftNonZero, C3.PolyFillType.pftNonZero), h;
  };
  C3.Clipper.MinkowskiSum = function() {
    var r5 = arguments, t = r5.length;
    if (t == 3) {
      var e = r5[0], n4 = r5[1], i = r5[2];
      return C3.Clipper.Minkowski(e, n4, true, i);
    } else if (t == 4) {
      for (var e = r5[0], a4 = r5[1], u5 = r5[2], i = r5[3], h = new C3.Clipper(), d, m5 = 0, v3 = a4.length; m5 < v3; ++m5) {
        var d = C3.Clipper.Minkowski(e, a4[m5], true, i);
        h.AddPaths(d, C3.PolyType.ptSubject, true);
      }
      i && h.AddPaths(a4, C3.PolyType.ptClip, true);
      var x2 = new C3.Paths();
      return h.Execute(C3.ClipType.ctUnion, x2, u5, u5), x2;
    }
  };
  C3.Clipper.MinkowskiDiff = function(r5, t, e) {
    return C3.Clipper.Minkowski(r5, t, false, e);
  };
  C3.Clipper.PolyTreeToPaths = function(r5) {
    var t = new Array();
    return C3.Clipper.AddPolyNodeToPaths(r5, C3.Clipper.NodeType.ntAny, t), t;
  };
  C3.Clipper.AddPolyNodeToPaths = function(r5, t, e) {
    var n4 = true;
    switch (t) {
      case C3.Clipper.NodeType.ntOpen:
        return;
      case C3.Clipper.NodeType.ntClosed:
        n4 = !r5.IsOpen;
        break;
    }
    r5.m_polygon.length > 0 && n4 && e.push(r5.m_polygon);
    for (var i = 0, a4 = r5.Childs(), u5 = a4.length, h = a4[i]; i < u5; i++, h = a4[i]) C3.Clipper.AddPolyNodeToPaths(h, t, e);
  };
  C3.Clipper.OpenPathsFromPolyTree = function(r5) {
    for (var t = new C3.Paths(), e = 0, n4 = r5.ChildCount(); e < n4; e++) r5.Childs()[e].IsOpen && t.push(r5.Childs()[e].m_polygon);
    return t;
  };
  C3.Clipper.ClosedPathsFromPolyTree = function(r5) {
    var t = new C3.Paths();
    return C3.Clipper.AddPolyNodeToPaths(r5, C3.Clipper.NodeType.ntClosed, t), t;
  };
  lx3(C3.Clipper, C3.ClipperBase);
  C3.Clipper.NodeType = { ntAny: 0, ntOpen: 1, ntClosed: 2 };
  C3.ClipperOffset = function(r5, t) {
    typeof r5 > "u" && (r5 = 2), typeof t > "u" && (t = C3.ClipperOffset.def_arc_tolerance), this.m_destPolys = new C3.Paths(), this.m_srcPoly = new C3.Path(), this.m_destPoly = new C3.Path(), this.m_normals = new Array(), this.m_delta = 0, this.m_sinA = 0, this.m_sin = 0, this.m_cos = 0, this.m_miterLim = 0, this.m_StepsPerRad = 0, this.m_lowest = new C3.IntPoint(), this.m_polyNodes = new C3.PolyNode(), this.MiterLimit = r5, this.ArcTolerance = t, this.m_lowest.X = -1;
  };
  C3.ClipperOffset.two_pi = 6.28318530717959;
  C3.ClipperOffset.def_arc_tolerance = 0.25;
  C3.ClipperOffset.prototype.Clear = function() {
    C3.Clear(this.m_polyNodes.Childs()), this.m_lowest.X = -1;
  };
  C3.ClipperOffset.Round = C3.Clipper.Round;
  C3.ClipperOffset.prototype.AddPath = function(r5, t, e) {
    var n4 = r5.length - 1;
    if (!(n4 < 0)) {
      var i = new C3.PolyNode();
      if (i.m_jointype = t, i.m_endtype = e, e == C3.EndType.etClosedLine || e == C3.EndType.etClosedPolygon) for (; n4 > 0 && C3.IntPoint.op_Equality(r5[0], r5[n4]); ) n4--;
      i.m_polygon.push(r5[0]);
      for (var a4 = 0, u5 = 0, h = 1; h <= n4; h++) C3.IntPoint.op_Inequality(i.m_polygon[a4], r5[h]) && (a4++, i.m_polygon.push(r5[h]), (r5[h].Y > i.m_polygon[u5].Y || r5[h].Y == i.m_polygon[u5].Y && r5[h].X < i.m_polygon[u5].X) && (u5 = a4));
      if (!(e == C3.EndType.etClosedPolygon && a4 < 2 || e != C3.EndType.etClosedPolygon && a4 < 0) && (this.m_polyNodes.AddChild(i), e == C3.EndType.etClosedPolygon)) if (this.m_lowest.X < 0) this.m_lowest = new C3.IntPoint(0, u5);
      else {
        var d = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];
        (i.m_polygon[u5].Y > d.Y || i.m_polygon[u5].Y == d.Y && i.m_polygon[u5].X < d.X) && (this.m_lowest = new C3.IntPoint(this.m_polyNodes.ChildCount() - 1, u5));
      }
    }
  };
  C3.ClipperOffset.prototype.AddPaths = function(r5, t, e) {
    for (var n4 = 0, i = r5.length; n4 < i; n4++) this.AddPath(r5[n4], t, e);
  };
  C3.ClipperOffset.prototype.FixOrientations = function() {
    if (this.m_lowest.X >= 0 && !C3.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) for (var r5 = 0; r5 < this.m_polyNodes.ChildCount(); r5++) {
      var t = this.m_polyNodes.Childs()[r5];
      (t.m_endtype == C3.EndType.etClosedPolygon || t.m_endtype == C3.EndType.etClosedLine && C3.Clipper.Orientation(t.m_polygon)) && t.m_polygon.reverse();
    }
    else for (var r5 = 0; r5 < this.m_polyNodes.ChildCount(); r5++) {
      var t = this.m_polyNodes.Childs()[r5];
      t.m_endtype == C3.EndType.etClosedLine && !C3.Clipper.Orientation(t.m_polygon) && t.m_polygon.reverse();
    }
  };
  C3.ClipperOffset.GetUnitNormal = function(r5, t) {
    var e = t.X - r5.X, n4 = t.Y - r5.Y;
    if (e == 0 && n4 == 0) return new C3.DoublePoint(0, 0);
    var i = 1 / Math.sqrt(e * e + n4 * n4);
    return e *= i, n4 *= i, new C3.DoublePoint(n4, -e);
  };
  C3.ClipperOffset.prototype.DoOffset = function(r5) {
    if (this.m_destPolys = new Array(), this.m_delta = r5, C3.ClipperBase.near_zero(r5)) {
      for (var t = 0; t < this.m_polyNodes.ChildCount(); t++) {
        var e = this.m_polyNodes.Childs()[t];
        e.m_endtype == C3.EndType.etClosedPolygon && this.m_destPolys.push(e.m_polygon);
      }
      return;
    }
    this.MiterLimit > 2 ? this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit) : this.m_miterLim = 0.5;
    var n4;
    this.ArcTolerance <= 0 ? n4 = C3.ClipperOffset.def_arc_tolerance : this.ArcTolerance > Math.abs(r5) * C3.ClipperOffset.def_arc_tolerance ? n4 = Math.abs(r5) * C3.ClipperOffset.def_arc_tolerance : n4 = this.ArcTolerance;
    var i = 3.14159265358979 / Math.acos(1 - n4 / Math.abs(r5));
    this.m_sin = Math.sin(C3.ClipperOffset.two_pi / i), this.m_cos = Math.cos(C3.ClipperOffset.two_pi / i), this.m_StepsPerRad = i / C3.ClipperOffset.two_pi, r5 < 0 && (this.m_sin = -this.m_sin);
    for (var t = 0; t < this.m_polyNodes.ChildCount(); t++) {
      var e = this.m_polyNodes.Childs()[t];
      this.m_srcPoly = e.m_polygon;
      var a4 = this.m_srcPoly.length;
      if (!(a4 == 0 || r5 <= 0 && (a4 < 3 || e.m_endtype != C3.EndType.etClosedPolygon))) {
        if (this.m_destPoly = new Array(), a4 == 1) {
          if (e.m_jointype == C3.JoinType.jtRound) for (var u5 = 1, h = 0, d = 1; d <= i; d++) {
            this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[0].X + u5 * r5), C3.ClipperOffset.Round(this.m_srcPoly[0].Y + h * r5)));
            var m5 = u5;
            u5 = u5 * this.m_cos - this.m_sin * h, h = m5 * this.m_sin + h * this.m_cos;
          }
          else for (var u5 = -1, h = -1, d = 0; d < 4; ++d) this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[0].X + u5 * r5), C3.ClipperOffset.Round(this.m_srcPoly[0].Y + h * r5))), u5 < 0 ? u5 = 1 : h < 0 ? h = 1 : u5 = -1;
          this.m_destPolys.push(this.m_destPoly);
          continue;
        }
        this.m_normals.length = 0;
        for (var d = 0; d < a4 - 1; d++) this.m_normals.push(C3.ClipperOffset.GetUnitNormal(this.m_srcPoly[d], this.m_srcPoly[d + 1]));
        if (e.m_endtype == C3.EndType.etClosedLine || e.m_endtype == C3.EndType.etClosedPolygon ? this.m_normals.push(C3.ClipperOffset.GetUnitNormal(this.m_srcPoly[a4 - 1], this.m_srcPoly[0])) : this.m_normals.push(new C3.DoublePoint(this.m_normals[a4 - 2])), e.m_endtype == C3.EndType.etClosedPolygon) {
          for (var v3 = a4 - 1, d = 0; d < a4; d++) v3 = this.OffsetPoint(d, v3, e.m_jointype);
          this.m_destPolys.push(this.m_destPoly);
        } else if (e.m_endtype == C3.EndType.etClosedLine) {
          for (var v3 = a4 - 1, d = 0; d < a4; d++) v3 = this.OffsetPoint(d, v3, e.m_jointype);
          this.m_destPolys.push(this.m_destPoly), this.m_destPoly = new Array();
          for (var x2 = this.m_normals[a4 - 1], d = a4 - 1; d > 0; d--) this.m_normals[d] = new C3.DoublePoint(-this.m_normals[d - 1].X, -this.m_normals[d - 1].Y);
          this.m_normals[0] = new C3.DoublePoint(-x2.X, -x2.Y), v3 = 0;
          for (var d = a4 - 1; d >= 0; d--) v3 = this.OffsetPoint(d, v3, e.m_jointype);
          this.m_destPolys.push(this.m_destPoly);
        } else {
          for (var v3 = 0, d = 1; d < a4 - 1; ++d) v3 = this.OffsetPoint(d, v3, e.m_jointype);
          var S4;
          if (e.m_endtype == C3.EndType.etOpenButt) {
            var d = a4 - 1;
            S4 = new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[d].X + this.m_normals[d].X * r5), C3.ClipperOffset.Round(this.m_srcPoly[d].Y + this.m_normals[d].Y * r5)), this.m_destPoly.push(S4), S4 = new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[d].X - this.m_normals[d].X * r5), C3.ClipperOffset.Round(this.m_srcPoly[d].Y - this.m_normals[d].Y * r5)), this.m_destPoly.push(S4);
          } else {
            var d = a4 - 1;
            v3 = a4 - 2, this.m_sinA = 0, this.m_normals[d] = new C3.DoublePoint(-this.m_normals[d].X, -this.m_normals[d].Y), e.m_endtype == C3.EndType.etOpenSquare ? this.DoSquare(d, v3) : this.DoRound(d, v3);
          }
          for (var d = a4 - 1; d > 0; d--) this.m_normals[d] = new C3.DoublePoint(-this.m_normals[d - 1].X, -this.m_normals[d - 1].Y);
          this.m_normals[0] = new C3.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y), v3 = a4 - 1;
          for (var d = v3 - 1; d > 0; --d) v3 = this.OffsetPoint(d, v3, e.m_jointype);
          e.m_endtype == C3.EndType.etOpenButt ? (S4 = new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * r5), C3.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * r5)), this.m_destPoly.push(S4), S4 = new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * r5), C3.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * r5)), this.m_destPoly.push(S4)) : (v3 = 1, this.m_sinA = 0, e.m_endtype == C3.EndType.etOpenSquare ? this.DoSquare(0, 1) : this.DoRound(0, 1)), this.m_destPolys.push(this.m_destPoly);
        }
      }
    }
  };
  C3.ClipperOffset.prototype.Execute = function() {
    var r5 = arguments, t = r5[0] instanceof C3.PolyTree;
    if (t) {
      var e = r5[0], n4 = r5[1];
      e.Clear(), this.FixOrientations(), this.DoOffset(n4);
      var i = new C3.Clipper(0);
      if (i.AddPaths(this.m_destPolys, C3.PolyType.ptSubject, true), n4 > 0) i.Execute(C3.ClipType.ctUnion, e, C3.PolyFillType.pftPositive, C3.PolyFillType.pftPositive);
      else {
        var a4 = C3.Clipper.GetBounds(this.m_destPolys), u5 = new C3.Path();
        if (u5.push(new C3.IntPoint(a4.left - 10, a4.bottom + 10)), u5.push(new C3.IntPoint(a4.right + 10, a4.bottom + 10)), u5.push(new C3.IntPoint(a4.right + 10, a4.top - 10)), u5.push(new C3.IntPoint(a4.left - 10, a4.top - 10)), i.AddPath(u5, C3.PolyType.ptSubject, true), i.ReverseSolution = true, i.Execute(C3.ClipType.ctUnion, e, C3.PolyFillType.pftNegative, C3.PolyFillType.pftNegative), e.ChildCount() == 1 && e.Childs()[0].ChildCount() > 0) {
          var h = e.Childs()[0];
          e.Childs()[0] = h.Childs()[0];
          for (var d = 1; d < h.ChildCount(); d++) e.AddChild(h.Childs()[d]);
        } else e.Clear();
      }
    } else {
      var e = r5[0], n4 = r5[1];
      C3.Clear(e), this.FixOrientations(), this.DoOffset(n4);
      var i = new C3.Clipper(0);
      if (i.AddPaths(this.m_destPolys, C3.PolyType.ptSubject, true), n4 > 0) i.Execute(C3.ClipType.ctUnion, e, C3.PolyFillType.pftPositive, C3.PolyFillType.pftPositive);
      else {
        var a4 = C3.Clipper.GetBounds(this.m_destPolys), u5 = new C3.Path();
        u5.push(new C3.IntPoint(a4.left - 10, a4.bottom + 10)), u5.push(new C3.IntPoint(a4.right + 10, a4.bottom + 10)), u5.push(new C3.IntPoint(a4.right + 10, a4.top - 10)), u5.push(new C3.IntPoint(a4.left - 10, a4.top - 10)), i.AddPath(u5, C3.PolyType.ptSubject, true), i.ReverseSolution = true, i.Execute(C3.ClipType.ctUnion, e, C3.PolyFillType.pftNegative, C3.PolyFillType.pftNegative), e.length > 0 && e.splice(0, 1);
      }
    }
  };
  C3.ClipperOffset.prototype.OffsetPoint = function(r5, t, e) {
    if (this.m_sinA = this.m_normals[t].X * this.m_normals[r5].Y - this.m_normals[r5].X * this.m_normals[t].Y, this.m_sinA < 5e-5 && this.m_sinA > -5e-5) return t;
    if (this.m_sinA > 1 ? this.m_sinA = 1 : this.m_sinA < -1 && (this.m_sinA = -1), this.m_sinA * this.m_delta < 0) this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[r5].X + this.m_normals[t].X * this.m_delta), C3.ClipperOffset.Round(this.m_srcPoly[r5].Y + this.m_normals[t].Y * this.m_delta))), this.m_destPoly.push(new C3.IntPoint(this.m_srcPoly[r5])), this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[r5].X + this.m_normals[r5].X * this.m_delta), C3.ClipperOffset.Round(this.m_srcPoly[r5].Y + this.m_normals[r5].Y * this.m_delta)));
    else switch (e) {
      case C3.JoinType.jtMiter: {
        var n4 = 1 + (this.m_normals[r5].X * this.m_normals[t].X + this.m_normals[r5].Y * this.m_normals[t].Y);
        n4 >= this.m_miterLim ? this.DoMiter(r5, t, n4) : this.DoSquare(r5, t);
        break;
      }
      case C3.JoinType.jtSquare:
        this.DoSquare(r5, t);
        break;
      case C3.JoinType.jtRound:
        this.DoRound(r5, t);
        break;
    }
    return t = r5, t;
  };
  C3.ClipperOffset.prototype.DoSquare = function(r5, t) {
    var e = Math.tan(Math.atan2(this.m_sinA, this.m_normals[t].X * this.m_normals[r5].X + this.m_normals[t].Y * this.m_normals[r5].Y) / 4);
    this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[r5].X + this.m_delta * (this.m_normals[t].X - this.m_normals[t].Y * e)), C3.ClipperOffset.Round(this.m_srcPoly[r5].Y + this.m_delta * (this.m_normals[t].Y + this.m_normals[t].X * e)))), this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[r5].X + this.m_delta * (this.m_normals[r5].X + this.m_normals[r5].Y * e)), C3.ClipperOffset.Round(this.m_srcPoly[r5].Y + this.m_delta * (this.m_normals[r5].Y - this.m_normals[r5].X * e))));
  };
  C3.ClipperOffset.prototype.DoMiter = function(r5, t, e) {
    var n4 = this.m_delta / e;
    this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[r5].X + (this.m_normals[t].X + this.m_normals[r5].X) * n4), C3.ClipperOffset.Round(this.m_srcPoly[r5].Y + (this.m_normals[t].Y + this.m_normals[r5].Y) * n4)));
  };
  C3.ClipperOffset.prototype.DoRound = function(r5, t) {
    for (var e = Math.atan2(this.m_sinA, this.m_normals[t].X * this.m_normals[r5].X + this.m_normals[t].Y * this.m_normals[r5].Y), n4 = C3.Cast_Int32(C3.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(e))), i = this.m_normals[t].X, a4 = this.m_normals[t].Y, u5, h = 0; h < n4; ++h) this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[r5].X + i * this.m_delta), C3.ClipperOffset.Round(this.m_srcPoly[r5].Y + a4 * this.m_delta))), u5 = i, i = i * this.m_cos - this.m_sin * a4, a4 = u5 * this.m_sin + a4 * this.m_cos;
    this.m_destPoly.push(new C3.IntPoint(C3.ClipperOffset.Round(this.m_srcPoly[r5].X + this.m_normals[r5].X * this.m_delta), C3.ClipperOffset.Round(this.m_srcPoly[r5].Y + this.m_normals[r5].Y * this.m_delta)));
  };
  C3.Error = function(r5) {
    try {
      throw new Error(r5);
    } catch (t) {
      alert(t.message);
    }
  };
  C3.JS = {};
  C3.JS.AreaOfPolygon = function(r5, t) {
    return t || (t = 1), C3.Clipper.Area(r5) / (t * t);
  };
  C3.JS.AreaOfPolygons = function(r5, t) {
    t || (t = 1);
    for (var e = 0, n4 = 0; n4 < r5.length; n4++) e += C3.Clipper.Area(r5[n4]);
    return e / (t * t);
  };
  C3.JS.BoundsOfPath = function(r5, t) {
    return C3.JS.BoundsOfPaths([r5], t);
  };
  C3.JS.BoundsOfPaths = function(r5, t) {
    t || (t = 1);
    var e = C3.Clipper.GetBounds(r5);
    return e.left /= t, e.bottom /= t, e.right /= t, e.top /= t, e;
  };
  C3.JS.Clean = function(n4, t) {
    if (!(n4 instanceof Array)) return [];
    var e = n4[0] instanceof Array, n4 = C3.JS.Clone(n4);
    if (typeof t != "number" || t === null) return C3.Error("Delta is not a number in Clean()."), n4;
    if (n4.length === 0 || n4.length == 1 && n4[0].length === 0 || t < 0) return n4;
    e || (n4 = [n4]);
    for (var i = n4.length, a4, u5, h, d, m5, v3, x2, S4 = [], I3 = 0; I3 < i; I3++) if (u5 = n4[I3], a4 = u5.length, a4 !== 0) {
      if (a4 < 3) {
        h = u5, S4.push(h);
        continue;
      }
      for (h = u5, d = t * t, m5 = u5[0], v3 = 1, x2 = 1; x2 < a4; x2++) (u5[x2].X - m5.X) * (u5[x2].X - m5.X) + (u5[x2].Y - m5.Y) * (u5[x2].Y - m5.Y) <= d || (h[v3] = u5[x2], m5 = u5[x2], v3++);
      m5 = u5[v3 - 1], (u5[0].X - m5.X) * (u5[0].X - m5.X) + (u5[0].Y - m5.Y) * (u5[0].Y - m5.Y) <= d && v3--, v3 < a4 && h.splice(v3, a4 - v3), h.length && S4.push(h);
    }
    return !e && S4.length ? S4 = S4[0] : !e && S4.length === 0 ? S4 = [] : e && S4.length === 0 && (S4 = [[]]), S4;
  };
  C3.JS.Clone = function(r5) {
    if (!(r5 instanceof Array)) return [];
    if (r5.length === 0) return [];
    if (r5.length == 1 && r5[0].length === 0) return [[]];
    var t = r5[0] instanceof Array;
    t || (r5 = [r5]);
    var e = r5.length, n4, i, a4, u5, h = new Array(e);
    for (i = 0; i < e; i++) {
      for (n4 = r5[i].length, u5 = new Array(n4), a4 = 0; a4 < n4; a4++) u5[a4] = { X: r5[i][a4].X, Y: r5[i][a4].Y };
      h[i] = u5;
    }
    return t || (h = h[0]), h;
  };
  C3.JS.Lighten = function(r5, t) {
    if (!(r5 instanceof Array)) return [];
    if (typeof t != "number" || t === null) return C3.Error("Tolerance is not a number in Lighten()."), C3.JS.Clone(r5);
    if (r5.length === 0 || r5.length == 1 && r5[0].length === 0 || t < 0) return C3.JS.Clone(r5);
    r5[0] instanceof Array || (r5 = [r5]);
    var e, n4, i, a4, u5, h, d, m5, v3, x2, S4, I3, w3, E4, T3, D4, A3, L3 = r5.length, B3 = t * t, j3 = [];
    for (e = 0; e < L3; e++) if (i = r5[e], h = i.length, h != 0) {
      for (a4 = 0; a4 < 1e6; a4++) {
        for (u5 = [], h = i.length, i[h - 1].X != i[0].X || i[h - 1].Y != i[0].Y ? (I3 = 1, i.push({ X: i[0].X, Y: i[0].Y }), h = i.length) : I3 = 0, S4 = [], n4 = 0; n4 < h - 2; n4++) d = i[n4], v3 = i[n4 + 1], m5 = i[n4 + 2], D4 = d.X, A3 = d.Y, w3 = m5.X - D4, E4 = m5.Y - A3, (w3 !== 0 || E4 !== 0) && (T3 = ((v3.X - D4) * w3 + (v3.Y - A3) * E4) / (w3 * w3 + E4 * E4), T3 > 1 ? (D4 = m5.X, A3 = m5.Y) : T3 > 0 && (D4 += w3 * T3, A3 += E4 * T3)), w3 = v3.X - D4, E4 = v3.Y - A3, x2 = w3 * w3 + E4 * E4, x2 <= B3 && (S4[n4 + 1] = 1, n4++);
        for (u5.push({ X: i[0].X, Y: i[0].Y }), n4 = 1; n4 < h - 1; n4++) S4[n4] || u5.push({ X: i[n4].X, Y: i[n4].Y });
        if (u5.push({ X: i[h - 1].X, Y: i[h - 1].Y }), I3 && i.pop(), S4.length) i = u5;
        else break;
      }
      h = u5.length, u5[h - 1].X == u5[0].X && u5[h - 1].Y == u5[0].Y && u5.pop(), u5.length > 2 && j3.push(u5);
    }
    return !r5[0] instanceof Array && (j3 = j3[0]), typeof j3 > "u" && (j3 = [[]]), j3;
  };
  C3.JS.PerimeterOfPath = function(r5, t, e) {
    if (typeof r5 > "u") return 0;
    var n4 = Math.sqrt, i = 0, a4, u5, h = 0, d = 0, m5 = 0, v3 = 0, x2 = r5.length;
    if (x2 < 2) return 0;
    for (t && (r5[x2] = r5[0], x2++); --x2; ) a4 = r5[x2], h = a4.X, d = a4.Y, u5 = r5[x2 - 1], m5 = u5.X, v3 = u5.Y, i += n4((h - m5) * (h - m5) + (d - v3) * (d - v3));
    return t && r5.pop(), i / e;
  };
  C3.JS.PerimeterOfPaths = function(r5, t, e) {
    e || (e = 1);
    for (var n4 = 0, i = 0; i < r5.length; i++) n4 += C3.JS.PerimeterOfPath(r5[i], t, e);
    return n4;
  };
  C3.JS.ScaleDownPath = function(r5, t) {
    var e, n4;
    for (t || (t = 1), e = r5.length; e--; ) n4 = r5[e], n4.X = n4.X / t, n4.Y = n4.Y / t;
  };
  C3.JS.ScaleDownPaths = function(r5, t) {
    var e, n4, i;
    for (t || (t = 1), e = r5.length; e--; ) for (n4 = r5[e].length; n4--; ) i = r5[e][n4], i.X = i.X / t, i.Y = i.Y / t;
  };
  C3.JS.ScaleUpPath = function(r5, t) {
    var e, n4, i = Math.round;
    for (t || (t = 1), e = r5.length; e--; ) n4 = r5[e], n4.X = i(n4.X * t), n4.Y = i(n4.Y * t);
  };
  C3.JS.ScaleUpPaths = function(r5, t) {
    var e, n4, i, a4 = Math.round;
    for (t || (t = 1), e = r5.length; e--; ) for (n4 = r5[e].length; n4--; ) i = r5[e][n4], i.X = a4(i.X * t), i.Y = a4(i.Y * t);
  };
  C3.ExPolygons = function() {
    return [];
  };
  C3.ExPolygon = function() {
    this.outer = null, this.holes = null;
  };
  C3.JS.AddOuterPolyNodeToExPolygons = function(r5, t) {
    var e = new C3.ExPolygon();
    e.outer = r5.Contour();
    var n4 = r5.Childs(), i = n4.length;
    e.holes = new Array(i);
    var a4, u5, h, d, m5, v3;
    for (h = 0; h < i; h++) for (a4 = n4[h], e.holes[h] = a4.Contour(), d = 0, m5 = a4.Childs(), v3 = m5.length; d < v3; d++) u5 = m5[d], C3.JS.AddOuterPolyNodeToExPolygons(u5, t);
    t.push(e);
  };
  C3.JS.ExPolygonsToPaths = function(r5) {
    var t, e, n4, i, a4 = new C3.Paths();
    for (t = 0, n4 = r5.length; t < n4; t++) for (a4.push(r5[t].outer), e = 0, i = r5[t].holes.length; e < i; e++) a4.push(r5[t].holes[e]);
    return a4;
  };
  C3.JS.PolyTreeToExPolygons = function(r5) {
    var t = new C3.ExPolygons(), e, n4, i, a4;
    for (n4 = 0, i = r5.Childs(), a4 = i.length; n4 < a4; n4++) e = i[n4], C3.JS.AddOuterPolyNodeToExPolygons(e, t);
    return t;
  };
  jy3.exports = C3;
});
var oL = L((BVt, x2) => {
  a();
  (function() {
    function r5(u5, h) {
      var d = u5.x - h.x, m5 = u5.y - h.y;
      return d * d + m5 * m5;
    }
    H$3(r5, "getSqDist");
    function t(u5, h, d) {
      var m5 = h.x, v3 = h.y, x3 = d.x - m5, S4 = d.y - v3;
      if (x3 !== 0 || S4 !== 0) {
        var I3 = ((u5.x - m5) * x3 + (u5.y - v3) * S4) / (x3 * x3 + S4 * S4);
        I3 > 1 ? (m5 = d.x, v3 = d.y) : I3 > 0 && (m5 += x3 * I3, v3 += S4 * I3);
      }
      return x3 = u5.x - m5, S4 = u5.y - v3, x3 * x3 + S4 * S4;
    }
    H$3(t, "getSqSegDist");
    function e(u5, h) {
      for (var d = u5[0], m5 = [d], v3, x3 = 1, S4 = u5.length; x3 < S4; x3++) v3 = u5[x3], r5(v3, d) > h && (m5.push(v3), d = v3);
      return d !== v3 && m5.push(v3), m5;
    }
    H$3(e, "simplifyRadialDist");
    function n4(u5, h, d, m5, v3) {
      for (var x3 = m5, S4, I3 = h + 1; I3 < d; I3++) {
        var w3 = t(u5[I3], u5[h], u5[d]);
        w3 > x3 && (S4 = I3, x3 = w3);
      }
      x3 > m5 && (S4 - h > 1 && n4(u5, h, S4, m5, v3), v3.push(u5[S4]), d - S4 > 1 && n4(u5, S4, d, m5, v3));
    }
    H$3(n4, "simplifyDPStep");
    function i(u5, h) {
      var d = u5.length - 1, m5 = [u5[0]];
      return n4(u5, 0, d, h, m5), m5.push(u5[d]), m5;
    }
    H$3(i, "simplifyDouglasPeucker");
    function a4(u5, h, d) {
      if (u5.length <= 2) return u5;
      var m5 = h !== void 0 ? h * h : 1;
      return u5 = d ? u5 : e(u5, m5), u5 = i(u5, m5), u5;
    }
    H$3(a4, "simplify"), typeof define == "function" && define.amd ? define(function() {
      return a4;
    }) : typeof x2 < "u" ? (x2.exports = a4, x2.exports.default = a4) : typeof self < "u" ? self.simplify = a4 : window.simplify = a4;
  })();
});
a();
a();
var d_ = class d_2 {
  constructor(t) {
    O(this, "id");
    this.id = t;
  }
};
H$3(d_, "BaseMetaData");
var si = d_;
a();
a();
var vp = class vp2 {
  constructor(t, e, n4) {
    O(this, "__type", vp2.__type);
    O(this, "id", E());
    O(this, "latitude");
    O(this, "longitude");
    O(this, "floorId");
    O(this, "verticalOffset");
    var i;
    if (typeof t == "object") this.latitude = t.latitude, this.longitude = t.longitude, this.floorId = t.floorId, this.verticalOffset = (i = t.verticalOffset) != null ? i : 0;
    else {
      if (e == null) throw new Error("Coordinate longitude is required.");
      this.latitude = t, this.longitude = e, this.floorId = n4, this.verticalOffset = 0;
    }
  }
  static is(t) {
    return t.__type === vp2.__type;
  }
  get anchorTarget() {
    return this;
  }
  get focusTarget() {
    return this;
  }
  isEqual(t) {
    return this.latitude === t.latitude && this.longitude === t.longitude && this.floorId === t.floorId;
  }
  toJSON() {
    return { __type: vp2.__type, latitude: this.latitude, longitude: this.longitude, floorId: this.floorId, verticalOffset: this.verticalOffset };
  }
  destroy() {
  }
};
H$3(vp, "Coordinate"), O(vp, "__type", "coordinate");
var m_ = vp, ve2 = m_;
a();
a();
a();
function Mn(r5) {
  if (!r5) throw new Error("coord is required");
  if (!Array.isArray(r5)) {
    if (r5.type === "Feature" && r5.geometry !== null && r5.geometry.type === "Point") return r5.geometry.coordinates;
    if (r5.type === "Point") return r5.coordinates;
  }
  if (Array.isArray(r5) && r5.length >= 2 && !Array.isArray(r5[0]) && !Array.isArray(r5[1])) return r5;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
H$3(Mn, "getCoord");
function Hr(r5) {
  if (Array.isArray(r5)) return r5;
  if (r5.type === "Feature") {
    if (r5.geometry !== null) return r5.geometry.coordinates;
  } else if (r5.coordinates) return r5.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
H$3(Hr, "getCoords");
function g_(r5, t, e) {
  if (!r5) throw new Error("No feature passed");
  if (!e) throw new Error(".featureOf() requires a name");
  if (!r5 || r5.type !== "Feature" || !r5.geometry) throw new Error("Invalid input to " + e + ", Feature with geometry required");
  if (!r5.geometry || r5.geometry.type !== t) throw new Error("Invalid input to " + e + ": must be a " + t + ", given " + r5.geometry.type);
}
H$3(g_, "featureOf");
function Qn(r5) {
  return r5.type === "Feature" ? r5.geometry : r5;
}
H$3(Qn, "getGeom");
function os(r5, t) {
  return r5.type === "FeatureCollection" ? "FeatureCollection" : r5.type === "GeometryCollection" ? "GeometryCollection" : r5.type === "Feature" && r5.geometry !== null ? r5.geometry.type : r5.type;
}
H$3(os, "getType");
N$2(nv(), 1);
a();
N$2(BP(), 1);
a();
a();
function cn$1(r5, t, e) {
  if (e === void 0 && (e = {}), !r5) throw new Error("point is required");
  if (!t) throw new Error("polygon is required");
  var n4 = Mn(r5), i = Qn(t), a4 = i.type, u5 = t.bbox, h = i.coordinates;
  if (u5 && _A(n4, u5) === false) return false;
  a4 === "Polygon" && (h = [h]);
  for (var d = false, m5 = 0; m5 < h.length && !d; m5++) if (GP(n4, h[m5][0], e.ignoreBoundary)) {
    for (var v3 = false, x2 = 1; x2 < h[m5].length && !v3; ) GP(n4, h[m5][x2], !e.ignoreBoundary) && (v3 = true), x2++;
    v3 || (d = true);
  }
  return d;
}
H$3(cn$1, "booleanPointInPolygon");
function GP(r5, t, e) {
  var n4 = false;
  t[0][0] === t[t.length - 1][0] && t[0][1] === t[t.length - 1][1] && (t = t.slice(0, t.length - 1));
  for (var i = 0, a4 = t.length - 1; i < t.length; a4 = i++) {
    var u5 = t[i][0], h = t[i][1], d = t[a4][0], m5 = t[a4][1], v3 = r5[1] * (u5 - d) + h * (d - r5[0]) + m5 * (r5[0] - u5) === 0 && (u5 - r5[0]) * (d - r5[0]) <= 0 && (h - r5[1]) * (m5 - r5[1]) <= 0;
    if (v3) return !e;
    var x2 = h > r5[1] != m5 > r5[1] && r5[0] < (d - u5) * (r5[1] - h) / (m5 - h) + u5;
    x2 && (n4 = !n4);
  }
  return n4;
}
H$3(GP, "inRing");
function _A(r5, t) {
  return t[0] <= r5[0] && t[1] <= r5[1] && t[2] >= r5[0] && t[3] >= r5[1];
}
H$3(_A, "inBBox");
a();
a();
function CA(r5, t, e) {
  e === void 0 && (e = {});
  var n4 = Mn(r5), i = Mn(t), a4 = Nn2(i[1] - n4[1]), u5 = Nn2(i[0] - n4[0]), h = Nn2(n4[1]), d = Nn2(i[1]), m5 = Math.pow(Math.sin(a4 / 2), 2) + Math.pow(Math.sin(u5 / 2), 2) * Math.cos(h) * Math.cos(d);
  return Ln(2 * Math.atan2(Math.sqrt(m5), Math.sqrt(1 - m5)), e.units);
}
H$3(CA, "distance");
var bn = CA;
a();
(function() {
  function r5(t, e, n4) {
    this.a = t, this.b = e, this.c = n4;
    var i = e.x - t.x, a4 = e.y - t.y, u5 = n4.x - t.x, h = n4.y - t.y, d = i * (t.x + e.x) + a4 * (t.y + e.y), m5 = u5 * (t.x + n4.x) + h * (t.y + n4.y), v3 = 2 * (i * (n4.y - e.y) - a4 * (n4.x - e.x)), x2, S4;
    this.x = (h * d - a4 * m5) / v3, this.y = (i * m5 - u5 * d) / v3, x2 = this.x - t.x, S4 = this.y - t.y, this.r = x2 * x2 + S4 * S4;
  }
  return H$3(r5, "Triangle"), r5;
})();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
N$2(O_(), 1);
a();
a();
a();
a();
a();
(function() {
  function r5(t) {
    this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || 0.85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length, this.delay = 0;
    for (var e = 0; e < this.length; e++) this.points[e].z = this.points[e].z || 0;
    for (var e = 0; e < this.length - 1; e++) {
      var n4 = this.points[e], i = this.points[e + 1];
      this.centers.push({ x: (n4.x + i.x) / 2, y: (n4.y + i.y) / 2, z: (n4.z + i.z) / 2 });
    }
    this.controls.push([this.points[0], this.points[0]]);
    for (var e = 0; e < this.centers.length - 1; e++) {
      var a4 = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2, u5 = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2, h = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;
      this.controls.push([{ x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + a4), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + u5), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + h) }, { x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + a4), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + u5), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + h) }]);
    }
    return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this;
  }
  return H$3(r5, "Spline"), r5.prototype.cacheSteps = function(t) {
    var e = [], n4 = this.pos(0);
    e.push(0);
    for (var i = 0; i < this.duration; i += 10) {
      var a4 = this.pos(i), u5 = Math.sqrt((a4.x - n4.x) * (a4.x - n4.x) + (a4.y - n4.y) * (a4.y - n4.y) + (a4.z - n4.z) * (a4.z - n4.z));
      u5 > t && (e.push(i), n4 = a4);
    }
    return e;
  }, r5.prototype.vector = function(t) {
    var e = this.pos(t + 10), n4 = this.pos(t - 10);
    return { angle: 180 * Math.atan2(e.y - n4.y, e.x - n4.x) / 3.14, speed: Math.sqrt((n4.x - e.x) * (n4.x - e.x) + (n4.y - e.y) * (n4.y - e.y) + (n4.z - e.z) * (n4.z - e.z)) };
  }, r5.prototype.pos = function(t) {
    var e = t - this.delay;
    e < 0 && (e = 0), e > this.duration && (e = this.duration - 1);
    var n4 = e / this.duration;
    if (n4 >= 1) return this.points[this.length - 1];
    var i = Math.floor((this.points.length - 1) * n4), a4 = (this.length - 1) * n4 - i;
    return BA(a4, this.points[i], this.controls[i][1], this.controls[i + 1][0], this.points[i + 1]);
  }, r5;
})();
function BA(r5, t, e, n4, i) {
  var a4 = GA(r5), u5 = { x: i.x * a4[0] + n4.x * a4[1] + e.x * a4[2] + t.x * a4[3], y: i.y * a4[0] + n4.y * a4[1] + e.y * a4[2] + t.y * a4[3], z: i.z * a4[0] + n4.z * a4[1] + e.z * a4[2] + t.z * a4[3] };
  return u5;
}
H$3(BA, "bezier");
function GA(r5) {
  var t = r5 * r5, e = t * r5;
  return [e, 3 * t * (1 - r5), 3 * r5 * (1 - r5) * (1 - r5), (1 - r5) * (1 - r5) * (1 - r5)];
}
H$3(GA, "B");
a();
a();
a();
a();
function vg(r5, t) {
  t === void 0 && (t = {});
  var e = Number(r5[0]), n4 = Number(r5[1]), i = Number(r5[2]), a4 = Number(r5[3]);
  if (r5.length === 6) throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  var u5 = [e, n4], h = [e, a4], d = [i, a4], m5 = [i, n4];
  return Sn([[u5, m5, d, h, u5]], t.properties, { bbox: r5, id: t.id });
}
H$3(vg, "bboxPolygon");
function VA(r5) {
  return vg(lt(r5));
}
H$3(VA, "envelope");
var D_ = VA;
a();
a();
a();
function ss(r5, t, e, n4) {
  n4 === void 0 && (n4 = {});
  var i = Mn(r5), a4 = Nn2(i[0]), u5 = Nn2(i[1]), h = Nn2(e), d = On2(t, n4.units), m5 = Math.asin(Math.sin(u5) * Math.cos(d) + Math.cos(u5) * Math.sin(d) * Math.cos(h)), v3 = a4 + Math.atan2(Math.sin(h) * Math.sin(d) * Math.cos(u5), Math.cos(d) - Math.sin(u5) * Math.sin(m5)), x2 = An$1(v3), S4 = An$1(m5);
  return Ft$1([x2, S4], n4.properties);
}
H$3(ss, "destination");
a();
a();
function Yl(r5, t, e) {
  if (e === void 0 && (e = {}), e.final === true) return jA(r5, t);
  var n4 = Mn(r5), i = Mn(t), a4 = Nn2(n4[0]), u5 = Nn2(i[0]), h = Nn2(n4[1]), d = Nn2(i[1]), m5 = Math.sin(u5 - a4) * Math.cos(d), v3 = Math.cos(h) * Math.sin(d) - Math.sin(h) * Math.cos(d) * Math.cos(u5 - a4);
  return An$1(Math.atan2(m5, v3));
}
H$3(Yl, "bearing");
function jA(r5, t) {
  var e = Yl(t, r5);
  return e = (e + 180) % 360, e;
}
H$3(jA, "calculateFinalBearing");
a();
function UA(r5, t) {
  t === void 0 && (t = {});
  var e = lt(r5), n4 = (e[0] + e[2]) / 2, i = (e[1] + e[3]) / 2;
  return Ft$1([n4, i], t.properties, t);
}
H$3(UA, "center");
var qa = UA;
a();
a();
a();
a();
a();
N$2(Em$1(), 1);
a();
a();
a();
a();
function XA(r5) {
  if (!r5) throw new Error("geojson is required");
  var t = [];
  return Bt(r5, function(e) {
    YA(e, t);
  }), wn$1(t);
}
H$3(XA, "lineSegment");
function YA(r5, t) {
  var e = [], n4 = r5.geometry;
  if (n4 !== null) {
    switch (n4.type) {
      case "Polygon":
        e = Hr(n4);
        break;
      case "LineString":
        e = [Hr(n4)];
    }
    e.forEach(function(i) {
      var a4 = qA(i, r5.properties);
      a4.forEach(function(u5) {
        u5.id = t.length, t.push(u5);
      });
    });
  }
}
H$3(YA, "lineSegmentFeature");
function qA(r5, t) {
  var e = [];
  return r5.reduce(function(n4, i) {
    var a4 = ut([n4, i], t);
    return a4.bbox = WA(n4, i), e.push(a4), i;
  }), e;
}
H$3(qA, "createSegments");
function WA(r5, t) {
  var e = r5[0], n4 = r5[1], i = t[0], a4 = t[1], u5 = e < i ? e : i, h = n4 < a4 ? n4 : a4, d = e > i ? e : i, m5 = n4 > a4 ? n4 : a4;
  return [u5, h, d, m5];
}
H$3(WA, "bbox");
var xp = XA;
var lE = N$2(mv(), 1);
function _N(r5, t) {
  var e = {}, n4 = [];
  if (r5.type === "LineString" && (r5 = I(r5)), t.type === "LineString" && (t = I(t)), r5.type === "Feature" && t.type === "Feature" && r5.geometry !== null && t.geometry !== null && r5.geometry.type === "LineString" && t.geometry.type === "LineString" && r5.geometry.coordinates.length === 2 && t.geometry.coordinates.length === 2) {
    var i = aE(r5, t);
    return i && n4.push(i), wn$1(n4);
  }
  var a4 = (0, lE.default)();
  return a4.load(xp(t)), Vn$1(xp(r5), function(u5) {
    Vn$1(a4.search(u5), function(h) {
      var d = aE(u5, h);
      if (d) {
        var m5 = Hr(d).join(",");
        e[m5] || (e[m5] = true, n4.push(d));
      }
    });
  }), wn$1(n4);
}
H$3(_N, "lineIntersect");
function aE(r5, t) {
  var e = Hr(r5), n4 = Hr(t);
  if (e.length !== 2) throw new Error("<intersects> line1 must only contain 2 coordinates");
  if (n4.length !== 2) throw new Error("<intersects> line2 must only contain 2 coordinates");
  var i = e[0][0], a4 = e[0][1], u5 = e[1][0], h = e[1][1], d = n4[0][0], m5 = n4[0][1], v3 = n4[1][0], x2 = n4[1][1], S4 = (x2 - m5) * (u5 - i) - (v3 - d) * (h - a4), I3 = (v3 - d) * (a4 - m5) - (x2 - m5) * (i - d), w3 = (u5 - i) * (a4 - m5) - (h - a4) * (i - d);
  if (S4 === 0) return null;
  var E4 = I3 / S4, T3 = w3 / S4;
  if (E4 >= 0 && E4 <= 1 && T3 >= 0 && T3 <= 1) {
    var D4 = i + E4 * (u5 - i), A3 = a4 + E4 * (h - a4);
    return Ft$1([D4, A3]);
  }
  return null;
}
H$3(aE, "intersects");
var Za = _N;
function CN(r5, t, e) {
  e === void 0 && (e = {});
  var n4 = Ft$1([1 / 0, 1 / 0], { dist: 1 / 0 }), i = 0;
  return Bt(r5, function(a4) {
    for (var u5 = Hr(a4), h = 0; h < u5.length - 1; h++) {
      var d = Ft$1(u5[h]);
      d.properties.dist = bn(t, d, e);
      var m5 = Ft$1(u5[h + 1]);
      m5.properties.dist = bn(t, m5, e);
      var v3 = bn(d, m5, e), x2 = Math.max(d.properties.dist, m5.properties.dist), S4 = Yl(d, m5), I3 = ss(t, x2, S4 + 90, e), w3 = ss(t, x2, S4 - 90, e), E4 = Za(ut([I3.geometry.coordinates, w3.geometry.coordinates]), ut([d.geometry.coordinates, m5.geometry.coordinates])), T3 = null;
      E4.features.length > 0 && (T3 = E4.features[0], T3.properties.dist = bn(t, T3, e), T3.properties.location = i + bn(d, T3, e)), d.properties.dist < n4.properties.dist && (n4 = d, n4.properties.index = h, n4.properties.location = i), m5.properties.dist < n4.properties.dist && (n4 = m5, n4.properties.index = h + 1, n4.properties.location = i + v3), T3 && T3.properties.dist < n4.properties.dist && (n4 = T3, n4.properties.index = h), i += v3;
    }
  }), n4;
}
H$3(CN, "nearestPointOnLine");
var ql = CN;
a();
a();
a();
N$2(nv(), 1);
a();
a();
a();
a();
a();
a();
function _p(r5, t) {
  return t === void 0 && (t = {}), jn$1(r5, function(e, n4) {
    var i = n4.geometry.coordinates;
    return e + bn(i[0], i[1], t);
  }, 0);
}
H$3(_p, "length");
a();
function MN(r5, t, e) {
  var n4 = Hr(e);
  if (os(e) !== "LineString") throw new Error("line must be a LineString");
  var i = ql(e, r5), a4 = ql(e, t), u5;
  i.properties.index <= a4.properties.index ? u5 = [i, a4] : u5 = [a4, i];
  for (var h = [u5[0].geometry.coordinates], d = u5[0].properties.index + 1; d < u5[1].properties.index + 1; d++) h.push(n4[d]);
  return h.push(u5[1].geometry.coordinates), ut(h, e.properties);
}
H$3(MN, "lineSlice");
var yv = MN;
a();
a();
a();
a();
function TN(r5, t, e) {
  e === void 0 && (e = {});
  for (var n4 = Mn(r5), i = Hr(t), a4 = 0; a4 < i.length - 1; a4++) {
    var u5 = false;
    if (e.ignoreEndVertices && (a4 === 0 && (u5 = "start"), a4 === i.length - 2 && (u5 = "end"), a4 === 0 && a4 + 1 === i.length - 1 && (u5 = "both")), wN(i[a4], i[a4 + 1], n4, u5, typeof e.epsilon > "u" ? null : e.epsilon)) return true;
  }
  return false;
}
H$3(TN, "booleanPointOnLine");
function wN(r5, t, e, n4, i) {
  var a4 = e[0], u5 = e[1], h = r5[0], d = r5[1], m5 = t[0], v3 = t[1], x2 = e[0] - h, S4 = e[1] - d, I3 = m5 - h, w3 = v3 - d, E4 = x2 * w3 - S4 * I3;
  if (i !== null) {
    if (Math.abs(E4) > i) return false;
  } else if (E4 !== 0) return false;
  if (n4) {
    if (n4 === "start") return Math.abs(I3) >= Math.abs(w3) ? I3 > 0 ? h < a4 && a4 <= m5 : m5 <= a4 && a4 < h : w3 > 0 ? d < u5 && u5 <= v3 : v3 <= u5 && u5 < d;
    if (n4 === "end") return Math.abs(I3) >= Math.abs(w3) ? I3 > 0 ? h <= a4 && a4 < m5 : m5 < a4 && a4 <= h : w3 > 0 ? d <= u5 && u5 < v3 : v3 < u5 && u5 <= d;
    if (n4 === "both") return Math.abs(I3) >= Math.abs(w3) ? I3 > 0 ? h < a4 && a4 < m5 : m5 < a4 && a4 < h : w3 > 0 ? d < u5 && u5 < v3 : v3 < u5 && u5 < d;
  } else return Math.abs(I3) >= Math.abs(w3) ? I3 > 0 ? h <= a4 && a4 <= m5 : m5 <= a4 && a4 <= h : w3 > 0 ? d <= u5 && u5 <= v3 : v3 <= u5 && u5 <= d;
  return false;
}
H$3(wN, "isPointOnLineSegment");
var ed2 = TN;
a();
a();
a();
a();
N$2(O_(), 1);
a();
var hE = Math.PI / 180, fE = 180 / Math.PI, xg2 = H$3(function(r5, t) {
  this.lon = r5, this.lat = t, this.x = hE * r5, this.y = hE * t;
}, "Coord");
xg2.prototype.view = function() {
  return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};
xg2.prototype.antipode = function() {
  var r5 = -1 * this.lat, t = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
  return new xg2(t, r5);
};
var dE = H$3(function() {
  this.coords = [], this.length = 0;
}, "LineString");
dE.prototype.move_to = function(r5) {
  this.length++, this.coords.push(r5);
};
var X_ = H$3(function(r5) {
  this.properties = r5 || {}, this.geometries = [];
}, "Arc");
X_.prototype.json = function() {
  if (this.geometries.length <= 0) return { geometry: { type: "LineString", coordinates: null }, type: "Feature", properties: this.properties };
  if (this.geometries.length === 1) return { geometry: { type: "LineString", coordinates: this.geometries[0].coords }, type: "Feature", properties: this.properties };
  for (var r5 = [], t = 0; t < this.geometries.length; t++) r5.push(this.geometries[t].coords);
  return { geometry: { type: "MultiLineString", coordinates: r5 }, type: "Feature", properties: this.properties };
};
X_.prototype.wkt = function() {
  for (var r5 = "", t = "LINESTRING(", e = H$3(function(a4) {
    t += a4[0] + " " + a4[1] + ",";
  }, "collect"), n4 = 0; n4 < this.geometries.length; n4++) {
    if (this.geometries[n4].coords.length === 0) return "LINESTRING(empty)";
    var i = this.geometries[n4].coords;
    i.forEach(e), r5 += t.substring(0, t.length - 1) + ")";
  }
  return r5;
};
var mE = H$3(function(r5, t, e) {
  if (!r5 || r5.x === void 0 || r5.y === void 0) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
  if (!t || t.x === void 0 || t.y === void 0) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
  this.start = new xg2(r5.x, r5.y), this.end = new xg2(t.x, t.y), this.properties = e || {};
  var n4 = this.start.x - this.end.x, i = this.start.y - this.end.y, a4 = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(n4 / 2), 2);
  if (this.g = 2 * Math.asin(Math.sqrt(a4)), this.g === Math.PI) throw new Error("it appears " + r5.view() + " and " + t.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
  if (isNaN(this.g)) throw new Error("could not calculate great circle between " + r5 + " and " + t);
}, "GreatCircle");
mE.prototype.interpolate = function(r5) {
  var t = Math.sin((1 - r5) * this.g) / Math.sin(this.g), e = Math.sin(r5 * this.g) / Math.sin(this.g), n4 = t * Math.cos(this.start.y) * Math.cos(this.start.x) + e * Math.cos(this.end.y) * Math.cos(this.end.x), i = t * Math.cos(this.start.y) * Math.sin(this.start.x) + e * Math.cos(this.end.y) * Math.sin(this.end.x), a4 = t * Math.sin(this.start.y) + e * Math.sin(this.end.y), u5 = fE * Math.atan2(a4, Math.sqrt(Math.pow(n4, 2) + Math.pow(i, 2))), h = fE * Math.atan2(i, n4);
  return [h, u5];
};
mE.prototype.Arc = function(r5, t) {
  var e = [];
  if (!r5 || r5 <= 2) e.push([this.start.lon, this.start.lat]), e.push([this.end.lon, this.end.lat]);
  else for (var n4 = 1 / (r5 - 1), i = 0; i < r5; ++i) {
    var a4 = n4 * i, u5 = this.interpolate(a4);
    e.push(u5);
  }
  for (var h = false, d = 0, m5 = t && t.offset ? t.offset : 10, v3 = 180 - m5, x2 = -180 + m5, S4 = 360 - m5, I3 = 1; I3 < e.length; ++I3) {
    var w3 = e[I3 - 1][0], E4 = e[I3][0], T3 = Math.abs(E4 - w3);
    T3 > S4 && (E4 > v3 && w3 < x2 || w3 > v3 && E4 < x2) ? h = true : T3 > d && (d = T3);
  }
  var D4 = [];
  if (h && d < m5) {
    var A3 = [];
    D4.push(A3);
    for (var L3 = 0; L3 < e.length; ++L3) {
      var B3 = parseFloat(e[L3][0]);
      if (L3 > 0 && Math.abs(B3 - e[L3 - 1][0]) > S4) {
        var j3 = parseFloat(e[L3 - 1][0]), W4 = parseFloat(e[L3 - 1][1]), $5 = parseFloat(e[L3][0]), F3 = parseFloat(e[L3][1]);
        if (j3 > -180 && j3 < x2 && $5 === 180 && L3 + 1 < e.length && e[L3 - 1][0] > -180 && e[L3 - 1][0] < x2) {
          A3.push([-180, e[L3][1]]), L3++, A3.push([e[L3][0], e[L3][1]]);
          continue;
        } else if (j3 > v3 && j3 < 180 && $5 === -180 && L3 + 1 < e.length && e[L3 - 1][0] > v3 && e[L3 - 1][0] < 180) {
          A3.push([180, e[L3][1]]), L3++, A3.push([e[L3][0], e[L3][1]]);
          continue;
        }
        if (j3 < x2 && $5 > v3) {
          var J4 = j3;
          j3 = $5, $5 = J4;
          var ot2 = W4;
          W4 = F3, F3 = ot2;
        }
        if (j3 > v3 && $5 < x2 && ($5 += 360), j3 <= 180 && $5 >= 180 && j3 < $5) {
          var K4 = (180 - j3) / ($5 - j3), H5 = K4 * F3 + (1 - K4) * W4;
          A3.push([e[L3 - 1][0] > v3 ? 180 : -180, H5]), A3 = [], A3.push([e[L3 - 1][0] > v3 ? -180 : 180, H5]), D4.push(A3);
        } else A3 = [], D4.push(A3);
        A3.push([B3, e[L3][1]]);
      } else A3.push([e[L3][0], e[L3][1]]);
    }
  } else {
    var _t2 = [];
    D4.push(_t2);
    for (var ct2 = 0; ct2 < e.length; ++ct2) _t2.push([e[ct2][0], e[ct2][1]]);
  }
  for (var ft2 = new X_(this.properties), mt2 = 0; mt2 < D4.length; ++mt2) {
    var St2 = new dE();
    ft2.geometries.push(St2);
    for (var dt2 = D4[mt2], xt2 = 0; xt2 < dt2.length; ++xt2) St2.move_to(dt2[xt2]);
  }
  return ft2;
};
a();
N$2(mv(), 1);
a();
a();
function Cp2(r5, t) {
  t === void 0 && (t = {});
  var e = Qn(r5);
  switch (!t.properties && r5.type === "Feature" && (t.properties = r5.properties), e.type) {
    case "Polygon":
      return yE(e, t);
    case "MultiPolygon":
      return NN(e, t);
    default:
      throw new Error("invalid poly");
  }
}
H$3(Cp2, "default");
function yE(r5, t) {
  t === void 0 && (t = {});
  var e = Qn(r5), n4 = e.coordinates, i = t.properties ? t.properties : r5.type === "Feature" ? r5.properties : {};
  return vE(n4, i);
}
H$3(yE, "polygonToLine");
function NN(r5, t) {
  t === void 0 && (t = {});
  var e = Qn(r5), n4 = e.coordinates, i = t.properties ? t.properties : r5.type === "Feature" ? r5.properties : {}, a4 = [];
  return n4.forEach(function(u5) {
    a4.push(vE(u5, i));
  }), wn$1(a4);
}
H$3(NN, "multiPolygonToLine");
function vE(r5, t) {
  return r5.length > 1 ? Pn$1(r5, t) : ut(r5[0], t);
}
H$3(vE, "coordsToLine");
a();
a();
a();
a();
N$2(mv(), 1);
N$2(bC(), 1);
a();
a();
a();
a();
a();
a();
a();
N$2(nv(), 1);
H$3(function(r5) {
  return [[r5.bottomleft, 0], [0, 0], [0, r5.leftbottom]];
}, "p00");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [r5.bottomright, 0]];
}, "p01");
H$3(function(r5) {
  return [[r5.topright, 1], [1, 1], [1, r5.righttop]];
}, "p02");
H$3(function(r5) {
  return [[0, r5.lefttop], [0, 1], [r5.topleft, 1]];
}, "p03");
H$3(function(r5) {
  return [[r5.bottomright, 0], [r5.bottomleft, 0], [0, r5.leftbottom], [0, r5.lefttop]];
}, "p04");
H$3(function(r5) {
  return [[r5.bottomright, 0], [r5.bottomleft, 0], [1, r5.righttop], [1, r5.rightbottom]];
}, "p05");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [r5.topleft, 1], [r5.topright, 1]];
}, "p06");
H$3(function(r5) {
  return [[0, r5.leftbottom], [0, r5.lefttop], [r5.topleft, 1], [r5.topright, 1]];
}, "p07");
H$3(function(r5) {
  return [[0, 0], [0, r5.leftbottom], [1, r5.rightbottom], [1, 0]];
}, "p08");
H$3(function(r5) {
  return [[1, 0], [r5.bottomright, 0], [r5.topright, 1], [1, 1]];
}, "p09");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [0, r5.lefttop], [0, 1]];
}, "p10");
H$3(function(r5) {
  return [[r5.bottomleft, 0], [0, 0], [0, 1], [r5.topleft, 1]];
}, "p11");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [0, r5.leftbottom], [0, r5.lefttop]];
}, "p12");
H$3(function(r5) {
  return [[r5.topleft, 1], [r5.topright, 1], [r5.bottomright, 0], [r5.bottomleft, 0]];
}, "p13");
H$3(function() {
  return [[0, 0], [0, 1], [1, 1], [1, 0]];
}, "p14");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [0, 0], [0, 1], [r5.topleft, 1]];
}, "p15");
H$3(function(r5) {
  return [[r5.topright, 1], [1, 1], [1, 0], [0, 0], [0, r5.leftbottom]];
}, "p16");
H$3(function(r5) {
  return [[1, 0], [r5.bottomright, 0], [0, r5.lefttop], [0, 1], [1, 1]];
}, "p17");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [r5.bottomleft, 0], [0, 0], [0, 1]];
}, "p18");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [0, r5.lefttop], [0, 1], [r5.topleft, 1]];
}, "p19");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [r5.bottomright, 0], [r5.bottomleft, 0], [r5.topright, 1]];
}, "p20");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [r5.bottomright, 0], [0, r5.leftbottom], [0, r5.lefttop]];
}, "p21");
H$3(function(r5) {
  return [[r5.topright, 1], [r5.bottomleft, 0], [0, 0], [0, r5.leftbottom], [r5.topleft, 1]];
}, "p22");
H$3(function(r5) {
  return [[r5.bottomright, 0], [r5.bottomleft, 0], [0, r5.lefttop], [0, 1], [r5.topleft, 1]];
}, "p23");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [0, r5.leftbottom], [0, r5.lefttop], [r5.topright, 1]];
}, "p24");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [r5.bottomright, 0], [r5.topleft, 1], [r5.topright, 1]];
}, "p25");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [r5.bottomleft, 0], [0, 0], [0, r5.leftbottom]];
}, "p26");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [0, 0], [0, r5.leftbottom], [r5.topleft, 1], [r5.topright, 1]];
}, "p27");
H$3(function(r5) {
  return [[1, 1], [1, 0], [r5.bottomright, 0], [0, r5.leftbottom], [0, r5.lefttop], [r5.topright, 1]];
}, "p28");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [r5.bottomright, 0], [r5.bottomleft, 0], [0, r5.lefttop], [0, 1]];
}, "p29");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [r5.bottomleft, 0], [0, 0], [0, 1], [r5.topleft, 1]];
}, "p30");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [r5.bottomleft, 0], [0, 0], [0, r5.leftbottom], [r5.topright, 1]];
}, "p31");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [r5.bottomright, 0], [0, r5.lefttop], [0, 1], [r5.topleft, 1]];
}, "p32");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [r5.bottomright, 0], [r5.bottomleft, 0], [0, r5.leftbottom], [0, r5.lefttop], [r5.topleft, 1], [r5.topright, 1]];
}, "p33");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [r5.bottomleft, 0], [0, 0], [0, r5.leftbottom], [r5.topright, 1]];
}, "p34");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [r5.bottomright, 0], [0, r5.lefttop], [0, 1], [r5.topleft, 1]];
}, "p35");
H$3(function(r5) {
  return [[1, 1], [1, r5.righttop], [r5.bottomright, 0], [r5.bottomleft, 0], [0, r5.leftbottom], [0, r5.lefttop], [r5.topright, 1]];
}, "p36");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [r5.bottomleft, 0], [0, 0], [0, r5.leftbottom], [r5.topleft, 1], [r5.topright, 1]];
}, "p37");
H$3(function(r5) {
  return [[1, r5.righttop], [1, r5.rightbottom], [r5.bottomright, 0], [r5.bottomleft, 0], [0, r5.lefttop], [0, 1], [r5.topleft, 1]];
}, "p38");
H$3(function(r5) {
  return [[1, r5.rightbottom], [1, 0], [r5.bottomright, 0], [0, r5.leftbottom], [0, r5.lefttop], [r5.topleft, 1], [r5.topright, 1]];
}, "p39");
a();
a();
a();
a();
a();
a();
a();
a();
function yF(r5) {
  return (r5 > 0) - (r5 < 0) || +r5;
}
H$3(yF, "mathSign");
function ud(r5, t, e) {
  var n4 = t[0] - r5[0], i = t[1] - r5[1], a4 = e[0] - t[0], u5 = e[1] - t[1];
  return yF(n4 * u5 - a4 * i);
}
H$3(ud, "orientationIndex");
function i6(r5, t) {
  var e = r5.geometry.coordinates[0].map(function(u5) {
    return u5[0];
  }), n4 = r5.geometry.coordinates[0].map(function(u5) {
    return u5[1];
  }), i = t.geometry.coordinates[0].map(function(u5) {
    return u5[0];
  }), a4 = t.geometry.coordinates[0].map(function(u5) {
    return u5[1];
  });
  return Math.max.apply(null, e) === Math.max.apply(null, i) && Math.max.apply(null, n4) === Math.max.apply(null, a4) && Math.min.apply(null, e) === Math.min.apply(null, i) && Math.min.apply(null, n4) === Math.min.apply(null, a4);
}
H$3(i6, "envelopeIsEqual");
function PC(r5, t) {
  return t.geometry.coordinates[0].every(function(e) {
    return cn$1(Ft$1(e), r5);
  });
}
H$3(PC, "envelopeContains");
function o6(r5, t) {
  return r5[0] === t[0] && r5[1] === t[1];
}
H$3(o6, "coordinatesEqual");
var vF = (function() {
  function r5(t) {
    this.id = r5.buildId(t), this.coordinates = t, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = false;
  }
  return H$3(r5, "Node"), r5.buildId = function(t) {
    return t.join(",");
  }, r5.prototype.removeInnerEdge = function(t) {
    this.innerEdges = this.innerEdges.filter(function(e) {
      return e.from.id !== t.from.id;
    });
  }, r5.prototype.removeOuterEdge = function(t) {
    this.outerEdges = this.outerEdges.filter(function(e) {
      return e.to.id !== t.to.id;
    });
  }, r5.prototype.addOuterEdge = function(t) {
    this.outerEdges.push(t), this.outerEdgesSorted = false;
  }, r5.prototype.sortOuterEdges = function() {
    var t = this;
    this.outerEdgesSorted || (this.outerEdges.sort(function(e, n4) {
      var i = e.to, a4 = n4.to;
      if (i.coordinates[0] - t.coordinates[0] >= 0 && a4.coordinates[0] - t.coordinates[0] < 0) return 1;
      if (i.coordinates[0] - t.coordinates[0] < 0 && a4.coordinates[0] - t.coordinates[0] >= 0) return -1;
      if (i.coordinates[0] - t.coordinates[0] === 0 && a4.coordinates[0] - t.coordinates[0] === 0) return i.coordinates[1] - t.coordinates[1] >= 0 || a4.coordinates[1] - t.coordinates[1] >= 0 ? i.coordinates[1] - a4.coordinates[1] : a4.coordinates[1] - i.coordinates[1];
      var u5 = ud(t.coordinates, i.coordinates, a4.coordinates);
      if (u5 < 0) return 1;
      if (u5 > 0) return -1;
      var h = Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2), d = Math.pow(a4.coordinates[0] - t.coordinates[0], 2) + Math.pow(a4.coordinates[1] - t.coordinates[1], 2);
      return h - d;
    }), this.outerEdgesSorted = true);
  }, r5.prototype.getOuterEdges = function() {
    return this.sortOuterEdges(), this.outerEdges;
  }, r5.prototype.getOuterEdge = function(t) {
    return this.sortOuterEdges(), this.outerEdges[t];
  }, r5.prototype.addInnerEdge = function(t) {
    this.innerEdges.push(t);
  }, r5;
})(), EC = vF;
a();
var bF = (function() {
  function r5(t, e) {
    this.from = t, this.to = e, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this);
  }
  return H$3(r5, "Edge"), r5.prototype.getSymetric = function() {
    return this.symetric || (this.symetric = new r5(this.to, this.from), this.symetric.symetric = this), this.symetric;
  }, r5.prototype.deleteEdge = function() {
    this.from.removeOuterEdge(this), this.to.removeInnerEdge(this);
  }, r5.prototype.isEqual = function(t) {
    return this.from.id === t.from.id && this.to.id === t.to.id;
  }, r5.prototype.toString = function() {
    return "Edge { " + this.from.id + " -> " + this.to.id + " }";
  }, r5.prototype.toLineString = function() {
    return ut([this.from.coordinates, this.to.coordinates]);
  }, r5.prototype.compareTo = function(t) {
    return ud(t.from.coordinates, t.to.coordinates, this.to.coordinates);
  }, r5;
})(), s6 = bF;
a();
var xF = (function() {
  function r5() {
    this.edges = [], this.polygon = void 0, this.envelope = void 0;
  }
  return H$3(r5, "EdgeRing"), r5.prototype.push = function(t) {
    this.edges.push(t), this.polygon = this.envelope = void 0;
  }, r5.prototype.get = function(t) {
    return this.edges[t];
  }, Object.defineProperty(r5.prototype, "length", { get: H$3(function() {
    return this.edges.length;
  }, "get"), enumerable: true, configurable: true }), r5.prototype.forEach = function(t) {
    this.edges.forEach(t);
  }, r5.prototype.map = function(t) {
    return this.edges.map(t);
  }, r5.prototype.some = function(t) {
    return this.edges.some(t);
  }, r5.prototype.isValid = function() {
    return true;
  }, r5.prototype.isHole = function() {
    var t = this, e = this.edges.reduce(function(u5, h, d) {
      return h.from.coordinates[1] > t.edges[u5].from.coordinates[1] && (u5 = d), u5;
    }, 0), n4 = (e === 0 ? this.length : e) - 1, i = (e + 1) % this.length, a4 = ud(this.edges[n4].from.coordinates, this.edges[e].from.coordinates, this.edges[i].from.coordinates);
    return a4 === 0 ? this.edges[n4].from.coordinates[0] > this.edges[i].from.coordinates[0] : a4 > 0;
  }, r5.prototype.toMultiPoint = function() {
    return Cn$1(this.edges.map(function(t) {
      return t.from.coordinates;
    }));
  }, r5.prototype.toPolygon = function() {
    if (this.polygon) return this.polygon;
    var t = this.edges.map(function(e) {
      return e.from.coordinates;
    });
    return t.push(this.edges[0].from.coordinates), this.polygon = Sn([t]);
  }, r5.prototype.getEnvelope = function() {
    return this.envelope ? this.envelope : this.envelope = D_(this.toPolygon());
  }, r5.findEdgeRingContaining = function(t, e) {
    var n4 = t.getEnvelope(), i, a4;
    return e.forEach(function(u5) {
      var h = u5.getEnvelope();
      if (a4 && (i = a4.getEnvelope()), !i6(h, n4) && PC(h, n4)) {
        for (var d = t.map(function(w3) {
          return w3.from.coordinates;
        }), m5 = void 0, v3 = H$3(function(w3) {
          u5.some(function(E4) {
            return o6(w3, E4.from.coordinates);
          }) || (m5 = w3);
        }, "_loop_1"), x2 = 0, S4 = d; x2 < S4.length; x2++) {
          var I3 = S4[x2];
          v3(I3);
        }
        m5 && u5.inside(Ft$1(m5)) && (!a4 || PC(i, h)) && (a4 = u5);
      }
    }), a4;
  }, r5.prototype.inside = function(t) {
    return cn$1(t, this.toPolygon());
  }, r5;
})(), OC = xF;
function _F(r5) {
  if (!r5) throw new Error("No geojson passed");
  if (r5.type !== "FeatureCollection" && r5.type !== "GeometryCollection" && r5.type !== "MultiLineString" && r5.type !== "LineString" && r5.type !== "Feature") throw new Error("Invalid input type '" + r5.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
}
H$3(_F, "validateGeoJson");
(function() {
  function r5() {
    this.edges = [], this.nodes = {};
  }
  return H$3(r5, "Graph"), r5.fromGeoJson = function(t) {
    _F(t);
    var e = new r5();
    return Bt(t, function(n4) {
      g_(n4, "LineString", "Graph::fromGeoJson"), Bn2(n4, function(i, a4) {
        if (i) {
          var u5 = e.getNode(i), h = e.getNode(a4);
          e.addEdge(u5, h);
        }
        return a4;
      });
    }), e;
  }, r5.prototype.getNode = function(t) {
    var e = EC.buildId(t), n4 = this.nodes[e];
    return n4 || (n4 = this.nodes[e] = new EC(t)), n4;
  }, r5.prototype.addEdge = function(t, e) {
    var n4 = new s6(t, e), i = n4.getSymetric();
    this.edges.push(n4), this.edges.push(i);
  }, r5.prototype.deleteDangles = function() {
    var t = this;
    Object.keys(this.nodes).map(function(e) {
      return t.nodes[e];
    }).forEach(function(e) {
      return t._removeIfDangle(e);
    });
  }, r5.prototype._removeIfDangle = function(t) {
    var e = this;
    if (t.innerEdges.length <= 1) {
      var n4 = t.getOuterEdges().map(function(i) {
        return i.to;
      });
      this.removeNode(t), n4.forEach(function(i) {
        return e._removeIfDangle(i);
      });
    }
  }, r5.prototype.deleteCutEdges = function() {
    var t = this;
    this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach(function(e) {
      e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e));
    });
  }, r5.prototype._computeNextCWEdges = function(t) {
    var e = this;
    typeof t > "u" ? Object.keys(this.nodes).forEach(function(n4) {
      return e._computeNextCWEdges(e.nodes[n4]);
    }) : t.getOuterEdges().forEach(function(n4, i) {
      t.getOuterEdge((i === 0 ? t.getOuterEdges().length : i) - 1).symetric.next = n4;
    });
  }, r5.prototype._computeNextCCWEdges = function(t, e) {
    for (var n4 = t.getOuterEdges(), i, a4, u5 = n4.length - 1; u5 >= 0; --u5) {
      var h = n4[u5], d = h.symetric, m5 = void 0, v3 = void 0;
      h.label === e && (m5 = h), d.label === e && (v3 = d), !(!m5 || !v3) && (v3 && (a4 = v3), m5 && (a4 && (a4.next = m5, a4 = void 0), i || (i = m5)));
    }
    a4 && (a4.next = i);
  }, r5.prototype._findLabeledEdgeRings = function() {
    var t = [], e = 0;
    return this.edges.forEach(function(n4) {
      if (!(n4.label >= 0)) {
        t.push(n4);
        var i = n4;
        do
          i.label = e, i = i.next;
        while (!n4.isEqual(i));
        e++;
      }
    }), t;
  }, r5.prototype.getEdgeRings = function() {
    var t = this;
    this._computeNextCWEdges(), this.edges.forEach(function(n4) {
      n4.label = void 0;
    }), this._findLabeledEdgeRings().forEach(function(n4) {
      t._findIntersectionNodes(n4).forEach(function(i) {
        t._computeNextCCWEdges(i, n4.label);
      });
    });
    var e = [];
    return this.edges.forEach(function(n4) {
      n4.ring || e.push(t._findEdgeRing(n4));
    }), e;
  }, r5.prototype._findIntersectionNodes = function(t) {
    var e = [], n4 = t, i = H$3(function() {
      var a4 = 0;
      n4.from.getOuterEdges().forEach(function(u5) {
        u5.label === t.label && ++a4;
      }), a4 > 1 && e.push(n4.from), n4 = n4.next;
    }, "_loop_1");
    do
      i();
    while (!t.isEqual(n4));
    return e;
  }, r5.prototype._findEdgeRing = function(t) {
    var e = t, n4 = new OC();
    do
      n4.push(e), e.ring = n4, e = e.next;
    while (!t.isEqual(e));
    return n4;
  }, r5.prototype.removeNode = function(t) {
    var e = this;
    t.getOuterEdges().forEach(function(n4) {
      return e.removeEdge(n4);
    }), t.innerEdges.forEach(function(n4) {
      return e.removeEdge(n4);
    }), delete this.nodes[t.id];
  }, r5.prototype.removeEdge = function(t) {
    this.edges = this.edges.filter(function(e) {
      return !e.isEqual(t);
    }), t.deleteEdge();
  }, r5;
})();
a();
function CF(r5, t) {
  var e = true;
  return Bt(r5, function(n4) {
    Bt(t, function(i) {
      if (e === false) return false;
      e = SF(n4.geometry, i.geometry);
    });
  }), e;
}
H$3(CF, "booleanDisjoint");
function SF(r5, t) {
  switch (r5.type) {
    case "Point":
      switch (t.type) {
        case "Point":
          return !wF(r5.coordinates, t.coordinates);
        case "LineString":
          return !a6(t, r5);
        case "Polygon":
          return !cn$1(r5, t);
      }
      break;
    case "LineString":
      switch (t.type) {
        case "Point":
          return !a6(r5, t);
        case "LineString":
          return !IF(r5, t);
        case "Polygon":
          return !l6(t, r5);
      }
      break;
    case "Polygon":
      switch (t.type) {
        case "Point":
          return !cn$1(t, r5);
        case "LineString":
          return !l6(r5, t);
        case "Polygon":
          return !MF(t, r5);
      }
  }
  return false;
}
H$3(SF, "disjoint");
function a6(r5, t) {
  for (var e = 0; e < r5.coordinates.length - 1; e++) if (TF(r5.coordinates[e], r5.coordinates[e + 1], t.coordinates)) return true;
  return false;
}
H$3(a6, "isPointOnLine");
function IF(r5, t) {
  var e = Za(r5, t);
  return e.features.length > 0;
}
H$3(IF, "isLineOnLine");
function l6(r5, t) {
  for (var e = 0, n4 = t.coordinates; e < n4.length; e++) {
    var i = n4[e];
    if (cn$1(i, r5)) return true;
  }
  var a4 = Za(t, Cp2(r5));
  return a4.features.length > 0;
}
H$3(l6, "isLineInPoly");
function MF(r5, t) {
  for (var e = 0, n4 = r5.coordinates[0]; e < n4.length; e++) {
    var i = n4[e];
    if (cn$1(i, t)) return true;
  }
  for (var a4 = 0, u5 = t.coordinates[0]; a4 < u5.length; a4++) {
    var h = u5[a4];
    if (cn$1(h, r5)) return true;
  }
  var d = Za(Cp2(r5), Cp2(t));
  return d.features.length > 0;
}
H$3(MF, "isPolyInPoly");
function TF(r5, t, e) {
  var n4 = e[0] - r5[0], i = e[1] - r5[1], a4 = t[0] - r5[0], u5 = t[1] - r5[1], h = n4 * u5 - i * a4;
  return h !== 0 ? false : Math.abs(a4) >= Math.abs(u5) ? a4 > 0 ? r5[0] <= e[0] && e[0] <= t[0] : t[0] <= e[0] && e[0] <= r5[0] : u5 > 0 ? r5[1] <= e[1] && e[1] <= t[1] : t[1] <= e[1] && e[1] <= r5[1];
}
H$3(TF, "isPointOnLineSegment");
function wF(r5, t) {
  return r5[0] === t[0] && r5[1] === t[1];
}
H$3(wF, "compareCoords");
var DC = CF;
a();
a();
a();
N$2(LC(), 1);
a();
N$2(LC(), 1);
a();
function Eg2(r5, t) {
  var e = false;
  return Bt(r5, function(n4) {
    Bt(t, function(i) {
      if (e === true) return true;
      e = !DC(n4.geometry, i.geometry);
    });
  }), e;
}
H$3(Eg2, "booleanIntersects");
a();
N$2(g6(), 1);
a();
N$2(T6(), 1);
a();
a();
function P6(r5) {
  for (var t = r5, e = []; t.parent; ) e.unshift(t), t = t.parent;
  return e;
}
H$3(P6, "pathTo");
function UF() {
  return new E6(function(r5) {
    return r5.f;
  });
}
H$3(UF, "getHeap");
var RC = { search: H$3(function(r5, t, e, n4) {
  r5.cleanDirty(), n4 = n4 || {};
  var i = n4.heuristic || RC.heuristics.manhattan, a4 = n4.closest || false, u5 = UF(), h = t;
  for (t.h = i(t, e), u5.push(t); u5.size() > 0; ) {
    var d = u5.pop();
    if (d === e) return P6(d);
    d.closed = true;
    for (var m5 = r5.neighbors(d), v3 = 0, x2 = m5.length; v3 < x2; ++v3) {
      var S4 = m5[v3];
      if (!(S4.closed || S4.isWall())) {
        var I3 = d.g + S4.getCost(d), w3 = S4.visited;
        (!w3 || I3 < S4.g) && (S4.visited = true, S4.parent = d, S4.h = S4.h || i(S4, e), S4.g = I3, S4.f = S4.g + S4.h, r5.markDirty(S4), a4 && (S4.h < h.h || S4.h === h.h && S4.g < h.g) && (h = S4), w3 ? u5.rescoreElement(S4) : u5.push(S4));
      }
    }
  }
  return a4 ? P6(h) : [];
}, "search"), heuristics: { manhattan: H$3(function(r5, t) {
  var e = Math.abs(t.x - r5.x), n4 = Math.abs(t.y - r5.y);
  return e + n4;
}, "manhattan"), diagonal: H$3(function(r5, t) {
  var e = 1, n4 = Math.sqrt(2), i = Math.abs(t.x - r5.x), a4 = Math.abs(t.y - r5.y);
  return e * (i + a4) + (n4 - 2 * e) * Math.min(i, a4);
}, "diagonal") }, cleanNode: H$3(function(r5) {
  r5.f = 0, r5.g = 0, r5.h = 0, r5.visited = false, r5.closed = false, r5.parent = null;
}, "cleanNode") };
function Og2(r5, t) {
  t = t || {}, this.nodes = [], this.diagonal = !!t.diagonal, this.grid = [];
  for (var e = 0; e < r5.length; e++) {
    this.grid[e] = [];
    for (var n4 = 0, i = r5[e]; n4 < i.length; n4++) {
      var a4 = new Vv(e, n4, i[n4]);
      this.grid[e][n4] = a4, this.nodes.push(a4);
    }
  }
  this.init();
}
H$3(Og2, "Graph");
Og2.prototype.init = function() {
  this.dirtyNodes = [];
  for (var r5 = 0; r5 < this.nodes.length; r5++) RC.cleanNode(this.nodes[r5]);
};
Og2.prototype.cleanDirty = function() {
  for (var r5 = 0; r5 < this.dirtyNodes.length; r5++) RC.cleanNode(this.dirtyNodes[r5]);
  this.dirtyNodes = [];
};
Og2.prototype.markDirty = function(r5) {
  this.dirtyNodes.push(r5);
};
Og2.prototype.neighbors = function(r5) {
  var t = [], e = r5.x, n4 = r5.y, i = this.grid;
  return i[e - 1] && i[e - 1][n4] && t.push(i[e - 1][n4]), i[e + 1] && i[e + 1][n4] && t.push(i[e + 1][n4]), i[e] && i[e][n4 - 1] && t.push(i[e][n4 - 1]), i[e] && i[e][n4 + 1] && t.push(i[e][n4 + 1]), this.diagonal && (i[e - 1] && i[e - 1][n4 - 1] && t.push(i[e - 1][n4 - 1]), i[e + 1] && i[e + 1][n4 - 1] && t.push(i[e + 1][n4 - 1]), i[e - 1] && i[e - 1][n4 + 1] && t.push(i[e - 1][n4 + 1]), i[e + 1] && i[e + 1][n4 + 1] && t.push(i[e + 1][n4 + 1])), t;
};
Og2.prototype.toString = function() {
  for (var r5 = [], t = this.grid, e, n4, i, a4, u5 = 0, h = t.length; u5 < h; u5++) {
    for (e = [], n4 = t[u5], i = 0, a4 = n4.length; i < a4; i++) e.push(n4[i].weight);
    r5.push(e.join(" "));
  }
  return r5.join("\n");
};
function Vv(r5, t, e) {
  this.x = r5, this.y = t, this.weight = e;
}
H$3(Vv, "GridNode");
Vv.prototype.toString = function() {
  return "[" + this.x + " " + this.y + "]";
};
Vv.prototype.getCost = function(r5) {
  return r5 && r5.x !== this.x && r5.y !== this.y ? this.weight * 1.41421 : this.weight;
};
Vv.prototype.isWall = function() {
  return this.weight === 0;
};
function E6(r5) {
  this.content = [], this.scoreFunction = r5;
}
H$3(E6, "BinaryHeap");
E6.prototype = { push: H$3(function(r5) {
  this.content.push(r5), this.sinkDown(this.content.length - 1);
}, "push"), pop: H$3(function() {
  var r5 = this.content[0], t = this.content.pop();
  return this.content.length > 0 && (this.content[0] = t, this.bubbleUp(0)), r5;
}, "pop"), remove: H$3(function(r5) {
  var t = this.content.indexOf(r5), e = this.content.pop();
  t !== this.content.length - 1 && (this.content[t] = e, this.scoreFunction(e) < this.scoreFunction(r5) ? this.sinkDown(t) : this.bubbleUp(t));
}, "remove"), size: H$3(function() {
  return this.content.length;
}, "size"), rescoreElement: H$3(function(r5) {
  this.sinkDown(this.content.indexOf(r5));
}, "rescoreElement"), sinkDown: H$3(function(r5) {
  for (var t = this.content[r5]; r5 > 0; ) {
    var e = (r5 + 1 >> 1) - 1, n4 = this.content[e];
    if (this.scoreFunction(t) < this.scoreFunction(n4)) this.content[e] = t, this.content[r5] = n4, r5 = e;
    else break;
  }
}, "sinkDown"), bubbleUp: H$3(function(r5) {
  for (var t = this.content.length, e = this.content[r5], n4 = this.scoreFunction(e); ; ) {
    var i = r5 + 1 << 1, a4 = i - 1, u5 = null, h;
    if (a4 < t) {
      var d = this.content[a4];
      h = this.scoreFunction(d), h < n4 && (u5 = a4);
    }
    if (i < t) {
      var m5 = this.content[i], v3 = this.scoreFunction(m5);
      v3 < (u5 === null ? n4 : h) && (u5 = i);
    }
    if (u5 !== null) this.content[r5] = this.content[u5], this.content[u5] = e, r5 = u5;
    else break;
  }
}, "bubbleUp") };
a();
a();
a();
a();
a();
a();
a();
a();
function FC() {
  this._ = null;
}
H$3(FC, "RedBlackTree");
function pd2(r5) {
  r5.U = r5.C = r5.L = r5.R = r5.P = r5.N = null;
}
H$3(pd2, "RedBlackNode");
FC.prototype = { constructor: FC, insert: H$3(function(r5, t) {
  var e, n4, i;
  if (r5) {
    if (t.P = r5, t.N = r5.N, r5.N && (r5.N.P = t), r5.N = t, r5.R) {
      for (r5 = r5.R; r5.L; ) r5 = r5.L;
      r5.L = t;
    } else r5.R = t;
    e = r5;
  } else this._ ? (r5 = O6(this._), t.P = null, t.N = r5, r5.P = r5.L = t, e = r5) : (t.P = t.N = null, this._ = t, e = null);
  for (t.L = t.R = null, t.U = e, t.C = true, r5 = t; e && e.C; ) n4 = e.U, e === n4.L ? (i = n4.R, i && i.C ? (e.C = i.C = false, n4.C = true, r5 = n4) : (r5 === e.R && (Dg2(this, e), r5 = e, e = r5.U), e.C = false, n4.C = true, Lg2(this, n4))) : (i = n4.L, i && i.C ? (e.C = i.C = false, n4.C = true, r5 = n4) : (r5 === e.L && (Lg2(this, e), r5 = e, e = r5.U), e.C = false, n4.C = true, Dg2(this, n4))), e = r5.U;
  this._.C = false;
}, "insert"), remove: H$3(function(r5) {
  r5.N && (r5.N.P = r5.P), r5.P && (r5.P.N = r5.N), r5.N = r5.P = null;
  var t = r5.U, e, n4 = r5.L, i = r5.R, a4, u5;
  if (n4 ? i ? a4 = O6(i) : a4 = n4 : a4 = i, t ? t.L === r5 ? t.L = a4 : t.R = a4 : this._ = a4, n4 && i ? (u5 = a4.C, a4.C = r5.C, a4.L = n4, n4.U = a4, a4 !== i ? (t = a4.U, a4.U = r5.U, r5 = a4.R, t.L = r5, a4.R = i, i.U = a4) : (a4.U = t, t = a4, r5 = a4.R)) : (u5 = r5.C, r5 = a4), r5 && (r5.U = t), !u5) {
    if (r5 && r5.C) {
      r5.C = false;
      return;
    }
    do {
      if (r5 === this._) break;
      if (r5 === t.L) {
        if (e = t.R, e.C && (e.C = false, t.C = true, Dg2(this, t), e = t.R), e.L && e.L.C || e.R && e.R.C) {
          (!e.R || !e.R.C) && (e.L.C = false, e.C = true, Lg2(this, e), e = t.R), e.C = t.C, t.C = e.R.C = false, Dg2(this, t), r5 = this._;
          break;
        }
      } else if (e = t.L, e.C && (e.C = false, t.C = true, Lg2(this, t), e = t.L), e.L && e.L.C || e.R && e.R.C) {
        (!e.L || !e.L.C) && (e.R.C = false, e.C = true, Dg2(this, e), e = t.L), e.C = t.C, t.C = e.L.C = false, Lg2(this, t), r5 = this._;
        break;
      }
      e.C = true, r5 = t, t = t.U;
    } while (!r5.C);
    r5 && (r5.C = false);
  }
}, "remove") };
function Dg2(r5, t) {
  var e = t, n4 = t.R, i = e.U;
  i ? i.L === e ? i.L = n4 : i.R = n4 : r5._ = n4, n4.U = i, e.U = n4, e.R = n4.L, e.R && (e.R.U = e), n4.L = e;
}
H$3(Dg2, "RedBlackRotateLeft");
function Lg2(r5, t) {
  var e = t, n4 = t.L, i = e.U;
  i ? i.L === e ? i.L = n4 : i.R = n4 : r5._ = n4, n4.U = i, e.U = n4, e.L = n4.R, e.L && (e.L.U = e), n4.R = e;
}
H$3(Lg2, "RedBlackRotateRight");
function O6(r5) {
  for (; r5.L; ) r5 = r5.L;
  return r5;
}
H$3(O6, "RedBlackFirst");
var BC = FC;
a();
a();
function hd2(r5, t, e, n4) {
  var i = [null, null], a4 = Mi.push(i) - 1;
  return i.left = r5, i.right = t, e && Ag2(i, r5, t, e), n4 && Ag2(i, t, r5, n4), xo[r5.index].halfedges.push(a4), xo[t.index].halfedges.push(a4), i;
}
H$3(hd2, "createEdge");
function fd2(r5, t, e) {
  var n4 = [t, e];
  return n4.left = r5, n4;
}
H$3(fd2, "createBorderEdge");
function Ag2(r5, t, e, n4) {
  !r5[0] && !r5[1] ? (r5[0] = n4, r5.left = t, r5.right = e) : r5.left === e ? r5[1] = n4 : r5[0] = n4;
}
H$3(Ag2, "setEdgeEnd");
function zF(r5, t, e, n4, i) {
  var a4 = r5[0], u5 = r5[1], h = a4[0], d = a4[1], m5 = u5[0], v3 = u5[1], x2 = 0, S4 = 1, I3 = m5 - h, w3 = v3 - d, E4;
  if (E4 = t - h, !(!I3 && E4 > 0)) {
    if (E4 /= I3, I3 < 0) {
      if (E4 < x2) return;
      E4 < S4 && (S4 = E4);
    } else if (I3 > 0) {
      if (E4 > S4) return;
      E4 > x2 && (x2 = E4);
    }
    if (E4 = n4 - h, !(!I3 && E4 < 0)) {
      if (E4 /= I3, I3 < 0) {
        if (E4 > S4) return;
        E4 > x2 && (x2 = E4);
      } else if (I3 > 0) {
        if (E4 < x2) return;
        E4 < S4 && (S4 = E4);
      }
      if (E4 = e - d, !(!w3 && E4 > 0)) {
        if (E4 /= w3, w3 < 0) {
          if (E4 < x2) return;
          E4 < S4 && (S4 = E4);
        } else if (w3 > 0) {
          if (E4 > S4) return;
          E4 > x2 && (x2 = E4);
        }
        if (E4 = i - d, !(!w3 && E4 < 0)) {
          if (E4 /= w3, w3 < 0) {
            if (E4 > S4) return;
            E4 > x2 && (x2 = E4);
          } else if (w3 > 0) {
            if (E4 < x2) return;
            E4 < S4 && (S4 = E4);
          }
          return !(x2 > 0) && !(S4 < 1) || (x2 > 0 && (r5[0] = [h + x2 * I3, d + x2 * w3]), S4 < 1 && (r5[1] = [h + S4 * I3, d + S4 * w3])), true;
        }
      }
    }
  }
}
H$3(zF, "clipEdge");
function HF(r5, t, e, n4, i) {
  var a4 = r5[1];
  if (a4) return true;
  var u5 = r5[0], h = r5.left, d = r5.right, m5 = h[0], v3 = h[1], x2 = d[0], S4 = d[1], I3 = (m5 + x2) / 2, w3 = (v3 + S4) / 2, E4, T3;
  if (S4 === v3) {
    if (I3 < t || I3 >= n4) return;
    if (m5 > x2) {
      if (!u5) u5 = [I3, e];
      else if (u5[1] >= i) return;
      a4 = [I3, i];
    } else {
      if (!u5) u5 = [I3, i];
      else if (u5[1] < e) return;
      a4 = [I3, e];
    }
  } else if (E4 = (m5 - x2) / (S4 - v3), T3 = w3 - E4 * I3, E4 < -1 || E4 > 1) if (m5 > x2) {
    if (!u5) u5 = [(e - T3) / E4, e];
    else if (u5[1] >= i) return;
    a4 = [(i - T3) / E4, i];
  } else {
    if (!u5) u5 = [(i - T3) / E4, i];
    else if (u5[1] < e) return;
    a4 = [(e - T3) / E4, e];
  }
  else if (v3 < S4) {
    if (!u5) u5 = [t, E4 * t + T3];
    else if (u5[0] >= n4) return;
    a4 = [n4, E4 * n4 + T3];
  } else {
    if (!u5) u5 = [n4, E4 * n4 + T3];
    else if (u5[0] < t) return;
    a4 = [t, E4 * t + T3];
  }
  return r5[0] = u5, r5[1] = a4, true;
}
H$3(HF, "connectEdge");
function D6(r5, t, e, n4) {
  for (var i = Mi.length, a4; i--; ) (!HF(a4 = Mi[i], r5, t, e, n4) || !zF(a4, r5, t, e, n4) || !(Math.abs(a4[0][0] - a4[1][0]) > Xr || Math.abs(a4[0][1] - a4[1][1]) > Xr)) && delete Mi[i];
}
H$3(D6, "clipEdges");
function L6(r5) {
  return xo[r5.index] = { site: r5, halfedges: [] };
}
H$3(L6, "createCell");
function XF(r5, t) {
  var e = r5.site, n4 = t.left, i = t.right;
  return e === i && (i = n4, n4 = e), i ? Math.atan2(i[1] - n4[1], i[0] - n4[0]) : (e === n4 ? (n4 = t[1], i = t[0]) : (n4 = t[0], i = t[1]), Math.atan2(n4[0] - i[0], i[1] - n4[1]));
}
H$3(XF, "cellHalfedgeAngle");
function GC(r5, t) {
  return t[+(t.left !== r5.site)];
}
H$3(GC, "cellHalfedgeStart");
function YF(r5, t) {
  return t[+(t.left === r5.site)];
}
H$3(YF, "cellHalfedgeEnd");
function A6() {
  for (var r5 = 0, t = xo.length, e, n4, i, a4; r5 < t; ++r5) if ((e = xo[r5]) && (a4 = (n4 = e.halfedges).length)) {
    var u5 = new Array(a4), h = new Array(a4);
    for (i = 0; i < a4; ++i) u5[i] = i, h[i] = XF(e, Mi[n4[i]]);
    for (u5.sort(function(d, m5) {
      return h[m5] - h[d];
    }), i = 0; i < a4; ++i) h[i] = n4[u5[i]];
    for (i = 0; i < a4; ++i) n4[i] = h[i];
  }
}
H$3(A6, "sortCellHalfedges");
function N6(r5, t, e, n4) {
  var i = xo.length, a4, u5, h, d, m5, v3, x2, S4, I3, w3, E4, T3, D4 = true;
  for (a4 = 0; a4 < i; ++a4) if (u5 = xo[a4]) {
    for (h = u5.site, m5 = u5.halfedges, d = m5.length; d--; ) Mi[m5[d]] || m5.splice(d, 1);
    for (d = 0, v3 = m5.length; d < v3; ) w3 = YF(u5, Mi[m5[d]]), E4 = w3[0], T3 = w3[1], x2 = GC(u5, Mi[m5[++d % v3]]), S4 = x2[0], I3 = x2[1], (Math.abs(E4 - S4) > Xr || Math.abs(T3 - I3) > Xr) && (m5.splice(d, 0, Mi.push(fd2(h, w3, Math.abs(E4 - r5) < Xr && n4 - T3 > Xr ? [r5, Math.abs(S4 - r5) < Xr ? I3 : n4] : Math.abs(T3 - n4) < Xr && e - E4 > Xr ? [Math.abs(I3 - n4) < Xr ? S4 : e, n4] : Math.abs(E4 - e) < Xr && T3 - t > Xr ? [e, Math.abs(S4 - e) < Xr ? I3 : t] : Math.abs(T3 - t) < Xr && E4 - r5 > Xr ? [Math.abs(I3 - t) < Xr ? S4 : r5, t] : null)) - 1), ++v3);
    v3 && (D4 = false);
  }
  if (D4) {
    var A3, L3, B3, j3 = 1 / 0;
    for (a4 = 0, D4 = null; a4 < i; ++a4) (u5 = xo[a4]) && (h = u5.site, A3 = h[0] - r5, L3 = h[1] - t, B3 = A3 * A3 + L3 * L3, B3 < j3 && (j3 = B3, D4 = u5));
    if (D4) {
      var W4 = [r5, t], $5 = [r5, n4], F3 = [e, n4], J4 = [e, t];
      D4.halfedges.push(Mi.push(fd2(h = D4.site, W4, $5)) - 1, Mi.push(fd2(h, $5, F3)) - 1, Mi.push(fd2(h, F3, J4)) - 1, Mi.push(fd2(h, J4, W4)) - 1);
    }
  }
  for (a4 = 0; a4 < i; ++a4) (u5 = xo[a4]) && (u5.halfedges.length || delete xo[a4]);
}
H$3(N6, "clipCells");
a();
var k6 = [], jv;
function qF() {
  pd2(this), this.x = this.y = this.arc = this.site = this.cy = null;
}
H$3(qF, "Circle");
function Tp2(r5) {
  var t = r5.P, e = r5.N;
  if (!(!t || !e)) {
    var n4 = t.site, i = r5.site, a4 = e.site;
    if (n4 !== a4) {
      var u5 = i[0], h = i[1], d = n4[0] - u5, m5 = n4[1] - h, v3 = a4[0] - u5, x2 = a4[1] - h, S4 = 2 * (d * x2 - m5 * v3);
      if (!(S4 >= -1e-12)) {
        var I3 = d * d + m5 * m5, w3 = v3 * v3 + x2 * x2, E4 = (x2 * I3 - m5 * w3) / S4, T3 = (d * w3 - v3 * I3) / S4, D4 = k6.pop() || new qF();
        D4.arc = r5, D4.site = i, D4.x = E4 + u5, D4.y = (D4.cy = T3 + h) + Math.sqrt(E4 * E4 + T3 * T3), r5.circle = D4;
        for (var A3 = null, L3 = dd2._; L3; ) if (D4.y < L3.y || D4.y === L3.y && D4.x <= L3.x) if (L3.L) L3 = L3.L;
        else {
          A3 = L3.P;
          break;
        }
        else if (L3.R) L3 = L3.R;
        else {
          A3 = L3;
          break;
        }
        dd2.insert(A3, D4), A3 || (jv = D4);
      }
    }
  }
}
H$3(Tp2, "attachCircle");
function wp(r5) {
  var t = r5.circle;
  t && (t.P || (jv = t.N), dd2.remove(t), k6.push(t), pd2(t), r5.circle = null);
}
H$3(wp, "detachCircle");
var B6 = [];
function WF() {
  pd2(this), this.edge = this.site = this.circle = null;
}
H$3(WF, "Beach");
function F6(r5) {
  var t = B6.pop() || new WF();
  return t.site = r5, t;
}
H$3(F6, "createBeach");
function VC(r5) {
  wp(r5), Pp.remove(r5), B6.push(r5), pd2(r5);
}
H$3(VC, "detachBeach");
function G6(r5) {
  var t = r5.circle, e = t.x, n4 = t.cy, i = [e, n4], a4 = r5.P, u5 = r5.N, h = [r5];
  VC(r5);
  for (var d = a4; d.circle && Math.abs(e - d.circle.x) < Xr && Math.abs(n4 - d.circle.cy) < Xr; ) a4 = d.P, h.unshift(d), VC(d), d = a4;
  h.unshift(d), wp(d);
  for (var m5 = u5; m5.circle && Math.abs(e - m5.circle.x) < Xr && Math.abs(n4 - m5.circle.cy) < Xr; ) u5 = m5.N, h.push(m5), VC(m5), m5 = u5;
  h.push(m5), wp(m5);
  var v3 = h.length, x2;
  for (x2 = 1; x2 < v3; ++x2) m5 = h[x2], d = h[x2 - 1], Ag2(m5.edge, d.site, m5.site, i);
  d = h[0], m5 = h[v3 - 1], m5.edge = hd2(d.site, m5.site, null, i), Tp2(d), Tp2(m5);
}
H$3(G6, "removeBeach");
function V6(r5) {
  for (var t = r5[0], e = r5[1], n4, i, a4, u5, h = Pp._; h; ) if (a4 = j6(h, e) - t, a4 > Xr) h = h.L;
  else if (u5 = t - ZF(h, e), u5 > Xr) {
    if (!h.R) {
      n4 = h;
      break;
    }
    h = h.R;
  } else {
    a4 > -Xr ? (n4 = h.P, i = h) : u5 > -Xr ? (n4 = h, i = h.N) : n4 = i = h;
    break;
  }
  L6(r5);
  var d = F6(r5);
  if (Pp.insert(n4, d), !(!n4 && !i)) {
    if (n4 === i) {
      wp(n4), i = F6(n4.site), Pp.insert(d, i), d.edge = i.edge = hd2(n4.site, d.site), Tp2(n4), Tp2(i);
      return;
    }
    if (!i) {
      d.edge = hd2(n4.site, d.site);
      return;
    }
    wp(n4), wp(i);
    var m5 = n4.site, v3 = m5[0], x2 = m5[1], S4 = r5[0] - v3, I3 = r5[1] - x2, w3 = i.site, E4 = w3[0] - v3, T3 = w3[1] - x2, D4 = 2 * (S4 * T3 - I3 * E4), A3 = S4 * S4 + I3 * I3, L3 = E4 * E4 + T3 * T3, B3 = [(T3 * A3 - I3 * L3) / D4 + v3, (S4 * L3 - E4 * A3) / D4 + x2];
    Ag2(i.edge, m5, w3, B3), d.edge = hd2(m5, r5, null, B3), i.edge = hd2(r5, w3, null, B3), Tp2(n4), Tp2(i);
  }
}
H$3(V6, "addBeach");
function j6(r5, t) {
  var e = r5.site, n4 = e[0], i = e[1], a4 = i - t;
  if (!a4) return n4;
  var u5 = r5.P;
  if (!u5) return -1 / 0;
  e = u5.site;
  var h = e[0], d = e[1], m5 = d - t;
  if (!m5) return h;
  var v3 = h - n4, x2 = 1 / a4 - 1 / m5, S4 = v3 / m5;
  return x2 ? (-S4 + Math.sqrt(S4 * S4 - 2 * x2 * (v3 * v3 / (-2 * m5) - d + m5 / 2 + i - a4 / 2))) / x2 + n4 : (n4 + h) / 2;
}
H$3(j6, "leftBreakPoint");
function ZF(r5, t) {
  var e = r5.N;
  if (e) return j6(e, t);
  var n4 = r5.site;
  return n4[1] === t ? n4[0] : 1 / 0;
}
H$3(ZF, "rightBreakPoint");
var Xr = 1e-6, Pp, xo, dd2, Mi;
function $F(r5, t, e) {
  return (r5[0] - e[0]) * (t[1] - r5[1]) - (r5[0] - t[0]) * (e[1] - r5[1]);
}
H$3($F, "triangleArea");
function JF(r5, t) {
  return t[1] - r5[1] || t[0] - r5[0];
}
H$3(JF, "lexicographic");
function Uv(r5, t) {
  var e = r5.sort(JF).pop(), n4, i, a4;
  for (Mi = [], xo = new Array(r5.length), Pp = new BC(), dd2 = new BC(); ; ) if (a4 = jv, e && (!a4 || e[1] < a4.y || e[1] === a4.y && e[0] < a4.x)) (e[0] !== n4 || e[1] !== i) && (V6(e), n4 = e[0], i = e[1]), e = r5.pop();
  else if (a4) G6(a4.arc);
  else break;
  if (A6(), t) {
    var u5 = +t[0][0], h = +t[0][1], d = +t[1][0], m5 = +t[1][1];
    D6(u5, h, d, m5), N6(u5, h, d, m5);
  }
  this.edges = Mi, this.cells = xo, Pp = dd2 = Mi = xo = null;
}
H$3(Uv, "Diagram");
Uv.prototype = { constructor: Uv, polygons: H$3(function() {
  var r5 = this.edges;
  return this.cells.map(function(t) {
    var e = t.halfedges.map(function(n4) {
      return GC(t, r5[n4]);
    });
    return e.data = t.site.data, e;
  });
}, "polygons"), triangles: H$3(function() {
  var r5 = [], t = this.edges;
  return this.cells.forEach(function(e, n4) {
    if (h = (a4 = e.halfedges).length) for (var i = e.site, a4, u5 = -1, h, d, m5 = t[a4[h - 1]], v3 = m5.left === i ? m5.right : m5.left; ++u5 < h; ) d = v3, m5 = t[a4[u5]], v3 = m5.left === i ? m5.right : m5.left, d && v3 && n4 < d.index && n4 < v3.index && $F(i, d, v3) < 0 && r5.push([i.data, d.data, v3.data]);
  }), r5;
}, "triangles"), links: H$3(function() {
  return this.edges.filter(function(r5) {
    return r5.right;
  }).map(function(r5) {
    return { source: r5.left.data, target: r5.right.data };
  });
}, "links"), find: H$3(function(r5, t, e) {
  for (var n4 = this, i, a4 = n4._found || 0, u5 = n4.cells.length, h; !(h = n4.cells[a4]); ) if (++a4 >= u5) return null;
  var d = r5 - h.site[0], m5 = t - h.site[1], v3 = d * d + m5 * m5;
  do
    h = n4.cells[i = a4], a4 = null, h.halfedges.forEach(function(x2) {
      var S4 = n4.edges[x2], I3 = S4.left;
      if (!((I3 === h.site || !I3) && !(I3 = S4.right))) {
        var w3 = r5 - I3[0], E4 = t - I3[1], T3 = w3 * w3 + E4 * E4;
        T3 < v3 && (v3 = T3, a4 = I3.index);
      }
    });
  while (a4 !== null);
  return n4._found = i, e == null || v3 <= e * e ? h.site : null;
}, "find") };
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
N$2(md2(), 1);
a();
N$2(X6(), 1);
a();
a();
a();
function _o() {
  return new Xv();
}
H$3(_o, "default");
function Xv() {
  this.reset();
}
H$3(Xv, "Adder");
Xv.prototype = { constructor: Xv, reset: H$3(function() {
  this.s = this.t = 0;
}, "reset"), add: H$3(function(r5) {
  Y6(Hv, r5, this.t), Y6(this, Hv.s, this.s), this.s ? this.t += Hv.t : this.s = Hv.t;
}, "add"), valueOf: H$3(function() {
  return this.s;
}, "valueOf") };
var Hv = new Xv();
function Y6(r5, t, e) {
  var n4 = r5.s = t + e, i = n4 - t, a4 = n4 - i;
  r5.t = t - a4 + (e - i);
}
H$3(Y6, "add");
a();
var Pr = 1e-6;
var Br = Math.PI, li = Br / 2, Yv = Br / 4, Ka = Br * 2, Bo = Br / 180, An = Math.abs, sa = Math.atan, Go = Math.atan2, gr = Math.cos;
var qv = Math.exp;
var Ng2 = Math.log;
var Me$1 = Math.sin;
var zi2 = Math.sqrt, kg2 = Math.tan;
function zC(r5) {
  return r5 > 1 ? 0 : r5 < -1 ? Br : Math.acos(r5);
}
H$3(zC, "acos");
function Co(r5) {
  return r5 > 1 ? li : r5 < -1 ? -li : Math.asin(r5);
}
H$3(Co, "asin");
a();
function aa() {
}
H$3(aa, "noop");
a();
_o();
_o();
a();
a();
function Op(r5) {
  var t = r5[0], e = r5[1], n4 = gr(e);
  return [n4 * gr(t), n4 * Me$1(t), Me$1(e)];
}
H$3(Op, "cartesian");
function Rg2(r5, t) {
  return [r5[1] * t[2] - r5[2] * t[1], r5[2] * t[0] - r5[0] * t[2], r5[0] * t[1] - r5[1] * t[0]];
}
H$3(Rg2, "cartesianCross");
function Fg(r5) {
  var t = zi2(r5[0] * r5[0] + r5[1] * r5[1] + r5[2] * r5[2]);
  r5[0] /= t, r5[1] /= t, r5[2] /= t;
}
H$3(Fg, "cartesianNormalizeInPlace");
_o();
a();
a();
a();
a();
a();
function W6(r5, t) {
  return [r5 > Br ? r5 - Ka : r5 < -Br ? r5 + Ka : r5, t];
}
H$3(W6, "rotationIdentity");
W6.invert = W6;
a();
a();
function Wv() {
  var r5 = [], t;
  return { point: H$3(function(e, n4) {
    t.push([e, n4]);
  }, "point"), lineStart: H$3(function() {
    r5.push(t = []);
  }, "lineStart"), lineEnd: aa, rejoin: H$3(function() {
    r5.length > 1 && r5.push(r5.pop().concat(r5.shift()));
  }, "rejoin"), result: H$3(function() {
    var e = r5;
    return r5 = [], t = null, e;
  }, "result") };
}
H$3(Wv, "default");
a();
a();
a();
function Zv(r5, t) {
  return An(r5[0] - t[0]) < Pr && An(r5[1] - t[1]) < Pr;
}
H$3(Zv, "default");
function $v(r5, t, e, n4) {
  this.x = r5, this.z = t, this.o = e, this.e = n4, this.v = false, this.n = this.p = null;
}
H$3($v, "Intersection");
function Jv(r5, t, e, n4, i) {
  var a4 = [], u5 = [], h, d;
  if (r5.forEach(function(w3) {
    if (!((E4 = w3.length - 1) <= 0)) {
      var E4, T3 = w3[0], D4 = w3[E4], A3;
      if (Zv(T3, D4)) {
        for (i.lineStart(), h = 0; h < E4; ++h) i.point((T3 = w3[h])[0], T3[1]);
        i.lineEnd();
        return;
      }
      a4.push(A3 = new $v(T3, w3, null, true)), u5.push(A3.o = new $v(T3, null, A3, false)), a4.push(A3 = new $v(D4, w3, null, false)), u5.push(A3.o = new $v(D4, null, A3, true));
    }
  }), !!a4.length) {
    for (u5.sort(t), Z6(a4), Z6(u5), h = 0, d = u5.length; h < d; ++h) u5[h].e = e = !e;
    for (var m5 = a4[0], v3, x2; ; ) {
      for (var S4 = m5, I3 = true; S4.v; ) if ((S4 = S4.n) === m5) return;
      v3 = S4.z, i.lineStart();
      do {
        if (S4.v = S4.o.v = true, S4.e) {
          if (I3) for (h = 0, d = v3.length; h < d; ++h) i.point((x2 = v3[h])[0], x2[1]);
          else n4(S4.x, S4.n.x, 1, i);
          S4 = S4.n;
        } else {
          if (I3) for (v3 = S4.p.z, h = v3.length - 1; h >= 0; --h) i.point((x2 = v3[h])[0], x2[1]);
          else n4(S4.x, S4.p.x, -1, i);
          S4 = S4.p;
        }
        S4 = S4.o, v3 = S4.z, I3 = !I3;
      } while (!S4.v);
      i.lineEnd();
    }
  }
}
H$3(Jv, "default");
function Z6(r5) {
  if (t = r5.length) {
    for (var t, e = 0, n4 = r5[0], i; ++e < t; ) n4.n = i = r5[e], i.p = n4, n4 = i;
    n4.n = i = r5[0], i.p = n4;
  }
}
H$3(Z6, "link");
a();
a();
a();
function Zl(r5, t) {
  return r5 < t ? -1 : r5 > t ? 1 : r5 >= t ? 0 : NaN;
}
H$3(Zl, "default");
a();
function Kv(r5) {
  return r5.length === 1 && (r5 = uB(r5)), { left: H$3(function(t, e, n4, i) {
    for (n4 == null && (n4 = 0), i == null && (i = t.length); n4 < i; ) {
      var a4 = n4 + i >>> 1;
      r5(t[a4], e) < 0 ? n4 = a4 + 1 : i = a4;
    }
    return n4;
  }, "left"), right: H$3(function(t, e, n4, i) {
    for (n4 == null && (n4 = 0), i == null && (i = t.length); n4 < i; ) {
      var a4 = n4 + i >>> 1;
      r5(t[a4], e) > 0 ? i = a4 : n4 = a4 + 1;
    }
    return n4;
  }, "right") };
}
H$3(Kv, "default");
function uB(r5) {
  return function(t, e) {
    return Zl(r5(t), e);
  };
}
H$3(uB, "ascendingComparator");
var $6 = Kv(Zl);
$6.right;
$6.left;
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
a();
function Bg2(r5) {
  for (var t = r5.length, e, n4 = -1, i = 0, a4, u5; ++n4 < t; ) i += r5[n4].length;
  for (a4 = new Array(i); --t >= 0; ) for (u5 = r5[t], e = u5.length; --e >= 0; ) a4[--i] = u5[e];
  return a4;
}
H$3(Bg2, "default");
a();
a();
a();
a();
a();
a();
a();
a();
a();
var HC = _o();
function tb(r5, t) {
  var e = t[0], n4 = t[1], i = [Me$1(e), -gr(e), 0], a4 = 0, u5 = 0;
  HC.reset();
  for (var h = 0, d = r5.length; h < d; ++h) if (v3 = (m5 = r5[h]).length) for (var m5, v3, x2 = m5[v3 - 1], S4 = x2[0], I3 = x2[1] / 2 + Yv, w3 = Me$1(I3), E4 = gr(I3), T3 = 0; T3 < v3; ++T3, S4 = A3, w3 = B3, E4 = j3, x2 = D4) {
    var D4 = m5[T3], A3 = D4[0], L3 = D4[1] / 2 + Yv, B3 = Me$1(L3), j3 = gr(L3), W4 = A3 - S4, $5 = W4 >= 0 ? 1 : -1, F3 = $5 * W4, J4 = F3 > Br, ot2 = w3 * B3;
    if (HC.add(Go(ot2 * $5 * Me$1(F3), E4 * j3 + ot2 * gr(F3))), a4 += J4 ? W4 + $5 * Ka : W4, J4 ^ S4 >= e ^ A3 >= e) {
      var K4 = Rg2(Op(x2), Op(D4));
      Fg(K4);
      var H5 = Rg2(i, K4);
      Fg(H5);
      var _t2 = (J4 ^ W4 >= 0 ? -1 : 1) * Co(H5[2]);
      (n4 > _t2 || n4 === _t2 && (K4[0] || K4[1])) && (u5 += J4 ^ W4 >= 0 ? 1 : -1);
    }
  }
  return (a4 < -Pr || a4 < Pr && HC < -Pr) ^ u5 & 1;
}
H$3(tb, "default");
a();
a();
_o();
a();
a();
a();
a();
a();
_o();
_o();
a();
a();
a();
function XC(r5) {
  this._context = r5;
}
H$3(XC, "PathContext");
XC.prototype = { _radius: 4.5, pointRadius: H$3(function(r5) {
  return this._radius = r5, this;
}, "pointRadius"), polygonStart: H$3(function() {
  this._line = 0;
}, "polygonStart"), polygonEnd: H$3(function() {
  this._line = NaN;
}, "polygonEnd"), lineStart: H$3(function() {
  this._point = 0;
}, "lineStart"), lineEnd: H$3(function() {
  this._line === 0 && this._context.closePath(), this._point = NaN;
}, "lineEnd"), point: H$3(function(r5, t) {
  switch (this._point) {
    case 0: {
      this._context.moveTo(r5, t), this._point = 1;
      break;
    }
    case 1: {
      this._context.lineTo(r5, t);
      break;
    }
    default: {
      this._context.moveTo(r5 + this._radius, t), this._context.arc(r5, t, this._radius, 0, Ka);
      break;
    }
  }
}, "point"), result: aa };
a();
_o();
a();
function YC() {
  this._string = [];
}
H$3(YC, "PathString");
YC.prototype = { _radius: 4.5, _circle: t7(4.5), pointRadius: H$3(function(r5) {
  return (r5 = +r5) !== this._radius && (this._radius = r5, this._circle = null), this;
}, "pointRadius"), polygonStart: H$3(function() {
  this._line = 0;
}, "polygonStart"), polygonEnd: H$3(function() {
  this._line = NaN;
}, "polygonEnd"), lineStart: H$3(function() {
  this._point = 0;
}, "lineStart"), lineEnd: H$3(function() {
  this._line === 0 && this._string.push("Z"), this._point = NaN;
}, "lineEnd"), point: H$3(function(r5, t) {
  switch (this._point) {
    case 0: {
      this._string.push("M", r5, ",", t), this._point = 1;
      break;
    }
    case 1: {
      this._string.push("L", r5, ",", t);
      break;
    }
    default: {
      this._circle == null && (this._circle = t7(this._radius)), this._string.push("M", r5, ",", t, this._circle);
      break;
    }
  }
}, "point"), result: H$3(function() {
  if (this._string.length) {
    var r5 = this._string.join("");
    return this._string = [], r5;
  } else return null;
}, "result") };
function t7(r5) {
  return "m0," + r5 + "a" + r5 + "," + r5 + " 0 1,1 0," + -2 * r5 + "a" + r5 + "," + r5 + " 0 1,1 0," + 2 * r5 + "z";
}
H$3(t7, "circle");
a();
a();
a();
a();
a();
a();
function eb(r5, t, e, n4) {
  return function(i, a4) {
    var u5 = t(a4), h = i.invert(n4[0], n4[1]), d = Wv(), m5 = t(d), v3 = false, x2, S4, I3, w3 = { point: E4, lineStart: D4, lineEnd: A3, polygonStart: H$3(function() {
      w3.point = L3, w3.lineStart = B3, w3.lineEnd = j3, S4 = [], x2 = [];
    }, "polygonStart"), polygonEnd: H$3(function() {
      w3.point = E4, w3.lineStart = D4, w3.lineEnd = A3, S4 = Bg2(S4);
      var W4 = tb(x2, h);
      S4.length ? (v3 || (a4.polygonStart(), v3 = true), Jv(S4, PB, W4, e, a4)) : W4 && (v3 || (a4.polygonStart(), v3 = true), a4.lineStart(), e(null, null, 1, a4), a4.lineEnd()), v3 && (a4.polygonEnd(), v3 = false), S4 = x2 = null;
    }, "polygonEnd"), sphere: H$3(function() {
      a4.polygonStart(), a4.lineStart(), e(null, null, 1, a4), a4.lineEnd(), a4.polygonEnd();
    }, "sphere") };
    function E4(W4, $5) {
      var F3 = i(W4, $5);
      r5(W4 = F3[0], $5 = F3[1]) && a4.point(W4, $5);
    }
    H$3(E4, "point");
    function T3(W4, $5) {
      var F3 = i(W4, $5);
      u5.point(F3[0], F3[1]);
    }
    H$3(T3, "pointLine");
    function D4() {
      w3.point = T3, u5.lineStart();
    }
    H$3(D4, "lineStart");
    function A3() {
      w3.point = E4, u5.lineEnd();
    }
    H$3(A3, "lineEnd");
    function L3(W4, $5) {
      I3.push([W4, $5]);
      var F3 = i(W4, $5);
      m5.point(F3[0], F3[1]);
    }
    H$3(L3, "pointRing");
    function B3() {
      m5.lineStart(), I3 = [];
    }
    H$3(B3, "ringStart");
    function j3() {
      L3(I3[0][0], I3[0][1]), m5.lineEnd();
      var W4 = m5.clean(), $5 = d.result(), F3, J4 = $5.length, ot2, K4, H5;
      if (I3.pop(), x2.push(I3), I3 = null, !!J4) {
        if (W4 & 1) {
          if (K4 = $5[0], (ot2 = K4.length - 1) > 0) {
            for (v3 || (a4.polygonStart(), v3 = true), a4.lineStart(), F3 = 0; F3 < ot2; ++F3) a4.point((H5 = K4[F3])[0], H5[1]);
            a4.lineEnd();
          }
          return;
        }
        J4 > 1 && W4 & 2 && $5.push($5.pop().concat($5.shift())), S4.push($5.filter(wB));
      }
    }
    return H$3(j3, "ringEnd"), w3;
  };
}
H$3(eb, "default");
function wB(r5) {
  return r5.length > 1;
}
H$3(wB, "validSegment");
function PB(r5, t) {
  return ((r5 = r5.x)[0] < 0 ? r5[1] - li - Pr : li - r5[1]) - ((t = t.x)[0] < 0 ? t[1] - li - Pr : li - t[1]);
}
H$3(PB, "compareIntersection");
function OB(r5) {
  var t = NaN, e = NaN, n4 = NaN, i;
  return { lineStart: H$3(function() {
    r5.lineStart(), i = 1;
  }, "lineStart"), point: H$3(function(a4, u5) {
    var h = a4 > 0 ? Br : -Br, d = An(a4 - t);
    An(d - Br) < Pr ? (r5.point(t, e = (e + u5) / 2 > 0 ? li : -li), r5.point(n4, e), r5.lineEnd(), r5.lineStart(), r5.point(h, e), r5.point(a4, e), i = 0) : n4 !== h && d >= Br && (An(t - n4) < Pr && (t -= n4 * Pr), An(a4 - h) < Pr && (a4 -= h * Pr), e = DB(t, e, a4, u5), r5.point(n4, e), r5.lineEnd(), r5.lineStart(), r5.point(h, e), i = 0), r5.point(t = a4, e = u5), n4 = h;
  }, "point"), lineEnd: H$3(function() {
    r5.lineEnd(), t = e = NaN;
  }, "lineEnd"), clean: H$3(function() {
    return 2 - i;
  }, "clean") };
}
H$3(OB, "clipAntimeridianLine");
function DB(r5, t, e, n4) {
  var i, a4, u5 = Me$1(r5 - e);
  return An(u5) > Pr ? sa((Me$1(t) * (a4 = gr(n4)) * Me$1(e) - Me$1(n4) * (i = gr(t)) * Me$1(r5)) / (i * a4 * u5)) : (t + n4) / 2;
}
H$3(DB, "clipAntimeridianIntersect");
function LB(r5, t, e, n4) {
  var i;
  if (r5 == null) i = e * li, n4.point(-Br, i), n4.point(0, i), n4.point(Br, i), n4.point(Br, 0), n4.point(Br, -i), n4.point(0, -i), n4.point(-Br, -i), n4.point(-Br, 0), n4.point(-Br, i);
  else if (An(r5[0] - t[0]) > Pr) {
    var a4 = r5[0] < t[0] ? Br : -Br;
    i = e * a4 / 2, n4.point(-a4, i), n4.point(0, i), n4.point(a4, i);
  } else n4.point(t[0], t[1]);
}
H$3(LB, "clipAntimeridianInterpolate");
a();
a();
function rb(r5) {
  return function(t) {
    var e = new qC();
    for (var n4 in r5) e[n4] = r5[n4];
    return e.stream = t, e;
  };
}
H$3(rb, "transformer");
function qC() {
}
H$3(qC, "TransformStream");
qC.prototype = { constructor: qC, point: H$3(function(r5, t) {
  this.stream.point(r5, t);
}, "point"), sphere: H$3(function() {
  this.stream.sphere();
}, "sphere"), lineStart: H$3(function() {
  this.stream.lineStart();
}, "lineStart"), lineEnd: H$3(function() {
  this.stream.lineEnd();
}, "lineEnd"), polygonStart: H$3(function() {
  this.stream.polygonStart();
}, "polygonStart"), polygonEnd: H$3(function() {
  this.stream.polygonEnd();
}, "polygonEnd") };
a();
a();
rb({ point: H$3(function(r5, t) {
  this.stream.point(r5 * Bo, t * Bo);
}, "point") });
a();
a();
a();
a();
function nb(r5) {
  return function(t, e) {
    var n4 = gr(t), i = gr(e), a4 = r5(n4 * i);
    return [a4 * i * Me$1(t), a4 * Me$1(e)];
  };
}
H$3(nb, "azimuthalRaw");
function Qa(r5) {
  return function(t, e) {
    var n4 = zi2(t * t + e * e), i = r5(n4), a4 = Me$1(i), u5 = gr(i);
    return [Go(t * a4, n4 * u5), Co(n4 && e * a4 / n4)];
  };
}
H$3(Qa, "azimuthalInvert");
var a7 = nb(function(r5) {
  return zi2(2 / (1 + r5));
});
a7.invert = Qa(function(r5) {
  return 2 * Co(r5 / 2);
});
a();
var l7 = nb(function(r5) {
  return (r5 = zC(r5)) && r5 / Me$1(r5);
});
l7.invert = Qa(function(r5) {
  return r5;
});
a();
a();
function WC(r5, t) {
  return [r5, Ng2(kg2((li + t) / 2))];
}
H$3(WC, "mercatorRaw");
WC.invert = function(r5, t) {
  return [r5, 2 * sa(qv(t)) - li];
};
a();
a();
function ib(r5, t) {
  return [r5, t];
}
H$3(ib, "equirectangularRaw");
ib.invert = ib;
a();
function u7(r5, t) {
  var e = gr(t), n4 = gr(r5) * e;
  return [e * Me$1(r5) / n4, Me$1(t) / n4];
}
H$3(u7, "gnomonicRaw");
u7.invert = Qa(sa);
a();
a();
function c7(r5, t) {
  var e = t * t, n4 = e * e;
  return [r5 * (0.8707 - 0.131979 * e + n4 * (-0.013791 + n4 * (3971e-6 * e - 1529e-6 * n4))), t * (1.007226 + e * (0.015085 + n4 * (-0.044475 + 0.028874 * e - 5916e-6 * n4)))];
}
H$3(c7, "naturalEarth1Raw");
c7.invert = function(r5, t) {
  var e = t, n4 = 25, i;
  do {
    var a4 = e * e, u5 = a4 * a4;
    e -= i = (e * (1.007226 + a4 * (0.015085 + u5 * (-0.044475 + 0.028874 * a4 - 5916e-6 * u5))) - t) / (1.007226 + a4 * (0.015085 * 3 + u5 * (-0.044475 * 7 + 0.028874 * 9 * a4 - 5916e-6 * 11 * u5)));
  } while (An(i) > Pr && --n4 > 0);
  return [r5 / (0.8707 + (a4 = e * e) * (-0.131979 + a4 * (-0.013791 + a4 * a4 * a4 * (3971e-6 - 1529e-6 * a4)))), e];
};
a();
function p7(r5, t) {
  return [gr(t) * Me$1(r5), Me$1(t)];
}
H$3(p7, "orthographicRaw");
p7.invert = Qa(Co);
a();
function h7(r5, t) {
  var e = gr(t), n4 = 1 + gr(r5) * e;
  return [e * Me$1(r5) / n4, Me$1(t) / n4];
}
H$3(h7, "stereographicRaw");
h7.invert = Qa(function(r5) {
  return 2 * sa(r5);
});
a();
function f7(r5, t) {
  return [Ng2(kg2((li + t) / 2)), -r5];
}
H$3(f7, "transverseMercatorRaw");
f7.invert = function(r5, t) {
  return [-t, 2 * sa(qv(r5)) - li];
};
a();
N$2(md2(), 1);
a();
N$2(md2(), 1);
a();
N$2(md2(), 1);
a();
a();
N$2(md2(), 1);
a();
a();
a();
a();
function $C(r5) {
  var i, a4, u5, h, d, m5;
  let t = ((a4 = (i = r5.enterprise) == null ? void 0 : i.locations) == null ? void 0 : a4.reduce((v3, x2) => (v3[x2.id] = x2, v3), {})) || {};
  for (let v3 of ((u5 = r5.enterprise) == null ? void 0 : u5.locationInstances) || []) t[v3.id] = v3;
  let e = {};
  for (let v3 of r5["floorstack.json"] || []) e[v3.id] = v3;
  let n4 = {};
  for (let v3 of ((h = r5["floor.geojson"]) == null ? void 0 : h.features) || []) v3.properties && v3.properties.id && (n4[v3.properties.id] = v3.properties);
  return { type: "downloaded", data: r5, optimized: { "enterprise-location": t, "enterprise-category": ((m5 = (d = r5.enterprise) == null ? void 0 : d.categories) == null ? void 0 : m5.reduce((v3, x2) => (v3[x2.id] = x2, v3), {})) || {}, "floor-stack": e, floor: n4 } };
}
H$3($C, "parseLocalePackToLanguagePack");
function m7(r5) {
  return /^https?:\/\/cdn\.mappedin\.com/.test(r5);
}
H$3(m7, "isMappedinCdnUrl");
function g7(r5) {
  let t = r5.split("?")[1];
  return !!(t != null && t.includes("sv="));
}
H$3(g7, "hasSasToken");
function Ti(r5, t) {
  var n4;
  let e = ((n4 = r5 == null ? void 0 : r5.properties) == null ? void 0 : n4.id) || "unknown";
  if (r5.geometry == null) return B.error('Cannot get the center coordinate for "'.concat(e, '" because it has no geometry.')), new ve2({ latitude: 0, longitude: 0, floorId: t });
  try {
    if (r5.geometry.type === "LineString") {
      let [[i, a4], [u5, h]] = r5.geometry.coordinates, d = (i + u5) / 2, m5 = (a4 + h) / 2;
      return new ve2({ latitude: m5, longitude: d, floorId: t });
    } else if (r5.geometry.type === "Point") {
      let [i, a4] = r5.geometry.coordinates;
      return new ve2({ latitude: a4, longitude: i, floorId: t });
    } else if (r5.geometry.type === "Polygon") {
      let i = r5;
      if (i.properties.center != null) {
        let [a4, u5] = i.properties.center;
        return new ve2({ latitude: u5, longitude: a4, floorId: t });
      }
    }
  } catch (i) {
  }
  try {
    let [i, a4] = qa(r5).geometry.coordinates;
    return new ve2({ latitude: a4, longitude: i, floorId: t });
  } catch (i) {
    return B.error('Failed to get center coordinate for "'.concat(e, '" ').concat(i instanceof Error ? i.stack : "")), new ve2({ latitude: 0, longitude: 0, floorId: t });
  }
}
H$3(Ti, "getCenterCoordinate");
var tl, So, Lp, pc, Dp = class Dp2 extends si {
  constructor(e, n4) {
    super(n4.mvfData.properties.id);
    O(this, "__type", Dp2.__type);
    Q$3(this, tl);
    Q$3(this, So, {});
    Q$3(this, Lp);
    Q$3(this, pc);
    R$1(this, tl, e), R$1(this, Lp, n4.floorId), R$1(this, pc, n4.mvfData);
  }
  static is(e) {
    return e.__type === Dp2.__type;
  }
  get locations() {
    return P(this, So).locations ? P(this, So).locations : (P(this, So).locations = (P(this, tl).locationIdsByNodeId[this.id] || []).map((e) => P(this, tl).getById("enterprise-location", e)).filter(Boolean), P(this, So).locations);
  }
  get space() {
    var e;
    return P(this, tl).getById("space", (e = P(this, tl).spaceIdsByNodeId[this.id]) == null ? void 0 : e[0]);
  }
  get floor() {
    let e = P(this, tl).getById("floor", P(this, Lp));
    if (e == null) throw new Error("Floor ".concat(P(this, Lp), " not found!"));
    return e;
  }
  get coordinate() {
    return P(this, So).coordinate == null && (P(this, So).coordinate = Ti(P(this, pc), P(this, Lp))), P(this, So).coordinate;
  }
  get externalId() {
    var e;
    return (e = P(this, pc).properties.externalId) != null ? e : "";
  }
  get neighbors() {
    if (P(this, So).neighbours == null) {
      let e = P(this, pc).properties.neighbors.map((n4) => {
        let i = P(this, tl).getById("node", n4.id);
        if (i == null) throw new Error("Node ".concat(n4.id, " not found!"));
        return i;
      });
      P(this, So).neighbours = e;
    }
    return P(this, So).neighbours;
  }
  get geoJSON() {
    return G$1(F$1({}, P(this, pc)), { properties: null });
  }
  get focusTarget() {
    return this.coordinate;
  }
  get anchorTarget() {
    return this.coordinate;
  }
  toJSON() {
    return { __type: Dp2.__type, id: this.id, floor: this.floor.id, coordinate: this.coordinate.toJSON(), neighbors: this.neighbors.map((e) => e.id) };
  }
  destroy() {
    for (let e of Object.keys(P(this, So))) delete P(this, So)[e];
  }
};
tl = /* @__PURE__ */ new WeakMap(), So = /* @__PURE__ */ new WeakMap(), Lp = /* @__PURE__ */ new WeakMap(), pc = /* @__PURE__ */ new WeakMap(), H$3(Dp, "Node"), O(Dp, "__type", "node");
var JC = Dp, $l = JC;
a();
a();
var Ap2, KC = class KC2 {
  constructor(t, e) {
    O(this, "id");
    Q$3(this, Ap2);
    this.id = t;
  }
  get geoJSONBoundingBox() {
    return P(this, Ap2) ? P(this, Ap2) : "bbox" in this.geoJSON.geometry && this.geoJSON.geometry.bbox ? this.geoJSON.geometry.bbox : (R$1(this, Ap2, lt(this.geoJSON)), P(this, Ap2));
  }
  get geoJSON() {
    return { properties: null, type: "Feature", geometry: { type: "Polygon", coordinates: [[]] } };
  }
};
Ap2 = /* @__PURE__ */ new WeakMap(), H$3(KC, "BaseMapData");
var la = KC;
var hc, Ts, ua2, yd, Gg, tS, Np = class Np2 extends la {
  constructor(e, n4) {
    super(n4.mvfData.id, e);
    Q$3(this, Gg);
    O(this, "__type", Np2.__type);
    Q$3(this, hc);
    Q$3(this, Ts, {});
    Q$3(this, ua2);
    Q$3(this, yd);
    R$1(this, hc, e), R$1(this, ua2, n4.mvfData), R$1(this, yd, n4.facadeId);
  }
  static is(e) {
    return e.__type === Np2.__type;
  }
  get type() {
    return P(this, ua2).type;
  }
  get name() {
    var e;
    return (e = S$1(this, Gg, tS).call(this, "name")) != null ? e : "";
  }
  get shortName() {
    var e;
    return (e = S$1(this, Gg, tS).call(this, "shortName")) != null ? e : "";
  }
  get externalId() {
    var e;
    return (e = P(this, ua2).externalId) != null ? e : "";
  }
  get floors() {
    var e, n4;
    if (P(this, Ts).floors == null) {
      let i = ((n4 = (e = P(this, ua2).floors) != null ? e : P(this, ua2).maps) != null ? n4 : []).reduce((a4, u5) => {
        let h = P(this, hc).floorsById[u5];
        return h && a4.push(h), a4;
      }, []);
      i.length === 0 && B.error("Floor stack ".concat(this.id, " has no floors")), P(this, Ts).floors = i.sort((a4, u5) => a4.elevation - u5.elevation);
    }
    return P(this, Ts).floors;
  }
  get defaultFloor() {
    if (P(this, Ts).defaultFloor != null) return P(this, Ts).defaultFloor;
    let e = P(this, ua2).defaultFloor ? P(this, hc).getById("floor", P(this, ua2).defaultFloor) : void 0;
    return P(this, Ts).defaultFloor = e || this.floors.reduce((n4, i) => Math.abs(i.elevation) < Math.abs(n4.elevation) ? i : n4), P(this, Ts).defaultFloor;
  }
  get facade() {
    return P(this, yd) ? P(this, hc).facadesById[P(this, yd)] : void 0;
  }
  toJSON() {
    return { __type: Np2.__type, id: this.id, name: this.name, shortName: this.shortName, type: this.type, floors: this.floors.map((e) => e.id) };
  }
  destroy() {
    for (let e of globalThis.Object.keys(P(this, Ts))) delete P(this, Ts)[e];
  }
};
hc = /* @__PURE__ */ new WeakMap(), Ts = /* @__PURE__ */ new WeakMap(), ua2 = /* @__PURE__ */ new WeakMap(), yd = /* @__PURE__ */ new WeakMap(), Gg = /* @__PURE__ */ new WeakSet(), tS = H$3(function(e) {
  return P(this, hc).getPropTranslation(this.__type, e, this.id, P(this, ua2)[e]);
}, "#translate"), H$3(Np, "FloorStack"), O(Np, "__type", "floor-stack");
var QC = Np, Vg2 = QC;
a();
a();
a();
a();
a();
a();
var jg2, Jl, kp2 = class kp3 extends si {
  constructor(e) {
    super(String(E()));
    O(this, "__type", kp3.__type);
    Q$3(this, jg2, {});
    Q$3(this, Jl);
    R$1(this, Jl, e.mvfData);
  }
  static is(e) {
    return e.__type === kp3.__type;
  }
  get url() {
    return P(this, Jl).url;
  }
  get name() {
    if ("displayName" in P(this, Jl)) return P(this, Jl).displayName;
    if ("label" in P(this, Jl)) return P(this, Jl).label;
  }
  toJSON() {
    return { __type: kp3.__type, id: this.id, url: this.url, name: this.name };
  }
  destroy() {
    for (let e of globalThis.Object.keys(P(this, jg2))) delete P(this, jg2)[e];
  }
};
jg2 = /* @__PURE__ */ new WeakMap(), Jl = /* @__PURE__ */ new WeakMap(), H$3(kp2, "Hyperlink"), O(kp2, "__type", "hyperlink");
var eS = kp2, fc = eS;
a();
a();
function Ug2(r5) {
  return typeof r5 == "string" ? r5 : r5.id;
}
H$3(Ug2, "getId");
function nS(r5) {
  return Array.isArray(r5) && Number.isFinite(r5[0]) && Number.isFinite(r5[1]);
}
H$3(nS, "isPosition");
var rS = 8, el = H$3((r5) => typeof r5 == "number" ? r5.toFixed(rS) : nS(r5) ? r5[1].toFixed(rS) + "-" + r5[0].toFixed(rS) : r5.map((t) => el(t)).join("-"), "serializeCoords"), $B = H$3((r5) => {
  let t = /^https:\/\/cdn\.mappedin\.com\/[^/]+\/[^/]+\.[a-zA-Z0-9]+$/, e = /^https:\/\/cdn-staging\.mappedin\.net\/[^/]+\/[^/]+\.[a-zA-Z0-9]+$/;
  return t.test(r5) || e.test(r5);
}, "isPrivateCdnAsset"), ob = H$3((r5) => {
  if (!$B(r5)) return null;
  let t = "";
  r5.startsWith("https://") ? (t = "https://", r5 = r5.slice(8)) : r5.startsWith("http://") && (t = "http://", r5 = r5.slice(7));
  let [e, n4, i] = r5.split("/");
  return { origin: t + e, mapId: n4, fileName: i };
}, "parseCdnAssetUrl");
var zg, dc, Fp, Rp = class Rp2 extends si {
  constructor(e) {
    super(String(E()));
    O(this, "__type", Rp2.__type);
    Q$3(this, zg, {});
    Q$3(this, dc);
    Q$3(this, Fp);
    R$1(this, dc, e.mvfData), R$1(this, Fp, e.mapData);
  }
  static is(e) {
    return e.__type === Rp2.__type;
  }
  get url() {
    let e = P(this, dc).url;
    if (P(this, Fp).tokenManager == null) return e;
    let n4 = ob(P(this, dc).url);
    if (n4 == null) return e;
    let i = n4.mapId;
    try {
      if (P(this, Fp).tokenManager.isEnterpriseMode()) return e;
      let a4 = P(this, Fp).tokenManager.getSasToken(i).token;
      if (a4 == null || a4 === "") throw new Error("SAS token empty!");
      return "".concat(e, "?").concat(a4);
    } catch (a4) {
      return B.error("Error getting SAS token for image", { error: a4, url: e }), e;
    }
  }
  get name() {
    return P(this, dc).altText;
  }
  get altText() {
    return P(this, dc).altText;
  }
  toJSON() {
    return { __type: Rp2.__type, id: this.id, url: this.url, name: this.name };
  }
  destroy() {
    for (let e of globalThis.Object.keys(P(this, zg))) delete P(this, zg)[e];
  }
};
zg = /* @__PURE__ */ new WeakMap(), dc = /* @__PURE__ */ new WeakMap(), Fp = /* @__PURE__ */ new WeakMap(), H$3(Rp, "ImageMetaData"), O(Rp, "__type", "image");
var iS = Rp, mc = iS;
var vd2, Kl, Ql, oS = class oS2 extends la {
  constructor(e, n4) {
    super(n4.properties.id, e);
    Q$3(this, vd2);
    Q$3(this, Kl);
    Q$3(this, Ql, {});
    R$1(this, vd2, e), R$1(this, Kl, n4);
  }
  get externalId() {
    var e;
    return (e = P(this, Kl).properties.externalId) != null ? e : "";
  }
  get name() {
    var n4, i, a4, u5;
    let e = (i = (n4 = P(this, Kl).properties.details) == null ? void 0 : n4.name) != null ? i : "";
    return e === "" && (e = (u5 = (a4 = this.locationProfiles.find((h) => h.name && h.name.length > 0)) == null ? void 0 : a4.name) != null ? u5 : ""), e;
  }
  get description() {
    var n4, i, a4, u5;
    let e = (i = (n4 = P(this, Kl).properties.details) == null ? void 0 : n4.description) != null ? i : "";
    return e === "" && (e = (u5 = (a4 = this.locationProfiles.find((h) => h.description && h.description.length > 0)) == null ? void 0 : a4.description) != null ? u5 : ""), e;
  }
  get images() {
    var n4, i, a4, u5, h;
    if (P(this, Ql).images != null) return P(this, Ql).images;
    let e = (a4 = (i = (n4 = P(this, Kl).properties.details) == null ? void 0 : n4.images) == null ? void 0 : i.map((d) => new mc({ mvfData: d, mapData: P(this, vd2) }))) != null ? a4 : [];
    return (e == null || e.length === 0) && (e = (h = (u5 = this.locationProfiles.find((d) => d.images.length > 0)) == null ? void 0 : u5.images) != null ? h : []), P(this, Ql).images = e, e;
  }
  get links() {
    var n4, i, a4, u5, h;
    if (P(this, Ql).links != null) return P(this, Ql).links;
    let e = (a4 = (i = (n4 = P(this, Kl).properties.details) == null ? void 0 : n4.links) == null ? void 0 : i.map((d) => new fc({ mvfData: d }))) != null ? a4 : [];
    return (e == null || e.length === 0) && (e = (h = (u5 = this.locationProfiles.find((d) => d.links.length > 0)) == null ? void 0 : u5.links) != null ? h : []), P(this, Ql).links = e, e;
  }
  get locationProfiles() {
    var e;
    return (e = P(this, vd2).locationProfilesByAttachedFeatureId[this.id]) != null ? e : [];
  }
};
vd2 = /* @__PURE__ */ new WeakMap(), Kl = /* @__PURE__ */ new WeakMap(), Ql = /* @__PURE__ */ new WeakMap(), H$3(oS, "DetailedMapData");
var Hi = oS;
var Hg2, Gp, bd2, xd2, Bp = class Bp2 extends Hi {
  constructor(e, n4) {
    super(e, n4.mvfData);
    O(this, "__type", Bp2.__type);
    Q$3(this, Hg2);
    Q$3(this, Gp);
    Q$3(this, bd2, {});
    Q$3(this, xd2);
    R$1(this, Hg2, e), R$1(this, Gp, n4.floorId), R$1(this, xd2, n4.mvfData);
  }
  static is(e) {
    return e.__type === Bp2.__type;
  }
  get center() {
    return P(this, bd2).center == null && (P(this, bd2).center = Ti(P(this, xd2), P(this, Gp))), P(this, bd2).center;
  }
  get floor() {
    let e = P(this, Hg2).getById("floor", P(this, Gp));
    if (e == null) throw new Error("Floor ".concat(P(this, Gp), " not found!"));
    return e;
  }
  get geoJSON() {
    return G$1(F$1({}, P(this, xd2)), { properties: null });
  }
  get focusTarget() {
    return this;
  }
  get anchorTarget() {
    return this.center;
  }
  toJSON() {
    return { __type: Bp2.__type, id: this.id, name: this.name, floor: this.floor.id };
  }
  destroy() {
  }
};
Hg2 = /* @__PURE__ */ new WeakMap(), Gp = /* @__PURE__ */ new WeakMap(), bd2 = /* @__PURE__ */ new WeakMap(), xd2 = /* @__PURE__ */ new WeakMap(), H$3(Bp, "Area"), O(Bp, "__type", "area");
var sS = Bp, tu2 = sS;
a();
var jp, eu2, Up, _d2, Vp = class Vp2 extends Hi {
  constructor(e, n4) {
    super(e, n4.mvfData);
    O(this, "__type", Vp2.__type);
    Q$3(this, jp);
    Q$3(this, eu2);
    Q$3(this, Up);
    Q$3(this, _d2);
    R$1(this, eu2, {}), R$1(this, _d2, n4.mvfData), R$1(this, jp, e), R$1(this, Up, n4.floorId);
  }
  static is(e) {
    return e.__type === Vp2.__type;
  }
  get floor() {
    let e = P(this, jp).getById("floor", P(this, Up));
    if (e == null) throw new Error("Floor ".concat(P(this, Up), " not found!"));
    return e;
  }
  get center() {
    return P(this, eu2).center == null && (P(this, eu2).center = Ti(P(this, _d2), P(this, Up))), P(this, eu2).center;
  }
  get isExterior() {
    var i;
    let e = P(this, jp).obstructionIdByEntranceId[this.id], n4 = P(this, jp).getMVFFeatureById("obstruction", e);
    return (i = n4 == null ? void 0 : n4.properties.footprintComponent) != null ? i : false;
  }
  get geoJSON() {
    return G$1(F$1({}, P(this, _d2)), { properties: null });
  }
  get focusTarget() {
    return this.center;
  }
  get anchorTarget() {
    return this.center;
  }
  toJSON() {
    return { __type: Vp2.__type, id: this.id, name: this.name, floor: this.floor.id, center: this.center.toJSON() };
  }
  destroy() {
    for (let e of Object.keys(P(this, eu2))) delete P(this, eu2)[e];
  }
};
jp = /* @__PURE__ */ new WeakMap(), eu2 = /* @__PURE__ */ new WeakMap(), Up = /* @__PURE__ */ new WeakMap(), _d2 = /* @__PURE__ */ new WeakMap(), H$3(Vp, "Door"), O(Vp, "__type", "door");
var aS = Vp, ca = aS;
a();
var gc, Hp, as, rl, zp = class zp2 extends Hi {
  constructor(e, n4) {
    super(e, n4.mvfData);
    O(this, "__type", zp2.__type);
    Q$3(this, gc);
    Q$3(this, Hp);
    Q$3(this, as, {});
    Q$3(this, rl);
    R$1(this, gc, e), R$1(this, Hp, n4.floorId), R$1(this, rl, n4.mvfData);
  }
  getMvfData() {
    return P(this, rl);
  }
  static is(e) {
    return e.__type === zp2.__type;
  }
  get type() {
    return KB(P(this, rl).properties.kind);
  }
  get locations() {
    if (P(this, as).locations) return P(this, as).locations;
    P(this, as).locations = [];
    let e = P(this, gc).mvfLocationsBySpaceId[P(this, rl).properties.id];
    if ((e == null ? void 0 : e.length) > 0) for (let n4 of e) {
      let i = P(this, gc).getById("enterprise-location", n4.id);
      i && P(this, as).locations.push(i);
    }
    return P(this, as).locations;
  }
  get floor() {
    let e = P(this, gc).getById("floor", P(this, Hp));
    if (e == null) throw new Error("Floor ".concat(P(this, Hp), " not found!"));
    return e;
  }
  get doors() {
    return P(this, rl).properties.destinationNodes.reduce((e, n4) => {
      let i = P(this, gc).doorsByNodeId[n4];
      return i && e.push(i), e;
    }, []);
  }
  get center() {
    return P(this, as).center == null && (P(this, as).center = Ti(P(this, rl), P(this, Hp))), P(this, as).center;
  }
  get geoJSON() {
    return G$1(F$1({}, P(this, rl)), { properties: null });
  }
  get focusTarget() {
    return this.geoJSON.geometry.type === "Polygon" ? this : this.center;
  }
  get anchorTarget() {
    return this.center;
  }
  toJSON() {
    return { __type: zp2.__type, id: this.id, name: this.name, type: this.type, floor: this.floor.id, center: this.center.toJSON() };
  }
  destroy() {
    for (let e of Object.keys(P(this, as))) delete P(this, as)[e];
  }
};
gc = /* @__PURE__ */ new WeakMap(), Hp = /* @__PURE__ */ new WeakMap(), as = /* @__PURE__ */ new WeakMap(), rl = /* @__PURE__ */ new WeakMap(), H$3(zp, "Space"), O(zp, "__type", "space");
var lS = zp, JB = ["room", "hallway", "exterior", "void", "gate", "connection.stairs", "connection.elevator", "poi"];
function KB(r5) {
  if (r5 == null || r5 === "default") return "room";
  let t = r5.toLowerCase();
  return JB.includes(t) ? t : "room";
}
H$3(KB, "validateSpaceType");
var ui = lS;
a();
var ws, Gr, ls, Cd2, sb, Xp = class Xp2 extends la {
  constructor(e, n4) {
    super(n4.mvfData.properties.id, e);
    Q$3(this, Cd2);
    O(this, "__type", Xp2.__type);
    Q$3(this, ws);
    Q$3(this, Gr, {});
    Q$3(this, ls);
    R$1(this, ws, e), R$1(this, ls, n4.mvfData);
  }
  static is(e) {
    return e.__type === Xp2.__type;
  }
  get focusTarget() {
    return this;
  }
  get name() {
    var e, n4;
    return "name" in P(this, ls).properties ? (n4 = S$1(this, Cd2, sb).call(this, "name")) != null ? n4 : "" : (e = P(this, ls).properties.externalId) != null ? e : "";
  }
  get shortName() {
    var e, n4;
    return "shortName" in P(this, ls).properties ? (n4 = S$1(this, Cd2, sb).call(this, "shortName")) != null ? n4 : "" : (e = P(this, ls).properties.externalId) != null ? e : "";
  }
  get subtitle() {
    var e;
    return (e = S$1(this, Cd2, sb).call(this, "subtitle")) != null ? e : "";
  }
  get externalId() {
    var e;
    return (e = P(this, ls).properties.externalId) != null ? e : "";
  }
  get elevation() {
    return P(this, ls).properties.elevation;
  }
  get spaces() {
    if (P(this, Gr).spaces == null) {
      let e = P(this, ws).spaces.filter((n4) => n4.floor.id === this.id);
      P(this, Gr).spaces = e;
    }
    return P(this, Gr).spaces;
  }
  get geoJSON() {
    var e;
    return { type: "Feature", properties: null, geometry: (e = P(this, ls).geometry) != null ? e : { type: "Polygon", coordinates: [] } };
  }
  get objects() {
    if (P(this, Gr).objects == null) {
      let e = P(this, ws).objects.filter((n4) => n4.floor.id === this.id);
      P(this, Gr).objects = e;
    }
    return P(this, Gr).objects;
  }
  get connections() {
    if (P(this, Gr).connections == null) {
      let e = P(this, ws).connections.filter((n4) => n4.floors.includes(this));
      P(this, Gr).connections = e;
    }
    return P(this, Gr).connections;
  }
  get doors() {
    if (P(this, Gr).doors == null) {
      let e = P(this, ws).doors.filter((n4) => n4.floor.id === this.id);
      P(this, Gr).doors = e;
    }
    return P(this, Gr).doors;
  }
  get annotations() {
    if (P(this, Gr).annotations == null) {
      let e = P(this, ws).annotations.filter((n4) => n4.floor.id === this.id);
      P(this, Gr).annotations = e;
    }
    return P(this, Gr).annotations;
  }
  get pois() {
    if (P(this, Gr).pois == null) {
      let e = P(this, ws).pointsOfInterest.filter((n4) => n4.floor.id === this.id);
      P(this, Gr).pois = e;
    }
    return P(this, Gr).pois;
  }
  get floorStack() {
    if (P(this, Gr).floorStack == null) {
      let e = P(this, ws).floorStacks.find((n4) => n4.floors.includes(this));
      P(this, Gr).floorStack = e;
    }
    return P(this, Gr).floorStack;
  }
  get center() {
    return P(this, Gr).center == null && (P(this, Gr).center = Ti(P(this, ls), this.id)), P(this, Gr).center;
  }
  toJSON() {
    return { __type: Xp2.__type, id: this.id, name: this.name, shortName: this.shortName, subtitle: this.subtitle, elevation: this.elevation, spaces: this.spaces.map((e) => e.id), objects: this.objects.map((e) => e.id), connections: this.connections.map((e) => e.id), doors: this.doors.map((e) => e.id), annotations: this.annotations.map((e) => e.id), pois: this.pois.map((e) => e.id) };
  }
  destroy() {
    for (let e of globalThis.Object.keys(P(this, Gr))) delete P(this, Gr)[e];
  }
};
ws = /* @__PURE__ */ new WeakMap(), Gr = /* @__PURE__ */ new WeakMap(), ls = /* @__PURE__ */ new WeakMap(), Cd2 = /* @__PURE__ */ new WeakSet(), sb = H$3(function(e) {
  let n4 = P(this, ls).properties[e];
  return P(this, ws).getPropTranslation(this.__type, e, this.id, n4);
}, "#translate"), H$3(Xp, "Floor"), O(Xp, "__type", "floor");
var uS = Xp, Io = uS;
a();
a();
a();
var Xg2 = H$3((r5) => r5 != null, "notNull");
a();
function Yg2(r5) {
  let t;
  if (ui.is(r5) || ca.is(r5) || Vo.is(r5) || tu2.is(r5) || Ps.is(r5)) t = r5.center;
  else if (ru2.is(r5) || nu2.is(r5)) t = r5.coordinate;
  else if (ve2.is(r5)) t = r5;
  else if ($l.is(r5)) t = r5.coordinate;
  else if (nl.is(r5)) t = r5.coordinates[0];
  else return;
  return t;
}
H$3(Yg2, "getCoordinateFromStuffs");
a();
a();
var Yp = { auto: true, debug: false, pitch: 45, bearing: 0, antialiasing: { enabled: true }, shadingAndOutlines: true, outdoorView: { layersHiddenByGeometry: ["building", "building-top"] }, imagePlacementOptions: { mode: "default" }, flipImagesToFaceCamera: true, multiFloorView: { enabled: false, floorHeight: 10 } }, il2 = "ExteriorWalls", yc = "Walls", y7 = 0, Sd2 = "InteriorDoors", Id2 = "ExteriorDoors", Gn2 = "GeometryLayer", iu2 = "LabelsLayer", ol = "MarkersLayer", qg = "FootprintLayer", qp = "OcclusionLayer", sl = "ImagesLayer", Wp = "FacadesLayer";
var v7 = ["https://mappedin.auth0.com", "https://mappedin-staging.auth0.com"], b7 = { orange: "#F26336", teal: "#057685", lightTeal: "#5DC7D0" };
var QB = /* @__PURE__ */ new Set(["outdoorView", "bearing", "pitch", "zoomLevel", "screenOffsets", "debug", "initialFloor", "shadingAndOutlines", "wallTopColor", "style", "multiFloorView", "occlusion", "imagePlacementOptions", "flipImagesToFaceCamera", "injectStyles", "useStandaloneCamera", "preloadFloors", "hideImagesNotOnCurrentFloor"]), tG = /* @__PURE__ */ new Set(["style", "enabled", "layersHiddenByGeometry", "lowDpi"]);
function cS(r5) {
  var t, e;
  (t = r5.outdoorView) != null && t.enabled && !((e = r5.outdoorView) != null && e.token) && B.error("Enable outdoor view requires a token. Provide token in `options.outdoorView.token`");
}
H$3(cS, "validateOptions");
function pS(r5, t) {
  var i, a4, u5, h, d, m5;
  let e = ((i = r5 == null ? void 0 : r5.outdoorView) == null ? void 0 : i.token) || t.outdoorViewToken, n4 = G$1(F$1(F$1({}, Yp), r5), { outdoorView: F$1({ enabled: ((a4 = r5 == null ? void 0 : r5.outdoorView) == null ? void 0 : a4.enabled) === void 0 ? !!e : (u5 = r5 == null ? void 0 : r5.outdoorView) == null ? void 0 : u5.enabled, layersHiddenByGeometry: (h = Yp.outdoorView) == null ? void 0 : h.layersHiddenByGeometry }, r5 == null ? void 0 : r5.outdoorView), bearing: (m5 = (d = r5 == null ? void 0 : r5.bearing) != null ? d : t.naturalBearing) != null ? m5 : 0, imagePlacementOptions: F$1(F$1({}, Yp.imagePlacementOptions), r5 == null ? void 0 : r5.imagePlacementOptions), multiFloorView: F$1(F$1({}, Yp.multiFloorView), r5 == null ? void 0 : r5.multiFloorView) });
  return e && n4.outdoorView && (n4.outdoorView.token = e), n4;
}
H$3(pS, "handleShow3DMapOptionDefault");
function x7(r5) {
  let t = { remove_watermark: false };
  if (r5) try {
    let e = Sr(r5);
    Object.assign(t, e.capabilities);
  } catch (e) {
    B.error("Error decoding capabilities from token", e);
  }
  return t;
}
H$3(x7, "handleTokenCapabilities");
function _7(r5) {
  let t = Object.fromEntries(Object.entries(r5).filter(([e]) => QB.has(e)));
  return t.outdoorView && (t.outdoorView = Object.fromEntries(Object.entries(t.outdoorView).filter(([e]) => tG.has(e)))), t;
}
H$3(_7, "getPublicOptions");
var vc, Es2, ou2, Zp = class Zp2 extends Hi {
  constructor(e, n4) {
    let i = Object.values(n4.mvfDataByFloorId)[0];
    super(e, i);
    O(this, "__type", Zp2.__type);
    Q$3(this, vc);
    Q$3(this, Es2);
    Q$3(this, ou2);
    R$1(this, Es2, {}), R$1(this, vc, e), R$1(this, ou2, n4.mvfDataByFloorId);
  }
  static is(e) {
    return e.__type === Zp2.__type;
  }
  get accessible() {
    var e;
    return (e = Object.values(P(this, ou2))[0].properties.accessible) != null ? e : false;
  }
  get type() {
    var e, n4;
    return (n4 = (e = Object.values(P(this, ou2))[0].properties.kind) == null ? void 0 : e.split(".")[1]) != null ? n4 : "unknown";
  }
  get extra() {
    return Object.values(P(this, ou2))[0].properties.extra;
  }
  get coordinates() {
    return P(this, Es2).coordinates == null && (P(this, Es2).coordinates = Object.entries(P(this, ou2)).map(([e, n4]) => Ti(n4, e))), P(this, Es2).coordinates;
  }
  get nodes() {
    return Object.values(P(this, ou2))[0].properties.nodes.map((e) => P(this, vc).getById("node", e));
  }
  get floors() {
    return this.coordinates.map((e) => e.floorId ? P(this, vc).getById("floor", e.floorId) : void 0).filter(Xg2);
  }
  get locationProfiles() {
    var n4, i, a4, u5, h;
    if (P(this, Es2).locationProfiles != null) return P(this, Es2).locationProfiles;
    let e = super.locationProfiles;
    if (e == null || e.length === 0) {
      let d = [(i = (n4 = this.coordinates[0]) == null ? void 0 : n4.longitude) != null ? i : 0, (u5 = (a4 = this.coordinates[0]) == null ? void 0 : a4.latitude) != null ? u5 : 0], m5 = el(d), v3 = (h = P(this, vc).mvfConnectionIdsByLatLon[m5]) != null ? h : [];
      for (let x2 of v3) {
        let S4 = P(this, vc).locationProfilesByAttachedFeatureId[x2];
        if (S4 != null) {
          e = S4;
          break;
        }
      }
    }
    return P(this, Es2).locationProfiles = e != null ? e : [], e;
  }
  get focusTarget() {
    return this.coordinates;
  }
  toJSON() {
    return { __type: Zp2.__type, id: this.id, name: this.name, type: this.type, externalId: this.externalId, coordinates: this.coordinates.map((e) => e.toJSON()), floors: this.floors.map((e) => e.id), extra: this.extra };
  }
  destroy() {
    for (let e of Object.keys(P(this, Es2))) delete P(this, Es2)[e];
  }
};
vc = /* @__PURE__ */ new WeakMap(), Es2 = /* @__PURE__ */ new WeakMap(), ou2 = /* @__PURE__ */ new WeakMap(), H$3(Zp, "Connection"), O(Zp, "__type", "connection");
var hS = Zp, bc2 = hS;
a();
var Wg2, Jp, xc, Kp, $p = class $p2 extends Hi {
  constructor(e, n4) {
    super(e, n4.mvfData);
    O(this, "__type", $p2.__type);
    Q$3(this, Wg2);
    Q$3(this, Jp);
    Q$3(this, xc, {});
    Q$3(this, Kp);
    R$1(this, Wg2, e), R$1(this, Jp, n4.floorId), R$1(this, Kp, n4.mvfData);
  }
  static is(e) {
    return e.__type === $p2.__type;
  }
  get type() {
    let e = P(this, Kp).properties.kind;
    return e == null && (e = "object"), e === "Desks" && (e = "desk"), e.toLowerCase();
  }
  get floor() {
    let e = P(this, Wg2).getById("floor", P(this, Jp));
    if (e == null) throw new Error("Floor ".concat(P(this, Jp), " not found!"));
    return e;
  }
  get center() {
    return P(this, xc).center == null && (P(this, xc).center = Ti(P(this, Kp), P(this, Jp))), P(this, xc).center;
  }
  get geoJSON() {
    return G$1(F$1({}, P(this, Kp)), { properties: null });
  }
  get anchorTarget() {
    return this.center;
  }
  get focusTarget() {
    return this.geoJSON.geometry.type === "Polygon" ? this : this.center;
  }
  toJSON() {
    return { __type: $p2.__type, id: this.id, name: this.name, type: this.type, floor: this.floor.id, center: this.center.toJSON() };
  }
  destroy() {
    for (let e of globalThis.Object.keys(P(this, xc))) P(this, xc)[e] = null;
  }
};
Wg2 = /* @__PURE__ */ new WeakMap(), Jp = /* @__PURE__ */ new WeakMap(), xc = /* @__PURE__ */ new WeakMap(), Kp = /* @__PURE__ */ new WeakMap(), H$3($p, "MapObject"), O($p, "__type", "object");
var fS = $p, Vo = fS;
a();
var Zg, th2, _c, Md2, Qp = class Qp2 extends Hi {
  constructor(e, n4) {
    super(e, n4.mvfData);
    O(this, "__type", Qp2.__type);
    Q$3(this, Zg);
    Q$3(this, th2);
    Q$3(this, _c, {});
    Q$3(this, Md2);
    R$1(this, Zg, e), R$1(this, Md2, n4.mvfData), R$1(this, th2, n4.floorId);
  }
  static is(e) {
    return e.__type === Qp2.__type;
  }
  get floor() {
    let e = P(this, Zg).getById("floor", P(this, th2));
    if (e == null) throw new Error("Floor ".concat(P(this, th2), " not found!"));
    return e;
  }
  get coordinate() {
    return P(this, _c).coordinate == null && (P(this, _c).coordinate = Ti(P(this, Md2), P(this, th2))), P(this, _c).coordinate;
  }
  get geoJSON() {
    return G$1(F$1({}, P(this, Md2)), { properties: null });
  }
  get focusTarget() {
    return this.coordinate;
  }
  get anchorTarget() {
    return this.coordinate;
  }
  toJSON() {
    return { __type: Qp2.__type, id: this.id, name: this.name, floor: this.floor.id, coordinate: this.coordinate.toJSON() };
  }
  destroy() {
    for (let e in P(this, _c)) P(this, _c)[e] = null;
  }
};
Zg = /* @__PURE__ */ new WeakMap(), th2 = /* @__PURE__ */ new WeakMap(), _c = /* @__PURE__ */ new WeakMap(), Md2 = /* @__PURE__ */ new WeakMap(), H$3(Qp, "PointOfInterest"), O(Qp, "__type", "point-of-interest");
var dS = Qp, ru2 = dS;
a();
var $g2, rh2, Cc2, nh2, Jg2, gS, eh2 = class eh3 extends Hi {
  constructor(e, n4) {
    super(e, n4.mvfData);
    Q$3(this, Jg2);
    O(this, "__type", eh3.__type);
    Q$3(this, $g2);
    Q$3(this, rh2);
    Q$3(this, Cc2, {});
    Q$3(this, nh2);
    R$1(this, $g2, e), R$1(this, rh2, n4.floorId), R$1(this, nh2, n4.mvfData);
  }
  static is(e) {
    return e.__type === eh3.__type;
  }
  get group() {
    return S$1(this, Jg2, gS).call(this).group;
  }
  get type() {
    return S$1(this, Jg2, gS).call(this).type;
  }
  get coordinate() {
    return P(this, Cc2).coordinate == null && (P(this, Cc2).coordinate = Ti(P(this, nh2), P(this, rh2))), P(this, Cc2).coordinate;
  }
  get floor() {
    let e = P(this, $g2).getById("floor", P(this, rh2));
    if (e == null) throw new Error("Floor ".concat(P(this, rh2), " not found!"));
    return e;
  }
  get geoJSON() {
    return G$1(F$1({}, P(this, nh2)), { properties: null });
  }
  get focusTarget() {
    return this.coordinate;
  }
  get anchorTarget() {
    return this.coordinate;
  }
  toJSON() {
    return { __type: eh3.__type, id: this.id, group: this.group, type: this.type, coordinate: this.coordinate.toJSON() };
  }
  destroy() {
    for (let e of Object.keys(P(this, Cc2))) delete P(this, Cc2)[e];
  }
};
$g2 = /* @__PURE__ */ new WeakMap(), rh2 = /* @__PURE__ */ new WeakMap(), Cc2 = /* @__PURE__ */ new WeakMap(), nh2 = /* @__PURE__ */ new WeakMap(), Jg2 = /* @__PURE__ */ new WeakSet(), gS = H$3(function() {
  let [e, n4] = P(this, nh2).properties.symbolId.split("--");
  return { group: e, type: n4 };
}, "#getGroupAndTypeFromSymbolId"), H$3(eh2, "Annotation"), O(eh2, "__type", "annotation");
var mS = eh2, nu2 = mS;
a();
var eG = /* @__PURE__ */ new Set(["wall", "area"]), rG = /* @__PURE__ */ new Set(["void", "desk-entrance"]), nG = H$3((r5, t) => {
  var d, m5, v3, x2, S4, I3, w3, E4, T3, D4, A3;
  let e = {}, n4 = {}, i = {}, a4 = {}, u5 = {}, h = {};
  for (let L3 of r5["location.json"] || []) {
    let B3 = new ih2(t, { mvfData: L3 });
    if (e[L3.id] = B3, L3.externalId && (a4[L3.externalId] == null && (a4[L3.externalId] = []), a4[L3.externalId].push(B3)), L3.categories) for (let W4 of L3.categories) u5[W4] == null && (u5[W4] = []), u5[W4].push(B3);
    let j3 = [...(m5 = (d = L3.obstructions) == null ? void 0 : d.map((W4) => W4.id)) != null ? m5 : [], ...(x2 = (v3 = L3.spaces) == null ? void 0 : v3.map((W4) => W4.id)) != null ? x2 : [], ...(I3 = (S4 = L3.annotations) == null ? void 0 : S4.map((W4) => W4.id)) != null ? I3 : [], ...(w3 = L3.connections) != null ? w3 : [], ...(T3 = (E4 = L3.entrances) == null ? void 0 : E4.map((W4) => W4.id)) != null ? T3 : [], ...(A3 = (D4 = L3.areas) == null ? void 0 : D4.map((W4) => W4.id)) != null ? A3 : []];
    for (let W4 of j3) W4 && (h[W4] == null && (h[W4] = []), h[W4].push(B3));
  }
  for (let L3 of r5["category.json"] || []) {
    let B3 = new Qg2(t, { mvfData: L3 });
    n4[L3.id] = B3, L3.parent && (i[L3.parent] == null && (i[L3.parent] = []), i[L3.parent].push(B3));
  }
  return { locationCategoriesByParentId: i, locationProfilesById: e, locationCategoriesById: n4, locationProfilesByExternalId: a4, locationProfilesByCategoryId: u5, locationProfilesByAttachedFeatureId: h };
}, "processMVFLocationProfilesAndCategories"), iG = H$3((r5, t, e) => {
  var E4, T3;
  let n4 = {}, i = {}, a4 = {}, u5 = {}, h = {}, d = {}, m5 = {}, v3 = {}, x2 = {}, S4 = {}, I3 = {}, w3 = globalThis.Object.keys(r5.space);
  for (let D4 of w3) {
    let A3 = r5.space[D4];
    if (A3 != null) {
      for (let L3 of A3.features) if (I3[L3.properties.id] = D4, d[L3.properties.id] = L3, L3.properties.kind === "desk-entrance" && (h[L3.properties.externalId] == null && (h[L3.properties.externalId] = []), h[L3.properties.externalId].push(...L3.properties.destinationNodes)), !rG.has((E4 = L3.properties.kind) != null ? E4 : "")) {
        if ((T3 = L3.properties.kind) != null && T3.includes("connection")) {
          let B3 = el(L3.geometry.coordinates);
          x2[B3] == null && (x2[B3] = []), x2[B3].push(L3.properties.id);
          continue;
        }
        if (L3.properties.kind === "poi") {
          let B3 = new ru2(e, { floorId: D4, mvfData: L3 });
          a4[L3.properties.id] = B3, v3[D4] || (v3[D4] = []), v3[D4].push(L3), L3.properties.externalId && (u5[L3.properties.externalId] == null && (u5[L3.properties.externalId] = []), u5[L3.properties.externalId].push(B3));
        } else {
          let B3 = new ui(e, { floorId: D4, mvfData: L3 });
          n4[L3.properties.id] = B3, L3.properties.externalId && (i[L3.properties.externalId] == null && (i[L3.properties.externalId] = []), i[L3.properties.externalId].push(B3)), m5[D4] || (m5[D4] = []), m5[D4].push(L3);
        }
      }
    }
  }
  for (let D4 in x2) {
    let A3 = x2[D4], L3 = {};
    for (let j3 of A3) {
      let W4 = I3[j3], $5 = d[j3], F3 = t == null ? void 0 : t["n_" + $5.properties.id.split("s_")[1]];
      L3[W4] = G$1(F$1({}, $5), { properties: G$1(F$1({}, $5.properties), { accessible: (F3 == null ? void 0 : F3.accessible) === true }) });
    }
    let B3 = new bc2(e, { mvfDataByFloorId: L3 });
    S4[B3.id] = B3;
  }
  return { spacesById: n4, spacesByExternalId: i, poisById: a4, poisByExternalId: u5, connectionsById: S4, objectEntranceNodeIdsByObstructionId: h, mvfSpacesById: d, connectionIdsByLatLon: x2, mvfSpacesByFloorId: m5, mvfPoisByFloorId: v3 };
}, "processMVFSpaces"), oG = H$3((r5, t) => {
  var u5, h;
  let e = {}, n4 = {}, i = {}, a4 = {};
  for (let d of r5["node.geojson"].features) {
    i[d.properties.id] = d;
    let m5 = new $l(t, { mvfData: d, floorId: (u5 = d.properties.floor) != null ? u5 : d.properties.map });
    e[d.properties.id] = m5, d.properties.externalId && (n4[d.properties.externalId] == null && (n4[d.properties.externalId] = []), n4[d.properties.externalId].push(m5));
    let v3 = (h = d.properties.floor) != null ? h : d.properties.map;
    a4[v3] || (a4[v3] = []), a4[v3].push(d);
  }
  return { nodesById: e, nodesByExternalId: n4, mvfNodesById: i, mvfNodesByFloorId: a4 };
}, "processMVFNodes"), sG = H$3((r5, t) => {
  var h, d;
  let e = {}, n4 = {}, i = {}, a4 = {}, u5 = globalThis.Object.keys(r5.obstruction);
  for (let m5 of u5) {
    let v3 = r5.obstruction[m5];
    if (v3 != null) for (let x2 of v3.features) {
      i[x2.properties.id] = x2;
      for (let I3 of x2.properties.entrances) a4[I3] = x2.properties.id;
      if (eG.has((d = (h = x2.properties.kind) == null ? void 0 : h.toLowerCase()) != null ? d : "")) continue;
      let S4 = new Vo(t, { floorId: m5, mvfData: x2 });
      e[x2.properties.id] = S4, x2.properties.externalId && (n4[x2.properties.externalId] == null && (n4[x2.properties.externalId] = []), n4[x2.properties.externalId].push(S4));
    }
  }
  return { objectsById: e, objectsByExternalId: n4, mvfObstructionById: i, obstructionIdByEntranceId: a4 };
}, "processMVFObstructions"), aG = H$3((r5, t) => {
  let e = {}, n4 = {}, i = {};
  if ("floor.geojson" in r5 && r5["floor.geojson"] != null) for (let a4 of r5["floor.geojson"].features) {
    i[a4.properties.id] = a4.properties;
    let u5 = new Io(t, { mvfData: a4 });
    e[a4.properties.id] = u5, a4.properties.externalId && (n4[a4.properties.externalId] == null && (n4[a4.properties.externalId] = []), n4[a4.properties.externalId].push(u5));
  }
  else for (let a4 of r5["map.geojson"]) {
    i[a4.id] = a4;
    let u5 = new Io(t, { mvfData: { properties: a4 } });
    e[a4.id] = u5;
  }
  return { floorsById: e, floorsByExternalId: n4, mvfFloorsById: i };
}, "processMVFFloors"), lG = H$3((r5, t) => {
  var d;
  let e = {}, n4 = {}, i = {}, a4 = {}, u5 = {}, h = r5["floorstack.json"] || r5["mapstack.json"] || r5["mapstack.geojson"];
  if (h != null) for (let m5 of h) {
    let v3 = (d = r5.facade) == null ? void 0 : d[m5.id], x2 = new Vg2(t, { mvfData: m5, facadeId: v3 == null ? void 0 : v3.id });
    if (e[m5.id] = x2, m5.externalId && (n4[m5.externalId] == null && (n4[m5.externalId] = []), n4[m5.externalId].push(x2)), i[m5.id] = m5, v3) {
      let S4 = new Ps(t, { mvfData: v3, floorStackId: m5.id });
      a4[v3.id] = S4;
      for (let I3 of v3.spaces) u5[I3.spaceId] = S4;
    }
  }
  return { floorStacksById: e, floorStacksByExternalId: n4, mvfFloorStacksById: i, facadesById: a4, facadesBySpaceId: u5 };
}, "processMVFFloorStacks"), uG = H$3((r5, t) => {
  let e = {}, n4 = {}, i = r5["connection.json"].reduce((a4, u5) => {
    u5.nodes.forEach((d) => a4[d] = u5), e[u5.id] = u5;
    let h = t == null ? void 0 : t[u5.nodes[0]];
    if (h != null) {
      let d = el(h.geometry.coordinates);
      n4[d] == null && (n4[d] = []), n4[d].push(u5.id);
    }
    return a4;
  }, {});
  return { mvfConnectionsById: e, mvfConnectionsByNodeId: i, mvfConnectionIdsByLatLon: n4 };
}, "processMVFConnections"), cG = H$3((r5, t) => {
  let e = {}, n4 = {}, i = {}, a4 = {}, u5 = {}, h = globalThis.Object.keys(r5.entrance);
  for (let d of h) {
    let m5 = r5.entrance[d];
    if (m5 != null) for (let v3 of m5.features) {
      a4[v3.properties.id] = v3;
      let x2 = new ca(t, { floorId: d, mvfData: v3 });
      v3.properties.node && (i[v3.properties.node] = x2), e[v3.properties.id] = x2, v3.properties.externalId && (n4[v3.properties.externalId] == null && (n4[v3.properties.externalId] = []), n4[v3.properties.externalId].push(x2)), u5[d] || (u5[d] = []), u5[d].push(v3);
    }
  }
  return { doorsById: e, doorsByExternalId: n4, doorsByNodeId: i, mvfEntrancesById: a4, mvfEntrancesByFloorId: u5 };
}, "processMVFEntrances"), pG = H$3((r5, t, e) => {
  var n4;
  if (r5.textAreas != null) for (let i in r5.textAreas) {
    let a4 = (n4 = r5.textAreas[i]) == null ? void 0 : n4.features;
    if (a4 != null) {
      for (let u5 of a4) if ("anchorId" in u5.properties) {
        let h = u5 == null ? void 0 : u5.properties, d = t[h.anchorId] || e[h.anchorId];
        if (d != null && h != null) {
          let m5 = d.properties;
          m5.textArea = h, m5.textArea && (m5.textArea.position = u5.geometry.coordinates);
        }
      }
    }
  }
}, "processMVFTextAreas"), hG = H$3((r5, t, e) => {
  var n4;
  if (r5.floorImages != null) for (let i in r5.floorImages) {
    let a4 = (n4 = r5.floorImages[i]) == null ? void 0 : n4.features;
    if (a4 != null) {
      for (let u5 of a4) if ("anchorId" in u5.properties) {
        let h = u5 == null ? void 0 : u5.properties, d = t[h.anchorId] || e[h.anchorId];
        if (d != null && h != null) {
          let m5 = d.properties;
          m5.image = h, m5.image && (m5.image.position = u5.geometry.coordinates);
        }
      }
    }
  }
}, "processMVFPolygonImages"), fG = H$3((r5, t) => {
  var n4, i;
  if (((n4 = r5.enterprise) == null ? void 0 : n4.enterpriseStyles) == null) return;
  let e = (i = r5.enterprise) == null ? void 0 : i.enterpriseStyles;
  for (let a4 in e) {
    let u5 = e[a4];
    u5.geometryAnchors.forEach((h) => {
      let d = t[h.geometryId];
      if (d != null) {
        let m5 = d.properties;
        m5.style = { styleId: a4, edgeOffset: u5.edgeOffset };
      }
    });
  }
}, "processMVFEnterprisePolygonStyles"), dG = H$3((r5, t, e) => {
  if (!(r5.enterprise == null || r5.enterprise.textures == null)) for (let n4 of r5.enterprise.textures) for (let i of n4.geometryAnchors) {
    let a4 = t[i.geometryId] || e[i.geometryId];
    if (a4 != null) {
      let u5 = a4.properties;
      u5.textures == null && (u5.textures = []), u5.textures.push(n4);
    }
  }
}, "processMVFEnterpriseTextures"), mG = H$3((r5, t) => {
  let e = {}, n4 = {}, i = {};
  if (r5.annotation == null) return { annotationsById: e, mvfAnnotationsById: n4, mvfAnnotationsByFloorId: i };
  let a4 = globalThis.Object.keys(r5.annotation);
  for (let u5 of a4) {
    let h = r5.annotation[u5];
    if (h != null) for (let d of h.features) {
      n4[d.properties.id] = d;
      let m5 = new nu2(t, { floorId: u5, mvfData: d });
      e[d.properties.id] = m5, i[u5] || (i[u5] = []), i[u5].push(d);
    }
  }
  return { annotationsById: e, mvfAnnotationsById: n4, mvfAnnotationsByFloorId: i };
}, "processMVFAnnotations"), gG = H$3((r5, t) => {
  let e = {}, n4 = {}, i = {};
  if (r5.area == null) return { areasById: e, areasByExternalId: n4, mvfAreasById: i };
  let a4 = globalThis.Object.keys(r5.area);
  for (let u5 of a4) {
    let h = r5.area[u5];
    if (h != null) for (let d of h.features) {
      i[d.properties.id] = d;
      let m5 = new tu2(t, { floorId: u5, mvfData: d });
      e[d.properties.id] = m5, d.properties.externalId && (n4[d.properties.externalId] == null && (n4[d.properties.externalId] = []), n4[d.properties.externalId].push(m5));
    }
  }
  return { areasById: e, areasByExternalId: n4, mvfAreasById: i };
}, "processMVFAreas"), C7 = H$3((r5, t) => {
  var A3, L3, B3, j3, W4, $5, F3, J4, ot2, K4, H5, _t2, ct2;
  let e = {}, n4 = {}, i = {}, a4 = {}, u5 = ((L3 = (A3 = r5.enterprise) == null ? void 0 : A3.locations) != null ? L3 : []).reduce((ft2, mt2) => (ft2[mt2.id] = mt2, ft2), {}), h = {}, d = {}, m5 = {}, v3 = {}, x2 = {}, S4 = {}, I3 = ((B3 = r5.enterprise) == null ? void 0 : B3.venue) || {}, w3 = {}, E4 = {}, T3 = {};
  for (let ft2 of (W4 = (j3 = r5.enterprise) == null ? void 0 : j3.categories) != null ? W4 : []) {
    let mt2 = new Kg2(t, { mvfData: ft2 });
    h[ft2.id] = mt2, ft2.externalId && (d[ft2.externalId] == null && (d[ft2.externalId] = []), d[ft2.externalId].push(mt2)), m5[ft2.id] = ft2, ft2.locations.forEach((St2) => {
      x2[St2] == null && (x2[St2] = []), x2[St2].push(ft2.id);
    });
  }
  let D4 = {};
  for (let ft2 of (F3 = ($5 = r5.enterprise) == null ? void 0 : $5.locationInstances) != null ? F3 : []) {
    let mt2 = u5[ft2.parent], St2 = Object.keys(mt2), dt2 = {};
    for (let q4 of St2) dt2[q4] = void 0;
    let xt2 = F$1(G$1(F$1({}, dt2), { polygons: [], nodes: [] }), ft2);
    D4[xt2.parent] == null && (D4[xt2.parent] = []), D4[xt2.parent].push(new nl(t, { mvfData: xt2, categoryIds: ((ot2 = (J4 = r5.enterprise) == null ? void 0 : J4.categoryPriorities) == null ? void 0 : ot2[xt2.id]) || x2[xt2.id], parentId: ft2.parent })), w3[xt2.id] = ft2;
  }
  for (let ft2 in r5.space) {
    let mt2 = r5.space[ft2];
    if (mt2 != null) for (let St2 of mt2.features) {
      for (let dt2 of St2.properties.destinationNodes) E4[dt2] == null && (E4[dt2] = []), E4[dt2].push(St2.properties.id);
      T3[St2.properties.id] = St2.properties.destinationNodes;
    }
  }
  for (let ft2 of (H5 = (K4 = r5.enterprise) == null ? void 0 : K4.locations) != null ? H5 : []) {
    let mt2 = new nl(t, { mvfData: ft2, categoryIds: ((ct2 = (_t2 = r5.enterprise) == null ? void 0 : _t2.categoryPriorities) == null ? void 0 : ct2[ft2.id]) || x2[ft2.id], locationInstances: D4[ft2.id] });
    i[ft2.id] = mt2, ft2.externalId && (a4[ft2.externalId] == null && (a4[ft2.externalId] = []), a4[ft2.externalId].push(mt2)), ft2.nodes.forEach((St2) => {
      S4[St2.id] == null && (S4[St2.id] = []), S4[St2.id].push(ft2.id);
    });
    for (let St2 of ft2.polygons) v3[St2.id] == null && (v3[St2.id] = []), v3[St2.id].push(ft2);
  }
  if (t.enterpriseMode === true) {
    for (let ft2 in t.mvfConnectionsById) {
      let mt2 = {}, St2 = t.mvfConnectionsById[ft2];
      for (let dt2 of t.mvfConnectionsById[ft2].nodes) {
        let xt2 = t.nodesById[dt2];
        xt2 != null && (mt2[xt2.floor.id] = { type: "Feature", geometry: { type: "Point", coordinates: [xt2.coordinate.longitude, xt2.coordinate.latitude] }, properties: { id: ft2, externalId: St2.externalId, kind: "enterprise." + St2.type, destinationNodes: [], flags: "", type: St2.type, nodes: St2.nodes, accessible: St2.accessible, extra: St2.extra, details: St2.details } });
      }
      Object.keys(mt2).length > 0 && (e[ft2] = new bc2(t, { mvfDataByFloorId: mt2 }), St2.externalId && (n4[St2.externalId] == null && (n4[St2.externalId] = []), n4[St2.externalId].push(e[ft2])));
    }
    t.connectionsById = e;
  }
  return { spaceIdsByNodeId: E4, connectionsByExternalId: n4, locationIdsByNodeId: S4, mvfLocationsBySpaceId: v3, mvfLocationsById: u5, mvfCategoriesById: m5, locationsById: i, locationsByExternalId: a4, locationInstancesById: w3, categoriesById: h, categoriesByExternalId: d, destinationNodesIdsBySpaceId: T3, venue: I3 };
}, "createEnterpriseDataFromMVF"), S7 = H$3((r5, t) => {
  let { nodesById: e, nodesByExternalId: n4, mvfNodesById: i, mvfNodesByFloorId: a4 } = oG(r5, t), { mvfConnectionsById: u5, mvfConnectionsByNodeId: h, mvfConnectionIdsByLatLon: d } = uG(r5, i), { spacesById: m5, spacesByExternalId: v3, poisById: x2, poisByExternalId: S4, mvfSpacesById: I3, objectEntranceNodeIdsByObstructionId: w3, connectionsById: E4, connectionIdsByLatLon: T3, mvfSpacesByFloorId: D4, mvfPoisByFloorId: A3 } = iG(r5, h, t), { objectsById: L3, objectsByExternalId: B3, mvfObstructionById: j3, obstructionIdByEntranceId: W4 } = sG(r5, t), { floorsById: $5, floorsByExternalId: F3, mvfFloorsById: J4 } = aG(r5, t), { floorStacksById: ot2, floorStacksByExternalId: K4, mvfFloorStacksById: H5, facadesById: _t2, facadesBySpaceId: ct2 } = lG(r5, t), { doorsById: ft2, doorsByExternalId: mt2, doorsByNodeId: St2, mvfEntrancesById: dt2, mvfEntrancesByFloorId: xt2 } = cG(r5, t), { annotationsById: q4, mvfAnnotationsById: ee2, mvfAnnotationsByFloorId: Gt2 } = mG(r5, t), { areasById: Kt2, areasByExternalId: It2, mvfAreasById: ie2 } = gG(r5, t);
  hG(r5, I3, j3), pG(r5, I3, j3), fG(r5, I3), dG(r5, I3, j3);
  let { locationCategoriesByParentId: vr2, locationProfilesById: Qe2, locationCategoriesById: Nt2, locationProfilesByExternalId: At2, locationProfilesByCategoryId: Ct2, locationProfilesByAttachedFeatureId: _e3 } = nG(r5, t);
  return { spacesById: m5, spacesByExternalId: v3, nodesById: e, nodesByExternalId: n4, objectsById: L3, objectsByExternalId: B3, floorsById: $5, floorsByExternalId: F3, floorStacksById: ot2, floorStacksByExternalId: K4, facadesById: _t2, facadesBySpaceId: ct2, connectionsById: E4, doorsById: ft2, doorsByExternalId: mt2, doorsByNodeId: St2, poisById: x2, poisByExternalId: S4, annotationsById: q4, areasById: Kt2, areasByExternalId: It2, objectEntranceNodeIdsByObstructionId: w3, obstructionIdByEntranceId: W4, connectionIdsByLatLon: T3, locationProfilesById: Qe2, locationCategoriesById: Nt2, locationProfilesByExternalId: At2, locationProfilesByCategoryId: Ct2, locationCategoriesByParentId: vr2, mvfSpacesById: I3, mvfNodesById: i, mvfObstructionById: j3, mvfFloorsById: J4, mvfFloorStacksById: H5, mvfConnectionsById: u5, mvfConnectionsByNodeId: h, mvfEntrancesById: dt2, mvfAnnotationsById: ee2, mvfNodesByFloorId: a4, mvfSpacesByFloorId: D4, mvfPoisByFloorId: A3, mvfAreasById: ie2, mvfEntrancesByFloorId: xt2, mvfAnnotationsByFloorId: Gt2, locationProfilesByAttachedFeatureId: _e3, mvfConnectionIdsByLatLon: d };
}, "createDataFromMVF");
a();
a();
a();
var yG = H$3(function() {
  let t = globalThis.fetch;
  return { fetch(...e) {
    if (!Xg2(t)) throw new Error("fetch is not available in your environment. Pass your own function into `setFetchFn` (node-fetch, etc)");
    return t == null ? void 0 : t(...e);
  }, setFetch(e) {
    t = e;
  } };
}, "createFetchControl")(), I7 = yG.fetch;
var E7 = ["websdk", "web", "webv2", "kiosk-v2", "mobile", "iossdk", "androidsdk", "reactnativesdk", "gen7", "bespoke"], M7 = E7[0], O7 = "https://api-gateway.mappedin.com/track-analytics/a/", D7 = "deny-watchposition", L7 = "load-mapview", A7 = "load-mapdata", N7 = "change-language", k7 = "query-directions";
var al, Os2, su2, vS, ab, bS = class bS2 {
  constructor() {
    Q$3(this, su2);
    Q$3(this, al, Object.freeze({}));
    Q$3(this, Os2);
    O(this, "oneTimeEventsSent", /* @__PURE__ */ new Set());
    O(this, "sendGetDirectionsEvent", or((t, e) => this.sendAnalyticEvent(k7, { start: t, end: e, type: "location_to_location" }), 2500));
    R$1(this, Os2, S$1(this, su2, ab).call(this, P(this, al)));
  }
  init(t) {
    this.reset(), this.updateStateWithOptions(t);
  }
  reset() {
    R$1(this, al, {}), R$1(this, Os2, S$1(this, su2, ab).call(this, {})), this.oneTimeEventsSent.clear();
  }
  updateStateWithOptions(t) {
    return R$1(this, al, Object.freeze(Object.assign({}, P(this, al), t))), R$1(this, Os2, S$1(this, su2, ab).call(this, t)), S$1(this, su2, vS).call(this, P(this, Os2)), P(this, Os2);
  }
  updateState(t) {
    let e = F$1({}, t);
    e.mapId && (e.analyticsBaseUrl = yS(G$1(F$1({}, P(this, Os2)), { mapId: e.mapId }))), e.context && (e.context = P7(e.context)), e.baseUri && (e.analyticsBaseUrl = yS({ baseUri: e.baseUri, mapId: P(this, Os2).mapId })), Object.assign(P(this, Os2), e), this.handleStateUpdate(t), S$1(this, su2, vS).call(this, e);
  }
  handleStateUpdate(t) {
    var e;
    (e = t.userPosition) != null && e.floorLevel ? this.sendBlueDotEvents("found-floor") : t.userPosition && this.sendBlueDotEvents("found-position");
  }
  get authReady() {
    let { key: t, secret: e, accessToken: n4 } = this.getState();
    return !!(t && e) || !!n4;
  }
  getState() {
    return P(this, Os2);
  }
  getContext() {
    return this.getState().context || P(this, al).context || M7;
  }
  getSessionId() {
    return this.getState().sessionId || P(this, al).sessionId || w7();
  }
  getDeviceId() {
    return this.getState().deviceId || P(this, al).deviceId || T7();
  }
  sendAnalyticEvent(t, e = {}) {
    let n4 = this.getState(), i = vG(n4.analyticsBaseUrl, t), a4 = { "mi-context": this.getContext(), "mi-session": this.getSessionId(), "mi-device": this.getDeviceId() };
    if (n4.logEvents && B.log("Analytics.track", i, a4), !n4.sendEvents) return Promise.resolve();
    if (!this.authReady) return B.warn("Auth needs to be ready to send analytics.");
    let u5 = G$1(F$1({}, e), { g: n4.geolocationMode, sdk_version: n4.version });
    return n4.userPosition && Object.assign(u5, n4.userPosition), a4["Content-Type"] = "application/json", n4.accessToken ? a4.Authorization = "Bearer ".concat(n4.accessToken) : n4.noAuth || n4.secret && n4.key && (a4["x-mappedin-key"] = btoa(n4.key), a4["x-mappedin-secret"] = btoa(n4.secret)), I7(i, { method: "POST", mode: "cors", headers: a4, body: JSON.stringify(u5) });
  }
  capture(t, e) {
    if (xG.includes(t)) return B.warn("".concat(t, " event is sent internally.")), Promise.resolve();
    let n4 = bG.includes(t) ? t.slice(1) : t;
    return this.sendAnalyticEvent(n4, e);
  }
  sendGetMapDataEvent(t) {
    return this.sendAnalyticEvent(A7, t);
  }
  sendChangeLanguageEvent(t) {
    return this.sendAnalyticEvent(N7, t);
  }
  sendWatchPositionDenied() {
    return this.sendAnalyticEvent(D7);
  }
  sendMapViewLoadedEvent({ firstRenderDuration: t, dimension: e, collisionWorkerDisabled: n4, outdoorsWorkerDisabled: i }) {
    return this.sendAnalyticEvent(L7, { type: "3d", firstRenderDuration: t, width: e.width, height: e.height, devicePixelRatio: globalThis.devicePixelRatio || 1, collisionWorkerDisabled: n4, outdoorsWorkerDisabled: i });
  }
  sendBlueDotEvents(t) {
    if (!((t === "found-floor" || t === "found-position") && this.oneTimeEventsSent.has(t))) return this.oneTimeEventsSent.add(t), this.sendAnalyticEvent(t);
  }
};
al = /* @__PURE__ */ new WeakMap(), Os2 = /* @__PURE__ */ new WeakMap(), su2 = /* @__PURE__ */ new WeakSet(), vS = H$3(function(t) {
  t.sessionId && Pe$1.getInstance().saveSessionData("id", t.sessionId), t.deviceId && Pe$1.getInstance().saveLocalData("deviceId", t.deviceId);
}, "#saveStateToStorage"), ab = H$3(function(t) {
  var n4, i, a4, u5;
  let e = (n4 = t.baseUri) != null ? n4 : O7;
  return { baseUri: e, analyticsBaseUrl: yS(G$1(F$1({}, t), { baseUri: e })), version: ((i = p$1 == null ? void 0 : p$1.env) == null ? void 0 : i.npm_package_version) || "v6", deviceId: t.deviceId || T7(), accessToken: t.accessToken, mapId: t.mapId, sessionId: t.sessionId || w7(), platformString: t.platformString || "", context: P7(t.context) || M7, geolocationMode: false, sendEvents: (a4 = t.sendEvents) != null ? a4 : true, logEvents: (u5 = t.logEvents) != null ? u5 : false, noAuth: t.noAuth || false, key: t.key, secret: t.secret };
}, "#getStateWithOption"), H$3(bS, "AnalyticsInternal");
var Td2 = bS;
function yS({ mapId: r5, baseUri: t = O7 }) {
  return "".concat(t).concat(r5, "/");
}
H$3(yS, "getBaseUrl");
function T7() {
  return Pe$1.getInstance().loadLocalData("deviceId");
}
H$3(T7, "getDeviceIDFromStorage");
function w7() {
  return Pe$1.getInstance().loadSessionData("id");
}
H$3(w7, "getSessionIDFromStorage");
function vG(r5, t) {
  return r5 + t;
}
H$3(vG, "buildUrl");
function P7(r5) {
  return E7.find((t) => t === r5);
}
H$3(P7, "getValidContext");
var bG = ["$select-location", "$select-category", "$query-suggest", "$query-search"], xG = [L7, A7, k7, D7, N7];
new Td2();
var Ds2, xS = class xS2 {
  constructor(t) {
    Q$3(this, Ds2);
    O(this, "capture");
    O(this, "updateState");
    R$1(this, Ds2, t), this.capture = P(this, Ds2).capture.bind(P(this, Ds2)), this.updateState = P(this, Ds2).updateState.bind(P(this, Ds2));
  }
  getState() {
    let i = P(this, Ds2).getState(), { sessionId: t, deviceId: e } = i;
    return J$1(i, ["sessionId", "deviceId"]);
  }
  getContext() {
    return P(this, Ds2).getContext();
  }
  getSessionId() {
    return P(this, Ds2).getSessionId();
  }
  getDeviceId() {
    return P(this, Ds2).getDeviceId();
  }
};
Ds2 = /* @__PURE__ */ new WeakMap(), H$3(xS, "Analytics");
var ty2 = xS;
a();
var _G = /* @__PURE__ */ new Set(["polygons"]), pa2, xn, jo, ey2, oh2 = class oh3 extends si {
  constructor(e, n4) {
    super(n4.mvfData.externalId);
    O(this, "__type", oh3.__type);
    O(this, "description");
    O(this, "name", "");
    O(this, "amenity");
    O(this, "externalId", "");
    O(this, "extra");
    O(this, "gallery");
    O(this, "instances");
    O(this, "logo");
    O(this, "operationHours");
    O(this, "phone");
    O(this, "picture");
    O(this, "shortName");
    O(this, "showFloatingLabelWhenImagePresent");
    O(this, "showLogo");
    O(this, "siblingGroups");
    O(this, "social");
    O(this, "sortOrder", -1);
    O(this, "states");
    O(this, "tags");
    O(this, "type", "");
    O(this, "hidden", false);
    Q$3(this, pa2);
    Q$3(this, xn, {});
    Q$3(this, jo);
    Q$3(this, ey2);
    R$1(this, pa2, e), R$1(this, jo, n4.mvfData), R$1(this, ey2, n4.categoryIds || []), this.instances = n4.locationInstances || [];
    for (let i in n4.mvfData) !_G.has(i) && !Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), i) && Object.defineProperty(this, i, { enumerable: true, get() {
      if (n4.parentId) {
        let a4 = P(this, pa2).locationsById[n4.parentId];
        return P(this, jo)[i] != null ? P(this, pa2).getPropTranslation(this.__type, i, P(this, jo).id, P(this, jo)[i]) : P(this, pa2).getPropTranslation(this.__type, i, P(this, jo).id, a4[i]);
      }
      return P(this, pa2).getPropTranslation(this.__type, i, P(this, jo).id, P(this, jo)[i]);
    } });
  }
  static is(e) {
    return e.__type === oh3.__type;
  }
  get focusTarget() {
    return this.spaces;
  }
  get categories() {
    return P(this, xn).categories ? P(this, xn).categories : (P(this, xn).categories = (P(this, ey2).map((e) => P(this, pa2).getById("enterprise-category", e)) || []).filter(Boolean), P(this, xn).categories);
  }
  get coordinates() {
    if (P(this, xn).coordinates) return P(this, xn).coordinates;
    P(this, xn).coordinates = [];
    for (let e = 0; e < this.nodes.length; e++) P(this, xn).coordinates.push(this.nodes[e].coordinate);
    return P(this, xn).coordinates;
  }
  get nodes() {
    if (P(this, xn).nodes) return P(this, xn).nodes;
    P(this, xn).nodes = [];
    for (let e = 0; e < P(this, jo).nodes.length; e++) {
      let n4 = P(this, pa2).getById("node", P(this, jo).nodes[e].id);
      n4 && P(this, xn).nodes.push(n4);
    }
    return P(this, xn).nodes;
  }
  get spaces() {
    if (P(this, xn).spaces) return P(this, xn).spaces;
    P(this, xn).spaces = [];
    for (let e = 0; e < P(this, jo).polygons.length; e++) {
      let n4 = P(this, pa2).getById("space", P(this, jo).polygons[e].id);
      n4 && P(this, xn).spaces.push(n4);
    }
    return P(this, xn).spaces;
  }
  toJSON() {
    return { __type: oh3.__type, id: this.id, name: this.name };
  }
  destroy() {
    for (let e of Object.keys(P(this, xn))) delete P(this, xn)[e];
  }
};
pa2 = /* @__PURE__ */ new WeakMap(), xn = /* @__PURE__ */ new WeakMap(), jo = /* @__PURE__ */ new WeakMap(), ey2 = /* @__PURE__ */ new WeakMap(), H$3(oh2, "EnterpriseLocation"), O(oh2, "__type", "enterprise-location");
var _S = oh2, nl = _S;
a();
var CG = /* @__PURE__ */ new Set(), ah2, Mo, ll, sh2 = class sh3 extends si {
  constructor(e, n4) {
    super(n4.mvfData.externalId);
    O(this, "__type", sh3.__type);
    O(this, "name", "");
    O(this, "color");
    O(this, "externalId", "");
    O(this, "extra");
    O(this, "icon");
    O(this, "iconFromDefaultList");
    O(this, "sortOrder", -1);
    O(this, "picture");
    Q$3(this, ah2);
    Q$3(this, Mo, {});
    Q$3(this, ll);
    R$1(this, ah2, e), R$1(this, ll, n4.mvfData);
    for (let i in n4.mvfData) !CG.has(i) && !Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), i) && Object.defineProperty(this, i, { get() {
      return P(this, ah2).getPropTranslation(this.__type, i, P(this, ll).id, P(this, ll)[i]);
    } });
  }
  static is(e) {
    return e.__type === sh3.__type;
  }
  get children() {
    if (P(this, Mo).children) return P(this, Mo).children;
    P(this, Mo).children = [];
    for (let e = 0; e < P(this, ll).children.length; e++) {
      let n4 = P(this, ah2).getById("enterprise-category", P(this, ll).children[e]);
      n4 && P(this, Mo).children.push(n4);
    }
    return P(this, Mo).children;
  }
  get locations() {
    if (P(this, Mo).locations) return P(this, Mo).locations;
    P(this, Mo).locations = [];
    for (let e = 0; e < P(this, ll).locations.length; e++) {
      let n4 = P(this, ah2).getById("enterprise-location", P(this, ll).locations[e]);
      n4 && P(this, Mo).locations.push(n4);
    }
    return P(this, Mo).locations;
  }
  toJSON() {
    return { __type: sh3.__type, id: this.id, name: this.name };
  }
  destroy() {
    for (let e of Object.keys(P(this, Mo))) delete P(this, Mo)[e];
  }
};
ah2 = /* @__PURE__ */ new WeakMap(), Mo = /* @__PURE__ */ new WeakMap(), ll = /* @__PURE__ */ new WeakMap(), H$3(sh2, "EnterpriseCategory"), O(sh2, "__type", "enterprise-category");
var CS = sh2, Kg2 = CS;
a();
var SG = /* @__PURE__ */ new Set(), ry2, ny2, lh2 = class lh3 extends si {
  constructor(e, n4) {
    super(n4.mvfData.externalId);
    O(this, "__type", lh3.__type);
    O(this, "countrycode");
    O(this, "externalId", "");
    O(this, "defaultLanguage", { code: "en", name: "English" });
    O(this, "defaultMap");
    O(this, "extra");
    O(this, "icon");
    O(this, "languages", []);
    O(this, "links", []);
    O(this, "logo");
    O(this, "mappedinWebUrl");
    O(this, "slug", "");
    O(this, "topLocations");
    O(this, "tzid");
    Q$3(this, ry2, {});
    Q$3(this, ny2);
    R$1(this, ny2, n4.mvfData);
    for (let i in n4.mvfData) !SG.has(i) && !Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), i) && (this[i] = n4.mvfData[i]);
  }
  static is(e) {
    return e.__type === lh3.__type;
  }
  get name() {
    var e;
    return (e = P(this, ny2).name) != null ? e : "";
  }
  toJSON() {
    return { __type: lh3.__type, id: this.id, name: this.name };
  }
  destroy() {
    for (let e of Object.keys(P(this, ry2))) delete P(this, ry2)[e];
  }
};
ry2 = /* @__PURE__ */ new WeakMap(), ny2 = /* @__PURE__ */ new WeakMap(), H$3(lh2, "EnterpriseVenue"), O(lh2, "__type", "enterprise-venue");
var SS = lh2, lb = SS;
a();
a();
function wd(r5) {
  return r5.endsWith("/") ? r5 : "".concat(r5, "/");
}
H$3(wd, "normalizeUrl");
a();
var Pd2 = "https://app.mappedin.com/", R7 = "https://auth.mappedin.com/";
a();
a();
var IG = H$3((r5) => {
  let t = Date.now();
  return r5 - t;
}, "fromNow"), ub = H$3((r5, t) => IG(r5) <= t * 60 * 1e3, "shouldRefreshToken");
var B7 = 60, G7 = B7 * 60 * 1e3, F7 = "accessTokens";
async function iy2(r5, t = false) {
  let e = "".concat(r5.key), n4 = Pe$1.getInstance(), i = (n4 == null ? void 0 : n4.loadSessionData(F7)) || {}, a4 = Math.floor(Date.now() / 1e3);
  if (i[e] && !ub(i[e].expiresTimestamp * 1e3, B7)) return i[e];
  let u5 = t ? await MG(r5, a4) : await TG(r5, a4), h = G$1(F$1({}, i), { [e]: u5 });
  return n4 == null || n4.saveSessionData(F7, h), u5;
}
H$3(iy2, "getAccessToken");
async function MG(r5, t) {
  var a4;
  let e = "".concat((a4 = r5.baseAuthUri) != null ? a4 : R7, "oauth2/token"), n4 = await ha()(e, { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ grant_type: "client_credentials", client_id: r5.key, client_secret: r5.secret }) });
  if (!n4.ok) throw new Error("".concat(n4.status, " ").concat(n4.statusText, ": ").concat(await n4.text()));
  let i = await n4.json();
  return { accessToken: i.access_token, expiresTimestamp: t + i.expires_in };
}
H$3(MG, "fetchAccessTokenEnterprise");
async function TG(r5, t) {
  let e = "".concat(r5.baseAuthUri ? wd(r5.baseAuthUri) : Pd2, "api/api-key/token"), n4 = await ha()(e, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ key: r5.key, secret: r5.secret }) });
  if (!n4.ok) throw new Error("".concat(n4.status, " ").concat(n4.statusText, ": ").concat(await n4.text()));
  let i = await n4.json();
  return { accessToken: i.access_token, expiresTimestamp: t + i.expires_in };
}
H$3(TG, "fetchAccessToken");
a();
var j7 = 60, U7 = j7 * 60 * 1e3, V7 = "miSasTokens";
async function IS(r5, t) {
  let e = "".concat(t, "__").concat(r5.mapId), n4 = Pe$1.getInstance(), i = (n4 == null ? void 0 : n4.loadSessionData(V7)) || {};
  if (i[e] && !ub(i[e].expires, j7)) return i[e];
  let a4 = await wG(r5, t), u5 = G$1(F$1({}, i), { [e]: { token: a4.token, expires: new Date(a4.expires).getTime() } });
  return n4 == null || n4.saveSessionData(V7, u5), a4;
}
H$3(IS, "getSasToken");
async function wG(r5, t) {
  let e = "".concat(r5.baseUri ? wd(r5.baseUri) : Pd2, "api/v1/venue/").concat(r5.mapId, "/sas-token"), n4 = await ha()(e, { method: "GET", headers: { Authorization: "Bearer ".concat(t) } });
  if (!n4.ok) throw new Error("".concat(n4.status, " ").concat(n4.statusText, ": ").concat(await n4.text()));
  let i = await n4.json();
  return { token: i.token, expires: new Date(i.expires).getTime() };
}
H$3(wG, "fetchSasToken");
var z7 = globalThis.fetch, Y7, PG = (Y7 = p$1 == null ? void 0 : p$1.env) == null ? void 0 : Y7.npm_package_version;
function ha() {
  if (z7 == null) throw new Error("fetch is not available in your environment. Pass your own function into `setFetchFn` (node-fetch, etc)");
  return z7;
}
H$3(ha, "isomorphicFetch");
var MS = { supplementaryUrl: "https://api-gateway.mappedin.com/analytics/", headers: {}, accessToken: "", clientId: "", noAuth: false, includeHidden: true, clientSecret: "", apiGateway: "", authorization: "", perspective: "Website", language: "", venue: "" };
function q7(r5) {
  var e;
  let t = F$1(F$1({}, MS), r5);
  return t.headers = G$1(F$1({}, t.headers), { "mappedin-sdk-version": PG }), t.things = [], "platformString" in r5 && (t.headers = G$1(F$1({}, t.headers), { "mappedin-platform-version": r5.platformString })), t.noAuth || (t.accessToken ? t.authorization = "Bearer ".concat(t.accessToken) : t.clientId && t.clientSecret && (t.authorization = "Basic ".concat(globalThis.btoa("".concat(t.clientId, ":").concat(t.clientSecret))))), t.language = (e = t.language) == null ? void 0 : e.toLowerCase(), t;
}
H$3(q7, "parseOptions");
function EG(r5, t, e = false) {
  ({ language: r5.language, clientId: r5.clientId, clientSecret: r5.clientSecret });
  let { headers: i } = r5;
  i["Content-Type"] = i["Content-Type"] || "text/json", r5.accessToken ? i.Authorization = "Bearer ".concat(r5.accessToken) : r5.noAuth || r5.clientId && r5.clientSecret && (i["x-mappedin-key"] = btoa(r5.clientId), i["x-mappedin-secret"] = btoa(r5.clientSecret));
  let a4 = { method: "GET", headers: i };
  return r5.secure && (t += "&withcdntoken"), { req: a4, url: t };
}
H$3(EG, "constructParamsForRequest");
async function OG(r5, t, e = false) {
  let n4 = EG(r5, t, e), i = await ha()(n4.url, n4.req);
  if (!i.ok) throw new Error("".concat(i.status, " ").concat(i.statusText));
  return i.json();
}
H$3(OG, "generateAPIRequest");
var DG = H$3((r5) => {
  let t = r5 != null && typeof r5 == "object" && "perspectives" in r5 && r5.perspectives != null && typeof r5.perspectives == "object" ? r5.perspectives : null;
  if (t == null || Object.keys(t).length === 0) return B.warn("No perspectives available in response!"), null;
  let e = {};
  for (let [n4, i] of Object.entries(t)) {
    let a4 = "url" in i && typeof i.url == "string" ? i.url : null, u5 = "locale_packs" in i && typeof i.locale_packs == "object" ? i.locale_packs : null;
    if (a4 == null || u5 == null) {
      B.warn("Perspective ".concat(n4, " is missing url or locale_packs!"));
      continue;
    }
    e[n4] = { url: a4, locale_packs: u5 };
  }
  return e;
}, "getPerspectivesFromResponse");
async function LG(r5, t = "exports/mvf/1/bundle") {
  var m5, v3;
  let e = q7(F$1(F$1({ baseUri: "https://api-gateway.mappedin.com/" }, MS), r5)), n4 = "".concat(e.baseUri + t, "?venue=").concat(e.venue, "&version=").concat((m5 = e.version) != null ? m5 : "2.0.0");
  e.headers["Content-Type"] = "application/zip";
  let i = await OG(e, n4), a4 = i.url, u5 = i.locale_packs, h = (v3 = e.perspective) != null ? v3 : MS.perspective, d = DG(i);
  if (h != null && h !== "" && d != null) {
    let x2 = d[h];
    x2 == null ? B.warn("Perspective ".concat(h, " not found in response! Loading default perspective instead.")) : (B.log('Loading perspective "'.concat(h, '"')), a4 = x2.url, u5 = x2.locale_packs);
  }
  return { url: a4, localePacks: u5, updated_at: i.updated_at };
}
H$3(LG, "getVenueMVFURL");
var Ed2 = /* @__PURE__ */ (function() {
  let r5;
  return () => (r5 || (r5 = new TextDecoder()), r5);
})();
async function TS(r5, { signal: t }) {
  let e = await (await ha()(r5, { signal: t })).arrayBuffer();
  return new Uint8Array(e);
}
H$3(TS, "getLanguagePackUnitArray");
async function Od2(r5) {
  let e = (await import("./browser-6HMQAV4T-CVBTXkDD.js")).unzipSync(r5), n4 = {};
  if (e["enterprise/"] != null) {
    n4.enterprise = {};
    let i = e["enterprise/locations.json"];
    i && (n4.enterprise.locations = JSON.parse(Ed2().decode(i)));
    let a4 = e["enterprise/locationInstances.json"];
    a4 && (n4.enterprise.locationInstances = JSON.parse(Ed2().decode(a4)));
    let u5 = e["enterprise/categories.json"];
    u5 && (n4.enterprise.categories = JSON.parse(Ed2().decode(u5)));
  }
  return e["floorstack.json"] && (n4["floorstack.json"] = JSON.parse(Ed2().decode(e["floorstack.json"]))), e["floor.geojson"] && (n4["floor.geojson"] = JSON.parse(Ed2().decode(e["floor.geojson"]))), e["manifest.json"] && (n4["manifest.geojson"] = JSON.parse(Ed2().decode(e["manifest.json"]))), n4;
}
H$3(Od2, "parseLanguagePack");
async function W7(r5, { signal: t }) {
  try {
    let e = await (await ha()(r5, { signal: t })).arrayBuffer();
    if (t.aborted) return;
    let n4 = new Uint8Array(e);
    return await Od2(n4);
  } catch (e) {
    let n4 = new Error("downloadLanguagePack failed");
    throw n4.cause = e, n4;
  }
}
H$3(W7, "downloadLanguagePack");
async function wS(r5) {
  return new Promise(async (t, e) => {
    try {
      let n4 = r5.useDraftData ? "exports/mvf2-draft/1/bundle" : "exports/mvf2/1/bundle", { url: i, localePacks: a4 } = await LG(r5, n4), u5 = await ha()(i).then((d) => d.arrayBuffer()), h = new Uint8Array(u5);
      t({ compressed: h, localePacks: a4 });
    } catch (n4) {
      e(n4);
    }
  });
}
H$3(wS, "downloadVenueBundleMVFAPIGateway");
async function PS(r5, t) {
  return new Promise(async (e, n4) => {
    try {
      let { url: i } = await AG(r5, t), a4 = await ha()(i).then((h) => h.arrayBuffer()), u5 = new Uint8Array(a4);
      e(u5);
    } catch (i) {
      n4(i);
    }
  });
}
H$3(PS, "downloadMVF");
async function AG(r5, t) {
  let e = new URL("".concat(r5.baseUri ? wd(r5.baseUri) : Pd2, "api/venue/").concat(r5.mapId, "/mvf"));
  r5.viewId && e.searchParams.set("configId", r5.viewId), r5.mvfVersion && e.searchParams.set("version", r5.mvfVersion);
  let n4 = await ha()(e.toString(), { headers: { Authorization: "Bearer ".concat(t) } });
  if (!n4.ok) throw new Error("".concat(n4.status, " ").concat(n4.statusText));
  return n4.json();
}
H$3(AG, "getMakerBundleURL");
function pb(r5) {
  var n4, i, a4, u5, h, d, m5, v3, x2, S4, I3, w3, E4, T3, D4, A3, L3, B$12;
  let t = new TextDecoder(), e = t.decode.bind(t);
  try {
    let j3 = { "connection.json": JSON.parse(e(r5["connection.json"])), "manifest.geojson": JSON.parse(e(r5["manifest.geojson"])), "map.geojson": r5["map.geojson"] ? JSON.parse(e(r5["map.geojson"])) : void 0, "mapstack.geojson": r5["mapstack.geojson"] ? JSON.parse(e(r5["mapstack.geojson"])) : void 0, "node.geojson": JSON.parse(e(r5["node.geojson"])), obstruction: {}, space: {}, entrance: {}, facade: {}, "tileset.json": r5["tileset.json"] ? JSON.parse(e(r5["tileset.json"])) : void 0 };
    if (r5.enterprise != null && (j3.enterprise = {}, (n4 = r5.enterprise) != null && n4["locations.json"] && (j3.enterprise.locations = JSON.parse(e((i = r5.enterprise) == null ? void 0 : i["locations.json"]))), (a4 = r5.enterprise) != null && a4["categories.json"] && (j3.enterprise.categories = JSON.parse(e((u5 = r5.enterprise) == null ? void 0 : u5["categories.json"]))), (h = r5.enterprise) != null && h["venue.json"] && (j3.enterprise.venue = JSON.parse(e((d = r5.enterprise) == null ? void 0 : d["venue.json"]))), (m5 = r5.enterprise) != null && m5["layers.json"] && (j3.enterprise.layers = JSON.parse(e((v3 = r5.enterprise) == null ? void 0 : v3["layers.json"]))), (x2 = r5.enterprise) != null && x2["locationInstances.json"] && (j3.enterprise.locationInstances = JSON.parse(e((S4 = r5.enterprise) == null ? void 0 : S4["locationInstances.json"]))), (I3 = r5.enterprise) != null && I3["enterpriseStyles.json"] && (j3.enterprise.enterpriseStyles = JSON.parse(e((w3 = r5.enterprise) == null ? void 0 : w3["enterpriseStyles.json"]))), (E4 = r5.enterprise) != null && E4["textures.json"] && (j3.enterprise.textures = JSON.parse(e((T3 = r5.enterprise) == null ? void 0 : T3["textures.json"]))), (D4 = r5.enterprise) != null && D4["floorText.json"] && (j3.enterprise.floorText = JSON.parse(e((A3 = r5.enterprise) == null ? void 0 : A3["floorText.json"]))), (L3 = r5.enterprise) != null && L3["categoryPriorities.json"] && (j3.enterprise.categoryPriorities = JSON.parse(e((B$12 = r5.enterprise) == null ? void 0 : B$12["categoryPriorities.json"])))), r5["floorstack.json"] != null ? j3["floorstack.json"] = JSON.parse(e(r5["floorstack.json"])) : r5["mapstack.json"] != null && (j3["mapstack.json"] = JSON.parse(e(r5["mapstack.json"]))), j3["floorstack.json"] == null && j3["mapstack.json"] == null && j3["mapstack.geojson"] == null) throw new Error("MVF is missing floorstack.json or mapstack.json/mapstack.geojson");
    if (r5["floor.geojson"] && (j3["floor.geojson"] = JSON.parse(e(r5["floor.geojson"]))), j3["floor.geojson"] == null && j3["map.geojson"] == null) throw new Error("MVF is missing floor.geojson or map.geojson");
    if ("styles.json" in r5 && (j3["styles.json"] = JSON.parse(e(r5["styles.json"]))), "shapes.json" in r5 && (j3["shapes.json"] = JSON.parse(e(r5["shapes.json"]))), "location.json" in r5 && (j3["location.json"] = JSON.parse(e(r5["location.json"]))), "category.json" in r5 && (j3["category.json"] = JSON.parse(e(r5["category.json"]))), r5.annotation != null) {
      j3.annotation = {};
      let $5 = Object.keys(r5.annotation);
      for (let F3 of $5) {
        let J4 = F3.replace(/\.json|\.geojson/g, "");
        j3.annotation[J4] = JSON.parse(e(r5.annotation[F3]));
      }
    }
    let W4 = Object.keys(r5.space);
    for (let $5 of W4) {
      let F3 = $5.replace(/\.json|\.geojson/g, "");
      j3.space[F3] = JSON.parse(e(r5.space[$5]));
    }
    if (r5.obstruction != null) {
      let $5 = Object.keys(r5.obstruction);
      for (let F3 of $5) {
        let J4 = F3.replace(/\.json|\.geojson/g, "");
        j3.obstruction[J4] = JSON.parse(e(r5.obstruction[F3]));
      }
    } else j3.obstruction = {};
    if (r5.entrance != null) {
      let $5 = Object.keys(r5.entrance);
      for (let F3 of $5) {
        let J4 = F3.replace(/\.json|\.geojson/g, "");
        j3.entrance[J4] = JSON.parse(e(r5.entrance[F3]));
      }
    } else j3.entrance = {};
    if ("floorImages" in r5 && r5.floorImages != null) {
      j3.floorImages = {};
      for (let $5 of Object.keys(r5.floorImages)) {
        let F3 = $5.replace(/\.json|\.geojson/g, "");
        j3.floorImages[F3] = JSON.parse(e(r5.floorImages[$5]));
      }
    }
    if ("textAreas" in r5 && r5.textAreas != null) {
      j3.textAreas = {};
      for (let $5 of Object.keys(r5.textAreas)) {
        let F3 = $5.replace(/\.json|\.geojson/g, "");
        j3.textAreas[F3] = JSON.parse(e(r5.textAreas[$5]));
      }
    }
    if ("facade" in r5 && r5.facade != null) {
      j3.facade = {};
      for (let $5 of Object.keys(r5.facade)) {
        let F3 = $5.replace(/\.json|\.geojson/g, "");
        j3.facade[F3] = JSON.parse(e(r5.facade[$5]));
      }
    }
    if ("area" in r5 && r5.area != null) {
      j3.area = {};
      for (let $5 of Object.keys(r5.area)) {
        let F3 = $5.replace(/\.json|\.geojson/g, "");
        j3.area[F3] = JSON.parse(e(r5.area[$5]));
      }
    }
    return j3;
  } catch (j3) {
    throw B.error(j3), new Error("MVF parsing failed! Probably encountered a bad file.");
  }
}
H$3(pb, "parseMVF");
function NG(r5) {
  if (r5 == null || typeof r5 != "object") return false;
  let t = ["connection.json", "manifest.geojson", "floor.geojson" in r5 ? "floor.geojson" : "map.geojson", "node.geojson", "floorstack.json" in r5 ? "floorstack.json" : "mapstack.json" in r5 ? "mapstack.json" : "mapstack.geojson"];
  "styles.json" in r5 && t.push("styles.json"), "shapes.json" in r5 && t.push("shapes.json");
  for (let e of t) if (r5[e] == null || r5[e][Symbol.toStringTag] !== "Uint8Array") return false;
  return true;
}
H$3(NG, "validateStaticMVFFiles");
async function hb(r5) {
  return new Promise(async (t, e) => {
    try {
      if (r5 == null || typeof r5 != "object") throw new Error("Error parsing data! Unzipping failed.");
      if (r5[Symbol.toStringTag] !== "Uint8Array") throw new Error("Unexpected file type! Unzipping failed.");
      let i = (await import("./browser-6HMQAV4T-CVBTXkDD.js")).unzipSync(r5);
      if (!NG(i)) throw new Error("MVF is missing some expect static files. Unzipping failed.");
      let a4 = {}, u5 = Object.keys(i);
      for (let h of u5) {
        if (i[h].length === 0) continue;
        let d = h.split("/");
        if (d.length < 0) throw new Error("Encounted a file with no name! Unzipping failed.");
        if (d.length > 2) throw new Error("Encountered unexpected nesting in MVF! Unzipping failed.");
        if (d.length === 1) {
          a4[d[0]] = i[h];
          continue;
        }
        if (d[0] === "image") {
          B.warn("MVF unzipping encountered an image. Ignoring as this case has not been implemented.");
          continue;
        } else a4[d[0]] == null && (a4[d[0]] = {}), a4[d[0]][d[1]] = i[h];
      }
      t(a4);
    } catch (n4) {
      e(n4);
    }
  });
}
H$3(hb, "unzipMVF");
function Sc2() {
  let r5 = "us", t = {};
  function e() {
    return BG(VG(r5), t);
  }
  return H$3(e, "getState"), { updateByUserOption(n4) {
    var i, a4;
    n4.environment && (r5 = n4.environment), n4.baseUri && (t.baseUri = n4.baseUri), n4.baseAuthUri && (t.baseAuthUri = n4.baseAuthUri), (i = n4.analytics) != null && i.baseUri && (t.analyticsBaseUri = (a4 = n4.analytics) == null ? void 0 : a4.baseUri);
  }, updateTileServerBaseUrl(n4) {
    t.tileServerUri = n4;
  }, updateEnvironment(n4) {
    r5 = n4;
  }, getBaseUri(n4) {
    return r5 === "us" && n4 ? H7.baseUri : e().baseUri;
  }, getBaseAuthUri(n4 = false) {
    return r5 === "us" && n4 ? H7.baseAuthUri : e().baseAuthUri;
  }, getAnalyticsBaseUri() {
    return e().analyticsBaseUri;
  }, getTileServerUri() {
    return e().tileServerUri;
  }, reset() {
    r5 = "us", t = {};
  }, __getState: e };
}
H$3(Sc2, "createEnvControl");
var Z7 = Object.freeze({ baseUri: "https://app.mappedin.com/", baseAuthUri: "https://app.mappedin.com/", analyticsBaseUri: "https://api-gateway.mappedin.com/track-analytics/a/", tileServerUri: "https://tiles-cdn.mappedin.com/styles/mappedin/style.json" }), H7 = Object.freeze(G$1(F$1({}, Z7), { baseUri: "https://api-gateway.mappedin.com/", baseAuthUri: "https://auth.mappedin.com/" })), kG = Object.freeze({ baseUri: "https://api-gateway.eu.mappedin.com/", baseAuthUri: "https://auth.eu.mappedin.com/", analyticsBaseUri: "https://api-gateway.eu.mappedin.com/track-analytics/a/", tileServerUri: "https://tiles-cdn.eu.mappedin.com/styles/mappedin/style.json" }), RG = Object.freeze({ baseUri: "https://api-gateway-staging.mappedin.net/", baseAuthUri: "https://auth-staging.mappedin.net/", analyticsBaseUri: "https://api-gateway-staging.mappedin.net/track-analytics/a/", tileServerUri: "https://tiles-cdn.mappedin.com/styles/mappedin/style.json" }), FG = Object.freeze({ baseUri: "https://app-staging.mappedin.net/", baseAuthUri: "https://app-staging.mappedin.net/", analyticsBaseUri: "https://api-gateway-staging.mappedin.net/track-analytics/a/", tileServerUri: "https://tiles-cdn.mappedin.com/styles/mappedin/style.json" });
function BG(r5, t) {
  return F$1(F$1({}, r5), t);
}
H$3(BG, "getAuthStateByEnvironment");
var GG = { eu: kG, us: Z7, "us-staging-enterprise": RG, "us-staging-self-serve": FG };
function VG(r5) {
  return GG[r5];
}
H$3(VG, "getEnvironmentAuthState");
var fb = H$3((r5) => {
  var e, n4;
  let t = Object.values((n4 = (e = r5["floorstack.json"]) != null ? e : r5["mapstack.json"]) != null ? n4 : {});
  return t.length === 1 ? [] : t.filter((i) => i.type !== "Outdoor").map((i) => i.id.replace("fs_", "").replace("ms_", ""));
}, "getBuildingIds"), cb;
async function jG() {
  return cb || (cb = (await import("./dist-NFOUUHU5-XzvEbjti.js")).extractAndConvertMVFv3, cb);
}
H$3(jG, "getExtractAndConvertMvfV3");
var X7 = H$3(async (r5) => {
  let t = performance.now(), e = await (await jG())(r5);
  return B.log("Parsed MVFv3 in ".concat(performance.now() - t, "ms")), e.inspectErr((n4) => {
    throw B.error(n4), new Error("MVFv3 parsing failed!");
  }), e.unwrap();
}, "unzipAndParseMVFv3ToMVFv2");
async function oy(r5, t = "2.0.0") {
  switch (t) {
    case "2.0.0":
      try {
        let e = await hb(r5);
        return pb(e);
      } catch (e) {
        return X7(r5);
      }
    case "3.0.0":
      return X7(r5);
    default:
      throw new Error("Unsupported MVF version: ".concat(t));
  }
}
H$3(oy, "unzipAndParseMVFv2");
a();
a();
a();
a();
var FZ = {};
M$1(FZ, { ACTION_TYPE: () => AM, Annotation: () => nu2, Area: () => tu2, BEARING_TYPE: () => f2, CONNECTION_TYPE: () => NM, Connection: () => bc2, Coordinate: () => ve2, DOORS: () => I1, Directions: () => ju, Door: () => ca, E_SDK_LOG_LEVEL: () => Et, EnterpriseCategory: () => Kg2, EnterpriseLocation: () => nl, EnterpriseVenue: () => lb, Facade: () => Ps, Floor: () => Io, FloorStack: () => Vg2, Hyperlink: () => fc, ImageMetaData: () => mc, LocationCategory: () => Qg2, LocationProfile: () => ih2, MAPPEDIN_COLORS: () => b7, MapObject: () => Vo, Node: () => $l, PointOfInterest: () => ru2, Space: () => ui, WALLS: () => S1, __setWatermarkOnClickFn: () => DZ, checkWorkerUrls: () => LL, createMapLibreOverlay: () => kZ, disableText3DWorker: () => cL, enableTestMode: () => NS, findPreferredLanguageInVenue: () => L2, getMapData: () => DL, getMapDataEnterprise: () => NZ, hydrateMapData: () => _L, hydrateMapDataFromMVF: () => LZ, parseMVF: () => pb, preloadFont: () => $3, setLoggerLevel: () => ur, setUseEnterpriseAPI: () => AZ, setWorkersUrl: () => gL, show3dMap: () => AL, show3dMapGeojson: () => RZ, unzipAndParseMVFv2: () => oy, unzipMVF: () => hb });
a();
a();
a();
a();
var ay2, ly, uy, ES = class ES2 {
  constructor(t, e, { enabled: n4 = false } = {}) {
    Q$3(this, ay2);
    O(this, "searchInstance");
    Q$3(this, ly);
    Q$3(this, uy);
    O(this, "enabled", false);
    R$1(this, ay2, t), R$1(this, ly, e), R$1(this, uy, () => {
      var i;
      (i = this.searchInstance) == null || i.then((a4) => a4.populate());
    }), n4 && this.enable();
  }
  async query(t, e = {}) {
    if (this.enabled || await this.enable(), !this.searchInstance) return B.error("Search should be enabled by now"), { places: [], enterpriseLocations: [], enterpriseCategories: [] };
    try {
      return await (await this.searchInstance).search(t, e);
    } catch (n4) {
      return B.error("Search.query failed due to", n4), { places: [], enterpriseLocations: [], enterpriseCategories: [] };
    }
  }
  async suggest(t, e = {}) {
    if (this.enabled || await this.enable(), !this.searchInstance) return B.error("Search should be enabled by now"), [];
    try {
      return await (await this.searchInstance).suggest(t, e);
    } catch (n4) {
      return B.error("Search.suggest failed due to", n4), [];
    }
  }
  async enable() {
    this.enabled || (this.enabled = true, this.searchInstance || (this.searchInstance = import("./internal-A2RG32A3-DqUIrAtZ.js").then(({ InternalSearch: t }) => new t(P(this, ay2)))), P(this, ly).on("language-change", P(this, uy)), await this.searchInstance);
  }
};
ay2 = /* @__PURE__ */ new WeakMap(), ly = /* @__PURE__ */ new WeakMap(), uy = /* @__PURE__ */ new WeakMap(), H$3(ES, "Search");
var sy2 = ES;
var $7 = /* @__PURE__ */ new WeakMap(), uh2, Tn, DS = class DS2 {
  constructor(t, { search: e } = {}) {
    Q$3(this, uh2);
    Q$3(this, Tn);
    O(this, "Analytics");
    O(this, "Search");
    O(this, "Query");
    O(this, "internal");
    O(this, "on", H$3((t5, e4) => {
      P(this, uh2).on(t5, e4);
    }, "on"));
    O(this, "off", H$3((t5, e4) => {
      P(this, uh2).off(t5, e4);
    }, "off"));
    O(this, "getDirections", H$3((t5, e4, n4) => P(this, Tn).getDirections(t5, e4, n4), "getDirections"));
    O(this, "getDirectionsMultiDestination", H$3((t5, e4, n4) => P(this, Tn).getDirectionsMultiDestination(t5, e4, n4), "getDirectionsMultiDestination"));
    R$1(this, uh2, new Se$1()), R$1(this, Tn, t), $7.set(this, t), this.Analytics = new ty2(t.Analytics), this.Query = t.Query, this.internal = t, this.Search = new sy2(this, t, { enabled: e == null ? void 0 : e.enabled }), P(this, Tn).on("language-change", (n4) => {
      P(this, uh2).publish("language-change", n4);
    });
  }
  getEnv() {
    return P(this, Tn).getEnv();
  }
  getAccessToken() {
    var t;
    return (t = P(this, Tn).tokenManager) == null ? void 0 : t.getAccessToken().token;
  }
  get mapName() {
    return P(this, Tn).mapName;
  }
  get mapId() {
    var t;
    return (t = P(this, Tn).getMapDataOptions) == null ? void 0 : t.mapId;
  }
  get mapCenter() {
    return P(this, Tn).mapCenter;
  }
  get organizationId() {
    return P(this, Tn).organizationId;
  }
  get outdoorViewToken() {
    return P(this, Tn).outdoorViewToken;
  }
  getByType(t) {
    return P(this, Tn).getByType(t);
  }
  getById(t, e) {
    return P(this, Tn).getById(t, e);
  }
  getByExternalId(t, e) {
    return P(this, Tn).getByExternalId(t, e);
  }
  getGeoJSON(t) {
    return t.geoJSON;
  }
  async changeLanguage(t) {
    return P(this, Tn).changeLanguage(t);
  }
  get currentLanguage() {
    return P(this, Tn).currentLanguage;
  }
  get naturalBearing() {
    var t;
    return (t = P(this, Tn).naturalBearing) != null ? t : 0;
  }
  getDistance(t, e) {
    return P(this, Tn).getDistance(t, e);
  }
  toBinaryBundle({ downloadLanguagePacks: t = true } = {}) {
    return P(this, Tn).toBinaryBundle({ downloadLanguagePacks: t });
  }
  toJSONBundle({ downloadLanguagePacks: t = true } = {}) {
    return P(this, Tn).toJSONBundle({ downloadLanguagePacks: t });
  }
};
uh2 = /* @__PURE__ */ new WeakMap(), Tn = /* @__PURE__ */ new WeakMap(), H$3(DS, "MapData");
var OS = DS, cy = OS;
function py(r5) {
  let t = $7.get(r5);
  if (!t) throw new Error("MapDataInternal not found");
  return t;
}
H$3(py, "getMapDataInternal");
a();
a();
a();
a();
var UG = 1e-7;
function LS(r5) {
  return { type: "Point", coordinates: r5 };
}
H$3(LS, "point");
function zG(r5, t) {
  let { coordinates: e } = t.geometry, { coordinates: n4 } = r5.geometry, i = e.map((a4) => ql(r5, LS(a4)));
  return n4.reduce((a4, u5) => {
    let h = yv(LS(u5), i[0], r5), d = yv(LS(u5), i[1], r5), m5 = _p(h) < _p(d) ? h : d;
    return m5.properties = G$1(F$1({}, r5.properties), { entrances: [] }), a4.concat([m5]);
  }, []);
}
H$3(zG, "splitObstructionByEntrance");
function AS(r5, t) {
  return t.reduce((e, n4) => {
    let i = { epsilon: UG }, a4 = e.obstructions.findIndex((h) => ed2(qa(n4), h, i)), u5 = e.obstructions[a4];
    if (u5) {
      let [h, d] = zG(u5, n4);
      e.entrances.push(n4), e.obstructions.splice(a4, 1, h, d);
    }
    return e;
  }, { obstructions: [r5], entrances: [] });
}
H$3(AS, "findAndSplitObstructionByAllEntrances");
a();
a();
a();
a();
(function() {
  typeof globalThis != "object" && (Object.defineProperty(Object.prototype, "__magic__", { get: H$3(function() {
    return this;
  }, "get"), configurable: true }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__);
})();
var J7 = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAkGBwgHBgkICAgKCgkLDhcPDg0NDhwUFREXIh4jIyEeICAlKjUtJScyKCAgLj8vMjc5PDw8JC1CRkE6RjU7PDn/2wBDAQoKCg4MDhsPDxs5JiAmOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTn/wgARCAIABAADAREAAhEBAxEB/8QAGwABAAMBAQEBAAAAAAAAAAAAAAECAwQFBgf/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAP3EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAIAAAJAFAAAAAAAAAAAAAAAAAAAAAAAAABAgAAEgCgAAAAAAAAAAAAAAAAAAAABERLSM1zM4zXMzjMoUIqCCSSS8XNC9mpoaVomharWTQAAAAAAAAAAAAAAAAEREtIoZrnGZkucUKFStQQSTFixdNDStF0TWrmiWqbJoAAAAAAAAAAAAAIgiWkZy4HNLzHLXKcxzpzmFYmRkUKFSCCSSxcuampsbR0HSdK9R1R1HTZvWll0mlAAAAAAAAAAAIiKLnLjHNLynLXKcycxzmNYmJmUKFSCAWLFy5qamxvHQvSdJ0nVHUdFm1aparWKAjNWSKAAAAARBEtYzlyXnjmOSuM4U4q4jjOM5a5k5zAyMjOqFCCCCSSS5c0jU1NzoOk6pew7TtjuO1e0646jezWr2WSaUAAAAAECIqtZco55eY464zhTirhOI5Dks5jAwMTIzqhUqQASWLFzSNTY3Og6V646zsO2O47V7DrjqNzWy9nlZ1c0LlrLEk0EQQVipRczIyMU5q5F4U8+vOPOrgThOOuU5jAxMjMzKpUggigJiSSxY0XQ1Njc6TqjtO49CX0D0T0Y7l7E6JdzU1NEvViSalBAWIqVKLSMjIxOauM4U86vPPOrz04TjrkOYwMTIzKJQqQQCKmBJJYutzQ1Njc6TrOyO475fRPRPQjuXsToXWPn6kkkEkhCkEAgggqVMjlrzzzDy7PMPPrhOQ5jBMqoVIIIAAIAJAAJJJLFzWN16TsO49CPTPUl9Q9A6o1LFiSSSSQpCwQQCCCpVMjlrzzyzy7PMPPrhOM5kwM6zKlQQAAQASAASCxY0NI3XpOw7j0I9M9SX0z0DqjU+UqpQqVIBFgEyixJYuWLFDkrzE8o8yvOONOasipBAAAAAAAAAAABJJY2OiO1fQPUj1T0pewuVKlCCqQsBIUSSSSWLlyTM5K808pPLrzziTnrEqQQAAAAAAAAAAASSWNjojtX0D1I9VfSOuND4uzMzqhQqVIALEli5c1jUuQc1vnp5pwJzVmQQAAAAAAAAAAAAAASSaHTHevpHoHTFjMyM6zKlSpABJJcsaGkamhU5q88804E5qzIIAAAAAAAAAAAAAAJJNDpjvX0j0Dqix8dVDMolSpAqCYElixc0XU0IMjlTlrIqAAAAAAAAAAAAAAAAAWNTqjqXYGZkZpUoQQRSFIsSXLroaGhBkcqctZFQAAAAAAAAAAAAAAAACxqdUdS7EngWQCAAQASACSSSwKlSCAAAAAAAAAAAAAAAAAACSSxYFSCCAACCQACSSSwKlSCAAAAAAAAAAAAAAAAAACSSxYGIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAJAJAJBAAIAIABAAAAAAAAAAAAAAAAAAAABIAJAJAJBAAIAIABAAAAJABAAAAAAAAAJBILEli5Y0LlzQ0Lly5csWLAkgFSChUoUMyhmUMyhQqVKkEEAEAAAAAAAAAkEgsSWLljQuXNDQuXLlyxYsCSAVIKFShQzKGZQzKFCpUqQe+ZmZkUKFCpUEEAAkksWLFzQ0NTU2NzY3Og3NzoNzc2NjU1NS5csSAQVKmZmZGRiYmBgYHOYGBgYGBiZGRkUMypUqQCAASSWLFi5oaGpqbG5sbnQbm50G5ubGxqampcuWJAIIKGZmZGRiYmBgYHOYGBgYGR+jmBzmBzmJiZGZQoQQSSWLmhqbGxudB0nSdJ1HSdR1HSdJ0G5qamhcsWJJJBIIIBUqVKFDIyMDA5jmOU5TlOY5TmOc5znMTEyMyhQggFixc0NTY2NzoOk6TpOo6TqOo6TpOg3NTU0LlixJJIJBAIKkFChQyMjAwOY5jlOU5jnP00yMTnOc5zAwMjMoVIJJLmhqbmx0HQdBubmxqXLkkgAAAAAAAAAAAAAEEFTMzMTEwOc5znMDAyMyhUgkkuaGpsbnQdB0G5ubGpcuSSAAAAAAAAAAAAAAQQVKGZ1gAEEEEFSCACSSxJJJIAAAAAAAAAAAAAAAAAAAAAAABBBBBUggAkkksSSSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCCpBUqQVIKggAkFiSSxYksSSSSAAAAAAAAAAAAAAAAAAQCCpBUqQVIKggAkFiSSxYksSWBIAAKFiQAAAAAAAAACCpUoUMzIyMzMzMyhQoVKkEEAgkEkklixYuXNDQ0NTQ1NC5cuWJAAAAAAAAAAIKlShQzMjIzMzMzKFChUqQQQCCQSSSWLFyxoXNDQ1NDU0LljUkkAAAAAAAAAAggggEEAgAAAAAAAAAAAAAEkgkkkkkAAAAAAAAAAgggggEAgAAAAAEgEAAAAAAEkgkkuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADyyCCCCCCCCAQASCSQWJJJJLEkkkkkgkkEgkAEgAAEAAgEAggEEEEEEEFSCCCCCCAQASCSQWJJJJLEkkkkkgkkEgEgEgAAEAAgEAggEEEEEH5AQQQQVBBAIAAJBIJJJLEkkkkliSSSSSQSSCQSAAAQAQQCCCCCCCCCpBBBBBUEEEAgAAkEgkkksSSSSSWJJJJJJBJIJBIAABABBAIIIIIIIIKg/LCAQCACAAAACQCQSCQSASSASCQCQAAAAAAQCAQAQCAQAQQCACAAAACQCQSCQSASSASCQCQAAAAAAQCAQAQCAQfPgAAAAAAAAAAAAAAkAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAgAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/xAApEAAABQUBAQACAwACAwAAAAABAgQFFQMGERQWEhNAUAAgMGCAkKCw/9oACAEBAAECAP8AwTZznOf3mc5/YZE41xVivFyM6i7C8C8C8zMzMzMyDyDyDyDwV4K7ldSuZV5VgVwqZ/SCca4qxXmcjOouwvAvEzMzMzMzMyDyDyDwV4K7ldSuRVwKgrgf88TDWMrO4VHOo61Hao7ndzvB3k7yZ5M8i8i8zMzMzMyDyDyDyV5K8keSPJHmm8U3em70nam603Mi8qotUDfk5GqZUdfUc6jrUdqjvUeDvB3kzyZ5M8i8i8zMzMzMzMg8g8leSvJHkjyR5pvFN4pu9N2pOtNzIvKqLWA39PX+/saplJlh1tRfVcKrlVdKrrVdqrvVdzu53Y7sZ2M6mdRdRdBdJSUk5SUB0B0B1K6kdSOxHam7Unek70nei7UXWi6UXKk40l9NaRWWuB8/75E41zKjraq+q41nOq6VXas7VXeq71Hc7ud2O7GdRdRdZQXSUlJSUlAdCugOpXUjqR2I7U3em70nek70nai60XSk5UnGkvItIrKoCsC0FwLgXAuBbube3ubm7uiuFcZcZaZYdZUWVl1dwruVdzrulZ0qulVzqOR3EzgZeZcZcK0Vm3t7W1tbW1tgrBYC0q0q4q8jgRxpuVJzoulB0oOlBzoOVBworqa0iwi0i0q4FwLQWAr2trZ2trb3RWiuFcZaZadbUW1l1ZwruVd0rulZ0qulVzqOR3E7gZeZeK4VorNzb29ra2tsFe2CwFpVxVxV5HAjjTcqTnRdKDpQdKDnQcqDhRXU1pFhVm/ISUnKSkrLSsrKyspJyUhvitOtrLq69Q4qHGu41nGqvqLjrDKhUDW+nv1nP+Oc+vYVArFUEVEWUl1FfQcU7imckzinX0VxFoLgXyMlJykrLS0tLS0rKSclI74rjraq6uvUuKhxruNdxqr6i46wysVA1vp79Zz/AI5z6A4VArFUEVkWUl1FfQcU7imcUzinX0VxFoLZKTlJWVlpaXl5eWlpWUB0BzBxkDr669SvUr666stqqz1xqes/j5AxahFFJXRWp1yZemX0F5HCQkpOUlZaWlpeXl5aWB2lQdAcwcZE7hWcFLgpXqF1ZbVVnUDU9Z/HyBi1CV6SuitTrky9MvoLyL5AXEXEXIXIXKSkpKSkpIHIHIHIrkVxK4yJnCsvrra6uqpPVE354GJVpKaCtOtoryuEiZxM5C5C5C5SUnJSclJSQOQORXIrkVxBxM4VV9dbXV1VJ6om/PAxKtFTQVp1tFeRwkRWitFYKvb2tra2draBUCsFgLCrSrQWitOsqqT1RN+jAxKtJTTWFWitMtMtFYKzb29ra2tnaBUCsFZVhVpVoLRWnWVFJ6om/RgYlWkpprAW73v36zn++c+gOFQKv1GoJv04GCp9Rq/T36zn++c+gOFT7fUagm/TgYKn1+3/AKEeMefHjx8/n8vl8vn8/Hjx5xj9bjHnx48fP5/L5fL5/Px48ecY/wAvOPxceQIFIKIJgSAiBAVuK2FaitINAM4MwMwMsJCQkJCQkJCwosws4tAtItQtgtot4oRSCm+Hy8ecfi48gQKQUQTAkBECArcVsK1FaQaAZwZgZgZYSEhISEhISFhRZhZxaBaRahbBbRbxQikFN8BpfMWgWozWLaLcKAUWpq62vr/DX19YEoJARAhBvK2laytRGgjORlIyEYiMJLfJbxLdJbhLbJbRLaJbJbZLbAWxzHMcxzHMcxzHMDbBrYNbJraNbRrbPbh7dPbx7fOwHYjsZ2UzMZoM0maxbRbhQCi1NXW19fX19fW1QSAiBCDeVtK1laiNBGYjKRkIxEYSW+S3iW6S3CW2S2iW0S2S2yW2AtgLY5jmOY5jmOY5gbYNbJrZNbRraPbZ7cPbp7ePb52A7EdjOymZjW4e3D26e3j2+ZgMwmYhYxY4SEhISEBjKxlYiMJGAjAS3iW9TtynblO26dtUrap2zTtmnbNO2SW2S3isRWYGkG0EAItTW1/h8Phr6+rp6AtwtQs5mI9vntw9tHtk9s1LZqWzUto9tnts9uHt09vHt8zAZhMxCxixwkJCQkIDGVjKxEYSMBGAlvEt6nblO3Kdt0rap21TtmnbNO2SWyS2yW8ViKzA1A2ggBFqa2v8Ph8NfW1dPRFuFqMzGYjW+e3D20e2T2zUtk9tHto1tCzHYj2+e3T24e3D24a3DW4Nuc5znOc4FuBbhbcLbhLcJblO3CW4S3iMRGcrYVECcKYB+cJBoCjM2maDsZ7fPbp7cPbh7cNbhrcG3Oc5znOcC3C24W3C24S3CW5TtwluEt4jERnK2FRAnCmAfnCQaAoxb/7ePl8NbU09PT1NYKHy8Y/ZePl8NbU09PT1NYKHy8Y/4Z6+g1tjb3d+Rk5SVlZWVlZSTkd8Fu3s/b6es/pvX0Gtsbe7vyMnKSkrKysrKSciC8Fu3s/YKnrP9gqAb8X0NQawqBVCrMrMqMoGuNUTiYf4ICT5/L4/H4fD4fH4hSCmBAAP4AgctUtYqgqoqsqsqoFIVwqAb8X0NQawqBVCrMrMqMoGuNUTiYf4ICT5/L4/H4fD4fH4hSCmBAAP4AgctUtYqgqkqsqsqsFIV/Hn8XHj5/H4a+traurq6mpqampqampqampqampqampqampqamrq62tr/D4/Lx5/Fx4+fx+Gvra2rq6upqampqampqamrq6upqampqampqamrq6utra/w+Py/wCgEzNTc5OTs7PT09PT8/Pz09PT07Ozk3Ng9TMxLy0rKSclJSMhIb+9vbu9u7u7u7u7u729vb2/vyEjJSUnKSstLzEzNTc5OTs7Oz09PT8/Pz09PT07Ozk5NzUzMS8tKyknJSUjISG/v727vbu7u7u7u7u9u729v78hIyUlJykrLS8x0nR9H0fR9H0XRdF0XRdD0PQ9F0XRdF0XRdF0fR9H0nSdJ0vS9L0vTdN03TdP0/T9P0/T9P0/T9P0/T9R0/T9P0/T9P0/TdN03S9L0vS9J0nSdJ0fR9H0XRdF0PRdD0PQ9D0PRdF0XRdF0XR9H0fSdJ0nS9L0vS9N03TdN0/T9P0/T9P0/T9P0/T9P1HT9P0/T9P0/T9N03TdL0vS9L0vSS8tLy0tLS0rKysrKysrKysrKystLS0vLS8vLy8vMTExMTExMzMzMTMzMzM1NTUzMzMzMzMzMzExMTExMS8vLy8vLy8tKy0tKysrKysrKysrKysrLS0tLy0vLy8vLzExMTExMTMzMzEzMzMzNTU1MzMzMzMzMzMxMTExMTEvLy8vnOc5znOc5znOc5znOc5znOc59ZznPr169evXr169evXr169evXr16znOfWc5znOc5znOc5znOc5znOc5znOc59ZznPr169evXr169evXr169evXr16znOfWc5z/9YD//xAArEAEAAgIDAQABBAICAQUAAAAAAVICYgNRYQRBEEBQUzFCIDARYICQoLD/2gAIAQEAAz8A/wDgmhCEI/nYQj+RhjH5ccflxw44YMe0dtmzZs2bNmzZs2bIsjtiwlxy45/Ljn8se0fwuPbjj8uOPy44YQxR2izZs2bNmzZs2bNkWR2xYS45cc/lhP5Y9/wEQwj8sIRD1s2bNmzZs2bNmzZs2bNmzZs2bNmzZs2bNmyLMZYZMZ/KJ/dRDCPywhjCI/LZs2bNmzZs2bNmzZs2bNmzZs2bNmzZs2bNkWYywlhP5RP/ABj9hDGGMIh69bNmzZs2bNmzZsmybJsmybJsmybJsmybJsmybJs2bNmzZs2bNmzZ7+mMsZYyj9hDGGMIj9NmzZs2bNmzZs2bJsmybJsmybJs2TZNk2TZNk2bJs2bNmzZs2bNmzZ6iWMsXr16hiwYMGDBgwYo/T169/T162bNmzZs2TZNk2T2ntPae09pSlKUpSlPae09p7T2mybJsmzZs2bNmz17+nr16hiwYOPtx9uPtx9sO2DBih69evXr1s2bNmzZsmybJsmye09p7T2lKUpSlKU9p7T2ntNk2TZNmzZs2bNmz17+vr1s2bNmzZs2bNmzZs2evXr169bNmye09p7SlKUp/wC6UpSlKe09p7etmzZs9evWzZs2bNmzZs2bNmzZs2bPXr1s9bNmye09p7SlKUp/7pSlKUp7T29bPWz169evWzZs2bNmzZs2bNmzZs2bNmzZs2evU9plM/vJhMJ7T29bNnrZ62bNmzZs2bNmzZs2bNmzZs2bNnr39J7TKZ/eTCYT3+nr162bNnrZs2bJsntNk2TZPabNmzZs2etnr39JlM/wUwmP09etmzZs2bNk2TZNk2TZNk2bNmzZs2bNnv6TKZ/gphMfp69etk9p7T2ntKUpSlKUp7T2nt69e/pMpn+GmH/j9PXr1Pae09pSySlklKU9p7T29evf0mUz/DTCY/T16lP/AHSlKU/xUpSlP/dKUpT/ABUpT/8AQllKWTJl0y6ZdMumXTLpl0y6ZJSn+QlKWTJl0y6ZdMumXTLpl0y6ZJSn/sn9xKWXTLpn0z6Z9M+mXTLplVlVlVlVlVlVlVlVlVlVlRlVlVlRlVlVlVlVlVlVlVl0z6Z9M4/DPpn0z6ZdMkp/byll0y6Z9M+mfTPpn0y6ZVZVZVZVZVZVZVZVZUZVZUZVZVZVZVZVZVZVZVZVZVZdM+mfTOPwz6Z9M+mTJlVlVlVl0yZ9M2fTPpn0z6Z9M+mbPpn0z6Z9M2fTPpl0yqyqyqyqyqyomiaJomiaJomiaJomjRo0aNGjRo0aNGjRNE0TRNE0TRNE0TRNE0ZVZVZVZVZVZVZM+mbPpn0z6Z9M+mfTNn0z6Z9M+mfTPpl0y6ZVZVZVTVlVlRNE0TRlRNE0TRNE0TRo0aNGjRo0aNGjRomiaJomiaJomiaJomqaJqyq0TRNE0TRNE0TVNE1TVNU1TRNE1TVNU0TRNE0TRNGjRo0aNGjRhWHFHTgh88Pmj8Pnj/V89HBRwf1w4f64cNMXFSHFTFxUxcVIcP9cOGkOCkPno+ej55/D55cEuKemHUIo0aNGjRo0TRNE0TRNE0TVNE0TVNE1TVNE1TRNU0TRNE0TRNGjRo0aNGjRhWHFHThh88Pnj8Pnq+ejgo4P64cP9cOKkOKkOKmLipi4aYuH+uHBSHBSHz0fPR88/h88uCXFNWHUIo0aNGjRo4ZcU9MOoRRFGjRo0aNGjRo0aNGjRo0RRhVxR04IcGP4cGP+jij/GEMI/xjCP3+M/5xhxT/AJwhwT/o4Mv9XBk4p6YdQiiKNGjRo0aNGjRo0aNGjRoijGsOKOnBi4Mfw4I/0cUf4whhH+MYR+/xn/OMOKf84Q4J/wBHBP8Ar/zxrDCsOKkOKjhq4auGrhq4auGjipDjpDGsI/k8awwrDipDio4aOGrhq4auGrho4qQ46QxrCP8A0bHcMLQ47w4rw4buCzgs4O3A4HA4XA4HA4HA4O3BZwWcN3Fdx3hhaGNoR/Dx3DC0OO8OK8OG7gs4LODtwOBwOFwOBwOBwODtwWcFnDdxXcd4YWhjaEf88UftoQh4y6ZuRyuVzOZzeudz+uf1z+uf1z+uf1z+uf1zuf1z+uf1z+uf1z+udzR25nM5o7c3rlcrlZsniOkSj9tCEPGXTNyuVy+uZzOb1z+uf1z+uf1z+uf1z+uf1z+udz+uf1z+uf1z+uf1z+ueO3O5nM5vXK5XKzZPEdMUftoYsemHTDpx9OPpxVcVXDVw1cNXDVw0cNHDRw0cNHDRw0cNHDRw0cNHDRw0cNHDRw0cNHDVw1cNXFVxVcVXFVx9OPph0w6Yo/bQxY9MOnH04+nH04quKrhq4auGrhq4aOGjho4aOGjho4aOGkOGkOGkOGjho4aOGjho4aOGjhq4auGriq4quKriq4+nH0w6Ydf+wHgcLhcLicTjYdww7hh3DDuGPcMe4Y9ww7hh3DDuGHcONxuJxOFwuBwOB8753z2fPZ89nz3fNd893zXfPd893z3fP/Y+e757uC75/wCyHz/2Q+f+yHBd893z3fPd893z3fPd893zXfNd893z2fPZ8/b5+3zvncDgcLhcLicTjYdww7hh3DDuGHcMe4Ydww7hh3DDuGHcONxuJxOFwuBwPnfO+d89nz2fPZ893zXfPd813z3fPd893z/2Pnu+e7gu+f8Ash8/9kPn/shwXcF3z3fPd893z3fPd893zXfNd893z2fPZ8/b5+3zvncDdu3bt03bt26bpum6bpum6bt27du3bt26bt26bpum6bpum6bpum6bt03TdN26bpum6bpum7dN03TdN03TdN03TdN03Tdum7dum7dN27dum6bpum6bpum6bpum7du3bt03bpu3bpum6bpum6bpum6bpu3TdN03bpum6bpum6bt03TdN03TdN03TdN03TdN03TduysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysysmzKzKzKybMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrMrJT+2lKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSn9tKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpT/wDrA//EAB0RAAMBAAMBAQEAAAAAAAAAAAABERIwQFAgkMD/2gAIAQIBAT8A/COlKioqKioqKi+zSoqKioqL59Ro0aKyvpVlZWaNFXiVGkaNFZWV9CsrNGjRpFXepo0V8c69Zo0u1pGilfVnJWaNF+NFXNUaNFfmU0aReamkaNPzNM19VlZWaKysrK/XrKzTNGjRWaKyv+u0/8QAHREBAQACAQUAAAAAAAAAAAAAEQBAUCAQITCQwP/aAAgBAwEBPwD1NkRER07eYiIiNMRERGARERGgIiNAREZRERoCIjiYBERqiIwiI1REcCIiIiIjbkREREREfXZ//9k=";
a();
a();
var K7 = false;
function NS() {
  K7 = true;
}
H$3(NS, "enableTestMode");
function Q7() {
  return K7;
}
H$3(Q7, "isTestMode");
var kS = class kS2 {
  constructor(t) {
    O(this, "backgroundAlpha", 1);
    O(this, "backgroundColor", new Ft$3());
    O(this, "width", 0);
    O(this, "height", 0);
    O(this, "options", {});
    O(this, "renderer");
    O(this, "enabledLayers", /* @__PURE__ */ new Set([0, 1]));
    O(this, "handleWebGLContextCreationError", H$3((t5) => {
      var e4, n5;
      (n5 = (e4 = this.options).onWebGLContextCreationError) == null || n5.call(e4, t5);
    }, "handleWebGLContextCreationError"));
    O(this, "handleWebGLContextLost", H$3((t5) => {
      var e4, n5;
      (n5 = (e4 = this.options).onWebGLContextLost) == null || n5.call(e4, t5);
    }, "handleWebGLContextLost"));
    O(this, "handleWebGLContextRestored", H$3((t5) => {
      var e4, n5;
      (n5 = (e4 = this.options).onWebGLContextRestored) == null || n5.call(e4, t5);
    }, "handleWebGLContextRestored"));
    var e, n4, i, a4, u5;
    try {
      this.options = t, Q7() ? (this.renderer = { setSize: H$3(() => {
      }, "setSize"), state: { reset: H$3(() => {
      }, "reset") }, properties: { get: H$3(() => {
      }, "get") }, getSize: H$3(() => ({ width: window.innerWidth, height: innerHeight }), "getSize"), getDrawingBufferSize: H$3(() => ({ width: window.innerWidth, height: innerHeight }), "getDrawingBufferSize"), getClearAlpha: H$3(() => 1, "getClearAlpha"), getClearColor: H$3(() => new Ft$3(), "getClearColor"), autoUpdate: true, shadowMap: { autoUpdate: true }, getContext: H$3(() => ({ getContextAttributes() {
        return { alpha: true, antialias: false, depth: true, stencil: false };
      } }), "getContext"), readRenderTargetPixelsAsync: H$3(() => Promise.resolve([]), "readRenderTargetPixelsAsync"), setRenderTarget: H$3(() => {
      }, "setRenderTarget"), setClearColor: H$3(() => {
      }, "setClearColor"), clear: H$3(() => {
      }, "clear"), render: H$3(() => {
      }, "render"), clearStencil: H$3(() => {
      }, "clearStencil"), clearDepth: H$3(() => {
      }, "clearDepth"), domElement: document.createElement("canvas"), capabilities: { isWebGL2: true } }, this.renderer.domElement.style.width = "1920px", Object.defineProperty(this.renderer.domElement, "clientWidth", { value: 1920 }), this.renderer.domElement.style.height = "1080px", Object.defineProperty(this.renderer.domElement, "clientHeight", { value: 1080 })) : this.renderer = new dp$1({ canvas: t.canvas, alpha: t.alpha || false, stencil: true, antialias: typeof t.antialias == "boolean" ? t.antialias : true, powerPreference: "high-performance", preserveDrawingBuffer: true }), this.backgroundColor = new Ft$3((e = t.backgroundColor) != null ? e : "#ffffff"), this.backgroundAlpha = (n4 = t.backgroundAlpha) != null ? n4 : 1;
    } catch (h) {
      B.error(h), t.onWebGLRendererError && t.onWebGLRendererError(h);
    }
    (i = this.domElement()) == null || i.addEventListener("webglcontextlost", this.handleWebGLContextLost), (a4 = this.domElement()) == null || a4.addEventListener("webglcontextrestored", this.handleWebGLContextRestored), (u5 = this.domElement()) == null || u5.addEventListener("webglcontextcreationerror", this.handleWebGLContextCreationError);
  }
  destroy() {
    var t, e, n4, i, a4;
    this.renderer && ((e = (t = this.renderer).dispose) == null || e.call(t)), (n4 = this.domElement()) == null || n4.removeEventListener("webglcontextlost", this.handleWebGLContextLost), (i = this.domElement()) == null || i.removeEventListener("webglcontextrestored", this.handleWebGLContextRestored), (a4 = this.domElement()) == null || a4.removeEventListener("webglcontextcreationerror", this.handleWebGLContextCreationError);
  }
  render(t, e) {
    if (this.renderer) {
      this.renderer.state.reset(), e.layers.disableAll();
      for (let n4 of this.enabledLayers.values()) e.layers.enable(n4);
      this.renderer.clearStencil(), this.renderer.autoClear = false, this.renderer.setRenderTarget(null), this.renderer.render(t, e), this.renderer.clearDepth(), e.layers.disableAll(), e.layers.enable(Ro.ALWAYS_ON_TOP), this.renderer.render(t, e), this.renderer.state.reset();
    }
  }
  clear() {
    this.renderer && (this.renderer.setClearColor(this.backgroundColor, this.backgroundAlpha), this.renderer.clear());
  }
  setBufferSize(t, e) {
    p$1.env.NODE_ENV === "test" || !this.renderer || (this.width = t, this.height = e, this.renderer.setSize(t, e, false));
  }
  setBackgroundColor(t, e) {
    this.backgroundColor = t, this.backgroundAlpha = e;
  }
  domElement() {
    var t;
    return (t = this.renderer) == null ? void 0 : t.domElement;
  }
};
H$3(kS, "Renderer");
var db = kS;
a();
a();
var t9 = '"use strict";(()=>{var G=Object.defineProperty;var J=(n,e,t)=>e in n?G(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var l=(n,e,t)=>J(n,typeof e!="symbol"?e+"":e,t);function M(n,e){return e.x+e.w<n.x+n.w&&e.x>n.x&&e.y>n.y&&e.y+e.h<n.y+n.h}function j(n,e){let[t,i]=e;return t>=n.x&&t<=n.x+n.w&&i>=n.y&&i<=n.y+n.h}function q(n,e){let t=e.x,i=e.y,o=e.x+e.w,h=e.y+e.h,k=n.x,p=n.y,f=n.x+n.w,g=n.y+n.h;return t<f&&k<o&&i<g&&p<h}function c(n,e){for(let t=0;t<e.length;t++)n.push(e[t])}var s=class{constructor(e,t,i,o,h){l(this,"x");l(this,"y");l(this,"w");l(this,"h");l(this,"userData");this.userData=typeof h>"u"?null:h,this.x=e,this.y=t,this.w=i,this.h=o}contains(e){return e===this?!1:M(this,e)}intersects(e){return q(this,e)}intersectsPoint(e){return j(this,e)}draw(e){e.fillStyle="rgba(123,222,26, 0.8)",e.fillRect(this.x,this.y,this.w,this.h)}};var w=class n{constructor(e,t){l(this,"topLeft");l(this,"topRight");l(this,"bottomLeft");l(this,"bottomRight");l(this,"divided",!1);l(this,"boundary");l(this,"capacity",16);l(this,"objects",[]);l(this,"parent");this.parent=t,this.boundary=e}getSize(){return this.divided?this.objects.length+this.topLeft.getSize()+this.topRight.getSize()+this.bottomLeft.getSize()+this.bottomRight.getSize():this.objects.length}subdivide(){let{x:e,y:t,w:i,h:o}=this.boundary;this.topLeft=new n(new s(e,t,i/2,o/2),this),this.topRight=new n(new s(e+i/2,t,i/2,o/2),this),this.bottomLeft=new n(new s(e,t+o/2,i/2,o/2),this),this.bottomRight=new n(new s(e+i/2,t+o/2,i/2,o/2),this),this.divided=!0}queryRect(e){let t=[];if(this.boundary.intersects(e))t.push(...this.objects);else return[];return this.divided&&(c(t,this.topLeft.queryRect(e)),c(t,this.topRight.queryRect(e)),c(t,this.bottomLeft.queryRect(e)),c(t,this.bottomRight.queryRect(e))),t}queryPoint(e){let t=[];if(this.boundary.intersectsPoint(e))t.push(...this.objects);else return[];return this.divided&&(c(t,this.topLeft.queryPoint(e)),c(t,this.topRight.queryPoint(e)),c(t,this.bottomLeft.queryPoint(e)),c(t,this.bottomRight.queryPoint(e))),t}insert(e){return(this.parent?!this.boundary.contains(e):!this.boundary.intersects(e))?!1:this.objects.length<this.capacity?(this.objects.push(e),!0):(this.divided||this.subdivide(),(this.topLeft.insert(e)||this.topRight.insert(e)||this.bottomLeft.insert(e)||this.bottomRight.insert(e))===!1&&this.objects.push(e),!0)}drawObjects(e){this.objects.forEach(t=>t.draw(e)),this.divided&&(this.topLeft.drawObjects(e),this.topRight.drawObjects(e),this.bottomLeft.drawObjects(e),this.bottomRight.drawObjects(e))}draw(e){e.rect(this.boundary.x,this.boundary.y,this.boundary.w,this.boundary.h),this.divided&&(this.topLeft.draw(e),this.topRight.draw(e),this.bottomLeft.draw(e),this.bottomRight.draw(e)),e.strokeStyle="black",e.lineWidth=4,e.stroke()}};var d=200,S=10;function z(n,e,t,i,o,h,k="-1"){let p=1/0,f=1/0,g=-1/0,P=-1/0,O=new s(-S,0,5,t),K=new s(-S,0,e,5),W=new s(e-5,0,e+S,t),V=new s(0,t-5,e,t+S),Q=Z(e,t,i,o,h),Y=[O,K,W,V],E=new s(-d,-d,e+d*2,t+d*2);for(let r of n){let R,T;for(let u=0;u<r.bboxes.length;u++){if(r.bboxes[u]==null||(R=r.bboxes[u].boundingBox,T=r.bboxes[u].index,r.lockedToStrategyIndex!==-1&&T!==r.lockedToStrategyIndex))continue;let[I,a,b,N]=R,[m,F,D,U]=[r.y-I,r.y+a,r.x-b,r.x+N],B=D,L=m,A=U-D,_=F-m;p=Math.min(p,B)-d,f=Math.min(f,L)-d,g=Math.max(g,B+A)+d,P=Math.max(P,L+_)+d,r.bboxes[u].boundingRect=new s(B,L,A,_)}}let y={msgId:k,colliders:new Array(n.length),debug:[]},C=new w(new s(p,f,g-p,P-f)),x;for(let r=0;r<n.length;r++)if(x=n[r],y.colliders[r]=[-1,0],x.enabledAndVisible){let[R,T,u]=[1/0,-1,void 0];for(let{index:I,boundingRect:a}of x.bboxes){if(a==null)continue;let b=[];if(b=C.queryRect(a).filter(m=>a.intersects(m)),x.shouldCollideWithScreenEdges&&Y.forEach(m=>{a.intersects(m)&&b.push(m)}),a.intersects(Q)){y.colliders[r]=[-1,0,a];break}if(b.length<=R&&(u=a,T=I,R=b.length),b.length===0){C.insert(a),y.colliders[r]=[I,E.contains(a)?0:1,a];break}}x.rank===5&&u!=null&&(C.insert(u),y.colliders[r]=[T,E.contains(u)?0:1,u])}else y.colliders[r]=[-1,0];return y}function Z(n,e,t,i,o){switch(o){case"top-right":return new s(n-t,0,t,i);case"bottom-left":return new s(0,e-i,t,i);case"bottom-right":return new s(n-t,e-i,t,i);case"top-left":return new s(0,0,t,i)}}function X(n){let e=n[0].map(t=>{let i=t[0].map(o=>({index:o[4],boundingBox:[o[0],o[1],o[2],o[3]]}));return{enabledAndVisible:t[1]===1,rank:t[2]===1?5:0,x:t[3],y:t[4],shouldCollideWithScreenEdges:t[5]===1,bboxes:i,lockedToStrategyIndex:t[6]}});return{msgId:"-1",totalWidth:n[3],totalHeight:n[2],watermarkWidth:n[4],watermarkHeight:n[5],watermarkPosition:n[6],colliders:e,devicePixelRatio:n[1]}}self.onmessage=n=>{let e=X(n.data);self.postMessage(z(e.colliders,e.totalWidth,e.totalHeight,e.watermarkWidth,e.watermarkHeight,e.watermarkPosition,e.msgId))};})();\n';
a();
a();
a();
a();
a();
function e9(r5, t) {
  return t.x + t.w < r5.x + r5.w && t.x > r5.x && t.y > r5.y && t.y + t.h < r5.y + r5.h;
}
H$3(e9, "contains");
a();
function r9(r5, t) {
  let [e, n4] = t;
  return e >= r5.x && e <= r5.x + r5.w && n4 >= r5.y && n4 <= r5.y + r5.h;
}
H$3(r9, "intersectPoint");
a();
function n9(r5, t) {
  let e = t.x, n4 = t.y, i = t.x + t.w, a4 = t.y + t.h, u5 = r5.x, h = r5.y, d = r5.x + r5.w, m5 = r5.y + r5.h;
  return e < d && u5 < i && n4 < m5 && h < a4;
}
H$3(n9, "intersects");
a();
function au2(r5, t) {
  for (let e = 0; e < t.length; e++) r5.push(t[e]);
}
H$3(au2, "appendItems");
a();
var RS = class RS2 {
  constructor(t, e, n4, i, a4) {
    O(this, "x");
    O(this, "y");
    O(this, "w");
    O(this, "h");
    O(this, "userData");
    this.userData = typeof a4 > "u" ? null : a4, this.x = t, this.y = e, this.w = n4, this.h = i;
  }
  contains(t) {
    return t === this ? false : e9(this, t);
  }
  intersects(t) {
    return n9(this, t);
  }
  intersectsPoint(t) {
    return r9(this, t);
  }
  draw(t) {
    t.fillStyle = "rgba(123,222,26, 0.8)", t.fillRect(this.x, this.y, this.w, this.h);
  }
};
H$3(RS, "Rectangle");
var Nr = RS;
var ch2 = class ch3 {
  constructor(t, e) {
    O(this, "topLeft");
    O(this, "topRight");
    O(this, "bottomLeft");
    O(this, "bottomRight");
    O(this, "divided", false);
    O(this, "boundary");
    O(this, "capacity", 16);
    O(this, "objects", []);
    O(this, "parent");
    this.parent = e, this.boundary = t;
  }
  getSize() {
    return this.divided ? this.objects.length + this.topLeft.getSize() + this.topRight.getSize() + this.bottomLeft.getSize() + this.bottomRight.getSize() : this.objects.length;
  }
  subdivide() {
    let { x: t, y: e, w: n4, h: i } = this.boundary;
    this.topLeft = new ch3(new Nr(t, e, n4 / 2, i / 2), this), this.topRight = new ch3(new Nr(t + n4 / 2, e, n4 / 2, i / 2), this), this.bottomLeft = new ch3(new Nr(t, e + i / 2, n4 / 2, i / 2), this), this.bottomRight = new ch3(new Nr(t + n4 / 2, e + i / 2, n4 / 2, i / 2), this), this.divided = true;
  }
  queryRect(t) {
    let e = [];
    if (this.boundary.intersects(t)) e.push(...this.objects);
    else return [];
    return this.divided && (au2(e, this.topLeft.queryRect(t)), au2(e, this.topRight.queryRect(t)), au2(e, this.bottomLeft.queryRect(t)), au2(e, this.bottomRight.queryRect(t))), e;
  }
  queryPoint(t) {
    let e = [];
    if (this.boundary.intersectsPoint(t)) e.push(...this.objects);
    else return [];
    return this.divided && (au2(e, this.topLeft.queryPoint(t)), au2(e, this.topRight.queryPoint(t)), au2(e, this.bottomLeft.queryPoint(t)), au2(e, this.bottomRight.queryPoint(t))), e;
  }
  insert(t) {
    return (this.parent ? !this.boundary.contains(t) : !this.boundary.intersects(t)) ? false : this.objects.length < this.capacity ? (this.objects.push(t), true) : (this.divided || this.subdivide(), (this.topLeft.insert(t) || this.topRight.insert(t) || this.bottomLeft.insert(t) || this.bottomRight.insert(t)) === false && this.objects.push(t), true);
  }
  drawObjects(t) {
    this.objects.forEach((e) => e.draw(t)), this.divided && (this.topLeft.drawObjects(t), this.topRight.drawObjects(t), this.bottomLeft.drawObjects(t), this.bottomRight.drawObjects(t));
  }
  draw(t) {
    t.rect(this.boundary.x, this.boundary.y, this.boundary.w, this.boundary.h), this.divided && (this.topLeft.draw(t), this.topRight.draw(t), this.bottomLeft.draw(t), this.bottomRight.draw(t)), t.strokeStyle = "black", t.lineWidth = 4, t.stroke();
  }
};
H$3(ch2, "QuadTree");
var Ls2 = ch2;
a();
a();
var i9 = ["", "", "low", "medium", "high", "always-visible"];
function o9(r5) {
  return Math.min(5, Math.max(2, r5));
}
H$3(o9, "clampTierNumber");
function Dd(r5) {
  if (typeof r5 == "number") return o9(r5);
  let t = i9.indexOf(r5);
  return t === -1 ? 3 : t;
}
H$3(Dd, "convertCollisionRankingTierToNumber");
function hy(r5) {
  let t = o9(r5);
  return i9[t];
}
H$3(hy, "convertNumberToCollisionRankingTier");
function s9(r5, t, e) {
  let n4, i, a4, u5 = null, h = 0;
  e || (e = {});
  let d = H$3(function() {
    h = e.leading === false ? 0 : Date.now(), u5 = null, a4 = r5.apply(n4, i), u5 || (n4 = i = null);
  }, "later");
  return function() {
    let m5 = Date.now();
    !h && e.leading === false && (h = m5);
    let v3 = t - (m5 - h);
    return n4 = globalThis, i = arguments, v3 <= 0 || v3 > t ? (u5 && (clearTimeout(u5), u5 = null), h = m5, a4 = r5.apply(n4, i), u5 || (n4 = i = null)) : !u5 && e.trailing !== false && (u5 = setTimeout(d, v3)), a4;
  };
}
H$3(s9, "throttle");
function a9(r5) {
  let t = r5[0].map((e) => {
    let n4 = e[0].map((i) => ({ index: i[4], boundingBox: [i[0], i[1], i[2], i[3]] }));
    return { enabledAndVisible: e[1] === 1, rank: e[2] === 1 ? 5 : 0, x: e[3], y: e[4], shouldCollideWithScreenEdges: e[5] === 1, bboxes: n4, lockedToStrategyIndex: e[6] };
  });
  return { msgId: "-1", totalWidth: r5[3], totalHeight: r5[2], watermarkWidth: r5[4], watermarkHeight: r5[5], watermarkPosition: r5[6], colliders: t, devicePixelRatio: r5[1] };
}
H$3(a9, "unpackMessage");
a();
a();
var Ic2 = 200, mb = 10;
function l9(r5, t, e, n4, i, a4, u5 = "-1") {
  let h = 1 / 0, d = 1 / 0, m5 = -1 / 0, v3 = -1 / 0, x2 = new Nr(-mb, 0, 5, e), S4 = new Nr(-mb, 0, t, 5), I3 = new Nr(t - 5, 0, t + mb, e), w3 = new Nr(0, e - 5, t, e + mb), E4 = XG(t, e, n4, i, a4), T3 = [x2, S4, I3, w3], D4 = new Nr(-Ic2, -Ic2, t + Ic2 * 2, e + Ic2 * 2);
  for (let j3 of r5) {
    let W4, $5;
    for (let F3 = 0; F3 < j3.bboxes.length; F3++) {
      if (j3.bboxes[F3] == null || (W4 = j3.bboxes[F3].boundingBox, $5 = j3.bboxes[F3].index, j3.lockedToStrategyIndex !== -1 && $5 !== j3.lockedToStrategyIndex)) continue;
      let [J4, ot2, K4, H5] = W4, [_t2, ct2, ft2, mt2] = [j3.y - J4, j3.y + ot2, j3.x - K4, j3.x + H5], St2 = ft2, dt2 = _t2, xt2 = mt2 - ft2, q4 = ct2 - _t2;
      h = Math.min(h, St2) - Ic2, d = Math.min(d, dt2) - Ic2, m5 = Math.max(m5, St2 + xt2) + Ic2, v3 = Math.max(v3, dt2 + q4) + Ic2, j3.bboxes[F3].boundingRect = new Nr(St2, dt2, xt2, q4);
    }
  }
  let A3 = { msgId: u5, colliders: new Array(r5.length), debug: [] }, L3 = new Ls2(new Nr(h, d, m5 - h, v3 - d)), B3;
  for (let j3 = 0; j3 < r5.length; j3++) if (B3 = r5[j3], A3.colliders[j3] = [-1, 0], B3.enabledAndVisible) {
    let [W4, $5, F3] = [1 / 0, -1, void 0];
    for (let { index: J4, boundingRect: ot2 } of B3.bboxes) {
      if (ot2 == null) continue;
      let K4 = [];
      if (K4 = L3.queryRect(ot2).filter((_t2) => ot2.intersects(_t2)), B3.shouldCollideWithScreenEdges && T3.forEach((_t2) => {
        ot2.intersects(_t2) && K4.push(_t2);
      }), ot2.intersects(E4)) {
        A3.colliders[j3] = [-1, 0, ot2];
        break;
      }
      if (K4.length <= W4 && (F3 = ot2, $5 = J4, W4 = K4.length), K4.length === 0) {
        L3.insert(ot2), A3.colliders[j3] = [J4, D4.contains(ot2) ? 0 : 1, ot2];
        break;
      }
    }
    B3.rank === 5 && F3 != null && (L3.insert(F3), A3.colliders[j3] = [$5, D4.contains(F3) ? 0 : 1, F3]);
  } else A3.colliders[j3] = [-1, 0];
  return A3;
}
H$3(l9, "processColliders");
function XG(r5, t, e, n4, i) {
  switch (i) {
    case "top-right":
      return new Nr(r5 - e, 0, e, n4);
    case "bottom-left":
      return new Nr(0, t - n4, e, n4);
    case "bottom-right":
      return new Nr(r5 - e, t - n4, e, n4);
    case "top-left":
      return new Nr(0, 0, e, n4);
  }
}
H$3(XG, "getWatermarkBoundary");
var FS = class FS2 {
  constructor() {
    O(this, "onmessage", H$3(() => {
    }, "onmessage"));
    O(this, "postMessage", H$3((t) => {
      let e = a9(t);
      this.onmessage({ data: l9(e.colliders, e.totalWidth, e.totalHeight, e.watermarkWidth, e.watermarkHeight, e.watermarkPosition, e.msgId) });
    }, "postMessage"));
    O(this, "terminate", H$3(() => {
    }, "terminate"));
  }
};
H$3(FS, "SyncWorker");
var gb = FS;
var ph2 = false, YG = 150, BS = class BS2 extends Se$1 {
  constructor(e, n4, i = true) {
    super();
    O(this, "worker");
    O(this, "debugContext");
    O(this, "debugCanvas");
    O(this, "collidersDirty", true);
    O(this, "packedMessage", [[], 0, 0, 0, 0, 0, "bottom-left"]);
    O(this, "visibleCollidersQTree", new Ls2(new Nr(0, 0, 0, 0)));
    O(this, "interactiveCollidersQTree", new Ls2(new Nr(0, 0, 0, 0)));
    O(this, "coreState");
    O(this, "postMessage");
    O(this, "showCollisionBoxes", H$3(() => {
      ph2 = true, this.debugCanvas.style.display = "block";
    }, "showCollisionBoxes"));
    O(this, "hideCollisionBoxes", H$3(() => {
      ph2 = false, this.debugContext.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height), this.debugCanvas.style.display = "none";
    }, "hideCollisionBoxes"));
    O(this, "currentMsgId", "");
    O(this, "working", false);
    O(this, "_postMessage", H$3(() => {
      this.worker.postMessage(this.packedMessage);
    }, "_postMessage"));
    O(this, "componentArray", []);
    O(this, "update", H$3((e4, n5, i5 = "bottom-left", a4 = false) => {
      let u5 = false;
      if (this.collidersDirty) {
        this.packedMessage = [[], 0, 0, 0, 0, 0, "bottom-left"], this.componentArray = [];
        let h;
        for (let d of this.coreState.geometry2DIdsInScene) {
          let m5 = this.coreState.geometry2DMap.get(d);
          m5 && (h = m5.components[0], this.componentArray.push(h));
        }
        this.resize(e4, n5, i5), this.collidersDirty = false, u5 = true;
      } else u5 = this.componentArray.some((h) => h.collisionDirty === true);
      u5 && this.componentArray.sort((h, d) => d.rank - h.rank);
      for (let h = 0; h < this.componentArray.length; h++) if (this.packedMessage) {
        let d = this.componentArray[h].toPackedMessage(a4 && !u5);
        this.packedMessage[0][h] == null && (this.packedMessage[0][h] = []), this.packedMessage[0][h][0] == null && (this.packedMessage[0][h][0] = []), this.packedMessage[0][h][0] = d.bboxes, this.packedMessage[0][h][1] = d.enabled && this.componentArray[h].visible && !this.componentArray[h].isOccluded ? 1 : 0, this.packedMessage[0][h][2] = d.rank === 5 ? 1 : 0, this.packedMessage[0][h][3] = d.x, this.packedMessage[0][h][4] = d.y, this.packedMessage[0][h][5] = d.shouldCollideWithScreenEdges ? 1 : 0, this.packedMessage[0][h][6] = d.lockedToStrategyIndex;
      }
      this.working || this.postMessage();
    }, "update"));
    O(this, "resolve", H$3((e4) => {
      if (this.working = false, this.collidersDirty || !e4.data) return;
      let n5 = e4.data.colliders, i5 = -1, a4, u5, h;
      ph2 && (this.visibleCollidersQTree = new Ls2(new Nr(0, 0, this.debugCanvas.width, this.debugCanvas.height))), this.interactiveCollidersQTree = new Ls2(new Nr(0, 0, this.debugCanvas.width, this.debugCanvas.height));
      for (let d = 0; d < this.componentArray.length; d++) {
        let m5 = this.componentArray[d];
        n5[d] != null && (i5 = n5[d][0], a4 = n5[d][2], m5.offscreen = n5[d][1] === 1, i5 !== -1 && a4 != null ? (h = new Nr(a4.x, a4.y, a4.w, a4.h, { entityId: m5.id }), ph2 && this.visibleCollidersQTree.insert(h), u5 = this.coreState.geometry2DMap.get(m5.id), (u5 == null ? void 0 : u5.components[1]) != null && this.interactiveCollidersQTree.insert(new Nr(a4.x, a4.y, a4.w, a4.h, { entityId: m5.id })), (m5.canShow === false || m5.visibilityNeedsUpdate !== false) && "visibilityNeedsUpdate" in m5 && (m5.visibilityNeedsUpdate = "show"), i5 !== -1 && i5 !== m5.currentStrategyIndex && (m5.activeBoundingBox = h, m5.onStrategySelected(i5))) : ((m5.canShow === true || m5.visibilityNeedsUpdate !== false) && "visibilityNeedsUpdate" in m5 && (m5.visibilityNeedsUpdate = "hide"), i5 !== -1 && i5 !== m5.currentStrategyIndex && m5.onStrategySelected(i5)));
      }
      ph2 && this.drawDebug(), this.publish("visibility-changed");
    }, "resolve"));
    O(this, "drawDebug", H$3(() => {
      ph2 && this.visibleCollidersQTree && (this.debugContext.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height), this.debugContext.beginPath(), this.visibleCollidersQTree.drawObjects(this.debugContext));
    }, "drawDebug"));
    O(this, "destroy", H$3(() => {
      this.worker.terminate();
    }, "destroy"));
    this.worker = i === false ? new gb() : hh2 !== "" ? new Worker(hh2) : new Worker(URL.createObjectURL(new Blob([t9], { type: "text/javascript" }))), this.coreState = n4, this.debugCanvas = e, this.debugContext = e.getContext("2d"), this.worker.onmessage = (a4) => this.resolve(a4), this.postMessage = s9(this._postMessage, YG, false), ph2 ? this.showCollisionBoxes() : this.hideCollisionBoxes();
  }
  resize(e, n4, i) {
    this.packedMessage[6] = i, this.packedMessage[5] = n4, this.packedMessage[4] = e, this.packedMessage[3] = this.debugCanvas.width, this.packedMessage[2] = this.debugCanvas.height;
  }
};
H$3(BS, "CollisionSystem");
var yb = BS;
a();
a();
a();
a();
var VS = class VS2 {
  constructor(t) {
    O(this, "type");
    O(this, "event");
    this.type = 0, this.event = t;
  }
  get timestamp() {
    return this.event.timeStamp;
  }
};
H$3(VS, "Tap");
var vb = VS, jS = class jS2 {
  constructor() {
    O(this, "taps", []);
  }
  add(t) {
    this.lastPointerDown && t.timestamp - this.lastPointerDown.timestamp < 50 ? this.lastPointerDown.type = 1 : this.taps.push(t);
  }
  get lastPointerDown() {
    return this.taps.length >= 1 ? this.taps[this.taps.length - 1] : void 0;
  }
  get isSingleTapWithTwoFingers() {
    var t;
    return this.isSingleTap && ((t = this.lastPointerDown) == null ? void 0 : t.type) === 1;
  }
  get isSingleTapWithOneFinger() {
    var t;
    return this.isSingleTap && ((t = this.lastPointerDown) == null ? void 0 : t.type) === 0;
  }
  get isDoubleTapWithOneFinger() {
    var t, e;
    return this.isDoubleTap && ((t = this.taps[0]) == null ? void 0 : t.type) === 0 && ((e = this.taps[1]) == null ? void 0 : e.type) === 0;
  }
  get isSingleTap() {
    return this.taps.length === 1;
  }
  get isDoubleTap() {
    return this.taps.length === 2;
  }
  discardOutsideOfWaitWindow(t) {
    this.taps = this.taps.filter((e) => t - e.timestamp < 300);
  }
  flush() {
    this.taps = [];
  }
  get _taps() {
    return this.taps;
  }
  destroy() {
    this.flush();
  }
};
H$3(jS, "TapsController");
var bb = jS;
a();
function US(r5) {
  let t = /* @__PURE__ */ new Set();
  for (let e of r5) {
    let n4 = e.object;
    for (; n4.visible && n4.parent && n4.parent.visible === true && !t.has(n4.parent); ) n4 = n4.parent, n4 instanceof z && n4.type === "group-container" && n4.visible && n4.components[1] && t.add(n4);
  }
  return Array.from(t);
}
H$3(US, "getUniqueIntersectedGroupContainers");
var Ld2, zS = class zS2 extends Se$1 {
  constructor(e, n4, i, a4, u5) {
    super();
    O(this, "raycaster", new Yl$2());
    O(this, "state", { hovered3DEntity: void 0, hovered2DEntity: void 0, hovered3DContainers: void 0, lastHover: void 0, interaction: { mouseDownStart: void 0, distanceFromMouseDown: void 0, isPanning: false } });
    O(this, "coreState");
    O(this, "camera");
    O(this, "worldPlane");
    O(this, "_quadtree", new Ls2(new Nr(0, 0, 0, 0)));
    O(this, "_container");
    O(this, "lastPointerEvent");
    O(this, "cursor", "grab");
    O(this, "touchesCount", 0);
    O(this, "isUserInteracting");
    O(this, "hasTouched", false);
    Q$3(this, Ld2);
    O(this, "onPointerMoveRaf", H$3((e4) => {
      this.lastPointerEvent = e4, P(this, Ld2) && cancelAnimationFrame(P(this, Ld2)), R$1(this, Ld2, requestAnimationFrame(() => {
        this.onPointerMove(e4);
      }));
    }, "onPointerMoveRaf"));
    O(this, "onPointerMove", H$3((e4) => {
      e4.preventDefault(), this.updateInteractionStateIfPanning(e4), (e4.pointerType !== "touch" || e4.pointerType === void 0 && this.hasTouched) && this.handleHover(e4), this.handleCursor();
    }, "onPointerMove"));
    O(this, "tapsControl", new bb());
    O(this, "onPointerDown", H$3((e4) => {
      e4.target === this._container && (this._container.addEventListener("pointerup", this.onPointerUp, false), this._container.addEventListener("pointercancel", this.onPointerUp, false), this.state.interaction.mouseDownStart = { time: Date.now(), timestamp: e4.timeStamp, clientX: e4.clientX, clientY: e4.clientY }, this.lastPointerEvent = e4, this.state.interaction.distanceFromMouseDown = 0, this.handleCursor(), e4.pointerType === "touch" && (this.tapsControl.add(new vb(e4)), this.touchesCount = Math.max(0, this.touchesCount + 1)));
    }, "onPointerDown"));
    O(this, "clickTimeout");
    O(this, "onPointerUp", H$3((e4) => {
      this.tapsControl.discardOutsideOfWaitWindow(e4.timeStamp), this.lastPointerEvent = e4, this.touchesCount = Math.max(0, this.touchesCount - 1), this.touchesCount === 0 && (this._container.removeEventListener("pointerup", this.onPointerUp, false), this._container.removeEventListener("pointercancel", this.onPointerUp, false)), this.updateInteractionStateIfPanning(e4);
      let { mouseDownStart: n5 } = this.state.interaction;
      !n5 || this.state.interaction.distanceFromMouseDown == null || (Date.now() < n5.time + 300 && (this.tapsControl.isSingleTapWithTwoFingers || this.state.interaction.distanceFromMouseDown <= 15) && (e4.pointerType === "touch" ? this.tapsControl.isSingleTapWithTwoFingers ? (this.publish("singletap-with-twofinger", e4), this.flush()) : this.tapsControl.isSingleTapWithOneFinger && this.touchesCount === 0 ? (this.clickTimeout && clearTimeout(this.clickTimeout), this.clickTimeout = window.setTimeout(() => {
        this.handleClick(e4), this.flush();
      }, 300)) : this.tapsControl.isDoubleTapWithOneFinger && (this.publish("doubletap-with-onefinger", e4), this.flush()) : this.handleClick(e4)), this.state.interaction.mouseDownStart = void 0, this.state.interaction.distanceFromMouseDown = void 0, this.state.interaction.isPanning = false, this.handleCursor());
    }, "onPointerUp"));
    O(this, "dirty3D", true);
    O(this, "cachedHitBoxes", { entities: [] });
    O(this, "ndcPoint", new ot$1());
    O(this, "debugPanel");
    this.isUserInteracting = u5, this.raycaster.layers.enableAll(), this.raycaster.layers.disable(1), this.camera = i, this._container = e, this.coreState = n4, this.worldPlane = a4, this._container.addEventListener("pointerdown", this.onPointerDown, false), this._container.addEventListener("pointermove", this.onPointerMoveRaf, false), this._container.classList.add("mappedin-interactive");
  }
  updateQuadtree(e) {
    this._quadtree = e;
  }
  setHovered3DEntityInteractionComponentDirty() {
    if (this.state.hovered3DEntity) {
      let e = this.state.hovered3DEntity.components[2];
      e && (e.dirty = true);
    }
  }
  getThreeDIntersectsFromXY(e) {
    this.raycaster.setFromCamera(e, this.camera), this.raycaster.layers.enable(0);
    let n4 = this.raycaster.intersectObjects(this._hitBoxes.entities, true).filter((a4) => {
      var u5, h;
      return ((u5 = a4.object) == null ? void 0 : u5.name) === "worldPlane" || ((h = a4.object) == null ? void 0 : h.visible);
    }), i = n4.findIndex((a4) => {
      var u5;
      return ((u5 = a4.object) == null ? void 0 : u5.name) === "worldPlane";
    });
    return i !== -1 && n4.push(n4.splice(i, 1)[0]), n4;
  }
  getGroupContainerIntersectsFromXY(e) {
    let n4 = this.getThreeDIntersectsFromXY(e), i;
    return n4 != null && n4.length > 0 && (i = US(n4)), i;
  }
  flush() {
    this.tapsControl.flush(), this.clickTimeout != null && (clearTimeout(this.clickTimeout), this.clickTimeout = void 0);
  }
  handleHover(e) {
    let n4 = e || this.lastPointerEvent;
    if (this.state.interaction.mouseDownStart || !n4 || this.isUserInteracting()) return;
    let { entity3D: i, entity2D: a4, position: u5, groupContainers: h } = this.intersect(n4);
    (this.detect3DEntityHover(i) || this.detect2DEntityHover(a4) || this.detect3DContainerHover(h)) && (this.state.hovered3DEntity = i, this.state.lastHover = i, this.state.hovered2DEntity = a4, this.state.hovered3DContainers = h, this.publish("hover", { entity2D: this.state.hovered2DEntity, entity3D: this.state.hovered3DEntity, position: u5, groupContainers: h })), this.handleCursor();
  }
  handleCursor() {
    var u5;
    let e = !!(this.state.hovered3DEntity && ((u5 = this.state.hovered3DEntity) != null && u5.components[2]) || this.state.hovered2DEntity), n4 = !!this.state.interaction.mouseDownStart, i = this.state.interaction.isPanning, a4 = $G(e, i, n4);
    this.cursor !== a4 && (this.cursor = a4, a4 === "pointer" ? this._container.classList.add("mappedin-interaction-hover") : this._container.classList.remove("mappedin-interaction-hover"));
  }
  detect2DEntityHover(e) {
    return this.state.hovered2DEntity !== e;
  }
  handleClick(e) {
    let n4 = this.intersect(e);
    this.publish("click", { entity2D: n4.entity2D, entity3D: n4.entity3D, position: n4.position, groupContainers: n4.groupContainers, pointerEvent: { button: e.button } });
  }
  get _hitBoxes() {
    if (this.dirty3D) {
      this.cachedHitBoxes.entities = [];
      let e;
      for (let n4 of this.coreState.geometry3DIdsInScene) e = this.coreState.geometry3DMap.get(n4), ((e == null ? void 0 : e.type) === "geometry" || (e == null ? void 0 : e.type) === "model" || (e == null ? void 0 : e.type) === "path" || (e == null ? void 0 : e.type) === "custom-geometry") && e.components[0].mesh && !this.cachedHitBoxes.entities.includes(e.components[0].mesh) && this.cachedHitBoxes.entities.push(e.components[0].mesh);
      return this.dirty3D = false, this.cachedHitBoxes.entities.push(this.worldPlane), this.cachedHitBoxes;
    }
    return this.cachedHitBoxes;
  }
  intersect(e) {
    var D4, A3, L3, B3, j3;
    let n4 = [e.offsetX, e.offsetY], i = this._quadtree.queryPoint(n4), [a4] = i.filter((W4) => W4.intersectsPoint(n4)), u5 = this.coreState.containerOffset[0], h = this.coreState.containerOffset[1];
    this.ndcPoint.x = (e.clientX - h) / this._container.clientWidth * 2 - 1, this.ndcPoint.y = -((e.clientY - u5) / this._container.clientHeight) * 2 + 1;
    let d = this.getThreeDIntersectsFromXY(this.ndcPoint), m5 = (D4 = d[0]) == null ? void 0 : D4.point, v3 = [], x2 = [], S4 = d.filter((W4) => W4.object.name !== "worldPlane");
    for (let W4 of S4) W4.object instanceof ye$1 && W4.object.material.depthTest === false ? v3.push(W4) : x2.push(W4);
    let I3 = (L3 = (A3 = v3[0]) != null ? A3 : x2[0]) != null ? L3 : void 0, w3, E4;
    if (I3 != null) {
      if (w3 = KG(I3.object, this.coreState.geometry3DMap), !w3) {
        let W4 = (B3 = I3 == null ? void 0 : I3.instanceId) != null ? B3 : I3 == null ? void 0 : I3.batchId;
        w3 = W4 != null && (I3 != null && I3.object.userData.entities) ? this.coreState.geometry3DMap.get(I3 == null ? void 0 : I3.object.userData.entities[W4]) : this.coreState.geometry3DMap.get(I3 == null ? void 0 : I3.object.userData.entityId);
      }
      w3 != null && w3.components[2] && (E4 = w3);
    }
    let T3 = US(S4);
    return { entity2D: ((j3 = a4 == null ? void 0 : a4.userData) == null ? void 0 : j3.entityId) === "watermark" ? { id: "watermark" } : this.coreState.geometry2DMap.get(a4 == null ? void 0 : a4.userData.entityId), entity3D: E4, position: m5, groupContainers: T3.length > 0 ? T3 : void 0 };
  }
  detect3DEntityHover(e) {
    return this.state.lastHover !== e && (this.state.lastHover && c9(this.state.lastHover, false, this.coreState), e && c9(e, true, this.coreState)), this.state.hovered3DEntity !== e;
  }
  detect3DContainerHover(e) {
    return !Or$1(this.state.hovered3DContainers, e);
  }
  updateInteractionStateIfPanning(e) {
    this.state.interaction.mouseDownStart && (this.state.interaction.distanceFromMouseDown = Math.sqrt(Math.pow(e.clientX - this.state.interaction.mouseDownStart.clientX, 2) + Math.pow(e.clientY - this.state.interaction.mouseDownStart.clientY, 2)), !this.state.interaction.isPanning && this.state.interaction.distanceFromMouseDown > 15 && (this.state.interaction.isPanning = true));
  }
  getMouseRayIntersects() {
    return this.raycaster.intersectObjects([this.worldPlane], false);
  }
  destroy() {
    this._container.removeEventListener("pointerdown", this.onPointerDown, false), this._container.removeEventListener("pointermove", this.onPointerMoveRaf, false), this._container.removeEventListener("pointerup", this.onPointerUp, false), this._container.removeEventListener("pointercancel", this.onPointerUp, false);
  }
  enableDebug() {
    let e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "0", e.style.right = "0", e.style.backgroundColor = "white", e.style.padding = "10px", document.body.append(e), e.id = "interaction-debug-panel", this.debugPanel = e, this.on("doubletap-with-onefinger", () => {
      this.queueDebugMessage("doubletap-with-onefinger", "#ffadad");
    }), this.on("singletap-with-twofinger", () => {
      this.queueDebugMessage("singletap-with-twofinger", "#ffd6a5");
    }), this.on("click", (n4) => {
      var i, a4, u5;
      this.queueDebugMessage("CLICK \n3D: ".concat((i = n4.entity3D) == null ? void 0 : i.id, " \n2D: ").concat((a4 = n4.entity2D) == null ? void 0 : a4.id, " \nPos: ").concat((u5 = n4.position) == null ? void 0 : u5.toArray().join(", ")), "#fdffb6");
    }), this.on("hover", (n4) => {
      var i, a4, u5;
      this.queueDebugMessage("HOVER \n3D: ".concat((i = n4.entity3D) == null ? void 0 : i.id, " \n2D: ").concat((a4 = n4.entity2D) == null ? void 0 : a4.id, " \nPos: ").concat((u5 = n4.position) == null ? void 0 : u5.toArray().join(", ")), "#caffbf");
    });
  }
  get _state() {
    return this.state;
  }
  queueDebugMessage(e, n4) {
    var a4;
    let i = document.createElement("pre");
    i.style.maxWidth = "300px", i.style.transition = "opacity 500ms cubic-bezier(0.4, 0, 0.2, 1)", i.style.backgroundColor = n4, i.textContent = e, (a4 = this.debugPanel) == null || a4.prepend(i), setTimeout(() => {
      i.style.opacity = "0", setTimeout(() => {
        i.remove();
      }, 500);
    }, 2500);
  }
  getCursor() {
    return this.cursor;
  }
};
Ld2 = /* @__PURE__ */ new WeakMap(), H$3(zS, "InteractionSystem");
var dy2 = zS;
function c9(r5, t, e) {
  var u5;
  let n4 = r5.components[2];
  n4 && n4.hover !== true && (n4.hover = t ? "user-interaction" : false, n4.dirty = true);
  let i = (u5 = r5.components[0].textMesh) == null ? void 0 : u5.userData.entityId;
  if (!i) return;
  let a4 = e.geometry3DMap.get(i);
  (a4 == null ? void 0 : a4.type) === "text3d" && (a4.components[1].hoverByPolygon = t, a4.components[1].dirty = true);
}
H$3(c9, "updateHover");
function $G(r5, t, e) {
  return t ? "grabbing" : r5 ? "pointer" : e ? "grabbing" : "grab";
}
H$3($G, "processCursor");
function JG(r5) {
  let t = r5;
  for (; t != null && t.parent; ) {
    if (t instanceof hl$2) return;
    if (t.userData.isSingleModel) return t;
    t = t.parent;
  }
}
H$3(JG, "findModelParent");
function KG(r5, t) {
  let e = JG(r5);
  return e ? t.get(e.userData.entityId) : void 0;
}
H$3(KG, "findModelParentEntity");
a();
a();
a();
var Q = {};
M$1(Q, { BRAND: () => IV, DIRTY: () => fh2, EMPTY_PATH: () => rV, INVALID: () => ae, NEVER: () => lj, OK: () => ao, ParseStatus: () => Xi, Schema: () => Ce, ZodAny: () => wc2, ZodArray: () => pu2, ZodBigInt: () => gh3, ZodBoolean: () => yh3, ZodBranded: () => _y, ZodCatch: () => Ph3, ZodDate: () => vh3, ZodDefault: () => wh3, ZodDiscriminatedUnion: () => Mb, ZodEffects: () => ks2, ZodEnum: () => Mh3, ZodError: () => Uo, ZodFirstPartyTypeKind: () => ce, ZodFunction: () => wb, ZodIntersection: () => Ch3, ZodIssueCode: () => Pt2, ZodLazy: () => Sh3, ZodLiteral: () => Ih2, ZodMap: () => Vd, ZodNaN: () => Ud, ZodNativeEnum: () => Th3, ZodNever: () => fa2, ZodNull: () => xh3, ZodNullable: () => hl, ZodNumber: () => mh2, ZodObject: () => zo, ZodOptional: () => As, ZodParsedType: () => Vt, ZodPipeline: () => Cy2, ZodPromise: () => Pc2, ZodReadonly: () => Eh3, ZodRecord: () => Tb, ZodSchema: () => Ce, ZodSet: () => jd, ZodString: () => Tc2, ZodSymbol: () => Bd2, ZodTransformer: () => ks2, ZodTuple: () => pl, ZodType: () => Ce, ZodUndefined: () => bh3, ZodUnion: () => _h3, ZodUnknown: () => cu2, ZodVoid: () => Gd2, addIssueToContext: () => Ft, any: () => AV, array: () => FV, bigint: () => PV, boolean: () => _9, coerce: () => aj, custom: () => v9, date: () => EV, datetimeRegex: () => g9, defaultErrorMap: () => lu2, discriminatedUnion: () => jV, effect: () => QV, enum: () => $V, function: () => qV, getErrorMap: () => Ad2, getParsedType: () => cl, instanceof: () => TV, intersection: () => UV, isAborted: () => Sb, isAsync: () => Nd2, isDirty: () => Ib, isValid: () => Mc2, late: () => MV, lazy: () => WV, literal: () => ZV, makeIssue: () => my2, map: () => XV, nan: () => wV, nativeEnum: () => JV, never: () => kV, null: () => LV, nullable: () => ej, number: () => x9, object: () => BV, objectUtil: () => HS, oboolean: () => sj, onumber: () => oj, optional: () => tj, ostring: () => ij, pipeline: () => nj, preprocess: () => rj, promise: () => KV, quotelessJson: () => QG, record: () => HV, set: () => YV, setErrorMap: () => eV, strictObject: () => GV, string: () => b9, symbol: () => OV, transformer: () => QV, tuple: () => zV, undefined: () => DV, union: () => VV, unknown: () => NV, util: () => fr, void: () => RV });
a();
a();
a();
a();
a();
var fr;
(function(r5) {
  r5.assertEqual = (i) => {
  };
  function t(i) {
  }
  H$3(t, "assertIs"), r5.assertIs = t;
  function e(i) {
    throw new Error();
  }
  H$3(e, "assertNever"), r5.assertNever = e, r5.arrayToEnum = (i) => {
    let a4 = {};
    for (let u5 of i) a4[u5] = u5;
    return a4;
  }, r5.getValidEnumValues = (i) => {
    let a4 = r5.objectKeys(i).filter((h) => typeof i[i[h]] != "number"), u5 = {};
    for (let h of a4) u5[h] = i[h];
    return r5.objectValues(u5);
  }, r5.objectValues = (i) => r5.objectKeys(i).map(function(a4) {
    return i[a4];
  }), r5.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    let a4 = [];
    for (let u5 in i) Object.prototype.hasOwnProperty.call(i, u5) && a4.push(u5);
    return a4;
  }, r5.find = (i, a4) => {
    for (let u5 of i) if (a4(u5)) return u5;
  }, r5.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && Number.isFinite(i) && Math.floor(i) === i;
  function n4(i, a4 = " | ") {
    return i.map((u5) => typeof u5 == "string" ? "'".concat(u5, "'") : u5).join(a4);
  }
  H$3(n4, "joinValues"), r5.joinValues = n4, r5.jsonStringifyReplacer = (i, a4) => typeof a4 == "bigint" ? a4.toString() : a4;
})(fr || (fr = {}));
var HS;
(function(r5) {
  r5.mergeShapes = (t, e) => F$1(F$1({}, t), e);
})(HS || (HS = {}));
var Vt = fr.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), cl = H$3((r5) => {
  switch (typeof r5) {
    case "undefined":
      return Vt.undefined;
    case "string":
      return Vt.string;
    case "number":
      return Number.isNaN(r5) ? Vt.nan : Vt.number;
    case "boolean":
      return Vt.boolean;
    case "function":
      return Vt.function;
    case "bigint":
      return Vt.bigint;
    case "symbol":
      return Vt.symbol;
    case "object":
      return Array.isArray(r5) ? Vt.array : r5 === null ? Vt.null : r5.then && typeof r5.then == "function" && r5.catch && typeof r5.catch == "function" ? Vt.promise : typeof Map < "u" && r5 instanceof Map ? Vt.map : typeof Set < "u" && r5 instanceof Set ? Vt.set : typeof Date < "u" && r5 instanceof Date ? Vt.date : Vt.object;
    default:
      return Vt.unknown;
  }
}, "getParsedType");
var Pt2 = fr.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), QG = H$3((r5) => JSON.stringify(r5, null, 2).replace(/"([^"]+)":/g, "$1:"), "quotelessJson"), _b = class _b2 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n4) => {
      this.issues = [...this.issues, n4];
    }, this.addIssues = (n4 = []) => {
      this.issues = [...this.issues, ...n4];
    };
    let e = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e) : this.__proto__ = e, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    let e = t || function(a4) {
      return a4.message;
    }, n4 = { _errors: [] }, i = H$3((a4) => {
      for (let u5 of a4.issues) if (u5.code === "invalid_union") u5.unionErrors.map(i);
      else if (u5.code === "invalid_return_type") i(u5.returnTypeError);
      else if (u5.code === "invalid_arguments") i(u5.argumentsError);
      else if (u5.path.length === 0) n4._errors.push(e(u5));
      else {
        let h = n4, d = 0;
        for (; d < u5.path.length; ) {
          let m5 = u5.path[d];
          d === u5.path.length - 1 ? (h[m5] = h[m5] || { _errors: [] }, h[m5]._errors.push(e(u5))) : h[m5] = h[m5] || { _errors: [] }, h = h[m5], d++;
        }
      }
    }, "processError");
    return i(this), n4;
  }
  static assert(t) {
    if (!(t instanceof _b2)) throw new Error("Not a ZodError: ".concat(t));
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, fr.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (e) => e.message) {
    let e = {}, n4 = [];
    for (let i of this.issues) i.path.length > 0 ? (e[i.path[0]] = e[i.path[0]] || [], e[i.path[0]].push(t(i))) : n4.push(t(i));
    return { formErrors: n4, fieldErrors: e };
  }
  get formErrors() {
    return this.flatten();
  }
};
H$3(_b, "ZodError");
var Uo = _b;
Uo.create = (r5) => new Uo(r5);
var tV = H$3((r5, t) => {
  let e;
  switch (r5.code) {
    case Pt2.invalid_type:
      r5.received === Vt.undefined ? e = "Required" : e = "Expected ".concat(r5.expected, ", received ").concat(r5.received);
      break;
    case Pt2.invalid_literal:
      e = "Invalid literal value, expected ".concat(JSON.stringify(r5.expected, fr.jsonStringifyReplacer));
      break;
    case Pt2.unrecognized_keys:
      e = "Unrecognized key(s) in object: ".concat(fr.joinValues(r5.keys, ", "));
      break;
    case Pt2.invalid_union:
      e = "Invalid input";
      break;
    case Pt2.invalid_union_discriminator:
      e = "Invalid discriminator value. Expected ".concat(fr.joinValues(r5.options));
      break;
    case Pt2.invalid_enum_value:
      e = "Invalid enum value. Expected ".concat(fr.joinValues(r5.options), ", received '").concat(r5.received, "'");
      break;
    case Pt2.invalid_arguments:
      e = "Invalid function arguments";
      break;
    case Pt2.invalid_return_type:
      e = "Invalid function return type";
      break;
    case Pt2.invalid_date:
      e = "Invalid date";
      break;
    case Pt2.invalid_string:
      typeof r5.validation == "object" ? "includes" in r5.validation ? (e = 'Invalid input: must include "'.concat(r5.validation.includes, '"'), typeof r5.validation.position == "number" && (e = "".concat(e, " at one or more positions greater than or equal to ").concat(r5.validation.position))) : "startsWith" in r5.validation ? e = 'Invalid input: must start with "'.concat(r5.validation.startsWith, '"') : "endsWith" in r5.validation ? e = 'Invalid input: must end with "'.concat(r5.validation.endsWith, '"') : fr.assertNever(r5.validation) : r5.validation !== "regex" ? e = "Invalid ".concat(r5.validation) : e = "Invalid";
      break;
    case Pt2.too_small:
      r5.type === "array" ? e = "Array must contain ".concat(r5.exact ? "exactly" : r5.inclusive ? "at least" : "more than", " ").concat(r5.minimum, " element(s)") : r5.type === "string" ? e = "String must contain ".concat(r5.exact ? "exactly" : r5.inclusive ? "at least" : "over", " ").concat(r5.minimum, " character(s)") : r5.type === "number" ? e = "Number must be ".concat(r5.exact ? "exactly equal to " : r5.inclusive ? "greater than or equal to " : "greater than ").concat(r5.minimum) : r5.type === "date" ? e = "Date must be ".concat(r5.exact ? "exactly equal to " : r5.inclusive ? "greater than or equal to " : "greater than ").concat(new Date(Number(r5.minimum))) : e = "Invalid input";
      break;
    case Pt2.too_big:
      r5.type === "array" ? e = "Array must contain ".concat(r5.exact ? "exactly" : r5.inclusive ? "at most" : "less than", " ").concat(r5.maximum, " element(s)") : r5.type === "string" ? e = "String must contain ".concat(r5.exact ? "exactly" : r5.inclusive ? "at most" : "under", " ").concat(r5.maximum, " character(s)") : r5.type === "number" ? e = "Number must be ".concat(r5.exact ? "exactly" : r5.inclusive ? "less than or equal to" : "less than", " ").concat(r5.maximum) : r5.type === "bigint" ? e = "BigInt must be ".concat(r5.exact ? "exactly" : r5.inclusive ? "less than or equal to" : "less than", " ").concat(r5.maximum) : r5.type === "date" ? e = "Date must be ".concat(r5.exact ? "exactly" : r5.inclusive ? "smaller than or equal to" : "smaller than", " ").concat(new Date(Number(r5.maximum))) : e = "Invalid input";
      break;
    case Pt2.custom:
      e = "Invalid input";
      break;
    case Pt2.invalid_intersection_types:
      e = "Intersection results could not be merged";
      break;
    case Pt2.not_multiple_of:
      e = "Number must be a multiple of ".concat(r5.multipleOf);
      break;
    case Pt2.not_finite:
      e = "Number must be finite";
      break;
    default:
      e = t.defaultError, fr.assertNever(r5);
  }
  return { message: e };
}, "errorMap"), lu2 = tV;
var p9 = lu2;
function eV(r5) {
  p9 = r5;
}
H$3(eV, "setErrorMap");
function Ad2() {
  return p9;
}
H$3(Ad2, "getErrorMap");
a();
var my2 = H$3((r5) => {
  let { data: t, path: e, errorMaps: n4, issueData: i } = r5, a4 = [...e, ...i.path || []], u5 = G$1(F$1({}, i), { path: a4 });
  if (i.message !== void 0) return G$1(F$1({}, i), { path: a4, message: i.message });
  let h = "", d = n4.filter((m5) => !!m5).slice().reverse();
  for (let m5 of d) h = m5(u5, { data: t, defaultError: h }).message;
  return G$1(F$1({}, i), { path: a4, message: h });
}, "makeIssue"), rV = [];
function Ft(r5, t) {
  let e = Ad2(), n4 = my2({ issueData: t, data: r5.data, path: r5.path, errorMaps: [r5.common.contextualErrorMap, r5.schemaErrorMap, e, e === lu2 ? void 0 : lu2].filter((i) => !!i) });
  r5.common.issues.push(n4);
}
H$3(Ft, "addIssueToContext");
var Cb = class Cb2 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, e) {
    let n4 = [];
    for (let i of e) {
      if (i.status === "aborted") return ae;
      i.status === "dirty" && t.dirty(), n4.push(i.value);
    }
    return { status: t.value, value: n4 };
  }
  static async mergeObjectAsync(t, e) {
    let n4 = [];
    for (let i of e) {
      let a4 = await i.key, u5 = await i.value;
      n4.push({ key: a4, value: u5 });
    }
    return Cb2.mergeObjectSync(t, n4);
  }
  static mergeObjectSync(t, e) {
    let n4 = {};
    for (let i of e) {
      let { key: a4, value: u5 } = i;
      if (a4.status === "aborted" || u5.status === "aborted") return ae;
      a4.status === "dirty" && t.dirty(), u5.status === "dirty" && t.dirty(), a4.value !== "__proto__" && (typeof u5.value < "u" || i.alwaysSet) && (n4[a4.value] = u5.value);
    }
    return { status: t.value, value: n4 };
  }
};
H$3(Cb, "ParseStatus");
var Xi = Cb, ae = Object.freeze({ status: "aborted" }), fh2 = H$3((r5) => ({ status: "dirty", value: r5 }), "DIRTY"), ao = H$3((r5) => ({ status: "valid", value: r5 }), "OK"), Sb = H$3((r5) => r5.status === "aborted", "isAborted"), Ib = H$3((r5) => r5.status === "dirty", "isDirty"), Mc2 = H$3((r5) => r5.status === "valid", "isValid"), Nd2 = H$3((r5) => typeof Promise < "u" && r5 instanceof Promise, "isAsync");
a();
a();
a();
var Zt;
(function(r5) {
  r5.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, r5.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Zt || (Zt = {}));
var qS = class qS2 {
  constructor(t, e, n4, i) {
    this._cachedPath = [], this.parent = t, this.data = e, this._path = n4, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
H$3(qS, "ParseInputLazyPath");
var Ns2 = qS, h9 = H$3((r5, t) => {
  if (Mc2(t)) return { success: true, data: t.value };
  if (!r5.common.issues.length) throw new Error("Validation failed but no issues detected.");
  return { success: false, get error() {
    if (this._error) return this._error;
    let e = new Uo(r5.common.issues);
    return this._error = e, this._error;
  } };
}, "handleResult");
function be(r5) {
  if (!r5) return {};
  let { errorMap: t, invalid_type_error: e, required_error: n4, description: i } = r5;
  if (t && (e || n4)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: H$3((u5, h) => {
    var m5, v3;
    let { message: d } = r5;
    return u5.code === "invalid_enum_value" ? { message: d != null ? d : h.defaultError } : typeof h.data > "u" ? { message: (m5 = d != null ? d : n4) != null ? m5 : h.defaultError } : u5.code !== "invalid_type" ? { message: h.defaultError } : { message: (v3 = d != null ? d : e) != null ? v3 : h.defaultError };
  }, "customMap"), description: i };
}
H$3(be, "processCreateParams");
var WS = class WS2 {
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return cl(t.data);
  }
  _getOrReturnCtx(t, e) {
    return e || { common: t.parent.common, data: t.data, parsedType: cl(t.data), schemaErrorMap: this._def.errorMap, path: t.path, parent: t.parent };
  }
  _processInputParams(t) {
    return { status: new Xi(), ctx: { common: t.parent.common, data: t.data, parsedType: cl(t.data), schemaErrorMap: this._def.errorMap, path: t.path, parent: t.parent } };
  }
  _parseSync(t) {
    let e = this._parse(t);
    if (Nd2(e)) throw new Error("Synchronous parse encountered promise.");
    return e;
  }
  _parseAsync(t) {
    let e = this._parse(t);
    return Promise.resolve(e);
  }
  parse(t, e) {
    let n4 = this.safeParse(t, e);
    if (n4.success) return n4.data;
    throw n4.error;
  }
  safeParse(t, e) {
    var a4;
    let n4 = { common: { issues: [], async: (a4 = e == null ? void 0 : e.async) != null ? a4 : false, contextualErrorMap: e == null ? void 0 : e.errorMap }, path: (e == null ? void 0 : e.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: t, parsedType: cl(t) }, i = this._parseSync({ data: t, path: n4.path, parent: n4 });
    return h9(n4, i);
  }
  "~validate"(t) {
    var n4, i;
    let e = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: t, parsedType: cl(t) };
    if (!this["~standard"].async) try {
      let a4 = this._parseSync({ data: t, path: [], parent: e });
      return Mc2(a4) ? { value: a4.value } : { issues: e.common.issues };
    } catch (a4) {
      (i = (n4 = a4 == null ? void 0 : a4.message) == null ? void 0 : n4.toLowerCase()) != null && i.includes("encountered") && (this["~standard"].async = true), e.common = { issues: [], async: true };
    }
    return this._parseAsync({ data: t, path: [], parent: e }).then((a4) => Mc2(a4) ? { value: a4.value } : { issues: e.common.issues });
  }
  async parseAsync(t, e) {
    let n4 = await this.safeParseAsync(t, e);
    if (n4.success) return n4.data;
    throw n4.error;
  }
  async safeParseAsync(t, e) {
    let n4 = { common: { issues: [], contextualErrorMap: e == null ? void 0 : e.errorMap, async: true }, path: (e == null ? void 0 : e.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: t, parsedType: cl(t) }, i = this._parse({ data: t, path: n4.path, parent: n4 }), a4 = await (Nd2(i) ? i : Promise.resolve(i));
    return h9(n4, a4);
  }
  refine(t, e) {
    let n4 = H$3((i) => typeof e == "string" || typeof e > "u" ? { message: e } : typeof e == "function" ? e(i) : e, "getIssueProperties");
    return this._refinement((i, a4) => {
      let u5 = t(i), h = H$3(() => a4.addIssue(F$1({ code: Pt2.custom }, n4(i))), "setError");
      return typeof Promise < "u" && u5 instanceof Promise ? u5.then((d) => d ? true : (h(), false)) : u5 ? true : (h(), false);
    });
  }
  refinement(t, e) {
    return this._refinement((n4, i) => t(n4) ? true : (i.addIssue(typeof e == "function" ? e(n4, i) : e), false));
  }
  _refinement(t) {
    return new ks2({ schema: this, typeName: ce.ZodEffects, effect: { type: "refinement", refinement: t } });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: H$3((e) => this["~validate"](e), "validate") };
  }
  optional() {
    return As.create(this, this._def);
  }
  nullable() {
    return hl.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return pu2.create(this);
  }
  promise() {
    return Pc2.create(this, this._def);
  }
  or(t) {
    return _h3.create([this, t], this._def);
  }
  and(t) {
    return Ch3.create(this, t, this._def);
  }
  transform(t) {
    return new ks2(G$1(F$1({}, be(this._def)), { schema: this, typeName: ce.ZodEffects, effect: { type: "transform", transform: t } }));
  }
  default(t) {
    let e = typeof t == "function" ? t : () => t;
    return new wh3(G$1(F$1({}, be(this._def)), { innerType: this, defaultValue: e, typeName: ce.ZodDefault }));
  }
  brand() {
    return new _y(F$1({ typeName: ce.ZodBranded, type: this }, be(this._def)));
  }
  catch(t) {
    let e = typeof t == "function" ? t : () => t;
    return new Ph3(G$1(F$1({}, be(this._def)), { innerType: this, catchValue: e, typeName: ce.ZodCatch }));
  }
  describe(t) {
    let e = this.constructor;
    return new e(G$1(F$1({}, this._def), { description: t }));
  }
  pipe(t) {
    return Cy2.create(this, t);
  }
  readonly() {
    return Eh3.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
H$3(WS, "ZodType");
var Ce = WS, nV = /^c[^\s-]{8,}$/i, iV = /^[0-9a-z]+$/, oV = /^[0-9A-HJKMNP-TV-Z]{26}$/i, sV = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, aV = /^[a-z0-9_-]{21}$/i, lV = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, uV = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, cV = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, pV = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", XS, hV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, fV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, dV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, mV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, gV = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, yV = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, d9 = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", vV = new RegExp("^".concat(d9, "$"));
function m9(r5) {
  let t = "[0-5]\\d";
  r5.precision ? t = "".concat(t, "\\.\\d{").concat(r5.precision, "}") : r5.precision == null && (t = "".concat(t, "(\\.\\d+)?"));
  let e = r5.precision ? "+" : "?";
  return "([01]\\d|2[0-3]):[0-5]\\d(:".concat(t, ")").concat(e);
}
H$3(m9, "timeRegexSource");
function bV(r5) {
  return new RegExp("^".concat(m9(r5), "$"));
}
H$3(bV, "timeRegex");
function g9(r5) {
  let t = "".concat(d9, "T").concat(m9(r5)), e = [];
  return e.push(r5.local ? "Z?" : "Z"), r5.offset && e.push("([+-]\\d{2}:?\\d{2})"), t = "".concat(t, "(").concat(e.join("|"), ")"), new RegExp("^".concat(t, "$"));
}
H$3(g9, "datetimeRegex");
function xV(r5, t) {
  return !!((t === "v4" || !t) && hV.test(r5) || (t === "v6" || !t) && dV.test(r5));
}
H$3(xV, "isValidIP");
function _V(r5, t) {
  if (!lV.test(r5)) return false;
  try {
    let [e] = r5.split("."), n4 = e.replace(/-/g, "+").replace(/_/g, "/").padEnd(e.length + (4 - e.length % 4) % 4, "="), i = JSON.parse(atob(n4));
    return !(typeof i != "object" || i === null || "typ" in i && (i == null ? void 0 : i.typ) !== "JWT" || !i.alg || t && i.alg !== t);
  } catch (e) {
    return false;
  }
}
H$3(_V, "isValidJWT");
function CV(r5, t) {
  return !!((t === "v4" || !t) && fV.test(r5) || (t === "v6" || !t) && mV.test(r5));
}
H$3(CV, "isValidCidr");
var dh3 = class dh4 extends Ce {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Vt.string) {
      let a4 = this._getOrReturnCtx(t);
      return Ft(a4, { code: Pt2.invalid_type, expected: Vt.string, received: a4.parsedType }), ae;
    }
    let n4 = new Xi(), i;
    for (let a4 of this._def.checks) if (a4.kind === "min") t.data.length < a4.value && (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.too_small, minimum: a4.value, type: "string", inclusive: true, exact: false, message: a4.message }), n4.dirty());
    else if (a4.kind === "max") t.data.length > a4.value && (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.too_big, maximum: a4.value, type: "string", inclusive: true, exact: false, message: a4.message }), n4.dirty());
    else if (a4.kind === "length") {
      let u5 = t.data.length > a4.value, h = t.data.length < a4.value;
      (u5 || h) && (i = this._getOrReturnCtx(t, i), u5 ? Ft(i, { code: Pt2.too_big, maximum: a4.value, type: "string", inclusive: true, exact: true, message: a4.message }) : h && Ft(i, { code: Pt2.too_small, minimum: a4.value, type: "string", inclusive: true, exact: true, message: a4.message }), n4.dirty());
    } else if (a4.kind === "email") cV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "email", code: Pt2.invalid_string, message: a4.message }), n4.dirty());
    else if (a4.kind === "emoji") XS || (XS = new RegExp(pV, "u")), XS.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "emoji", code: Pt2.invalid_string, message: a4.message }), n4.dirty());
    else if (a4.kind === "uuid") sV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "uuid", code: Pt2.invalid_string, message: a4.message }), n4.dirty());
    else if (a4.kind === "nanoid") aV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "nanoid", code: Pt2.invalid_string, message: a4.message }), n4.dirty());
    else if (a4.kind === "cuid") nV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "cuid", code: Pt2.invalid_string, message: a4.message }), n4.dirty());
    else if (a4.kind === "cuid2") iV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "cuid2", code: Pt2.invalid_string, message: a4.message }), n4.dirty());
    else if (a4.kind === "ulid") oV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "ulid", code: Pt2.invalid_string, message: a4.message }), n4.dirty());
    else if (a4.kind === "url") try {
      new URL(t.data);
    } catch (u5) {
      i = this._getOrReturnCtx(t, i), Ft(i, { validation: "url", code: Pt2.invalid_string, message: a4.message }), n4.dirty();
    }
    else a4.kind === "regex" ? (a4.regex.lastIndex = 0, a4.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "regex", code: Pt2.invalid_string, message: a4.message }), n4.dirty())) : a4.kind === "trim" ? t.data = t.data.trim() : a4.kind === "includes" ? t.data.includes(a4.value, a4.position) || (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.invalid_string, validation: { includes: a4.value, position: a4.position }, message: a4.message }), n4.dirty()) : a4.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a4.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a4.kind === "startsWith" ? t.data.startsWith(a4.value) || (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.invalid_string, validation: { startsWith: a4.value }, message: a4.message }), n4.dirty()) : a4.kind === "endsWith" ? t.data.endsWith(a4.value) || (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.invalid_string, validation: { endsWith: a4.value }, message: a4.message }), n4.dirty()) : a4.kind === "datetime" ? g9(a4).test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.invalid_string, validation: "datetime", message: a4.message }), n4.dirty()) : a4.kind === "date" ? vV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.invalid_string, validation: "date", message: a4.message }), n4.dirty()) : a4.kind === "time" ? bV(a4).test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.invalid_string, validation: "time", message: a4.message }), n4.dirty()) : a4.kind === "duration" ? uV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "duration", code: Pt2.invalid_string, message: a4.message }), n4.dirty()) : a4.kind === "ip" ? xV(t.data, a4.version) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "ip", code: Pt2.invalid_string, message: a4.message }), n4.dirty()) : a4.kind === "jwt" ? _V(t.data, a4.alg) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "jwt", code: Pt2.invalid_string, message: a4.message }), n4.dirty()) : a4.kind === "cidr" ? CV(t.data, a4.version) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "cidr", code: Pt2.invalid_string, message: a4.message }), n4.dirty()) : a4.kind === "base64" ? gV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "base64", code: Pt2.invalid_string, message: a4.message }), n4.dirty()) : a4.kind === "base64url" ? yV.test(t.data) || (i = this._getOrReturnCtx(t, i), Ft(i, { validation: "base64url", code: Pt2.invalid_string, message: a4.message }), n4.dirty()) : fr.assertNever(a4);
    return { status: n4.value, value: t.data };
  }
  _regex(t, e, n4) {
    return this.refinement((i) => t.test(i), F$1({ validation: e, code: Pt2.invalid_string }, Zt.errToObj(n4)));
  }
  _addCheck(t) {
    return new dh4(G$1(F$1({}, this._def), { checks: [...this._def.checks, t] }));
  }
  email(t) {
    return this._addCheck(F$1({ kind: "email" }, Zt.errToObj(t)));
  }
  url(t) {
    return this._addCheck(F$1({ kind: "url" }, Zt.errToObj(t)));
  }
  emoji(t) {
    return this._addCheck(F$1({ kind: "emoji" }, Zt.errToObj(t)));
  }
  uuid(t) {
    return this._addCheck(F$1({ kind: "uuid" }, Zt.errToObj(t)));
  }
  nanoid(t) {
    return this._addCheck(F$1({ kind: "nanoid" }, Zt.errToObj(t)));
  }
  cuid(t) {
    return this._addCheck(F$1({ kind: "cuid" }, Zt.errToObj(t)));
  }
  cuid2(t) {
    return this._addCheck(F$1({ kind: "cuid2" }, Zt.errToObj(t)));
  }
  ulid(t) {
    return this._addCheck(F$1({ kind: "ulid" }, Zt.errToObj(t)));
  }
  base64(t) {
    return this._addCheck(F$1({ kind: "base64" }, Zt.errToObj(t)));
  }
  base64url(t) {
    return this._addCheck(F$1({ kind: "base64url" }, Zt.errToObj(t)));
  }
  jwt(t) {
    return this._addCheck(F$1({ kind: "jwt" }, Zt.errToObj(t)));
  }
  ip(t) {
    return this._addCheck(F$1({ kind: "ip" }, Zt.errToObj(t)));
  }
  cidr(t) {
    return this._addCheck(F$1({ kind: "cidr" }, Zt.errToObj(t)));
  }
  datetime(t) {
    var e, n4;
    return typeof t == "string" ? this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: t }) : this._addCheck(F$1({ kind: "datetime", precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision, offset: (e = t == null ? void 0 : t.offset) != null ? e : false, local: (n4 = t == null ? void 0 : t.local) != null ? n4 : false }, Zt.errToObj(t == null ? void 0 : t.message)));
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({ kind: "time", precision: null, message: t }) : this._addCheck(F$1({ kind: "time", precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision }, Zt.errToObj(t == null ? void 0 : t.message)));
  }
  duration(t) {
    return this._addCheck(F$1({ kind: "duration" }, Zt.errToObj(t)));
  }
  regex(t, e) {
    return this._addCheck(F$1({ kind: "regex", regex: t }, Zt.errToObj(e)));
  }
  includes(t, e) {
    return this._addCheck(F$1({ kind: "includes", value: t, position: e == null ? void 0 : e.position }, Zt.errToObj(e == null ? void 0 : e.message)));
  }
  startsWith(t, e) {
    return this._addCheck(F$1({ kind: "startsWith", value: t }, Zt.errToObj(e)));
  }
  endsWith(t, e) {
    return this._addCheck(F$1({ kind: "endsWith", value: t }, Zt.errToObj(e)));
  }
  min(t, e) {
    return this._addCheck(F$1({ kind: "min", value: t }, Zt.errToObj(e)));
  }
  max(t, e) {
    return this._addCheck(F$1({ kind: "max", value: t }, Zt.errToObj(e)));
  }
  length(t, e) {
    return this._addCheck(F$1({ kind: "length", value: t }, Zt.errToObj(e)));
  }
  nonempty(t) {
    return this.min(1, Zt.errToObj(t));
  }
  trim() {
    return new dh4(G$1(F$1({}, this._def), { checks: [...this._def.checks, { kind: "trim" }] }));
  }
  toLowerCase() {
    return new dh4(G$1(F$1({}, this._def), { checks: [...this._def.checks, { kind: "toLowerCase" }] }));
  }
  toUpperCase() {
    return new dh4(G$1(F$1({}, this._def), { checks: [...this._def.checks, { kind: "toUpperCase" }] }));
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url");
  }
  get minLength() {
    let t = null;
    for (let e of this._def.checks) e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (let e of this._def.checks) e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
};
H$3(dh3, "ZodString");
var Tc2 = dh3;
Tc2.create = (r5) => {
  var t;
  return new Tc2(F$1({ checks: [], typeName: ce.ZodString, coerce: (t = r5 == null ? void 0 : r5.coerce) != null ? t : false }, be(r5)));
};
function SV(r5, t) {
  let e = (r5.toString().split(".")[1] || "").length, n4 = (t.toString().split(".")[1] || "").length, i = e > n4 ? e : n4, a4 = Number.parseInt(r5.toFixed(i).replace(".", "")), u5 = Number.parseInt(t.toFixed(i).replace(".", ""));
  return a4 % u5 / 10 ** i;
}
H$3(SV, "floatSafeRemainder");
var gy2 = class gy3 extends Ce {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Vt.number) {
      let a4 = this._getOrReturnCtx(t);
      return Ft(a4, { code: Pt2.invalid_type, expected: Vt.number, received: a4.parsedType }), ae;
    }
    let n4, i = new Xi();
    for (let a4 of this._def.checks) a4.kind === "int" ? fr.isInteger(t.data) || (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.invalid_type, expected: "integer", received: "float", message: a4.message }), i.dirty()) : a4.kind === "min" ? (a4.inclusive ? t.data < a4.value : t.data <= a4.value) && (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.too_small, minimum: a4.value, type: "number", inclusive: a4.inclusive, exact: false, message: a4.message }), i.dirty()) : a4.kind === "max" ? (a4.inclusive ? t.data > a4.value : t.data >= a4.value) && (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.too_big, maximum: a4.value, type: "number", inclusive: a4.inclusive, exact: false, message: a4.message }), i.dirty()) : a4.kind === "multipleOf" ? SV(t.data, a4.value) !== 0 && (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.not_multiple_of, multipleOf: a4.value, message: a4.message }), i.dirty()) : a4.kind === "finite" ? Number.isFinite(t.data) || (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.not_finite, message: a4.message }), i.dirty()) : fr.assertNever(a4);
    return { status: i.value, value: t.data };
  }
  gte(t, e) {
    return this.setLimit("min", t, true, Zt.toString(e));
  }
  gt(t, e) {
    return this.setLimit("min", t, false, Zt.toString(e));
  }
  lte(t, e) {
    return this.setLimit("max", t, true, Zt.toString(e));
  }
  lt(t, e) {
    return this.setLimit("max", t, false, Zt.toString(e));
  }
  setLimit(t, e, n4, i) {
    return new gy3(G$1(F$1({}, this._def), { checks: [...this._def.checks, { kind: t, value: e, inclusive: n4, message: Zt.toString(i) }] }));
  }
  _addCheck(t) {
    return new gy3(G$1(F$1({}, this._def), { checks: [...this._def.checks, t] }));
  }
  int(t) {
    return this._addCheck({ kind: "int", message: Zt.toString(t) });
  }
  positive(t) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: Zt.toString(t) });
  }
  negative(t) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: Zt.toString(t) });
  }
  nonpositive(t) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: Zt.toString(t) });
  }
  nonnegative(t) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: Zt.toString(t) });
  }
  multipleOf(t, e) {
    return this._addCheck({ kind: "multipleOf", value: t, message: Zt.toString(e) });
  }
  finite(t) {
    return this._addCheck({ kind: "finite", message: Zt.toString(t) });
  }
  safe(t) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: Zt.toString(t) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: Zt.toString(t) });
  }
  get minValue() {
    let t = null;
    for (let e of this._def.checks) e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (let e of this._def.checks) e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && fr.isInteger(t.value));
  }
  get isFinite() {
    let t = null, e = null;
    for (let n4 of this._def.checks) {
      if (n4.kind === "finite" || n4.kind === "int" || n4.kind === "multipleOf") return true;
      n4.kind === "min" ? (e === null || n4.value > e) && (e = n4.value) : n4.kind === "max" && (t === null || n4.value < t) && (t = n4.value);
    }
    return Number.isFinite(e) && Number.isFinite(t);
  }
};
H$3(gy2, "ZodNumber");
var mh2 = gy2;
mh2.create = (r5) => new mh2(F$1({ checks: [], typeName: ce.ZodNumber, coerce: (r5 == null ? void 0 : r5.coerce) || false }, be(r5)));
var yy2 = class yy3 extends Ce {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce) try {
      t.data = BigInt(t.data);
    } catch (a4) {
      return this._getInvalidInput(t);
    }
    if (this._getType(t) !== Vt.bigint) return this._getInvalidInput(t);
    let n4, i = new Xi();
    for (let a4 of this._def.checks) a4.kind === "min" ? (a4.inclusive ? t.data < a4.value : t.data <= a4.value) && (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.too_small, type: "bigint", minimum: a4.value, inclusive: a4.inclusive, message: a4.message }), i.dirty()) : a4.kind === "max" ? (a4.inclusive ? t.data > a4.value : t.data >= a4.value) && (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.too_big, type: "bigint", maximum: a4.value, inclusive: a4.inclusive, message: a4.message }), i.dirty()) : a4.kind === "multipleOf" ? t.data % a4.value !== BigInt(0) && (n4 = this._getOrReturnCtx(t, n4), Ft(n4, { code: Pt2.not_multiple_of, multipleOf: a4.value, message: a4.message }), i.dirty()) : fr.assertNever(a4);
    return { status: i.value, value: t.data };
  }
  _getInvalidInput(t) {
    let e = this._getOrReturnCtx(t);
    return Ft(e, { code: Pt2.invalid_type, expected: Vt.bigint, received: e.parsedType }), ae;
  }
  gte(t, e) {
    return this.setLimit("min", t, true, Zt.toString(e));
  }
  gt(t, e) {
    return this.setLimit("min", t, false, Zt.toString(e));
  }
  lte(t, e) {
    return this.setLimit("max", t, true, Zt.toString(e));
  }
  lt(t, e) {
    return this.setLimit("max", t, false, Zt.toString(e));
  }
  setLimit(t, e, n4, i) {
    return new yy3(G$1(F$1({}, this._def), { checks: [...this._def.checks, { kind: t, value: e, inclusive: n4, message: Zt.toString(i) }] }));
  }
  _addCheck(t) {
    return new yy3(G$1(F$1({}, this._def), { checks: [...this._def.checks, t] }));
  }
  positive(t) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: Zt.toString(t) });
  }
  negative(t) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: Zt.toString(t) });
  }
  nonpositive(t) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: Zt.toString(t) });
  }
  nonnegative(t) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: Zt.toString(t) });
  }
  multipleOf(t, e) {
    return this._addCheck({ kind: "multipleOf", value: t, message: Zt.toString(e) });
  }
  get minValue() {
    let t = null;
    for (let e of this._def.checks) e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (let e of this._def.checks) e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
};
H$3(yy2, "ZodBigInt");
var gh3 = yy2;
gh3.create = (r5) => {
  var t;
  return new gh3(F$1({ checks: [], typeName: ce.ZodBigInt, coerce: (t = r5 == null ? void 0 : r5.coerce) != null ? t : false }, be(r5)));
};
var ZS = class ZS2 extends Ce {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Vt.boolean) {
      let n4 = this._getOrReturnCtx(t);
      return Ft(n4, { code: Pt2.invalid_type, expected: Vt.boolean, received: n4.parsedType }), ae;
    }
    return ao(t.data);
  }
};
H$3(ZS, "ZodBoolean");
var yh3 = ZS;
yh3.create = (r5) => new yh3(F$1({ typeName: ce.ZodBoolean, coerce: (r5 == null ? void 0 : r5.coerce) || false }, be(r5)));
var Pb = class Pb2 extends Ce {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Vt.date) {
      let a4 = this._getOrReturnCtx(t);
      return Ft(a4, { code: Pt2.invalid_type, expected: Vt.date, received: a4.parsedType }), ae;
    }
    if (Number.isNaN(t.data.getTime())) {
      let a4 = this._getOrReturnCtx(t);
      return Ft(a4, { code: Pt2.invalid_date }), ae;
    }
    let n4 = new Xi(), i;
    for (let a4 of this._def.checks) a4.kind === "min" ? t.data.getTime() < a4.value && (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.too_small, message: a4.message, inclusive: true, exact: false, minimum: a4.value, type: "date" }), n4.dirty()) : a4.kind === "max" ? t.data.getTime() > a4.value && (i = this._getOrReturnCtx(t, i), Ft(i, { code: Pt2.too_big, message: a4.message, inclusive: true, exact: false, maximum: a4.value, type: "date" }), n4.dirty()) : fr.assertNever(a4);
    return { status: n4.value, value: new Date(t.data.getTime()) };
  }
  _addCheck(t) {
    return new Pb2(G$1(F$1({}, this._def), { checks: [...this._def.checks, t] }));
  }
  min(t, e) {
    return this._addCheck({ kind: "min", value: t.getTime(), message: Zt.toString(e) });
  }
  max(t, e) {
    return this._addCheck({ kind: "max", value: t.getTime(), message: Zt.toString(e) });
  }
  get minDate() {
    let t = null;
    for (let e of this._def.checks) e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (let e of this._def.checks) e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t != null ? new Date(t) : null;
  }
};
H$3(Pb, "ZodDate");
var vh3 = Pb;
vh3.create = (r5) => new vh3(F$1({ checks: [], coerce: (r5 == null ? void 0 : r5.coerce) || false, typeName: ce.ZodDate }, be(r5)));
var $S = class $S2 extends Ce {
  _parse(t) {
    if (this._getType(t) !== Vt.symbol) {
      let n4 = this._getOrReturnCtx(t);
      return Ft(n4, { code: Pt2.invalid_type, expected: Vt.symbol, received: n4.parsedType }), ae;
    }
    return ao(t.data);
  }
};
H$3($S, "ZodSymbol");
var Bd2 = $S;
Bd2.create = (r5) => new Bd2(F$1({ typeName: ce.ZodSymbol }, be(r5)));
var JS = class JS2 extends Ce {
  _parse(t) {
    if (this._getType(t) !== Vt.undefined) {
      let n4 = this._getOrReturnCtx(t);
      return Ft(n4, { code: Pt2.invalid_type, expected: Vt.undefined, received: n4.parsedType }), ae;
    }
    return ao(t.data);
  }
};
H$3(JS, "ZodUndefined");
var bh3 = JS;
bh3.create = (r5) => new bh3(F$1({ typeName: ce.ZodUndefined }, be(r5)));
var KS = class KS2 extends Ce {
  _parse(t) {
    if (this._getType(t) !== Vt.null) {
      let n4 = this._getOrReturnCtx(t);
      return Ft(n4, { code: Pt2.invalid_type, expected: Vt.null, received: n4.parsedType }), ae;
    }
    return ao(t.data);
  }
};
H$3(KS, "ZodNull");
var xh3 = KS;
xh3.create = (r5) => new xh3(F$1({ typeName: ce.ZodNull }, be(r5)));
var QS = class QS2 extends Ce {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(t) {
    return ao(t.data);
  }
};
H$3(QS, "ZodAny");
var wc2 = QS;
wc2.create = (r5) => new wc2(F$1({ typeName: ce.ZodAny }, be(r5)));
var t3 = class t32 extends Ce {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(t) {
    return ao(t.data);
  }
};
H$3(t3, "ZodUnknown");
var cu2 = t3;
cu2.create = (r5) => new cu2(F$1({ typeName: ce.ZodUnknown }, be(r5)));
var e3 = class e32 extends Ce {
  _parse(t) {
    let e = this._getOrReturnCtx(t);
    return Ft(e, { code: Pt2.invalid_type, expected: Vt.never, received: e.parsedType }), ae;
  }
};
H$3(e3, "ZodNever");
var fa2 = e3;
fa2.create = (r5) => new fa2(F$1({ typeName: ce.ZodNever }, be(r5)));
var r3 = class r32 extends Ce {
  _parse(t) {
    if (this._getType(t) !== Vt.undefined) {
      let n4 = this._getOrReturnCtx(t);
      return Ft(n4, { code: Pt2.invalid_type, expected: Vt.void, received: n4.parsedType }), ae;
    }
    return ao(t.data);
  }
};
H$3(r3, "ZodVoid");
var Gd2 = r3;
Gd2.create = (r5) => new Gd2(F$1({ typeName: ce.ZodVoid }, be(r5)));
var Rd2 = class Rd3 extends Ce {
  _parse(t) {
    let { ctx: e, status: n4 } = this._processInputParams(t), i = this._def;
    if (e.parsedType !== Vt.array) return Ft(e, { code: Pt2.invalid_type, expected: Vt.array, received: e.parsedType }), ae;
    if (i.exactLength !== null) {
      let u5 = e.data.length > i.exactLength.value, h = e.data.length < i.exactLength.value;
      (u5 || h) && (Ft(e, { code: u5 ? Pt2.too_big : Pt2.too_small, minimum: h ? i.exactLength.value : void 0, maximum: u5 ? i.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: i.exactLength.message }), n4.dirty());
    }
    if (i.minLength !== null && e.data.length < i.minLength.value && (Ft(e, { code: Pt2.too_small, minimum: i.minLength.value, type: "array", inclusive: true, exact: false, message: i.minLength.message }), n4.dirty()), i.maxLength !== null && e.data.length > i.maxLength.value && (Ft(e, { code: Pt2.too_big, maximum: i.maxLength.value, type: "array", inclusive: true, exact: false, message: i.maxLength.message }), n4.dirty()), e.common.async) return Promise.all([...e.data].map((u5, h) => i.type._parseAsync(new Ns2(e, u5, e.path, h)))).then((u5) => Xi.mergeArray(n4, u5));
    let a4 = [...e.data].map((u5, h) => i.type._parseSync(new Ns2(e, u5, e.path, h)));
    return Xi.mergeArray(n4, a4);
  }
  get element() {
    return this._def.type;
  }
  min(t, e) {
    return new Rd3(G$1(F$1({}, this._def), { minLength: { value: t, message: Zt.toString(e) } }));
  }
  max(t, e) {
    return new Rd3(G$1(F$1({}, this._def), { maxLength: { value: t, message: Zt.toString(e) } }));
  }
  length(t, e) {
    return new Rd3(G$1(F$1({}, this._def), { exactLength: { value: t, message: Zt.toString(e) } }));
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
H$3(Rd2, "ZodArray");
var pu2 = Rd2;
pu2.create = (r5, t) => new pu2(F$1({ type: r5, minLength: null, maxLength: null, exactLength: null, typeName: ce.ZodArray }, be(t)));
function kd(r5) {
  if (r5 instanceof zo) {
    let t = {};
    for (let e in r5.shape) {
      let n4 = r5.shape[e];
      t[e] = As.create(kd(n4));
    }
    return new zo(G$1(F$1({}, r5._def), { shape: H$3(() => t, "shape") }));
  } else return r5 instanceof pu2 ? new pu2(G$1(F$1({}, r5._def), { type: kd(r5.element) })) : r5 instanceof As ? As.create(kd(r5.unwrap())) : r5 instanceof hl ? hl.create(kd(r5.unwrap())) : r5 instanceof pl ? pl.create(r5.items.map((t) => kd(t))) : r5;
}
H$3(kd, "deepPartialify");
var us = class us2 extends Ce {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let t = this._def.shape(), e = fr.objectKeys(t);
    return this._cached = { shape: t, keys: e }, this._cached;
  }
  _parse(t) {
    if (this._getType(t) !== Vt.object) {
      let m5 = this._getOrReturnCtx(t);
      return Ft(m5, { code: Pt2.invalid_type, expected: Vt.object, received: m5.parsedType }), ae;
    }
    let { status: n4, ctx: i } = this._processInputParams(t), { shape: a4, keys: u5 } = this._getCached(), h = [];
    if (!(this._def.catchall instanceof fa2 && this._def.unknownKeys === "strip")) for (let m5 in i.data) u5.includes(m5) || h.push(m5);
    let d = [];
    for (let m5 of u5) {
      let v3 = a4[m5], x2 = i.data[m5];
      d.push({ key: { status: "valid", value: m5 }, value: v3._parse(new Ns2(i, x2, i.path, m5)), alwaysSet: m5 in i.data });
    }
    if (this._def.catchall instanceof fa2) {
      let m5 = this._def.unknownKeys;
      if (m5 === "passthrough") for (let v3 of h) d.push({ key: { status: "valid", value: v3 }, value: { status: "valid", value: i.data[v3] } });
      else if (m5 === "strict") h.length > 0 && (Ft(i, { code: Pt2.unrecognized_keys, keys: h }), n4.dirty());
      else if (m5 !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let m5 = this._def.catchall;
      for (let v3 of h) {
        let x2 = i.data[v3];
        d.push({ key: { status: "valid", value: v3 }, value: m5._parse(new Ns2(i, x2, i.path, v3)), alwaysSet: v3 in i.data });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      let m5 = [];
      for (let v3 of d) {
        let x2 = await v3.key, S4 = await v3.value;
        m5.push({ key: x2, value: S4, alwaysSet: v3.alwaysSet });
      }
      return m5;
    }).then((m5) => Xi.mergeObjectSync(n4, m5)) : Xi.mergeObjectSync(n4, d);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Zt.errToObj, new us2(F$1(G$1(F$1({}, this._def), { unknownKeys: "strict" }), t !== void 0 ? { errorMap: H$3((e, n4) => {
      var a4, u5, h, d;
      let i = (h = (u5 = (a4 = this._def).errorMap) == null ? void 0 : u5.call(a4, e, n4).message) != null ? h : n4.defaultError;
      return e.code === "unrecognized_keys" ? { message: (d = Zt.errToObj(t).message) != null ? d : i } : { message: i };
    }, "errorMap") } : {}));
  }
  strip() {
    return new us2(G$1(F$1({}, this._def), { unknownKeys: "strip" }));
  }
  passthrough() {
    return new us2(G$1(F$1({}, this._def), { unknownKeys: "passthrough" }));
  }
  extend(t) {
    return new us2(G$1(F$1({}, this._def), { shape: H$3(() => F$1(F$1({}, this._def.shape()), t), "shape") }));
  }
  merge(t) {
    return new us2({ unknownKeys: t._def.unknownKeys, catchall: t._def.catchall, shape: H$3(() => F$1(F$1({}, this._def.shape()), t._def.shape()), "shape"), typeName: ce.ZodObject });
  }
  setKey(t, e) {
    return this.augment({ [t]: e });
  }
  catchall(t) {
    return new us2(G$1(F$1({}, this._def), { catchall: t }));
  }
  pick(t) {
    let e = {};
    for (let n4 of fr.objectKeys(t)) t[n4] && this.shape[n4] && (e[n4] = this.shape[n4]);
    return new us2(G$1(F$1({}, this._def), { shape: H$3(() => e, "shape") }));
  }
  omit(t) {
    let e = {};
    for (let n4 of fr.objectKeys(this.shape)) t[n4] || (e[n4] = this.shape[n4]);
    return new us2(G$1(F$1({}, this._def), { shape: H$3(() => e, "shape") }));
  }
  deepPartial() {
    return kd(this);
  }
  partial(t) {
    let e = {};
    for (let n4 of fr.objectKeys(this.shape)) {
      let i = this.shape[n4];
      t && !t[n4] ? e[n4] = i : e[n4] = i.optional();
    }
    return new us2(G$1(F$1({}, this._def), { shape: H$3(() => e, "shape") }));
  }
  required(t) {
    let e = {};
    for (let n4 of fr.objectKeys(this.shape)) if (t && !t[n4]) e[n4] = this.shape[n4];
    else {
      let a4 = this.shape[n4];
      for (; a4 instanceof As; ) a4 = a4._def.innerType;
      e[n4] = a4;
    }
    return new us2(G$1(F$1({}, this._def), { shape: H$3(() => e, "shape") }));
  }
  keyof() {
    return y9(fr.objectKeys(this.shape));
  }
};
H$3(us, "ZodObject");
var zo = us;
zo.create = (r5, t) => new zo(F$1({ shape: H$3(() => r5, "shape"), unknownKeys: "strip", catchall: fa2.create(), typeName: ce.ZodObject }, be(t)));
zo.strictCreate = (r5, t) => new zo(F$1({ shape: H$3(() => r5, "shape"), unknownKeys: "strict", catchall: fa2.create(), typeName: ce.ZodObject }, be(t)));
zo.lazycreate = (r5, t) => new zo(F$1({ shape: r5, unknownKeys: "strip", catchall: fa2.create(), typeName: ce.ZodObject }, be(t)));
var n3 = class n32 extends Ce {
  _parse(t) {
    let { ctx: e } = this._processInputParams(t), n4 = this._def.options;
    function i(a4) {
      for (let h of a4) if (h.result.status === "valid") return h.result;
      for (let h of a4) if (h.result.status === "dirty") return e.common.issues.push(...h.ctx.common.issues), h.result;
      let u5 = a4.map((h) => new Uo(h.ctx.common.issues));
      return Ft(e, { code: Pt2.invalid_union, unionErrors: u5 }), ae;
    }
    if (H$3(i, "handleResults"), e.common.async) return Promise.all(n4.map(async (a4) => {
      let u5 = G$1(F$1({}, e), { common: G$1(F$1({}, e.common), { issues: [] }), parent: null });
      return { result: await a4._parseAsync({ data: e.data, path: e.path, parent: u5 }), ctx: u5 };
    })).then(i);
    {
      let a4, u5 = [];
      for (let d of n4) {
        let m5 = G$1(F$1({}, e), { common: G$1(F$1({}, e.common), { issues: [] }), parent: null }), v3 = d._parseSync({ data: e.data, path: e.path, parent: m5 });
        if (v3.status === "valid") return v3;
        v3.status === "dirty" && !a4 && (a4 = { result: v3, ctx: m5 }), m5.common.issues.length && u5.push(m5.common.issues);
      }
      if (a4) return e.common.issues.push(...a4.ctx.common.issues), a4.result;
      let h = u5.map((d) => new Uo(d));
      return Ft(e, { code: Pt2.invalid_union, unionErrors: h }), ae;
    }
  }
  get options() {
    return this._def.options;
  }
};
H$3(n3, "ZodUnion");
var _h3 = n3;
_h3.create = (r5, t) => new _h3(F$1({ options: r5, typeName: ce.ZodUnion }, be(t)));
var uu2 = H$3((r5) => r5 instanceof Sh3 ? uu2(r5.schema) : r5 instanceof ks2 ? uu2(r5.innerType()) : r5 instanceof Ih2 ? [r5.value] : r5 instanceof Mh3 ? r5.options : r5 instanceof Th3 ? fr.objectValues(r5.enum) : r5 instanceof wh3 ? uu2(r5._def.innerType) : r5 instanceof bh3 ? [void 0] : r5 instanceof xh3 ? [null] : r5 instanceof As ? [void 0, ...uu2(r5.unwrap())] : r5 instanceof hl ? [null, ...uu2(r5.unwrap())] : r5 instanceof _y || r5 instanceof Eh3 ? uu2(r5.unwrap()) : r5 instanceof Ph3 ? uu2(r5._def.innerType) : [], "getDiscriminator"), Eb = class Eb2 extends Ce {
  _parse(t) {
    let { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== Vt.object) return Ft(e, { code: Pt2.invalid_type, expected: Vt.object, received: e.parsedType }), ae;
    let n4 = this.discriminator, i = e.data[n4], a4 = this.optionsMap.get(i);
    return a4 ? e.common.async ? a4._parseAsync({ data: e.data, path: e.path, parent: e }) : a4._parseSync({ data: e.data, path: e.path, parent: e }) : (Ft(e, { code: Pt2.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [n4] }), ae);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(t, e, n4) {
    let i = /* @__PURE__ */ new Map();
    for (let a4 of e) {
      let u5 = uu2(a4.shape[t]);
      if (!u5.length) throw new Error("A discriminator value for key `".concat(t, "` could not be extracted from all schema options"));
      for (let h of u5) {
        if (i.has(h)) throw new Error("Discriminator property ".concat(String(t), " has duplicate value ").concat(String(h)));
        i.set(h, a4);
      }
    }
    return new Eb2(F$1({ typeName: ce.ZodDiscriminatedUnion, discriminator: t, options: e, optionsMap: i }, be(n4)));
  }
};
H$3(Eb, "ZodDiscriminatedUnion");
var Mb = Eb;
function YS(r5, t) {
  let e = cl(r5), n4 = cl(t);
  if (r5 === t) return { valid: true, data: r5 };
  if (e === Vt.object && n4 === Vt.object) {
    let i = fr.objectKeys(t), a4 = fr.objectKeys(r5).filter((h) => i.indexOf(h) !== -1), u5 = F$1(F$1({}, r5), t);
    for (let h of a4) {
      let d = YS(r5[h], t[h]);
      if (!d.valid) return { valid: false };
      u5[h] = d.data;
    }
    return { valid: true, data: u5 };
  } else if (e === Vt.array && n4 === Vt.array) {
    if (r5.length !== t.length) return { valid: false };
    let i = [];
    for (let a4 = 0; a4 < r5.length; a4++) {
      let u5 = r5[a4], h = t[a4], d = YS(u5, h);
      if (!d.valid) return { valid: false };
      i.push(d.data);
    }
    return { valid: true, data: i };
  } else return e === Vt.date && n4 === Vt.date && +r5 == +t ? { valid: true, data: r5 } : { valid: false };
}
H$3(YS, "mergeValues");
var i3 = class i32 extends Ce {
  _parse(t) {
    let { status: e, ctx: n4 } = this._processInputParams(t), i = H$3((a4, u5) => {
      if (Sb(a4) || Sb(u5)) return ae;
      let h = YS(a4.value, u5.value);
      return h.valid ? ((Ib(a4) || Ib(u5)) && e.dirty(), { status: e.value, value: h.data }) : (Ft(n4, { code: Pt2.invalid_intersection_types }), ae);
    }, "handleParsed");
    return n4.common.async ? Promise.all([this._def.left._parseAsync({ data: n4.data, path: n4.path, parent: n4 }), this._def.right._parseAsync({ data: n4.data, path: n4.path, parent: n4 })]).then(([a4, u5]) => i(a4, u5)) : i(this._def.left._parseSync({ data: n4.data, path: n4.path, parent: n4 }), this._def.right._parseSync({ data: n4.data, path: n4.path, parent: n4 }));
  }
};
H$3(i3, "ZodIntersection");
var Ch3 = i3;
Ch3.create = (r5, t, e) => new Ch3(F$1({ left: r5, right: t, typeName: ce.ZodIntersection }, be(e)));
var Ob = class Ob2 extends Ce {
  _parse(t) {
    let { status: e, ctx: n4 } = this._processInputParams(t);
    if (n4.parsedType !== Vt.array) return Ft(n4, { code: Pt2.invalid_type, expected: Vt.array, received: n4.parsedType }), ae;
    if (n4.data.length < this._def.items.length) return Ft(n4, { code: Pt2.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), ae;
    !this._def.rest && n4.data.length > this._def.items.length && (Ft(n4, { code: Pt2.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), e.dirty());
    let a4 = [...n4.data].map((u5, h) => {
      let d = this._def.items[h] || this._def.rest;
      return d ? d._parse(new Ns2(n4, u5, n4.path, h)) : null;
    }).filter((u5) => !!u5);
    return n4.common.async ? Promise.all(a4).then((u5) => Xi.mergeArray(e, u5)) : Xi.mergeArray(e, a4);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Ob2(G$1(F$1({}, this._def), { rest: t }));
  }
};
H$3(Ob, "ZodTuple");
var pl = Ob;
pl.create = (r5, t) => {
  if (!Array.isArray(r5)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new pl(F$1({ items: r5, typeName: ce.ZodTuple, rest: null }, be(t)));
};
var vy2 = class vy3 extends Ce {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    let { status: e, ctx: n4 } = this._processInputParams(t);
    if (n4.parsedType !== Vt.object) return Ft(n4, { code: Pt2.invalid_type, expected: Vt.object, received: n4.parsedType }), ae;
    let i = [], a4 = this._def.keyType, u5 = this._def.valueType;
    for (let h in n4.data) i.push({ key: a4._parse(new Ns2(n4, h, n4.path, h)), value: u5._parse(new Ns2(n4, n4.data[h], n4.path, h)), alwaysSet: h in n4.data });
    return n4.common.async ? Xi.mergeObjectAsync(e, i) : Xi.mergeObjectSync(e, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, e, n4) {
    return e instanceof Ce ? new vy3(F$1({ keyType: t, valueType: e, typeName: ce.ZodRecord }, be(n4))) : new vy3(F$1({ keyType: Tc2.create(), valueType: t, typeName: ce.ZodRecord }, be(e)));
  }
};
H$3(vy2, "ZodRecord");
var Tb = vy2, o3 = class o32 extends Ce {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    let { status: e, ctx: n4 } = this._processInputParams(t);
    if (n4.parsedType !== Vt.map) return Ft(n4, { code: Pt2.invalid_type, expected: Vt.map, received: n4.parsedType }), ae;
    let i = this._def.keyType, a4 = this._def.valueType, u5 = [...n4.data.entries()].map(([h, d], m5) => ({ key: i._parse(new Ns2(n4, h, n4.path, [m5, "key"])), value: a4._parse(new Ns2(n4, d, n4.path, [m5, "value"])) }));
    if (n4.common.async) {
      let h = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let d of u5) {
          let m5 = await d.key, v3 = await d.value;
          if (m5.status === "aborted" || v3.status === "aborted") return ae;
          (m5.status === "dirty" || v3.status === "dirty") && e.dirty(), h.set(m5.value, v3.value);
        }
        return { status: e.value, value: h };
      });
    } else {
      let h = /* @__PURE__ */ new Map();
      for (let d of u5) {
        let m5 = d.key, v3 = d.value;
        if (m5.status === "aborted" || v3.status === "aborted") return ae;
        (m5.status === "dirty" || v3.status === "dirty") && e.dirty(), h.set(m5.value, v3.value);
      }
      return { status: e.value, value: h };
    }
  }
};
H$3(o3, "ZodMap");
var Vd = o3;
Vd.create = (r5, t, e) => new Vd(F$1({ valueType: t, keyType: r5, typeName: ce.ZodMap }, be(e)));
var by2 = class by3 extends Ce {
  _parse(t) {
    let { status: e, ctx: n4 } = this._processInputParams(t);
    if (n4.parsedType !== Vt.set) return Ft(n4, { code: Pt2.invalid_type, expected: Vt.set, received: n4.parsedType }), ae;
    let i = this._def;
    i.minSize !== null && n4.data.size < i.minSize.value && (Ft(n4, { code: Pt2.too_small, minimum: i.minSize.value, type: "set", inclusive: true, exact: false, message: i.minSize.message }), e.dirty()), i.maxSize !== null && n4.data.size > i.maxSize.value && (Ft(n4, { code: Pt2.too_big, maximum: i.maxSize.value, type: "set", inclusive: true, exact: false, message: i.maxSize.message }), e.dirty());
    let a4 = this._def.valueType;
    function u5(d) {
      let m5 = /* @__PURE__ */ new Set();
      for (let v3 of d) {
        if (v3.status === "aborted") return ae;
        v3.status === "dirty" && e.dirty(), m5.add(v3.value);
      }
      return { status: e.value, value: m5 };
    }
    H$3(u5, "finalizeSet");
    let h = [...n4.data.values()].map((d, m5) => a4._parse(new Ns2(n4, d, n4.path, m5)));
    return n4.common.async ? Promise.all(h).then((d) => u5(d)) : u5(h);
  }
  min(t, e) {
    return new by3(G$1(F$1({}, this._def), { minSize: { value: t, message: Zt.toString(e) } }));
  }
  max(t, e) {
    return new by3(G$1(F$1({}, this._def), { maxSize: { value: t, message: Zt.toString(e) } }));
  }
  size(t, e) {
    return this.min(t, e).max(t, e);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
H$3(by2, "ZodSet");
var jd = by2;
jd.create = (r5, t) => new jd(F$1({ valueType: r5, minSize: null, maxSize: null, typeName: ce.ZodSet }, be(t)));
var Fd2 = class Fd3 extends Ce {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    let { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== Vt.function) return Ft(e, { code: Pt2.invalid_type, expected: Vt.function, received: e.parsedType }), ae;
    function n4(h, d) {
      return my2({ data: h, path: e.path, errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, Ad2(), lu2].filter((m5) => !!m5), issueData: { code: Pt2.invalid_arguments, argumentsError: d } });
    }
    H$3(n4, "makeArgsIssue");
    function i(h, d) {
      return my2({ data: h, path: e.path, errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, Ad2(), lu2].filter((m5) => !!m5), issueData: { code: Pt2.invalid_return_type, returnTypeError: d } });
    }
    H$3(i, "makeReturnsIssue");
    let a4 = { errorMap: e.common.contextualErrorMap }, u5 = e.data;
    if (this._def.returns instanceof Pc2) {
      let h = this;
      return ao(async function(...d) {
        let m5 = new Uo([]), v3 = await h._def.args.parseAsync(d, a4).catch((I3) => {
          throw m5.addIssue(n4(d, I3)), m5;
        }), x2 = await Reflect.apply(u5, this, v3);
        return await h._def.returns._def.type.parseAsync(x2, a4).catch((I3) => {
          throw m5.addIssue(i(x2, I3)), m5;
        });
      });
    } else {
      let h = this;
      return ao(function(...d) {
        let m5 = h._def.args.safeParse(d, a4);
        if (!m5.success) throw new Uo([n4(d, m5.error)]);
        let v3 = Reflect.apply(u5, this, m5.data), x2 = h._def.returns.safeParse(v3, a4);
        if (!x2.success) throw new Uo([i(v3, x2.error)]);
        return x2.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Fd3(G$1(F$1({}, this._def), { args: pl.create(t).rest(cu2.create()) }));
  }
  returns(t) {
    return new Fd3(G$1(F$1({}, this._def), { returns: t }));
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, e, n4) {
    return new Fd3(F$1({ args: t || pl.create([]).rest(cu2.create()), returns: e || cu2.create(), typeName: ce.ZodFunction }, be(n4)));
  }
};
H$3(Fd2, "ZodFunction");
var wb = Fd2, s3 = class s32 extends Ce {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    let { ctx: e } = this._processInputParams(t);
    return this._def.getter()._parse({ data: e.data, path: e.path, parent: e });
  }
};
H$3(s3, "ZodLazy");
var Sh3 = s3;
Sh3.create = (r5, t) => new Sh3(F$1({ getter: r5, typeName: ce.ZodLazy }, be(t)));
var a3 = class a32 extends Ce {
  _parse(t) {
    if (t.data !== this._def.value) {
      let e = this._getOrReturnCtx(t);
      return Ft(e, { received: e.data, code: Pt2.invalid_literal, expected: this._def.value }), ae;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
H$3(a3, "ZodLiteral");
var Ih2 = a3;
Ih2.create = (r5, t) => new Ih2(F$1({ value: r5, typeName: ce.ZodLiteral }, be(t)));
function y9(r5, t) {
  return new Mh3(F$1({ values: r5, typeName: ce.ZodEnum }, be(t)));
}
H$3(y9, "createZodEnum");
var xy2 = class xy3 extends Ce {
  _parse(t) {
    if (typeof t.data != "string") {
      let e = this._getOrReturnCtx(t), n4 = this._def.values;
      return Ft(e, { expected: fr.joinValues(n4), received: e.parsedType, code: Pt2.invalid_type }), ae;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(t.data)) {
      let e = this._getOrReturnCtx(t), n4 = this._def.values;
      return Ft(e, { received: e.data, code: Pt2.invalid_enum_value, options: n4 }), ae;
    }
    return ao(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let t = {};
    for (let e of this._def.values) t[e] = e;
    return t;
  }
  get Values() {
    let t = {};
    for (let e of this._def.values) t[e] = e;
    return t;
  }
  get Enum() {
    let t = {};
    for (let e of this._def.values) t[e] = e;
    return t;
  }
  extract(t, e = this._def) {
    return xy3.create(t, F$1(F$1({}, this._def), e));
  }
  exclude(t, e = this._def) {
    return xy3.create(this.options.filter((n4) => !t.includes(n4)), F$1(F$1({}, this._def), e));
  }
};
H$3(xy2, "ZodEnum");
var Mh3 = xy2;
Mh3.create = y9;
var l3 = class l32 extends Ce {
  _parse(t) {
    let e = fr.getValidEnumValues(this._def.values), n4 = this._getOrReturnCtx(t);
    if (n4.parsedType !== Vt.string && n4.parsedType !== Vt.number) {
      let i = fr.objectValues(e);
      return Ft(n4, { expected: fr.joinValues(i), received: n4.parsedType, code: Pt2.invalid_type }), ae;
    }
    if (this._cache || (this._cache = new Set(fr.getValidEnumValues(this._def.values))), !this._cache.has(t.data)) {
      let i = fr.objectValues(e);
      return Ft(n4, { received: n4.data, code: Pt2.invalid_enum_value, options: i }), ae;
    }
    return ao(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
H$3(l3, "ZodNativeEnum");
var Th3 = l3;
Th3.create = (r5, t) => new Th3(F$1({ values: r5, typeName: ce.ZodNativeEnum }, be(t)));
var u3 = class u32 extends Ce {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    let { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== Vt.promise && e.common.async === false) return Ft(e, { code: Pt2.invalid_type, expected: Vt.promise, received: e.parsedType }), ae;
    let n4 = e.parsedType === Vt.promise ? e.data : Promise.resolve(e.data);
    return ao(n4.then((i) => this._def.type.parseAsync(i, { path: e.path, errorMap: e.common.contextualErrorMap })));
  }
};
H$3(u3, "ZodPromise");
var Pc2 = u3;
Pc2.create = (r5, t) => new Pc2(F$1({ type: r5, typeName: ce.ZodPromise }, be(t)));
var c3 = class c32 extends Ce {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ce.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    let { status: e, ctx: n4 } = this._processInputParams(t), i = this._def.effect || null, a4 = { addIssue: H$3((u5) => {
      Ft(n4, u5), u5.fatal ? e.abort() : e.dirty();
    }, "addIssue"), get path() {
      return n4.path;
    } };
    if (a4.addIssue = a4.addIssue.bind(a4), i.type === "preprocess") {
      let u5 = i.transform(n4.data, a4);
      if (n4.common.async) return Promise.resolve(u5).then(async (h) => {
        if (e.value === "aborted") return ae;
        let d = await this._def.schema._parseAsync({ data: h, path: n4.path, parent: n4 });
        return d.status === "aborted" ? ae : d.status === "dirty" ? fh2(d.value) : e.value === "dirty" ? fh2(d.value) : d;
      });
      {
        if (e.value === "aborted") return ae;
        let h = this._def.schema._parseSync({ data: u5, path: n4.path, parent: n4 });
        return h.status === "aborted" ? ae : h.status === "dirty" ? fh2(h.value) : e.value === "dirty" ? fh2(h.value) : h;
      }
    }
    if (i.type === "refinement") {
      let u5 = H$3((h) => {
        let d = i.refinement(h, a4);
        if (n4.common.async) return Promise.resolve(d);
        if (d instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return h;
      }, "executeRefinement");
      if (n4.common.async === false) {
        let h = this._def.schema._parseSync({ data: n4.data, path: n4.path, parent: n4 });
        return h.status === "aborted" ? ae : (h.status === "dirty" && e.dirty(), u5(h.value), { status: e.value, value: h.value });
      } else return this._def.schema._parseAsync({ data: n4.data, path: n4.path, parent: n4 }).then((h) => h.status === "aborted" ? ae : (h.status === "dirty" && e.dirty(), u5(h.value).then(() => ({ status: e.value, value: h.value }))));
    }
    if (i.type === "transform") if (n4.common.async === false) {
      let u5 = this._def.schema._parseSync({ data: n4.data, path: n4.path, parent: n4 });
      if (!Mc2(u5)) return ae;
      let h = i.transform(u5.value, a4);
      if (h instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
      return { status: e.value, value: h };
    } else return this._def.schema._parseAsync({ data: n4.data, path: n4.path, parent: n4 }).then((u5) => Mc2(u5) ? Promise.resolve(i.transform(u5.value, a4)).then((h) => ({ status: e.value, value: h })) : ae);
    fr.assertNever(i);
  }
};
H$3(c3, "ZodEffects");
var ks2 = c3;
ks2.create = (r5, t, e) => new ks2(F$1({ schema: r5, typeName: ce.ZodEffects, effect: t }, be(e)));
ks2.createWithPreprocess = (r5, t, e) => new ks2(F$1({ schema: t, effect: { type: "preprocess", transform: r5 }, typeName: ce.ZodEffects }, be(e)));
var p3 = class p32 extends Ce {
  _parse(t) {
    return this._getType(t) === Vt.undefined ? ao(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
H$3(p3, "ZodOptional");
var As = p3;
As.create = (r5, t) => new As(F$1({ innerType: r5, typeName: ce.ZodOptional }, be(t)));
var h3 = class h32 extends Ce {
  _parse(t) {
    return this._getType(t) === Vt.null ? ao(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
H$3(h3, "ZodNullable");
var hl = h3;
hl.create = (r5, t) => new hl(F$1({ innerType: r5, typeName: ce.ZodNullable }, be(t)));
var f3 = class f32 extends Ce {
  _parse(t) {
    let { ctx: e } = this._processInputParams(t), n4 = e.data;
    return e.parsedType === Vt.undefined && (n4 = this._def.defaultValue()), this._def.innerType._parse({ data: n4, path: e.path, parent: e });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
H$3(f3, "ZodDefault");
var wh3 = f3;
wh3.create = (r5, t) => new wh3(F$1({ innerType: r5, typeName: ce.ZodDefault, defaultValue: typeof t.default == "function" ? t.default : () => t.default }, be(t)));
var d3 = class d32 extends Ce {
  _parse(t) {
    let { ctx: e } = this._processInputParams(t), n4 = G$1(F$1({}, e), { common: G$1(F$1({}, e.common), { issues: [] }) }), i = this._def.innerType._parse({ data: n4.data, path: n4.path, parent: F$1({}, n4) });
    return Nd2(i) ? i.then((a4) => ({ status: "valid", value: a4.status === "valid" ? a4.value : this._def.catchValue({ get error() {
      return new Uo(n4.common.issues);
    }, input: n4.data }) })) : { status: "valid", value: i.status === "valid" ? i.value : this._def.catchValue({ get error() {
      return new Uo(n4.common.issues);
    }, input: n4.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
H$3(d3, "ZodCatch");
var Ph3 = d3;
Ph3.create = (r5, t) => new Ph3(F$1({ innerType: r5, typeName: ce.ZodCatch, catchValue: typeof t.catch == "function" ? t.catch : () => t.catch }, be(t)));
var m3 = class m32 extends Ce {
  _parse(t) {
    if (this._getType(t) !== Vt.nan) {
      let n4 = this._getOrReturnCtx(t);
      return Ft(n4, { code: Pt2.invalid_type, expected: Vt.nan, received: n4.parsedType }), ae;
    }
    return { status: "valid", value: t.data };
  }
};
H$3(m3, "ZodNaN");
var Ud = m3;
Ud.create = (r5) => new Ud(F$1({ typeName: ce.ZodNaN }, be(r5)));
var IV = Symbol("zod_brand"), g3 = class g32 extends Ce {
  _parse(t) {
    let { ctx: e } = this._processInputParams(t), n4 = e.data;
    return this._def.type._parse({ data: n4, path: e.path, parent: e });
  }
  unwrap() {
    return this._def.type;
  }
};
H$3(g3, "ZodBranded");
var _y = g3, Db = class Db2 extends Ce {
  _parse(t) {
    let { status: e, ctx: n4 } = this._processInputParams(t);
    if (n4.common.async) return H$3(async () => {
      let a4 = await this._def.in._parseAsync({ data: n4.data, path: n4.path, parent: n4 });
      return a4.status === "aborted" ? ae : a4.status === "dirty" ? (e.dirty(), fh2(a4.value)) : this._def.out._parseAsync({ data: a4.value, path: n4.path, parent: n4 });
    }, "handleAsync")();
    {
      let i = this._def.in._parseSync({ data: n4.data, path: n4.path, parent: n4 });
      return i.status === "aborted" ? ae : i.status === "dirty" ? (e.dirty(), { status: "dirty", value: i.value }) : this._def.out._parseSync({ data: i.value, path: n4.path, parent: n4 });
    }
  }
  static create(t, e) {
    return new Db2({ in: t, out: e, typeName: ce.ZodPipeline });
  }
};
H$3(Db, "ZodPipeline");
var Cy2 = Db, y3 = class y32 extends Ce {
  _parse(t) {
    let e = this._def.innerType._parse(t), n4 = H$3((i) => (Mc2(i) && (i.value = Object.freeze(i.value)), i), "freeze");
    return Nd2(e) ? e.then((i) => n4(i)) : n4(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
H$3(y3, "ZodReadonly");
var Eh3 = y3;
Eh3.create = (r5, t) => new Eh3(F$1({ innerType: r5, typeName: ce.ZodReadonly }, be(t)));
function f9(r5, t) {
  let e = typeof r5 == "function" ? r5(t) : typeof r5 == "string" ? { message: r5 } : r5;
  return typeof e == "string" ? { message: e } : e;
}
H$3(f9, "cleanParams");
function v9(r5, t = {}, e) {
  return r5 ? wc2.create().superRefine((n4, i) => {
    var u5, h;
    let a4 = r5(n4);
    if (a4 instanceof Promise) return a4.then((d) => {
      var m5, v3;
      if (!d) {
        let x2 = f9(t, n4), S4 = (v3 = (m5 = x2.fatal) != null ? m5 : e) != null ? v3 : true;
        i.addIssue(G$1(F$1({ code: "custom" }, x2), { fatal: S4 }));
      }
    });
    if (!a4) {
      let d = f9(t, n4), m5 = (h = (u5 = d.fatal) != null ? u5 : e) != null ? h : true;
      i.addIssue(G$1(F$1({ code: "custom" }, d), { fatal: m5 }));
    }
  }) : wc2.create();
}
H$3(v9, "custom");
var MV = { object: zo.lazycreate }, ce;
(function(r5) {
  r5.ZodString = "ZodString", r5.ZodNumber = "ZodNumber", r5.ZodNaN = "ZodNaN", r5.ZodBigInt = "ZodBigInt", r5.ZodBoolean = "ZodBoolean", r5.ZodDate = "ZodDate", r5.ZodSymbol = "ZodSymbol", r5.ZodUndefined = "ZodUndefined", r5.ZodNull = "ZodNull", r5.ZodAny = "ZodAny", r5.ZodUnknown = "ZodUnknown", r5.ZodNever = "ZodNever", r5.ZodVoid = "ZodVoid", r5.ZodArray = "ZodArray", r5.ZodObject = "ZodObject", r5.ZodUnion = "ZodUnion", r5.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r5.ZodIntersection = "ZodIntersection", r5.ZodTuple = "ZodTuple", r5.ZodRecord = "ZodRecord", r5.ZodMap = "ZodMap", r5.ZodSet = "ZodSet", r5.ZodFunction = "ZodFunction", r5.ZodLazy = "ZodLazy", r5.ZodLiteral = "ZodLiteral", r5.ZodEnum = "ZodEnum", r5.ZodEffects = "ZodEffects", r5.ZodNativeEnum = "ZodNativeEnum", r5.ZodOptional = "ZodOptional", r5.ZodNullable = "ZodNullable", r5.ZodDefault = "ZodDefault", r5.ZodCatch = "ZodCatch", r5.ZodPromise = "ZodPromise", r5.ZodBranded = "ZodBranded", r5.ZodPipeline = "ZodPipeline", r5.ZodReadonly = "ZodReadonly";
})(ce || (ce = {}));
var TV = H$3((r5, t = { message: "Input not instance of ".concat(r5.name) }) => v9((e) => e instanceof r5, t), "instanceOfType"), b9 = Tc2.create, x9 = mh2.create, wV = Ud.create, PV = gh3.create, _9 = yh3.create, EV = vh3.create, OV = Bd2.create, DV = bh3.create, LV = xh3.create, AV = wc2.create, NV = cu2.create, kV = fa2.create, RV = Gd2.create, FV = pu2.create, BV = zo.create, GV = zo.strictCreate, VV = _h3.create, jV = Mb.create, UV = Ch3.create, zV = pl.create, HV = Tb.create, XV = Vd.create, YV = jd.create, qV = wb.create, WV = Sh3.create, ZV = Ih2.create, $V = Mh3.create, JV = Th3.create, KV = Pc2.create, QV = ks2.create, tj = As.create, ej = hl.create, rj = ks2.createWithPreprocess, nj = Cy2.create, ij = H$3(() => b9().optional(), "ostring"), oj = H$3(() => x9().optional(), "onumber"), sj = H$3(() => _9().optional(), "oboolean"), aj = { string: H$3((r5) => Tc2.create(G$1(F$1({}, r5), { coerce: true })), "string"), number: H$3((r5) => mh2.create(G$1(F$1({}, r5), { coerce: true })), "number"), boolean: H$3((r5) => yh3.create(G$1(F$1({}, r5), { coerce: true })), "boolean"), bigint: H$3((r5) => gh3.create(G$1(F$1({}, r5), { coerce: true })), "bigint"), date: H$3((r5) => vh3.create(G$1(F$1({}, r5), { coerce: true })), "date") };
var lj = ae;
var C9 = Q;
var Pi = C9;
var K9 = N$2(P3());
var Py = 4, ez = 8, rz = "0.6", J9 = "low-priority-pin", E3 = Q.object({ rank: Q.union([Q.enum(["low", "medium", "high", "always-visible"]), Q.number()]).optional(), interactive: Q.union([Q.boolean(), Q.literal("pointer-events-auto")]).optional(), id: Q.string().optional(), anchor: Q.union([Q.enum(["top", "bottom", "left", "right", "center", "top-left", "top-right", "bottom-left", "bottom-right"]), Q.array(Q.enum(["top", "bottom", "left", "right", "center", "top-left", "top-right", "bottom-left", "bottom-right"]))]).optional(), dynamicResize: Q.boolean().optional(), zIndex: Q.number().optional(), lowPriorityPin: Q.object({ enabled: Q.boolean().optional(), size: Q.number().positive().optional(), color: Q.string().optional() }).optional() });
function Q9(r5, t, e) {
  Q.array(Q.number()).min(2).max(3).parse(r5), Q.string().parse(t), E3.parse(e);
}
H$3(Q9, "validateMarker");
var nz = Object.freeze({ enabled: true, size: ez, color: "#666" }), Ah2 = class Ah3 {
  constructor(t, e = {}) {
    O(this, "id");
    O(this, "type", "marker");
    O(this, "rank", 0);
    O(this, "initialRank", 0);
    O(this, "activeAnchor", "center");
    O(this, "pointerEvents", "none");
    O(this, "options", { rank: "low", interactive: false, id: "", anchor: "center", dynamicResize: false, occluderId: 0, zIndex: void 0, verticalOffset: 0, lowPriorityPin: F$1({}, nz) });
    O(this, "projection", new ot$1());
    O(this, "enabled", true);
    O(this, "canShow", false);
    O(this, "visible", true);
    O(this, "isOccluded", false);
    O(this, "offscreen", false);
    O(this, "strategyIndex", -1);
    O(this, "activeBoundingBox", { x: 0, y: 0, w: 0, h: 0 });
    O(this, "dimensions", { width: 0, height: 0 });
    O(this, "markerContainer");
    O(this, "containerEl");
    O(this, "contentEl", null);
    O(this, "contentHtml", "");
    O(this, "style", { top: "0px", left: "0px" });
    O(this, "dirty", false);
    O(this, "attachedDirty", true);
    O(this, "collisionDirty", true);
    O(this, "visibilityNeedsUpdate", "show");
    O(this, "animation", null);
    O(this, "currentStrategyIndex", -1);
    O(this, "onStrategySelected", H$3((t5, e4 = false) => {
      var i5, a10;
      if (this.currentStrategyIndex === t5 && !e4) return;
      if (this.currentStrategyIndex = t5, t5 === this.lowPriorityPinStrategyIndex) {
        this.activeAnchor = "center", this.markerContainer.setAttribute("data-anchor", J9);
        let u5 = this.options.lowPriorityPin, h = u5.size, d = u5.color;
        this.markerContainer.style.setProperty("--mappedin-pin-size", "".concat(h, "px")), this.markerContainer.style.setProperty("--pin-color", d), this.markerContainer.style.opacity = rz, this.style.top = -h / 2 + "px", this.style.left = -h / 2 + "px";
      } else {
        this.activeAnchor = (a10 = (i5 = this.strategies[t5]) == null ? void 0 : i5.name) != null ? a10 : "center", this.markerContainer.setAttribute("data-anchor", this.activeAnchor), this.markerContainer.style.removeProperty("--mappedin-pin-size"), this.markerContainer.style.removeProperty("--pin-color"), this.markerContainer.style.opacity = "1";
        let { width: u5, height: h } = this.dimensions, d = -h / 2 + "px", m5 = -u5 / 2 + "px";
        switch (this.style.top = d, this.style.left = m5, this.activeAnchor) {
          case "top": {
            this.style.top = -h + "px";
            break;
          }
          case "bottom": {
            this.style.top = "0px";
            break;
          }
          case "left": {
            this.style.left = -u5 + "px";
            break;
          }
          case "right": {
            this.style.left = "0px";
            break;
          }
          case "top-left": {
            this.style.top = -h + "px", this.style.left = -u5 + "px";
            break;
          }
          case "top-right": {
            this.style.top = -h + "px", this.style.left = "0px";
            break;
          }
          case "bottom-left": {
            this.style.top = "0px", this.style.left = -u5 + "px";
            break;
          }
          case "bottom-right": {
            this.style.top = "0px", this.style.left = "0px";
            break;
          }
          default:
            this.style.top = d, this.style.left = m5;
        }
      }
      this.markerContainer.style.top = this.style.top, this.markerContainer.style.left = this.style.left;
    }, "onStrategySelected"));
    O(this, "packedMessage", { x: 0, y: 0, enabled: false, rank: 0, bboxes: [], lockedToStrategyIndex: -1, shouldCollideWithScreenEdges: false });
    var n4, i, a4;
    if (this.id = (e == null ? void 0 : e.id) || E(), this.options = (0, K9.default)(this.options, e), typeof e.rank == "string") this.rank = Dd(e.rank);
    else if (e.rank != null && e.rank > 0) this.rank = e.rank;
    else {
      let u5 = Math.trunc(p$1.env.NODE_ENV === "test" ? Ah3.testId : Ah3.testId * 10) / 10;
      Ah3.testId += 1e-3, this.rank = u5;
    }
    typeof e.interactive == "string" && (this.pointerEvents = e.interactive === "pointer-events-auto" ? "auto" : "none"), this.contentHtml = t, this.initialRank = this.rank, this.markerContainer = document.createElement("div"), this.markerContainer.className = "mappedin-marker", this.markerContainer.style.opacity = "0", this.markerContainer.innerHTML = '<div class="mappedin-marker-content">'.concat(this.contentHtml, "</div>"), this.markerContainer.setAttribute("data-marker-id", this.id.toString()), this.containerEl = (n4 = this.markerContainer.firstElementChild) != null ? n4 : null, this.contentEl = (a4 = (i = this.markerContainer.firstElementChild) == null ? void 0 : i.firstElementChild) != null ? a4 : null;
  }
  updateDimensions(t, e) {
    if (t != null && e != null) this.dimensions = { width: t, height: e };
    else {
      let { width: n4, height: i } = this.markerContainer.getBoundingClientRect();
      this.dimensions = { width: n4, height: i };
    }
    Object.assign(this.markerContainer, { width: this.dimensions.width + "px", height: this.dimensions.height + "px" }), this.currentStrategyIndex = -1;
  }
  get strategies() {
    var a4;
    let { width: t, height: e } = this.dimensions;
    if (t === 0 || e === 0) return [];
    let i = (Array.isArray(this.options.anchor) ? this.options.anchor : [this.options.anchor]).map((u5) => ({ name: u5, getBoundingBox: H$3(() => {
      let h = e / 2, d = e / 2, m5 = t / 2, v3 = t / 2;
      switch (u5) {
        case "top": {
          h = e, d = 0;
          break;
        }
        case "bottom": {
          h = 0, d = e;
          break;
        }
        case "left": {
          m5 = t, v3 = 0;
          break;
        }
        case "right": {
          m5 = 0, v3 = t;
          break;
        }
        case "top-left": {
          h = e, m5 = t, d = 0, v3 = 0;
          break;
        }
        case "top-right": {
          h = e, v3 = t, d = 0, m5 = 0;
          break;
        }
        case "bottom-left": {
          d = e, m5 = t, h = 0, v3 = 0;
          break;
        }
        case "bottom-right": {
          d = e, v3 = t, h = 0, m5 = 0;
          break;
        }
      }
      return [h + Py, d + Py, m5 + Py, v3 + Py];
    }, "getBoundingBox") }));
    if ((a4 = this.options.lowPriorityPin) != null && a4.enabled && this.options.rank !== "always-visible") {
      let u5 = { name: J9, getBoundingBox: H$3(() => {
        let h = Math.max(2, Py / 2);
        return [this.options.lowPriorityPin.size / 2 + h, this.options.lowPriorityPin.size / 2 + h, this.options.lowPriorityPin.size / 2 + h, this.options.lowPriorityPin.size / 2 + h];
      }, "getBoundingBox") };
      i.push(u5);
    }
    return i;
  }
  toPackedMessage(t = false) {
    var n4;
    this.packedMessage.x = this.projection.x, this.packedMessage.y = this.projection.y, this.packedMessage.enabled = this.enabled, this.packedMessage.rank = this.rank, this.packedMessage.shouldCollideWithScreenEdges = true;
    let e = this.currentStrategyIndex !== -1 && this.currentStrategyIndex !== this.lowPriorityPinStrategyIndex;
    if (this.visible && t && e && this.collisionDirty === false ? this.packedMessage.lockedToStrategyIndex = this.currentStrategyIndex : this.packedMessage.lockedToStrategyIndex = -1, e && this.currentStrategyIndex !== ((n4 = this.packedMessage.bboxes[0]) == null ? void 0 : n4[4])) {
      let i = this.packedMessage.bboxes.findIndex((a4) => a4[4] === this.currentStrategyIndex);
      if (i !== -1) {
        let a4 = this.packedMessage.bboxes.splice(i, 1)[0];
        this.packedMessage.bboxes.unshift(a4);
      }
    }
    if (!this.collisionDirty) return this.packedMessage;
    this.packedMessage.bboxes = [];
    for (let i = 0; i < this.strategies.length; i++) {
      let a4 = this.strategies[i];
      i === this.currentStrategyIndex && e ? this.packedMessage.bboxes.unshift([...a4.getBoundingBox(), i]) : this.packedMessage.bboxes.push([...a4.getBoundingBox(), i]);
    }
    return this.collisionDirty = false, this.packedMessage;
  }
  get lowPriorityPinStrategyIndex() {
    var t;
    return !((t = this.options.lowPriorityPin) != null && t.enabled) || this.options.rank === "always-visible" ? -1 : Array.isArray(this.options.anchor) ? this.options.anchor.length : 1;
  }
  destroy() {
  }
};
H$3(Ah2, "MarkerComponent"), O(Ah2, "testId", 0);
var fl = Ah2;
a();
a();
a();
a();
a();
var O3 = class O32 {
  constructor() {
    O(this, "hover", false);
    O(this, "dirty", false);
  }
};
H$3(O3, "InteractionComponent");
var Yd2 = O3;
a();
a();
function Vb(r5) {
  "@babel/helpers - typeof";
  return Vb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vb(r5);
}
H$3(Vb, "_typeof");
var iz = /^\s+/, oz = /\s+$/;
function Xt(r5, t) {
  if (r5 = r5 || "", t = t || {}, r5 instanceof Xt) return r5;
  if (!(this instanceof Xt)) return new Xt(r5, t);
  var e = sz(r5);
  this._originalInput = r5, this._r = e.r, this._g = e.g, this._b = e.b, this._a = e.a, this._roundA = Math.round(100 * this._a) / 100, this._format = t.format || e.format, this._gradientType = t.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = e.ok;
}
H$3(Xt, "tinycolor");
Xt.prototype = { isDark: H$3(function() {
  return this.getBrightness() < 128;
}, "isDark"), isLight: H$3(function() {
  return !this.isDark();
}, "isLight"), isValid: H$3(function() {
  return this._ok;
}, "isValid"), getOriginalInput: H$3(function() {
  return this._originalInput;
}, "getOriginalInput"), getFormat: H$3(function() {
  return this._format;
}, "getFormat"), getAlpha: H$3(function() {
  return this._a;
}, "getAlpha"), getBrightness: H$3(function() {
  var t = this.toRgb();
  return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
}, "getBrightness"), getLuminance: H$3(function() {
  var t = this.toRgb(), e, n4, i, a4, u5, h;
  return e = t.r / 255, n4 = t.g / 255, i = t.b / 255, e <= 0.03928 ? a4 = e / 12.92 : a4 = Math.pow((e + 0.055) / 1.055, 2.4), n4 <= 0.03928 ? u5 = n4 / 12.92 : u5 = Math.pow((n4 + 0.055) / 1.055, 2.4), i <= 0.03928 ? h = i / 12.92 : h = Math.pow((i + 0.055) / 1.055, 2.4), 0.2126 * a4 + 0.7152 * u5 + 0.0722 * h;
}, "getLuminance"), setAlpha: H$3(function(t) {
  return this._a = s8(t), this._roundA = Math.round(100 * this._a) / 100, this;
}, "setAlpha"), toHsv: H$3(function() {
  var t = e8(this._r, this._g, this._b);
  return { h: t.h * 360, s: t.s, v: t.v, a: this._a };
}, "toHsv"), toHsvString: H$3(function() {
  var t = e8(this._r, this._g, this._b), e = Math.round(t.h * 360), n4 = Math.round(t.s * 100), i = Math.round(t.v * 100);
  return this._a == 1 ? "hsv(" + e + ", " + n4 + "%, " + i + "%)" : "hsva(" + e + ", " + n4 + "%, " + i + "%, " + this._roundA + ")";
}, "toHsvString"), toHsl: H$3(function() {
  var t = t8(this._r, this._g, this._b);
  return { h: t.h * 360, s: t.s, l: t.l, a: this._a };
}, "toHsl"), toHslString: H$3(function() {
  var t = t8(this._r, this._g, this._b), e = Math.round(t.h * 360), n4 = Math.round(t.s * 100), i = Math.round(t.l * 100);
  return this._a == 1 ? "hsl(" + e + ", " + n4 + "%, " + i + "%)" : "hsla(" + e + ", " + n4 + "%, " + i + "%, " + this._roundA + ")";
}, "toHslString"), toHex: H$3(function(t) {
  return r8(this._r, this._g, this._b, t);
}, "toHex"), toHexString: H$3(function(t) {
  return "#" + this.toHex(t);
}, "toHexString"), toHex8: H$3(function(t) {
  return cz(this._r, this._g, this._b, this._a, t);
}, "toHex8"), toHex8String: H$3(function(t) {
  return "#" + this.toHex8(t);
}, "toHex8String"), toRgb: H$3(function() {
  return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
}, "toRgb"), toRgbString: H$3(function() {
  return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
}, "toRgbString"), toPercentageRgb: H$3(function() {
  return { r: Math.round(_n(this._r, 255) * 100) + "%", g: Math.round(_n(this._g, 255) * 100) + "%", b: Math.round(_n(this._b, 255) * 100) + "%", a: this._a };
}, "toPercentageRgb"), toPercentageRgbString: H$3(function() {
  return this._a == 1 ? "rgb(" + Math.round(_n(this._r, 255) * 100) + "%, " + Math.round(_n(this._g, 255) * 100) + "%, " + Math.round(_n(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(_n(this._r, 255) * 100) + "%, " + Math.round(_n(this._g, 255) * 100) + "%, " + Math.round(_n(this._b, 255) * 100) + "%, " + this._roundA + ")";
}, "toPercentageRgbString"), toName: H$3(function() {
  return this._a === 0 ? "transparent" : this._a < 1 ? false : Cz[r8(this._r, this._g, this._b, true)] || false;
}, "toName"), toFilter: H$3(function(t) {
  var e = "#" + n8(this._r, this._g, this._b, this._a), n4 = e, i = this._gradientType ? "GradientType = 1, " : "";
  if (t) {
    var a4 = Xt(t);
    n4 = "#" + n8(a4._r, a4._g, a4._b, a4._a);
  }
  return "progid:DXImageTransform.Microsoft.gradient(" + i + "startColorstr=" + e + ",endColorstr=" + n4 + ")";
}, "toFilter"), toString: H$3(function(t) {
  var e = !!t;
  t = t || this._format;
  var n4 = false, i = this._a < 1 && this._a >= 0, a4 = !e && i && (t === "hex" || t === "hex6" || t === "hex3" || t === "hex4" || t === "hex8" || t === "name");
  return a4 ? t === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (n4 = this.toRgbString()), t === "prgb" && (n4 = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (n4 = this.toHexString()), t === "hex3" && (n4 = this.toHexString(true)), t === "hex4" && (n4 = this.toHex8String(true)), t === "hex8" && (n4 = this.toHex8String()), t === "name" && (n4 = this.toName()), t === "hsl" && (n4 = this.toHslString()), t === "hsv" && (n4 = this.toHsvString()), n4 || this.toHexString());
}, "toString"), clone: H$3(function() {
  return Xt(this.toString());
}, "clone"), _applyModification: H$3(function(t, e) {
  var n4 = t.apply(null, [this].concat([].slice.call(e)));
  return this._r = n4._r, this._g = n4._g, this._b = n4._b, this.setAlpha(n4._a), this;
}, "_applyModification"), lighten: H$3(function() {
  return this._applyModification(dz, arguments);
}, "lighten"), brighten: H$3(function() {
  return this._applyModification(mz, arguments);
}, "brighten"), darken: H$3(function() {
  return this._applyModification(gz, arguments);
}, "darken"), desaturate: H$3(function() {
  return this._applyModification(pz, arguments);
}, "desaturate"), saturate: H$3(function() {
  return this._applyModification(hz, arguments);
}, "saturate"), greyscale: H$3(function() {
  return this._applyModification(fz, arguments);
}, "greyscale"), spin: H$3(function() {
  return this._applyModification(yz, arguments);
}, "spin"), _applyCombination: H$3(function(t, e) {
  return t.apply(null, [this].concat([].slice.call(e)));
}, "_applyCombination"), analogous: H$3(function() {
  return this._applyCombination(xz, arguments);
}, "analogous"), complement: H$3(function() {
  return this._applyCombination(vz, arguments);
}, "complement"), monochromatic: H$3(function() {
  return this._applyCombination(_z, arguments);
}, "monochromatic"), splitcomplement: H$3(function() {
  return this._applyCombination(bz, arguments);
}, "splitcomplement"), triad: H$3(function() {
  return this._applyCombination(i8, [3]);
}, "triad"), tetrad: H$3(function() {
  return this._applyCombination(i8, [4]);
}, "tetrad") };
Xt.fromRatio = function(r5, t) {
  if (Vb(r5) == "object") {
    var e = {};
    for (var n4 in r5) r5.hasOwnProperty(n4) && (n4 === "a" ? e[n4] = r5[n4] : e[n4] = Ey2(r5[n4]));
    r5 = e;
  }
  return Xt(r5, t);
};
function sz(r5) {
  var t = { r: 0, g: 0, b: 0 }, e = 1, n4 = null, i = null, a4 = null, u5 = false, h = false;
  return typeof r5 == "string" && (r5 = Tz(r5)), Vb(r5) == "object" && (du2(r5.r) && du2(r5.g) && du2(r5.b) ? (t = az(r5.r, r5.g, r5.b), u5 = true, h = String(r5.r).substr(-1) === "%" ? "prgb" : "rgb") : du2(r5.h) && du2(r5.s) && du2(r5.v) ? (n4 = Ey2(r5.s), i = Ey2(r5.v), t = uz(r5.h, n4, i), u5 = true, h = "hsv") : du2(r5.h) && du2(r5.s) && du2(r5.l) && (n4 = Ey2(r5.s), a4 = Ey2(r5.l), t = lz(r5.h, n4, a4), u5 = true, h = "hsl"), r5.hasOwnProperty("a") && (e = r5.a)), e = s8(e), { ok: u5, format: r5.format || h, r: Math.min(255, Math.max(t.r, 0)), g: Math.min(255, Math.max(t.g, 0)), b: Math.min(255, Math.max(t.b, 0)), a: e };
}
H$3(sz, "inputToRGB");
function az(r5, t, e) {
  return { r: _n(r5, 255) * 255, g: _n(t, 255) * 255, b: _n(e, 255) * 255 };
}
H$3(az, "rgbToRgb");
function t8(r5, t, e) {
  r5 = _n(r5, 255), t = _n(t, 255), e = _n(e, 255);
  var n4 = Math.max(r5, t, e), i = Math.min(r5, t, e), a4, u5, h = (n4 + i) / 2;
  if (n4 == i) a4 = u5 = 0;
  else {
    var d = n4 - i;
    switch (u5 = h > 0.5 ? d / (2 - n4 - i) : d / (n4 + i), n4) {
      case r5:
        a4 = (t - e) / d + (t < e ? 6 : 0);
        break;
      case t:
        a4 = (e - r5) / d + 2;
        break;
      case e:
        a4 = (r5 - t) / d + 4;
        break;
    }
    a4 /= 6;
  }
  return { h: a4, s: u5, l: h };
}
H$3(t8, "rgbToHsl");
function lz(r5, t, e) {
  var n4, i, a4;
  r5 = _n(r5, 360), t = _n(t, 100), e = _n(e, 100);
  function u5(m5, v3, x2) {
    return x2 < 0 && (x2 += 1), x2 > 1 && (x2 -= 1), x2 < 1 / 6 ? m5 + (v3 - m5) * 6 * x2 : x2 < 1 / 2 ? v3 : x2 < 2 / 3 ? m5 + (v3 - m5) * (2 / 3 - x2) * 6 : m5;
  }
  if (H$3(u5, "hue2rgb"), t === 0) n4 = i = a4 = e;
  else {
    var h = e < 0.5 ? e * (1 + t) : e + t - e * t, d = 2 * e - h;
    n4 = u5(d, h, r5 + 1 / 3), i = u5(d, h, r5), a4 = u5(d, h, r5 - 1 / 3);
  }
  return { r: n4 * 255, g: i * 255, b: a4 * 255 };
}
H$3(lz, "hslToRgb");
function e8(r5, t, e) {
  r5 = _n(r5, 255), t = _n(t, 255), e = _n(e, 255);
  var n4 = Math.max(r5, t, e), i = Math.min(r5, t, e), a4, u5, h = n4, d = n4 - i;
  if (u5 = n4 === 0 ? 0 : d / n4, n4 == i) a4 = 0;
  else {
    switch (n4) {
      case r5:
        a4 = (t - e) / d + (t < e ? 6 : 0);
        break;
      case t:
        a4 = (e - r5) / d + 2;
        break;
      case e:
        a4 = (r5 - t) / d + 4;
        break;
    }
    a4 /= 6;
  }
  return { h: a4, s: u5, v: h };
}
H$3(e8, "rgbToHsv");
function uz(r5, t, e) {
  r5 = _n(r5, 360) * 6, t = _n(t, 100), e = _n(e, 100);
  var n4 = Math.floor(r5), i = r5 - n4, a4 = e * (1 - t), u5 = e * (1 - i * t), h = e * (1 - (1 - i) * t), d = n4 % 6, m5 = [e, u5, a4, a4, h, e][d], v3 = [h, e, e, u5, a4, a4][d], x2 = [a4, a4, h, e, e, u5][d];
  return { r: m5 * 255, g: v3 * 255, b: x2 * 255 };
}
H$3(uz, "hsvToRgb");
function r8(r5, t, e, n4) {
  var i = [ma2(Math.round(r5).toString(16)), ma2(Math.round(t).toString(16)), ma2(Math.round(e).toString(16))];
  return n4 && i[0].charAt(0) == i[0].charAt(1) && i[1].charAt(0) == i[1].charAt(1) && i[2].charAt(0) == i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
H$3(r8, "rgbToHex");
function cz(r5, t, e, n4, i) {
  var a4 = [ma2(Math.round(r5).toString(16)), ma2(Math.round(t).toString(16)), ma2(Math.round(e).toString(16)), ma2(a8(n4))];
  return i && a4[0].charAt(0) == a4[0].charAt(1) && a4[1].charAt(0) == a4[1].charAt(1) && a4[2].charAt(0) == a4[2].charAt(1) && a4[3].charAt(0) == a4[3].charAt(1) ? a4[0].charAt(0) + a4[1].charAt(0) + a4[2].charAt(0) + a4[3].charAt(0) : a4.join("");
}
H$3(cz, "rgbaToHex");
function n8(r5, t, e, n4) {
  var i = [ma2(a8(n4)), ma2(Math.round(r5).toString(16)), ma2(Math.round(t).toString(16)), ma2(Math.round(e).toString(16))];
  return i.join("");
}
H$3(n8, "rgbaToArgbHex");
Xt.equals = function(r5, t) {
  return !r5 || !t ? false : Xt(r5).toRgbString() == Xt(t).toRgbString();
};
Xt.random = function() {
  return Xt.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
};
function pz(r5, t) {
  t = t === 0 ? 0 : t || 10;
  var e = Xt(r5).toHsl();
  return e.s -= t / 100, e.s = jb(e.s), Xt(e);
}
H$3(pz, "_desaturate");
function hz(r5, t) {
  t = t === 0 ? 0 : t || 10;
  var e = Xt(r5).toHsl();
  return e.s += t / 100, e.s = jb(e.s), Xt(e);
}
H$3(hz, "_saturate");
function fz(r5) {
  return Xt(r5).desaturate(100);
}
H$3(fz, "_greyscale");
function dz(r5, t) {
  t = t === 0 ? 0 : t || 10;
  var e = Xt(r5).toHsl();
  return e.l += t / 100, e.l = jb(e.l), Xt(e);
}
H$3(dz, "_lighten");
function mz(r5, t) {
  t = t === 0 ? 0 : t || 10;
  var e = Xt(r5).toRgb();
  return e.r = Math.max(0, Math.min(255, e.r - Math.round(255 * -(t / 100)))), e.g = Math.max(0, Math.min(255, e.g - Math.round(255 * -(t / 100)))), e.b = Math.max(0, Math.min(255, e.b - Math.round(255 * -(t / 100)))), Xt(e);
}
H$3(mz, "_brighten");
function gz(r5, t) {
  t = t === 0 ? 0 : t || 10;
  var e = Xt(r5).toHsl();
  return e.l -= t / 100, e.l = jb(e.l), Xt(e);
}
H$3(gz, "_darken");
function yz(r5, t) {
  var e = Xt(r5).toHsl(), n4 = (e.h + t) % 360;
  return e.h = n4 < 0 ? 360 + n4 : n4, Xt(e);
}
H$3(yz, "_spin");
function vz(r5) {
  var t = Xt(r5).toHsl();
  return t.h = (t.h + 180) % 360, Xt(t);
}
H$3(vz, "_complement");
function i8(r5, t) {
  if (isNaN(t) || t <= 0) throw new Error("Argument to polyad must be a positive number");
  for (var e = Xt(r5).toHsl(), n4 = [Xt(r5)], i = 360 / t, a4 = 1; a4 < t; a4++) n4.push(Xt({ h: (e.h + a4 * i) % 360, s: e.s, l: e.l }));
  return n4;
}
H$3(i8, "polyad");
function bz(r5) {
  var t = Xt(r5).toHsl(), e = t.h;
  return [Xt(r5), Xt({ h: (e + 72) % 360, s: t.s, l: t.l }), Xt({ h: (e + 216) % 360, s: t.s, l: t.l })];
}
H$3(bz, "_splitcomplement");
function xz(r5, t, e) {
  t = t || 6, e = e || 30;
  var n4 = Xt(r5).toHsl(), i = 360 / e, a4 = [Xt(r5)];
  for (n4.h = (n4.h - (i * t >> 1) + 720) % 360; --t; ) n4.h = (n4.h + i) % 360, a4.push(Xt(n4));
  return a4;
}
H$3(xz, "_analogous");
function _z(r5, t) {
  t = t || 6;
  for (var e = Xt(r5).toHsv(), n4 = e.h, i = e.s, a4 = e.v, u5 = [], h = 1 / t; t--; ) u5.push(Xt({ h: n4, s: i, v: a4 })), a4 = (a4 + h) % 1;
  return u5;
}
H$3(_z, "_monochromatic");
Xt.mix = function(r5, t, e) {
  e = e === 0 ? 0 : e || 50;
  var n4 = Xt(r5).toRgb(), i = Xt(t).toRgb(), a4 = e / 100, u5 = { r: (i.r - n4.r) * a4 + n4.r, g: (i.g - n4.g) * a4 + n4.g, b: (i.b - n4.b) * a4 + n4.b, a: (i.a - n4.a) * a4 + n4.a };
  return Xt(u5);
};
Xt.readability = function(r5, t) {
  var e = Xt(r5), n4 = Xt(t);
  return (Math.max(e.getLuminance(), n4.getLuminance()) + 0.05) / (Math.min(e.getLuminance(), n4.getLuminance()) + 0.05);
};
Xt.isReadable = function(r5, t, e) {
  var n4 = Xt.readability(r5, t), i, a4;
  switch (a4 = false, i = wz(e), i.level + i.size) {
    case "AAsmall":
    case "AAAlarge":
      a4 = n4 >= 4.5;
      break;
    case "AAlarge":
      a4 = n4 >= 3;
      break;
    case "AAAsmall":
      a4 = n4 >= 7;
      break;
  }
  return a4;
};
Xt.mostReadable = function(r5, t, e) {
  var n4 = null, i = 0, a4, u5, h, d;
  e = e || {}, u5 = e.includeFallbackColors, h = e.level, d = e.size;
  for (var m5 = 0; m5 < t.length; m5++) a4 = Xt.readability(r5, t[m5]), a4 > i && (i = a4, n4 = Xt(t[m5]));
  return Xt.isReadable(r5, n4, { level: h, size: d }) || !u5 ? n4 : (e.includeFallbackColors = false, Xt.mostReadable(r5, ["#fff", "#000"], e));
};
var D3 = Xt.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, Cz = Xt.hexNames = Sz(D3);
function Sz(r5) {
  var t = {};
  for (var e in r5) r5.hasOwnProperty(e) && (t[r5[e]] = e);
  return t;
}
H$3(Sz, "flip");
function s8(r5) {
  return r5 = parseFloat(r5), (isNaN(r5) || r5 < 0 || r5 > 1) && (r5 = 1), r5;
}
H$3(s8, "boundAlpha");
function _n(r5, t) {
  Iz(r5) && (r5 = "100%");
  var e = Mz(r5);
  return r5 = Math.min(t, Math.max(0, parseFloat(r5))), e && (r5 = parseInt(r5 * t, 10) / 100), Math.abs(r5 - t) < 1e-6 ? 1 : r5 % t / parseFloat(t);
}
H$3(_n, "bound01");
function jb(r5) {
  return Math.min(1, Math.max(0, r5));
}
H$3(jb, "clamp01");
function cs(r5) {
  return parseInt(r5, 16);
}
H$3(cs, "parseIntFromHex");
function Iz(r5) {
  return typeof r5 == "string" && r5.indexOf(".") != -1 && parseFloat(r5) === 1;
}
H$3(Iz, "isOnePointZero");
function Mz(r5) {
  return typeof r5 == "string" && r5.indexOf("%") != -1;
}
H$3(Mz, "isPercentage");
function ma2(r5) {
  return r5.length == 1 ? "0" + r5 : "" + r5;
}
H$3(ma2, "pad2");
function Ey2(r5) {
  return r5 <= 1 && (r5 = r5 * 100 + "%"), r5;
}
H$3(Ey2, "convertToPercentage");
function a8(r5) {
  return Math.round(parseFloat(r5) * 255).toString(16);
}
H$3(a8, "convertDecimalToHex");
function o8(r5) {
  return cs(r5) / 255;
}
H$3(o8, "convertHexToDecimal");
var da2 = (function() {
  var r5 = "[-\\+]?\\d+%?", t = "[-\\+]?\\d*\\.\\d+%?", e = "(?:" + t + ")|(?:" + r5 + ")", n4 = "[\\s|\\(]+(" + e + ")[,|\\s]+(" + e + ")[,|\\s]+(" + e + ")\\s*\\)?", i = "[\\s|\\(]+(" + e + ")[,|\\s]+(" + e + ")[,|\\s]+(" + e + ")[,|\\s]+(" + e + ")\\s*\\)?";
  return { CSS_UNIT: new RegExp(e), rgb: new RegExp("rgb" + n4), rgba: new RegExp("rgba" + i), hsl: new RegExp("hsl" + n4), hsla: new RegExp("hsla" + i), hsv: new RegExp("hsv" + n4), hsva: new RegExp("hsva" + i), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ };
})();
function du2(r5) {
  return !!da2.CSS_UNIT.exec(r5);
}
H$3(du2, "isValidCSSUnit");
function Tz(r5) {
  r5 = r5.replace(iz, "").replace(oz, "").toLowerCase();
  var t = false;
  if (D3[r5]) r5 = D3[r5], t = true;
  else if (r5 == "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var e;
  return (e = da2.rgb.exec(r5)) ? { r: e[1], g: e[2], b: e[3] } : (e = da2.rgba.exec(r5)) ? { r: e[1], g: e[2], b: e[3], a: e[4] } : (e = da2.hsl.exec(r5)) ? { h: e[1], s: e[2], l: e[3] } : (e = da2.hsla.exec(r5)) ? { h: e[1], s: e[2], l: e[3], a: e[4] } : (e = da2.hsv.exec(r5)) ? { h: e[1], s: e[2], v: e[3] } : (e = da2.hsva.exec(r5)) ? { h: e[1], s: e[2], v: e[3], a: e[4] } : (e = da2.hex8.exec(r5)) ? { r: cs(e[1]), g: cs(e[2]), b: cs(e[3]), a: o8(e[4]), format: t ? "name" : "hex8" } : (e = da2.hex6.exec(r5)) ? { r: cs(e[1]), g: cs(e[2]), b: cs(e[3]), format: t ? "name" : "hex" } : (e = da2.hex4.exec(r5)) ? { r: cs(e[1] + "" + e[1]), g: cs(e[2] + "" + e[2]), b: cs(e[3] + "" + e[3]), a: o8(e[4] + "" + e[4]), format: t ? "name" : "hex8" } : (e = da2.hex3.exec(r5)) ? { r: cs(e[1] + "" + e[1]), g: cs(e[2] + "" + e[2]), b: cs(e[3] + "" + e[3]), format: t ? "name" : "hex" } : false;
}
H$3(Tz, "stringInputToObject");
function wz(r5) {
  var t, e;
  return r5 = r5 || { level: "AA", size: "small" }, t = (r5.level || "AA").toUpperCase(), e = (r5.size || "small").toLowerCase(), t !== "AA" && t !== "AAA" && (t = "AA"), e !== "small" && e !== "large" && (e = "small"), { level: t, size: e };
}
H$3(wz, "validateWCAG2Parms");
var H3 = N$2(z3());
a();
var _X = Q.object({ rank: Q.union([Q.enum(["low", "medium", "high", "always-visible"]), Q.number()]).optional(), interactive: Q.boolean().optional(), appearance: Q.object({ margin: Q.number().min(6).optional(), text: Q.object({ numLines: Q.number().optional(), lineHeight: Q.number().optional(), size: Q.number().optional(), maxWidth: Q.number().optional(), foregroundColor: Q.string().optional(), backgroundColor: Q.string().optional() }).optional(), marker: Q.object({ size: Q.number().optional(), foregroundColor: Q.object({ active: Q.string().optional(), inactive: Q.string().optional() }).optional(), backgroundColor: Q.object({ active: Q.string().optional(), inactive: Q.string().optional() }).optional(), iconScale: Q.union([Q.number(), Q.object({ on: Q.literal("zoom-level").optional(), input: Q.array(Q.number()).nonempty(), output: Q.array(Q.number()).nonempty(), easing: Q.string().optional() })]).optional() }).optional() }).optional() }), q3 = H$3((r5) => {
  var t, e;
  if (_X.parse(r5 != null ? r5 : {}), typeof ((e = (t = r5.appearance) == null ? void 0 : t.marker) == null ? void 0 : e.iconScale) == "object") {
    let n4 = r5.appearance.marker.iconScale;
    if (n4.input.length !== n4.output.length) throw new Error("iconScale.input and iconScale.output must have the same number of values for interpolation!");
    if (n4.input.some((i, a4) => a4 > 0 && i < n4.input[a4 - 1])) throw new Error("iconScale.input must be sorted in increasing order for interpolation!");
  }
}, "validateLabelOptions");
function U8(r5, t, e) {
  Q.array(Q.number()).min(2).max(3).parse(r5), Q.string().parse(t), q3(e);
}
H$3(U8, "validateLabel");
var $d2 = { margin: 6, text: { numLines: 2, lineHeight: 1.2, size: 11.5, maxWidth: 150, foregroundColor: "white", backgroundColor: "#333" }, marker: { size: 5, foregroundColor: { active: "white", inactive: void 0 }, backgroundColor: { active: "#333", inactive: void 0 } } }, CX = { lightOnDark: G$1(F$1({}, $d2), { text: G$1(F$1({}, $d2.text), { foregroundColor: "white", backgroundColor: "#333" }), marker: G$1(F$1({}, $d2.marker), { foregroundColor: { active: "white", inactive: void 0 }, backgroundColor: { active: "#333", inactive: void 0 } }) }), darkOnLight: G$1(F$1({}, $d2), { text: G$1(F$1({}, $d2.text), { foregroundColor: "#333", backgroundColor: "white" }), marker: G$1(F$1({}, $d2.marker), { foregroundColor: { active: "#333", inactive: void 0 }, backgroundColor: { active: "white", inactive: void 0 } }) }) }, SX = "LOW_PRIORITY", B8 = 4, IX = 6, MX = 20, G8 = 2, TX = "cover", wX = -1 / 0, V8 = 6.5, j8 = { heightAbovePolygon: 0, appearance: CX.darkOnLight }, z8 = H$3((r5, t) => ["numLines", "lineHeight", "size", "maxWidth", "foregroundColor", "backgroundColor"].some((e) => {
  var n4, i, a4;
  return ((n4 = t.text) == null ? void 0 : n4[e]) != null && ((i = r5.text) == null ? void 0 : i[e]) !== ((a4 = t.text) == null ? void 0 : a4[e]);
}), "isOneOfTextDirtyOptions"), H8 = H$3((r5, t) => ["foregroundColor", "backgroundColor", "icon"].some((e) => {
  var n4, i, a4;
  return ((n4 = t.marker) == null ? void 0 : n4[e]) != null && ((i = r5.marker) == null ? void 0 : i[e]) !== ((a4 = t.marker) == null ? void 0 : a4[e]);
}), "isOneOfMarkerDirtyOptions"), Rh3 = class Rh4 {
  constructor(t, e, n4) {
    O(this, "lines", 0);
    O(this, "id");
    O(this, "rank");
    O(this, "type", "label");
    O(this, "initialRank");
    O(this, "contextConfigured", false);
    O(this, "fillText");
    O(this, "newStyle", {});
    O(this, "opacity", 0);
    O(this, "visibilityNeedsUpdate", false);
    O(this, "text");
    O(this, "style", { top: 0, left: 0, textLabelVisible: true, pinVisibility: 1, textAlign: "left" });
    O(this, "projection", new ot$1());
    O(this, "labelCacheId");
    O(this, "_cache", {});
    O(this, "appearance");
    O(this, "options");
    O(this, "visible", true);
    O(this, "enabled", true);
    O(this, "isOccluded", false);
    O(this, "offscreen", false);
    O(this, "canShow", false);
    O(this, "activeBoundingBox", { x: 0, y: 0, w: 0, h: 0 });
    O(this, "dimensions", { width: 0, height: 0 });
    O(this, "currentStrategyIndex", -1);
    O(this, "totalMarkerSize", 0);
    O(this, "iconScale", 1);
    O(this, "iconPadding");
    O(this, "dirty", true);
    O(this, "textDirty", true);
    O(this, "markerDirty", true);
    O(this, "attachedDirty", true);
    O(this, "collisionDirty", true);
    O(this, "lastTextAlign");
    O(this, "imageHash");
    O(this, "markerSize", 0);
    O(this, "iconVisible", false);
    O(this, "dp");
    O(this, "animate", true);
    O(this, "onStrategySelected", H$3((t5) => {
      if (this.currentStrategyIndex === t5) return;
      this.currentStrategyIndex = t5;
      let e4 = this.strategies[this.currentStrategyIndex];
      if (e4) {
        e4.onStrategySelected();
        let n5 = this.style;
        this.style = this.newStyle, this.newStyle = n5;
      }
    }, "onStrategySelected"));
    O(this, "packedMessage", { x: 0, y: 0, enabled: false, rank: 0, bboxes: [], shouldCollideWithScreenEdges: false, lockedToStrategyIndex: -1 });
    var a4, u5;
    if (this.id = (a4 = e.id) != null ? a4 : E(), this.options = (0, H3.default)({}, e, j8), this.text = t, this.dp = (h = 1) => h * n4.pixelRatio, typeof e.rank == "string") this.rank = Dd(e.rank), this.initialRank = this.rank;
    else if (e.rank != null && e.rank > 0) this.rank = e.rank, this.initialRank = e.rank;
    else {
      let h = Math.trunc(p$1.env.NODE_ENV === "test" ? Rh4.testId : Rh4.testId * 10) / 10;
      Rh4.testId += 1e-3, this.rank = h, this.initialRank = h;
    }
    let i = (0, H3.default)({}, this.options.appearance, j8.appearance);
    this.appearance = { margin: i.margin, text: { lineHeight: i.text.lineHeight, numLines: i.text.numLines, size: i.text.size, maxWidth: i.text.maxWidth, foregroundColor: i.text.foregroundColor, backgroundColor: i.text.backgroundColor }, marker: { foregroundColor: { active: i.marker.foregroundColor.active, inactive: i.marker.foregroundColor.inactive || Xt(i.marker.foregroundColor.active).setAlpha(0.5).toRgbString() }, backgroundColor: { active: i.marker.backgroundColor.active, inactive: i.marker.backgroundColor.inactive || Xt(i.marker.backgroundColor.active).setAlpha(0.5).toRgbString() }, icon: i.marker.icon, iconSize: i.marker.iconSize || MX, iconPadding: (u5 = i.marker.iconPadding) != null ? u5 : G8, iconFit: i.marker.iconFit || TX, iconOverflow: i.marker.iconOverflow || "hidden", iconVisibleAtZoomLevel: i.marker.iconVisibleAtZoomLevel == null ? wX : i.marker.iconVisibleAtZoomLevel, iconScale: i.marker.iconScale } };
  }
  get scaledMarkerSize() {
    return this.totalMarkerSize * this.iconScale;
  }
  get scaledIconPadding() {
    var t, e, n4;
    return ((n4 = (e = (t = this.appearance) == null ? void 0 : t.marker) == null ? void 0 : e.iconPadding) != null ? n4 : G8) * this.iconScale;
  }
  setEntity() {
  }
  calculateMarkerSize() {
    let t = this.dp();
    this.iconVisible && typeof this.appearance.marker.iconSize < "u" && this.imageHash ? this.markerSize = this.dp(this.appearance.marker.iconSize) : this.markerSize = this.dp(V8), this.totalMarkerSize = Math.ceil((this.markerSize + 2.5) / t);
  }
  get lowPriorityStrategyIndex() {
    return this.text === "" ? -1 : 3;
  }
  get strategies() {
    let { width: t, height: e } = this.dimensions, { margin: n4 } = this.appearance, i = Math.max(IX, n4), a4 = this.iconVisible ? i / 2 : 0, u5 = this.iconVisible ? this.scaledMarkerSize : V8 / 2, h = [{ name: "RIGHT", getBoundingBox: H$3(() => {
      let d = Math.max(this.scaledMarkerSize, e);
      return [d / 2 + i, d / 2 + i, this.scaledMarkerSize / 2 + i, this.scaledMarkerSize / 2 + t + i];
    }, "getBoundingBox"), onStrategySelected: H$3(() => {
      this.newStyle.textAlign = "left", this.newStyle.pinVisibility = 1, this.newStyle.top = -e / 2, this.newStyle.left = this.scaledMarkerSize / 2 + B8, this.newStyle.textLabelVisible = true;
    }, "onStrategySelected") }, { name: "LEFT", getBoundingBox: H$3(() => {
      let d = Math.max(this.scaledMarkerSize, e);
      return [d / 2 + i, d / 2 + i, this.scaledMarkerSize / 2 + t + i, this.scaledMarkerSize / 2 + i];
    }, "getBoundingBox"), onStrategySelected: H$3(() => {
      this.newStyle.textAlign = "right", this.newStyle.pinVisibility = 1, this.newStyle.top = -e / 2, this.newStyle.left = -t - this.scaledMarkerSize / 2 - B8, this.newStyle.textLabelVisible = true;
    }, "onStrategySelected") }, { name: "TOP", getBoundingBox: H$3(() => {
      let d = this.dp();
      return [e + this.scaledMarkerSize / 2 / d + i, this.scaledMarkerSize / 2 + i, t / 2 + i, t / 2 + i];
    }, "getBoundingBox"), onStrategySelected: H$3(() => {
      this.newStyle.pinVisibility = 1, this.newStyle.textAlign = "center", this.newStyle.textLabelVisible = true, this.newStyle.top = -e - this.scaledMarkerSize / 2, this.newStyle.left = -t / 2;
    }, "onStrategySelected") }, { name: SX, getBoundingBox: H$3(() => [u5 + a4, u5 + a4, u5 + a4, u5 + a4], "getBoundingBox"), onStrategySelected: H$3(() => {
      this.newStyle.pinVisibility = 0.5, this.newStyle.textLabelVisible = false, this.newStyle.top = 0, this.newStyle.left = 0;
    }, "onStrategySelected") }];
    return this.text === "" ? [{ name: "ICON_ONLY", getBoundingBox: H$3(() => [this.scaledMarkerSize / 2 + i, this.scaledMarkerSize / 2 + i, this.scaledMarkerSize / 2 + i, this.scaledMarkerSize / 2 + i], "getBoundingBox"), onStrategySelected: H$3(() => {
      this.newStyle.pinVisibility = 1, this.newStyle.textLabelVisible = false, this.newStyle.top = 0, this.newStyle.left = 0;
    }, "onStrategySelected") }] : h;
  }
  recomputeCurrentStrategy(t = this.iconScale) {
    if (this.iconScale !== t || this.dirty) {
      let e = this.strategies[this.currentStrategyIndex];
      if (this.iconScale = t, this.collisionDirty = true, e) {
        e.onStrategySelected(t);
        let n4 = this.style;
        this.style = this.newStyle, this.newStyle = n4;
      }
      this.dirty = false;
    }
  }
  updatePosition() {
  }
  disable() {
    this.visible = false;
  }
  toPackedMessage(t = false) {
    var e;
    if (this.visible && t && this.collisionDirty === false && this.currentStrategyIndex != null && this.currentStrategyIndex !== -1 && this.currentStrategyIndex !== this.lowPriorityStrategyIndex ? this.packedMessage.lockedToStrategyIndex = this.currentStrategyIndex : this.packedMessage.lockedToStrategyIndex = -1, this.packedMessage.x = this.projection.x, this.packedMessage.y = this.projection.y, this.packedMessage.enabled = this.enabled, this.packedMessage.rank = this.rank, this.currentStrategyIndex !== -1 && this.currentStrategyIndex !== this.lowPriorityStrategyIndex && this.currentStrategyIndex !== ((e = this.packedMessage.bboxes[0]) == null ? void 0 : e[4])) {
      let n4 = this.packedMessage.bboxes.findIndex((i) => i[4] === this.currentStrategyIndex);
      if (n4 !== -1) {
        let i = this.packedMessage.bboxes.splice(n4, 1)[0];
        this.packedMessage.bboxes.unshift(i);
      }
    }
    if (!this.collisionDirty) return this.packedMessage;
    this.packedMessage.bboxes = [];
    for (let n4 = 0; n4 < this.strategies.length; n4++) {
      let i = this.strategies[n4];
      n4 === this.currentStrategyIndex && this.currentStrategyIndex !== -1 && this.currentStrategyIndex !== this.lowPriorityStrategyIndex ? this.packedMessage.bboxes.unshift([...i.getBoundingBox(), n4]) : this.packedMessage.bboxes.push([...i.getBoundingBox(), n4]);
    }
    return this.packedMessage.shouldCollideWithScreenEdges = false, this.collisionDirty = false, this.packedMessage;
  }
  destroy() {
  }
};
H$3(Rh3, "LabelComponent"), O(Rh3, "testId", 0);
var X32 = Rh3, dl = X32;
a();
a();
var K3 = class K32 extends Se$1 {
  constructor(e, n4, i = true) {
    super();
    O(this, "rendererState");
    O(this, "convertTo3DMapPosition");
    O(this, "textSet", /* @__PURE__ */ new Set());
    O(this, "batchedTextMap", /* @__PURE__ */ new Map());
    O(this, "useWorker", true);
    O(this, "debugTextAreaMesh", /* @__PURE__ */ new Map());
    i === false && (this.useWorker = false, Jb(false)), this.rendererState = e, this.convertTo3DMapPosition = n4;
  }
  remove(e) {
    this.textSet.delete(e);
  }
  update(e) {
    var h, d, m5;
    let n4, i, a4, u5 = [];
    for (let v3 of this.rendererState.geometry3DIdsInScene) if (n4 = this.rendererState.geometry3DMap.get(v3), (n4 == null ? void 0 : n4.type) === "text3d") {
      i = n4.components[0], a4 = n4.components[1];
      let x2 = (h = i.mesh) == null ? void 0 : h.parent;
      if (!x2 || !(x2 instanceof z) || !(i instanceof Ec2)) continue;
      if ("textArea" in i.feature.properties && i.mesh != null && i.polygonEntityId != null && i.textMesh == null && i.mesh.parent != null && ((m5 = (d = i.feature.properties) == null ? void 0 : d.textArea) == null ? void 0 : m5.position) != null) {
        if (this.textSet.has(i.polygonEntityId)) continue;
        this.textSet.add(i.polygonEntityId), this.batchedTextMap.has(x2) || this.batchedTextMap.set(x2, Jd().then(({ BatchedText: w3 }) => {
          let E4 = new w3();
          return E4.type = "batchedtext", x2.add(E4), E4;
        }));
        let I3 = this.batchedTextMap.get(x2);
        if (!I3) throw new Error("batched text required");
        u5.push(X8({ entityId: v3, textComponent: i, styleComponent: a4, convertTo3DMapPosition: this.convertTo3DMapPosition, batchedMeshPromise: I3, rendererState: this.rendererState, type: "text-area" }).then(() => {
          this.publish("render");
        }));
      } else if (i.mesh != null && i.textMesh == null && i.mesh.parent != null) {
        if (this.textSet.has(v3.toString())) continue;
        this.textSet.add(v3.toString()), this.batchedTextMap.has(x2) || this.batchedTextMap.set(x2, Jd().then(({ BatchedText: w3 }) => {
          let E4 = new w3();
          return E4.type = "batchedtext", x2.add(E4), E4;
        }));
        let I3 = this.batchedTextMap.get(x2);
        if (!I3) throw new Error("batched text required");
        u5.push(X8({ entityId: v3, textComponent: i, styleComponent: a4, convertTo3DMapPosition: this.convertTo3DMapPosition, batchedMeshPromise: I3, rendererState: this.rendererState, type: "point" }).then(() => {
          this.publish("render");
        }));
      }
      let S4 = this.batchedTextMap.get(x2);
      i.textMesh && S4 && i.polygonEntityId != null && Promise.all([S4, Promise.resolve({ meshComponent: i, styleComponent: a4 })]).then(([I3, { meshComponent: w3, styleComponent: E4 }]) => {
        let { textMesh: T3 } = w3;
        if (I3 && T3) {
          let D4 = J3(I3, T3);
          w3.visible && !D4 ? I3.add(T3) : !w3.visible && D4 && I3.remove(T3);
        }
        E4.flipToFaceCamera && this.flipIfNeeded(w3, e);
      });
    }
    return Promise.all(u5);
  }
  flipIfNeeded(e, n4) {
    let i = e.textMesh;
    if (!i) return false;
    let a4 = i.rotation.z, u5 = _t(a4 + n4);
    u5 > Math.PI / 2 && u5 < 3 * Math.PI / 2 && (i.rotation.z = _t(a4 + Math.PI));
  }
  showTextAreaMesh() {
    let e, n4;
    for (let i of this.rendererState.geometry3DIdsInScene) if (e = this.rendererState.geometry3DMap.get(i), (e == null ? void 0 : e.type) === "text3d" && (n4 = e.components[0], "textArea" in n4.feature.properties)) {
      let a4 = n4.feature.properties.textArea;
      if (!a4) continue;
      let u5 = new Os$2(a4.maxWidth, a4.maxHeight), h = new ye$1(u5, new vs$1({ color: "pink" })), { textMesh: d } = n4;
      if (!d) continue;
      let m5 = this.convertTo3DMapPosition(a4.position, ky);
      h.position.copy(m5), h.position.z = d.position.z - 0.1, h.rotation.z = d.rotation.z, W3.identity(), W3.makeRotationAxis(new I$1(0, 0, 1), d.userData.rotationZ), ky.set(a4.maxWidth / 2, 0, 0), ky.applyMatrix4(W3), h.position.x -= ky.x, h.position.y -= ky.y, this.rendererState.entityScene.add(h), this.debugTextAreaMesh.set(i, h);
    }
    this.publish("render");
  }
  hideTextAreaMesh() {
    this.debugTextAreaMesh.forEach((e) => {
      this.rendererState.entityScene.remove(e);
    }), this.debugTextAreaMesh.clear(), this.publish("render");
  }
};
H$3(K3, "Text3DSystem");
var $b = K3;
function Jb(r5) {
  Jd().then(({ configureTroikaTextBuilder: t }) => {
    t({ useWorker: r5 });
  });
}
H$3(Jb, "configureWorker");
var W3 = new Vt$2(), ky = new I$1(), Z3;
async function $3(r5) {
  let { preloadFont: t } = await Jd();
  return t(r5);
}
H$3($3, "preloadFont");
function Jd() {
  return Z3 || (Z3 = import("./text3d-ZRYODT3I-D2_yPCxB.js").then((r5) => r5)), Z3;
}
H$3(Jd, "getText3DService");
async function X8({ entityId: r5, textComponent: t, styleComponent: e, convertTo3DMapPosition: n4, batchedMeshPromise: i, rendererState: a4, type: u5 = "text-area" }) {
  return Promise.all([Jd(), Promise.resolve({ entityId: r5, meshComponent: t, styleComponent: e })]).then(([{ createTroikaTextPoint: h, createTroikaTextArea: d }, m5]) => u5 === "text-area" ? d(m5.entityId, m5.meshComponent, m5.styleComponent, n4) : h(m5.entityId, m5.meshComponent, m5.styleComponent, n4)).catch((h) => {
    B.warn("Trouble creating text: ", h);
  }).then((h) => {
    if (!(h != null && h.text)) return;
    let d = [Promise.resolve(h.text), i, Promise.resolve()];
    if (t.polygonEntityId) {
      let m5 = a4.geometry3DMap.get(t.polygonEntityId);
      if ((m5 == null ? void 0 : m5.type) === "geometry") {
        let v3 = m5.components[0], x2 = m5.components[1];
        v3.textMesh = h.text, v3.mesh != null && (h.text.position.z = x2.altitude + x2.height + PX);
      }
    } else d[2] = Jd().then(({ syncText: m5 }) => m5(h.text));
    return Promise.all(d);
  }).then((h) => {
    if (!h) return;
    let [d, m5] = h;
    m5.add(d), t.batchedText || (t.batchedText = m5);
  });
}
H$3(X8, "createText");
function J3(r5, t) {
  return r5._members.has(t);
}
H$3(J3, "doesBatchedTextContainsText");
var PX = 0.5;
var EX = Q.object({ visible: Q.boolean(), color: Q.string(), flipToFaceCamera: Q.boolean(), font: Q.string().optional(), fontSize: Q.number(), margin: Q.union([Q.number(), Q.tuple([Q.number(), Q.number(), Q.number(), Q.number()])]), outlineColor: Q.string(), outlineOpacity: Q.number(), outlineBlur: Q.union([Q.number(), Q.string()]), outlineWidth: Q.number(), outlineOffsetX: Q.number(), outlineOffsetY: Q.number(), strokeWidth: Q.number(), maxWidth: Q.number().optional(), maxHeight: Q.number().optional(), strokeOpacity: Q.number(), strokeColor: Q.string(), fillOpacity: Q.number(), hoverColor: Q.string().optional(), id: Q.union([Q.string(), Q.number()]), type: Q.literal("text3d"), position: Q.tuple([Q.number(), Q.number(), Q.number()]), content: Q.string() }), Y8 = EX.partial().omit({ id: true, type: true }).strict(), q8 = Y8.omit({ margin: true, position: true, maxWidth: true, maxHeight: true, content: true }).strict(), W8 = Q.object({ appearance: Y8.optional(), parentId: Q.string().optional() }).strict(), Q3 = class Q32 {
  constructor(t) {
    O(this, "mesh", new fe());
    O(this, "textMesh");
    O(this, "type", "text3d");
    O(this, "feature");
    O(this, "parent");
    O(this, "batchedText");
    O(this, "polygonEntityId");
    this.feature = t;
  }
  get visible() {
    return this.batchedText && this.textMesh ? J3(this.batchedText, this.textMesh) : this.textMesh ? this.textMesh.visible : false;
  }
  set visible(t) {
    this.batchedText && this.textMesh ? t ? this.batchedText.addText(this.textMesh) : this.batchedText.removeText(this.textMesh) : this.textMesh && (this.textMesh.visible = t), this.mesh.visible = t;
  }
};
H$3(Q3, "Text3DComponent");
var Ec2 = Q3;
a();
var tI = class tI2 {
  constructor(t) {
    O(this, "color");
    O(this, "dirty", true);
    O(this, "visible", true);
    O(this, "edgeColors");
    O(this, "geometry");
    O(this, "ranges");
    O(this, "topFaceVerticesIndices");
    this.color = t;
  }
  get currentOpacity() {
    return this.edgeColors && this.ranges ? this.edgeColors.array[this.ranges.start * 4 + 3] : 0;
  }
  get currentColor() {
    return this.edgeColors && this.ranges ? [this.edgeColors.array[this.ranges.start * 4], this.edgeColors.array[this.ranges.start * 4 + 1], this.edgeColors.array[this.ranges.start * 4 + 2]] : [0, 0, 0];
  }
};
H$3(tI, "OutlineComponent");
var Kd = tI;
a();
a();
a();
var eI = class eI2 extends kn$1 {
  constructor(e) {
    let n4 = e, i = 3, a4 = i * 4;
    super(new Uint8Array(e * a4), i, e, De$3, hn);
    O(this, "_width");
    O(this, "_height");
    O(this, "_propertiesLength");
    this._width = a4, this._height = n4, this._propertiesLength = i;
  }
  setColor(e, n4, i) {
    let a4 = this.image.data, u5 = e * this._width;
    a4[u5] = Math.round(n4.r * 255), a4[u5 + 1] = Math.round(n4.g * 255), a4[u5 + 2] = Math.round(n4.b * 255), a4[u5 + 3] = 0, a4[u5 + 4] = Math.round(i.r * 255), a4[u5 + 5] = Math.round(i.g * 255), a4[u5 + 6] = Math.round(i.b * 255), a4[u5 + 7] = 0, this.needsUpdate = true;
  }
  getColor(e) {
    let n4 = this.image.data, i = e * this._width, a4 = new Ft$3(n4[i] / 255, n4[i + 1] / 255, n4[i + 2] / 255), u5 = new Ft$3(n4[i + 4] / 255, n4[i + 5] / 255, n4[i + 6] / 255);
    return { color: a4, topColor: u5 };
  }
  setTexture(e, n4, i) {
    let a4 = this.image.data, u5 = e * this._width;
    a4[u5 + 8] = n4 ? 255 : 0, a4[u5 + 9] = i ? 255 : 0, a4[u5 + 10] = 0, a4[u5 + 11] = 0, this.needsUpdate = true;
  }
  getTexture(e) {
    let n4 = this.image.data, i = e * this._width, a4 = n4[i + 8] === 255, u5 = n4[i + 9] === 255;
    return { texture: a4, topTexture: u5 };
  }
};
H$3(eI, "BatchedPropertiesTexture");
var Kb = eI;
a();
var Z8 = "#define LAMBERT\nvarying vec3 vViewPosition;\nvarying vec4 vPosition;\nvarying vec2 vUv;\nvarying vec4 finalPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 worldNormal;\nvarying float vBatchId;\n\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n	\n  // To mitigate visual defects on machines such as windows and iOS\n	vBatchId = getIndirectIndex(gl_DrawID) + 0.5;\n	vViewPosition = - mvPosition.xyz;\n	worldNormal = normal;\n	vUv = uv;\n	vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n}\n";
a();
var $8 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nuniform float uGradientEnd;\nuniform float uGradientIntensity;\nuniform float uMinSideAlpha;\nuniform float uMaxSideAlpha;\nuniform float uGradientStart;\nuniform highp sampler2D uPropertiesTexture;\nuniform highp sampler2D uTopTexture;\nuniform highp sampler2D uTexture;\nuniform float uRepeatYFactor;\nuniform bool uBlendTexture;\nvarying float vBatchId;\n\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 worldNormal;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvec3 blendTextureColor(vec3 diffuseColor, vec4 texColor) {\n	vec3 texturedColor = diffuseColor * texColor.rgb;\n	return mix(diffuseColor, texturedColor, texColor.a);\n}\n\nvoid main() {\n	#include <clipping_planes_fragment>\n\n	// get the normalized world normal of vertex fragment\n	vec3 surfaceNormal = normalize(worldNormal);\n\n	// get angle relative to Z up\n	float angle = degrees(acos(abs(dot(surfaceNormal, vec3(0.0, 0.0, 1.0)))));\n\n	int idx = int(vBatchId) * 1;\n	vec3 diffuse = vec3(texelFetch(uPropertiesTexture, ivec2(0, idx), 0).rgb);\n	bool shouldShowTexture = texelFetch(uPropertiesTexture, ivec2(2, idx), 0).r > 0.99;\n\n	if(shouldShowTexture) {\n		vec4 tex2d = texture2D(uTexture, vec2(vUv.x, vUv.y * uRepeatYFactor));\n		diffuse = uBlendTexture ? blendTextureColor(diffuse, tex2d) : tex2d.rgb;\n	}\n\n	// if this is a fragment facing upwards, use topColor. Avoid any sort of '==' comparison, due to floating point precision issue\n	if(angle < 0.02) {\n		bool shouldShowTopTexture = texelFetch(uPropertiesTexture, ivec2(2, idx), 0).g > 0.99;\n\n		if(shouldShowTopTexture) {\n			vec4 topTex2d = texture2D(uTopTexture, vUv);\n			diffuse = uBlendTexture ? blendTextureColor(diffuse, topTex2d) : topTex2d.rgb;\n		} else {\n			diffuse = vec3(texelFetch(uPropertiesTexture, ivec2(1, idx), 0).rgb);\n		}\n	}\n\n	vec4 diffuseColor = vec4(diffuse, opacity);\n\n	// only for vertical surfaces\n	if(angle > 89.0 && angle < 91.0) {\n\n		// get the percentage of the z position from the ground, up\n		float percentFromZeroZ = max((abs(vWorldPosition.z) - uGradientStart) / uGradientEnd, 0.0);\n\n		// gradient based on percentage\n		float alpha = smoothstep(uMinSideAlpha, uMaxSideAlpha, percentFromZeroZ);\n\n		// mix the shadow color with the diffuse color based on the alpha and opacity\n		diffuseColor = vec4(mix(diffuseColor.rgb, diffuseColor.rgb * (1.0 - uGradientIntensity), 1.0 - alpha), opacity);\n	}\n\n	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n\n	// accumulation\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n";
var OX = -0.05, DX = 1, rI = class rI2 extends Il$2 {
  constructor(e, n4, i = 1) {
    super(e);
    O(this, "propertiesTexture");
    O(this, "uniforms", { uGradientIntensity: { value: 0 }, uGradientEnd: { value: 0 }, uGradientStart: { value: 0 }, uTopTexture: { value: null }, uTexture: { value: null }, uRepeatYFactor: { value: 1 }, uBlendTexture: { value: false } });
    O(this, "colorSpace", Ve$1);
    O(this, "showTextures", H$3((e4) => {
      let n5 = !!this.uniforms.uTexture.value, i5 = !!this.uniforms.uTopTexture.value;
      (n5 || i5) && (this.propertiesTexture.setTexture(e4, n5, i5), this.needsUpdate = true);
    }, "showTextures"));
    this.propertiesTexture = new Kb(n4), this.uniforms.uRepeatYFactor.value = i, this.onBeforeCompile = (a4) => {
      let u5 = this.uniforms.uGradientIntensity, h = this.uniforms.uGradientEnd, d = this.uniforms.uGradientStart, m5 = this.uniforms.uTopTexture, v3 = this.uniforms.uTexture, x2 = this.uniforms.uRepeatYFactor, S4 = this.uniforms.uBlendTexture;
      this.uniforms = a4.uniforms, a4.vertexShader = Z8, a4.fragmentShader = $8, Object.assign(this.uniforms, { uGradientIntensity: u5, uGradientEnd: h, uGradientStart: d, uMinSideAlpha: { value: OX }, uMaxSideAlpha: { value: DX }, uPropertiesTexture: { value: this.propertiesTexture }, uTopTexture: m5, uTexture: v3, uRepeatYFactor: x2, uBlendTexture: S4 });
    };
  }
  get repeatYFactor() {
    return this.uniforms.uRepeatYFactor.value;
  }
  set repeatYFactor(e) {
    e !== this.uniforms.uRepeatYFactor.value && (this.uniforms.uRepeatYFactor.value = e, this.needsUpdate = true);
  }
  get texture() {
    return this.uniforms.uTexture.value;
  }
  set texture(e) {
    e.wrapS = Ur$1, e.wrapT = Ur$1, e.colorSpace = this.colorSpace, this.uniforms.uTexture.value = e;
  }
  get topTexture() {
    return this.uniforms.uTopTexture.value;
  }
  set topTexture(e) {
    e.wrapS = Ur$1, e.wrapT = Ur$1, e.colorSpace = this.colorSpace, this.uniforms.uTopTexture.value = e;
  }
  get blendTexture() {
    return this.uniforms.uBlendTexture.value;
  }
  set blendTexture(e) {
    e !== this.uniforms.uBlendTexture.value && (this.uniforms.uBlendTexture.value = e, this.colorSpace = e ? ri$1 : Ve$1, this.texture && (this.texture.colorSpace = this.colorSpace), this.topTexture && (this.topTexture.colorSpace = this.colorSpace), this.needsUpdate = true);
  }
  setGradientShading(e, n4, i) {
    this.uniforms.uGradientStart.value = e, this.uniforms.uGradientEnd.value = n4, this.uniforms.uGradientIntensity.value = i;
  }
  setColor(e, n4, i) {
    this.propertiesTexture.setColor(e, n4, i);
  }
  getColor(e) {
    return this.propertiesTexture.getColor(e);
  }
  hideTextures(e) {
    let n4 = !!this.uniforms.uTexture.value, i = !!this.uniforms.uTopTexture.value;
    (n4 || i) && (this.propertiesTexture.setTexture(e, false, false), this.needsUpdate = true);
  }
  removeSideTexture(e) {
    if (this.texture) {
      this.texture.dispose(), this.uniforms.uTexture.value = null;
      let n4 = !!this.uniforms.uTopTexture.value;
      this.propertiesTexture.setTexture(e, false, n4), this.needsUpdate = true;
    }
  }
  removeTopTexture(e) {
    if (this.topTexture) {
      this.topTexture.dispose(), this.uniforms.uTopTexture.value = null;
      let n4 = !!this.uniforms.uTexture.value;
      this.propertiesTexture.setTexture(e, n4, false), this.needsUpdate = true;
    }
  }
  dispose() {
    super.dispose(), this.propertiesTexture.dispose();
  }
};
H$3(rI, "BatchedStandardMaterial");
var Fh3 = rI;
a();
function J8(r5, t) {
  var m5, v3, x2;
  let e = 0;
  for (let S4 of r5) e += ((v3 = (m5 = S4.components[0]) == null ? void 0 : m5.geometry) == null ? void 0 : v3.attributes.position.count) || 0;
  let n4 = new Ft$3(t.color), i;
  i = new Fh3({ color: n4, side: t.side === "back" ? Le$2 : t.side === "front" ? Sn$2 : cn$3, opacity: (x2 = t.opacity) != null ? x2 : 1, transparent: t.opacity !== void 0 ? t.opacity < 1 : false, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 }, r5.length);
  let a4 = new ce$1(r5.length, e, 0, i), u5, h, d;
  for (let S4 of r5) u5 = S4.components[0], !(!(u5 instanceof mt) || !u5.geometry) && (u5.mesh = a4, u5.material = i, u5.instanceIndex = a4.addGeometry(u5.geometry), a4.addInstance(u5.instanceIndex), a4.userData.entities[u5.instanceIndex] = S4.id, i instanceof Fh3 && i.setColor(u5.instanceIndex, n4, t.topColor ? new Ft$3(t.topColor) : n4), h = a4.getGeometryIdAt(u5.instanceIndex), u5.batchedProps && (d = a4.getGeometryRangeAt(h), d && (u5.batchedProps.range = d), u5.batchedProps.geometryId = h));
  return a4.perObjectFrustumCulled = true, a4.matrixAutoUpdate = false, a4;
}
H$3(J8, "batchGeometries");
function Qd2(r5) {
  return Xt(r5).darken(30).toRgbString();
}
H$3(Qd2, "darkenColorForOutline");
function K8(r5, t, e, n4) {
  if (t.length < 1) return;
  r5.boundingBox || r5.computeBoundingBox();
  let i = r5.boundingBox, a4 = r5.getAttribute("position"), u5 = r5.getAttribute("normal"), h = r5.getAttribute("uv"), d, m5;
  r5.index ? (d = r5.index.count / 3, m5 = H$3(function(L3, B3) {
    return r5.index.getX(L3 * 3 + B3);
  }, "meshIndex")) : (d = a4.count / 3, m5 = H$3(function(L3, B3) {
    return L3 * 3 + B3;
  }, "meshIndex"));
  let v3 = new Vt$2();
  v3.makeRotationFromQuaternion(new En$1().setFromEuler(new Ze$1(0, 0, e / 180 * Math.PI)));
  let x2 = t.find((L3) => L3.face === "top"), S4;
  x2 && (S4 = { min: n4(x2.bounds[1], x2.bounds[0], 0), max: n4(x2.bounds[3], x2.bounds[2], i.max.z) });
  let I3 = t.find((L3) => L3.face === "side"), w3;
  if (I3 && (w3 = { min: n4(I3.bounds[1], I3.bounds[0], 0), max: n4(I3.bounds[3], I3.bounds[2], i.max.z) }), !(!w3 && !S4)) for (let L3 = 0; L3 < d; ++L3) {
    let B3 = u5.getX(m5(L3, 0)) + u5.getX(m5(L3, 1)) + u5.getX(m5(L3, 2)), j3 = u5.getY(m5(L3, 0)) + u5.getY(m5(L3, 1)) + u5.getY(m5(L3, 2)), W4 = u5.getZ(m5(L3, 0)) + u5.getZ(m5(L3, 1)) + u5.getZ(m5(L3, 2)), $5 = Math.abs(B3), F3 = Math.abs(j3), J4 = Math.abs(W4);
    var E4, T3;
    $5 <= F3 && $5 <= J4 ? (E4 = "x", F3 <= J4 ? T3 = "y" : T3 = "z") : F3 <= $5 && F3 <= J4 ? (E4 = "y", $5 <= J4 ? T3 = "x" : T3 = "z") : (E4 = "z", $5 <= F3 ? T3 = "x" : T3 = "y"), E4 === "z" && (E4 = T3, T3 = "z");
    let ot2, K4, H5, _t2, ct2, ft2;
    if (T3 === "z" || E4 === "z") {
      if (!I3 || !w3) continue;
      ot2 = I3.repeat.u, K4 = I3.repeat.v, H5 = I3.offset.u, _t2 = I3.offset.v, ct2 = I3.rotation, ft2 = w3;
    } else {
      if (!x2 || !S4) continue;
      ot2 = x2.repeat.u, K4 = x2.repeat.v, H5 = x2.offset.u, _t2 = x2.offset.v, ct2 = (360 - e + x2.rotation) % 360, ft2 = S4;
    }
    let { min: mt2, max: St2 } = ft2, dt2 = new fe$2();
    dt2.position.set(mt2.x, mt2.y, 0), dt2.updateMatrix(), dt2.updateMatrixWorld();
    let xt2 = mt2.clone().applyMatrix4(v3), q4 = St2.clone().applyMatrix4(v3), ee2 = Math.abs(q4.x - xt2.x), Gt2 = Math.abs(q4.y - xt2.y), Kt2 = new I$1(ee2, Gt2, St2.z).applyMatrix4(dt2.matrixWorld), It2 = Math.abs(Kt2[E4] - mt2[E4]), ie2 = Math.abs(Kt2[T3] - mt2[T3]), vr2 = ct2 * Math.PI / 180 || 0, Qe2 = Math.cos(vr2), Nt2 = Math.sin(vr2), At2 = dt2.matrixWorld.clone().invert(), Ct2 = new En$1().setFromEuler(new Ze$1(0, 0, e / 180 * Math.PI));
    for (let _e3 = 0; _e3 < 3; _e3++) {
      let qr2 = new I$1(a4.getX(m5(L3, _e3)), a4.getY(m5(L3, _e3)), a4.getZ(m5(L3, _e3))).applyMatrix4(At2);
      qr2.applyQuaternion(Ct2);
      let me2 = qr2.applyMatrix4(dt2.matrixWorld), Se2 = me2.x, br2 = me2.y, Wr2 = me2.z;
      var D4, A3;
      E4 === "x" ? D4 = ot2 * (Se2 - mt2[E4]) / It2 + H5 : E4 === "y" ? D4 = ot2 * (br2 - mt2[E4]) / It2 + H5 : D4 = ot2 * (Wr2 - mt2[E4]) / It2 + H5, T3 === "x" ? A3 = K4 * (Se2 - mt2[T3]) / ie2 + _t2 : T3 === "y" ? A3 = K4 * (br2 - mt2[T3]) / ie2 + _t2 : A3 = K4 * (Wr2 - mt2[T3]) / ie2 + _t2, D4 -= 0.5, A3 -= 0.5;
      let $i2 = D4 * Qe2 - A3 * Nt2 + 0.5, Yt2 = D4 * Nt2 + A3 * Qe2 + 0.5;
      h.setX(m5(L3, _e3), $i2), h.setY(m5(L3, _e3), Yt2);
    }
  }
}
H$3(K8, "updateUVsLegacy");
a();
var nI = class nI2 {
  constructor() {
    O(this, "focusMesh");
    O(this, "dirty", true);
  }
};
H$3(nI, "FocusableComponent");
var vu = nI;
function Ei(r5, t, e) {
  if (t !== void 0) {
    if (r5.type === "model" || r5.type === "path" || r5.type === "marker" || r5.type === "label" || r5.type === "geometry" || r5.type === "group-container" || r5.type === "custom-geometry") return t === true ? (r5 instanceof ne && r5.components[1] === void 0 ? (r5.components[1] = new Yd2(), r5.components[1].dirty = true) : r5 instanceof oe && r5.components[2] === void 0 ? (r5.components[2] = new Yd2(), r5.components[2].dirty = true) : r5 instanceof z && r5.components[1] === void 0 && (r5.components[1] = new Yd2(), r5.components[1].dirty = true), true) : (r5 instanceof ne ? r5.components[1] = void 0 : r5 instanceof oe ? r5.components[2] = void 0 : r5 instanceof z && (r5.components[1] = void 0), true);
    if (r5.type === "geometry-group") {
      let n4;
      for (let i of r5.userData.entities3D.values()) n4 = e.geometry3DMap.get(i), Ei(n4, t, e);
      return true;
    }
  }
  return false;
}
H$3(Ei, "updateInteractivity");
function Q8(r5, t, e) {
  if (!(!(e != null && e.color) && !("topColor" in e))) {
    if (e !== void 0 && r5.type === "geometry-group" && r5.components[0] != null) {
      let n4, i, a4 = r5.components[0];
      for (let u5 of r5.userData.entities3D.values()) if (n4 = t.geometry3DMap.get(u5), n4) {
        i = n4.components[1], i.color === a4.color && (i.initialColor = e.color || a4.color, i.color = e.color || a4.color, i.dirty = true);
        let h = n4.components[3];
        h && (h.color = Qd2(i.color || a4.color), h.dirty = true), i.topColor === a4.topColor && (i.topColor = e.topColor || a4.topColor, i.dirty = true);
      }
      return e.color !== void 0 && (a4.color = e.color, a4.dirty = true), "topColor" in e && (a4.topColor = e.topColor, a4.dirty = true), true;
    }
    return false;
  }
}
H$3(Q8, "updateGroupColor");
function tO(r5, t) {
  if (t !== void 0 && r5.type === "geometry-group" && r5.components[0] != null) {
    let e = r5.components[0];
    return e.shading = e.shading || {}, e.shading && (t.start !== e.shading.start || t.end !== e.shading.end || t.intensity !== e.shading.intensity) && (Object.assign(e.shading, t), r5.userData.shadingDirty = true), true;
  }
  return false;
}
H$3(tO, "updateGroupShading");
function eO(r5, t) {
  t !== void 0 && r5.type === "geometry" && (t.showImage !== void 0 && (r5.components[1].showImage = t.showImage), t.flipImageToFaceCamera !== void 0 && (r5.components[1].flipImageToFaceCamera = t.flipImageToFaceCamera));
}
H$3(eO, "updateImageProps");
function oI(r5, t, e) {
  if (e !== void 0) {
    if (r5.type === "geometry") {
      let n4 = r5.components[1];
      if (n4.height !== e) return n4.height = e, n4.dirty = true, r5.components[3] && (r5.components[3].dirty = true), true;
    } else if (r5.type === "geometry-group") {
      let n4 = r5.components[0];
      for (let i of r5.userData.entities3D.values()) {
        let a4 = t.geometry3DMap.get(i), u5;
        ((a4 == null ? void 0 : a4.type) === "geometry" || (a4 == null ? void 0 : a4.type) === "model") && (u5 = a4.components[1], u5.height === n4.height && (a4.components[1].height = e, a4.components[1].dirty = true), a4.components[3] && (a4.components[3].dirty = true));
      }
      return r5.components[0].height = e, true;
    }
  }
  return false;
}
H$3(oI, "updateHeight");
function sI(r5, t) {
  if (t !== void 0) {
    let e = false;
    (r5.type === "path" || r5.type === "geometry") && (t.initialColor !== void 0 && t.initialColor !== r5.components[1].initialColor && (r5.components[1].initialColor = t.initialColor, e = true), t.color !== void 0 && t.color !== r5.components[1].color && (r5.components[1].color = t.color, e = true, r5.components[3] && (r5.components[3].color = Qd2(t.color), r5.components[3].dirty = true)), "topColor" in t && (r5.components[1].topColor = t.topColor, e = true), e && (r5.components[1].dirty = true));
  }
}
H$3(sI, "updateColor");
function aI(r5, t, e) {
  t !== void 0 && (r5.type === "label" || r5.type === "marker" ? r5.updatePosition(e(t[1], t[0], t[2] || 0)) : r5.type === "custom-geometry" && r5.components[0].position.copy(e(t[1], t[0], t[2] || 0)));
}
H$3(aI, "updatePosition");
function lI(r5, t) {
  var e;
  return t !== void 0 && (r5.type === "marker" || r5.type === "label" || r5.type === "custom-geometry") && r5.parentObject3D !== t && r5.parentObject3D instanceof z ? ((e = r5.parentObject3D) == null || e.removeEntity(r5), t.addEntity(r5), true) : false;
}
H$3(lI, "updateParent");
function rO(r5, t) {
  t !== void 0 && (r5.type === "marker" || r5.type === "label") && r5.components[0].enabled !== t && (r5.components[0].enabled = t);
}
H$3(rO, "updateEnabled");
function nO(r5, t, e) {
  if (t !== void 0 && r5.type === "marker") {
    let n4 = r5.components[0];
    if (t.contentHTML !== void 0) return n4.containerEl.innerHTML = t.contentHTML, n4.contentHtml = t.contentHTML, true;
    if (t.anchor !== void 0 && (n4.options.anchor = t.anchor, n4.collisionDirty = true), t.dynamicResize !== void 0) return n4.options.dynamicResize = t.dynamicResize, true;
    if (t.options != null) {
      try {
        E3.parse(t.options || {});
      } catch (i) {
        return B.error(i), false;
      }
      return t.options.interactive != null && (t.options.interactive === "pointer-events-auto" ? (n4.pointerEvents = "auto", Ei(r5, false, e)) : (n4.pointerEvents = "none", Ei(r5, t.options.interactive, e))), iO(r5, t.options.rank), true;
    }
  }
  return false;
}
H$3(nO, "updateMarker");
function iO(r5, t) {
  return t !== void 0 && (r5.type === "marker" || r5.type === "label") ? (r5.components[0].rank = Dd(t), true) : false;
}
H$3(iO, "updateRank");
function oO(r5, t, e) {
  var n4, i, a4, u5, h, d;
  if (t !== void 0 && r5.type === "label") {
    let m5 = r5.components[0];
    t.text !== void 0 && t.text !== m5.text && (m5.text = t.text, m5.textDirty = true);
    try {
      q3((n4 = t.options) != null ? n4 : {});
    } catch (v3) {
      B.error(v3);
      return;
    }
    z8(m5.appearance, ((i = t.options) == null ? void 0 : i.appearance) || {}) && (m5.textDirty = true), H8(m5.appearance, ((a4 = t.options) == null ? void 0 : a4.appearance) || {}) && (m5.markerDirty = true), Qt(m5.appearance, ((u5 = t.options) == null ? void 0 : u5.appearance) || {}), Ei(r5, (h = t.options) == null ? void 0 : h.interactive, e), iO(r5, (d = t.options) == null ? void 0 : d.rank);
  }
}
H$3(oO, "updateLabel");
function sO(r5, t) {
  t !== void 0 && r5.type === "geometry" && (r5.components[1].hoverColor = t, r5.components[1].dirty = true);
}
H$3(sO, "updateHoverColor");
function aO(r5, t) {
  if (t !== void 0) {
    let e = r5.components[2];
    if (r5.type === "geometry" && e != null) return e.hover = t, e.dirty = true, true;
  }
  return false;
}
H$3(aO, "updateHovered");
function uI(r5, t) {
  t !== void 0 && r5.type === "image" && (r5.components[1].flipImageToFaceCamera = t);
}
H$3(uI, "updateFlipImageToFaceCamera");
function ml(r5, t, e) {
  if (e !== void 0) if (r5.type === "model" || r5.type === "path" || r5.type === "geometry" || r5.type === "custom-geometry" || r5.type === "image" || r5.type === "text3d") {
    e !== r5.components[1].visible && (r5.components[1].visible = e, r5.components[1].dirty = true);
    let n4 = r5.components[3];
    return n4 && (n4.visible = e, n4.dirty = true), true;
  } else {
    if (r5.type === "geometry-group") return r5.setVisible(e), true;
    if (r5.type === "group-container") {
      if (r5.visible !== e) return r5.setVisible(e), e === false && r5.traverse((n4) => {
        if (n4 instanceof k) {
          let i = t.geometry2DMap.get(n4.userData.entityId);
          if (i) {
            let a4 = i.components[0];
            a4 instanceof dl && (a4.canShow = e);
          }
        }
      }), true;
    } else if (r5.type === "label") return r5.components[0].visible = e, true;
  }
  return false;
}
H$3(ml, "updateVisibility");
function cI(r5, t, e) {
  if (e !== void 0) {
    if (r5.type === "geometry-group") {
      let n4 = r5.components[0];
      if (n4.opacity !== e) {
        for (let i of r5.userData.entities3D.values()) {
          let a4 = t.geometry3DMap.get(i), u5;
          ((a4 == null ? void 0 : a4.type) === "geometry" || (a4 == null ? void 0 : a4.type) === "model") && (u5 = a4.components[1], (!u5.opacity || u5.opacity === n4.opacity) && (u5.opacity = e, u5.dirty = true));
        }
        return r5.setOpacity(e), n4.opacity = e, true;
      }
    } else if (r5.type === "group-container" && r5.opacity !== e) {
      r5.setOpacity(e);
      let n4 = 1;
      return r5.parent instanceof z && (n4 = r5.parent.opacity), lO(r5, t, n4), true;
    }
  }
  return false;
}
H$3(cI, "updateOpacity");
function lO(r5, t, e = 1) {
  if (r5.type === "group-container" && "children" in r5 && r5.children.length > 0) {
    let n4 = e * r5.opacity;
    r5.userData.computedOpacity = n4;
    for (let i of r5.children) (i instanceof M && i.type === "geometry-group" || i instanceof z && i.type === "group-container") && lO(i, t, n4);
  } else if (r5.type === "geometry-group") for (let n4 of r5.userData.entities3D.values()) {
    let i = t.geometry3DMap.get(n4), a4;
    ((i == null ? void 0 : i.type) === "geometry" || (i == null ? void 0 : i.type) === "model") && (a4 = i.components[1], a4.dirty = true);
  }
}
H$3(lO, "cascadeOpacity");
function uO(r5, t) {
  if (t !== void 0 && r5.type === "geometry-group") {
    let e = r5.components[0];
    (t == null ? void 0 : t.texture) != null && e.texture !== (t == null ? void 0 : t.texture) && (e.texture = t.texture, e.dirty = true), (t == null ? void 0 : t.topTexture) != null && e.topTexture !== (t == null ? void 0 : t.topTexture) && (e.topTexture = t.topTexture, e.dirty = true);
  }
}
H$3(uO, "updateGroupTexture");
function cO(r5, t) {
  if (r5.type === "geometry") {
    let e = false, n4 = r5.components[1];
    if ((t == null ? void 0 : t.texture) != null && n4.texture !== (t == null ? void 0 : t.texture) && (n4.texture = t.texture, e = true), (t == null ? void 0 : t.topTexture) != null && n4.topTexture !== (t == null ? void 0 : t.topTexture) && (n4.topTexture = t.topTexture, e = true), e && r5.components[0] instanceof mt) {
      let i = r5.components[0];
      return i.detached === false && (i.detached = true, i.dirty = true), r5.components[1].dirty = true, true;
    }
  }
  return false;
}
H$3(cO, "updateIndividualGeometryTexture");
function pO(r5, t) {
  if (t !== void 0 && r5.type === "geometry") {
    let e = r5.components[1];
    if (e.opacity !== t) {
      e.opacity = t;
      let n4 = r5.components[0], i = r5.components[3];
      i && (i.dirty = true), n4.detached === false && (n4.detached = true, n4.dirty = true), t === 0 ? e.visible = false : e.visible = true, e.dirty = true;
      let a4 = r5.parentObject3D;
      return (a4 == null ? void 0 : a4.type) === "geometry-group" && (a4.userData.shadingDirty = true), true;
    }
  }
  return false;
}
H$3(pO, "updateIndividualGeometryOpacity");
function tm2(r5, t) {
  if (t !== void 0) if (r5.type === "geometry" || r5.type === "path" || r5.type === "custom-geometry") {
    let e = r5.components[1];
    if (e.altitude !== t) return e.altitude = t, e.dirty = true, r5.components[3] && (r5.components[3].dirty = true), true;
  } else {
    if (r5.type === "group-container" && r5.altitude !== t) return r5.setAltitude(t), true;
    if (r5.type === "geometry-group" && r5.altitude !== t) return r5.setAltitude(t), true;
  }
  return false;
}
H$3(tm2, "updateAltitude");
function Qb(r5, t, e) {
  if (e !== void 0) {
    if (r5.type === "geometry-group" && r5.components[0] != null) for (let n4 of r5.userData.entities3D.values()) {
      let i = t.geometry3DMap.get(n4);
      i instanceof oe && Qb(i, t, e);
    }
    else if (r5.type === "geometry") {
      let n4 = r5.components[3], i = r5.components[1];
      !n4 && e === true ? r5.components[3] = new Kd(Qd2(i.color)) : n4 && (n4.visible = e, n4.dirty = true);
    }
    return true;
  }
  return false;
}
H$3(Qb, "updateOutline");
function tx2(r5, t) {
  if (t !== void 0) {
    let e, n4 = 4;
    if (r5.type === "geometry" ? (e = r5.components[4], n4 = 4) : r5.type === "group-container" && (e = r5.components[2], n4 = 2), t === true && e == null) return r5.components[n4] = new vu(), true;
    if (t === false && e != null) return r5.components[n4] = void 0, true;
  }
  return false;
}
H$3(tx2, "updateFocusable");
function hO(r5, t) {
  if (t !== void 0 && r5.type === "geometry") {
    let e = r5.components[1];
    if (e.renderOrder !== t) {
      e.renderOrder = t;
      let n4 = r5.components[0];
      return n4.detached === false && (n4.detached = true, n4.dirty = true), n4.imageMesh && (n4.imageMesh.renderOrder = t + 1), e.dirty = true, true;
    }
  }
  return false;
}
H$3(hO, "updateIndividualGeometryRenderOrder");
function fO(r5, t, e) {
  let { visible: n4, color: i } = e;
  if (r5.type !== "path") return;
  let a4 = r5.components[0];
  n4 != null && ml(r5, t, n4), i != null && sI(r5, { color: i }), Object.assign(a4, pI(e)), Jt(e) || (a4.materialDirty = true, (e.nearRadius != null || e.farRadius != null) && (a4.dirty = true), (e.nearZoomLevel != null || e.farZoomLevel != null) && (a4.dirty = true));
}
H$3(fO, "handlePathUpdate");
function pI(r5) {
  return Yt(r5, AX);
}
H$3(pI, "pickPathOptions");
var AX = ["animateArrowsOnPath", "displayArrowsOnPath", "nearRadius", "farRadius", "accentColor", "completeFraction", "nearZoomLevel", "farZoomLevel", "dashed", "visibleThroughGeometry"];
function dO(r5) {
  if (!(r5 instanceof oe && r5.type === "text3d")) throw new Error("expect target is TextGeometry3D");
}
H$3(dO, "assetGeometryIsText3D");
var ex2 = ["visible", "color", "strokeWidth", "outlineOffsetX", "outlineOffsetY", "outlineWidth", "outlineBlur", "outlineOpacity", "outlineColor", "strokeWidth", "strokeColor", "strokeOpacity", "maxWidth", "maxHeight", "font", "hoverColor", "fillOpacity", "fontSize", "flipToFaceCamera"];
function mO(r5, t, e) {
  ml(r5, t, e.visible);
  let n4 = r5.components[1], i = Yt(e, ex2);
  "margin" in e && B.warn("update to margin is not supported atm"), "content" in e && B.warn("content update is not supported atm");
  try {
    q8.parse(i);
  } catch (a4) {
    B.error(a4);
    return;
  }
  Object.keys(i).length > 0 && (Object.assign(n4, i), n4.dirty = true);
}
H$3(mO, "handleText3DUpdate");
var NX = ["color", "material", "opacity", "verticalOffset", "rotation", "position", "scale"];
function gO(r5, t) {
  let e = Yt(t, NX), n4 = r5.components[1], i = r5.components[0];
  Object.keys(e).length > 0 && (e.material && (n4.material = e.material), e.opacity != null && (n4.opacity = e.opacity, e.opacity === 0 ? n4.visible = false : n4.visible = true, n4.dirty = true), e.verticalOffset != null && (n4.verticalOffset = e.verticalOffset), e.color != null && (n4.color = e.color), e.position != null && (i.feature.geometry.coordinates = e.position, i.positionDirty = true), e.rotation != null && (n4.rotation = e.rotation), e.scale != null && (n4.scale = e.scale), n4.dirty = true);
}
H$3(gO, "handleModelStyleUpdate");
var Bh3, gl, rx2, Oc3, yO, Fy2, nx2, vO, bO, By2, ix2, Gy2, Vy2, ox, hI = class hI2 {
  constructor(t) {
    Q$3(this, Oc3);
    Q$3(this, Bh3, null);
    Q$3(this, gl);
    O(this, "getCurrentSceneGLTF", H$3(async (t5) => {
      let e = F$1({ onlyVisible: true, binary: true, light: true, scale: 1 }, t5), n4 = await S$1(this, Oc3, yO).call(this), i = P(this, rx2).call(this, e), a4 = await n4.parseAsync(i, { trs: false, maxTextureSize: 1 / 0, onlyVisible: e.onlyVisible, binary: e.binary, scale: e.scale }), u5;
      if (a4 instanceof ArrayBuffer) u5 = new Blob([a4], { type: "application/octet-stream" });
      else {
        let h = JSON.stringify(a4, null, 2);
        u5 = new Blob([h], { type: "text/plain" });
      }
      return u5;
    }, "getCurrentSceneGLTF"));
    Q$3(this, rx2, H$3((t5) => {
      let { scale: e, light: n4, onlyVisible: i } = t5, a4 = new hl$2(), u5 = new Pe$3().setFromObject(P(this, gl).entityScene);
      if (P(this, Fy2).call(this, P(this, gl).entityScene, a4, i), n4) {
        let h = new kl$1(16777215, 0.3 * Math.PI);
        h.position.set(0, Math.max(u5.max.x, u5.max.y) * e * 0.5, u5.max.y * e * 4), h.lookAt(0, 0, -1), h.target.position.set(0, 0, -1), h.add(h.target), a4.add(h);
      }
      return a4;
    }, "#getExportedScene"));
    Q$3(this, Fy2, H$3((t5, e, n4) => {
      t5.material && (t5 instanceof _l$2 ? S$1(this, Oc3, vO).call(this, t5).forEach((i) => e.add(i)) : t5 instanceof qr && e.add(S$1(this, Oc3, bO).call(this, t5))), t5.children.forEach((i) => {
        (!n4 || i.visible) && P(this, Fy2).call(this, i, e, n4);
      });
    }, "#processObject3D"));
    Q$3(this, nx2, H$3((t5, e, n4) => {
      let i = new ea$1({ color: new Ft$3(t5), metalness: 0 });
      return i.opacity = e, i.transparent = n4, i;
    }, "#createStandardMaterial"));
    Q$3(this, By2, H$3((t5) => {
      let { geometry: e, material: n4, position: i, rotation: a4, quaternion: u5, scale: h } = t5;
      if (!(e != null && e.isBufferGeometry)) return t5;
      let d = e.attributes.position, m5 = e.attributes.normal, v3 = e.attributes.uv;
      return P(this, ix2).call(this, d, m5), P(this, Vy2).call(this, i, h, a4, u5), v3 && P(this, ox).call(this, v3), n4 != null && n4.map && e.type === "PlaneGeometry" && (t5.side = cn$3), t5;
    }, "#convertGeometry"));
    Q$3(this, ix2, H$3((t5, e) => {
      let n4 = new I$1(), i = new I$1();
      for (let a4 = 0; a4 < t5.count; a4++) n4.fromBufferAttribute(t5, a4), P(this, Gy2).call(this, n4), t5.setXYZ(a4, n4.x, n4.y, n4.z), e && (i.fromBufferAttribute(e, a4), P(this, Gy2).call(this, i), e.setXYZ(a4, i.x, i.y, i.z));
    }, "#convertAttributes"));
    Q$3(this, Gy2, H$3((t5) => {
      let e = t5.y;
      t5.y = t5.z, t5.z = -e;
    }, "#convertVector"));
    Q$3(this, Vy2, H$3((t5, e, n4, i) => {
      let a4 = t5.y;
      t5.y = t5.z, t5.z = -a4;
      let u5 = e.y;
      if (e.y = e.z, e.z = u5, n4 instanceof Ze$1) n4.order = "YXZ", n4.set(n4.x, n4.y, n4.z, n4.order);
      else {
        let h = i.y;
        i.set(i.x, i.z, -h, i.w);
      }
    }, "#convertObjectProperties"));
    Q$3(this, ox, H$3((t5) => {
      for (let e = 0; e < t5.count; e++) {
        let n4 = t5.getX(e), i = t5.getY(e);
        t5.setXY(e, n4, i);
      }
    }, "#convertUVs"));
    R$1(this, gl, t), P(this, gl).entityScene = t.entityScene, P(this, gl).geometry3DMap = t.geometry3DMap;
  }
  destroy() {
    R$1(this, Bh3, null);
  }
};
Bh3 = /* @__PURE__ */ new WeakMap(), gl = /* @__PURE__ */ new WeakMap(), rx2 = /* @__PURE__ */ new WeakMap(), Oc3 = /* @__PURE__ */ new WeakSet(), yO = H$3(async function() {
  if (!P(this, Bh3)) {
    let { GLTFExporter: t } = await import("./GLTFExporter-W4OR66GG-CMwk1rb4.js");
    R$1(this, Bh3, new t());
  }
  return P(this, Bh3);
}, "#getGLTFExporter"), Fy2 = /* @__PURE__ */ new WeakMap(), nx2 = /* @__PURE__ */ new WeakMap(), vO = H$3(function(t) {
  var u5, h;
  let e = [], i = ((u5 = t.userData) != null && u5.entities ? Object.values((h = t.userData) == null ? void 0 : h.entities) : []).map((d) => P(this, gl).geometry3DMap.get(d)), a4 = /* @__PURE__ */ new Map();
  return i.forEach((d) => {
    var I3;
    if (!d || !(d instanceof oe)) return;
    let m5 = d.components[1], v3 = d.components[2];
    if (!m5.visible || m5 instanceof Oe && m5.opacity === 0 || m5 instanceof je || m5 instanceof We) return;
    let x2 = v3 != null && v3.hover ? m5.hoverColor || P(this, gl).hoverColor : m5.color, S4 = "".concat(x2, "-").concat(m5.opacity, "-").concat(Number(m5.visible));
    a4.has(S4) || a4.set(S4, []), (I3 = a4.get(S4)) == null || I3.push(d);
  }), a4.forEach((d, m5) => {
    let [v3, x2, S4] = m5.split("-"), I3 = d.reduce((D4, A3) => {
      if (A3.type === "custom-geometry") return D4;
      let L3 = A3.components[0];
      return "geometry" in L3 && L3.geometry instanceof pe$3 && D4.push(L3.geometry), D4;
    }, []), w3 = P(this, nx2).call(this, v3, Number(x2), t.material.transparent), E4 = R(I3, true), T3 = new ye$1(E4, w3);
    T3.position.copy(t.position), T3.rotation.copy(t.rotation), T3.scale.copy(t.scale), T3.visible = !!S4, P(this, Vy2).call(this, T3.position, T3.scale, T3.rotation, T3.quaternion), e.push(P(this, By2).call(this, T3));
  }), e;
}, "#processBatchedMesh"), bO = H$3(function(t) {
  let e = t.geometry.clone(), n4 = t.material, i = new vs$1({ color: n4.color, side: cn$3 });
  i.opacity = n4.opacity, i.transparent = n4.transparent;
  let a4 = new qr(e, i);
  return a4.position.copy(t.position), a4.rotation.copy(t.rotation), a4.scale.copy(t.scale), a4.visible = t.visible, P(this, By2).call(this, a4);
}, "#processLineSegments"), By2 = /* @__PURE__ */ new WeakMap(), ix2 = /* @__PURE__ */ new WeakMap(), Gy2 = /* @__PURE__ */ new WeakMap(), Vy2 = /* @__PURE__ */ new WeakMap(), ox = /* @__PURE__ */ new WeakMap(), H$3(hI, "ExporterSystem");
var Ry2 = hI;
a();
a();
a();
var mI = N$2(EO());
function OO(r5) {
  this.name = "JSClipperError", this.message = r5, this.stack = new Error().stack;
}
H$3(OO, "JSClipperError");
OO.prototype = Error.prototype;
mI.default.Error = function(r5) {
  throw new OO(r5);
};
var pi = mI.default;
var wq = "gray", Pq = 0.1, zy2 = 100, gI = new pi.ClipperOffset();
function Eq(r5, t) {
  gI.Clear(), t /= 2;
  let e = r5.map((i) => ({ X: i.x * zy2, Y: i.y * zy2 }));
  gI.AddPath(e, pi.JoinType.jtMiter, pi.EndType.etClosedPolygon);
  let n4 = new pi.Paths();
  return gI.Execute(n4, t * zy2), n4.length ? n4.map((a4) => a4.map((u5) => ({ x: u5.X / zy2, y: u5.Y / zy2 }))) : [r5];
}
H$3(Eq, "offset");
function px2(r5, t, e) {
  var S4, I3, w3, E4, T3;
  let { color: n4 = wq, opacity: i = 1, altitude: a4 = 0, height: u5 = Pq } = e || {};
  Array.isArray(i) && (i = 1);
  let h = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, m5 = r5.geometry.coordinates[0].map((D4) => {
    let A3 = t(D4[1], D4[0]);
    return h.min.x = Math.min(h.min.x, A3.x), h.min.y = Math.min(h.min.y, A3.y), h.max.x = Math.max(h.max.x, A3.x), h.max.y = Math.max(h.max.y, A3.y), A3;
  });
  ((I3 = (S4 = r5.properties) == null ? void 0 : S4.style) == null ? void 0 : I3.edgeOffset) != null && r5.properties.style.edgeOffset !== 0 || ((w3 = r5.properties) == null ? void 0 : w3.image) != null ? m5 = Eq(m5, ((T3 = (E4 = r5.properties) == null ? void 0 : E4.style) == null ? void 0 : T3.edgeOffset) || 0) : m5 = [m5];
  let v3 = [];
  for (let D4 of m5) {
    let A3 = new ta$1();
    A3.moveTo(D4[0].x, D4[0].y), D4.slice(1).forEach((W4) => A3.lineTo(W4.x, W4.y)), A3.lineTo(D4[0].x, D4[0].y);
    let L3 = r5.geometry.coordinates.slice(1);
    A3.holes = L3.map((W4) => {
      let $5 = W4.map((J4) => t(J4[1], J4[0])), F3 = new Ls$2();
      return F3.moveTo($5[0].x, $5[0].y), $5.slice(1).forEach((J4) => F3.lineTo(J4.x, J4.y)), F3.lineTo($5[0].x, $5[0].y), F3;
    });
    let B3 = { bevelEnabled: false, depth: u5 }, j3 = new Al$1(A3, B3);
    j3.userData = { style: { color: n4, opacity: i } }, v3.push(j3);
  }
  if (v3.length === 1) return v3[0];
  let x2 = R(v3);
  return x2.userData = { style: { color: n4, opacity: i }, _split: true }, x2;
}
H$3(px2, "renderPolygonGeometry");
a();
var Oq = "gray", Dq = 0.1;
function hx2(r5, t, e) {
  let { color: n4 = Oq, opacity: i = 1, altitude: a4 = 0, height: u5 = Dq } = e || {};
  Array.isArray(i) && (i = 1);
  let h = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, d = { bevelEnabled: false, depth: u5 }, m5 = [];
  r5.geometry.coordinates.forEach((x2) => {
    let S4 = new ta$1(), I3 = x2[0].map((T3) => {
      let D4 = t(T3[1], T3[0]);
      return h.min.x = Math.min(h.min.x, D4.x), h.min.y = Math.min(h.min.y, D4.y), h.max.x = Math.max(h.max.x, D4.x), h.max.y = Math.max(h.max.y, D4.y), D4;
    });
    S4.moveTo(I3[0].x, I3[0].y), I3.slice(1).forEach((T3) => S4.lineTo(T3.x, T3.y)), S4.lineTo(I3[0].x, I3[0].y);
    let w3 = x2.slice(1);
    S4.holes = w3.map((T3) => {
      let D4 = T3.map((L3) => t(L3[1], L3[0])), A3 = new Ls$2();
      return A3.moveTo(D4[0].x, D4[0].y), D4.slice(1).forEach((L3) => A3.lineTo(L3.x, L3.y)), A3.lineTo(D4[0].x, D4[0].y), A3;
    });
    let E4 = new Al$1(S4, d);
    m5.push(E4);
  });
  let v3 = R(m5);
  return v3.translate(0, 0, a4 || 0), v3.userData = { style: { color: n4, opacity: i } }, v3;
}
H$3(hx2, "renderMultiPolygonGeometry");
a();
var Lq = "gray", yI = new pi.ClipperOffset(), wo = 100;
function DO(r5, t, e) {
  let { color: n4 = Lq, opacity: i = 1, width: a4 = 1, join: u5 = "round", cap: h = "round", height: d = 0.01, altitude: m5 = 0 } = e || {};
  Array.isArray(i) && (i = 0);
  let v3 = [];
  for (let E4 = 0; E4 < r5.geometry.coordinates.length - 1; E4++) {
    let T3 = t(r5.geometry.coordinates[E4][1], r5.geometry.coordinates[E4][0]), D4 = t(r5.geometry.coordinates[E4 + 1][1], r5.geometry.coordinates[E4 + 1][0]);
    v3.push([T3, D4]);
  }
  yI.AddPaths(v3.map((E4) => E4.map((T3) => ({ X: T3.x * wo, Y: T3.y * wo }))), u5 === "round" ? pi.JoinType.jsRound : u5 === "miter" ? pi.JoinType.jsMiter : pi.JoinType.jsSquare, h === "round" ? pi.EndType.etOpenRound : h === "butt" ? pi.EndType.etOpenButt : pi.EndType.etOpenSquare);
  let x2 = new pi.PolyTree();
  yI.Execute(x2, a4 / 2 * wo);
  let S4 = [], I3 = { bevelEnabled: false, depth: d };
  for (let E4 of x2.m_AllPolys) {
    let T3 = new ta$1();
    if (E4.IsHole()) continue;
    let D4 = E4.m_polygon;
    T3.moveTo(D4[0].X / wo, D4[0].Y / wo), D4.slice(1).forEach((A3) => T3.lineTo(A3.X / wo, A3.Y / wo)), T3.lineTo(D4[0].X / wo, D4[0].Y / wo), T3.holes = E4.m_Childs.map((A3) => {
      let L3 = new Ls$2(), B3 = A3.m_polygon;
      return L3.moveTo(B3[0].X / wo, B3[0].Y / wo), B3.slice(1).forEach((j3) => L3.lineTo(j3.X / wo, j3.Y / wo)), L3.lineTo(B3[0].X / wo, B3[0].Y / wo), L3;
    }), S4.push(new Al$1(T3, I3));
  }
  let w3 = R(S4);
  return w3.translate(0, 0, m5 || 0), w3.userData = { style: { color: n4, opacity: i } }, yI.Clear(), w3;
}
H$3(DO, "renderLineStringGeometry");
a();
var Po = 100, Aq = 0.22, Nq = 0.01;
function LO(r5, t, e = {}) {
  let { width: n4 = Aq, height: i = Nq, color: a4 = "gray", opacity: u5 = 1, altitude: h = 0 } = e, d = { min: { x: 1 / 0, y: 1 / 0 }, max: { x: -1 / 0, y: -1 / 0 } }, m5 = { bevelEnabled: false, depth: i }, v3 = new pi.ClipperOffset(), x2 = r5.geometry.coordinates.map((E4) => E4.map((T3) => t(T3[1], T3[0])));
  v3.AddPaths(x2.map((E4) => E4.map((T3) => ({ X: T3.x * Po, Y: T3.y * Po }))), pi.JoinType.jsMiter, pi.EndType.etOpenRound);
  let S4 = new pi.PolyTree();
  v3.Execute(S4, n4 / 2 * Po);
  let I3 = [];
  for (let E4 of S4.m_AllPolys) {
    let T3 = new ta$1();
    if (E4.IsHole()) continue;
    d.min.x = Math.min(d.min.x, E4.m_polygon[0].X), d.min.y = Math.min(d.min.y, E4.m_polygon[0].Y), d.max.x = Math.max(d.max.x, E4.m_polygon[0].X), d.max.y = Math.max(d.max.y, E4.m_polygon[0].Y);
    let D4 = E4.m_polygon;
    T3.moveTo(D4[0].X / Po, D4[0].Y / Po), D4.slice(1).forEach((A3) => T3.lineTo(A3.X / Po, A3.Y / Po)), T3.lineTo(D4[0].X / Po, D4[0].Y / Po), T3.holes = E4.m_Childs.map((A3) => {
      let L3 = new Ls$2(), B3 = A3.m_polygon;
      return L3.moveTo(B3[0].X / Po, B3[0].Y / Po), B3.slice(1).forEach((j3) => L3.lineTo(j3.X / Po, j3.Y / Po)), L3.lineTo(B3[0].X / Po, B3[0].Y / Po), L3;
    }), I3.push(new Al$1(T3, m5));
  }
  let w3 = R(I3);
  return w3.translate(0, 0, h || 0), w3.userData = { style: { color: a4, opacity: u5 } }, v3.Clear(), w3;
}
H$3(LO, "renderMultiLineStringGeometry");
a();
a();
var nm2 = Q.object({ type: Q.enum(["Point"]), coordinates: Q.array(Q.number()).min(2).max(3) });
var kq = Q.object({ rotation: Q.array(Q.number()).length(3).optional(), altitude: Q.number().optional(), scale: Q.array(Q.number()).length(3).optional(), interactive: Q.boolean().optional(), verticalOffset: Q.number().optional(), id: Q.union([Q.number(), Q.string()]).optional() }), Rq = Q.object({ type: Q.enum(["Feature"]), geometry: nm2, properties: kq }), Fq = Q.object({ type: Q.enum(["FeatureCollection"]), features: Q.array(Rq) }), Bq = Q.object({ color: Q.string() }), Gq = Q.object({ url: Q.string(), color: Q.string().optional(), opacity: Q.number().optional(), material: Q.record(Q.string(), Bq).optional() });
function NO(r5, t, e) {
  Q.union([Q.number(), Q.string()]).parse(r5), Fq.parse(t), Gq.parse(e);
}
H$3(NO, "validateModelGroup");
var Hy2, Xy2, vI = class vI2 {
  constructor(t) {
    O(this, "mesh");
    O(this, "type", "model");
    O(this, "positionDirty", true);
    O(this, "outline");
    O(this, "geometry");
    O(this, "material");
    O(this, "feature");
    O(this, "instanceIndex", -1);
    O(this, "visible", true);
    O(this, "color", new Ft$3());
    O(this, "position", new I$1());
    Q$3(this, Hy2, 0);
    Q$3(this, Xy2, 1);
    this.feature = t;
  }
  setOpacity() {
  }
  setColor() {
  }
  get altitude() {
    return P(this, Hy2);
  }
  set altitude(t) {
    this.mesh && (this.mesh.position.z = t, R$1(this, Hy2, t));
  }
  getRotation() {
    return this.mesh ? [this.mesh.rotation.x, this.mesh.rotation.y, this.mesh.rotation.z] : void 0;
  }
  setRotation(t) {
    this.mesh && this.mesh.rotation.set(Zp$2.degToRad(t[0]), Zp$2.degToRad(t[1]), Zp$2.degToRad(t[2]));
  }
  getScale() {
    return this.mesh ? [this.mesh.scale.x, this.mesh.scale.y, this.mesh.scale.z] : void 0;
  }
  setScale(t) {
    this.mesh && this.mesh.scale.set(t[0], t[1], t[2]);
  }
  get opacity() {
    return P(this, Xy2);
  }
  set opacity(t) {
    var e, n4, i;
    if (this.mesh) {
      if (this.mesh.children[0] instanceof ml$2) {
        for (let a4 of this.mesh.children) if (a4 instanceof ml$2) {
          ((e = a4.userData) == null ? void 0 : e.originalOpacity) === void 0 && (a4.userData.originalOpacity = a4.material.opacity);
          let u5 = nn(t, 0, (n4 = a4.userData) == null ? void 0 : n4.originalOpacity, 0, 1);
          a4.material.opacity = u5, a4.material.transparent = u5 < 1, a4.material.needsUpdate = true;
        }
      } else (i = this.mesh) == null || i.traverse((a4) => {
        a4 instanceof ye$1 && a4.material && (Array.isArray(a4.material) ? a4.material.forEach((u5) => {
          AO(u5, t);
        }) : AO(a4.material, t));
      });
      R$1(this, Xy2, t);
    }
  }
};
Hy2 = /* @__PURE__ */ new WeakMap(), Xy2 = /* @__PURE__ */ new WeakMap(), H$3(vI, "ModelComponent");
var Ac2 = vI;
function AO(r5, t) {
  r5.opacity !== t && (t === 1 ? (r5.opacity = 1, r5.transparent = false) : (r5.opacity = t, r5.transparent = true), r5.needsUpdate = true);
}
H$3(AO, "updateMaterialOpacity");
a();
function fx2(r5) {
  var h, d;
  let t = r5.components[0], e = r5.components[1];
  e.opacity != null && e.opacity !== t.opacity && (t.opacity = e.opacity);
  let n4 = e.material, i = e.color;
  if (n4 || i) {
    let m5 = Vq(i, n4);
    (h = t.mesh) == null || h.traverse((v3) => {
      v3 instanceof ye$1 && v3.material && (Array.isArray(v3.material) ? v3.material.forEach((x2) => {
        m5[x2.name] ? x2.color.set(m5[x2.name].color) : x2.color.set(i);
      }) : m5[v3.material.name] ? v3.material.color.set(m5[v3.material.name].color) : v3.material.color.set(i));
    });
  }
  let a4 = (d = t.feature.geometry.coordinates[2]) != null ? d : 0, u5 = e.verticalOffset + a4;
  t.altitude !== u5 && (t.altitude = u5), e.visible !== t.visible && (t.visible = e.visible), e.rotation && t.setRotation(e.rotation), e.scale && t.setScale(e.scale);
}
H$3(fx2, "applyModelGeometryStyle");
function Vq(r5, t) {
  let e = {};
  if (r5 && Object.assign(e, { Default: { color: r5 }, Fabric: { color: r5 }, Mpdn_Logo: { color: r5 }, CouchLogo: { color: r5 } }), t) for (let n4 in t) t[n4].color && (e[n4] ? e[n4].color = t[n4].color : e[n4] = { color: t[n4].color });
  return e;
}
H$3(Vq, "consolidateColorAndMaterial");
function kO(r5, t) {
  var u5, h;
  let e = r5.components[0], i = (u5 = r5.components[1].verticalOffset) != null ? u5 : 0, a4 = e.feature.geometry.coordinates.slice();
  a4[2] = ((h = a4[2]) != null ? h : 0) + i, e.mesh ? e.mesh.position.copy(t(a4)) : e.position.copy(t(a4));
}
H$3(kO, "applyModelPosition");
function jq(r5) {
  let { color: t, opacity: e, topColor: n4, texture: i, topTexture: a4 } = r5;
  return "".concat(t).concat(e).concat(n4 || "").concat(i || "").concat(a4 || "");
}
H$3(jq, "generateIndex");
var bI = class bI2 extends Se$1 {
  constructor(e, n4) {
    super();
    O(this, "state");
    O(this, "convertTo3DMapPosition");
    O(this, "loader");
    O(this, "optimizePromise", []);
    this.state = e, this.convertTo3DMapPosition = n4;
  }
  async getGLTFLoader() {
    if (this.loader) return this.loader;
    let { GLTFLoader: e } = await import("./GLTFLoader-CWW4SC4X-CMtq9RR0.js");
    return this.loader = new e(), this.loader;
  }
  createEntityFromFeature(e, n4, i) {
    var h, d;
    let a4 = new mt(n4), u5 = new oe(a4, new Oe(G$1(F$1({}, i), { url: (d = (h = n4.properties) == null ? void 0 : h.image) == null ? void 0 : d.path })));
    return i != null && i.outline && (u5.components[3] = new Kd(Qd2(i.color))), i != null && i.focusable && (u5.components[4] = new vu()), u5.id = e, u5;
  }
  createModelFromFeature(e, n4, i) {
    let a4 = new Ac2(n4), u5 = F$1({}, i);
    n4.properties.verticalOffset != null && (u5.verticalOffset = n4.properties.verticalOffset), n4.properties.rotation != null && (u5.rotation = n4.properties.rotation), n4.properties.scale != null && (u5.scale = n4.properties.scale);
    let h = new We(u5), d = new oe(a4, h);
    return d.id = e, d;
  }
  populateEntityMesh(e, n4) {
    let i = e.components[0];
    i.geometry = n4, i.batchedProps = { range: { start: 0, count: 1 / 0, indexCount: 1 / 0, indexStart: 0, vertexCount: 1 / 0, vertexStart: 0, reservedVertexCount: 1 / 0, reservedIndexCount: 1 / 0 }, geometryId: -1, positionCount: n4.attributes.position.count }, i.currentHeight = e.components[1].height, i.dirty = false;
  }
  async populateModelGroup(e, n4, i) {
    let a4 = new Vt$2(), u5 = new Ze$1(), h = new En$1(), d = new I$1(), m5 = new fe(), v3 = await this.getGLTFLoader(), x2 = new Promise((S4) => {
      v3.load(n4, (I3) => {
        "entities3D" in i.userData && (i.userData.entities3D.size > 1 ? I3.scene.traverse((w3) => {
          let E4 = w3;
          if ("isMesh" in E4 && E4.isMesh === true) {
            let T3 = new ml$2(E4.geometry, E4.material, e.size);
            T3.userData = { entities: {} }, m5.add(T3), i.add(m5);
          }
        }) : (I3.scene.traverse((w3) => {
          "isMesh" in w3 && w3.isMesh === true && (w3.position.set(0, 0, 0), w3.rotation.set(0, 0, 0), w3.scale.set(1, 1, 1), w3.updateMatrix());
        }), m5.add(I3.scene), i.add(m5), m5.userData.isSingleModel = true, m5.userData.entityId = e.values().next().value, m5.userData.type = "model")), S4();
      });
    });
    return this.optimizePromise.push(x2.then(() => {
      var w3, E4, T3, D4, A3, L3, B3, j3, W4, $5, F3, J4;
      let S4 = 0, I3;
      for (let ot2 of e.values()) {
        if (I3 = this.state.geometry3DMap.get(ot2), !I3 || (I3 == null ? void 0 : I3.type) !== "model") continue;
        let K4 = I3.components[0], H5 = I3.components[1], _t2 = I3.components[0].feature;
        K4.mesh = m5, K4.instanceIndex = S4, fx2(I3), I3.components[1].dirty = false;
        let { x: ct2, y: ft2 } = this.convertTo3DMapPosition(_t2.geometry.coordinates[1], _t2.geometry.coordinates[0], 0);
        K4.position.set(ct2, ft2, K4.altitude), u5.set(Zp$2.degToRad((E4 = (w3 = H5.rotation) == null ? void 0 : w3[0]) != null ? E4 : nr[0]), Zp$2.degToRad((D4 = (T3 = H5.rotation) == null ? void 0 : T3[1]) != null ? D4 : nr[1]), Zp$2.degToRad((L3 = (A3 = H5.rotation) == null ? void 0 : A3[2]) != null ? L3 : nr[2])), d.set((j3 = (B3 = H5.scale) == null ? void 0 : B3[0]) != null ? j3 : rr[0], ($5 = (W4 = H5.scale) == null ? void 0 : W4[1]) != null ? $5 : rr[1], (J4 = (F3 = H5.scale) == null ? void 0 : F3[2]) != null ? J4 : rr[2]), h.setFromEuler(u5), a4.compose(K4.position, h, d), m5.children.forEach((mt2) => {
          !I3 || (I3 == null ? void 0 : I3.type) !== "model" || !(mt2 instanceof ml$2) || (mt2.setMatrixAt(S4, a4), mt2.userData.entities[S4] = I3.id);
        }), K4.mesh.userData.isSingleModel && (K4.mesh.matrix.copy(a4), K4.mesh.matrix.decompose(K4.mesh.position, K4.mesh.quaternion, K4.mesh.scale)), S4++;
      }
      this.publish("model-loaded");
    })), m5;
  }
  populateEntityGroup(e) {
    var h;
    let n4, i, a4, u5;
    for (let d of e.values()) u5 = this.state.geometry3DMap.get(d), u5.components[0] instanceof mt && (i = u5.components[0].feature, a4 = u5.components[1], i.geometry.type === "Polygon" ? (n4 = px2(i, this.convertTo3DMapPosition, a4), (h = i.properties) != null && h.textures && i.properties.textures.length > 0 && K8(n4, i.properties.textures, this.state.naturalBearing, this.convertTo3DMapPosition), this.populateEntityMesh(u5, n4)) : i.geometry.type === "MultiPolygon" ? (n4 = hx2(i, this.convertTo3DMapPosition, a4), this.populateEntityMesh(u5, n4)) : i.geometry.type === "LineString" ? (n4 = DO(i, this.convertTo3DMapPosition, a4), this.populateEntityMesh(u5, n4)) : i.geometry.type === "MultiLineString" && (n4 = LO(i, this.convertTo3DMapPosition, a4), this.populateEntityMesh(u5, n4)));
    return e;
  }
  update() {
    var e;
    for (let n4 of this.state.geometryGroupIdsToLoad.values()) {
      let i = this.state.geometry3DMap.get(n4);
      if (i instanceof M && i.userData.dirty) {
        if (i.userData.modelURL) i.userData.modelURL && (this.populateModelGroup(i.userData.entities3D, i.userData.modelURL, i), i.userData.dirty = false);
        else try {
          this.populateEntityGroup(i.userData.entities3D);
        } catch (h) {
          B.warn(h);
        }
        let a4, u5 = {};
        for (let h of i.userData.entities3D.values()) {
          a4 = this.state.geometry3DMap.get(h);
          let d = a4 == null ? void 0 : a4.components[0];
          if ((a4 == null ? void 0 : a4.type) === "geometry") {
            let m5 = a4.components[1], v3 = jq(m5);
            u5[v3] === void 0 && (u5[v3] = { style: m5, entities: [] }), u5[v3].entities.push(a4);
          } else d && "mesh" in d && d.mesh && ((e = d.mesh) == null ? void 0 : e.parent) !== i && i.add(d.mesh);
        }
        for (let h in u5) {
          let d = J8(u5[h].entities, u5[h].style);
          i.add(d);
        }
        for (let h of i.userData.entities3D.values()) if (a4 = this.state.geometry3DMap.get(h), a4 != null && a4.entities2D.size > 0) for (let d of a4.entities2D.values()) d && (a4.attach(d), this.publish("geometry-2d-added"));
        this.publish("geometry-group-added"), i.userData.dirty = false;
      }
    }
    return Promise.resolve();
  }
};
H$3(bI, "MeshCreationAndOptimizationSystem");
var dx = bI;
a();
var xI = class xI2 {
  constructor(t, e) {
    O(this, "state");
    O(this, "dirty", true);
    O(this, "domTree");
    this.state = t, this.domTree = e;
  }
  update() {
    if (this.dirty) {
      let t;
      for (let e of Array.from(this.domTree.children)) if (t = this.state.geometry2DMap.get(e.userData.entityId), t) {
        let n4 = t.components[0];
        (!n4.enabled || !n4.visible || !this.state.geometry2DIdsInScene.has(e.userData.entityId)) && this.domTree.removeChild(e);
      } else this.domTree.removeChild(e);
      for (let e of this.state.geometry2DIdsInScene) if (t = this.state.geometry2DMap.get(e), t) {
        let n4 = t.components[0];
        n4 instanceof fl && n4.enabled && n4.markerContainer && !this.domTree.contains(n4.markerContainer) && (n4.markerContainer.userData = { entityId: t.id }, this.domTree.appendChild(n4.markerContainer), n4.updateDimensions());
      }
      this.dirty = false;
    }
  }
};
H$3(xI, "DOMVisibilitySystem");
var mx = xI;
a();
var _I = class _I2 {
  constructor(t, e) {
    O(this, "state");
    O(this, "project");
    this.state = t, this.project = e;
  }
  update() {
    let t, e = 0, n4, i;
    for (let a4 of this.state.geometry2DIdsInScene) if (t = this.state.geometry2DMap.get(a4), t) {
      i = t.components[0];
      let u5 = t.attachedTo ? this.state.geometry3DMap.get(t.attachedTo) : void 0;
      if (u5 instanceof oe) if (this.state.geometry3DIdsInScene.has(u5.id)) {
        n4 = u5.components[1], i = t.components[0], (n4.dirty || t.components[0].attachedDirty) && (e = n4.height, t.setAltitude(e));
        let h = n4.visible && n4.opacity > 0;
        i.visible !== h && (i.visible = h);
      } else i.visible === true && (i.visible = false);
      this.project(t.components[0].projection, t.position), t.components[0].attachedDirty = false;
    }
  }
};
H$3(_I, "TwoDProjectionSystem");
var gx2 = _I;
a();
a();
var Uq = H$3(function() {
  let t, e;
  return (n4) => {
    if ((!e || !e) && (t = document.createElement("canvas"), t.width = 500 * n4, t.height = 500 * n4, t.style.width = "500px", t.style.height = "500px", e = t.getContext("2d")), !e) throw new Error("Could not get 2D context");
    return { measureCanvas: t, measureCanvasContext: e };
  };
}, "createMeasureCanvasContext")(), RO = H$3(({ text: r5, size: t, maxWidth: e, pixelRatio: n4, maxLines: i = 2, lineHeight: a4 = 1.2, options: u5 = { strokeText: true } }) => {
  let h = "bold ".concat(t * n4, "px 'InterUI-Regular', Helvetica Neue, Arial, sans-serif"), { measureCanvasContext: d } = Uq(n4);
  d.font = h;
  let m5 = [], v3 = r5.split(" "), x2 = 0, S4 = 0, I3 = 0;
  for (; S4 < v3.length; ) {
    let D4 = v3[S4];
    if (x2 === i && x2 > 0) {
      m5[x2 - 1] += "...";
      break;
    }
    if (m5[x2] == null && (m5[x2] = D4, S4++), v3.length === 1) {
      m5[x2] = D4;
      break;
    }
    if (v3[S4] == null) break;
    let { width: A3 } = d.measureText(m5[x2] + " " + v3[S4]);
    A3 <= e * n4 ? (m5[x2] += " " + v3[S4], S4++) : x2++;
  }
  m5.forEach((D4) => {
    let { width: A3 } = d.measureText(D4);
    I3 = Math.max(A3, I3);
  });
  let w3 = t * n4 * a4, E4 = m5.length * w3;
  return { maxWidth: I3, maxHeight: E4, lines: m5.length, draw: H$3((D4, A3, L3) => {
    m5.length === 1 ? (u5.strokeText && D4.strokeText(m5[0], A3, L3), D4.fillText(m5[0], A3, L3)) : (u5.strokeText && (D4.strokeText(m5[0], A3, L3 - w3 / 2), D4.strokeText(m5[1], A3, L3 + w3 / 2)), D4.fillText(m5[0], A3, L3 - w3 / 2), D4.fillText(m5[1], A3, L3 + w3 / 2));
  }, "draw") };
}, "shaveText");
a();
function FO(r5) {
  let t = new Image();
  return r5 && (/<svg[\s\S]*>/i.test(r5) ? t.src = "data:image/svg+xml;base64,".concat(btoa(r5)) : t.src = r5), t;
}
H$3(FO, "createImage");
var CI = class CI2 extends Se$1 {
  constructor(e, n4, i) {
    super();
    O(this, "dirty", false);
    O(this, "state");
    O(this, "colliderContext");
    O(this, "colliderCanvas");
    O(this, "transformRequestFunc");
    O(this, "transformRequest", H$3(async (e4) => this.transformRequestFunc ? await this.transformRequestFunc(e4) : { url: e4 }, "transformRequest"));
    O(this, "pinCache", {});
    O(this, "imageCache", {});
    O(this, "imagePromiseCache", {});
    O(this, "imageDimensionsCache", {});
    O(this, "textCache", {});
    O(this, "update", H$3((e4) => {
      let n5 = this.state.pixelRatio;
      this.colliderContext.clearRect(0, 0, this.colliderCanvas.width, this.colliderCanvas.height);
      let i5, a4, u5, h, d, m5, v3;
      for (let x2 of this.state.geometry2DIdsInScene) if (v3 = this.state.geometry2DMap.get(x2), v3 != null && (m5 = v3.components[0], m5 instanceof dl && !v3.disposed)) {
        if (d = m5.appearance.marker.iconVisibleAtZoomLevel, m5.appearance.marker.icon != null && d && e4 >= d !== m5.iconVisible && (m5.iconVisible = e4 >= d, m5.dirty = true), (m5.dirty || this.dirty) && m5.calculateMarkerSize(), a4 = m5.appearance.marker.foregroundColor, u5 = m5.appearance.marker.backgroundColor, h = wr(m5.markerSize, 2), i5 = "".concat(a4.active, "-").concat(a4.inactive, "-").concat(u5.active, "-").concat(u5.inactive, "-").concat(h, "-").concat(m5.iconVisible), m5.labelCacheId = i5, (!this.pinCache[i5] || this.dirty) && (this.prepare(m5, i5, this.colliderContext), m5.dirty = true), (m5.appearance.marker.icon && (!m5.imageHash || m5.markerDirty) || this.dirty) && this.cacheImage(m5), this.textCache[m5.id] == null || m5.textDirty || this.dirty) {
          m5.dirty = true, this.textCache[m5.id] = {};
          let { textDrawFn: I3, width: w3, height: E4 } = this.processText(m5.text, m5.appearance.text.size, m5.appearance.text.maxWidth, m5.appearance.text.numLines, m5.appearance.text.lineHeight);
          ["left", "center", "right"].forEach((T3) => {
            this.textCache[m5.id][T3] = this.textToCanvas(I3, m5.appearance.text.size, T3, w3, E4, m5.appearance.text.foregroundColor, m5.appearance.text.backgroundColor);
          }), m5.dimensions = { width: Math.ceil(w3 / n5), height: Math.ceil(E4 / n5) };
        }
        let S4 = 1;
        if (m5.appearance.marker.iconScale) if (typeof m5.appearance.marker.iconScale == "number") S4 = m5.appearance.marker.iconScale;
        else {
          let { on: I3, input: w3, output: E4, easing: T3 } = m5.appearance.marker.iconScale;
          I3 === "zoom-level" ? S4 = on$1(e4, w3, E4, T3 != null ? T3 : "linear") : B.warn("Unsupported interpolation property: ".concat(I3));
        }
        m5.recomputeCurrentStrategy(m5.iconVisible ? S4 : 1), m5.canShow && m5.visible && (m5.enabled || m5.visibilityNeedsUpdate !== false) && this.draw(m5, i5, this.colliderContext), m5.textDirty = false, m5.markerDirty = false;
      }
      this.dirty = false;
    }, "update"));
    O(this, "processText", H$3((e4, n5, i5, a4, u5) => {
      let h = this.state.pixelRatio, { draw: d, maxWidth: m5, maxHeight: v3 } = RO({ text: e4, size: n5, pixelRatio: h, maxWidth: i5, maxLines: a4, lineHeight: u5 });
      return { textDrawFn: d, width: m5 + 2.5 * h * 2, height: v3 + 2.5 * h * 2 };
    }, "processText"));
    O(this, "textToCanvas", H$3((e4, n5, i5, a4, u5, h, d) => {
      let m5 = this.state.pixelRatio, v3, x2 = a4, S4 = u5;
      window.OffscreenCanvas != null && !Kt() ? v3 = new OffscreenCanvas(x2, S4) : (v3 = document.createElement("canvas"), v3.width = x2, v3.height = S4, v3.style.width = x2 + "px", v3.style.height = S4 + "px");
      let I3 = v3.getContext("2d", { willReadFrequently: true });
      if (!I3) return;
      I3.textAlign = i5, I3.font = "bold ".concat(n5 * m5, "px 'InterUI-Regular', Helvetica Neue, Arial, sans-serif"), I3.textBaseline = "middle", I3.lineJoin = "miter", I3.miterLimit = 2, I3.strokeStyle = "white", I3.lineWidth = 2.5 * m5, I3.fillStyle = h, I3.strokeStyle = d;
      let w3 = i5 === "left" ? 0 : i5 === "center" ? x2 / 2 : x2 - 2.5 * m5 / 2;
      return e4(I3, w3, (S4 + 2.5 * m5 / 2) / 2), v3;
    }, "textToCanvas"));
    O(this, "cacheImage", H$3((e4) => {
      if (!e4.appearance.marker.icon) return;
      let n5 = Pi$1(e4.appearance.marker.icon);
      this.imagePromiseCache[n5] || (this.imagePromiseCache[n5] = new Promise((i5) => {
        this.transformRequest(e4.appearance.marker.icon).then((a4) => {
          let u5 = FO(a4.url);
          u5.onload = () => {
            this.imageCache[n5] = u5, this.publish("img:loaded"), i5(u5);
          };
        });
      })), e4.imageHash !== n5 && (e4.imageHash = n5, this.imagePromiseCache[n5].then(() => {
        e4.dirty = true;
      }));
    }, "cacheImage"));
    O(this, "createPinCanvas", H$3((e4, n5, i5, a4, u5 = 1) => {
      let h, d = this.state.pixelRatio, m5 = e4.totalMarkerSize * 2 * d * u5;
      window.OffscreenCanvas != null ? h = new OffscreenCanvas(m5, m5) : (h = document.createElement("canvas"), h.width = m5, h.height = m5, h.style.width = m5 / d + "px", h.style.height = m5 / d + "px");
      let v3 = h.getContext("2d");
      return v3.shadowColor = "rgba(0,0,0,0.3)", v3.shadowOffsetY = 2 * d, v3.shadowBlur = 5 * d, v3.beginPath(), v3.arc(m5 / 2, m5 / 2, (n5 / 2 + 2.5 * d / 2) * u5, 0, 2 * Math.PI), v3.fillStyle = i5, v3.fill(), v3.beginPath(), v3.arc(m5 / 2, m5 / 2, n5 / 2 * u5, 0, 2 * Math.PI), v3.shadowColor = "transparent", v3.fillStyle = a4, v3.fill(), h;
    }, "createPinCanvas"));
    O(this, "prepare", H$3((e4, n5, i5) => {
      let a4 = this.state.pixelRatio;
      i5.lineWidth = 4 * a4;
      let u5 = typeof e4.appearance.marker.iconScale == "number" ? [e4.appearance.marker.iconScale] : e4.appearance.marker.iconScale == null ? [] : e4.appearance.marker.iconScale.output, h = u5.length > 0 ? Math.max(...u5) : void 0, d = this.createPinCanvas(e4, e4.markerSize, e4.appearance.marker.backgroundColor.active, e4.appearance.marker.foregroundColor.active, h), m5 = this.createPinCanvas(e4, e4.iconVisible ? e4.markerSize : 3.5 * a4, e4.appearance.marker.backgroundColor.inactive, e4.appearance.marker.foregroundColor.inactive, h);
      this.pinCache[n5] = [d, m5];
    }, "prepare"));
    this.state = e, this.colliderCanvas = n4, this.colliderContext = n4.getContext("2d"), this.transformRequestFunc = i;
  }
  draw(e, n4, i) {
    var m5, v3;
    if (!e.canShow || !e.visible) return;
    i.save(), i.globalAlpha = e.opacity;
    let a4 = this.state.pixelRatio, u5 = e.projection.x * a4, h = e.projection.y * a4, d = e.style.pinVisibility === 1 ? this.pinCache[n4][0] : this.pinCache[n4][1];
    if (i.drawImage(d, u5 - e.scaledMarkerSize * a4, h - e.scaledMarkerSize * a4, e.scaledMarkerSize * 2 * a4, e.scaledMarkerSize * 2 * a4), e.appearance.marker.icon && e.iconVisible && e.imageHash && e.appearance.marker.iconSize && this.imageCache[e.imageHash]) {
      let x2 = this.imageCache[e.imageHash], S4 = (e.scaledMarkerSize - e.scaledIconPadding) * a4, I3 = e.appearance.marker.iconFit, w3 = S4, E4 = S4, T3 = "".concat(e.imageHash, "_").concat(I3);
      if (this.imageDimensionsCache[T3]) w3 = this.imageDimensionsCache[T3].width, E4 = this.imageDimensionsCache[T3].height;
      else {
        let D4 = x2.width * a4, A3 = x2.height * a4;
        if (I3 === "contain") {
          let L3 = Math.sqrt(D4 ** 2 + A3 ** 2), B3 = S4 / L3;
          w3 = D4 * B3, E4 = A3 * B3;
        }
        if (I3 === "cover") {
          let L3 = S4 / D4, B3 = S4 / A3, j3 = Math.max(L3, B3);
          w3 = D4 * j3, E4 = A3 * j3;
        }
      }
      i.save(), i.beginPath(), i.arc(u5, h, S4 / 2, 0, 2 * Math.PI), i.closePath(), ((v3 = (m5 = e == null ? void 0 : e.appearance) == null ? void 0 : m5.marker) == null ? void 0 : v3.iconOverflow) !== "visible" && i.clip(), i.drawImage(x2, u5 - w3 / 2, h - E4 / 2, w3, E4), i.restore();
    }
    e.style.textLabelVisible && e.style.textAlign != null && e.style.left != null && e.style.top != null && i.drawImage(this.textCache[e.id][e.style.textAlign], u5 + e.style.left * a4, h + e.style.top * a4), i.restore();
  }
};
H$3(CI, "TwoDDrawSystem");
var yx = CI;
a();
a();
var Nc2 = class Nc3 {
  constructor() {
    O(this, "loader");
    this.loader = new Ul();
  }
  static getInstance() {
    return Nc3.instance || (Nc3.instance = new Nc3()), Nc3.instance;
  }
  getLoader() {
    return this.loader;
  }
  load(t) {
    return new Promise((e, n4) => {
      this.loader.load(t, e, void 0, n4);
    });
  }
};
H$3(Nc2, "TextureLoaderSingleton"), O(Nc2, "instance");
var SI = Nc2, kc2 = SI.getInstance();
function Yq(r5, t) {
  let e = r5.components[2], n4 = r5.components[1];
  return e != null && e.hover ? [n4.hoverColor || t, n4.hoverColor || t] : [n4.color, n4.topColor || n4.color];
}
H$3(Yq, "processColor");
var Uh3, qy2, II = class II2 extends Se$1 {
  constructor(e, n4) {
    super();
    Q$3(this, Uh3);
    O(this, "state");
    O(this, "convertTo3DMapPosition");
    O(this, "textureLoadingCache", /* @__PURE__ */ new Map());
    this.convertTo3DMapPosition = n4, this.state = e;
  }
  setShading(e, n4) {
    e.material && e.material.setGradientShading(n4.start, n4.end, n4.intensity);
  }
  processTextures(e, n4, i) {
    var a4;
    if (n4.texture !== e.texture && n4.texture !== "" && S$1(this, Uh3, qy2).call(this, n4.texture, e, "texture"), n4.topTexture !== e.topTexture && n4.topTexture !== "" && S$1(this, Uh3, qy2).call(this, n4.topTexture, e, "topTexture"), (e.texture == null || e.topTexture == null) && Array.isArray((a4 = e.feature.properties) == null ? void 0 : a4.textures) && e.feature.properties.textures.length > 0) for (let u5 of e.feature.properties.textures) u5.face === "top" && e.topTexture !== u5.path ? S$1(this, Uh3, qy2).call(this, u5.path, e, "topTexture") : u5.face === "side" && e.texture !== u5.path && S$1(this, Uh3, qy2).call(this, u5.path, e, "texture"), e.blendTexture = true;
    (e.texture != null || e.topTexture != null) && (i != null && i.hover && e.texturesVisible ? e.hideTextures() : e.texturesVisible || e.showTextures(), n4.texture === "" && e.removeSideTexture(), n4.topTexture === "" && e.removeTopTexture());
  }
  update() {
    var a4, u5, h, d, m5, v3, x2, S4;
    let e, n4, i;
    for (let I3 of this.state.geometry3DIdsInScene) if (i = this.state.geometry3DMap.get(I3), i instanceof M && i.type === "geometry-group") {
      let w3 = i.components[0];
      if (i.userData.shadingDirty) {
        let E4 = i.userData.entities3D.values().next().value;
        if (E4 == null) continue;
        let T3 = this.state.geometry3DMap.get(E4);
        T3 instanceof oe && (T3.type === "geometry" || T3.type === "custom-geometry") && (e = T3.components[0], i.userData.shadingDirty && w3.shading && this.setShading(e, w3.shading));
        let D4, A3;
        for (let L3 of i.userData.entities3D.values()) D4 = this.state.geometry3DMap.get(L3), A3 = D4.components[0], D4.type === "geometry" && A3.detached && i.userData.shadingDirty && w3.shading && this.setShading(A3, w3.shading);
        i.userData.shadingDirty = false;
      }
      if (w3.dirty) {
        let E4 = i.getfirstChildEntityId();
        if (E4) {
          let D4 = this.state.geometry3DMap.get(E4), A3 = D4 == null ? void 0 : D4.components[0];
          A3 instanceof mt && this.processTextures(A3, w3);
        }
        let T3 = w3.opacity * Oi$1(i);
        i.getOpacity() !== T3 && i.setOpacity(T3), w3.dirty = false;
      }
    } else if (i && (i.type === "geometry" || i.type === "custom-geometry") && ((a4 = i.components[1]) != null && a4.dirty || (u5 = i.components[2]) != null && u5.dirty)) {
      let w3 = i.components[0], E4 = i.components[1];
      n4 = i.components[2];
      let T3 = Yq(i, this.state.hoverColor);
      if (w3.setColor(T3[0], T3[1]), E4.visible !== w3.visible && (w3.visible = E4.visible, w3 instanceof mt && w3.textMesh)) {
        let A3 = this.state.geometry3DMap.get(w3.textMesh.userData.entityId);
        (A3 == null ? void 0 : A3.type) === "text3d" && A3.components[0].polygonEntityId != null && (A3.components[0].visible = E4.visible);
      }
      E4.altitude !== w3.altitude && (w3.altitude = E4.altitude);
      let D4 = E4.opacity * Oi$1(i);
      D4 !== w3.opacity && (w3.opacity = D4), E4.renderOrder !== w3.renderOrder && (w3.renderOrder = E4.renderOrder), E4.dirty = false, w3 instanceof mt && this.processTextures(w3, E4, n4), i.components[2] && (i.components[2].dirty = false);
    } else if ((i == null ? void 0 : i.type) === "model") i.components[1].dirty && (fx2(i), i.components[1].dirty = false), i.components[0].positionDirty && (kO(i, this.convertTo3DMapPosition), i.components[0].positionDirty = false);
    else if ((i == null ? void 0 : i.type) === "image" && ((h = i.components[1]) != null && h.dirty)) {
      e = i.components[0];
      let w3 = i.components[1];
      w3.visible !== e.visible && (e.visible = w3.visible), w3.dirty = false;
    } else if ((i == null ? void 0 : i.type) === "text3d" && ((d = i.components[1]) != null && d.dirty) && i.components[0].polygonEntityId != null) {
      e = i.components[0];
      let w3 = i.components[1];
      w3.visible != null && w3.visible !== e.visible && (e.visible = w3.visible);
      let { textMesh: E4 } = e;
      if (E4) {
        Object.assign(E4, w3.getState());
        let T3 = (m5 = w3.hoverColor) != null ? m5 : this.state.text3dHoverColor;
        E4.color = w3.hoverByPolygon ? T3 : (v3 = w3.color) != null ? v3 : vt.color, E4.outlineColor = w3.hoverByPolygon ? T3 : (x2 = w3.outlineColor) != null ? x2 : vt.outlineColor, E4.strokeColor = w3.hoverByPolygon ? T3 : (S4 = w3.strokeColor) != null ? S4 : vt.strokeColor;
      }
      w3.dirty = false;
    }
  }
  destroy() {
    this.textureLoadingCache.forEach(async (e) => {
      (await e).dispose();
    }), this.textureLoadingCache.clear();
  }
};
Uh3 = /* @__PURE__ */ new WeakSet(), qy2 = H$3(async function(e, n4, i) {
  if (!(!e || !n4.showTextures)) if (this.textureLoadingCache.has(e)) {
    i === "topTexture" ? n4.topTexture = await this.textureLoadingCache.get(e) : n4.texture = await this.textureLoadingCache.get(e), n4.showTextures();
    return;
  } else {
    let a4 = new Promise((u5, h) => {
      kc2.getLoader().load(e, (d) => {
        i === "topTexture" ? n4.topTexture = d : n4.texture = d, n4.showTextures(), this.publish("texture-loaded"), u5(d);
      }, void 0, () => {
        B.error("Failed to load texture: ".concat(e)), h("Failed to load texture: ".concat(e));
      });
    });
    this.textureLoadingCache.set(e, a4);
  }
}, "#loadTexture"), H$3(II, "DrawSystem");
var vx = II;
a();
var MI = class MI2 extends Se$1 {
  constructor(e) {
    super();
    O(this, "state");
    O(this, "animating", /* @__PURE__ */ new Map());
    O(this, "isAnimating", false);
    O(this, "startTime", -1);
    O(this, "showDuration", 300);
    O(this, "hideDuration", 250);
    O(this, "update", H$3(() => {
      this.animating.clear();
      let e4, n4;
      for (let i of this.state.geometry2DIdsInScene) e4 = this.state.geometry2DMap.get(i), e4 && (n4 = e4.components[0], n4 instanceof dl && (n4.visibilityNeedsUpdate === "show" ? (n4.canShow = true, this.animating.set(n4, [n4.opacity, 1])) : n4.visibilityNeedsUpdate === "hide" && this.animating.set(n4, [n4.opacity, 0])));
      this.startTime = performance.now(), this.publish("animate:2d");
    }, "update"));
    O(this, "playAnimations");
    this.state = e, this.playAnimations = this._playAnimations;
  }
  _playAnimations() {
    let e = performance.now();
    for (let [n4, [i, a4]] of this.animating.entries()) {
      let u5 = a4 === 1 ? this.showDuration : this.hideDuration, h = (e - this.startTime) / u5;
      n4.opacity = nn(h, 0, 1, i, a4, a4 === 0 ? ot : kt), e - this.startTime >= u5 && (a4 === 1 ? n4.canShow = true : a4 === 0 && (n4.canShow = false), n4.visibilityNeedsUpdate = false, this.animating.delete(n4));
    }
    this.publish("draw:2d"), this.animating.size > 0 && this.publish("animate:2d");
  }
};
H$3(MI, "TwoDVisibilitySystem");
var bx2 = MI;
a();
var TI = class TI2 extends Se$1 {
  constructor(e, n4, i, a4, u5, h, d) {
    super();
    O(this, "state");
    O(this, "renderer");
    O(this, "mode");
    O(this, "scene");
    O(this, "cameraObject");
    O(this, "viewCamera");
    O(this, "systems");
    O(this, "needs2DRecompute", false);
    O(this, "twoDdirty", true);
    O(this, "threeDdirty", true);
    O(this, "frameId", null);
    O(this, "twoDFrameId", null);
    O(this, "animationFrameId", null);
    O(this, "nextFrame", null);
    O(this, "update", H$3((e4 = false) => {
      var n5;
      if (((n5 = this.renderer) == null ? void 0 : n5.renderer) == null) return Promise.resolve();
      if (e4) {
        let i5 = this.commitRenderState();
        return this.paint(), i5;
      } else return this.frameId ? Promise.resolve() : new Promise((i5, a10) => {
        this.frameId = requestAnimationFrame(() => {
          var u6, h4;
          return ((u6 = this.renderer) == null ? void 0 : u6.renderer) == null ? i5() : this.mode === "standalone" ? (h4 = this.commitRenderState()) == null ? void 0 : h4.then(() => {
            this.paint(), i5();
          }).catch((d4) => {
            a10(d4);
          }) : i5();
        });
      });
    }, "update"));
    O(this, "animate2D", H$3(() => {
      this.animationFrameId = requestAnimationFrame(() => {
        this.animationFrameId = null, this.systems.twoDVisiblitySystem.playAnimations();
      });
    }, "animate2D"));
    O(this, "drawEntities2D", H$3(() => {
      this.twoDFrameId || (this.twoDFrameId = requestAnimationFrame(() => {
        this.twoDFrameId = null, this.systems.twoDDrawSystem.update(this.systems.cameraSystem.getZoomLevel());
      }));
    }, "drawEntities2D"));
    O(this, "updateEntities2D", H$3(() => {
      this.twoDFrameId && (cancelAnimationFrame(this.twoDFrameId), this.twoDFrameId = null), this.twoDFrameId = requestAnimationFrame(() => {
        this.twoDFrameId = null, this.systems.watermarkSystem.insertIntoQuadTree(this.systems.collisionSystem.interactiveCollidersQTree), this.systems.interactionSystem.updateQuadtree(this.systems.collisionSystem.interactiveCollidersQTree), this.systems.twoDVisiblitySystem.update(), this.systems.twoDDrawSystem.update(this.systems.cameraSystem.getZoomLevel()), this.systems.domDrawSystem.update(this.systems.cameraSystem.isUserInteracting());
      });
    }, "updateEntities2D"));
    O(this, "commitRenderState", H$3(() => {
      try {
        let e4 = [];
        this.frameId = null, this.publish("pre-render"), this.state.internalTweenGroup.update(), this.state.externalTweenGroup.update(), (this.mode === "outdoors-interleaved" || this.mode === "standalone") && this.systems.cameraSystem.update(), this.state.shouldMeasureCanvas && (this.state.shouldMeasureCanvas = false, this.publish("measure-canvas")), this.twoDdirty && (this.state.geometry2DIdsInScene.clear(), Zt$1(this.state.entityScene, this.state.geometry2DIdsInScene), this.systems.domVisiblitySystem.dirty = true, this.systems.collisionSystem.collidersDirty = true, this.systems.domMutationSystem.dirty = true, this.systems.panBoundsSystem.dirty = true, this.twoDdirty = false), this.threeDdirty && (this.state.geometry3DIdsInScene.clear(), this.state.geometryGroupIdsToLoad.clear(), Xt$1(this.state.entityScene, this.state.geometry3DIdsInScene, this.state.geometryGroupIdsToLoad), this.threeDdirty = false, this.systems.interactionSystem.dirty3D = true, this.systems.panBoundsSystem.dirty = true, this.systems.outlineInterpolationSystem.geometries3DDirty = true, this.systems.geometryInFocusSystem.focusablesDirty = true);
        let n5 = this.systems.meshOptimizationSystem.update();
        n5 && e4.push(n5), this.systems.meshModificationSystem.update(), this.systems.meshDetachmentSystem.update(), this.systems.imageSystem.update(this.systems.cameraSystem.getRotation()), e4.push(this.systems.text3DSystem.update(this.systems.cameraSystem.getRotation())), this.systems.customGeometrySystem.update(), this.systems.panBoundsSystem.update(), this.systems.geometryInFocusSystem.update(this.systems.cameraSystem.isCameraMoving(), this.systems.cameraSystem.lastCameraStoppedMovingTime()), this.systems.stackSystem.update(), this.systems.outlineInterpolationSystem.update(this.systems.cameraSystem.getZoomLevel(), this.systems.cameraSystem.zoomDirty), this.systems.pathSystem.update(this.systems.cameraSystem.minZoomAltitude, this.systems.cameraSystem.maxZoomAltitude, this.systems.cameraSystem.getZoomAltitude(), this.systems.cameraSystem.getRotation()), this.systems.cameraSystem.postRender(), this.systems.domVisiblitySystem.update(), this.systems.domMutationSystem.update(), this.systems.twoDProjectionSystem.update(), this.systems.occlusion2DSystem.update(), this.systems.twoDDrawSystem.update(this.systems.cameraSystem.getZoomLevel()), this.systems.domDrawSystem.update(this.systems.cameraSystem.isUserInteracting()), this.systems.watermarkSystem.update();
        let i5 = this.needs2DRecompute;
        return this.nextFrame = requestAnimationFrame(() => {
          this.systems.collisionSystem.update(this.systems.watermarkSystem.width, this.systems.watermarkSystem.height, this.systems.watermarkSystem.options.position, !i5);
        }), this.systems.drawSystem.update(), this.systems.geometryDisposalSystem.update(), this.systems.cameraSystem.dirty = false, this.systems.cameraSystem.zoomDirty = false, this.systems.cameraSystem.rotationDirty = false, this.systems.cameraSystem.stateDirty && (this.publish("camera-state-change"), this.systems.cameraSystem.stateDirty = false), this.publish("post-render"), Promise.all(e4);
      } catch (e4) {
        return Promise.reject(e4);
      }
    }, "commitRenderState"));
    this.renderer = e, this.state = n4, this.mode = i, this.scene = a4, this.cameraObject = u5, this.viewCamera = h, this.systems = d, this.systems.collisionSystem.on("visibility-changed", this.updateEntities2D), this.systems.twoDVisiblitySystem.on("draw:2d", this.drawEntities2D), this.systems.twoDVisiblitySystem.on("animate:2d", this.animate2D), this.systems.cameraSystem.on("pan-start", () => this.needs2DRecompute = false), this.systems.cameraSystem.on("zoom-start", () => this.needs2DRecompute = false), this.systems.cameraSystem.on("zoom-end", () => this.needs2DRecompute = true), this.systems.cameraSystem.on("rotate-start", () => this.needs2DRecompute = false), this.systems.cameraSystem.on("rotate-end", () => this.needs2DRecompute = true);
  }
  paint() {
    var e;
    (e = this.renderer) != null && e.renderer && (this.mode === "standalone" && this.renderer.clear(), this.renderer.render(this.scene, this.state.useStandaloneCamera || this.mode === "standalone" ? this.cameraObject : this.viewCamera));
  }
  destroy() {
    this.frameId && cancelAnimationFrame(this.frameId), this.twoDFrameId && cancelAnimationFrame(this.twoDFrameId), this.animationFrameId && cancelAnimationFrame(this.animationFrameId), this.nextFrame && cancelAnimationFrame(this.nextFrame), this.state.geometry2DIdsInScene.clear(), this.state.geometry3DIdsInScene.clear(), this.systems.domVisiblitySystem.dirty = true, this.systems.collisionSystem.collidersDirty = true, this.update(), this.systems.collisionSystem.off("visibility-changed", this.updateEntities2D), this.systems.twoDVisiblitySystem.off("draw:2d", this.drawEntities2D), this.systems.twoDVisiblitySystem.off("animate:2d", this.animate2D);
  }
};
H$3(TI, "RenderSystem");
var xx2 = TI;
a();
var qq = Q.object({ interactive: Q.boolean().optional(), id: Q.string().optional(), nearRadius: Q.number().optional(), farRadius: Q.number().optional(), accentColor: Q.string().optional(), displayArrowsOnPath: Q.boolean().optional(), animateArrowsOnPath: Q.boolean().optional(), nearZoomLevel: Q.number().optional(), farZoomLevel: Q.number().optional(), visibleThroughGeometry: Q.boolean().optional(), dashed: Q.boolean().optional() }), Wq = Q.object({ type: Q.enum(["Feature"]), geometry: nm2, properties: Q.object({ parentId: Q.any().optional() }) });
function BO(r5, t) {
  Q.object({ features: Q.array(Wq) }).parse(r5), qq.parse(t);
}
H$3(BO, "validatePath");
var Wy2, wI = class wI2 {
  constructor(t, e) {
    O(this, "type", "path");
    O(this, "mesh", new fe());
    O(this, "material");
    O(this, "geometry");
    O(this, "outline");
    O(this, "feature");
    O(this, "options");
    O(this, "nearRadius", 0.2);
    O(this, "farRadius", 0.4);
    O(this, "nearZoomLevel");
    O(this, "farZoomLevel");
    O(this, "nearZoomAltitude");
    O(this, "farZoomAltitude");
    O(this, "accentColor", "blue");
    O(this, "completeFraction", 1);
    O(this, "altitudeAdjustment", 1);
    O(this, "displayArrowsOnPath", false);
    O(this, "animateArrowsOnPath", false);
    O(this, "visibleThroughGeometry", false);
    O(this, "dashed", false);
    O(this, "isVertical", false);
    O(this, "dirty", true);
    O(this, "materialDirty", true);
    O(this, "position", new I$1());
    Q$3(this, Wy2, 0);
    var n4, i, a4, u5, h, d, m5;
    this.feature = t, this.options = e || {}, this.accentColor = (n4 = e == null ? void 0 : e.accentColor) != null ? n4 : this.accentColor, this.nearRadius = (i = e == null ? void 0 : e.nearRadius) != null ? i : this.nearRadius, this.farRadius = (a4 = e == null ? void 0 : e.farRadius) != null ? a4 : this.farRadius, this.nearZoomLevel = e == null ? void 0 : e.nearZoomLevel, this.farZoomLevel = e == null ? void 0 : e.farZoomLevel, this.displayArrowsOnPath = (u5 = e == null ? void 0 : e.displayArrowsOnPath) != null ? u5 : this.displayArrowsOnPath, this.animateArrowsOnPath = (h = e == null ? void 0 : e.animateArrowsOnPath) != null ? h : this.animateArrowsOnPath, this.visibleThroughGeometry = (d = e == null ? void 0 : e.visibleThroughGeometry) != null ? d : this.visibleThroughGeometry, this.dashed = (m5 = e == null ? void 0 : e.dashed) != null ? m5 : this.dashed;
  }
  setColor() {
  }
  setOpacity() {
  }
  set visible(t) {
    this.mesh && (this.mesh.visible = t);
  }
  get visible() {
    return this.mesh ? this.mesh.visible : false;
  }
  get altitude() {
    return P(this, Wy2);
  }
  set altitude(t) {
    this.mesh && (this.mesh.position.z = t, R$1(this, Wy2, t));
  }
  set complete(t) {
    this.material && (this.material.uniforms.complete.value = t, this.material.needsUpdate = true);
  }
};
Wy2 = /* @__PURE__ */ new WeakMap(), H$3(wI, "PathComponent");
var Rc2 = wI;
a();
var PI = class PI2 {
  constructor(t) {
    O(this, "rendererState");
    this.rendererState = t;
  }
  update() {
    let t;
    for (let e of this.rendererState.geometry3DIdsInScene) if (t = this.rendererState.geometry3DMap.get(e), t instanceof z && t.components[0]) {
      let n4 = t.components[0];
      if (n4.dirty) {
        for (let i of t.children) (i instanceof M || i instanceof z) && (i.userData.entityId !== t.components[0].activeId ? i.setVisible(false) : i.setVisible(true));
        n4.dirty = false;
      }
    }
  }
};
H$3(PI, "StackSystem");
var _x2 = PI;
a();
a();
a();
var Vn = Object.freeze({ Linear: Object.freeze({ None: H$3(function(r5) {
  return r5;
}, "None"), In: H$3(function(r5) {
  return r5;
}, "In"), Out: H$3(function(r5) {
  return r5;
}, "Out"), InOut: H$3(function(r5) {
  return r5;
}, "InOut") }), Quadratic: Object.freeze({ In: H$3(function(r5) {
  return r5 * r5;
}, "In"), Out: H$3(function(r5) {
  return r5 * (2 - r5);
}, "Out"), InOut: H$3(function(r5) {
  return (r5 *= 2) < 1 ? 0.5 * r5 * r5 : -0.5 * (--r5 * (r5 - 2) - 1);
}, "InOut") }), Cubic: Object.freeze({ In: H$3(function(r5) {
  return r5 * r5 * r5;
}, "In"), Out: H$3(function(r5) {
  return --r5 * r5 * r5 + 1;
}, "Out"), InOut: H$3(function(r5) {
  return (r5 *= 2) < 1 ? 0.5 * r5 * r5 * r5 : 0.5 * ((r5 -= 2) * r5 * r5 + 2);
}, "InOut") }), Quartic: Object.freeze({ In: H$3(function(r5) {
  return r5 * r5 * r5 * r5;
}, "In"), Out: H$3(function(r5) {
  return 1 - --r5 * r5 * r5 * r5;
}, "Out"), InOut: H$3(function(r5) {
  return (r5 *= 2) < 1 ? 0.5 * r5 * r5 * r5 * r5 : -0.5 * ((r5 -= 2) * r5 * r5 * r5 - 2);
}, "InOut") }), Quintic: Object.freeze({ In: H$3(function(r5) {
  return r5 * r5 * r5 * r5 * r5;
}, "In"), Out: H$3(function(r5) {
  return --r5 * r5 * r5 * r5 * r5 + 1;
}, "Out"), InOut: H$3(function(r5) {
  return (r5 *= 2) < 1 ? 0.5 * r5 * r5 * r5 * r5 * r5 : 0.5 * ((r5 -= 2) * r5 * r5 * r5 * r5 + 2);
}, "InOut") }), Sinusoidal: Object.freeze({ In: H$3(function(r5) {
  return 1 - Math.sin((1 - r5) * Math.PI / 2);
}, "In"), Out: H$3(function(r5) {
  return Math.sin(r5 * Math.PI / 2);
}, "Out"), InOut: H$3(function(r5) {
  return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r5)));
}, "InOut") }), Exponential: Object.freeze({ In: H$3(function(r5) {
  return r5 === 0 ? 0 : Math.pow(1024, r5 - 1);
}, "In"), Out: H$3(function(r5) {
  return r5 === 1 ? 1 : 1 - Math.pow(2, -10 * r5);
}, "Out"), InOut: H$3(function(r5) {
  return r5 === 0 ? 0 : r5 === 1 ? 1 : (r5 *= 2) < 1 ? 0.5 * Math.pow(1024, r5 - 1) : 0.5 * (-Math.pow(2, -10 * (r5 - 1)) + 2);
}, "InOut") }), Circular: Object.freeze({ In: H$3(function(r5) {
  return 1 - Math.sqrt(1 - r5 * r5);
}, "In"), Out: H$3(function(r5) {
  return Math.sqrt(1 - --r5 * r5);
}, "Out"), InOut: H$3(function(r5) {
  return (r5 *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r5 * r5) - 1) : 0.5 * (Math.sqrt(1 - (r5 -= 2) * r5) + 1);
}, "InOut") }), Elastic: Object.freeze({ In: H$3(function(r5) {
  return r5 === 0 ? 0 : r5 === 1 ? 1 : -Math.pow(2, 10 * (r5 - 1)) * Math.sin((r5 - 1.1) * 5 * Math.PI);
}, "In"), Out: H$3(function(r5) {
  return r5 === 0 ? 0 : r5 === 1 ? 1 : Math.pow(2, -10 * r5) * Math.sin((r5 - 0.1) * 5 * Math.PI) + 1;
}, "Out"), InOut: H$3(function(r5) {
  return r5 === 0 ? 0 : r5 === 1 ? 1 : (r5 *= 2, r5 < 1 ? -0.5 * Math.pow(2, 10 * (r5 - 1)) * Math.sin((r5 - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r5 - 1)) * Math.sin((r5 - 1.1) * 5 * Math.PI) + 1);
}, "InOut") }), Back: Object.freeze({ In: H$3(function(r5) {
  var t = 1.70158;
  return r5 === 1 ? 1 : r5 * r5 * ((t + 1) * r5 - t);
}, "In"), Out: H$3(function(r5) {
  var t = 1.70158;
  return r5 === 0 ? 0 : --r5 * r5 * ((t + 1) * r5 + t) + 1;
}, "Out"), InOut: H$3(function(r5) {
  var t = 2.5949095;
  return (r5 *= 2) < 1 ? 0.5 * (r5 * r5 * ((t + 1) * r5 - t)) : 0.5 * ((r5 -= 2) * r5 * ((t + 1) * r5 + t) + 2);
}, "InOut") }), Bounce: Object.freeze({ In: H$3(function(r5) {
  return 1 - Vn.Bounce.Out(1 - r5);
}, "In"), Out: H$3(function(r5) {
  return r5 < 0.36363636363636365 ? 7.5625 * r5 * r5 : r5 < 0.7272727272727273 ? 7.5625 * (r5 -= 0.5454545454545454) * r5 + 0.75 : r5 < 0.9090909090909091 ? 7.5625 * (r5 -= 0.8181818181818182) * r5 + 0.9375 : 7.5625 * (r5 -= 0.9545454545454546) * r5 + 0.984375;
}, "Out"), InOut: H$3(function(r5) {
  return r5 < 0.5 ? Vn.Bounce.In(r5 * 2) * 0.5 : Vn.Bounce.Out(r5 * 2 - 1) * 0.5 + 0.5;
}, "InOut") }), generatePow: H$3(function(r5) {
  return r5 === void 0 && (r5 = 4), r5 = r5 < Number.EPSILON ? Number.EPSILON : r5, r5 = r5 > 1e4 ? 1e4 : r5, { In: H$3(function(t) {
    return Math.pow(t, r5);
  }, "In"), Out: H$3(function(t) {
    return 1 - Math.pow(1 - t, r5);
  }, "Out"), InOut: H$3(function(t) {
    return t < 0.5 ? Math.pow(t * 2, r5) / 2 : (1 - Math.pow(2 - t * 2, r5)) / 2 + 0.5;
  }, "InOut") };
}, "generatePow") }), Zy2 = H$3(function() {
  return performance.now();
}, "now"), Cx2 = (function() {
  function r5() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    this._tweens = {}, this._tweensAddedDuringUpdate = {}, this.add.apply(this, t);
  }
  return H$3(r5, "Group"), r5.prototype.getAll = function() {
    var t = this;
    return Object.keys(this._tweens).map(function(e) {
      return t._tweens[e];
    });
  }, r5.prototype.removeAll = function() {
    this._tweens = {};
  }, r5.prototype.add = function() {
    for (var t, e = [], n4 = 0; n4 < arguments.length; n4++) e[n4] = arguments[n4];
    for (var i = 0, a4 = e; i < a4.length; i++) {
      var u5 = a4[i];
      (t = u5._group) === null || t === void 0 || t.remove(u5), u5._group = this, this._tweens[u5.getId()] = u5, this._tweensAddedDuringUpdate[u5.getId()] = u5;
    }
  }, r5.prototype.remove = function() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    for (var n4 = 0, i = t; n4 < i.length; n4++) {
      var a4 = i[n4];
      a4._group = void 0, delete this._tweens[a4.getId()], delete this._tweensAddedDuringUpdate[a4.getId()];
    }
  }, r5.prototype.allStopped = function() {
    return this.getAll().every(function(t) {
      return !t.isPlaying();
    });
  }, r5.prototype.update = function(t, e) {
    t === void 0 && (t = Zy2()), e === void 0 && (e = true);
    var n4 = Object.keys(this._tweens);
    if (n4.length !== 0) for (; n4.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var i = 0; i < n4.length; i++) {
        var a4 = this._tweens[n4[i]], u5 = !e;
        a4 && a4.update(t, u5) === false && !e && this.remove(a4);
      }
      n4 = Object.keys(this._tweensAddedDuringUpdate);
    }
  }, r5;
})(), im2 = { Linear: H$3(function(r5, t) {
  var e = r5.length - 1, n4 = e * t, i = Math.floor(n4), a4 = im2.Utils.Linear;
  return t < 0 ? a4(r5[0], r5[1], n4) : t > 1 ? a4(r5[e], r5[e - 1], e - n4) : a4(r5[i], r5[i + 1 > e ? e : i + 1], n4 - i);
}, "Linear"), Bezier: H$3(function(r5, t) {
  for (var e = 0, n4 = r5.length - 1, i = Math.pow, a4 = im2.Utils.Bernstein, u5 = 0; u5 <= n4; u5++) e += i(1 - t, n4 - u5) * i(t, u5) * r5[u5] * a4(n4, u5);
  return e;
}, "Bezier"), CatmullRom: H$3(function(r5, t) {
  var e = r5.length - 1, n4 = e * t, i = Math.floor(n4), a4 = im2.Utils.CatmullRom;
  return r5[0] === r5[e] ? (t < 0 && (i = Math.floor(n4 = e * (1 + t))), a4(r5[(i - 1 + e) % e], r5[i], r5[(i + 1) % e], r5[(i + 2) % e], n4 - i)) : t < 0 ? r5[0] - (a4(r5[0], r5[0], r5[1], r5[1], -n4) - r5[0]) : t > 1 ? r5[e] - (a4(r5[e], r5[e], r5[e - 1], r5[e - 1], n4 - e) - r5[e]) : a4(r5[i ? i - 1 : 0], r5[i], r5[e < i + 1 ? e : i + 1], r5[e < i + 2 ? e : i + 2], n4 - i);
}, "CatmullRom"), Utils: { Linear: H$3(function(r5, t, e) {
  return (t - r5) * e + r5;
}, "Linear"), Bernstein: H$3(function(r5, t) {
  var e = im2.Utils.Factorial;
  return e(r5) / e(t) / e(r5 - t);
}, "Bernstein"), Factorial: /* @__PURE__ */ (function() {
  var r5 = [1];
  return function(t) {
    var e = 1;
    if (r5[t]) return r5[t];
    for (var n4 = t; n4 > 1; n4--) e *= n4;
    return r5[t] = e, e;
  };
})(), CatmullRom: H$3(function(r5, t, e, n4, i) {
  var a4 = (e - r5) * 0.5, u5 = (n4 - t) * 0.5, h = i * i, d = i * h;
  return (2 * t - 2 * e + a4 + u5) * d + (-3 * t + 3 * e - 2 * a4 - u5) * h + a4 * i + t;
}, "CatmullRom") } }, GO = (function() {
  function r5() {
  }
  return H$3(r5, "Sequence"), r5.nextId = function() {
    return r5._nextId++;
  }, r5._nextId = 0, r5;
})(), EI = new Cx2(), Ho = (function() {
  function r5(t, e) {
    this._isPaused = false, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = false, this._initialRepeat = 0, this._repeat = 0, this._yoyo = false, this._isPlaying = false, this._reversed = false, this._delayTime = 0, this._startTime = 0, this._easingFunction = Vn.Linear.None, this._interpolationFunction = im2.Linear, this._chainedTweens = [], this._onStartCallbackFired = false, this._onEveryStartCallbackFired = false, this._id = GO.nextId(), this._isChainStopped = false, this._propertiesAreSetUp = false, this._goToEnd = false, this._object = t, typeof e == "object" ? (this._group = e, e.add(this)) : e === true && (this._group = EI, EI.add(this));
  }
  return H$3(r5, "Tween"), r5.prototype.getId = function() {
    return this._id;
  }, r5.prototype.isPlaying = function() {
    return this._isPlaying;
  }, r5.prototype.isPaused = function() {
    return this._isPaused;
  }, r5.prototype.getDuration = function() {
    return this._duration;
  }, r5.prototype.to = function(t, e) {
    if (e === void 0 && (e = 1e3), this._isPlaying) throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
    return this._valuesEnd = t, this._propertiesAreSetUp = false, this._duration = e < 0 ? 0 : e, this;
  }, r5.prototype.duration = function(t) {
    return t === void 0 && (t = 1e3), this._duration = t < 0 ? 0 : t, this;
  }, r5.prototype.dynamic = function(t) {
    return t === void 0 && (t = false), this._isDynamic = t, this;
  }, r5.prototype.start = function(t, e) {
    if (t === void 0 && (t = Zy2()), e === void 0 && (e = false), this._isPlaying) return this;
    if (this._repeat = this._initialRepeat, this._reversed) {
      this._reversed = false;
      for (var n4 in this._valuesStartRepeat) this._swapEndStartRepeatValues(n4), this._valuesStart[n4] = this._valuesStartRepeat[n4];
    }
    if (this._isPlaying = true, this._isPaused = false, this._onStartCallbackFired = false, this._onEveryStartCallbackFired = false, this._isChainStopped = false, this._startTime = t, this._startTime += this._delayTime, !this._propertiesAreSetUp || e) {
      if (this._propertiesAreSetUp = true, !this._isDynamic) {
        var i = {};
        for (var a4 in this._valuesEnd) i[a4] = this._valuesEnd[a4];
        this._valuesEnd = i;
      }
      this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e);
    }
    return this;
  }, r5.prototype.startFromCurrentValues = function(t) {
    return this.start(t, true);
  }, r5.prototype._setupProperties = function(t, e, n4, i, a4) {
    for (var u5 in n4) {
      var h = t[u5], d = Array.isArray(h), m5 = d ? "array" : typeof h, v3 = !d && Array.isArray(n4[u5]);
      if (!(m5 === "undefined" || m5 === "function")) {
        if (v3) {
          var x2 = n4[u5];
          if (x2.length === 0) continue;
          for (var S4 = [h], I3 = 0, w3 = x2.length; I3 < w3; I3 += 1) {
            var E4 = this._handleRelativeValue(h, x2[I3]);
            if (isNaN(E4)) {
              v3 = false, console.warn("Found invalid interpolation list. Skipping.");
              break;
            }
            S4.push(E4);
          }
          v3 && (n4[u5] = S4);
        }
        if ((m5 === "object" || d) && h && !v3) {
          e[u5] = d ? [] : {};
          var T3 = h;
          for (var D4 in T3) e[u5][D4] = T3[D4];
          i[u5] = d ? [] : {};
          var x2 = n4[u5];
          if (!this._isDynamic) {
            var A3 = {};
            for (var D4 in x2) A3[D4] = x2[D4];
            n4[u5] = x2 = A3;
          }
          this._setupProperties(T3, e[u5], x2, i[u5], a4);
        } else (typeof e[u5] > "u" || a4) && (e[u5] = h), d || (e[u5] *= 1), v3 ? i[u5] = n4[u5].slice().reverse() : i[u5] = e[u5] || 0;
      }
    }
  }, r5.prototype.stop = function() {
    return this._isChainStopped || (this._isChainStopped = true, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = false, this._isPaused = false, this._onStopCallback && this._onStopCallback(this._object), this) : this;
  }, r5.prototype.end = function() {
    return this._goToEnd = true, this.update(this._startTime + this._duration), this;
  }, r5.prototype.pause = function(t) {
    return t === void 0 && (t = Zy2()), this._isPaused || !this._isPlaying ? this : (this._isPaused = true, this._pauseStart = t, this);
  }, r5.prototype.resume = function(t) {
    return t === void 0 && (t = Zy2()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = false, this._startTime += t - this._pauseStart, this._pauseStart = 0, this);
  }, r5.prototype.stopChainedTweens = function() {
    for (var t = 0, e = this._chainedTweens.length; t < e; t++) this._chainedTweens[t].stop();
    return this;
  }, r5.prototype.group = function(t) {
    return t ? (t.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
  }, r5.prototype.remove = function() {
    var t;
    return (t = this._group) === null || t === void 0 || t.remove(this), this;
  }, r5.prototype.delay = function(t) {
    return t === void 0 && (t = 0), this._delayTime = t, this;
  }, r5.prototype.repeat = function(t) {
    return t === void 0 && (t = 0), this._initialRepeat = t, this._repeat = t, this;
  }, r5.prototype.repeatDelay = function(t) {
    return this._repeatDelayTime = t, this;
  }, r5.prototype.yoyo = function(t) {
    return t === void 0 && (t = false), this._yoyo = t, this;
  }, r5.prototype.easing = function(t) {
    return t === void 0 && (t = Vn.Linear.None), this._easingFunction = t, this;
  }, r5.prototype.interpolation = function(t) {
    return t === void 0 && (t = im2.Linear), this._interpolationFunction = t, this;
  }, r5.prototype.chain = function() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return this._chainedTweens = t, this;
  }, r5.prototype.onStart = function(t) {
    return this._onStartCallback = t, this;
  }, r5.prototype.onEveryStart = function(t) {
    return this._onEveryStartCallback = t, this;
  }, r5.prototype.onUpdate = function(t) {
    return this._onUpdateCallback = t, this;
  }, r5.prototype.onRepeat = function(t) {
    return this._onRepeatCallback = t, this;
  }, r5.prototype.onComplete = function(t) {
    return this._onCompleteCallback = t, this;
  }, r5.prototype.onStop = function(t) {
    return this._onStopCallback = t, this;
  }, r5.prototype.update = function(t, e) {
    var n4 = this, i;
    if (t === void 0 && (t = Zy2()), e === void 0 && (e = r5.autoStartOnUpdate), this._isPaused) return true;
    var a4;
    if (!this._goToEnd && !this._isPlaying) if (e) this.start(t, true);
    else return false;
    if (this._goToEnd = false, t < this._startTime) return true;
    this._onStartCallbackFired === false && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = true), this._onEveryStartCallbackFired === false && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = true);
    var u5 = t - this._startTime, h = this._duration + ((i = this._repeatDelayTime) !== null && i !== void 0 ? i : this._delayTime), d = this._duration + this._repeat * h, m5 = H$3(function() {
      if (n4._duration === 0 || u5 > d) return 1;
      var E4 = Math.trunc(u5 / h), T3 = u5 - E4 * h, D4 = Math.min(T3 / n4._duration, 1);
      return D4 === 0 && u5 === n4._duration ? 1 : D4;
    }, "calculateElapsedPortion"), v3 = m5(), x2 = this._easingFunction(v3);
    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, x2), this._onUpdateCallback && this._onUpdateCallback(this._object, v3), this._duration === 0 || u5 >= this._duration) if (this._repeat > 0) {
      var S4 = Math.min(Math.trunc((u5 - this._duration) / h) + 1, this._repeat);
      isFinite(this._repeat) && (this._repeat -= S4);
      for (a4 in this._valuesStartRepeat) !this._yoyo && typeof this._valuesEnd[a4] == "string" && (this._valuesStartRepeat[a4] = this._valuesStartRepeat[a4] + parseFloat(this._valuesEnd[a4])), this._yoyo && this._swapEndStartRepeatValues(a4), this._valuesStart[a4] = this._valuesStartRepeat[a4];
      return this._yoyo && (this._reversed = !this._reversed), this._startTime += h * S4, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = false, true;
    } else {
      this._onCompleteCallback && this._onCompleteCallback(this._object);
      for (var I3 = 0, w3 = this._chainedTweens.length; I3 < w3; I3++) this._chainedTweens[I3].start(this._startTime + this._duration, false);
      return this._isPlaying = false, false;
    }
    return true;
  }, r5.prototype._updateProperties = function(t, e, n4, i) {
    for (var a4 in n4) if (e[a4] !== void 0) {
      var u5 = e[a4] || 0, h = n4[a4], d = Array.isArray(t[a4]), m5 = Array.isArray(h), v3 = !d && m5;
      v3 ? t[a4] = this._interpolationFunction(h, i) : typeof h == "object" && h ? this._updateProperties(t[a4], u5, h, i) : (h = this._handleRelativeValue(u5, h), typeof h == "number" && (t[a4] = u5 + (h - u5) * i));
    }
  }, r5.prototype._handleRelativeValue = function(t, e) {
    return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
  }, r5.prototype._swapEndStartRepeatValues = function(t) {
    var e = this._valuesStartRepeat[t], n4 = this._valuesEnd[t];
    typeof n4 == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(n4) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
  }, r5.autoStartOnUpdate = false, r5;
})();
GO.nextId;
var yl = EI;
yl.getAll.bind(yl);
yl.removeAll.bind(yl);
yl.add.bind(yl);
yl.remove.bind(yl);
yl.update.bind(yl);
a();
a();
a();
var VO = H$3((r5, t) => (t - r5 + Math.PI) % (Math.PI * 2) + Math.PI * 2 % (Math.PI * 2) - Math.PI, "differenceBetweenAngles"), jO = H$3((r5, t) => new ot$1(r5.clientX - t.offsetLeft, r5.clientY - t.offsetTop), "getTouchPos"), OI = H$3((r5, t) => Math.atan2(t.y - r5.y, t.x - r5.x), "angle"), $y2 = H$3((r5, t) => Math.sqrt((t.y - r5.y) ** 2 + (t.x - r5.x) ** 2), "distance"), DI = H$3((r5, t) => new ot$1((r5.x + t.x) / 2, (r5.y + t.y) / 2), "average"), LI = H$3((r5) => {
  let t = 0, { wheelDelta: e, detail: n4 } = r5;
  return e !== void 0 ? t = e : n4 !== void 0 && (t = -n4), t;
}, "getScrollDelta");
var AI = class AI2 {
  constructor(t, e) {
    O(this, "input1");
    O(this, "input2");
    O(this, "lastAngle");
    O(this, "lastDistance");
    O(this, "totalDistance");
    O(this, "first");
    O(this, "second");
    this.input1 = t, this.input2 = e, this.lastAngle = OI(t, e), this.lastDistance = $y2(t, e), this.totalDistance = 0, this.first = t, this.second = e;
  }
  update(t, e) {
    let n4 = $y2(t, e);
    this.input1 = t, this.input2 = e;
    let i = OI(t, e);
    this.lastAngle = i, this.lastDistance = n4, this.totalDistance += ($y2(this.first, t) + $y2(this.second, e)) / 2, this.first = DI(this.first, t), this.second = DI(this.second, e);
  }
};
H$3(AI, "InputSet");
var Sx = AI;
a();
var NI = class NI2 {
  constructor(t, e, n4) {
    O(this, "touch");
    O(this, "camera");
    O(this, "cameraPlane");
    O(this, "viewCoordinate");
    O(this, "snapHolderMatrix");
    O(this, "snapCamera");
    O(this, "cameraPosition");
    O(this, "raycaster");
    O(this, "worldCoordinate");
    O(this, "snapshotted", false);
    this.touch = t, this.camera = e, this.cameraPlane = n4, this.viewCoordinate = { x: t.x, y: t.y }, this.camera.updateMatrixWorld(), this.camera.updateMatrix(), this.snapHolderMatrix = this.camera.matrixWorld.clone(), this.snapCamera = this.camera.clone(), this.snapshotCameraState();
  }
  snapshotCameraState() {
    this.camera.updateMatrix(), this.camera.updateMatrixWorld(), this.cameraPosition = this.camera.position.clone();
    let t = new ot$1(this.viewCoordinate.x, this.viewCoordinate.y);
    this.raycaster = this.raycaster || new Yl$2(), this.raycaster.setFromCamera(t, this.snapCamera);
    let e = this.raycaster.intersectObject(this.cameraPlane, true);
    this.worldCoordinate = e && e.length > 0 ? e[0].point : null, this.snapshotted = true;
  }
  updateAnchorState(t, e) {
    this.camera = t, this.snapCamera = t.clone(), this.snapHolderMatrix = t.matrixWorld.clone(), this.updateViewCoordinate(e), this.snapshotCameraState();
  }
  updateViewCoordinate(t) {
    this.viewCoordinate = { x: t.x, y: t.y };
  }
  reUnproject() {
    var n4, i;
    let t = new ot$1(this.viewCoordinate.x, this.viewCoordinate.y);
    (n4 = this.raycaster) == null || n4.setFromCamera(t, this.snapCamera);
    let e = (i = this.raycaster) == null ? void 0 : i.intersectObject(this.cameraPlane, true)[0];
    return e ? e.point : void 0;
  }
};
H$3(NI, "TouchAnchor");
var Jy2 = NI;
var Fs2 = {};
M$1(Fs2, { BLOCK_MERCATOR_ZOOM_LEVEL: () => $q, CLIPPING_RADIUS: () => Ky2, CONTROL_OPTIONS: () => Zq, DEFAULT_ANIMATION_DURATION: () => GI, DEFAULT_BEARING: () => eW, DEFAULT_MAX_ZOOM_LEVEL: () => Qq, DEFAULT_MIN_ZOOM_LEVEL: () => VI, DEFAULT_PITCH: () => tW, DEFAULT_ZOOM_LEVEL: () => Kq, EVENTS: () => wx2, MAPLIBRE_TILE_SIZE: () => Ix, MAX_LAT: () => RI, MAX_MERCATOR_ZOOM_LEVEL: () => Tx2, MIN_LAT: () => kI, MIN_MERCATOR_ZOOM_LEVEL: () => Mx2, ROOM_MERCATOR_ZOOM_LEVEL: () => Jq, TWO_PI: () => FI, WHEEL_ZOOM_MULTIPLIER: () => BI, ZRANGE: () => om2 });
a();
var Ix = 512, kI = -85.051129, RI = 85.051129, Ky2 = 1e4, Zq = { chain: "chain", cancel: "cancel" }, FI = Math.PI * 2, om2 = 100, BI = 1e4, Mx2 = 0, Tx2 = 24, $q = 17, Jq = 20, GI = 200, wx2 = ["change", "pan-start", "pan-end", "rotate-start", "rotate-end", "zoom-start", "zoom-end", "multi-start", "multi-end", "multi-cancel", "pedestal-start", "pedestal-change", "pedestal-end", "user-pan-start", "user-pedestal-start", "user-rotate-start", "user-dolly-start", "user-zoom-start", "user-tilt-start", "user-pan-end", "user-pedestal-end", "user-rotate-end", "user-dolly-end", "user-zoom-end", "user-tilt-end", "position-updated", "zoom-updated", "tilt-updated", "rotation-updated"], Kq = 18, VI = 12, Qq = 22, tW = 0, eW = 0;
a();
function UO(r5) {
  r5 && (r5.map && (r5.map.dispose(), r5.map = void 0), r5.dispose());
}
H$3(UO, "scrubMaterial");
function Jr(r5) {
  for (let t = r5.children.length - 1; t >= 0; t--) Jr(r5.children[t]);
  "geometry" in r5 && r5.geometry && r5.geometry.dispose(), r5.parent && r5.parent.remove(r5), "material" in r5 && Array.isArray(r5.material) ? r5.material.forEach(function(t) {
    UO(t);
  }) : "material" in r5 && typeof r5.material < "u" && UO(r5.material);
}
H$3(Jr, "destroyObject3D");
var Px = false;
var Ex, Ox = class Ox2 extends Se$1 {
  constructor(e, n4, i, a4, u5) {
    super();
    O(this, "dirty", false);
    O(this, "zoomDirty", false);
    O(this, "rotationDirty", false);
    O(this, "panDirty", false);
    O(this, "stateDirty", false);
    Q$3(this, Ex, VI);
    O(this, "zoomSpeed", 5);
    O(this, "rotateSpeed", 100);
    O(this, "enabled", true);
    O(this, "enableZoom", true);
    O(this, "enablePan", true);
    O(this, "enablePedestal", false);
    O(this, "maxPedestal", 1 / 0);
    O(this, "minPedestal", 0);
    O(this, "enableRotate", true);
    O(this, "minZoomAltitude", 0);
    O(this, "maxZoomAltitude", 1 / 0);
    O(this, "ignoreZoomLimits", false);
    O(this, "zoomFactor", 1);
    O(this, "panBounds", { min: new I$1(1 / 0, 1 / 0), max: new I$1(-1 / 0, -1 / 0), center: new I$1(0, 0, 0), radius: 1 / 0 });
    O(this, "minTilt", 0);
    O(this, "maxTilt", 1.2);
    O(this, "MOUSE_BUTTONS", { ORBIT: Tp$2.RIGHT, ZOOM: Tp$2.MIDDLE, PAN: Tp$2.LEFT });
    O(this, "camera");
    O(this, "scene");
    O(this, "renderer");
    O(this, "elevation");
    O(this, "orbit");
    O(this, "cameraPlane");
    O(this, "raycaster", new Yl$2());
    O(this, "rendererState");
    O(this, "options");
    O(this, "state", -1);
    O(this, "intersection");
    O(this, "viewState", null);
    O(this, "tweens", /* @__PURE__ */ new Map());
    O(this, "clock", new Xl(true));
    O(this, "coords", { mouse: new ot$1(), rotateStart: new ot$1(), rotateEnd: new ot$1(), rotateDelta: new ot$1(), panStart: new I$1(), panCameraStart: new I$1(), panEnd: new I$1(), panDelta: new I$1(), initialShiftPos: new ot$1(), initialPedestal: 0, floorAnchor: new I$1() });
    O(this, "touch", { origin: { offsetLeft: 0, offsetTop: 0 }, touches: [], anchor1: null, anchor2: null, inputs: null });
    O(this, "scrollTimer", null);
    O(this, "lastWheelTime", 0);
    O(this, "resetZoom", false);
    O(this, "zoomStart");
    O(this, "pedestalScaleFactor", 1);
    O(this, "isUserZooming", false);
    O(this, "stayInsideBounds", true);
    O(this, "userInteracting", false);
    O(this, "cameraMoving", false);
    O(this, "lastCameraMoveTime", Date.now());
    O(this, "raycastToFloor", H$3((e4) => {
      this.raycaster.setFromCamera(e4, this.camera);
      let n5 = this.raycaster.intersectObject(this.cameraPlane, false)[0];
      return n5 ? n5.point : new I$1();
    }, "raycastToFloor"));
    O(this, "isUserInteracting", H$3(() => this.userInteracting, "isUserInteracting"));
    O(this, "getPosition", H$3(() => new I$1(this.orbit.position.x, this.orbit.position.y, this.orbit.position.z), "getPosition"));
    O(this, "getPedestal", H$3(() => this.orbit.position.z, "getPedestal"));
    O(this, "pan", H$3((e4, n5) => {
      isNaN(e4) || isNaN(n5) || (this.setPosition(this.orbit.position.x + e4, this.orbit.position.y + n5), this.publish("position-updated"));
    }, "pan"));
    O(this, "postRender", H$3(() => {
      (this.state === 2 || this.state === 6) && (this.raycaster.setFromCamera(this.coords.mouse, this.camera), this.intersection = this.raycaster.intersectObject(this.cameraPlane, false)[0], this.intersection && (this.coords.panStart.set(this.intersection.point.x, this.intersection.point.y, 0), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0))), this.state === 3 && this.resetZoom && (this.resetZoom = false, this.zoomStart = this.getZoomAltitude(), this.coords.floorAnchor = this.raycastToFloor(this.coords.mouse), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0)), this.state === 7 && this.isAnimating === false && (this.state = -1, this.publish("multi-end"));
    }, "postRender"));
    O(this, "isCameraMoving", H$3(() => this.cameraMoving, "isCameraMoving"));
    O(this, "lastCameraStoppedMovingTime", H$3(() => this.lastCameraMoveTime, "lastCameraStoppedMovingTime"));
    O(this, "setPosition", H$3((e4, n5) => {
      e4 === void 0 || n5 === void 0 || isNaN(e4) || isNaN(n5) || (this.state === -1 && this.publish("pan-start"), this.updateCameraPosition(e4, n5), this.publish("position-updated"), this.publish("change"), this.state === -1 && this.publish("pan-end"), this.dirty = true, this.stateDirty = true);
    }, "setPosition"));
    O(this, "updateCameraPosition", H$3((e4, n5) => {
      let i5 = e4 - this.panBounds.center.x, a10 = n5 - this.panBounds.center.y, u6 = Math.sqrt(i5 * i5 + a10 * a10);
      if (this.stayInsideBounds && u6 > this.panBounds.radius) {
        let h = Math.atan2(a10, i5), d = { x: Math.cos(h) * this.panBounds.radius + this.panBounds.center.x, y: Math.sin(h) * this.panBounds.radius + this.panBounds.center.y };
        this.orbit.position.x = d.x, this.orbit.position.y = d.y;
      } else this.orbit.position.x = e4, this.orbit.position.y = n5;
    }, "updateCameraPosition"));
    O(this, "tilt", H$3((e4) => {
      if (isNaN(e4)) return;
      this.state === -1 && this.publish("rotate-start");
      let n5 = this.stayInsideBounds ? Math.max(Math.min(e4 + this.getTilt(), this.maxTilt), this.minTilt) : e4 + this.getTilt();
      n5 !== this.elevation.rotation.x && (this.elevation.rotation.x = n5, this.publish("tilt-updated")), this.publish("change"), this.state === -1 && this.publish("rotate-end"), this.stateDirty = true;
    }, "tilt"));
    O(this, "zoomIn", H$3((e4, n5, i5) => {
      let a10 = this.getZoomAltitude();
      this.animateCamera({ zoom: a10 / 1.5 }, e4, n5, i5);
    }, "zoomIn"));
    O(this, "zoomOut", H$3((e4, n5, i5) => {
      let a10 = this.getZoomAltitude();
      this.animateCamera({ zoom: a10 * 1.5 }, e4, n5, i5);
    }, "zoomOut"));
    O(this, "getRotation", H$3(() => (-this.orbit.rotation.z + Math.PI * 2) % (Math.PI * 2), "getRotation"));
    O(this, "cancelAnimation", H$3(() => {
      let e4 = Array.from(this.tweens.keys()), n5 = e4[e4.length - 1];
      n5.state === 7 && this.publish("multi-cancel", { zooming: true, rotating: true, tilting: true }), this.completeTween(n5);
    }, "cancelAnimation"));
    O(this, "animateCamera", H$3((e4, n5, i5, a10, u6, h) => {
      let d = F$1({ interruptible: true }, h), m5 = {}, v3 = {}, x2 = this.getPosition();
      if (e4.position != null && (e4.position.x !== void 0 && (m5.x = x2.x, v3.x = e4.position.x), e4.position.y !== void 0 && (m5.y = x2.y, v3.y = e4.position.y), e4.position.z !== void 0 && (m5.z = x2.z, v3.z = e4.position.z)), e4.zoom !== void 0 && (m5.zoom = this.stayInsideBounds ? Math.min(Math.max(this.getZoomAltitude(), this.getZoomScaledMin()), this.getZoomScaledMax()) : this.getZoomAltitude(), this.viewState === "multi_floor" || !this.stayInsideBounds ? v3.zoom = e4.zoom : v3.zoom = Math.min(Math.max(e4.zoom, this.getZoomScaledMin()), this.getZoomScaledMax())), e4.rotation !== void 0) {
        let { start: L3, end: B3 } = Ir(this.getRotation(), e4.rotation);
        m5.rotation = L3, v3.rotation = B3;
      }
      e4.tilt !== void 0 && (m5.tilt = this.getTilt(), this.viewState === "multi_floor" || !this.stayInsideBounds ? v3.tilt = e4.tilt : v3.tilt = Math.max(Math.min(e4.tilt, this.maxTilt), this.minTilt));
      let S4 = m5.zoom !== v3.zoom, I3 = m5.rotation !== v3.rotation, w3 = m5.tilt !== v3.tilt, E4 = new Ho(m5).to(v3, p$1.env.TESTING ? 0 : n5).onUpdate((L3) => {
        this.setMulti({ x: L3.x, y: L3.y, z: L3.z }, L3.zoom, L3.rotation, L3.tilt);
      }).onComplete(() => {
        this.completeTween(E4), this.publish("multi-end", { zooming: S4, rotating: I3, tilting: w3 }), a10 && a10();
      }).onStart(() => {
        this.state !== 7 && (this.state = 7, E4.state = 7, this.publish("multi-start", { zooming: S4, rotating: I3, tilting: w3 })), this.publish("change");
      });
      this.rendererState.internalTweenGroup.add(E4);
      let T3 = Array.from(this.tweens.entries()), D4 = T3[T3.length - 1], A3 = false;
      return D4 != null && (D4[1].interruptible ? (typeof D4[1].cancelledCallback == "function" && D4[1].cancelledCallback(), this.completeTween(D4[0])) : (A3 = true, D4[0].chain(E4))), this.tweens.set(E4, { cancelledCallback: u6, interruptible: d.interruptible }), i5 ? E4.easing(i5) : E4.easing(Vn.Quadratic.In), !e4.doNotAutoStart && !A3 && (E4.start(), this.publish("change")), E4.cameraAnimation = true, E4;
    }, "animateCamera"));
    O(this, "setMulti", H$3((e4, n5, i5, a10, u6 = true) => {
      this.state === -1 && this.publish("multi-start");
      let h = false;
      e4 != null && (e4.x !== void 0 && !isNaN(e4.x) && e4.y !== void 0 && !isNaN(e4.y) && (this.updateCameraPosition(e4.x, e4.y), h = true), e4.z !== void 0 && !isNaN(e4.z) && (this.setPedestal(e4.z, true, false), h = true)), h && this.publish("position-updated");
      let d = { zooming: false, tilting: !!n5, rotating: false };
      if (n5 !== void 0 && !isNaN(n5)) {
        let m5 = this.stayInsideBounds ? Math.min(Math.max(n5, this.getZoomScaledMin()), this.getZoomScaledMax()) : n5;
        m5 !== this.camera.position.z && (d.zooming = true, this.camera.position.z = m5, this.publish("zoom-updated"), this.zoomDirty = true, this.viewState === "multi_floor" ? n5 > Ky2 && (this.camera.near = n5 - Ky2, this.camera.far = n5 + Ky2) : (this.camera.near = n5 / om2, this.camera.far = n5 * om2), this.camera.updateProjectionMatrix());
      }
      if (i5 !== void 0 && !isNaN(i5) && i5 !== this.getRotation() && (d.rotating = true, this.orbit.rotation.z = -i5, this.publish("rotation-updated")), a10 !== void 0 && !isNaN(a10)) {
        let m5 = this.stayInsideBounds ? Math.max(Math.min(a10, this.maxTilt), this.minTilt) : a10;
        m5 !== this.elevation.rotation.x && (d.tilting = true, this.elevation.rotation.x = m5, this.publish("tilt-updated"));
      }
      u6 && this.publish("change"), this.state === -1 && this.publish("multi-end", d), this.stateDirty = true;
    }, "setMulti"));
    O(this, "getZoomScaledMin", H$3(() => this.minZoomAltitude * this.zoomFactor, "getZoomScaledMin"));
    O(this, "getZoomScaledMax", H$3(() => {
      let e4 = this.minZoomAltitude * this.zoomFactor;
      return Math.max(this.maxZoomAltitude, e4);
    }, "getZoomScaledMax"));
    O(this, "setRotation", H$3((e4, n5) => {
      if (isNaN(e4)) return;
      this.state === -1 && !n5 && this.publish("rotate-start");
      let i5 = -(e4 % FI);
      i5 !== this.orbit.rotation.z && (this.orbit.rotation.z = i5, n5 || this.publish("rotation-updated")), n5 || this.publish("change"), this.state === -1 && !n5 && this.publish("rotate-end"), this.dirty = true, this.rotationDirty = true, n5 || (this.stateDirty = true);
    }, "setRotation"));
    O(this, "setZoomAltitude", H$3((e4) => {
      if (isNaN(e4)) return;
      this.state === -1 && this.publish("zoom-start");
      let n5 = this.stayInsideBounds ? Math.min(Math.max(e4, this.getZoomScaledMin()), this.getZoomScaledMax()) : e4;
      n5 !== this.camera.position.z && (this.camera.position.z = n5, this.publish("zoom-updated"), this.zoomDirty = true), this.camera.near = n5 / om2, this.camera.far = n5 * om2, this.camera.updateProjectionMatrix(), this.publish("change"), this.state === -1 && this.publish("zoom-end"), this.dirty = true, this.stateDirty = true;
    }, "setZoomAltitude"));
    O(this, "setZoomLevel", H$3((e4) => {
      this.setZoomAltitude(this.convertZoomLevelToAltitude(e4));
    }, "setZoomLevel"));
    O(this, "getZoomAltitude", H$3(() => this.camera.position.z, "getZoomAltitude"));
    O(this, "getZoomLevel", H$3(() => this.convertAltitudeToZoomLevel(this.getZoomAltitude()), "getZoomLevel"));
    O(this, "setTilt", H$3((e4, n5) => {
      if (isNaN(e4)) return;
      this.state === -1 && !n5 && this.publish("rotate-start");
      let i5 = this.stayInsideBounds ? Math.max(Math.min(e4, this.maxTilt), this.minTilt) : e4;
      i5 !== this.elevation.rotation.x && (this.elevation.rotation.x = i5, n5 || this.publish("tilt-updated")), n5 || this.publish("change"), this.state === -1 && !n5 && this.publish("rotate-end"), this.dirty = true, n5 || (this.stateDirty = true);
    }, "setTilt"));
    O(this, "getTilt", H$3(() => this.elevation.rotation.x, "getTilt"));
    O(this, "setCameraPlaneElevation", H$3((e4) => {
      this.cameraPlane.position.z = e4;
    }, "setCameraPlaneElevation"));
    O(this, "zoom", H$3((e4) => {
      if (isNaN(e4)) return;
      this.state === -1 && this.publish("zoom-start");
      let n5 = this.getZoomAltitude() - e4;
      this.camera.position.z = this.stayInsideBounds ? Math.min(Math.max(n5, this.minZoomAltitude * this.zoomFactor), this.maxZoomAltitude * this.zoomFactor) : n5, this.publish("zoom-updated"), this.zoomDirty = true, this.publish("change"), this.state === -1 && this.publish("zoom-end"), this.stateDirty = true;
    }, "zoom"));
    O(this, "getProjectionScaleFactor", H$3((e4, n5, i5) => Ci(e4, n5, i5), "getProjectionScaleFactor"));
    O(this, "update", H$3(() => {
      this.orbit.updateMatrixWorld(), this.lastWheelTime > 0 && this.state === 3 && this.clock.getElapsedTime() - this.lastWheelTime > 0.2 && (this.lastWheelTime = 0, this.state = -1, this.publish("zoom-end"), this.removeMouseMoveEventListeners());
    }, "update"));
    O(this, "setPedestal", H$3((e4, n5 = false, i5 = true) => {
      typeof e4 == "number" && !isNaN(e4) && (this.orbit.position.z = e4, n5 && (this.publishPedestalChangeEvent(e4), this.publish("pedestal-change", { pedestal: e4 })), this.publish("change"), this.dirty = true, i5 && (this.stateDirty = true));
    }, "setPedestal"));
    O(this, "dispose", H$3(() => {
      for (let e4 of wx2) e4.endsWith("start") ? (this.off(e4, this.setCameraMoving), e4.startsWith("user") && this.off(e4, this.setUserInteracting)) : (e4.endsWith("end") || e4.endsWith("cancel")) && (this.off(e4, this.unsetCameraMoving), e4.startsWith("user") && this.off(e4, this.unsetUserInteracting));
      this.removeEventListeners(), this.scene.remove(this.cameraPlane);
    }, "dispose"));
    O(this, "createCameraPlane", H$3(() => {
      let e4 = 1e10, n5 = 1, i5 = new Os$2(e4, e4, n5, n5), a10 = new vs$1({ color: 0, wireframe: Px, visible: Px }), u6 = new ye$1(i5, a10);
      return this.scene.add(u6), u6;
    }, "createCameraPlane"));
    O(this, "addEventListeners", H$3(() => {
      let { domElement: e4 } = this.renderer;
      for (let n5 of wx2) n5.endsWith("start") ? (this.on(n5, this.setCameraMoving), n5.startsWith("user") && this.on(n5, this.setUserInteracting)) : (n5.endsWith("end") || n5.endsWith("cancel")) && (this.on(n5, this.unsetCameraMoving), n5.startsWith("user") && this.on(n5, this.unsetUserInteracting));
      e4.addEventListener("contextmenu", this.onContextMenu, false), e4.addEventListener("mousedown", this.onMouseDown, false), e4.addEventListener("wheel", this.onMouseWheel, { passive: false }), e4.addEventListener("touchstart", this.onTouchStart, false), e4.addEventListener("touchend", this.onTouchEnd, false), e4.addEventListener("touchmove", this.onTouchMove, false);
    }, "addEventListeners"));
    O(this, "addMouseEventListeners", H$3(() => {
      this.addMouseMoveEventListeners(), window.addEventListener("mouseup", this.onMouseUp, false), window.addEventListener("mouseout", this.onMouseUp, false);
    }, "addMouseEventListeners"));
    O(this, "addMouseMoveEventListeners", H$3(() => {
      this.renderer.domElement.addEventListener("mousemove", this.onMouseMove, false);
    }, "addMouseMoveEventListeners"));
    O(this, "removeMouseMoveEventListeners", H$3(() => {
      this.renderer.domElement.removeEventListener("mousemove", this.onMouseMove, false);
    }, "removeMouseMoveEventListeners"));
    O(this, "removeEventListeners", H$3(() => {
      let { domElement: e4 } = this.renderer;
      e4.removeEventListener("contextmenu", this.onContextMenu, false), e4.removeEventListener("mousedown", this.onMouseDown, false), e4.removeEventListener("wheel", this.onMouseWheel, false), e4.removeEventListener("touchstart", this.onTouchStart, false), e4.removeEventListener("touchend", this.onTouchEnd, false), e4.removeEventListener("touchmove", this.onTouchMove, false), e4.removeEventListener("mousemove", this.onMouseMove, false), window.removeEventListener("mouseup", this.onMouseUp, false), window.removeEventListener("mouseout", this.onMouseUp, false);
    }, "removeEventListeners"));
    O(this, "removeMouseUpEventListeners", H$3(() => {
      this.renderer.domElement.removeEventListener("mousemove", this.onMouseMove, false), window.removeEventListener("mouseup", this.onMouseUp, false), window.removeEventListener("mouseout", this.onMouseUp, false);
    }, "removeMouseUpEventListeners"));
    O(this, "onContextMenu", H$3((e4) => {
      e4.preventDefault();
    }, "onContextMenu"));
    O(this, "onMouseUp", H$3(() => {
      if (this.enabled !== false) {
        switch (this.removeMouseUpEventListeners(), this.state) {
          case 2:
            this.publish("pan-end"), this.publish("user-pan-end");
            break;
          case 1:
            this.publish("zoom-end"), this.publish("user-dolly-end");
            break;
          case 0:
            this.publish("rotate-end"), this.publish("user-rotate-end");
            break;
          case 8:
            this.publish("pedestal-end"), this.publish("user-pedestal-end");
            break;
        }
        this.state = -1, this.panDirty = false;
      }
    }, "onMouseUp"));
    O(this, "onMouseMove", H$3((e4) => {
      if (this.enabled !== false) if (e4.preventDefault(), this.mouseToScene(e4), this.state === 0) {
        if (this.enableRotate === false) return;
        this.handleMouseMoveRotate(e4);
      } else if (this.state === 2) {
        if (this.enablePan === false) return;
        this.handleMouseMovePan();
      } else this.state === 3 ? (this.resetZoom = true, this.state = -1) : this.state === 8 && this.handleMouseMovePedestal(e4);
    }, "onMouseMove"));
    O(this, "onTouchStart", H$3((e4) => {
      if (this.enabled !== false) {
        switch (this.updateTouchOrigin(), this.touchToScene(e4), e4.touches.length) {
          case 1:
            this.enablePedestal ? (this.handleTouchStartPedestal(e4), this.state = 9) : this.enablePan && (this.handleTouchStartPan(e4), this.state = 6);
            break;
          case 2:
            this.touch.inputs = new Sx(this.touch.touches[0], this.touch.touches[1]);
            break;
          default:
            this.state = -1;
        }
        this.state;
      }
    }, "onTouchStart"));
    O(this, "onTouchMove", H$3((e4) => {
      if (this.enabled !== false) switch (this.touchToScene(e4), e4.touches.length) {
        case 2:
          e4.preventDefault(), e4.stopPropagation();
          let n5 = F$1({}, this.touch.inputs.first), i5 = F$1({}, this.touch.inputs.second), a10 = new ot$1(this.touch.touches[0].x, this.touch.touches[0].y), u6 = new ot$1(this.touch.touches[1].x, this.touch.touches[1].y);
          if (this.touch.inputs.update(this.touch.touches[0], this.touch.touches[1]), this.enableRotate && this.state === 4) this.handleTouchMoveTilt(e4);
          else if (this.state === 5) this.handleTouchMoveDolly();
          else if (this.state !== 5 && this.touch.inputs.totalDistance > 0.05) {
            let h = n5.y < a10.y && i5.y < u6.y, d = n5.y > a10.y && i5.y > u6.y;
            this.enableRotate && this.state !== 4 && (d || h) ? (this.handleTouchStartTilt(e4), this.state = 4) : (this.handleTouchStartDolly(), this.state = 5);
          }
          break;
        case 1:
          (this.enablePedestal || this.enablePan) && (e4.preventDefault(), e4.stopPropagation()), this.enablePedestal && this.state === 9 ? this.handleTouchMovePedestal(e4) : this.enablePan && this.state === 6 && this.handleTouchMovePan(e4);
          break;
        default:
          this.state = -1;
      }
    }, "onTouchMove"));
    O(this, "onTouchEnd", H$3((e4) => {
      if (this.enabled !== false) {
        switch (this.handleTouchEnd(), this.state) {
          case 2:
          case 6:
            this.publish("user-pan-end");
            break;
          case 4:
            this.publish("pan-end"), this.publish("user-tilt-end");
            break;
          case 1:
          case 5:
            this.publish("zoom-end"), this.publish("user-dolly-end");
            break;
          case 0:
            this.publish("rotate-end"), this.publish("user-rotate-end");
            break;
          case 8:
          case 9:
            this.publish("pedestal-end"), this.publish("user-pedestal-end");
            break;
        }
        e4.touches.length ? this.onTouchStart(e4) : this.state = -1;
      }
    }, "onTouchEnd"));
    O(this, "handleTouchMovePan", H$3((e4) => {
      let n5 = Object.hasOwn(e4, "x") ? new ot$1(e4.x, e4.y) : this.touch.touches[0], i5 = this.raycastToFloor(n5);
      this.coords.panEnd.set(i5.x, i5.y, 0), this.coords.panDelta.subVectors(this.coords.panEnd, this.coords.panStart), this.setPosition(this.coords.panCameraStart.x - this.coords.panDelta.x, this.coords.panCameraStart.y - this.coords.panDelta.y), this.publish("change"), this.panDirty = true;
    }, "handleTouchMovePan"));
    O(this, "handleTouchStartDolly", H$3(() => {
      let e4 = this.touch.touches[0].x - this.touch.touches[1].x, n5 = this.touch.touches[0].y - this.touch.touches[1].y;
      this.zoomStart = this.getZoomAltitude();
      let i5 = new ot$1(this.touch.touches[0].x - e4 / 2, this.touch.touches[0].y - n5 / 2);
      this.coords.floorAnchor = this.raycastToFloor(i5), this.orbit.updateMatrixWorld(), this.touch.anchor1 = new Jy2(this.touch.touches[0], this.camera, this.cameraPlane), this.touch.anchor2 = new Jy2(this.touch.touches[1], this.camera, this.cameraPlane), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("user-dolly-start"), this.publish("zoom-start"), this.publish("multi-start");
    }, "handleTouchStartDolly"));
    O(this, "handleMouseMovePan", H$3(() => {
      let e4 = this.raycastToFloor(this.coords.mouse);
      this.coords.panEnd.set(e4.x, e4.y, 0), this.coords.panDelta.subVectors(this.coords.panEnd, this.coords.panStart), this.setPosition(this.coords.panCameraStart.x - this.coords.panDelta.x, this.coords.panCameraStart.y - this.coords.panDelta.y), this.publish("change"), this.panDirty = true;
    }, "handleMouseMovePan"));
    O(this, "handleTouchStartTilt", H$3((e4) => {
      this.coords.rotateStart.set(e4.touches[1].clientX, e4.touches[1].clientY), this.publish("user-tilt-start"), this.publish("rotate-start");
    }, "handleTouchStartTilt"));
    O(this, "handleTouchMovePedestal", H$3((e4) => {
      this.handleMouseMovePedestal(e4.touches[0]);
    }, "handleTouchMovePedestal"));
    O(this, "handleTouchMoveTilt", H$3((e4) => {
      this.coords.rotateEnd.set(e4.touches[1].clientX, e4.touches[1].clientY), this.coords.rotateDelta.subVectors(this.coords.rotateEnd, this.coords.rotateStart), this.setTilt(this.getTilt() - this.coords.rotateDelta.y / this.rotateSpeed), this.coords.rotateStart.copy(this.coords.rotateEnd);
    }, "handleTouchMoveTilt"));
    O(this, "handleTouchMoveDolly", H$3(() => {
      let e4 = this.touch.inputs.first, n5 = this.touch.inputs.second;
      this.touch.anchor1.viewCoordinate = { x: e4.x, y: e4.y }, this.touch.anchor2.viewCoordinate = { x: n5.x, y: n5.y };
      let i5 = this.makeTransformFromTouchAnchors(this.touch.anchor1, this.touch.anchor2);
      i5 && this.setCameraFromTransformMatrix(i5), this.orbit.updateMatrixWorld(), this.touch.anchor1.updateAnchorState(this.camera, e4), this.touch.anchor2.updateAnchorState(this.camera, n5);
    }, "handleTouchMoveDolly"));
    O(this, "handleTouchEnd", H$3(() => {
      this.state === 4 || this.state === 5 ? this.publish("multi-end") : this.state === 6 && this.publish("pan-end"), this.panDirty = false;
    }, "handleTouchEnd"));
    O(this, "handleTouchStartPan", H$3((e4) => {
      let n5 = Object.hasOwn(e4, "x") ? new ot$1(e4.x, e4.y) : this.touch.touches[0], i5 = this.raycastToFloor(n5);
      this.coords.panStart.set(i5.x, i5.y, 0), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("user-pan-start"), this.publish("pan-start");
    }, "handleTouchStartPan"));
    O(this, "handleTouchStartPedestal", H$3((e4) => {
      this.handleMouseDownPedestal(e4.touches[0]);
    }, "handleTouchStartPedestal"));
    O(this, "onMouseDown", H$3((e4) => {
      if (this.enabled !== false) {
        if (this.mouseToScene(e4), e4.preventDefault(), this.state === 3 && this.publish("zoom-end"), e4.button === this.MOUSE_BUTTONS.ORBIT) {
          if (this.enableRotate === false) return;
          this.handleMouseDownRotate(e4), this.state = 0;
        } else e4.button === this.MOUSE_BUTTONS.PAN && (this.enablePan ? (this.handleMouseDownPan(), this.state = 2) : this.enablePedestal && (this.handleMouseDownPedestal(e4), this.state = 8));
        this.state !== -1 && this.addMouseEventListeners();
      }
    }, "onMouseDown"));
    O(this, "onMouseWheel", H$3((e4) => {
      this.enabled === false || this.enableZoom === false || this.state !== -1 && this.state !== 3 || (e4.preventDefault(), e4.stopPropagation(), this.mouseToScene(e4), this.canScrollZoom(e4) && (this.lastWheelTime = this.clock.getElapsedTime(), this.publishUserZoomEvent()), this.state !== 3 && this.canScrollZoom(e4) && (this.addMouseMoveEventListeners(), this.state = 3, this.zoomStart = this.getZoomAltitude(), this.coords.floorAnchor = this.raycastToFloor(this.coords.mouse), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("zoom-start")), this.scrollTimer != null && clearTimeout(this.scrollTimer), this.scrollTimer = setTimeout(() => {
        this.publish("zoom-end");
      }, 50), this.handleMouseWheel(e4));
    }, "onMouseWheel"));
    O(this, "handleMouseWheel", H$3((e4) => {
      if (this.publish("zoom-start"), !this.canScrollZoom(e4)) {
        this.lastWheelTime > 0 && this.publish("zoom-end"), this.lastWheelTime = 0, this.state = -1;
        return;
      }
      let n5 = this.getZoomAltitude(), i5 = n5 - LI(e4) * n5 / BI * this.zoomSpeed;
      if (this.setZoomAltitude(i5), this.enablePan) {
        let a10 = i5 / this.zoomStart;
        this.coords.panDelta.subVectors(this.coords.floorAnchor, this.coords.panCameraStart).multiplyScalar(1 - a10), this.setPosition(this.coords.panCameraStart.x + this.coords.panDelta.x, this.coords.panCameraStart.y + this.coords.panDelta.y);
      }
      this.publish("change");
    }, "handleMouseWheel"));
    O(this, "setCameraFromTransformMatrix", H$3((e4) => {
      this.orbit.updateMatrixWorld();
      let n5 = new Ze$1();
      n5.setFromRotationMatrix(e4, "ZYX");
      let i5 = (e4.elements[14] - this.cameraPlane.position.z) / Math.cos(n5.x), a10 = n5.z, u6 = new I$1(0, 0, 1);
      u6.applyEuler(n5), u6.setLength(i5);
      let h = new I$1();
      h.setFromMatrixPosition(e4), h.sub(u6), this.enablePan && this.setPosition(h.x, h.y), this.enableZoom && this.setZoomAltitude(i5), this.enableRotate && this.setRotation(-a10);
    }, "setCameraFromTransformMatrix"));
    O(this, "makeTransformFromTouchAnchors", H$3((e4, n5) => {
      this.orbit.updateMatrixWorld(), this.camera.updateProjectionMatrix();
      let i5 = this.camera.projectionMatrix.clone(), a10 = e4.worldCoordinate, u6 = n5.worldCoordinate, h = e4.reUnproject(), d = n5.reUnproject();
      if (!h || !d || !a10 || !u6) return null;
      let m5 = e4.viewCoordinate, v3 = n5.viewCoordinate, x2 = u6.x - a10.x, S4 = u6.y - a10.y, I3 = Math.atan2(S4, x2), w3 = d.x - h.x, E4 = d.y - h.y, T3 = Math.atan2(E4, w3), D4 = VO(I3, T3), A3 = new Vt$2();
      A3.makeRotationZ(-D4);
      let L3 = A3.clone();
      L3.multiply(e4.snapHolderMatrix);
      let B3 = H$3((Ai2, Hn2, Ni2) => Ai2.elements[(Hn2 - 1) * 4 + Ni2 - 1], "m"), j3 = B3(i5, 1, 1) * B3(L3, 1, 1) - m5.x * B3(i5, 3, 4) * B3(L3, 3, 1), W4 = B3(i5, 1, 1) * B3(L3, 1, 2) - m5.x * B3(i5, 3, 4) * B3(L3, 3, 2), $5 = B3(i5, 1, 1) * B3(L3, 1, 3) - m5.x * B3(i5, 3, 4) * B3(L3, 3, 3), F3 = a10.x * j3 + a10.y * W4 + a10.z * $5, J4 = B3(i5, 2, 2) * B3(L3, 2, 1) - m5.y * B3(i5, 3, 4) * B3(L3, 3, 1), ot2 = B3(i5, 2, 2) * B3(L3, 2, 2) - m5.y * B3(i5, 3, 4) * B3(L3, 3, 2), K4 = B3(i5, 2, 2) * B3(L3, 2, 3) - m5.y * B3(i5, 3, 4) * B3(L3, 3, 3), H5 = a10.x * J4 + a10.y * ot2 + a10.z * K4, _t2 = B3(i5, 1, 1) * B3(L3, 1, 1) - v3.x * B3(i5, 3, 4) * B3(L3, 3, 1), ct2 = B3(i5, 1, 1) * B3(L3, 1, 2) - v3.x * B3(i5, 3, 4) * B3(L3, 3, 2), ft2 = B3(i5, 1, 1) * B3(L3, 1, 3) - v3.x * B3(i5, 3, 4) * B3(L3, 3, 3), mt2 = u6.x * _t2 + u6.y * ct2 + u6.z * ft2, St2 = B3(i5, 2, 2) * B3(L3, 2, 1) - v3.y * B3(i5, 3, 4) * B3(L3, 3, 1), dt2 = B3(i5, 2, 2) * B3(L3, 2, 2) - v3.y * B3(i5, 3, 4) * B3(L3, 3, 2), xt2 = B3(i5, 2, 2) * B3(L3, 2, 3) - v3.y * B3(i5, 3, 4) * B3(L3, 3, 3), q4 = u6.x * St2 + u6.y * dt2 + u6.z * xt2, ee2 = Math.abs(_t2 - j3), Gt2 = Math.abs(ct2 - W4), Kt2 = Math.abs(ft2 - $5), It2 = Math.abs(_t2 - J4), ie2 = Math.abs(ct2 - ot2), vr2 = Math.abs(ft2 - K4), Qe2 = Math.abs(St2 - j3), Nt2 = Math.abs(dt2 - W4), At2 = Math.abs(xt2 - $5), Ct2 = Math.abs(St2 - J4), _e3 = Math.abs(dt2 - ot2), de2 = Math.abs(xt2 - K4), qr2 = Math.min(ee2 + Gt2 + Kt2, It2 + ie2 + vr2), me2 = Math.min(Qe2 + Nt2 + At2, Ct2 + _e3 + de2);
      qr2 < me2 && (_t2 = St2, ct2 = dt2, ft2 = xt2, mt2 = q4);
      let Se2 = J4 * $5 - j3 * K4, br2 = ot2 * $5 - W4 * K4, Wr2 = H5 * $5 - F3 * K4, $i2 = _t2 * K4 - J4 * ft2, Yt2 = ct2 * K4 - ot2 * ft2, mr2 = mt2 * K4 - H5 * ft2, co2 = (mr2 * br2 - Wr2 * Yt2) / ($i2 * br2 - Se2 * Yt2), Ji2 = (mr2 * Se2 - Wr2 * $i2) / (Yt2 * Se2 - br2 * $i2), po2 = ot2 * j3 - W4 * J4, En2 = K4 * j3 - $5 * J4, wt2 = H5 * j3 - F3 * J4, Hs3 = ct2 * J4 - ot2 * _t2, Zo2 = ft2 * J4 - K4 * _t2, ho2 = ((mt2 * J4 - H5 * _t2) * po2 - wt2 * Hs3) / (Zo2 * po2 - En2 * Hs3), Pa2 = L3.clone();
      return Pa2.elements[12] = co2, Pa2.elements[13] = Ji2, Pa2.elements[14] = ho2, ho2 > 0 ? Pa2 : null;
    }, "makeTransformFromTouchAnchors"));
    O(this, "updateTouchOrigin", H$3(() => {
      let e4 = this.renderer.domElement;
      this.touch.origin.offsetLeft = e4.getBoundingClientRect().left, this.touch.origin.offsetTop = e4.getBoundingClientRect().top;
    }, "updateTouchOrigin"));
    O(this, "touchToScene", H$3((e4) => {
      this.touch.touches = [];
      for (let n5 = 0, i5 = e4.touches.length; n5 < i5; n5++) {
        let a10 = e4.touches[n5], u6 = jO(a10, this.touch.origin);
        this.touch.touches.push(new ot$1(u6.x / this.renderer.domElement.width * this.rendererState.pixelRatio * 2 - 1, -(u6.y / this.renderer.domElement.height * this.rendererState.pixelRatio) * 2 + 1));
      }
      this.coords.mouse = this.touch.touches[0];
    }, "touchToScene"));
    O(this, "canScrollZoom", H$3((e4) => {
      let n5 = LI(e4), i5 = this.getZoomAltitude();
      return !(n5 < 0 && i5 === this.getZoomScaledMax() || n5 > 0 && i5 === this.getZoomScaledMin());
    }, "canScrollZoom"));
    O(this, "mouseToScene", H$3((e4) => {
      let n5 = this.getMousePos(e4);
      return this.coords.mouse.x = n5.x / this.renderer.domElement.width * this.rendererState.pixelRatio * 2 - 1, this.coords.mouse.y = -(n5.y / this.renderer.domElement.height * this.rendererState.pixelRatio) * 2 + 1, this.coords.mouse;
    }, "mouseToScene"));
    O(this, "getMousePos", H$3((e4) => ({ x: e4.offsetX, y: e4.offsetY }), "getMousePos"));
    O(this, "handleMouseDownRotate", H$3((e4) => {
      this.coords.rotateStart.set(e4.clientX, e4.clientY), this.publish("rotate-start"), this.publish("user-rotate-start");
    }, "handleMouseDownRotate"));
    O(this, "handleMouseDownPan", H$3(() => {
      let e4 = this.raycastToFloor(this.coords.mouse);
      this.coords.panStart.set(e4.x, e4.y, 0), this.coords.panCameraStart.set(this.orbit.position.x, this.orbit.position.y, 0), this.publish("pan-start"), this.publish("user-pan-start");
    }, "handleMouseDownPan"));
    O(this, "handleMouseDownPedestal", H$3((e4) => {
      let n5 = new ot$1(e4.clientX, e4.clientY);
      this.coords.initialShiftPos = n5, this.coords.initialPedestal = this.getPedestal(), this.pedestalScaleFactor = Ci(this.camera.fov, this.renderer.domElement.clientHeight, this.getZoomAltitude()), this.publish("pedestal-start"), this.publish("user-pedestal-start");
    }, "handleMouseDownPedestal"));
    O(this, "handleMouseMovePedestal", H$3((e4) => {
      let n5 = { x: e4.clientX, y: e4.clientY }, i5 = this.coords.initialPedestal + this.pedestalScaleFactor * (n5.y - this.coords.initialShiftPos.y);
      this.stayInsideBounds && (i5 < this.minPedestal ? i5 = Math.max(i5, this.minPedestal) : i5 > this.maxPedestal && (i5 = Math.min(i5, this.maxPedestal))), i5 !== this.getPedestal() && this.setPedestal(i5, true);
    }, "handleMouseMovePedestal"));
    O(this, "handleMouseMoveRotate", H$3((e4) => {
      this.coords.rotateEnd.set(e4.clientX, e4.clientY), this.coords.rotateDelta.subVectors(this.coords.rotateEnd, this.coords.rotateStart), this.setRotation(this.getRotation() + this.coords.rotateDelta.x / this.rotateSpeed), this.setTilt(this.getTilt() - this.coords.rotateDelta.y / this.rotateSpeed), this.coords.rotateStart.copy(this.coords.rotateEnd), this.publish("change");
    }, "handleMouseMoveRotate"));
    O(this, "publishUserZoomDebounced", $t$1(() => {
      this.isUserZooming = false, this.publish("user-zoom-end");
    }, 250));
    O(this, "publishUserZoomEvent", H$3(() => {
      this.isUserZooming ? this.publishUserZoomDebounced() : (this.publish("user-zoom-start"), this.isUserZooming = true, this.publishUserZoomDebounced());
    }, "publishUserZoomEvent"));
    O(this, "setCameraMoving", H$3(() => {
      this.cameraMoving = true;
    }, "setCameraMoving"));
    O(this, "unsetCameraMoving", H$3(() => {
      this.cameraMoving = false, this.lastCameraMoveTime = Date.now();
    }, "unsetCameraMoving"));
    O(this, "setUserInteracting", H$3(() => {
      this.userInteracting = true;
    }, "setUserInteracting"));
    O(this, "unsetUserInteracting", H$3(() => {
      this.userInteracting = false;
    }, "unsetUserInteracting"));
    O(this, "publishPedestalChangeEvent", H$3((e4) => {
      this.publish("pedestal-change", { pedestal: e4, scrolledToTop: this.scrolledToTop, scrolledToBottom: this.scrolledToBottom, scrollPercent: this.scrollPercent });
    }, "publishPedestalChangeEvent"));
    O(this, "convertAltitudeToZoomLevel", H$3((e4) => {
      let [, n5] = this.center, a10 = e4 * 2 * Math.tan(Zp$2.degToRad(this.camera.fov) / 2) / this.options.canvasHeight, u6 = Math.cos(Zp$2.degToRad(n5)) * 2 * Math.PI * j / a10;
      return Zp$2.clamp(Math.log2(u6 / 512), Mx2, Tx2);
    }, "convertAltitudeToZoomLevel"));
    O(this, "convertZoomLevelToAltitude", H$3((e4) => {
      let [, n5] = this.center, i5 = Zp$2.clamp(e4, Mx2, Tx2), a10 = Math.pow(2, i5), u6 = Zp$2.clamp(n5, kI, RI), h = a10 * 512;
      return Math.cos(Zp$2.degToRad(u6)) * Math.PI * 2 * j / h * this.options.canvasHeight / 2 / Math.tan(Zp$2.degToRad(this.camera.fov) / 2);
    }, "convertZoomLevelToAltitude"));
    O(this, "completeTween", H$3((e4) => {
      e4.isPlaying() && e4.stop(), this.rendererState.internalTweenGroup.remove(e4), this.tweens.delete(e4);
    }, "completeTween"));
    O(this, "debugContainer", new fe$2());
    this.camera = e, this.renderer = i, this.rendererState = a4, this.scene = n4, this.options = u5, this.elevation = e.parent, this.orbit = this.elevation.parent, this.cameraPlane = this.createCameraPlane(), this.zoomStart = e.position.z, u5.mode !== "outdoors-overlay" && this.addEventListeners();
  }
  get maxZoomLevel() {
    return this.convertAltitudeToZoomLevel(this.minZoomAltitude);
  }
  setMaxZoomLevel(e) {
    this.minZoomAltitude = this.convertZoomLevelToAltitude(e), this.stateDirty = true;
  }
  get defaultMinZoomLevel() {
    return P(this, Ex);
  }
  get minZoomLevel() {
    return this.convertAltitudeToZoomLevel(this.maxZoomAltitude);
  }
  setMinZoomLevel(e) {
    this.maxZoomAltitude = this.convertZoomLevelToAltitude(e), this.stateDirty = true;
  }
  get scrollPercent() {
    let e = this.minPedestal, n4 = this.maxPedestal, i = this.getPedestal();
    return i = Math.min(i, n4), i = Math.max(i, e), (i - e) / (n4 - e) * 100;
  }
  get fov() {
    return this.camera.fov;
  }
  get scrolledToBottom() {
    return this.minPedestal === 0 || Math.floor(this.getPedestal()) <= this.minPedestal;
  }
  get scrolledToTop() {
    return this.maxPedestal === 0 || Math.ceil(this.getPedestal()) >= this.maxPedestal;
  }
  get center() {
    var a4, u5, h, d;
    let e = this.getPosition(), { lat: n4, lon: i } = Ti$1((u5 = (a4 = this.rendererState.center) == null ? void 0 : a4[1]) != null ? u5 : 0, (d = (h = this.rendererState.center) == null ? void 0 : h[0]) != null ? d : 0, e.x, e.y);
    return [i, n4];
  }
  setCenter(e, n4) {
    var u5, h, d, m5;
    let { x: i, y: a4 } = Mi$1((h = (u5 = this.rendererState.center) == null ? void 0 : u5[1]) != null ? h : 0, (m5 = (d = this.rendererState.center) == null ? void 0 : d[0]) != null ? m5 : 0, n4, e);
    this.setPosition(i, a4);
  }
  get isAnimating() {
    return this.rendererState.internalTweenGroup.getAll().some((e) => e.cameraAnimation);
  }
  getCameraFrameForCoordinates(e, n4) {
    let i = n4.minZoom !== void 0 ? n4.minZoom : this.minZoomAltitude, a4 = n4.maxZoom !== void 0 ? n4.maxZoom : this.maxZoomAltitude, u5 = this.options.canvasWidth, h = this.options.canvasHeight, d = this.getRotation(), m5 = this.getTilt(), v3 = this.getPosition();
    this.setRotation(n4.rotation || d, true), this.setTilt(n4.tilt || m5, true);
    let x2 = zO(e, { canvasWidth: u5, canvasHeight: h, paddingOption: n4.padding, verticalPadding: n4.verticalPadding, minZoom: i, maxZoom: a4, position: v3, camera: this.camera, orbit: this.orbit });
    return this.setRotation(d, true), this.setTilt(m5, true), { center: x2.position, zoomLevel: this.convertAltitudeToZoomLevel(x2.zoom) };
  }
  focusOn(e, n4) {
    let i = n4.curve, a4 = n4.callback, u5 = n4.cancelledCallback, h = n4.minZoom !== void 0 ? n4.minZoom : this.minZoomAltitude, d = n4.maxZoom !== void 0 ? n4.maxZoom : this.maxZoomAltitude, m5 = this.options.canvasWidth, v3 = this.options.canvasHeight, x2;
    n4.duration !== void 0 ? x2 = n4.duration : p$1.env.TESTING === "true" ? x2 = 0 : x2 = GI;
    let S4 = n4.padding, I3 = this.getRotation(), w3 = this.getTilt();
    n4.rotation != null && this.setRotation(n4.rotation), n4.tilt != null && this.setTilt(n4.tilt);
    let E4 = zO(e, { canvasHeight: v3, paddingOption: S4, canvasWidth: m5, minZoom: h, maxZoom: d, camera: this.camera, orbit: this.orbit, position: this.getPosition(), verticalPadding: n4.verticalPadding });
    this.setRotation(I3), this.setTilt(w3), this.animateCamera({ position: E4.position, tilt: n4.tilt, rotation: n4.rotation, zoom: E4.zoom }, x2, i, a4, u5, n4);
  }
  resize(e, n4) {
    this.options.canvasWidth = e, this.options.canvasHeight = n4;
  }
};
Ex = /* @__PURE__ */ new WeakMap(), H$3(Ox, "CameraSystem"), O(Ox, "CAMERA_FRAME_PADDING_SIDES", ["top", "bottom", "left", "right"]);
var sm2 = Ox;
function zO(r5, { canvasWidth: t, orbit: e, paddingOption: n4, verticalPadding: i = 0, canvasHeight: a4, minZoom: u5, maxZoom: h, camera: d, position: m5 }) {
  let v3 = { zoom: u5, position: m5 };
  if (r5.length === 0) return v3;
  for (let Se2 of sm2.CAMERA_FRAME_PADDING_SIDES) typeof n4[Se2] != "number" && (n4[Se2] = 0);
  let x2 = n4.type === "portion" ? { top: n4.top * a4, bottom: n4.bottom * a4, left: n4.left * t, right: n4.right * t } : n4;
  if (x2.left + x2.right >= t || x2.top + x2.bottom >= a4) return v3;
  e.updateMatrixWorld();
  let S4 = d.matrixWorldInverse, I3 = d.fov * (Math.PI / 180) / 2, w3 = I3, T3 = Math.atan(Math.tan(I3) * (t / a4)), D4 = new I$1(1 / 0, 1 / 0, 1 / 0), A3 = new I$1(-1 / 0, -1 / 0, -1 / 0), L3 = new Pe$3(), B3 = new I$1();
  for (let Se2 = 0, br2 = r5.length; Se2 < br2; Se2++) B3.copy(r5[Se2]), L3.expandByPoint(B3), B3.applyMatrix4(S4), D4.min(B3), A3.max(B3), B3.copy(r5[Se2]), B3.z -= i, B3.applyMatrix4(S4), D4.min(B3), A3.max(B3), B3.copy(r5[Se2]), B3.z += i, B3.applyMatrix4(S4), D4.min(B3), A3.max(B3);
  let j3 = A3.x - D4.x, W4 = A3.y - D4.y, $5 = t - x2.left - x2.right, F3 = a4 - x2.top - x2.bottom, J4 = (A3.x + D4.x) / 2, ot2 = (A3.y + D4.y) / 2, K4 = j3 / $5, H5 = W4 / F3, _t2 = u5, ct2 = h, ft2 = _t2 * Math.tan(T3) * 2, mt2 = ct2 * Math.tan(T3) * 2, St2 = ft2 / t, dt2 = mt2 / t, xt2 = Math.max(K4, H5);
  xt2 = Zp$2.clamp(xt2, St2, dt2);
  let q4 = $5 * xt2, ee2 = F3 * xt2, Gt2 = { min: { x: J4 - q4 / 2 - x2.left * xt2, y: ot2 - ee2 / 2 - x2.bottom * xt2 }, max: { x: J4 + q4 / 2 + x2.right * xt2, y: ot2 + ee2 / 2 + x2.top * xt2 } }, Kt2 = (Gt2.min.x + Gt2.max.x) / 2, It2 = (Gt2.min.y + Gt2.max.y) / 2, ie2 = L3.getCenter(new I$1()), vr2 = Math.abs(Kt2 - Gt2.min.x), Qe2 = Math.abs(It2 - Gt2.min.y), Nt2 = vr2 / Math.tan(T3), At2 = Qe2 / Math.tan(w3), Ct2 = new I$1();
  Ct2.set(Kt2, It2, A3.z + Math.max(Nt2, At2)), Ct2.applyMatrix4(d.matrixWorld);
  let _e3 = new I$1();
  _e3.set(Kt2, It2, A3.z), _e3.applyMatrix4(d.matrixWorld);
  let de2 = new I$1().subVectors(_e3, Ct2), qr2 = (ie2.z - Ct2.z) / de2.z, me2 = new I$1().copy(Ct2).add(de2.clone().multiplyScalar(qr2));
  return _e3.set(me2.x, me2.y, me2.z), Ct2.sub(_e3), { position: me2, zoom: Ct2.length() };
}
H$3(zO, "getCameraFrameForPoints");
a();
var nW = 300, Qy2, t1, jI = class jI2 {
  constructor(t) {
    O(this, "state");
    Q$3(this, Qy2, new I$1());
    Q$3(this, t1, new I$1());
    this.state = t;
  }
  update(t) {
    var i;
    let e, n4;
    this.state.cameraObject.getWorldPosition(P(this, t1));
    for (let a4 of this.state.geometry2DIdsInScene) if (e = this.state.geometry2DMap.get(a4), e && (n4 = e.components[0], n4 && "containerEl" in n4 && n4.markerContainer != null)) {
      if (n4.visibilityNeedsUpdate !== false && (n4.visibilityNeedsUpdate === "show" ? n4.canShow = true : n4.canShow = false), (n4.canShow && n4.visible === true || ((i = n4.animation) == null ? void 0 : i.pending) === true) && !n4.offscreen) if (n4.options.zIndex != null) n4.markerContainer.style.transform = "translate3D(".concat(n4.projection.x, "px, ").concat(n4.projection.y, "px, ").concat(n4.options.zIndex, "px)");
      else {
        e.object3d.getWorldPosition(P(this, Qy2));
        let u5 = P(this, t1).distanceTo(P(this, Qy2));
        n4.markerContainer.style.transform = "translate3D(".concat(n4.projection.x, "px, ").concat(n4.projection.y, "px, ").concat(-u5, "px)");
      }
      if (n4.canShow === true && n4.visible === true ? n4.markerContainer.style.pointerEvents = t ? "none" : n4.pointerEvents : n4.markerContainer.style.pointerEvents = "none", n4.currentStrategyIndex === -1 && n4.visible && n4.visibilityNeedsUpdate === "show") continue;
      n4.visibilityNeedsUpdate !== false && !n4.offscreen && (n4.visibilityNeedsUpdate === "show" && (n4.markerContainer.style.opacity = "0"), n4.animation && n4.animation.cancel(), n4.animation = n4.markerContainer.animate([{ opacity: n4.canShow && n4.visible ? "1" : "0" }], { duration: nW, easing: "ease-in-out", fill: "forwards" }), n4.visibilityNeedsUpdate = false);
    }
  }
};
Qy2 = /* @__PURE__ */ new WeakMap(), t1 = /* @__PURE__ */ new WeakMap(), H$3(jI, "DOMDrawSystem");
var Dx2 = jI;
a();
var UI = class UI2 {
  constructor() {
    O(this, "percentExpanded", 0);
    O(this, "activeId", "");
    O(this, "gap", 20);
    O(this, "dirty", true);
  }
};
H$3(UI, "StackComponent");
var Lx = UI;
a();
var zI = class zI2 extends Se$1 {
  constructor(e, n4) {
    super();
    O(this, "state");
    O(this, "dirty", true);
    O(this, "domTree");
    O(this, "observers", /* @__PURE__ */ new Map());
    O(this, "updateDimensions", H$3((e4) => {
      e4.forEach((n5) => {
        var u5;
        let a4 = (u5 = n5.target.parentElement) == null ? void 0 : u5.getAttribute("data-marker-id");
        if (a4) {
          let h = this.state.geometry2DMap.get(a4), d = h == null ? void 0 : h.components[0];
          h && d instanceof fl && (d.updateDimensions(n5.contentRect.width, n5.contentRect.height), d.collisionDirty = true);
        }
      }), this.publish("dimensions-update");
    }, "updateDimensions"));
    this.state = e, this.domTree = n4;
  }
  setupObserver() {
    var i;
    if (this.observers) {
      for (let a4 of this.observers.values()) a4.disconnect();
      this.observers.clear();
    }
    let e, n4;
    for (let a4 of this.domTree.children) {
      let u5 = a4.getAttribute("data-marker-id");
      if (u5 != null && (e = this.state.geometry2DMap.get(u5), n4 = e.components[0], (i = n4.options) != null && i.dynamicResize)) {
        let h = new ResizeObserver(this.updateDimensions);
        h.observe(n4.containerEl), this.observers.set(a4.userData.entityId, h);
      }
    }
  }
  update() {
    this.dirty && (this.setupObserver(), this.dirty = false);
  }
  destroy() {
    for (let e of this.observers.values()) e.disconnect();
    this.observers.clear();
  }
};
H$3(zI, "DOMResizeSystem");
var Ax2 = zI;
a();
var iW = 0, oW = 90;
p$1.env.NODE_ENV === "test", false;
var xu2 = { linear: Vn.Linear.None, "ease-in": Vn.Quadratic.In, "ease-out": Vn.Quadratic.Out, "ease-in-out": Vn.Quadratic.InOut }, aW = -50, $t, pe, bu, e1, r1, XI, YI = class YI2 {
  constructor(t, e, n4) {
    Q$3(this, r1);
    Q$3(this, $t);
    Q$3(this, pe);
    Q$3(this, bu);
    Q$3(this, e1);
    R$1(this, $t, t), R$1(this, pe, e), R$1(this, bu, n4), P(this, pe).cameraSystem.on("pedestal-change", ({ pedestal: i }) => {
      P(this, $t).map && (P(this, $t).map.transform.elevation = i, P(this, $t).map.transform.minElevationForCurrentTile = aW, P(this, $t).map.triggerRepaint()), P(this, pe).cameraSystem.setCameraPlaneElevation(i);
    });
  }
  get center() {
    var t, e;
    return P(this, $t).mode === "outdoors-overlay" && P(this, $t).map ? (e = (t = P(this, $t).map).getCenter) == null ? void 0 : e.call(t).toArray() : P(this, pe).cameraSystem.center;
  }
  setCenter(t) {
    var e;
    if (P(this, $t).mode === "outdoors-overlay" && P(this, $t).map) {
      (e = P(this, $t).map) == null || e.setCenter(t), P(this, pe).interactionSystem.handleHover();
      return;
    }
    P(this, pe).cameraSystem.setCenter(t[0], t[1]), P(this, pe).interactionSystem.handleHover();
  }
  get zoomLevel() {
    var t;
    return P(this, $t).mode === "outdoors-overlay" && P(this, $t).map ? (t = P(this, $t).map) == null ? void 0 : t.getZoom() : P(this, pe).cameraSystem.getZoomLevel();
  }
  setZoomLevel(t) {
    var e;
    P(this, $t).mode === "outdoors-overlay" && P(this, $t).map && ((e = P(this, $t).map) == null || e.setZoom(t)), P(this, pe).cameraSystem.setZoomLevel(Lr(t, this.minZoomLevel, this.maxZoomLevel, "zoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMinZoomLevel() and mapView.Camera.setMaxZoomLevel() to adjust limits."));
  }
  getState() {
    return { zoomLevel: this.zoomLevel, minZoomLevel: this.minZoomLevel, maxZoomLevel: this.maxZoomLevel, minPitch: this.minPitch, maxPitch: this.maxPitch, autoMinZoomLevel: this.autoMinZoomLevel, panMode: this.panMode, screenOffsets: this.insetsPadding, center: this.center, bearing: this.bearing, pitch: this.pitch, elevation: this.elevation };
  }
  get isAnimating() {
    return P(this, pe).cameraSystem.isAnimating;
  }
  cancelAnimation() {
    P(this, pe).cameraSystem.cancelAnimation();
  }
  get maxZoomLevel() {
    return P(this, pe).cameraSystem.maxZoomLevel;
  }
  get minZoomLevel() {
    return P(this, pe).cameraSystem.minZoomLevel;
  }
  setAutoMinZoomLevel(t) {
    P(this, pe).panBoundsSystem.autoMinZoomLevel = t, t && (P(this, pe).panBoundsSystem.dirty = true, P(this, pe).panBoundsSystem.update());
  }
  get autoMinZoomLevel() {
    return P(this, pe).panBoundsSystem.autoMinZoomLevel;
  }
  setMinZoomLevel(t, e = false) {
    var i;
    e && this.setAutoMinZoomLevel(false);
    let n4 = Lr(t, Fs2.MIN_MERCATOR_ZOOM_LEVEL, this.maxZoomLevel, "setMinZoomLevel was clamped. minZoomLevel must be between ".concat(Fs2.MIN_MERCATOR_ZOOM_LEVEL, " and maxZoomLevel."));
    P(this, pe).cameraSystem.setMinZoomLevel(n4), this.zoomLevel < n4 && this.setZoomLevel(n4), (i = P(this, $t).map) == null || i.setMinZoom(n4);
  }
  setMaxZoomLevel(t) {
    var n4;
    let e = Lr(t, this.minZoomLevel, Fs2.MAX_MERCATOR_ZOOM_LEVEL, "setMaxZoomLevel was clamped. maxZoomLevel must be between minZoomLevel and ".concat(Fs2.MAX_MERCATOR_ZOOM_LEVEL, "."));
    P(this, pe).cameraSystem.setMaxZoomLevel(e), this.zoomLevel > e && this.setZoomLevel(e), (n4 = P(this, $t).map) == null || n4.setMaxZoom(e);
  }
  get maxPitch() {
    var t, e;
    return P(this, $t).mode === "outdoors-overlay" && P(this, $t).map ? (e = (t = P(this, $t).map) == null ? void 0 : t.getMaxPitch) == null ? void 0 : e.call(t) : Zp$2.radToDeg(P(this, pe).cameraSystem.maxTilt);
  }
  get minPitch() {
    var t, e;
    return P(this, $t).mode === "outdoors-overlay" && P(this, $t).map ? (e = (t = P(this, $t).map) == null ? void 0 : t.getMinPitch) == null ? void 0 : e.call(t) : Zp$2.radToDeg(P(this, pe).cameraSystem.minTilt);
  }
  setMinPitch(t) {
    var n4;
    let e = Math.max(iW, t);
    (n4 = P(this, $t).map) == null || n4.setMinPitch(e), P(this, pe).cameraSystem.minTilt = Zp$2.degToRad(e);
  }
  setMaxPitch(t) {
    var n4;
    let e = Math.min(oW, t);
    (n4 = P(this, $t).map) == null || n4.setMaxPitch(e), P(this, pe).cameraSystem.maxTilt = Zp$2.degToRad(e);
  }
  get bearing() {
    var t;
    return P(this, $t).mode === "outdoors-overlay" && P(this, $t).map ? (t = P(this, $t).map) == null ? void 0 : t.getBearing() : Zp$2.radToDeg(P(this, pe).cameraSystem.getRotation());
  }
  setBearing(t) {
    var e;
    if (P(this, $t).mode === "outdoors-overlay" && P(this, $t).map) {
      (e = P(this, $t).map) == null || e.setBearing(t);
      return;
    }
    P(this, pe).cameraSystem.setRotation(Zp$2.degToRad(t));
  }
  get pitch() {
    var t;
    return P(this, $t).mode === "outdoors-overlay" && P(this, $t).map ? (t = P(this, $t).map) == null ? void 0 : t.getPitch() : Zp$2.radToDeg(P(this, pe).cameraSystem.getTilt());
  }
  setPitch(t) {
    var e;
    if (P(this, $t).mode === "outdoors-overlay" && P(this, $t).map) {
      (e = P(this, $t).map) == null || e.setPitch(t);
      return;
    }
    P(this, pe).cameraSystem.setTilt(Zp$2.degToRad(Lr(t, this.minPitch, this.maxPitch, "pitch was clamped to minPitch/maxPitch bounds. Use mapView.Camera.setMinPitch() and mapView.Camera.setMaxPitch() to adjust limits.")));
  }
  get elevation() {
    return P(this, pe).cameraSystem.getPedestal();
  }
  setElevation(t) {
    P(this, pe).cameraSystem.setPedestal(t, true);
  }
  animateElevation(t, e) {
    return P(this, e1) && P(this, e1).stop(), new Promise((n4) => {
      var i;
      P(this, pe).cameraSystem.animateCamera({ position: { z: t } }, (e == null ? void 0 : e.duration) || 300, xu2[(e == null ? void 0 : e.easing) || "ease-in-out"], n4, n4, { interruptible: (i = e == null ? void 0 : e.interruptible) != null ? i : true });
    });
  }
  get insetsPadding() {
    return P(this, bu).insetsPadding;
  }
  get panMode() {
    return P(this, pe).cameraSystem.enablePan === false && P(this, pe).cameraSystem.enablePedestal === true ? "elevation" : "default";
  }
  setPanMode(t) {
    if (t !== "default" && t !== "elevation") throw new Error("Invalid pan mode");
    t !== this.panMode && (t === "default" ? (P(this, pe).cameraSystem.enablePan = true, P(this, pe).cameraSystem.enablePedestal = false) : (P(this, pe).cameraSystem.enablePan = false, P(this, pe).cameraSystem.enablePedestal = true));
  }
  setInsetPadding(t) {
    P(this, bu).insetsPadding = Object.assign({}, P(this, bu).insetsPadding, t);
  }
  animateTo(t) {
    var u5, h, d, m5, v3, x2;
    if (P(this, $t).mode === "outdoors-overlay" && P(this, $t).map) return (x2 = P(this, $t).map) == null || x2.flyTo({ center: (u5 = t.center) != null ? u5 : this.center, zoom: (h = t.zoomLevel) != null ? h : this.zoomLevel, bearing: (d = t.bearing) != null ? d : this.bearing, pitch: (m5 = t.pitch) != null ? m5 : this.pitch, duration: (v3 = t.duration) != null ? v3 : 600 }), Promise.resolve();
    let e = t.center ? P(this, $t).convertTo3DMapPosition(t.center[1], t.center[0], t.center[2] || this.elevation) : void 0, n4 = t.zoomLevel !== void 0 ? P(this, pe).cameraSystem.convertZoomLevelToAltitude(Lr(t.zoomLevel, this.minZoomLevel, this.maxZoomLevel, "zoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMinZoomLevel() and mapView.Camera.setMaxZoomLevel() to adjust limits.")) : void 0, i = t.bearing !== void 0 ? Zp$2.degToRad(t.bearing) : void 0, a4 = t.pitch !== void 0 ? Zp$2.degToRad(Lr(t.pitch, this.minPitch, this.maxPitch, "pitch was clamped to minPitch/maxPitch bounds. Use mapView.Camera.setMinPitch() and mapView.Camera.setMaxPitch() to adjust limits.")) : void 0;
    return new Promise((S4) => {
      var I3;
      P(this, pe).cameraSystem.animateCamera({ position: e, zoom: n4, rotation: i, tilt: a4 }, t.duration || 0, xu2[t.easing || "ease-in-out"], () => {
        P(this, pe).interactionSystem.handleHover(), S4();
      }, S4, { interruptible: (I3 = t == null ? void 0 : t.interruptible) != null ? I3 : true });
    });
  }
  getCameraFrameForCoordinates(t, e) {
    let n4 = S$1(this, r1, XI).call(this, e || {}, () => Promise.resolve()), { pointCloud: i } = HO(t, P(this, $t), P(this, bu).geometry3DMap);
    if (i.length === 0) return B.error("No valid coordinates found in targets:", t), { center: this.center, zoomLevel: this.zoomLevel };
    let { center: a4, zoomLevel: u5 } = P(this, pe).cameraSystem.getCameraFrameForCoordinates(i, n4);
    return { center: P(this, $t).convert3DMapPositionToCoordinate(a4), zoomLevel: u5 };
  }
  focusOn(t, e) {
    var u5, h, d, m5;
    let { pointCloud: n4, geoBounds: i, firstPosition: a4 } = HO(t, P(this, $t), P(this, bu).geometry3DMap);
    return n4.length === 0 ? (B.error("No valid coordinates found in targets:", t), Promise.resolve()) : P(this, $t).mode === "outdoors-overlay" && P(this, $t).map ? (n4.length === 1 && a4 ? (u5 = P(this, $t).map) == null || u5.flyTo({ center: [a4[0], a4[1]], duration: (e == null ? void 0 : e.duration) || P(this, $t).map.getBearing(), animate: true, bearing: (e == null ? void 0 : e.bearing) === void 0 ? P(this, $t).map.getBearing() : e == null ? void 0 : e.bearing, pitch: (e == null ? void 0 : e.pitch) === void 0 ? P(this, $t).map.getPitch() : e == null ? void 0 : e.pitch, zoom: (e == null ? void 0 : e.maxZoomLevel) || P(this, $t).map.getMaxZoom() }) : (m5 = P(this, $t).map) == null || m5.fitBounds(i, { duration: (h = e == null ? void 0 : e.duration) != null ? h : Fs2.DEFAULT_ANIMATION_DURATION, bearing: (e == null ? void 0 : e.bearing) === void 0 ? P(this, $t).map.getBearing() : e == null ? void 0 : e.bearing, pitch: (e == null ? void 0 : e.pitch) === void 0 ? P(this, $t).map.getPitch() : e == null ? void 0 : e.pitch, maxZoom: (d = e == null ? void 0 : e.maxZoomLevel) != null ? d : P(this, $t).map.getMaxZoom() }), P(this, pe).interactionSystem.handleHover(), Promise.resolve()) : new Promise((v3) => {
      P(this, pe).cameraSystem.focusOn(n4, S$1(this, r1, XI).call(this, e || {}, v3));
    });
  }
};
$t = /* @__PURE__ */ new WeakMap(), pe = /* @__PURE__ */ new WeakMap(), bu = /* @__PURE__ */ new WeakMap(), e1 = /* @__PURE__ */ new WeakMap(), r1 = /* @__PURE__ */ new WeakSet(), XI = H$3(function(t, e) {
  var n4;
  return { minZoom: (t == null ? void 0 : t.maxZoomLevel) === void 0 ? void 0 : P(this, pe).cameraSystem.convertZoomLevelToAltitude(Lr(t.maxZoomLevel, this.minZoomLevel, this.maxZoomLevel, "maxZoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMaxZoomLevel() to adjust limits.")), maxZoom: (t == null ? void 0 : t.minZoomLevel) === void 0 ? void 0 : P(this, pe).cameraSystem.convertZoomLevelToAltitude(Lr(t.minZoomLevel, this.minZoomLevel, this.maxZoomLevel, "minZoomLevel was clamped to minZoomLevel/maxZoomLevel bounds. Use mapView.Camera.setMinZoomLevel() to adjust limits.")), padding: t != null && t.padding ? Object.assign({}, Fo, t == null ? void 0 : t.padding) : this.insetsPadding, curve: xu2[(t == null ? void 0 : t.easing) || "ease-in-out"], rotation: (t == null ? void 0 : t.bearing) === void 0 ? void 0 : Zp$2.degToRad(t.bearing), tilt: (t == null ? void 0 : t.pitch) !== void 0 ? Zp$2.degToRad(Lr(t.pitch, this.minPitch, this.maxPitch, "pitch was clamped to minPitch/maxPitch bounds. Use mapView.Camera.setMinPitch() and mapView.Camera.setMaxPitch() to adjust limits.")) : void 0, duration: t == null ? void 0 : t.duration, callback: H$3(() => {
    P(this, pe).interactionSystem.handleHover(), e();
  }, "callback"), cancelledCallback: e, interruptible: (n4 = t == null ? void 0 : t.interruptible) != null ? n4 : true, verticalPadding: t == null ? void 0 : t.verticalPadding };
}, "#convertToLegacy"), H$3(YI, "Camera");
var Nx = YI;
function HI(r5, t) {
  r5[0] = Math.min(r5[0], t[0]), r5[1] = Math.min(r5[1], t[1]), r5[2] = Math.max(r5[2], t[0]), r5[3] = Math.max(r5[3], t[1]);
}
H$3(HI, "updateBounds");
function HO(r5, t, e) {
  var h;
  let n4 = [], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a4 = null;
  if (!r5 || !Array.isArray(r5) || r5.length === 0) return { pointCloud: n4, geoBounds: i, firstPosition: a4 };
  let u5 = t.getSystems().renderSystem;
  (u5.threeDdirty || u5.twoDdirty) && t.renderSync();
  for (let d of r5) if (typeof d == "string") {
    let m5 = e.get(d);
    if (!m5) {
      B.error("Entity not found with id:", d);
      continue;
    }
    let v3 = new Pe$3();
    Jo(t, "userData" in m5 && (h = m5.userData.entityId) != null ? h : m5.id, n4, v3, m5 instanceof z ? m5.position.z : void 0);
    let x2 = t.convert3DMapPositionToCoordinate(v3.min), S4 = t.convert3DMapPositionToCoordinate(v3.max);
    HI(i, x2), HI(i, S4), a4 || (a4 = t.convert3DMapPositionToCoordinate(v3.getCenter(new I$1())));
  } else n4.push(t.convertTo3DMapPosition(d[1], d[0], d[2] || 0)), HI(i, d), a4 || (a4 = d);
  return { pointCloud: n4, geoBounds: i, firstPosition: a4 };
}
H$3(HO, "processTargets");
function lW(r5, t) {
  var n4, i, a4, u5;
  let e = [[t[0], t[1]], [t[0], t[3]], [t[2], t[3]], [t[2], t[1]], [t[0], t[1]]];
  (n4 = r5.map) != null && n4.getLayer("bounds-outline") && r5.map.removeLayer("bounds-outline"), (i = r5.map) != null && i.getSource("bounds-source") && r5.map.removeSource("bounds-source"), (a4 = r5.map) == null || a4.addSource("bounds-source", { type: "geojson", data: { type: "Feature", properties: {}, geometry: { type: "LineString", coordinates: e } } }), (u5 = r5.map) == null || u5.addLayer({ id: "bounds-outline", type: "line", source: "bounds-source", layout: {}, paint: { "line-color": "#FF0000", "line-width": 2, "line-opacity": 0.8 } });
}
H$3(lW, "drawBounds");
a();
a();
var XO = "uniform vec4 uSize;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  // Scale the position by the size of the quad\n  // and shift to top left corner for 0,0\n	vec2 transformed = position.xy * uSize.xy - vec2(1.0, -1.0);\n  // Apply width .x and height .y of image\n  transformed += vec2(uSize.x, -uSize.y);\n  // Apply left .w and top .z offset\n  transformed += vec2(uSize.w, -uSize.z) * 2.0;\n  gl_Position = vec4(transformed, 1.0, 1.0);\n}";
a();
var YO = "varying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float uOpacity;\nvoid main() {\n  #ifndef debug\n  vec4 texture = texture2D(uTexture, vUv);\n  gl_FragColor = vec4(texture.rgb, texture.a * uOpacity);\n  #else\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  #endif\n}";
a();
var qO = 4.291666666666667, WO = 15, ZO = 25, $O = 43 / 60;
a();
var JO = ["horizontal", "icon"], uW = /* @__PURE__ */ new Map([[JO[0], '<svg viewBox="0 0 206 48">\n      <path d="M27.2678 14.2261H22.3187C21.0695 14.2261 20.4695 14.7801 20.4695 15.9852V31.142L10.3966 15.5591C9.69665 14.4784 9.2475 14.2773 7.8475 14.2261H2.97462C1.67462 14.2261 1.07631 14.7801 1.07631 15.9852V44.7665C1.07631 45.9716 1.67462 46.5256 2.97462 46.5256H7.92377C9.22207 46.5256 9.82207 45.9716 9.82207 44.7665V29.6847L19.9441 45.1926C20.695 46.3244 21.095 46.5256 22.4933 46.5256H27.2933C28.5916 46.5256 29.1916 45.9716 29.1916 44.7665V15.9852C29.1407 14.7801 28.5424 14.2261 27.2678 14.2261Z"/>\n      <path d="M5.44915 10.9602C8.45863 10.9602 10.8983 8.50669 10.8983 5.48011C10.8983 2.45353 8.45863 0 5.44915 0C2.43967 0 0 2.45353 0 5.48011C0 8.50669 2.43967 10.9602 5.44915 10.9602Z"/>\n      <path d="M61.7899 25.0449C63.2306 23.1903 65.078 22.2051 67.556 22.2051C72.0526 22.2051 74.7611 25.3347 74.7611 29.4511V39.2489C74.8187 39.7125 74.5306 39.9443 74.0695 39.9443H72.5136C72.0526 39.9443 71.7645 39.7125 71.8221 39.2489V29.5091C71.8221 27.1909 69.9187 25.2187 67.4984 25.2187C65.1339 25.2187 63.2323 27.1329 63.2323 29.2773V39.2489C63.2899 39.7125 63.0018 39.9443 62.5407 39.9443H60.9831C60.5221 39.9443 60.2916 39.7125 60.2916 39.2489V29.4511C60.2916 27.1329 58.3899 25.2187 56.0255 25.2187C53.7204 25.2187 51.7594 27.075 51.7594 29.2773V39.3068C51.817 39.7705 51.5289 40.0023 51.0102 40.0023H49.5119C49.0509 40.0023 48.7628 39.7705 48.7628 39.3068V23.25C48.7051 22.7864 48.9933 22.4966 49.5119 22.4966H50.9526C51.356 22.4966 51.5289 22.6704 51.5289 23.0182V24.2352C52.7407 22.9602 54.239 22.2648 56.0255 22.2648C58.4475 22.2068 60.3492 23.192 61.7899 25.0466V25.0449ZM77.1255 31.2477C77.1255 26.3216 81.1018 22.2051 86.1187 22.2051C88.539 22.2051 90.6136 23.1903 92.3441 25.1608V23.1903C92.3441 22.7267 92.5746 22.5528 93.0357 22.5528H94.4187C94.8797 22.5528 95.1102 22.7847 95.1102 23.3062V39.3648C95.1102 39.8284 94.8797 40.0602 94.4187 40.0602H93.0357C92.5746 40.0602 92.3441 39.8284 92.3441 39.4227V37.4523C90.6712 39.3648 88.5967 40.35 86.1746 40.35C81.1018 40.2341 77.1238 36.1773 77.1238 31.2477H77.1255ZM92.1136 31.2477C92.1136 27.8284 89.4611 25.2187 86.0594 25.2187C82.7746 25.2187 80.1221 27.8864 80.1221 31.2477C80.1221 34.6687 82.7746 37.2784 86.1187 37.2784C86.9062 37.2789 87.6861 37.1232 88.4138 36.8202C89.1414 36.5173 89.8026 36.0731 90.3593 35.513C90.9161 34.9528 91.3577 34.2878 91.6587 33.556C91.9597 32.8241 92.1143 32.0397 92.1136 31.2477ZM100.992 37.3943V46.3807C101.049 46.8443 100.761 47.1341 100.298 47.1341H98.7424C98.2814 47.1341 97.9933 46.9023 97.9933 46.3807V23.1903C97.9933 22.7267 98.2238 22.4369 98.7424 22.4369H100.183C100.646 22.379 100.934 22.6687 100.934 23.0744V24.9869C102.605 23.0744 104.68 22.1472 107.044 22.1472C112.002 22.1472 116.037 26.2619 116.037 31.1898C116.037 36.1176 112.059 40.2341 107.044 40.2341C104.622 40.2341 102.603 39.3068 100.992 37.3943ZM106.987 25.2187C103.7 25.2187 101.049 27.8864 101.049 31.2477C101.049 34.6687 103.7 37.2784 107.044 37.2784C110.446 37.2784 113.039 34.6108 113.039 31.2477C113.039 27.8864 110.388 25.2187 106.987 25.2187ZM121.11 37.3943V46.3807C121.168 46.8443 120.88 47.1341 120.419 47.1341H118.861C118.4 47.1341 118.112 46.9023 118.112 46.3807V23.1903C118.112 22.7267 118.342 22.4369 118.861 22.4369H120.302C120.764 22.379 121.053 22.6687 121.053 23.0744V24.9869C122.724 23.0744 124.798 22.1472 127.163 22.1472C132.12 22.1472 136.156 26.2619 136.156 31.1898C136.156 36.1176 132.178 40.2341 127.163 40.2341C124.742 40.2341 122.781 39.3068 121.11 37.3943ZM127.105 25.2187C123.819 25.2187 121.168 27.8864 121.168 31.2477C121.168 34.6687 123.819 37.2784 127.163 37.2784C130.564 37.2784 133.158 34.6108 133.158 31.2477C133.158 27.8864 130.507 25.2187 127.107 25.2187H127.105ZM153.97 32.3506H141.054C141.342 35.2483 143.995 37.4523 147.164 37.4523C148.893 37.4523 150.393 37.0466 151.719 36.0597C152.007 35.8858 152.295 35.7699 152.353 35.7699C152.583 35.7699 152.756 35.8858 152.929 36.1773L153.505 37.1625C153.622 37.3364 153.68 37.4523 153.68 37.5682C153.68 37.8 153.507 38.0318 153.103 38.3216C151.258 39.5966 149.183 40.292 146.992 40.292C141.688 40.292 137.883 36.3511 137.883 31.2477C137.883 26.204 141.803 22.2051 146.703 22.2051C151.546 22.2051 154.717 25.7983 154.717 31.0176C154.717 31.5972 154.717 32.3506 153.968 32.3506H153.97ZM141.056 30.0324H151.72C151.432 26.8432 149.473 24.929 146.648 24.929C145.241 24.8904 143.875 25.3995 142.833 26.3501C141.791 27.3007 141.154 28.6194 141.056 30.0307V30.0324ZM156.332 31.2477C156.332 26.3216 160.31 22.2051 165.326 22.2051C167.748 22.2051 169.707 23.1324 171.32 25.0449V16.2324C171.263 15.7687 171.551 15.479 172.012 15.479H173.57C174.031 15.479 174.319 15.7108 174.319 16.2324V39.3068C174.319 39.7705 174.088 40.0023 173.57 40.0023H172.129C171.666 40.0602 171.378 39.7705 171.378 39.3648V37.3943C169.649 39.3068 167.632 40.292 165.268 40.292C160.31 40.2341 156.332 36.1773 156.332 31.2477ZM171.264 31.2477C171.264 27.8284 168.612 25.2187 165.21 25.2187C161.924 25.2187 159.273 27.8864 159.273 31.2477C159.273 34.6687 161.924 37.2784 165.268 37.2784C166.057 37.2838 166.839 37.1316 167.569 36.8304C168.299 36.5292 168.962 36.0852 169.52 35.5241C170.077 34.963 170.519 34.296 170.818 33.5619C171.117 32.8277 171.268 32.0411 171.263 31.2477H171.264ZM177.72 19.0739C177.715 18.8594 177.754 18.646 177.833 18.4468C177.912 18.2476 178.031 18.0667 178.182 17.915C178.333 17.7633 178.512 17.6439 178.71 17.5642C178.909 17.4845 179.121 17.446 179.334 17.4511C179.546 17.4507 179.756 17.4923 179.952 17.5737C180.148 17.6551 180.326 17.7746 180.476 17.9254C180.626 18.0762 180.745 18.2553 180.826 18.4523C180.907 18.6494 180.948 18.8606 180.948 19.0739C180.953 19.2884 180.914 19.5017 180.835 19.7009C180.756 19.9001 180.637 20.081 180.486 20.2327C180.335 20.3845 180.156 20.5038 179.957 20.5835C179.759 20.6633 179.547 20.7017 179.334 20.6966C178.412 20.7545 177.72 20.0591 177.72 19.0739ZM177.836 39.2489V23.1903C177.836 22.7267 178.066 22.4369 178.527 22.4369H180.083C180.544 22.4369 180.832 22.6687 180.775 23.1903V39.2489C180.832 39.7125 180.544 39.9443 180.083 39.9443H178.527C178.066 39.9443 177.836 39.7125 177.836 39.2489ZM186.944 23.0165V24.1756C188.212 22.8426 189.71 22.2051 191.497 22.2051C195.937 22.2051 198.646 25.2767 198.646 29.3932V39.2489C198.703 39.7125 198.415 39.9443 197.954 39.9443H196.398C195.936 39.9443 195.705 39.7125 195.705 39.2489V29.4511C195.705 27.1329 193.803 25.2187 191.439 25.2187C189.134 25.2187 187.175 27.075 187.175 29.2773V39.3068C187.232 39.7705 186.944 40.0023 186.424 40.0023H184.868C184.407 40.0023 184.119 39.7705 184.119 39.3068V23.1903C184.061 22.7267 184.349 22.4949 184.868 22.4949H186.309C186.712 22.4949 186.944 22.6687 186.944 23.0165Z"/>\n      <path d="M204 40C205.115 40 206 39.0857 206 38V37.9886C206 36.9029 205.126 36 204 36C202.885 36 202 36.9143 202 38V38.0114C202 39.0971 202.874 40 204 40ZM204 39.7829C202.989 39.7829 202.23 38.9829 202.23 38.0114V38C202.23 37.0286 203 36.2171 204 36.2171C205.011 36.2171 205.77 37.0171 205.77 37.9886V38C205.77 38.9714 205 39.7829 204 39.7829ZM203.218 38.9714H203.609V38.2743H204.034L204.517 38.9714H204.989L204.448 38.2057C204.724 38.1257 204.92 37.92 204.92 37.5886C204.92 37.1657 204.586 36.9486 204.138 36.9486H203.218V38.9714ZM203.609 37.9543V37.2914H204.103C204.368 37.2914 204.517 37.4057 204.517 37.6229C204.517 37.8171 204.368 37.9543 204.103 37.9543H203.609Z"/>\n    </svg>'], [JO[1], '<svg viewBox="0 0 43 60">\n      <path d="M14.0291 7.06645C14.0291 10.9691 10.8885 14.1329 7.01453 14.1329C3.14051 14.1329 0 10.9691 0 7.06645C0 3.16376 3.14051 0 7.01453 0C10.8885 0 14.0291 3.16376 14.0291 7.06645Z"/>\n      <path d="M28.7335 18.3468H35.1045C36.7455 18.3468 37.5178 19.0599 37.5821 20.6158V57.7309C37.5821 59.2868 36.8099 60 35.1367 60H28.9588C27.1569 60 26.642 59.7406 25.6767 58.282L12.6452 38.282V57.7309C12.6452 59.2868 11.8729 60 10.1997 60H3.82873C2.15554 60 1.3833 59.2868 1.3833 57.7309V20.6158C1.3833 19.0599 2.15554 18.3468 3.82873 18.3468H10.1032C11.9051 18.4116 12.4843 18.671 13.3852 20.0648L26.3524 40.162V20.6158C26.3524 19.0599 27.1247 18.3468 28.7335 18.3468Z"/>\n      <path d="M41.5 60C42.3362 60 43 59.3143 43 58.5V58.4914C43 57.6771 42.3448 57 41.5 57C40.6638 57 40 57.6857 40 58.5V58.5086C40 59.3229 40.6552 60 41.5 60ZM41.5 59.8371C40.7414 59.8371 40.1724 59.2371 40.1724 58.5086V58.5C40.1724 57.7714 40.75 57.1629 41.5 57.1629C42.2586 57.1629 42.8276 57.7629 42.8276 58.4914V58.5C42.8276 59.2286 42.25 59.8371 41.5 59.8371ZM40.9138 59.2286H41.2069V58.7057H41.5259L41.8879 59.2286H42.2414L41.8362 58.6543C42.0431 58.5943 42.1897 58.44 42.1897 58.1914C42.1897 57.8743 41.9397 57.7114 41.6034 57.7114H40.9138V59.2286ZM41.2069 58.4657V57.9686H41.5776C41.7759 57.9686 41.8879 58.0543 41.8879 58.2171C41.8879 58.3629 41.7759 58.4657 41.5776 58.4657H41.2069Z"/>\n    </svg>']]), cW = /<svg([^>]*)>/g;
function KO(r5, t, e, n4) {
  let i = uW.get(r5);
  return i ? i.replace(cW, '<svg$1 width="'.concat(e, '" height="').concat(n4, '" xmlns="http://www.w3.org/2000/svg" style="fill: ').concat(t, ';">')) : "";
}
H$3(KO, "getLogoIcon");
var QO = false, Yr, _u2, am2, hi, Eo, zh3, ga2, vl, qI = class qI2 extends Se$1 {
  constructor(e, n4, i) {
    super();
    Q$3(this, Yr, { padding: 16, scale: 1, iconOnly: false, position: "bottom-left", color: "dark", onClick: H$3(() => {
      window != null && window.open("https://www.mappedin.com");
    }, "onClick"), interactive: true, visible: true });
    Q$3(this, _u2);
    Q$3(this, am2);
    Q$3(this, hi);
    Q$3(this, Eo);
    Q$3(this, zh3);
    Q$3(this, ga2, 0);
    Q$3(this, vl, 0);
    O(this, "dirty", true);
    O(this, "getPositionAlignedCanvasCoordinates", H$3((e4, n5) => ({ "top-left": { x: 0, y: 0 }, "top-right": { x: e4, y: 0 }, "bottom-left": { x: 0, y: n5 }, "bottom-right": { x: e4, y: n5 }, center: { x: e4 / 2, y: n5 / 2 }, top: { x: e4 / 2, y: 0 }, bottom: { x: e4 / 2, y: n5 }, left: { x: 0, y: n5 / 2 }, right: { x: e4, y: n5 / 2 } })[P(this, Yr).position], "getPositionAlignedCanvasCoordinates"));
    O(this, "getPositionAlignedPadding", H$3(() => {
      var i5, a4, u5, h;
      let e4 = P(this, Yr).padding;
      if (typeof e4 == "number") return { "top-left": { x: e4, y: e4 }, "top-right": { x: -e4, y: e4 }, "bottom-left": { x: e4, y: -e4 }, "bottom-right": { x: -e4, y: -e4 }, center: { x: 0, y: 0 }, top: { x: 0, y: e4 }, bottom: { x: 0, y: -e4 }, left: { x: e4, y: 0 }, right: { x: -e4, y: 0 } }[P(this, Yr).position];
      let n5 = { top: (i5 = e4.top) != null ? i5 : 0, right: (a4 = e4.right) != null ? a4 : 0, bottom: (u5 = e4.bottom) != null ? u5 : 0, left: (h = e4.left) != null ? h : 0 };
      return { x: n5.left - n5.right, y: n5.top - n5.bottom };
    }, "getPositionAlignedPadding"));
    i && Object.entries(i).forEach(([a4, u5]) => {
      u5 !== void 0 && (P(this, Yr)[a4] = u5);
    }), R$1(this, am2, e), R$1(this, _u2, n4);
  }
  get color() {
    return P(this, Yr).color === "light" ? "white" : "#293136";
  }
  get iconName() {
    return P(this, Yr).iconOnly ? "icon" : "horizontal";
  }
  get minWidth() {
    return P(this, Yr).iconOnly ? WO : 75;
  }
  get defaultWidth() {
    return P(this, Yr).iconOnly ? ZO : 150;
  }
  get aspectRatio() {
    return P(this, Yr).iconOnly ? $O : qO;
  }
  get options() {
    return F$1({}, P(this, Yr));
  }
  set options(e) {
    var n4, i;
    R$1(this, Yr, { padding: e.padding || P(this, Yr).padding, position: e.position || P(this, Yr).position, iconOnly: e.iconOnly || P(this, Yr).iconOnly, color: e.color || P(this, Yr).color, scale: e.scale || P(this, Yr).scale, onClick: P(this, Yr).onClick, interactive: (n4 = e.interactive) != null ? n4 : P(this, Yr).interactive, visible: (i = e.visible) != null ? i : P(this, Yr).visible });
  }
  get icon() {
    return KO(this.iconName, this.color, P(this, ga2) * P(this, _u2).pixelRatio, P(this, vl) * P(this, _u2).pixelRatio);
  }
  setSize(e, n4) {
    P(this, Eo) && (P(this, Eo).uniforms.uSize.value.x = e, P(this, Eo).uniforms.uSize.value.y = n4);
  }
  setXY(e, n4) {
    P(this, Eo) && (P(this, Eo).uniforms.uSize.value.w = e, P(this, Eo).uniforms.uSize.value.z = n4);
  }
  get width() {
    return P(this, ga2);
  }
  get height() {
    return P(this, vl);
  }
  getPositionAlignedOffset(e, n4) {
    return { "top-left": { x: 0, y: 0 }, "top-right": { x: -e, y: 0 }, "bottom-left": { x: 0, y: -n4 }, "bottom-right": { x: -e, y: -n4 }, center: { x: -(e / 2), y: -(n4 / 2) }, top: { x: -(e / 2), y: 0 }, bottom: { x: -(e / 2), y: -n4 }, left: { x: 0, y: -(n4 / 2) }, right: { x: -e, y: -(n4 / 2) } }[P(this, Yr).position];
  }
  insertIntoQuadTree(e) {
    P(this, zh3) != null && typeof P(this, Yr).onClick == "function" && P(this, Yr).interactive && e.insert(P(this, zh3));
  }
  resize(e, n4) {
    if (P(this, Yr).visible !== true) return;
    let i = this.getPositionAlignedCanvasCoordinates(e, n4), a4 = this.getPositionAlignedPadding(), u5 = this.getPositionAlignedOffset(P(this, ga2), P(this, vl)), h = Math.min(e - P(this, ga2), Math.max(0, i.x + a4.x + u5.x)), d = Math.min(n4 - P(this, vl), Math.max(0, i.y + a4.y + u5.y));
    this.setSize(P(this, ga2) / e, P(this, vl) / n4), this.setXY(h / e, d / n4), R$1(this, zh3, new Nr(h, d, P(this, ga2), P(this, vl), { entityId: "watermark" }));
  }
  update() {
    this.dirty && (P(this, Yr).visible === true ? (R$1(this, ga2, Math.min(P(this, _u2).canvasWidth, Math.max(this.minWidth, this.defaultWidth * P(this, Yr).scale))), R$1(this, vl, P(this, ga2) / this.aspectRatio), kc2.getLoader().load("data:image/svg+xml;base64,".concat(btoa(this.icon)), (e) => {
      if (R$1(this, Eo, new sn$1({ uniforms: { uTexture: { value: e }, uSize: { value: new $t$3(0, 0, 0, 0) }, uOpacity: { value: 0.7 } }, vertexShader: XO, fragmentShader: YO, depthWrite: false, depthTest: false, defines: { debug: QO }, wireframe: QO, transparent: true, visible: true })), P(this, hi)) P(this, hi).visible = true, P(this, hi).material = P(this, Eo), P(this, hi).material.needsUpdate = true;
      else {
        let n4 = new Os$2(2, 2, 1, 1);
        R$1(this, hi, new ye$1(n4, P(this, Eo))), P(this, hi).position.set(0, 0, -1), P(this, hi).frustumCulled = false, P(this, hi).renderOrder = 999;
        let i = new Xi$2(1, 1, 1), a4 = new ye$1(i, new vs$1({ transparent: true, opacity: 0, depthTest: false, depthWrite: false }));
        a4.frustumCulled = false, a4.layers.set(1), P(this, hi).add(a4), P(this, am2).add(P(this, hi));
      }
      this.resize(P(this, _u2).canvasWidth, P(this, _u2).canvasHeight), this.publish("texture-loaded");
    })) : P(this, hi) && (P(this, hi).visible = false), this.dirty = false);
  }
  destroy() {
    P(this, hi) && (P(this, am2).remove(P(this, hi)), Jr(P(this, hi))), R$1(this, hi, void 0), P(this, Eo) && P(this, Eo).dispose(), R$1(this, Eo, void 0), R$1(this, zh3, void 0);
  }
};
Yr = /* @__PURE__ */ new WeakMap(), _u2 = /* @__PURE__ */ new WeakMap(), am2 = /* @__PURE__ */ new WeakMap(), hi = /* @__PURE__ */ new WeakMap(), Eo = /* @__PURE__ */ new WeakMap(), zh3 = /* @__PURE__ */ new WeakMap(), ga2 = /* @__PURE__ */ new WeakMap(), vl = /* @__PURE__ */ new WeakMap(), H$3(qI, "WatermarkSystem");
var kx2 = qI;
a();
var Rx = 100, fW = false, WI = class WI2 extends Se$1 {
  constructor(e, n4) {
    super();
    O(this, "currentTotalBoundingBox");
    O(this, "state");
    O(this, "cameraSystem");
    O(this, "debugMesh", null);
    O(this, "dirty", true);
    O(this, "autoMinZoomLevel", true);
    this.state = e, this.cameraSystem = n4;
  }
  update() {
    if (this.dirty) {
      this.currentTotalBoundingBox == null && (this.currentTotalBoundingBox = new Pe$3(), this.state.entityScene.children.length === 0 ? this.currentTotalBoundingBox.setFromCenterAndSize(new I$1(0, 0, 0), new I$1(Rx * 2, Rx * 2, 0)) : (this.currentTotalBoundingBox.setFromObject(this.state.entityScene), this.currentTotalBoundingBox.expandByScalar(Rx)));
      let e = new Pe$3().setFromObject(this.state.entityScene);
      this.currentTotalBoundingBox.union(e);
      let n4 = e.getSize(new I$1()), i = Math.max(n4.x, n4.y, n4.z);
      for (let u5 of this.state.geometry2DMap.values()) u5.positionDirty === true && (this.currentTotalBoundingBox.expandByPoint(u5.position), u5.positionDirty = false);
      let a4 = Fx2.copy(this.currentTotalBoundingBox).expandByScalar(Math.max(i, Rx)).getBoundingSphere(dW).radius;
      if (this.cameraSystem.panBounds = { center: this.currentTotalBoundingBox.getCenter(new I$1()), min: Fx2.min, max: Fx2.max, radius: a4 }, this.publish("update"), this.cameraSystem.dirty = true, this.dirty = false, fW) ;
    }
  }
};
H$3(WI, "PanBoundsSystem");
var Bx2 = WI, Fx2 = new Pe$3(), dW = new Ae$3();
a();
var tD = " Mappedin", mW = "https://info.mappedin.com/feedback", $I = ["top-left", "top-right", "bottom-left", "bottom-right"], gW = 640, yW = H$3(() => "<svg xmlns='http://www.w3.org/2000/svg' width='15' height='15' fill-rule='evenodd' viewBox='0 0 20 20'>\n						<circle cx='10' cy='10' r='5.9' style='fill:rgba(255,255,255,1);'/>\n						<path style='fill:rgba(0,0,0,0.7);' d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/>\n					</svg>", "getAttributionButtonIcon"), ZI = { custom: [], position: "bottom-right", feedback: true }, JI = class JI2 {
  constructor(t) {
    O(this, "controlContainerEl");
    O(this, "controlPositions");
    O(this, "compact");
    O(this, "attribContainerEl");
    O(this, "attribInnerEl");
    O(this, "attribButtonEl");
    O(this, "feedbackLinkEl");
    O(this, "attribHTML", tD);
    O(this, "customAttributions", []);
    O(this, "toggleAttribution", H$3((t5) => {
      this.attribContainerEl != null && (t5.preventDefault(), this.attribContainerEl.classList.contains("mappedin-compact") && (this.attribContainerEl.classList.contains("mappedin-compact-show") ? (this.attribContainerEl.removeAttribute("open"), this.attribContainerEl.classList.remove("mappedin-compact-show")) : (this.attribContainerEl.classList.add("mappedin-compact-show"), this.attribContainerEl.setAttribute("open", ""))));
    }, "toggleAttribution"));
    this.controlContainerEl = document.createElement("div"), this.controlContainerEl.classList.add("mappedin-control-container"), t.appendChild(this.controlContainerEl), this.controlPositions = $I.reduce((e, n4) => {
      let i = document.createElement("div");
      return i.classList.add("mappedin-ctrl-".concat(n4)), this.controlContainerEl.appendChild(i), e[n4] = i, e;
    }, {});
  }
  addAttributionControl(t = ZI) {
    var i;
    let e = t.position && $I.includes(t.position) ? t.position : ZI.position;
    this.attribContainerEl = document.createElement("details"), this.attribContainerEl.classList.add("mappedin-ctrl-attrib", "mappedin-ctrl-attrib-".concat(e)), this.attribContainerEl.open = true, this.attribContainerEl.tabIndex = 0, this.attribContainerEl.ariaLabel = "Attribution", this.controlPositions[e].appendChild(this.attribContainerEl), this.attribButtonEl = document.createElement("summary"), this.attribButtonEl.addEventListener("click", this.toggleAttribution), this.attribButtonEl.classList.add("mappedin-ctrl-attrib-button"), this.attribButtonEl.title = "Toggle attribution", this.attribButtonEl.ariaLabel = "Toggle attribution", this.attribButtonEl.tabIndex = 0, this.attribButtonEl.innerHTML = yW(), this.attribContainerEl.appendChild(this.attribButtonEl), this.attribInnerEl = document.createElement("div"), this.attribInnerEl.classList.add("mappedin-ctrl-attrib-inner"), this.attribInnerEl.innerHTML = this.attribHTML, this.attribContainerEl.appendChild(this.attribInnerEl), ((i = t.feedback) != null ? i : ZI.feedback) && (this.feedbackLinkEl = document.createElement("a"), this.feedbackLinkEl.href = mW, this.feedbackLinkEl.target = "_blank", this.feedbackLinkEl.rel = "noopener", this.feedbackLinkEl.textContent = "Provide Feedback", this.feedbackLinkEl.classList.add("mappedin-ctrl-attrib-inner"), this.feedbackLinkEl.classList.add("mappedin-ctrl-attrib-inner-bold"), this.attribContainerEl.appendChild(this.feedbackLinkEl)), t.custom && (this.customAttributions = t.custom), this.updateAttributionDisplay();
  }
  updateAttribution(t) {
    if (!t.style || !this.attribInnerEl || !this.attribContainerEl) return;
    let e = [tD], n4 = t.style.sourceCaches;
    for (let i in n4) {
      let a4 = n4[i];
      if (a4.used || a4.usedForTerrain) {
        let u5 = a4.getSource();
        u5.attribution && e.indexOf(u5.attribution) < 0 && e.push(u5.attribution);
      }
    }
    e = e.filter((i) => String(i).trim()), e = e.filter((i, a4) => {
      for (let u5 = a4 + 1; u5 < e.length; u5++) if (e[u5].indexOf(i) >= 0) return false;
      return true;
    }), this.attribHTML = e.join(" "), this.updateAttributionDisplay();
  }
  updateAttributionDisplay() {
    let t = [.../* @__PURE__ */ new Set([this.attribHTML, ...this.customAttributions])].filter(Boolean).join(" ");
    this.attribInnerEl && (this.attribInnerEl.innerHTML = t);
  }
  resizeAttribution(t) {
    this.attribContainerEl && (t <= gW || this.compact ? this.compact === false ? this.attribContainerEl.setAttribute("open", "") : !this.attribContainerEl.classList.contains("mappedin-compact") && !this.attribContainerEl.classList.contains("mappedin-attrib-empty") && (this.attribContainerEl.setAttribute("open", ""), this.attribContainerEl.classList.add("mappedin-compact", "mappedin-compact-show")) : (this.attribContainerEl.setAttribute("open", ""), this.attribContainerEl.classList.contains("mappedin-compact") && this.attribContainerEl.classList.remove("mappedin-compact", "mappedin-compact-show")));
  }
  destroyAttributionControl() {
    this.attribButtonEl && this.attribButtonEl.removeEventListener("click", this.toggleAttribution), this.attribContainerEl && (this.attribContainerEl.remove(), this.attribContainerEl = void 0, this.attribInnerEl = void 0, this.attribButtonEl = void 0);
  }
  resize(t) {
    this.resizeAttribution(t);
  }
  updateData(t) {
    this.updateAttribution(t);
  }
  destroy() {
    this.destroyAttributionControl(), this.controlContainerEl.remove(), this.compact = void 0;
  }
};
H$3(JI, "HTMLControlsSystem");
var Gx = JI;
a();
var n1, i1, KI = class KI2 {
  constructor(t, e) {
    O(this, "mesh");
    O(this, "type", "custom-geometry");
    O(this, "dirty", true);
    O(this, "feature");
    O(this, "builder");
    O(this, "outline");
    Q$3(this, n1, 1);
    O(this, "color", new Ft$3());
    Q$3(this, i1, 0);
    this.mesh = new fe(), this.feature = t, this.builder = e;
  }
  get visible() {
    return this.mesh.visible;
  }
  set visible(t) {
    this.mesh.visible = t;
  }
  set opacity(t) {
    R$1(this, n1, t);
  }
  get opacity() {
    return P(this, n1);
  }
  setColor(t) {
    this.color.set(t);
  }
  get position() {
    var t;
    return (t = this.mesh) == null ? void 0 : t.position;
  }
  get altitude() {
    return P(this, i1);
  }
  set altitude(t) {
    this.mesh && (this.mesh.position.z = t, R$1(this, i1, t));
  }
  get renderOrder() {
    return this.mesh ? this.mesh.renderOrder : 0;
  }
  set renderOrder(t) {
    this.mesh && (this.mesh.renderOrder = t);
  }
};
n1 = /* @__PURE__ */ new WeakMap(), i1 = /* @__PURE__ */ new WeakMap(), H$3(KI, "CustomGeometryComponent");
var lm = KI;
a();
var QI = class QI2 {
  constructor(t, e) {
    O(this, "state");
    O(this, "convertTo3DMapPosition");
    this.state = t, this.convertTo3DMapPosition = e;
  }
  update() {
    let t, e;
    for (let n4 of this.state.geometry3DIdsInScene) {
      let i = this.state.geometry3DMap.get(n4);
      (i == null ? void 0 : i.type) === "custom-geometry" && (t = i.components[0], e = i.components[1], t.dirty && e.visible !== false && (t.position.copy(this.convertTo3DMapPosition(t.feature.geometry.coordinates[1], t.feature.geometry.coordinates[0], e.altitude)), t.builder.setup(t.mesh), t.mesh.traverse((a4) => {
        a4.userData = { entityId: n4, type: "custom-geometry" };
      }), t.dirty = false), e.visible !== false && t.builder.update(t.mesh));
    }
  }
};
H$3(QI, "CustomGeometrySystem");
var Vx = QI;
a();
a();
function eD(r5) {
  return r5.children.some((t) => t.userData.isOutline);
}
H$3(eD, "hasOutline");
function jx(r5, t, e, n4) {
  let a4 = r5.getAttribute("position").array, u5 = -1 / 0;
  for (let h = 0; h < t.count; h++) {
    let m5 = (t.start + h) * 3, v3 = a4[m5 + 2];
    u5 = Math.max(u5, v3);
  }
  for (let h = 0; h < t.count; h++) {
    let m5 = (t.start + h) * 3, v3 = a4[m5 + 2];
    Math.abs(v3 - u5) < 1e-4 ? a4[m5 + 2] = Math.max(e + n4, 2e-4 + n4) : a4[m5 + 2] = n4;
  }
  r5.attributes.position.needsUpdate = true;
}
H$3(jx, "updateBufferGeometryHeight");
a();
function tM(r5) {
  var m5, v3;
  let t = new pe$3(), e = (m5 = r5.mesh) == null ? void 0 : m5.geometry;
  if (!e || !((v3 = r5.batchedProps) != null && v3.range)) return;
  let n4 = r5.batchedProps.range, i = n4.start, a4 = n4.count, u5 = e.getAttribute("position");
  if (u5) {
    let x2 = new Float32Array(a4 * 3);
    for (let S4 = 0; S4 < a4; S4++) {
      let I3 = i + S4;
      x2[S4 * 3] = u5.array[I3 * 3], x2[S4 * 3 + 1] = u5.array[I3 * 3 + 1], x2[S4 * 3 + 2] = u5.array[I3 * 3 + 2];
    }
    t.setAttribute("position", new ve$3(x2, 3));
  }
  let h = e.getAttribute("normal");
  if (h) {
    let x2 = new Float32Array(a4 * 3);
    for (let S4 = 0; S4 < a4; S4++) {
      let I3 = i + S4;
      x2[S4 * 3] = h.array[I3 * 3], x2[S4 * 3 + 1] = h.array[I3 * 3 + 1], x2[S4 * 3 + 2] = h.array[I3 * 3 + 2];
    }
    t.setAttribute("normal", new ve$3(x2, 3));
  }
  let d = e.getAttribute("uv");
  if (d) {
    let x2 = new Float32Array(a4 * 2);
    for (let S4 = 0; S4 < a4; S4++) {
      let I3 = i + S4;
      x2[S4 * 2] = d.array[I3 * 2], x2[S4 * 2 + 1] = d.array[I3 * 2 + 1];
    }
    t.setAttribute("uv", new ve$3(x2, 2));
  }
  if (e.index) {
    let x2 = e.index, S4 = new Uint32Array(a4);
    for (let I3 = 0; I3 < a4; I3++) S4[I3] = x2.array[i + I3];
    t.setIndex(new ve$3(S4, 1));
  }
  return t;
}
H$3(tM, "extractBufferGeometryFromBatchedGeometry");
function rD(r5, t) {
  let e = tM(r5);
  if (!e || !r5.mesh) return;
  r5.mesh.deleteInstance(r5.instanceIndex), r5.mesh.optimize();
  let n4 = t.addGeometry(e);
  t.addInstance(n4);
  let i = t.getGeometryIdAt(n4), a4 = t.getGeometryRangeAt(i);
  return a4 && r5.batchedProps && (r5.batchedProps.range = a4), e.dispose(), n4;
}
H$3(rD, "transferGeometryToNewBatchedMesh");
var xW = 80, Hh3, um2, zx, Hx, eM = class eM2 {
  constructor(t) {
    O(this, "rendererState");
    O(this, "outlineOpacitiesDirty", true);
    Q$3(this, Hh3, true);
    Q$3(this, um2, -1 / 0);
    Q$3(this, zx, /* @__PURE__ */ new Map());
    Q$3(this, Hx, new Ts$2({ vertexColors: true, linewidth: 1, transparent: true, opacity: 1, side: Sn$2 }));
    this.rendererState = t;
  }
  get geometries3DDirty() {
    return P(this, Hh3);
  }
  set geometries3DDirty(t) {
    R$1(this, Hh3, t);
  }
  update(t, e = true) {
    let n4;
    if (this.geometries3DDirty) {
      for (let a4 of this.rendererState.geometry3DIdsInScene) {
        let u5 = this.rendererState.geometry3DMap.get(a4);
        if (u5 instanceof M && u5.components[0].outline && !eD(u5) && u5.userData.entities3D.size > 0) {
          let h = [];
          for (let w3 of u5.userData.entities3D.values()) {
            let E4 = this.rendererState.geometry3DMap.get(w3);
            if (E4 instanceof oe && E4.type === "geometry" && E4.components[3] && E4.components[3].dirty === true && E4.components[0].material != null) {
              let T3 = E4.components[0].geometry, D4 = false;
              T3 || (T3 = tM(E4.components[0]), D4 = true), h.push([E4.components[3], new bl$2(T3, xW)]), D4 && (T3 == null || T3.dispose(), T3 = void 0);
            }
          }
          if (h.length === 0) continue;
          let d = R(h.map((w3) => w3[1]), false);
          if (d == null) continue;
          let m5 = d.getAttribute("position"), v3 = new Float32Array(m5.count * 4), x2 = new ve$3(v3, 4);
          d.setAttribute("color", x2);
          let S4 = 0;
          for (let w3 = 0; w3 < h.length; w3++) {
            let [E4, T3] = h[w3], D4 = T3.getAttribute("position").count;
            E4.edgeColors = x2, E4.geometry = d, E4.ranges = { count: D4, start: S4 }, S4 += D4, T3.dispose();
          }
          let I3 = new qr(d, P(this, Hx));
          I3.userData.isOutline = true, u5.add(I3);
        }
      }
      R$1(this, Hh3, false), this.outlineOpacitiesDirty = true;
    }
    for (let a4 of this.rendererState.geometry3DIdsInScene) {
      let u5 = this.rendererState.geometry3DMap.get(a4);
      if (u5 instanceof oe && u5.type === "geometry" && u5.components[3] && u5.components[3].dirty === true && u5.components[0].material != null && u5.parentObject3D instanceof M) {
        let h = u5.components[3].geometry;
        if (!h) continue;
        let d = u5.components[3];
        if (!d) continue;
        let m5 = d.edgeColors;
        if (!m5 || !d.ranges) continue;
        let v3 = new Ft$3(d.color);
        for (let I3 = 0; I3 < d.ranges.count; I3++) {
          let w3 = d.ranges.start + I3;
          m5.setXYZ(w3, v3.r, v3.g, v3.b);
        }
        let x2 = u5.components[1].height, S4 = u5.components[1].altitude;
        jx(h, d.ranges, x2, S4), h.attributes.color.needsUpdate = true, h.computeBoundingSphere(), d.dirty = false;
      }
    }
    let i = e ? nn(t, 16, 19, 0, 1) : P(this, um2);
    if ((i !== P(this, um2) || this.outlineOpacitiesDirty) && this.rendererState.geometry3DIdsInScene.size > 0) {
      for (let a4 of this.rendererState.geometry3DIdsInScene) if (n4 = this.rendererState.geometry3DMap.get(a4), (n4 == null ? void 0 : n4.type) === "geometry" && n4.components[0] instanceof mt) {
        let u5 = n4.components[3];
        if (u5 && u5.edgeColors && u5.geometry) {
          let h = u5.visible, d = Math.min(i, h ? n4.components[1].opacity * Oi$1(n4) : 0);
          if (u5.currentOpacity !== d) {
            for (let m5 = 0; m5 < u5.ranges.count; m5++) {
              let v3 = u5.ranges.start + m5;
              u5.edgeColors.setW(v3, d);
            }
            u5.geometry.attributes.color.needsUpdate = true;
          }
        }
      }
    }
    R$1(this, um2, i), R$1(this, Hh3, false), this.outlineOpacitiesDirty = false;
  }
  destroy() {
    P(this, zx).clear();
  }
};
Hh3 = /* @__PURE__ */ new WeakMap(), um2 = /* @__PURE__ */ new WeakMap(), zx = /* @__PURE__ */ new WeakMap(), Hx = /* @__PURE__ */ new WeakMap(), H$3(eM, "OutlineInterpolationSystem");
var Ux = eM;
a();
a();
var rM = class rM2 extends ye$1 {
  constructor() {
    super(...arguments);
    O(this, "userData", { entityId: "" });
  }
};
H$3(rM, "EntityMesh");
var Xx = rM, _W = Q.object({ flipImageToFaceCamera: Q.boolean().optional(), url: Q.string() }), CW = Q.object({ type: Q.enum(["Feature"]), properties: Q.object({ width: Q.number(), height: Q.number(), rotation: Q.number().min(0).max(360).optional(), verticalOffset: Q.number().optional() }), geometry: nm2 });
function nD(r5, t, e) {
  Q.union([Q.number(), Q.string()]).parse(r5), CW.parse(t), _W.parse(e);
}
H$3(nD, "validateImage");
var nM = class nM2 {
  constructor(t) {
    O(this, "mesh", new fe());
    O(this, "imageMesh");
    O(this, "outline");
    O(this, "type", "image");
    O(this, "instanceIndex", -1);
    O(this, "geometry");
    O(this, "material");
    O(this, "feature");
    O(this, "position", new I$1());
    this.feature = t;
  }
  get visible() {
    var t, e;
    return (e = (t = this.mesh) == null ? void 0 : t.visible) != null ? e : false;
  }
  set visible(t) {
    this.mesh && (this.mesh.visible = t);
  }
};
H$3(nM, "ImageComponent");
var Yx = nM;
a();
function iM(r5, t) {
  return { x: r5.x * Math.cos(t) - r5.y * Math.sin(t), y: r5.x * Math.sin(t) + r5.y * Math.cos(t) };
}
H$3(iM, "rotatePoint");
function SW(r5, t) {
  return r5.map((e) => iM(e, t));
}
H$3(SW, "rotatePoints");
function IW(r5) {
  let t = 1 / 0, e = 1 / 0, n4 = -1 / 0, i = -1 / 0;
  for (let a4 of r5) t = Math.min(t, a4.x), e = Math.min(e, a4.y), n4 = Math.max(n4, a4.x), i = Math.max(i, a4.y);
  return { minX: t, minY: e, maxX: n4, maxY: i };
}
H$3(IW, "getBounds");
function MW(r5, t) {
  let e = false;
  for (let n4 = 0, i = t.length - 1; n4 < t.length; i = n4++) {
    let a4 = t[n4].x, u5 = t[n4].y, h = t[i].x, d = t[i].y;
    u5 > r5.y != d > r5.y && r5.x < (h - a4) * (r5.y - u5) / (d - u5) + a4 && (e = !e);
  }
  return e;
}
H$3(MW, "pointInPolygon");
function iD(r5, t, e, n4, i) {
  for (let a4 = 0; a4 < i; a4++) for (let u5 = 0; u5 < n4; u5++) if (r5[e + a4][t + u5] !== 1) return false;
  return true;
}
H$3(iD, "isValidRectangle");
function TW(r5, t, e) {
  let n4 = r5.maxX - r5.minX, i = r5.maxY - r5.minY, a4, u5, h = F$1({}, r5);
  return n4 / i > t ? (u5 = i / e, a4 = u5 * t, h.minX += (n4 - a4 * e) / 2) : (a4 = n4 / e, u5 = a4 / t, h.minY += (i - u5 * e) / 2), { dx: a4, dy: u5, gridBounds: h };
}
H$3(TW, "calculateGridDimensions");
function wW(r5, t, e, n4, i) {
  let a4 = Array(e).fill(0).map(() => Array(e).fill(0));
  for (let u5 = 0; u5 < e; u5++) for (let h = 0; h < e; h++) {
    let d = { x: t.minX + h * n4, y: t.minY + u5 * i };
    MW(d, r5) && (a4[u5][h] = 1);
  }
  return a4;
}
H$3(wW, "createAndFillGrid");
function PW(r5, t) {
  let e = Array(t).fill(0).map(() => Array(t).fill(0));
  for (let n4 = 0; n4 < t; n4++) for (let i = 0; i < t; i++) if (r5[n4][i] === 1) {
    let a4 = 0;
    for (let u5 = 1; u5 <= Math.min(t - i, t - n4) && iD(r5, i, n4, u5, u5); u5++) a4 = u5;
    e[n4][i] = a4;
  }
  return e;
}
H$3(PW, "calculateRectSizes");
function EW(r5, t, e, n4, i, a4) {
  let u5 = 0, h = 0, d = 0;
  for (let m5 = 0; m5 < n4; m5++) for (let v3 = 0; v3 < n4; v3++) if (r5[m5][v3] === 1) {
    let x2 = Math.pow(t[m5][v3], 2), S4 = e.minX + v3 * i, I3 = e.minY + m5 * a4;
    u5 += x2, h += S4 * x2, d += I3 * x2;
  }
  return { x: h / u5, y: d / u5 };
}
H$3(EW, "calculatePolygonCenter");
function OW(r5, t, e, n4, i, a4, u5) {
  let h = -1 / 0, d = null, m5 = r5.length, v3 = Math.sqrt(Math.pow(t.maxX - t.minX, 2) + Math.pow(t.maxY - t.minY, 2));
  for (let x2 = 0; x2 < m5; x2++) for (let S4 = 0; S4 < m5; S4++) if (r5[x2][S4] === 1) for (let I3 = 1; I3 <= m5 - S4; I3++) {
    let w3 = I3;
    if (!(w3 > m5 - x2) && iD(r5, S4, x2, I3, w3)) {
      let E4 = I3 * w3, T3 = t.minX + (S4 + I3 / 2) * e, D4 = t.minY + (x2 + w3 / 2) * n4, A3 = { x: T3, y: D4 }, B3 = Math.sqrt(Math.pow(A3.x - i.x, 2) + Math.pow(A3.y - i.y, 2)) / v3, j3 = E4 * (1 - a4) - B3 * a4 * E4;
      j3 > h && (h = j3, d = { center: A3, width: I3 * e * u5, height: I3 * n4 * u5 });
    }
  }
  return d;
}
H$3(OW, "findBestRectangle");
function oM(r5, t, e, n4 = {}) {
  let { scaleFactor: i = 0.9, centerPriority: a4 = 0.5, resolution: u5 = 100, minimumSizeRatio: h = 0.5 } = n4, d = A(e), m5 = r5.width / r5.height, v3 = SW(t, d), x2 = IW(v3), { dx: S4, dy: I3, gridBounds: w3 } = TW(x2, m5, u5), E4 = wW(v3, w3, u5, S4, I3), T3 = PW(E4, u5), D4 = EW(E4, T3, w3, u5, S4, I3), A$12 = OW(E4, w3, S4, I3, D4, a4, i);
  return !A$12 || A$12.width < r5.width * h || A$12.height < r5.height * h ? r5 : G$1(F$1({}, A$12), { center: iM(A$12.center, -d), rotation: e, polygonCenter: iM(D4, -d) });
}
H$3(oM, "findLargestInteriorRectangle");
var o1 = Math.PI * 2, DW = Math.PI / 2, LW = Math.PI * 1.5, AW = wr(DW, 2), NW = wr(LW, 2), kW = 0.01, oD = false, sM = class sM2 extends Se$1 {
  constructor(e, n4, i = 0, a4 = 0, u5 = {}) {
    super();
    O(this, "rendererState");
    O(this, "convertTo3DMapPosition");
    O(this, "initialBearing", 0);
    O(this, "naturalBearing", 0);
    O(this, "imagePlacementOptions");
    O(this, "imageLoadingCache", /* @__PURE__ */ new Map());
    this.rendererState = e, this.convertTo3DMapPosition = n4, this.initialBearing = i, this.naturalBearing = a4, this.imagePlacementOptions = u5;
  }
  createImageMesh(e, n4, i, a4 = 0, u5, h) {
    var w3, E4, T3;
    let d = { width: i.width, height: i.height, center: this.convertTo3DMapPosition(u5), rotation: (w3 = i.rotation) != null ? w3 : 0 }, m5 = (E4 = this.imagePlacementOptions.mode) != null ? E4 : "default", v3 = (() => {
      switch (m5) {
        case "fit-nearest-90":
          let D4 = (this.initialBearing - this.naturalBearing + 360) % 180;
          return D4 >= 45 && D4 <= 135 ? oM(d, h, d.rotation + 90, this.imagePlacementOptions) : d;
        case "fit-initial-bearing":
          return oM(d, h, this.initialBearing, this.imagePlacementOptions);
        case "default":
        case "none":
        default:
          return d;
      }
    })();
    let x2 = new Il$2({ transparent: true, depthWrite: false, side: cn$3 }), S4 = new Os$2(v3.width, v3.height), I3 = new Xx(S4);
    if (I3.visible = false, (T3 = this.getOrDownloadImage(n4)) == null || T3.then((D4) => {
      x2.map = D4, x2.needsUpdate = true, x2.map.colorSpace = Ve$1, I3.visible = true, this.publish("image-loaded");
    }), I3.userData.entityId = e, I3.material = x2, oD) ;
    return I3.position.set(v3.center.x, v3.center.y, a4 + kW), I3.rotation.z = (-Zp$2.degToRad(v3.rotation) + o1) % o1, I3;
  }
  getOrDownloadImage(e) {
    var n4;
    if (this.imageLoadingCache.has(e)) return (n4 = this.imageLoadingCache.get(e)) == null ? void 0 : n4.promise;
    {
      let i = new Promise((a4) => {
        kc2.getLoader().load(e, (u5) => {
          let h = this.imageLoadingCache.get(e);
          h && !h.loaded && (h.loaded = true), a4(u5);
        });
      });
      return this.imageLoadingCache.set(e, { loaded: false, promise: i }), i;
    }
  }
  flipIfNeeded(e, n4) {
    if (e.imageMesh == null) return;
    let i = -n4, a4 = e.imageMesh.rotation.z, u5 = wr((a4 - i + o1) % o1, 2);
    u5 > AW && u5 < NW && (e.imageMesh.rotation.z = (a4 + Math.PI) % o1);
  }
  update(e) {
    var u5, h, d, m5, v3;
    let n4, i, a4;
    for (let x2 of this.rendererState.geometry3DIdsInScene) if (n4 = this.rendererState.geometry3DMap.get(x2), (n4 == null ? void 0 : n4.type) === "image") {
      if (i = n4.components[0], a4 = n4.components[1], a4.url && i.imageMesh == null) {
        let S4 = this.convertTo3DMapPosition(i.feature.geometry.coordinates), I3 = { x: S4.x, y: S4.y };
        i.imageMesh = this.createImageMesh(n4.id, a4.url, i.feature.properties, i.feature.properties.verticalOffset, i.feature.geometry.coordinates, [I3]), i.mesh.add(i.imageMesh), i.position.copy(i.imageMesh.position);
      }
      i.imageMesh && a4.flipImageToFaceCamera && this.flipIfNeeded(i, e);
    } else if ((n4 == null ? void 0 : n4.type) === "geometry") {
      if (i = n4.components[0], a4 = n4.components[1], a4.showImage && ((u5 = i.feature.properties) != null && u5.image) && i.imageMesh == null && i.visible && i.mesh != null && i.mesh.parent != null && ((h = i.feature.properties) == null ? void 0 : h.image.position) != null && i.feature.geometry.coordinates != null && i.feature.geometry.coordinates.length > 0) {
        let S4 = i.feature.geometry.coordinates[0].map((w3) => {
          let E4 = this.convertTo3DMapPosition(w3);
          return { x: E4.x, y: E4.y };
        }), I3 = this.createImageMesh(x2, (d = i.feature.properties) == null ? void 0 : d.image.path, (m5 = i.feature.properties) == null ? void 0 : m5.image, a4.height, (v3 = i.feature.properties) == null ? void 0 : v3.image.position, S4);
        i.mesh.parent.add(I3), i.imageMesh = I3;
      }
      if (i.imageMesh) {
        if (!i.visible) i.imageMesh.visible = false;
        else if (a4.showImage && !i.imageMesh.visible) if (a4.url) {
          let S4 = this.imageLoadingCache.get(a4.url);
          S4 && S4.loaded && (i.imageMesh.visible = true);
        } else i.imageMesh.visible = true;
        else !a4.showImage && i.imageMesh.visible && (i.imageMesh.visible = false);
        a4.flipImageToFaceCamera && this.flipIfNeeded(i, e);
      }
    }
  }
};
H$3(sM, "ImageSystem");
var qx = sM;
a();
var RW = 250, Fc3, aM = class aM2 extends Se$1 {
  constructor(e, n4) {
    super();
    O(this, "cameraDirty", true);
    O(this, "focusablesDirty", true);
    O(this, "state");
    O(this, "camera");
    O(this, "debugEl", null);
    O(this, "raycasters", []);
    O(this, "collisions", /* @__PURE__ */ new Map());
    O(this, "focusableEntities", /* @__PURE__ */ new Set());
    O(this, "debugRaycasters", false);
    Q$3(this, Fc3);
    O(this, "update", H$3((e4 = false, n5 = Date.now()) => {
      this.focusablesDirty && this.updateFocusableEntities(), !e4 && (Date.now() - n5 > RW || (P(this, Fc3) && cancelAnimationFrame(P(this, Fc3)), R$1(this, Fc3, requestAnimationFrame(() => {
        this.updateRaf();
      }))));
    }, "update"));
    this.state = e, this.camera = n4, this.buildRaycasters();
  }
  resize() {
    this.buildRaycasters();
  }
  buildRaycasters() {
    this.debugEl && this.debugEl.remove();
    let e = new ot$1(this.state.canvasWidth / 2, this.state.canvasHeight / 2), n4 = new ot$1(e.x / 1.2, e.y / 1.2), i = new ot$1(e.x + (e.x - n4.x), n4.y), a4 = new ot$1(n4.x, e.y + (e.y - n4.y)), u5 = new ot$1(i.x, a4.y), h = new ot$1(e.x, e.y / 1.5), d = new ot$1(e.x, e.y + (e.y - h.y));
    this.debugEl = document.createElement("div"), Object.assign(this.debugEl.style, { position: "absolute", top: "0", left: "0", width: "100%", height: "100%", pointerEvents: "none" }), document.body.append(this.debugEl), this.raycasters = [e, h, d, n4, i, a4, u5].map((m5, v3) => {
      if (this.debugRaycasters) {
        let E4 = document.createElement("div");
        E4.style.position = "absolute", E4.style.top = m5.y + "px", E4.style.left = m5.x + "px", E4.style.width = "10px", E4.style.height = "10px", E4.style.backgroundColor = "red", this.debugEl.append(E4);
      }
      let x2 = m5.x / this.state.canvasWidth * 2 - 1, S4 = -(m5.y / this.state.canvasHeight) * 2 + 1, I3 = new ot$1(x2, S4), w3 = new Yl$2();
      return w3.setFromCamera(I3, this.camera), [w3, I3, v3 === 0 ? 10 : v3 < 7 ? 2 : 1];
    });
  }
  updateFocusableEntities() {
    this.focusableEntities.clear();
    let e, n4, i;
    for (let a4 of this.state.geometry3DIdsInScene) if (i = this.state.geometry3DMap.get(a4), i != null) {
      if (i.type === "group-container" && i.components[2] !== void 0 && i.components[2] instanceof vu) {
        if (n4 = i.components[2], n4.dirty === true || n4.focusMesh == null) {
          n4.focusMesh && Jr(n4.focusMesh);
          let u5 = new Pe$3();
          u5.setFromObject(i);
          let h = u5.max.x - u5.min.x, d = u5.max.y - u5.min.y, m5 = u5.max.z - u5.min.z;
          if (!isFinite(h) || !isFinite(d) || !isFinite(m5) || isNaN(h) || isNaN(d) || isNaN(m5) || h <= 0 || d <= 0 || m5 <= 0) continue;
          let v3 = new Xi$2(h, d, m5), x2 = { transparent: true, opacity: this.debugRaycasters ? 1 : 0, visible: this.debugRaycasters };
          if (this.debugRaycasters) {
            let w3 = ["red", "green", "blue", "yellow", "purple", "orange", "pink", "brown", "gray", "black"];
            x2.color = w3[Math.floor(Math.random() * w3.length)];
          }
          let S4 = new vs$1(x2), I3 = new ye$1(v3, S4);
          I3.position.set((u5.min.x + u5.max.x) / 2, (u5.min.y + u5.max.y) / 2, 0), I3.userData = { entityId: i.userData.entityId }, n4.focusMesh = I3, i.add(I3), i.components[2].dirty = false;
        }
        this.focusableEntities.add(n4.focusMesh);
      } else if (i.type === "geometry" && i.components[4] && i.components[4] instanceof vu && (e = i.components[0], n4 = i.components[4], e instanceof mt && e.geometry != null && (n4.dirty === true || n4.focusMesh == null))) {
        if (n4.focusMesh == null) {
          let u5 = new ye$1(e.geometry);
          u5.userData = { entityId: i.id }, n4.focusMesh = u5;
        }
        this.focusableEntities.add(n4.focusMesh);
      }
    }
    this.focusablesDirty = false;
  }
  updateRaf() {
    if (this.focusableEntities.size === 0) {
      this.publish("geometry-in-focus", []);
      return;
    }
    this.cameraDirty && this.raycast();
  }
  raycast() {
    this.collisions.clear();
    for (let [n4, i] of this.raycasters) n4.setFromCamera(i, this.camera);
    for (let [n4, i, a4] of this.raycasters) n4.intersectObjects(Array.from(this.focusableEntities.values())).forEach((h) => {
      var d;
      if ((h == null ? void 0 : h.object) != null && "isMesh" in h.object && (h != null && h.object.isMesh)) {
        let m5 = h.object.userData.entityId, v3 = (d = this.collisions.get(m5)) != null ? d : 0;
        this.collisions.set(m5, v3 + a4);
      }
    });
    let e = Array.from(this.collisions, ([n4, i]) => ({ entityId: n4, weight: i })).sort((n4, i) => i.weight - n4.weight).map(({ entityId: n4 }) => n4);
    this.publish("geometry-in-focus", e), this.cameraDirty = false;
  }
  showRaycasters() {
    this.debugRaycasters = true, this.buildRaycasters();
  }
  hideRaycasters() {
    this.debugRaycasters = false, this.buildRaycasters();
  }
  destroy() {
    P(this, Fc3) && cancelAnimationFrame(P(this, Fc3)), this.debugEl && this.debugEl.remove(), this.collisions.clear(), this.focusableEntities.clear(), this.raycasters = [];
  }
};
Fc3 = /* @__PURE__ */ new WeakMap(), H$3(aM, "GeometryInFocusSystem");
var Wx = aM;
a();
var sD = 20, FW = 5e3, Bs2, s1, a1, Bc2, Xh3, Yh3, $x, l1, lM = class lM2 {
  constructor(t) {
    O(this, "dirty", true);
    O(this, "map");
    O(this, "stylesheetId", "");
    O(this, "userHiddenLayers", /* @__PURE__ */ new Set());
    O(this, "hiddenLayersInStyle", /* @__PURE__ */ new Set());
    O(this, "centerPoint");
    O(this, "bbox");
    O(this, "polygons");
    Q$3(this, Bs2, null);
    Q$3(this, s1, H$3(() => {
      P(this, Bs2) && (clearTimeout(P(this, Bs2)), R$1(this, Bs2, null), this.dirty = false);
    }, "#stopTrying"));
    Q$3(this, a1, H$3(() => {
      P(this, Bs2) && (clearTimeout(P(this, Bs2)), R$1(this, Bs2, null)), R$1(this, Bs2, setTimeout(() => {
        P(this, s1).call(this);
      }, FW));
    }, "#startTrying"));
    O(this, "handleRender", H$3(async () => {
      if (!(!this.map || !this.dirty) && !(!this.hiddenLayersInStyle || this.hiddenLayersInStyle.size === 0)) {
        if (P(this, Bc2) && (P(this, $x).call(this), R$1(this, Bc2, false)), this.centerPoint) {
          let t5 = this.map.project(this.centerPoint), e = this.map.queryRenderedFeatures(t5, { layers: Array.from(this.hiddenLayersInStyle) });
          if (e.length > 0) {
            for (let n4 of e) this.expr.push(["!=", ["id"], n4.id]);
            this.expr.length > 0 && this.hiddenLayersInStyle.forEach((n4) => {
              this.map.setFilter(n4, ["all", ...this.expr]);
            }), this.expr = [], R$1(this, Bc2, false), this.dirty = false;
          }
        } else if (this.bbox && this.polygons) {
          let t5 = this.map.queryRenderedFeatures([this.map.project([this.bbox[0], this.bbox[1]]), this.map.project([this.bbox[2], this.bbox[3]])], { layers: Array.from(this.hiddenLayersInStyle) });
          if (t5.length > 0) {
            R$1(this, Bc2, true);
            for (let e = 0; e < t5.length; e += sD) {
              let n4 = t5.slice(e, e + sD);
              P(this, Xh3).push(() => {
                for (let i of n4) if (i.geometry != null && "coordinates" in i.geometry) {
                  if (this.polygons == null) return;
                  let a4;
                  if (i.geometry.type === "Polygon" ? a4 = Sn(i.geometry.coordinates) : i.geometry.type === "MultiPolygon" && (a4 = In(i.geometry.coordinates)), !a4) continue;
                  for (let u5 of this.polygons) if (Eg2(u5, a4)) {
                    this.expr.push(["!=", ["id"], i.id]);
                    continue;
                  }
                }
              });
            }
            P(this, l1).call(this);
          }
        }
      }
    }, "handleRender"));
    O(this, "expr", []);
    Q$3(this, Bc2, false);
    Q$3(this, Xh3, []);
    Q$3(this, Yh3, null);
    Q$3(this, $x, H$3(() => {
      P(this, Yh3) && (globalThis.cancelAnimationFrame(P(this, Yh3)), R$1(this, Yh3, null)), R$1(this, Xh3, []);
    }, "#cancelJobs"));
    Q$3(this, l1, H$3(() => {
      let t5 = P(this, Xh3).pop();
      typeof t5 == "function" && (t5(), P(this, Xh3).length > 0 && R$1(this, Yh3, globalThis.requestAnimationFrame(P(this, l1)))), this.expr.length > 0 && (this.hiddenLayersInStyle.forEach((e) => {
        this.map.setFilter(e, ["all", ...this.expr]);
      }), this.dirty = false), this.expr = [], R$1(this, Bc2, false), P(this, s1).call(this);
    }, "#runJobs"));
    O(this, "handleStyleChange", H$3((t5) => {
      var e, n4;
      if (this.map && t5 && t5.dataType === "style" && t5.type === "styledata" && this.userHiddenLayers.size > 0) {
        let i = (n4 = (e = t5 == null ? void 0 : t5.style) == null ? void 0 : e.stylesheet) == null ? void 0 : n4.id;
        (!i || i !== this.stylesheetId) && (this.stylesheetId = i, this.filterStylesInMap(), this.dirty = true);
      }
    }, "handleStyleChange"));
    t && (this.map = t, this.map.on("styledata", this.handleStyleChange), this.map.on("render", this.handleRender));
  }
  hideLayersUnderPoint(t, e) {
    P(this, a1).call(this), this.centerPoint = t;
    for (let n4 of e) this.userHiddenLayers.add(n4);
    this.dirty = true, this.filterStylesInMap(), this.handleRender();
  }
  hideLayersIntersectingPolygons(t, e, n4) {
    P(this, Bs2) && clearTimeout(P(this, Bs2)), P(this, a1).call(this), this.bbox = t, this.polygons = e.reduce((i, a4) => {
      if (a4.geometry.type === "Polygon") {
        let u5 = Sn(a4.geometry.coordinates);
        i.push(u5);
      } else a4.geometry.type === "MultiPolygon" && i.push(...a4.geometry.coordinates.map((u5) => Sn(u5)));
      return i;
    }, []);
    for (let i of n4) this.userHiddenLayers.add(i);
    this.dirty = true, this.filterStylesInMap(), this.handleRender();
  }
  filterStylesInMap() {
    if (this.hiddenLayersInStyle = /* @__PURE__ */ new Set(), this.map) for (let t of this.userHiddenLayers) this.map.getLayer(t) && this.hiddenLayersInStyle.add(t);
  }
  destroy() {
    this.map && (this.map.off("styledata", this.handleStyleChange), this.map.off("render", this.handleRender));
  }
};
Bs2 = /* @__PURE__ */ new WeakMap(), s1 = /* @__PURE__ */ new WeakMap(), a1 = /* @__PURE__ */ new WeakMap(), Bc2 = /* @__PURE__ */ new WeakMap(), Xh3 = /* @__PURE__ */ new WeakMap(), Yh3 = /* @__PURE__ */ new WeakMap(), $x = /* @__PURE__ */ new WeakMap(), l1 = /* @__PURE__ */ new WeakMap(), H$3(lM, "OutdoorLayers");
var Zx = lM;
a();
a();
a();
a();
var Jx = `attribute float pathDistance;
attribute vec3 pathNormal;
attribute vec3 pathTangent;

uniform vec2 uvScale;
uniform float vertexes;
uniform float complete;
uniform float nearRadius;
uniform float farRadius;
uniform float nearZoom;
uniform float farZoom;
uniform float pulse;
uniform float pulseLength;
uniform bool pathIsVertical;
uniform bool displayArrowsOnPath;
uniform vec2 cameraParameters;
uniform float flattenFactor;

varying float zoomLevel;
varying float radius;
varying vec2 fragTexcoord;
varying float fragTopTextureU;
varying float fragPathDistance;

// Map the x value from the range [xMin, xMax] to the range [yMin, yMax] using
// linear interpolation/extrapolation.
//
// This performs a pure linear mapping y = mx + b where
// 'm = (yMax - yMin) / (xMax - xMin)',
// 'b = -xMin * (yMax - yMin) / (xMax - xMin) + yMin'.
float remap(float x, float xMin, float xMax, float yMin, float yMax) {
	return (x - xMin) / (xMax - xMin) * (yMax - yMin) + yMin;
}

// Map the x value from [xMin, xMax] to the range [yMin, yMax] using linear
// interpolation, clamping result values outside [yMin, yMax].
float clampRemap(float x, float xMin, float xMax, float yMin, float yMax) {
	return clamp(remap(x, xMin, xMax, yMin, yMax), yMin, yMax);
}

void main() {
	fragPathDistance = pathDistance;

	// We can get an origin point for the cross-section of the path by
	// subtracting the surface normal times the radius, since the surface normal
	// points strictly away from the centre.
	vec3 origin = position - nearRadius * normal;

	// Inflate the path along its surface normal to increase its radius from
	// 'nearRadius' to 'farRadius' when the camera is at 'farZoom'.
	vec3 adjustedPosition = position;
	zoomLevel = clampRemap(cameraParameters.x, nearZoom, farZoom, 0.0, 1.0);
	adjustedPosition += normal * (farRadius - nearRadius) * zoomLevel;

	// Determine how far the path extends "up" or "down" in the direction of the
	// path normal.
	float height = dot(adjustedPosition - origin, pathNormal);

	// Flatten the bottom half of the path entirely so that it's flat
	// against the floor. This makes the path look nicer when it's
	// semitransparent behind opaque geometry, so you don't see it
	// peeking through.
	float desiredHeight = max(height, 0.0);

	desiredHeight = desiredHeight * flattenFactor;

	float flattenMagnitude = height - desiredHeight;
	adjustedPosition = adjustedPosition - pathNormal * flattenMagnitude;

	// Transform the vertices into NDC.
	vec4 mvPosition = modelViewMatrix * vec4(adjustedPosition, 1.0);
	gl_Position = projectionMatrix * mvPosition;

	fragTexcoord = uv;

	// Compute a texture coordinate for mapping the arrow texture to the path.
	// We don't want to use the u-value that Three.js provides, because the
	// path may end up twisting arbitrarily -- but we want the arrow texture to
	// always be on the top of the path.
	vec3 bitangent = cross(normal, pathTangent);
	fragTopTextureU = -dot(bitangent, pathNormal) * 0.5 + 0.5;

	radius = mix(nearRadius, farRadius, zoomLevel);
}
`;
a();
var uM = `#define ARROW_FADING_POINT 0.15

uniform float complete;
uniform float nearRadius;
uniform float farRadius;
uniform vec2 resolution;
uniform vec2 cameraParameters;
uniform vec3 color;
uniform float pathLength;
uniform bool showPulse;
uniform vec3 pulseColor;
uniform float pulse;
uniform float pulseLength;
uniform bool pathIsVertical;
uniform bool displayArrowsOnPath;
uniform float arrowAnimationTimer;
uniform float opacityMultiplier;
uniform bool dashed;
uniform sampler2D arrowTexture;

varying float zoomLevel;
varying float radius;
varying vec2 fragTexcoord;
varying float fragTopTextureU;
varying float fragPathDistance;

// How long the arrow should be, as a factor of pathRadius. Since we've
// mostly flattened the top of the path, values near 2.0 (the diameter)
// will probably look best.
const float arrowLength = 2.0;

// How much of a relative margin the arrow texture should have inside the
// area laid out for it. Useful to pull the arrow away from the edges of the
// path, which slope down.
const float arrowMargin = 0.1;

// How many arrow-lengths of space should be between arrows on a short path.
const float arrowSpacingOnShortPath = 6.0;

// How many arrow-lengths of space should be between arrows on a long path.
const float arrowSpacingOnLongPath = 7.5;

// How long a path must be to be considered "long", as a factor of
// the path radius.
const float longPathLength = 200.;

// How long a path must be to be considered "short", as a factor of the
// path radius.
const float shortPathLength = 75.;

// How much of the path's length the fade-in should comprise when going from
// zero opacity to full opacity.
const float completeLength = 0.1;

// Map the x value from the range [xMin, xMax] to the range [yMin, yMax] using
// linear interpolation/extrapolation.
//
// This performs a pure linear mapping 'y = mx + b' where
// 'm = (yMax - yMin) / (xMax - xMin)',
// 'b = -xMin * (yMax - yMin) / (xMax - xMin) + yMin'.
float remap(float x, float xMin, float xMax, float yMin, float yMax) {
	return (x - xMin) / (xMax - xMin) * (yMax - yMin) + yMin;
}

// Map the x value from [xMin, xMax] to the range [yMin, yMax] using linear
// interpolation, clamping result values outside [yMin, yMax].
float clampRemap(float x, float xMin, float xMax, float yMin, float yMax) {
	return clamp(remap(x, xMin, xMax, yMin, yMax), yMin, yMax);
}

void main(void) {
	// Compute the opacity of the path based on the distance from the current
	// fragment to the 'complete' value as it varies from 0.0 to 1.0.
	// Fragments that are at the 'complete' value or past it will be fully
	// transparent, while fragments that are at 'complete - completeLength'
	// or before it will be fully opaque. However, we adjust the 'complete'
	// value here so that it overshoots by one full 'completeLength', so that
	// the entire path will be opaque when the 'complete' value is at 1.0.
	float completeLocation = complete * (1.0 + completeLength);
	float completeAmount = clampRemap(
		fragPathDistance,
		completeLocation - completeLength,
		completeLocation,
		0.0,
		1.0
	);
	float opacity = 1.0 - smoothstep(0.0, 1.0, completeAmount);

	// 2020/01/09 Terence Dickson
	// When we render the background and overlay for the mapbox outdoor context
	// behind everything else in single-buffer rendering, the fact that the path
	// writes to the depth buffer means that the background and overlay will not
	// be drawn behind the path even when the path is still fading in. The effect
	// is subtle and is only visible in single-buffer rendering so this quick fix
	// prevents writes to the depth buffer for zero opacity fragments, which gets
	// rid of the most visually-offensive ghosting.
	if (opacity <= 0.0) {
		discard;
	}

	// Push in the texture coordinates so that they ramp up
	// at 'arrowMargin' instead of at zero; this remapping looks somewhat
	// like this:
	// 1 ^        ___
	//   |       /
	//   |      /
	//   |     /
	//   |    /
	//   |___/
	// 0 +---------->
	//   0   ^      1
	//       arrowMargin
	// Making the arrows narrower on the path.
	float u = fragTopTextureU;
	u = clamp(
		u * (1. / (1. - arrowMargin * 2.)) - (1. / (1. - arrowMargin * 2.) - 1.) / 2.,
		0.0,
		1.0
	);

	float arrowSpacing = clampRemap(
		pathLength,
		shortPathLength * radius,
		longPathLength * radius,
		arrowSpacingOnShortPath,
		arrowSpacingOnLongPath
	);

	// Reduce the spacing between arrows when the camera zooms out, as increasing
	// the path radius will increase the arrow size and thus be able to fit
	// fewer arrows on in total, and this secondary movement of the arrows
	// "zooming off" the end of the path is unpleasant
	float expandAmount = mix(1.0, farRadius / nearRadius, zoomLevel);
	float effectiveArrowSpacing =
		arrowSpacing * 1.0 / expandAmount +
		arrowMargin * 2.0;

	float effectiveArrowLength = arrowLength * radius * (1. - arrowMargin * 2.0);

	// Adjust the slope of the vertical texture coordinate so that it goes
	// from 0 to 1 along the length of the arrow plus the spacing between
	// arrows, and adjust its x-intercept so that one arrow moves to the
	// exact position of the next arrow as 'arrowAnimationTimer' goes
	// from 0 to 1
	float v = (
		fragTexcoord.x * (pathLength / effectiveArrowLength)
		- arrowAnimationTimer * (1. + effectiveArrowSpacing)
	);

	// Compute a "looping sawtooth" wave for determining the vertical texture
	// coordinates of the arrow texture, roughly as follows:
	// 3 ^              /
	//   |          ___/
	// 2 |         /
	//   |     ___/
	// 1 |    /
	//   |___/
	// 0 +--------------->
	//   0   ^ ^
	//   ^   |_|
	//   |   effectiveArrowLength
	//   |___|
	//   effectiveArrowSpacing
	//
	// This is effectively equivalent to this sort of sawtooth wave:
	//   ^
	// 1 |    /    /    /
	//   |___/ ___/ ___/
	// 0 +--------------->
	//
	// Causing the image of the arrow to repeat, with dead space (the bottom
	// edge of the texture stretched out) between the arrows at the provided
	// spacing. The reason why the "looping" design is preferred is because
	// it takes advantage of WebGL's 'GL_REPEAT' texture wrapping behaviour
	// to avoid the discontinuity that can end up causing visual artifacts.
	if (mod(v, (1. + effectiveArrowSpacing)) < 1.) {
		v = v - effectiveArrowSpacing * floor(v / (1. + effectiveArrowSpacing));
	} else {
		v = ceil(v / (1. + effectiveArrowSpacing));
	}

	// Use the r-component of the texture to determine whether the arrow covers
	// this fragment or not
	vec2 sampleTexcoord = vec2(u, v);
	float arrowAmount = 0.0;
	vec3 secondColor = pulseColor;

	if (displayArrowsOnPath) {
		arrowAmount = texture2D(arrowTexture, sampleTexcoord).r;
		float delta = 1.0 - abs(fragPathDistance * 2.0 - 1.0);
		secondColor = mix(color, pulseColor, 1.0 - smoothstep(ARROW_FADING_POINT, 0.0, delta));
	}

	if (dashed) {
		float dashLength = 0.1; // Adjust this value to change the dash length
		float gapLength = 0.1; // Adjust this value to change the gap length
		float totalLength = dashLength + gapLength;
		float numSegments = ceil(1.0 / totalLength);
		float adjustedTotalLength = 1.0 / numSegments;
		float adjustedDashLength = adjustedTotalLength * (dashLength / (dashLength + gapLength));
		float pattern = mod(fragPathDistance, adjustedTotalLength);
		opacity = pattern < adjustedDashLength ? 1.0 : 0.0;
	}


	if (showPulse) {
		// Add the pulse color to the path by determining how far the current fragment
		// is from 'pulse'
		float pulseLocation = remap(
		pulse,
		0.0,
		1.0,
		-pulseLength,
		1.0 + pulseLength
		);
		float pulseDistance = smoothstep(
		0.0,
		pulseLength,
		abs(fragPathDistance - pulseLocation)
		);

		// Blend the pulse color to the path based on how close this fragment is to
		// the 'pulse' value and whether it's covered by an arrow -- but if it's
		// covered by *both*, then we go back to using the regular path color
		// (making arrows look like "holes" when they're overlapping the pulse.)
		float pulseLevel = abs(1.0 - pulseDistance - arrowAmount);

		gl_FragColor = vec4(mix(color, secondColor, pulseLevel), opacity * opacityMultiplier);
	} else if (displayArrowsOnPath) {
		gl_FragColor = vec4(mix(color, pulseColor, arrowAmount), opacity * opacityMultiplier);
	} else {
		gl_FragColor = vec4(color, opacity * opacityMultiplier);
	}
	#include <colorspace_fragment>
}
`;
a();
var aD = "uniform float complete;\nuniform float nearRadius;\nuniform float farRadius;\nvarying float fragPathDistance;\nconst float completeLength = 0.1;\n\n// Map the x value from the range [xMin, xMax] to the range [yMin, yMax] using\n// linear interpolation/extrapolation.\n//\n// This performs a pure linear mapping 'y = mx + b' where\n// 'm = (yMax - yMin) / (xMax - xMin)',\n// 'b = -xMin * (yMax - yMin) / (xMax - xMin) + yMin'.\nfloat remap(float x, float xMin, float xMax, float yMin, float yMax) {\n	return (x - xMin) / (xMax - xMin) * (yMax - yMin) + yMin;\n}\n\n// Map the x value from [xMin, xMax] to the range [yMin, yMax] using linear\n// interpolation, clamping result values outside [yMin, yMax].\nfloat clampRemap(float x, float xMin, float xMax, float yMin, float yMax) {\n	return clamp(remap(x, xMin, xMax, yMin, yMax), yMin, yMax);\n}\n\nvoid main(void) {\n	// this ensures that the stencil mask moves along with the path above it, to avoid the progress bar effect\n	float completeLocation = complete * (1.0 + completeLength);\n	float completeAmount = clampRemap(\n		fragPathDistance,\n		completeLocation - completeLength,\n		completeLocation,\n		0.0,\n		1.0\n	);\n	float opacity = 1.0 - smoothstep(0.0, 1.0, completeAmount);\n\n	// 2020/01/09 Terence Dickson\n	// When we render the background and overlay for the mapbox outdoor context\n	// behind everything else in single-buffer rendering, the fact that the path\n	// writes to the depth buffer means that the background and overlay will not\n	// be drawn behind the path even when the path is still fading in. The effect\n	// is subtle and is only visible in single-buffer rendering so this quick fix\n	// prevents writes to the depth buffer for zero opacity fragments, which gets\n	// rid of the most visually-offensive ghosting.\n	if (opacity <= 0.0) {\n		discard;\n	}\n\n	gl_FragColor = vec4(0.0, 1.0, 0.0, opacity);\n}";
var lD = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAAAAAB5Gfe6AAAQkHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarZpZciQ7rkT/uYpeAicQ5HI4mr0dvOX3ATOl0li3q3SVJkUqFMEBcHc4IuX2///fcf/hK7cSXRatpZXi+cott9h5U/3j63EMPt+fL1/h+fPdeff6NnJMHNPjD2U/7+qcl183aH6eH+/PO52PN7E+B3qZ+Tlgspkjb57X1edAKT7Oh+fvrj3v6/nNdp7ftd057abHnz78npVgLGG8FF3cKSTPz2oXJFaQWuocCz9D0mhnEu8Tx54k6dexc98F77vY+f48n96HwvnyvKB8iNHzfJCvY3cj9HZF4dfM7/6QZ4j+7deb2J2z6jn7sbueC5Eq7rmpl63cd1w4GCrd2wov5Vt4r/fVeFW2OMnYIpuD13ShhUi0T8hhhR5O2Pc4w2SJOe5IuGOMM6Z7rhL+FudNSrZXOFFJz3KpkqtJ1hKn4+tawp233flmqMy8AlfGwGCBOz693Fcn/+b1OtA5Bt0QfH2NFeuKFnCWYZmzn1xFQsJ5xlRufO/LvcGNf5PYRAblhrmywe7HY4gh4Re20s1z4jrx2fkHNYKu5wCEiLmFxYREBnwJSUIJXmPUEIhjJT+dlceU4yADQSSu4A65SamQnBptbu7RcK+NEh+nkRYSIZBGSQ0EIlk5C/jRXMFQlyTZiUgRlSpNekklFymlaDGN6po0q2hR1apNe001V6mlaq211d5iS0iYtNLUtdpa651JO0N37u5c0fuII408ZJSho442+gQ+M0+ZZeqss82+4koL+q+y1K262uo7bKC085Zdtu662+4HrJ108pFTjp562umvWXtm9X3WwofM/T5r4Zk1y1i+1+mvrHFa9WWIYHIiljMyFnMg42oZANDRcuZryDla5ixnvkVIIZGsBbHkrGAZI4N5hygnvObuV+Z+mzcn+Y/yFr/LnLPU/RuZc5a6Z+Y+5+2LrK1+K0q6CTIWWkx9OggbF+zaY+1Wk/766H46wF8ONFY+O8hBMEc7oc4Vdh+8JsE+PUSrVjr70Zz1+H56PH3o9sRR1ql5Ha8bUMQxpe89Tki8Sb0tE23cw3DcfEo+ugnj2G3WEmononVfoag71pVjR+EmAE53eT5tqYfEHl/7ThMusaI+St0jktFa9gKnreiQqCNpZ2mJdSkbaiK6DrovYR4/JhJfRsx5d5EVZnEIPetHnU5KynJPTSuCPuC0lOuXH7n1DNq7DpUtHbhM5lDA0c2bnDCJoOObMnyj+aPjPwx0yiDUxKKsg35VnRnBEVhonKwK5hOk5NttUrhr2+tMOXkPJb1RZ+iAelYjL2MuO3pGRQ78GdxwOOaTAcJZcewq7ilB1RJCSozUdSEdwVJVb6asiBsHH1Bqgbiv3Cmkkis6ktVnZGRRwMNJjUA3Ao2127YWdhAIblxF51hzMcZsVZc0r0dJo5Liqfn41Q+q193SGhhkMkgaLJRNnEpqBtyVvbcVffIk+LE9QPFBTMTQe0aWkMXMnx3dy5sfHreDE60Ql50E+SqRcmfK16L2p0Ol8JFATu3qASXy7SvmiGW2cdMBxsty44CvtLogfGlv7WkCSV0WId2270EaD5Ym40cs+SAwZuNjPSTywAvEfLmzQhtLDntfCnhl/fNmUNnzyA2g76Zn0SP+c+I6bCC0FONUQ4L50e95dif+DH/m9htQjBEhPPpOjYjmm2ChbfEMIUaYtAIxmWJHlilLU8ZRs9pCsHbDpFaRgZljz2QandjDIBPZDGTuoZW1KdlYh52ALzisKJRNWSQmLAWx8iv9mGttT15bBc2oxd57bZtVF98CYtK3UH22Yd/A7WaKa+ZjNTOXEzNhMJ5kmQOvfzsbxbZALJ2xwGBjX2HFQybhi7kpbA7DVpS3RxMJwFyHwGk5gs6a4lrRHVqhYT0QTJC9UZcC9Yrelkn6yXch68NKNtG7CiU3vf/zMZAYXPWdrR9XZ/ctMV1sJQ2wJEGxzaHs7LmmHIwnUwbwnNAapBY9xhE19DNJW3ua0dDk/AjwITacR0PqZxkbyJ+E5jYbxI84x1TBE+y90hwDCYZIM0tqAKPZfCzFrbH8kYCm3eqQkZ2+2GovcL8Suokyg8yyCJes6dcouSLiNSLb0ETJU+/N/WFsBBSOXBbm9Cwp4CzlOag7ro7R2vC19nSsCPmAjIEMiobFwaoVXhjTU2XMpgEsDH/L3Sx54OCTMUSXI/IIA2V4QcLQpwVz12pInI0bY56pIQ2BSGRLL+yLfZ7JkiimbK+aepsbwRStpokx5gCqe1hjdMAwcINbkk5jmedrNRAG5pUXPe0sZIoXy1h7lSDxApzheg24JeDNtDS1oBDBUC4iWZFilBPhZx0Kqx2lihpbG9q4sYidksCN4yRYhNM4nxfBbTi4E3AT6B3igbvs9Gv8ZkHsIfdlep+2HelEDbkJdNjqZQ90B7k6OIoFfkkPNoY+z0gzACa1f2qcBYxVJpT2QQgS19dKQlbC24S92xiEAFRKB5Uy1qrBgOtwIge55G0kRPfIytGx0tMOrGfrijB2FHOk/TKcMjDTMPeBo4FnXD5cQ8vtdgoAN0yuzZQHQI09wm/5vAB6RHyI9rYKiZ6YWC6rbaiLmDtoaToC1bViXQFNtgWsOfEEKCleC3GWPSfgQWRQWMgw/9FDgvOZrFAT3SmsA3DLbqlsSppQG5QeOjPXavUUkxF/qgLM05vW5o7UakuBqo2ZW8Nj0LB7imVJC9QSA+wd7RPztIUZ80xQZq0ROrc8CSVncWzkTA/RwmunldCPAQKjqVC7bhRuTIv0plbk7gOX4m5OAi2YesYZ0KBQRToG8iv9x8dgGtgECYRBeEU87OxoSc8epu+s7Mq/MN0VbBT19dii7ekO66UZwdAMtoAVQd13J5nwZe98OgGslmVqAGBkeLZNVNVlWpV18qihntXKnBZvrDIVgFpx4q5poLqREOVplMPSpTF2KvjBAzDpprkruXIaaUmUD4Xo2yrGWcYlixKIwRFjl0jPQhKznUXZAoSjlg9c/NwAI4p3Q/w5bCNfhUZS7bGfqesHqKAlyZZxZgNrhGevZXccaqBys4NEqB3Vqfptji9uUrhCL6yXFqxtm0hhLyYU3Tjd8I/HZaWD1oyVjnG5hhpCN5yHSf8BQUZlVNd00OP4M0TK+JSM7iqWi01SinFkCQXWxiZJLqqAHiEt3G3I2WYd46KU9pIJIOkoRQYCcEAAPguHo0Y4k8Hl6SW50MoW0uZU8jJOUghKo38Nl5ZSwsJNAUC2/lFZWkfMjrU8dFrTjHpJnUrLCILQIxINiYdQlDXaE/razQ4jjQluN5jW1Eh/S7yYvI5gigSjdLYU9TiFXAcHjISiLhQd9obb3OQmwY+YqVwiBMCkOGLXaK/ljBShh56c1g0uyIb2lBRKO7ZTAFncw5c5UGjGSy3CsI1Jt2mtruZkfhBZmbR+842Yu1eDiWEl0V6LZcGem6Ct+LW4Wy3oAjyNObazKBHomhJ3HMKEKHgiGksH+Ig1nTidfNMyA+oYHqVFaRGLiQreVLc9GvQgftKjW9cfUSKNYL80rqU7Um2rwqQJR1ai31Wq7vzKJEsFHDj0bAEMUKXgvfD5bWbaLPBTKz1Nk/Fg+GUZvUzFw80CLaKtPAACVAWrismh863FU4IJ0716SXBUNVb/SDMVvZgDt34CXoOq1JKvg0n08gPHTwXBNgD5W8pZZ8E9EVWcv1DZMB2NFysIwkqBSaH5QRmsAHdkHB+UANvLJvFpQKAahSmYTLEd2AFO+5rsqRRU6sVv5IP0wsSPLcWsbC1Y95mte71CUm6RJJWwkg6Q4k+xWMM0ByElJPQ6j2ED5hY42ALpZRytx9RlgQlJLijzhKi5eX5JBSIRGfo9o2xhd/0aWku8OS+4D9ZnovHDQMPaYo4qm2mlZbUnd7pR6oQj29Z2BqJ9n3LRT+MTLu3IR+ZP2TCPh3EDw8H1NHpoT7FibNYU8WHd9ESHcY12aDOQCUBddi4Ucp+4yuzz8ybcCCu1h8zvzXhDN4HYLq1R+U0xzUqg5QSA3iSBgdDouy55Ifx0DaeEhgezxBRGmoEJ6AJitVuzwtKPlUskHgU2F0LS7AFIwW5jPu0RUL7sp+fkNk0ee8P6uXYgl40WM+cdCOW21r13e0ivt0ff/mYcUfrQZWs2BiN6G+MDTGz1BKORmUTNQp9YGSHFxAeTkQrKd6FoVUogyytW25OLy3OpaO5oZCQp46aPzb5LnJiFEIwAKkmbYVYIjzVv3vj7rA6HignEeQAXTAHKDhoD7Uujh0QjtsB6fTP1NzO7T1Nzq4F1GnfHdXCG1Yxjwdtjf+PGRGTzEtEAUCz7KLfTdItLwCXuSOAzVjaZB6LvbUZhYGWmifSZlcMDnGHPd6gPeiK9erhpiw7ZP9ahTrMhFDa1J53m9ri2DloziqGETTcVSppCbTDDjExg6RrZ6cPEzB8XArEjQSB29odrUoLyoS/65RfM9fprGGjlHpbhGgbYD8MtmW1eFcAWX5dbcMHcl8sUI2k+H7GPW9VrArw3G+BefcCrCaAT/N53YLvP26Uy0kMFnDEZz0DJkmQqEOlL7SlKweYhH8gxpYeAYi0f9magqPbMYZuUI6007lSZQoyoGfYQHsNRzHXR3MMINTSMZpq1KD2A5MDJgtMLdRU6R4CEOJcKGiIJ7K6P/vAM6xpECHI8rRHsaEj6smkngAUjXTzrRoSI48ZpHOqgOY5OejKVdpnmiYUChQnVdIPa6ekGqRSRgEO119oDHOiIUQ5ciYVgaF1oG8Udo8WYtD+DEi8D/w8rAJE2k2PoyV0oMtpauxreaFjpujAvxFlwBhjuNqM9P0IfI5iD8Nh8y1kG4igjJkDNkOijnlLhItAd9lhRd670yNRTu95cR/Xuu0c5WO4DEFk5YQAPtLvU4TYPGRh4APPEDNiuuwR6SC21JoFbQBBMr+zJmT32QplNI6p16PbculN/pCX1wAyTWGTeJ774aln0gvQikw7TmkfsNbdQNs0adutYUDqNtGc0RqngUYdhUYuHSL1/eLrgvqDTC5neu++vufRkEgP9D2T64Kg/c4n+s7k3dDr3me8nOr0c72MRNmgF7D4WySPP0YAI/bI4eixwc7K13QiRiL85A8fnSsUj+mvTrsZtVUEQZ6sTpVafW8nYJZyaZS0U+0xIb6et9PhhtoObozQbjKAoDf6eiFgx1UUvpUYj1GweH0MNMrofhynfWn7+KYu7n5r83hN9aqm+6qjcH7dUlgvZVLV3xqq4fbP16qv+eofuTz43eomAqfS7GBAB9zEE31WJ37eVIPtdGN5A8nMYPvvLt8t2/V/6gM19G4g/hIL7UXf9JgbuLRZ+AoW//AzyMxTcWyz8BAruLRZ+AgX3r3y2+mT/PwfiN1DoVI+QT3CZDmvb8022JeYb6HiQPQpPPvboFB+i1MZdcqWZqthHmix6vttw0UAI1z8oEnGwVe++c7JamxslC+8xKJE41XJmug1npz+6CUAKyURd9gSxo+kWxvtZth848GBlws/0SKjYhmbZ9IiV+mcGBSdWHk8sqSr2zz5J7QME/0yD+z4Pe+JuGn1MV/vUyZwOHojWPlmPXgf9CuoeN9UAT+FGwaLg44v3dWe6QpvuL3Ln/p3k/2AgqNDcfwHgqUmIIqn+hwAAAAJiS0dEAACqjSMyAAAACXBIWXMAAAsSAAALEgHS3X78AAAAB3RJTUUH4wYRESAMujenGAAAB9FJREFUeNrtnWlsFVUUx899fS1gUoKioEY+WBRUEohGkUhAKxgEjSgGoRGB4AJCNKAIJBJZJSiyGYMKKkIoLlEUKhUraxFkKUE2kU1aCrRgW2jpg9f29R2/sBTo67v3zL2zvfP73MzM+XU6mf+5504BGIZhGIZhGIZhGIZhGMZGGq3JvSmR62++BXHH7Ylbf9ouRMT99yVq/e0PICIiHumUmPV3PooXOf5EItafXoCXOdUn8ep/pgjrUDY40ervX4JXUTEiocoXL5/FawiNEwlU/6hzeB3hqQljQIwJYT3UzEkQA2JiGOslsiAhDIgZ1RiD6NIEMBD8NIKxyQr6vv7FtdgQa31uILg0ig2zsZmv4//yePUj7rjNv/U3yUEJ/r7Xr/XfvBmlOPKwT+vfhpIUdvdj/Wm7UZpTz/mv/g4HUYGyQb5r/+SjEhXD/VV/j5OoSGisj16LRe9iVCY8xTcGxIulSKBmtk8MiKHlSMIn8ViMqkQivojHgfcuIJ0VAc/XPzmMVljrcQOBmdVojY1NvVx/8mcRtEqeh+NxypJatM6+ezxb/7Io6uBwR4/e/1moicJunvz956A2ip/1Xv3Nt6JGSgd6rf47/0KtlHssHrfZi5rxVDwWDx5C7XgoHotHC9AANbO8YqBXERohMt8bv/8X/kNDRDM9cA+IgWVojhWuNxAYXo4mWePyeBwYHUKz5Lo6HidNvICmybvVxfXPqEbz7Gvr2vrn1KAdHH7IpX//8yNoD8dcGY+TM6NoF26MxzLTL26Mx0majtM4q5ed7yhNulVsd5WAxqset/mGS6/d5CIBLXI62/7I6ZKyzjUC0rIfsP+hE3zkxt9c8vy7tPnJbiKfuyP+Xdn8ZDeuiMei+zF0juWOGyBNv+iMxw4bEBkl6CzOxmPx6ll0mryWDtb/ViU6z17H4rEYG0I3cMiheByYFEZ34Ew8Dn5UjW7BiXisY/rFDfGYmgWCCwcngXto0q08z1YBSUsy3NWgb5Qe2WSjgJRlfdy2RJPcNXm9bQIarexpsP5VdxHjcbMcm2Q3/5P64i71U8k/ELuLNsVjcct2cnST+rGg+Jo4XmhLPBZ376GOfoOkAIB5NWTHxuu/nzj9ElkA8gLgA+pLlvF43IU4/VI9G1QEAHnIPjfVaP1PnqRdVngKqAkActDMa2Hw/u9zijjjNg5UBcBr1FbD3jbG6h9QSruk8ovfyFESABnUWSNT8VgMI06/lF7aBqomAJ4n3m+G4nHgbeJfZfHljcCKAqDHcWo87m2g/gnE53LhlS+lqQqATv9S4/FL2u//qcT2T34XoAuAdvuJBspf11z/LOKbyYG6q4bqAqDVTqKByjFa21/U6ZfdaWBNADTdTDQQnqSv/pRMYjrZevVLCUUAiF+JBqpnaqv/J2I+zb3mxZwkAMTPDq8ep1A3P/1y3ZOEJABgiaPxuOnvxLN/B7oEwELq/sPl1utvSdz8VPsl6BMAn1AbBKut1t96F+3ENXOFTgFiehXRwAZL8Vi0JW5+qppW7+HIAgDGnyca2G4hHouOh2knvTARdAuAkedsj8cinTj9Ujka9AuAV87YHI/F08TNT2eHgQkB0I/aIDhGmuIU/YnnKxkAZgTAU8SGHC0eDyJufiqKfTKrAqBrPtFAiXo8HlFBO1VBA7ebZQHQifhUVo7H4p2QgQeOdQHQbp8t8Tg4idj+2dPgwJIGAdBqhw3xmDz9EuelQ4cASP3DeDwOziW+ecdbldEiACDbcDxOWkBs/8QNHpoEAPXjLNFMmfpv+IZ4+PjRU5cAWGwwHqcQNz/J2NUmAMgjavHjMfEPTGpvvz4BQH1MrzMkoHoW2CsAppEaBFskemQUA+HJYLcAeJfQINgpNVuvbiA0FuwXAG8qNwh2S07WqxqQ/saPXgEwRDGu7W8te2Q1A6XSH0HWLAD6nVa5zoPS9asZKJb/DLZuAdDzhPx1Hu2gkobkDRQq/J8w7QJAfstevuI3+WQN1F39dkAAtP9H7jpPdFVtiMgZOKC0Z9aAAEiT+mrbScLQjIyBXWngtABokRf/kKefonRF4xvYqrjmYEQApG6Md8SyvrS+eDwDG5QbzUYExL3QMxnUlZGGD5wFbhEADQ7YVwyhr401YCD6LbhHACyK3SA4N9TK6mhMA5EvwE0CYF6sBkFopLXl8exYq9/gLgHwYf3x+PxoqwMC9RoIvw9uE1D/gH3VeOsjItnSq9/OCqhvwL5qAoABA5XU28qsAHjj2tW8mukABgzEXP12WgAMvrpBEPkYwICB2KvfjguAvnUH7GvnARgwUGRhEt24gLoD9tGvAAwYKLDyySzzAqDzpQH76CIAAwYOWtqNYoMAaH9xwP57AAMG9ljbj2SHALhjJyLijwAGDGyzuCPNFgGQuhlxpfw1yR94dfAxi5cmojI/lRyx+rtaX9XDhADr2CVABc//JycWwAJYAAtgASyABbAAFsACWAALYAEsgAWwABbAAlgAC2ABLIAFsAAWwAJYAAtgASyABbAAFsACWAALYAEsgAWwABbAAlgAC2ABLIAFsAAWwAJYAAtgASyABbAAFsACWAALYAEsgAWwABbAAlgAC2ABLIAFsAAWwAJYAAtgASyABbAAFsACWIDToH8FyJUWtVWAALedDoFhGIZhGIZhGIZhGIYxyf+YwEMsIhMo/AAAAABJRU5ErkJggg==";
var GW = new Ul();
function uD(r5, t, e) {
  let { nearRadius: n4, farRadius: i, accentColor: a4, completeFraction: u5, isVertical: h, visibleThroughGeometry: d, dashed: m5 } = t, { color: v3 } = e, S4 = 0, I3 = 1 / 0, w3 = t.displayArrowsOnPath, E4 = true, T3 = w3, D4 = n4 / 2 + VW, A3 = 0;
  r5[0].z += D4;
  for (let Nt2 = 1; Nt2 < r5.length; ++Nt2) {
    r5[Nt2].z += D4;
    let At2 = r5[Nt2].x - r5[Nt2 - 1].x, Ct2 = r5[Nt2].z - r5[Nt2 - 1].z;
    if (h) A3 += Math.sqrt(At2 * At2 + Ct2 * Ct2);
    else {
      let _e3 = r5[Nt2].y - r5[Nt2 - 1].y;
      A3 += Math.sqrt(At2 * At2 + _e3 * _e3 + Ct2 * Ct2);
    }
  }
  if (!h) {
    let Nt2 = r5[0], At2 = r5[r5.length - 1];
    r5.push(At2.clone().setZ(At2.z - 0.01)), r5.unshift(Nt2.clone().setZ(Nt2.z - 0.01));
  }
  let L3 = new we$2();
  T3 && (L3 = GW.load(lD), L3.colorSpace = Ve$1);
  let B3 = new Ft$3(v3), j3 = new Ft$3(a4), W4 = { vertexes: { type: "f", value: 1 }, resolution: { type: "v2", value: new ot$1(1, 1) }, cameraParameters: { type: "v2", value: new ot$1(S4, 0) }, complete: { type: "f", value: 0 }, color: { type: "c", value: B3 }, pathLength: { type: "f", value: A3 }, nearRadius: { type: "f", value: n4 }, farRadius: { type: "f", value: i }, nearZoom: { type: "f", value: S4 }, farZoom: { type: "f", value: I3 }, pulseColor: { type: "c", value: j3 }, pulse: { type: "f", value: 0 }, pulseLength: { type: "f", value: 0.075 }, pathIsVertical: { type: "b", value: h }, arrowAnimationTimer: { type: "f", value: 0 }, arrowTexture: { type: "t", value: L3 }, displayArrowsOnPath: { type: "b", value: w3 }, showPulse: { type: "b", value: E4 }, opacityMultiplier: { type: "f", value: 1 }, dashed: { type: "b", value: m5 } }, $5 = new Jr$2(r5);
  $5.curveType = "catmullrom", $5.tension = 0;
  let F3 = 30, J4 = 8, ot2 = F3 * r5.length, K4 = new Cl$2($5, ot2, n4, J4, false), H5 = new Float32Array(K4.attributes.position.count);
  for (let Nt2 = r5.length; Nt2 < H5.length; Nt2++) H5[Nt2] = Nt2;
  K4.setAttribute("vertexIndex", new ve$3(H5, 1));
  let _t2 = new Float32Array(K4.attributes.position.count), ct2 = new ve$3(_t2, 1);
  for (let Nt2 = 0; Nt2 <= ot2; Nt2++) for (let At2 = 0; At2 <= J4; ++At2) ct2.setX(Nt2 * (J4 + 1) + At2, Nt2 / ot2);
  K4.setAttribute("pathDistance", ct2);
  let ft2 = new Float32Array(K4.attributes.normal.count * 3), mt2 = new ve$3(ft2, 3);
  for (let Nt2 = 0; Nt2 < ot2; Nt2++) {
    let At2 = K4.tangents[Nt2];
    for (let Ct2 = 0; Ct2 <= J4; ++Ct2) mt2.setXYZ(Nt2 * (J4 + 1) + Ct2, At2.x, At2.y, At2.z);
  }
  K4.setAttribute("pathTangent", mt2);
  let St2 = new Float32Array(K4.attributes.normal.count * 3), dt2 = new ve$3(St2, 3);
  for (let Nt2 = 0; Nt2 < ot2; Nt2++) {
    let At2 = K4.tangents[Nt2];
    var xt2, q4, ee2;
    h ? (xt2 = At2.x * At2.y, q4 = -1 + At2.y * At2.y, ee2 = At2.z * At2.y) : (xt2 = -At2.x * At2.z, q4 = -At2.y * At2.z, ee2 = 1 - At2.z * At2.z);
    let Ct2 = Math.sqrt(xt2 * xt2 + q4 * q4 + ee2 * ee2);
    Ct2 === 0 && (Ct2 = 1);
    let _e3 = xt2 / Ct2, de2 = q4 / Ct2, qr2 = ee2 / Ct2;
    for (let me2 = 0; me2 <= J4; ++me2) dt2.setXYZ(Nt2 * (J4 + 1) + me2, _e3, de2, qr2);
  }
  K4.setAttribute("pathNormal", dt2);
  let Gt2 = new sn$1({ uniforms: W4, vertexShader: Jx, fragmentShader: uM });
  Gt2.transparent = true, Gt2.alphaTest = 0.5, W4.resolution.value.x = 1, W4.resolution.value.y = 1, W4.vertexes.value = H5.length, W4.arrowTexture.value.wrapS = Ur$1, W4.arrowTexture.value.wrapT = Ur$1, W4.arrowTexture.value.anisotropy = 16;
  let Kt2 = new ye$1(K4, Gt2), It2 = Kt2.clone(), ie2 = G$1(F$1({}, W4), { opacityMultiplier: { type: "f", value: 0.25 } });
  ie2.complete.value = 1, It2.material = new sn$1({ uniforms: ie2, vertexShader: Jx, fragmentShader: uM }), It2.material.transparent = true, It2.material.alphaTest = 0.5, It2.material.depthWrite = false, It2.material.depthTest = false, ie2.resolution.value.x = 1, ie2.resolution.value.y = 1, ie2.vertexes.value = H5.length, ie2.arrowTexture.value.wrapS = Ur$1, ie2.arrowTexture.value.wrapT = Ur$1, ie2.arrowTexture.value.anisotropy = 16, ie2.complete.value = u5, Kt2.userData = It2.userData = t.mesh.userData;
  let vr2 = t.mesh;
  if (!d) {
    let Nt2 = new sn$1({ uniforms: W4, vertexShader: Jx, fragmentShader: aD }), At2 = new ye$1(K4, Nt2);
    At2.name = "stencil", At2.material.colorWrite = false, At2.material.stencilWrite = true, At2.material.stencilRef = 1, At2.material.stencilFunc = cl$2, At2.material.stencilZPass = Rp$2, At2.material.stencilZFail = Rp$2, At2.material.stencilFail = Rp$2, At2.material.depthWrite = false, At2.material.depthTest = false, At2.userData = t.mesh.userData, vr2.add(At2), vr2.add(It2);
  }
  if (vr2.add(Kt2), h) {
    let Nt2 = new Pe$3().setFromObject(Kt2), At2 = new I$1();
    Nt2.getCenter(At2), vr2.children.forEach((Ct2) => {
      Ct2.geometry.center(), Ct2.position.copy(At2);
    });
  }
  d && (Kt2.material.stencilWrite = true, Kt2.material.stencilRef = 1, Kt2.material.stencilFunc = Ip$2, Kt2.material.stencilZPass = jn$3, Kt2.material.stencilZFail = jn$3, Kt2.material.stencilFail = jn$3, Kt2.material.needsUpdate = true, Kt2.layers.disableAll(), Kt2.layers.enable(Ro.ALWAYS_ON_TOP)), K4.computeBoundingBox();
  let Qe2 = new I$1();
  return K4.boundingBox.getCenter(Qe2), { mesh: vr2, material: Gt2, center: Qe2 };
}
H$3(uD, "buildPath");
var VW = 0.15;
var jW = 0.5, cM = class cM2 extends Se$1 {
  constructor(e, n4, i, a4) {
    super();
    O(this, "rendererState");
    O(this, "altitudeDirty", true);
    O(this, "convertTo3DMapPosition");
    O(this, "getParentContainer");
    O(this, "convertZoomLevelToAltitude");
    this.rendererState = e, this.convertTo3DMapPosition = n4, this.getParentContainer = i, this.convertZoomLevelToAltitude = a4;
  }
  update(e, n4, i, a4 = 0) {
    let u5, h = false;
    for (let d of this.rendererState.geometry3DIdsInScene) if (u5 = this.rendererState.geometry3DMap.get(d), u5 && u5.type === "path" && u5.components[0].type === "path") {
      let m5 = u5.components[0], v3 = u5.components[1], x2 = m5.isVertical && this.altitudeDirty;
      if (!(m5 instanceof Rc2)) continue;
      let S4 = [];
      if (m5.dirty || x2) {
        if (m5.mesh.parent != null) for (let I3 = m5.mesh.children.length - 1; I3 >= 0; I3--) Jr(m5.mesh.children[0]);
        if (m5.feature.features.length === 2 && m5.feature.features[0].properties.parentId && m5.feature.features[1].properties.parentId) {
          let I3 = m5.feature.features[0], w3 = m5.feature.features[m5.feature.features.length - 1], E4, T3, D4 = I3.geometry.coordinates[2] || 0, A3 = w3.geometry.coordinates[2] || 0;
          I3.properties.parentId && (E4 = this.getParentContainer(I3.properties.parentId, true), E4 != null && E4.altitude != null && (D4 += E4.altitude, m5.isVertical = true)), w3.properties.parentId && (T3 = this.getParentContainer(w3.properties.parentId, true), T3 != null && T3.altitude != null && (A3 += T3.altitude, m5.isVertical = true));
          let L3 = this.convertTo3DMapPosition(I3.geometry.coordinates[1], I3.geometry.coordinates[0], D4), B3 = this.convertTo3DMapPosition(w3.geometry.coordinates[1], w3.geometry.coordinates[0], A3);
          Math.abs(L3.z - B3.z) > jW && E4 != null && E4.visible && T3 != null && T3.visible && (S4 = [L3, B3]);
        } else {
          let I3 = m5.feature.features;
          for (let w3 = 0; w3 < I3.length; w3++) if (w3 === 0 || !Ai(I3[w3].geometry.coordinates, I3[w3 - 1].geometry.coordinates)) {
            let E4 = this.convertTo3DMapPosition(I3[w3].geometry.coordinates[1], I3[w3].geometry.coordinates[0], I3[w3].geometry.coordinates[2] || 0);
            S4.push(E4);
          }
        }
        if (S4.length > 1) {
          let { mesh: I3, material: w3, center: E4 } = uD(S4, m5, { color: v3.color });
          m5.mesh = I3, m5.material = w3, m5.position = E4;
        }
        m5.dirty && (m5.nearZoomLevel != null && (m5.nearZoomAltitude = this.convertZoomLevelToAltitude(m5.nearZoomLevel)), m5.farZoomLevel != null && (m5.farZoomAltitude = this.convertZoomLevelToAltitude(m5.farZoomLevel))), m5.dirty = false;
      }
      v3.dirty && (m5.mesh.children.forEach((I3) => {
        I3.name !== "stencil" && (I3.material.uniforms.color.value.set(v3.color), I3.material.visible = v3.visible, I3.material.needsUpdate = true);
      }), m5.mesh.position.z = v3.altitude, v3.dirty = false), m5.isVertical && m5.mesh.children.forEach((I3) => {
        I3.rotation.z = -a4;
      }), m5.material && (m5.mesh.children.forEach((I3) => {
        var E4, T3;
        let w3 = I3.material.uniforms;
        if (I3.name === "stencil") {
          m5.materialDirty && (w3.complete.value = m5.completeFraction);
          return;
        }
        w3.nearZoom.value = (E4 = m5.nearZoomAltitude) != null ? E4 : e, w3.farZoom.value = (T3 = m5.farZoomAltitude) != null ? T3 : n4, w3.cameraParameters.value.x = i, m5.materialDirty && (w3.nearRadius.value = m5.nearRadius, w3.displayArrowsOnPath.value = m5.displayArrowsOnPath, w3.farRadius.value = m5.farRadius, w3.pulseColor.value.set(m5.accentColor), w3.complete.value = m5.completeFraction);
      }), m5.displayArrowsOnPath && m5.animateArrowsOnPath && (m5.mesh.children.forEach((I3) => {
        I3.name !== "stencil" && (I3.material.uniforms.arrowAnimationTimer.value = performance.now() / 3e3, I3.material.needsUpdate = true);
      }), h = true), m5.materialDirty = false);
    }
    this.altitudeDirty = false, h && this.publish("animate:path");
  }
};
H$3(cM, "PathSystem");
var u1 = cM;
a();
var ti, cm2, Cu2, pM = class pM2 {
  constructor(t) {
    O(this, "rendererState");
    O(this, "dirty", false);
    Q$3(this, ti);
    Q$3(this, cm2);
    Q$3(this, Cu2);
    this.rendererState = t;
  }
  updateOne(t) {
    if (t instanceof oe && t.components[0] instanceof mt && t.components[1] instanceof Oe && t.parentObject3D instanceof M && (R$1(this, ti, t.components[0]), R$1(this, Cu2, t.components[1]), P(this, ti).detached && P(this, ti).dirty && P(this, ti).mesh != null && P(this, ti).material != null && P(this, ti).batchedProps != null)) {
      R$1(this, cm2, t.parentObject3D), P(this, ti).visible = false;
      let e = new Ft$3(P(this, Cu2).color), n4 = P(this, Cu2).opacity * Oi$1(t), i = new Fh3({ color: e, side: cn$3, opacity: n4 != null ? n4 : 1, transparent: n4 !== void 0 ? n4 < 1 : false }, 1, P(this, ti).material.repeatYFactor), a4 = new ce$1(1, P(this, ti).batchedProps.positionCount, 0, i), u5 = rD(P(this, ti), a4);
      if (u5 == null) return;
      a4.userData = { entities: { 0: t.id }, detached: true }, P(this, ti).instanceIndex = u5, P(this, ti).material.setColor(P(this, ti).instanceIndex, e, P(this, Cu2).topColor ? new Ft$3(P(this, Cu2).topColor) : e), P(this, ti).mesh = a4, P(this, ti).material = i, P(this, cm2).add(a4), P(this, ti).dirty = false;
    }
  }
  update() {
    if (!this.dirty) return;
    let t;
    for (let e of this.rendererState.geometry3DIdsInScene) t = this.rendererState.geometry3DMap.get(e), this.updateOne(t);
    this.dirty = false, this.cleanup();
  }
  cleanup() {
    R$1(this, ti, void 0), R$1(this, cm2, void 0), R$1(this, Cu2, void 0);
  }
};
ti = /* @__PURE__ */ new WeakMap(), cm2 = /* @__PURE__ */ new WeakMap(), Cu2 = /* @__PURE__ */ new WeakMap(), H$3(pM, "MeshDetachmentSystem");
var Kx = pM;
a();
a();
function cD(r5, t, e) {
  var n4;
  if ((n4 = r5.batchedProps) != null && n4.range && r5.mesh) {
    let i = t || 1e-4, a4 = i / Math.max(e, 1e-4);
    return jx(r5.mesh.geometry, r5.batchedProps.range, i, 0), r5.material && (r5.material.repeatYFactor = a4), r5.currentHeight = i, true;
  }
  return false;
}
H$3(cD, "updateHeight");
function pD(r5, t, e, n4, i, a4) {
  return r5.mesh && r5.instanceIndex !== -1 ? (r5.mesh.getMatrixAt(r5.instanceIndex, e), e.decompose(n4, i, a4), n4.z = t, e.compose(n4, i, a4), r5.mesh.setMatrixAt(r5.instanceIndex, e), r5.altitude = t, true) : false;
}
H$3(pD, "updateAltitude");
var ya2, bl, t2, e2, r2, n2, hM = class hM2 {
  constructor(t) {
    O(this, "rendererState");
    O(this, "dirty", false);
    Q$3(this, ya2);
    Q$3(this, bl);
    Q$3(this, t2, new Vt$2());
    Q$3(this, e2, new I$1());
    Q$3(this, r2, new En$1());
    Q$3(this, n2, new I$1());
    this.rendererState = t;
  }
  updateOne(t) {
    var e;
    if (t instanceof oe && t.type === "geometry" && ((e = t.components[1]) != null && e.dirty) && (R$1(this, ya2, t.components[0]), R$1(this, bl, t.components[1]), t.type === "geometry")) {
      let n4 = false;
      P(this, bl).height !== P(this, ya2).currentHeight && (n4 = cD(P(this, ya2), P(this, bl).height, P(this, bl).initialHeight)), P(this, bl).altitude !== P(this, ya2).altitude && (n4 = pD(P(this, ya2), P(this, bl).altitude, P(this, t2), P(this, e2), P(this, r2), P(this, n2))), n4 && P(this, ya2).mesh != null && P(this, ya2).mesh.computeBoundingSphere();
    }
  }
  update() {
    let t;
    for (let e of this.rendererState.geometry3DIdsInScene) t = this.rendererState.geometry3DMap.get(e), this.updateOne(t);
    this.cleanup();
  }
  cleanup() {
    R$1(this, ya2, void 0), R$1(this, bl, void 0);
  }
};
ya2 = /* @__PURE__ */ new WeakMap(), bl = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap(), e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap(), H$3(hM, "MeshModificationSystem");
var Qx = hM;
a();
var UW = { showPolygonLabelTextAreaMesh: false, showEnvMap: false, showCollisionBoxes: false }, fM = class fM2 {
  constructor(t) {
    O(this, "state", UW);
    O(this, "core");
    this.core = t;
  }
  update(t) {
    let e = {};
    for (let [n4, i] of Object.entries(t)) n4 in this.state && this.state[n4] !== t[n4] && (this.state[n4] = i, e[n4] = i);
    this.handleUpdate(e);
  }
  handleUpdate(t) {
    t.showPolygonLabelTextAreaMesh != null && (t.showPolygonLabelTextAreaMesh ? this.core.getSystems().text3DSystem.showTextAreaMesh() : this.core.getSystems().text3DSystem.hideTextAreaMesh()), t.showEnvMap != null && (t.showEnvMap ? this.core.setEnvironment("basic") : this.core.setEnvironment(false)), t.showCollisionBoxes != null && (t.showCollisionBoxes ? (this.core.getSystems().collisionSystem.showCollisionBoxes(), this.core.render()) : this.core.getSystems().collisionSystem.hideCollisionBoxes());
  }
};
H$3(fM, "Debug");
var i2 = fM;
a();
var c1 = 9, hD = 0.1;
function HW(r5, t, e) {
  for (let n4 = 0; n4 < t; n4++) {
    let i = (e & 16711680) >> 16, a4 = (e & 65280) >> 8, u5 = e & 255;
    r5[n4 * 3] = i / 255, r5[n4 * 3 + 1] = a4 / 255, r5[n4 * 3 + 2] = u5 / 255;
  }
}
H$3(HW, "fillArrayWithColor");
var dM = class dM2 {
  constructor(t, e, n4) {
    O(this, "state");
    O(this, "renderer");
    O(this, "renderService");
    O(this, "pickingTexture");
    O(this, "pickingMaterial");
    O(this, "pixelBuffer");
    O(this, "width", 0);
    O(this, "height", 0);
    O(this, "scale", 1 / 2);
    O(this, "color", 1);
    O(this, "convertTo3DMapPosition");
    O(this, "destroyed", false);
    O(this, "enabled", false);
    O(this, "backgroundId", 16777215);
    O(this, "resize", H$3(() => {
      let t5 = this.state.pixelRatio;
      this.width = Math.floor(this.renderer.domElement.width / t5 * this.scale), this.height = Math.floor(this.renderer.domElement.height / t5 * this.scale), this.pixelBuffer = new Uint8Array(4 * this.width * this.height), this.pickingTexture = new on$3(this.width, this.height, { format: De$3, type: hn, internalFormat: "RGBA" });
    }, "resize"));
    O(this, "shouldShowByXY", H$3((t5, e4, n5) => {
      if (this.pixelBuffer == null) return false;
      let i = t5 + (this.height - e4 - 1) * this.width, a4 = this.pixelBuffer[i * 4], u5 = this.pixelBuffer[i * 4 + 1], h = this.pixelBuffer[i * 4 + 2], d = a4 << 16 | u5 << 8 | h;
      return d === n5 || d === this.backgroundId;
    }, "shouldShowByXY"));
    O(this, "activeOccluders", /* @__PURE__ */ new Set());
    O(this, "update", H$3(() => {
      if (!this.enabled || (this.activeOccluders.clear(), this.activeOccluders.add(this.backgroundId), !this.pickingTexture || !this.pixelBuffer)) return;
      let t5, e4;
      for (let i of this.state.geometry3DIdsInScene) {
        let a4 = this.state.geometry3DMap.get(i);
        if (a4 && a4 instanceof z && a4.userData.occluderFeature != null && a4.userData.occluderId != null && (this.activeOccluders.add(a4.userData.occluderId), a4.userData.occluderDirty)) {
          if (t5 = a4.userData.occluderFeature, t5.geometry.type === "Polygon") {
            let u5 = px2(t5, this.convertTo3DMapPosition, { color: "white", height: hD });
            e4 = this.createOccluderMesh(u5, a4.userData.occluderId), a4.add(e4);
          } else if (t5.geometry.type === "MultiPolygon") {
            let u5 = hx2(t5, this.convertTo3DMapPosition, { color: "white", height: hD });
            e4 = this.createOccluderMesh(u5, a4.userData.occluderId), a4 == null || a4.add(e4);
          }
          a4.userData.occluderDirty = false;
        }
      }
      this.renderer.setRenderTarget(this.pickingTexture);
      let n5 = new Ft$3(this.backgroundId);
      this.renderer.setClearColor(n5), this.renderer.clear(), this.state.cameraObject.layers.disableAll(), this.state.cameraObject.layers.enable(c1), this.renderer.render(this.state.entityScene.parent, this.state.cameraObject), this.renderer.setRenderTarget(null), this.state.cameraObject.layers.disable(c1), this.renderService.enabledLayers.delete(c1), this.renderer.readRenderTargetPixelsAsync(this.pickingTexture, 0, 0, this.width, this.height, this.pixelBuffer).then(() => {
        if (!this.destroyed) for (let i of this.state.geometry2DIdsInScene) {
          let a4 = this.state.geometry2DMap.get(i);
          if (a4 && (a4 == null ? void 0 : a4.occluderId) != null && this.activeOccluders.has(a4 == null ? void 0 : a4.occluderId)) {
            let u5 = a4.components[0].projection, h = Math.floor(u5.x * this.scale), d = Math.floor(u5.y * this.scale), m5 = this.shouldShowByXY(h, d, a4.occluderId);
            a4.components[0].isOccluded = !m5;
          }
        }
      });
    }, "update"));
    if (this.state = t, this.convertTo3DMapPosition = e, (n4 == null ? void 0 : n4.renderer) == null) throw new Error("No Renderer");
    this.renderService = n4, this.renderer = n4.renderer, this.resize(), this.pickingMaterial = new sn$1({ glslVersion: fc$2, vertexShader: "\n				attribute vec3 color;\n				varying vec3 vColor;\n				void main() {\n					vColor = color;\n					gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n				}\n			", fragmentShader: "\n				varying vec3 vColor;\n				out vec4 fragColor;\n\n				void main() {\n					fragColor = vec4(vColor, 1.0);\n				}\n			" });
  }
  applyId(t, e) {
    let n4 = t.attributes.position, i = new Float32Array(n4.count * 3);
    HW(i, n4.count, e), t.setAttribute("color", new ve$3(i, 3));
  }
  createOccluderMesh(t, e) {
    let n4 = new ye$1(t, this.pickingMaterial);
    return n4.layers.set(c1), this.applyId(n4.geometry, e), n4.userData.occluderId = e, n4;
  }
  reserveOccluderId() {
    return this.color++, this.color;
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
  destroy() {
    var t;
    this.destroyed = true, (t = this.pickingTexture) == null || t.dispose(), this.pickingMaterial.dispose(), this.pickingTexture = void 0, this.pixelBuffer = void 0;
  }
};
H$3(dM, "Occlusion2DSystem");
var o2 = dM;
a();
var mM = class mM2 {
  constructor(t) {
    this.state = t;
    O(this, "dirty", true);
  }
  update() {
    var t;
    if (this.dirty) {
      for (let e of this.state.geometry3DIdsInScene) {
        let n4 = this.state.geometry3DMap.get(e);
        if (n4 instanceof oe && n4.type === "geometry" && ((t = n4.components[0]) == null ? void 0 : t.geometry) != null) {
          let i = n4.components[0];
          i.geometry && (i.geometry.dispose(), i.geometry = void 0);
        }
      }
      this.dirty = false;
    }
  }
};
H$3(mM, "GeometryDisposalSystem");
var s2 = mM;
var fD = new Yl$2();
var { DEFAULT_PITCH: xM, DEFAULT_BEARING: _M, DEFAULT_ZOOM_LEVEL: CM, DEFAULT_MIN_ZOOM_LEVEL: XW, DEFAULT_MAX_ZOOM_LEVEL: YW } = Fs2, qW = Zp$2.radToDeg(0.6435011087932844), wn, Cn, qh3, p1, pm2, Gc2, Wh3, hm2, Yi, yM, it, Vr, va2, Pn, xl, Oi2, nt, h1, ei, jr, dD, mD, gD, Su, a2, f1, d1, m1, fm2, l2, g1, y1, v1, dm2, vM, Zh3, b1, x1, Oo, Do, bM, mm2, _1, SM = class SM2 extends Se$1 {
  constructor(e, n4 = {}) {
    var S4, I3, w3, E4, T3, D4, A3, L3, B$12, j3, W4, $5, F3, J4, ot2;
    super();
    Q$3(this, Yi);
    O(this, "options");
    O(this, "container");
    O(this, "Debug");
    Q$3(this, wn);
    Q$3(this, Cn);
    Q$3(this, qh3);
    Q$3(this, p1);
    Q$3(this, pm2);
    Q$3(this, Gc2);
    Q$3(this, Wh3);
    Q$3(this, hm2);
    O(this, "rendererDomElement");
    Q$3(this, it, { geometry3DMap: /* @__PURE__ */ new Map(), geometry2DMap: /* @__PURE__ */ new Map(), geometry2DIdsInScene: /* @__PURE__ */ new Set(), geometry3DIdsInScene: /* @__PURE__ */ new Set(), geometryGroupIdsToLoad: /* @__PURE__ */ new Set(), entityScene: new z("__scene"), hoverColor: "#f6efff", text3dHoverColor: "white", insetsPadding: Fo, shouldMeasureCanvas: true, pixelRatio: this.resolutionScale, canvasWidth: 0, canvasHeight: 0, internalTweenGroup: new Cx2(), externalTweenGroup: new Cx2(), cameraObject: new Te$1(), naturalBearing: 0, containerOffset: [0, 0], useStandaloneCamera: false });
    O(this, "camera");
    Q$3(this, Vr);
    Q$3(this, va2);
    Q$3(this, Pn);
    Q$3(this, xl);
    Q$3(this, Oi2);
    Q$3(this, nt, {});
    Q$3(this, h1, window.matchMedia("screen and (min-resolution: 2dppx)"));
    O(this, "map");
    Q$3(this, ei, H$3(() => {
      P(this, nt).renderSystem.twoDdirty = true;
    }, "#invalidate2DEntities"));
    Q$3(this, jr, H$3(() => {
      P(this, nt).renderSystem.threeDdirty = true;
    }, "#invalidate3DEntities"));
    Q$3(this, Su, "standalone");
    Q$3(this, a2, H$3(() => {
      P(this, nt).geometryDisposalSystem.dirty = true, this.render();
    }, "#setGeometryDisposalDirty"));
    Q$3(this, f1, H$3((e4) => Math.trunc(e4 * 10) / 10, "#round10"));
    Q$3(this, d1, H$3(() => {
      S$1(this, Yi, yM).call(this, Wt()), P(this, nt).twoDDrawSystem.dirty = true, P(this, fm2).call(this, void 0, void 0, true);
    }, "#handlePixelRatioChange"));
    Q$3(this, m1, H$3(() => {
      P(this, fm2).call(this);
    }, "#handleWindowResizeWithEvent"));
    Q$3(this, fm2, H$3((e4, n5, i5 = false) => {
      let a10 = e4 != null ? e4 : this.rendererDomElement.clientWidth, u6 = n5 != null ? n5 : this.rendererDomElement.clientHeight;
      if ((a10 === 0 || u6 === 0) && !i5) return;
      P(this, it).canvasWidth = a10, P(this, it).canvasHeight = u6, S$1(this, Yi, yM).call(this, Wt()), P(this, dm2).call(this), S$1(this, Yi, gD).call(this), P(this, nt).cameraSystem.resize(this.canvasWidth, this.canvasHeight), P(this, nt).cameraSystem.dirty = true, P(this, nt).watermarkSystem.resize(this.canvasWidth, this.canvasHeight), P(this, nt).htmlControlsSystem.resize(this.canvasWidth), P(this, nt).geometryInFocusSystem.resize(), P(this, nt).occlusion2DSystem.resize();
      let { top: h4, left: d4 } = this.container.getBoundingClientRect();
      P(this, it).containerOffset = [h4, d4], this.publish("resize"), this.render();
    }, "#handleWindowResize"));
    Q$3(this, l2, H$3(() => {
      this.renderSync();
    }, "#renderFull"));
    Q$3(this, g1, new I$1());
    Q$3(this, y1, H$3((e4, n5) => {
      let i5 = this.mode === "standalone" ? P(this, Cn) : this.viewCamera;
      if (P(this, Cn).position.z + this.camera.elevation > n5.z) {
        P(this, g1).copy(n5);
        let a10 = P(this, g1).project(i5), u6 = (a10.x + 1) / 2 * this.canvasWidth - 0 / 2, h4 = (-a10.y + 1) / 2 * this.canvasHeight - 0 / 2, d4 = P(this, f1).call(this, u6), m8 = P(this, f1).call(this, h4);
        e4.x = d4, e4.y = m8;
      } else e4.x = -1e3, e4.y = -1e3;
    }, "#project"));
    Q$3(this, v1, H$3((e4, n5) => {
      P(this, Oi2).setBufferSize(e4, n5), P(this, Cn).aspect = e4 / n5, P(this, Cn).updateProjectionMatrix(), P(this, Cn).updateMatrixWorld(true), P(this, pm2).x = e4, P(this, pm2).y = n5;
    }, "#setBufferSize"));
    Q$3(this, dm2, H$3(() => {
      var u6;
      let e4 = P(this, it).canvasWidth = this.rendererDomElement.clientWidth, n5 = P(this, it).canvasHeight = this.rendererDomElement.clientHeight, i5 = Math.floor(e4 * this.resolutionScale), a10 = Math.floor(n5 * this.resolutionScale);
      P(this, v1).call(this, i5, a10), (u6 = this.map) == null || u6.resize(), P(this, it).shouldMeasureCanvas = false;
    }, "#measureCanvas"));
    O(this, "getParentContainer", H$3((e4, n5 = true) => {
      if (!e4) return n5 ? P(this, it).entityScene : void 0;
      if (typeof e4 == "string" || typeof e4 == "number") {
        let i5 = P(this, it).geometry3DMap.get(e4);
        return i5 instanceof z ? i5 : (B.warn("Parent (".concat(typeof e4 == "object" ? e4.id : e4, ") is not a valid container, adding to scene")), n5 ? P(this, it).entityScene : void 0);
      } else if (e4.type === "group-container") {
        let i5 = P(this, it).geometry3DMap.get(e4.id);
        if (i5 instanceof z) return i5;
      }
      return n5 ? P(this, it).entityScene : void 0;
    }, "getParentContainer"));
    O(this, "showCollisionBoxes", H$3(() => {
      P(this, nt).collisionSystem.showCollisionBoxes(), this.render();
    }, "showCollisionBoxes"));
    O(this, "hideCollisionBoxes", H$3(() => {
      P(this, nt).collisionSystem.hideCollisionBoxes(), this.render();
    }, "hideCollisionBoxes"));
    O(this, "projectScreenXYToCoordinate", H$3((e4, n5, i5 = false) => {
      var S6, I4;
      let a10 = P(this, it).containerOffset[0], u6 = P(this, it).containerOffset[1], h4 = (e4 - u6) / P(this, it).canvasWidth * 2 - 1, d4 = -((n5 - a10) / P(this, it).canvasHeight) * 2 + 1, m8 = new ot$1(h4, d4), v4, x3;
      if (i5) fD.setFromCamera(m8, P(this, Cn)), v4 = (S6 = fD.intersectObject(P(this, Gc2), false)[0]) == null ? void 0 : S6.point;
      else {
        let w4 = P(this, nt).interactionSystem.getThreeDIntersectsFromXY(m8);
        v4 = (I4 = w4 == null ? void 0 : w4[0]) == null ? void 0 : I4.point, x3 = P(this, nt).interactionSystem.getGroupContainerIntersectsFromXY(m8);
      }
      if (v4) return { coordinate: this.convert3DMapPositionToCoordinate(v4), groupContainers: x3 };
    }, "projectScreenXYToCoordinate"));
    O(this, "projectCoordinateToScreenXY", H$3((e4) => {
      let n5 = this.convertTo3DMapPosition(e4[1], e4[0], e4[2] || 0), i5 = new ot$1();
      return P(this, y1).call(this, i5, n5), { x: i5.x, y: i5.y };
    }, "projectCoordinateToScreenXY"));
    O(this, "convert3DMapPositionToCoordinate", H$3((e4) => {
      var a10, u6, h4, d4;
      let { lat: n5, lon: i5 } = Ti$1((u6 = (a10 = P(this, it).center) == null ? void 0 : a10[1]) != null ? u6 : 0, (d4 = (h4 = P(this, it).center) == null ? void 0 : h4[0]) != null ? d4 : 0, e4.x, e4.y);
      return [i5, n5, e4.z];
    }, "convert3DMapPositionToCoordinate"));
    O(this, "setBackgroundColor", H$3((e4, n5) => {
      P(this, Oi2).setBackgroundColor(e4, n5);
    }, "setBackgroundColor"));
    O(this, "getMetresPerPixel", H$3(() => {
      let e4 = this.container.clientWidth, n5 = this.container.clientHeight / 2, i5 = this.projectScreenXYToCoordinate(0, n5, true), a10 = this.projectScreenXYToCoordinate(e4, n5, true);
      return i5 == null || a10 == null ? void 0 : Pr$1(i5.coordinate, a10.coordinate) / e4;
    }, "getMetresPerPixel"));
    O(this, "hideOutdoorLayersUnderPoint", H$3((e4, n5) => {
      !this.map || (n5 == null ? void 0 : n5.length) === 0 || (P(this, nt).outdoorLayersSystem.hideLayersUnderPoint(e4, n5), this.render());
    }, "hideOutdoorLayersUnderPoint"));
    O(this, "hideOutdoorLayersIntersectingPolygons", H$3((e4, n5, i5) => {
      P(this, nt).outdoorLayersSystem.hideLayersIntersectingPolygons(e4, n5, i5), this.render();
    }, "hideOutdoorLayersIntersectingPolygons"));
    Q$3(this, Zh3, new oi$1());
    Q$3(this, b1, new Vt$2());
    Q$3(this, x1, H$3((e4) => {
      var n5;
      B.error("Render failed: ", e4, (n5 = e4.stack) != null ? n5 : "No stack trace available"), this.publish("render-error", { error: e4 });
    }, "#onRenderError"));
    O(this, "render", H$3(() => {
      var e4;
      if (((e4 = P(this, nt)) == null ? void 0 : e4.renderSystem) != null) if (this.map && (this.mode === "outdoors-interleaved" || this.mode === "outdoors-overlay")) this.map.triggerRepaint();
      else return P(this, nt).renderSystem.update().catch(P(this, x1));
    }, "render"));
    O(this, "renderSync", H$3(() => P(this, nt).renderSystem.update(true).catch(P(this, x1)), "renderSync"));
    Q$3(this, Oo, $t$1(() => {
      this.publish("user-interaction-start", void 0);
    }, 0, true));
    Q$3(this, Do, $t$1(() => {
      this.publish("user-interaction-end", void 0), this.render();
    }, 0, true));
    O(this, "on", H$3((e4, n5) => {
      super.on(e4, n5), ["outdoor-view-loaded", "outdoor-style-loaded"].includes(e4) && this.mode === "standalone" && p$1.env.NODE_ENV !== "test" && (B.warn('"'.concat(e4, '" was subscribed to but outdoor view is disabled. The event has been triggered immediately. Enable outdoor view or remove the listener.')), this.publish(e4));
    }, "on"));
    O(this, "off", H$3((e4, n5) => {
      super.off(e4, n5);
    }, "off"));
    O(this, "getCursor", H$3(() => P(this, nt).interactionSystem.getCursor(), "getCursor"));
    O(this, "destroy", H$3(() => {
      var e4;
      P(this, nt) && (P(this, nt).cameraSystem.off("user-dolly-start", P(this, Oo)), P(this, nt).cameraSystem.off("user-pan-start", P(this, Oo)), P(this, nt).cameraSystem.off("user-rotate-start", P(this, Oo)), P(this, nt).cameraSystem.off("user-zoom-start", P(this, Oo)), P(this, nt).cameraSystem.off("user-tilt-start", P(this, Oo)), P(this, nt).cameraSystem.off("user-pedestal-start", P(this, Oo)), P(this, nt).cameraSystem.off("user-dolly-end", P(this, Do)), P(this, nt).cameraSystem.off("user-pan-end", P(this, Do)), P(this, nt).cameraSystem.off("user-rotate-end", P(this, Do)), P(this, nt).cameraSystem.off("user-zoom-end", P(this, Do)), P(this, nt).cameraSystem.off("user-tilt-end", P(this, Do)), P(this, nt).cameraSystem.off("user-pedestal-end", P(this, Do)), P(this, nt).renderSystem.off("measure-canvas", P(this, dm2)), P(this, nt).meshOptimizationSystem.off("geometry-2d-added", this.render), P(this, nt).meshOptimizationSystem.off("model-loaded", this.render), this.remove("__scene"), P(this, ei).call(this), P(this, jr).call(this), this.renderSync(), P(this, nt).renderSystem.destroy(), P(this, nt).cameraSystem.off("change", this.render), P(this, nt).pathSystem.off("animate:path", this.render), P(this, nt).cameraSystem.dispose(), P(this, nt).exporterSystem.destroy(), P(this, nt).outdoorLayersSystem.destroy(), P(this, nt).drawSystem.destroy(), window.removeEventListener("resize", P(this, m1), false), P(this, h1).removeEventListener("change", P(this, d1)), P(this, Wh3) && P(this, Wh3).disconnect(), this._subscribers = {}, P(this, Oi2).destroy(), (e4 = P(this, wn)) == null || e4.traverse((n5) => {
        Jr(n5), "dispose" in n5 && typeof n5.dispose == "function" && n5.dispose();
      }), R$1(this, wn, void 0), P(this, nt).htmlControlsSystem.destroy(), P(this, nt).collisionSystem.destroy(), P(this, nt).interactionSystem.destroy(), P(this, nt).domMutationSystem.destroy(), P(this, nt).geometryInFocusSystem.destroy(), R$1(this, nt, void 0), P(this, Su) !== "outdoors-overlay" && (this.map && (this.map.transform.getElevation = void 0, this.map.remove()), this.container.contains(this.rendererDomElement) && this.container.removeChild(this.rendererDomElement)), this.container.removeChild(P(this, xl)), this.container.removeChild(P(this, Vr)), R$1(this, Oi2, void 0));
    }, "destroy"));
    Q$3(this, mm2, new I$1());
    Q$3(this, _1, new I$1());
    if (P(this, it).useStandaloneCamera = (S4 = n4.useStandaloneCamera) != null ? S4 : false, P(this, it).naturalBearing = (I3 = n4.naturalBearing) != null ? I3 : 0, this.convertTo3DMapPosition = this.convertTo3DMapPosition.bind(this), !e.clientWidth || !e.clientHeight) throw new Error("[MappedinJS] Container width and height must be greater than 0");
    this.convertTo3DMapPosition = this.convertTo3DMapPosition.bind(this), (n4.mode === "outdoors-interleaved" || n4.mode === "outdoors-overlay") && n4.map && (R$1(this, Su, n4.mode), this.map = n4.map), P(this, it).entityScene.addEventListener("childadded", () => {
      P(this, jr).call(this), P(this, ei).call(this);
    }), P(this, it).entityScene.addEventListener("childremoved", () => {
      P(this, jr).call(this), P(this, ei).call(this);
    }), P(this, it).geometry3DMap.set(P(this, it).entityScene.userData.entityId, P(this, it).entityScene), n4.center && (P(this, it).center = n4.center ? [...n4.center] : [0, 0]), this.options = n4, this.container = e, S$1(this, Yi, dD).call(this), S$1(this, Yi, mD).call(this), P(this, nt).htmlControlsSystem = new Gx(this.container), P(this, Su) !== "outdoors-overlay" && P(this, nt).htmlControlsSystem.addAttributionControl(this.options.attribution), window.MappedinDebug || (window.MappedinDebug = {}), p$1.env.NODE_ENV === "test" && (window.MappedinDebug.mapViewCoreInstance = this), R$1(this, Oi2, new db({ antialias: typeof n4.antialias == "boolean" ? n4.antialias : true, alpha: false, canvas: this.mode !== "standalone" ? (w3 = n4.gl) == null ? void 0 : w3.canvas : void 0, onWebGLContextCreationError: n4.onWebGLContextCreationError, onWebGLContextLost: n4.onWebGLContextLost, onWebGLContextRestored: H$3((K4) => {
      var H5;
      (H5 = n4.onWebGLContextRestored) == null || H5.call(n4, K4), P(this, ei).call(this), P(this, jr).call(this), this.render();
    }, "onWebGLContextRestored"), onWebGLRendererError: n4.onWebGLRendererError, backgroundColor: n4.backgroundColor || "#ffffff", backgroundAlpha: (E4 = n4.backgroundAlpha) != null ? E4 : 1 })), R$1(this, wn, new hl$2()), P(this, Su) !== "standalone" && P(this, wn).add(Ni()), P(this, wn).add(P(this, it).entityScene);
    let i = window.__THREE_DEVTOOLS__;
    p$1.env.NODE_ENV === "dev" && typeof i < "u" && (i.dispatchEvent(new CustomEvent("observe", { detail: P(this, wn) })), i.dispatchEvent(new CustomEvent("observe", { detail: P(this, Oi2) }))), R$1(this, Cn, new Te$1(qW, this.aspect, 50, 1e5)), P(this, it).cameraObject = P(this, Cn), R$1(this, p1, new Ss$1()), P(this, Cn).renderOrder = 999;
    let a4 = new fe$2();
    a4.add(P(this, Cn)), R$1(this, hm2, new fe$2()), P(this, hm2).add(a4), P(this, wn).add(P(this, hm2)), P(this, Cn).updateProjectionMatrix(), P(this, Cn).updateMatrixWorld(true), this.referenceMap = { scale: 1, latitude: 0, longitude: 0, getNorth: H$3(() => 0, "getNorth"), georeference: [{ target: { x: 0, y: 0 } }, { target: { x: 0, y: 0 } }, { target: { x: 0, y: 0 } }, { target: { x: 0, y: 0 } }] }, this.rendererDomElement = P(this, Oi2).domElement(), R$1(this, pm2, new ot$1());
    let u5 = new Os$2(1e6, 1e6), h = new vs$1({ color: 0, visible: false });
    R$1(this, Gc2, new ye$1(u5, h)), P(this, Gc2).name = "worldPlane", P(this, wn).add(P(this, Gc2)), (T3 = n4.gl) != null && T3.canvas || e.appendChild(this.rendererDomElement), window.addEventListener("resize", P(this, m1), false), P(this, h1).addEventListener("change", P(this, d1)), typeof ResizeObserver == "function" && ((D4 = p$1.env) == null ? void 0 : D4.NODE_ENV) !== "test" && (R$1(this, Wh3, new ResizeObserver(Vc$1((K4) => {
      P(this, fm2).call(this, K4[0].contentRect.width, K4[0].contentRect.height);
    }, 50))), (A3 = P(this, Wh3)) == null || A3.observe(e)), e.classList.add("mappedin-map"), this.rendererDomElement.style.width = (L3 = globalThis.MappedinDebug) != null && L3.TEST_IOS ? "1080px" : "100%", this.rendererDomElement.style.height = (B$12 = globalThis.MappedinDebug) != null && B$12.TEST_IOS ? "1920px" : "100%", p$1.env.NODE_ENV === "test" && this.rendererDomElement.setAttribute("data-testid", "mappedin-canvas"), P(this, it).canvasWidth = this.rendererDomElement.clientWidth, P(this, it).canvasHeight = this.rendererDomElement.clientHeight, this.rendererDomElement.style.touchAction = "manipulation";
    let d = this.canvasWidth, m5 = this.canvasHeight;
    P(this, nt).watermarkSystem = new kx2(P(this, Cn), P(this, it), n4 == null ? void 0 : n4.watermark), P(this, nt).watermarkSystem.on("texture-loaded", this.render), P(this, it).shouldMeasureCanvas = true, P(this, it).pixelRatio = this.resolutionScale, P(this, v1).call(this, Math.floor(d * this.resolutionScale), Math.floor(m5 * this.resolutionScale));
    let v3 = new kl$1(16777215, 0.3 * Math.PI);
    v3.position.set(-150, -150, 350), P(this, wn).add(v3);
    let x2 = new Vl(16777215, 0.741 * Math.PI);
    P(this, wn).add(x2), P(this, nt).cameraSystem = new sm2(P(this, Cn), P(this, wn), P(this, Oi2).renderer, P(this, it), { mode: this.mode, canvasHeight: m5, canvasWidth: d }), P(this, nt).cameraSystem.on("user-dolly-start", P(this, Oo)), P(this, nt).cameraSystem.on("user-pan-start", P(this, Oo)), P(this, nt).cameraSystem.on("user-rotate-start", P(this, Oo)), P(this, nt).cameraSystem.on("user-zoom-start", P(this, Oo)), P(this, nt).cameraSystem.on("user-tilt-start", P(this, Oo)), P(this, nt).cameraSystem.on("user-pedestal-start", P(this, Oo)), P(this, nt).cameraSystem.on("user-dolly-end", P(this, Do)), P(this, nt).cameraSystem.on("user-pan-end", P(this, Do)), P(this, nt).cameraSystem.on("user-rotate-end", P(this, Do)), P(this, nt).cameraSystem.on("user-zoom-end", P(this, Do)), P(this, nt).cameraSystem.on("user-tilt-end", P(this, Do)), P(this, nt).cameraSystem.on("user-pedestal-end", P(this, Do)), P(this, nt).cameraSystem.on("change", () => {
      this.publish("camera-change", this.camera), P(this, nt).geometryInFocusSystem && (P(this, nt).geometryInFocusSystem.cameraDirty = true), this.render();
    }), P(this, nt).pathSystem = new u1(P(this, it), this.convertTo3DMapPosition, this.getParentContainer, P(this, nt).cameraSystem.convertZoomLevelToAltitude), P(this, nt).pathSystem.on("animate:path", this.render), P(this, nt).panBoundsSystem = new Bx2(P(this, it), P(this, nt).cameraSystem), P(this, nt).panBoundsSystem.on("update", () => {
      let { panBounds: K4, fov: H5, convertAltitudeToZoomLevel: _t2 } = P(this, nt).cameraSystem;
      if (P(this, nt).panBoundsSystem.autoMinZoomLevel) {
        if (K4.radius <= 0) return;
        let ct2 = Math.min(P(this, it).canvasWidth / P(this, it).canvasHeight, 1), ft2 = H5 * Math.PI / 180 * ct2, mt2 = Math.tan(ft2 / 2), { radius: St2, center: dt2 } = P(this, nt).cameraSystem.panBounds, xt2 = St2 / mt2, q4 = this.getThreeCamera().getWorldPosition(new I$1()), ee2 = dt2.distanceTo(q4), Gt2 = Math.abs(q4.z - dt2.z), Kt2 = xt2 * Gt2 / ee2, It2 = _t2(Kt2);
        Li$1(It2, this.camera.minZoomLevel) && this.camera.setMinZoomLevel(It2);
      }
      this.publish("pan-bounds-change", P(this, nt).cameraSystem.panBounds);
    }), this.camera = new Nx(this, P(this, nt), P(this, it)), this.camera.setZoomLevel((j3 = n4.zoomLevel) != null ? j3 : CM), this.camera.setBearing((W4 = n4.bearing) != null ? W4 : _M), this.camera.setPitch(($5 = n4.pitch) != null ? $5 : xM), this.camera.setMaxZoomLevel(YW), this.camera.setMinZoomLevel(XW), P(this, nt).domVisiblitySystem = new mx(P(this, it), P(this, xl)), P(this, nt).domMutationSystem = new Ax2(P(this, it), P(this, xl)), P(this, nt).domMutationSystem.on("dimensions-update", () => {
      P(this, nt).collisionSystem.collidersDirty = true, this.render();
    }), P(this, nt).domDrawSystem = new Dx2(P(this, it)), P(this, nt).collisionSystem = new yb(P(this, va2), P(this, it), ((F3 = n4.useCollisionWorker) != null ? F3 : true) && ((J4 = n4.useWorkers) != null ? J4 : true)), P(this, nt).twoDDrawSystem = new yx(P(this, it), P(this, Pn), n4.transformImageRequest), P(this, nt).twoDDrawSystem.on("img:loaded", this.render), P(this, nt).interactionSystem = new dy2(this.rendererDomElement, P(this, it), P(this, Cn), P(this, Gc2), P(this, nt).cameraSystem.isUserInteracting), P(this, nt).interactionSystem.on("doubletap-with-onefinger", (K4) => {
      var H5;
      this.camera.animateTo({ center: (H5 = this.projectScreenXYToCoordinate(K4.clientX, K4.clientY)) == null ? void 0 : H5.coordinate, zoomLevel: this.camera.zoomLevel + 1, duration: Bo$1, easing: "ease-out" });
    }), P(this, nt).interactionSystem.on("singletap-with-twofinger", () => {
      this.camera.animateTo({ zoomLevel: this.camera.zoomLevel - 1, duration: Bo$1, easing: "ease-out" });
    }), P(this, nt).interactionSystem.on("hover", this.render), P(this, nt).interactionSystem.on("click", (K4) => {
      var _t2, ct2, ft2, mt2, St2, dt2, xt2, q4, ee2, Gt2, Kt2, It2;
      if (((_t2 = K4.entity2D) == null ? void 0 : _t2.id) === "watermark" && typeof P(this, nt).watermarkSystem.options.onClick == "function" && P(this, nt).watermarkSystem.options.interactive) {
        P(this, nt).watermarkSystem.options.onClick();
        return;
      }
      let H5 = K4.entity3D ? [(ct2 = K4.entity3D) == null ? void 0 : ct2.id] : [];
      (St2 = (mt2 = (ft2 = K4.entity3D) == null ? void 0 : ft2.parentObject3D) == null ? void 0 : mt2.userData) != null && St2.entityId && H5.push((q4 = (xt2 = (dt2 = K4.entity3D) == null ? void 0 : dt2.parentObject3D) == null ? void 0 : xt2.userData) == null ? void 0 : q4.entityId), this.publish("click", { coordinate: this.convert3DMapPositionToCoordinate(K4.position), geometry: H5, paths: ((ee2 = K4.entity3D) == null ? void 0 : ee2.components[0]) instanceof Rc2 ? [K4.entity3D.id] : [], markers: ((Gt2 = K4.entity2D) == null ? void 0 : Gt2.components[0]) instanceof fl ? [K4.entity2D.id] : [], models: ((Kt2 = K4.entity3D) == null ? void 0 : Kt2.components[0]) instanceof Ac2 ? [K4.entity3D.id] : [], labels: ((It2 = K4.entity2D) == null ? void 0 : It2.components[0]) instanceof dl ? [K4.entity2D.id] : [], containers: Array.isArray(K4.groupContainers) ? K4.groupContainers.map((ie2) => ie2.userData.entityId) : [], pointerEvent: K4.pointerEvent });
    }), P(this, nt).interactionSystem.on("hover", (K4) => {
      var H5, _t2, ct2, ft2, mt2, St2;
      K4.position && ((H5 = K4.entity2D) == null ? void 0 : H5.id) !== "watermark" && this.publish("hover", { coordinate: this.convert3DMapPositionToCoordinate(K4.position), geometry: K4.entity3D ? [(_t2 = K4.entity3D) == null ? void 0 : _t2.id] : [], paths: ((ct2 = K4.entity3D) == null ? void 0 : ct2.components[0]) instanceof Rc2 ? [K4.entity3D.id] : [], markers: ((ft2 = K4.entity2D) == null ? void 0 : ft2.components[0]) instanceof fl ? [K4.entity2D.id] : [], models: ((mt2 = K4.entity3D) == null ? void 0 : mt2.components[0]) instanceof Ac2 ? [K4.entity3D.id] : [], labels: ((St2 = K4.entity2D) == null ? void 0 : St2.components[0]) instanceof dl ? [K4.entity2D.id] : [], containers: Array.isArray(K4.groupContainers) ? K4.groupContainers.map((dt2) => dt2.userData.entityId) : [] });
    }), P(this, nt).geometryInFocusSystem = new Wx(P(this, it), P(this, Cn)), P(this, nt).geometryInFocusSystem.on("geometry-in-focus", (K4) => {
      this.publish("geometry-in-focus", K4);
    }), P(this, nt).twoDVisiblitySystem = new bx2(P(this, it)), P(this, nt).drawSystem = new vx(P(this, it), this.convertTo3DMapPosition), P(this, nt).drawSystem.on("texture-loaded", this.render), P(this, nt).stackSystem = new _x2(P(this, it)), P(this, nt).twoDProjectionSystem = new gx2(P(this, it), P(this, y1)), P(this, nt).exporterSystem = new Ry2(P(this, it)), P(this, nt).meshOptimizationSystem = new dx(P(this, it), this.convertTo3DMapPosition), P(this, nt).meshOptimizationSystem.on("model-loaded", this.render), P(this, nt).meshOptimizationSystem.on("geometry-2d-added", this.render), P(this, nt).meshOptimizationSystem.on("geometry-group-added", P(this, a2)), P(this, nt).meshDetachmentSystem = new Kx(P(this, it)), P(this, nt).meshModificationSystem = new Qx(P(this, it)), P(this, nt).geometryDisposalSystem = new s2(P(this, it)), P(this, nt).customGeometrySystem = new Vx(P(this, it), this.convertTo3DMapPosition), P(this, nt).outlineInterpolationSystem = new Ux(P(this, it)), P(this, nt).renderSystem = new xx2(P(this, Oi2), P(this, it), this.mode, P(this, wn), P(this, Cn), this.viewCamera, P(this, nt)), P(this, nt).imageSystem = new qx(P(this, it), this.convertTo3DMapPosition, n4.bearing, n4.naturalBearing, n4.imagePlacementOptions), P(this, nt).text3DSystem = new $b(P(this, it), this.convertTo3DMapPosition, (ot2 = n4.useWorkers) != null ? ot2 : true), P(this, nt).text3DSystem.on("render", this.render), P(this, nt).imageSystem.on("image-loaded", this.render), P(this, nt).renderSystem.on("pre-render", () => this.publish("pre-render")), P(this, nt).renderSystem.on("post-render", () => this.publish("post-render")), P(this, nt).renderSystem.on("measure-canvas", P(this, dm2)), P(this, nt).outdoorLayersSystem = new Zx(this.map), P(this, nt).occlusion2DSystem = new o2(P(this, it), this.convertTo3DMapPosition, P(this, Oi2)), n4.occlusionEnabled && P(this, nt).occlusion2DSystem.enable(), this.Debug = new i2(this), n4.environment !== false && R$1(this, qh3, S$1(this, Yi, bM).call(this)), P(this, l2).call(this);
  }
  get viewCamera() {
    return P(this, p1);
  }
  get canvasWidth() {
    return P(this, it).canvasWidth;
  }
  get canvasHeight() {
    return P(this, it).canvasHeight;
  }
  get resolutionScale() {
    var e, n4;
    return (n4 = (e = this.map) == null ? void 0 : e._getClampedPixelRatio(this.canvasWidth, this.canvasHeight)) != null ? n4 : Wt();
  }
  get aspect() {
    return this.canvasWidth / this.canvasHeight;
  }
  get mode() {
    return P(this, Su);
  }
  addGroupContainer(e, n4, i) {
    if (!P(this, it).geometry3DMap.has(e) && !P(this, it).geometry2DMap.has(e)) {
      let a4 = new z(e);
      a4.addEventListener("childadded", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), a4.addEventListener("childremoved", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), (n4 == null ? void 0 : n4.visible) !== void 0 && (a4.visible = n4.visible), (n4 == null ? void 0 : n4.altitude) !== void 0 && a4.setAltitude(n4.altitude), (n4 == null ? void 0 : n4.interactive) !== void 0 && Ei(a4, n4.interactive, P(this, it)), (n4 == null ? void 0 : n4.focusable) !== void 0 && tx2(a4, n4.focusable), (n4 == null ? void 0 : n4.preloadGeometry) !== void 0 && (a4.userData.preloadGeometry = n4.preloadGeometry), P(this, it).geometry3DMap.set(e, a4);
      let u5 = this.getParentContainer(i);
      u5 instanceof z && u5.addEntity(a4), P(this, jr).call(this), this.render();
    } else B.error("Group container with ID '".concat(e, "' already exists. The group container cannot be added."));
    return { id: e, type: "group-container" };
  }
  addStackContainer(e, n4, i) {
    if (P(this, it).geometry3DMap.has(e)) B.error("Stack container with ID '".concat(e, "' already exists. The stack container cannot be added."));
    else {
      let a4 = new z(e);
      a4.addEventListener("childadded", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), a4.addEventListener("childremoved", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), a4.components[0] = new Lx(), (n4 == null ? void 0 : n4.visible) !== void 0 && (a4.visible = n4.visible), P(this, it).geometry3DMap.set(e, a4);
      let u5 = this.getParentContainer(i);
      u5 instanceof z && u5.addEntity(a4);
    }
    return { id: e, type: "stack-container" };
  }
  addCustomGeometry(e, n4, i, a4, u5) {
    if (P(this, it).geometry3DMap.has(e)) B.error("Custom geometry with ID '".concat(e, "' already exists. The custom geometry cannot be added."));
    else {
      let h = new lm(n4, i), d = new oe(h, new Oe(a4));
      (a4 == null ? void 0 : a4.interactive) !== void 0 && Ei(d, a4.interactive, P(this, it)), d.id = e, h.mesh.userData = { entityId: e, type: "custom-geometry" }, P(this, it).geometry3DMap.set(d.id, d);
      let m5 = this.getParentContainer(u5);
      m5 instanceof z && m5.addEntity(d), P(this, jr).call(this), this.render();
    }
    return { id: e, type: "custom-geometry" };
  }
  addGeometryGroup(e, n4, i, a4) {
    var u5, d;
    if (!P(this, it).geometry3DMap.has(e) && !P(this, it).geometry2DMap.has(e)) {
      let m5 = new M(e, new me(i));
      m5.addEventListener("childadded", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), m5.addEventListener("childremoved", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), m5.userData.dirty = true, P(this, it).geometry3DMap.set(e, m5);
      for (let x2 of n4.features) {
        if (x2.geometry == null || !["Polygon", "MultiPolygon", "LineString", "MultiLineString"].includes(x2.geometry.type)) continue;
        let S4 = (x2 == null ? void 0 : x2.id) || ((u5 = x2 == null ? void 0 : x2.properties) == null ? void 0 : u5.id) || E(), h = i || { color: Le }, { visible: I3, altitude: w3 } = h, E$12 = J$1(h, ["visible", "altitude"]), T3 = P(this, nt).meshOptimizationSystem.createEntityFromFeature(S4, x2, G$1(F$1({}, E$12), { outline: true }));
        P(this, it).geometry3DMap.set(S4, T3), m5.userData.entities3D.add(S4);
      }
      m5.setVisible((d = i == null ? void 0 : i.visible) != null ? d : true), (i == null ? void 0 : i.altitude) != null && m5.setAltitude(i.altitude);
      let v3 = this.getParentContainer(a4);
      v3 instanceof z && v3.addEntity(m5), P(this, jr).call(this), this.render();
    } else B.error("Geometry group with ID '".concat(e, "' already exists. The geometry group cannot be added."));
    return P(this, nt).outlineInterpolationSystem.geometries3DDirty = true, { id: e, type: "geometry-group" };
  }
  addOccluder(e, n4) {
    let i = this.getParentContainer(n4), a4 = P(this, nt).occlusion2DSystem.reserveOccluderId();
    return i == null || i.addOccluderFeature(e, a4), a4;
  }
  addImage(e, n4, i, a4) {
    try {
      nD(e, n4, i);
    } catch (u5) {
      B.error(u5);
      return;
    }
    if (!P(this, it).geometry3DMap.has(e) && !P(this, it).geometry2DMap.has(e)) {
      let u5 = new Yx(n4), h = new oe(u5, new Oe(i));
      h.id = e || E(), u5.mesh.userData = { entityId: h.id, type: "path" }, P(this, it).geometry3DMap.set(h.id, h);
      let d = this.getParentContainer(a4);
      d instanceof z && d.addEntity(h), P(this, jr).call(this), this.render();
    } else B.error("Image with ID '".concat(e, "' already exists. The image cannot be added."));
    return { id: e, type: "image" };
  }
  addModelGroup(e, n4, i, { parent: a4, onComplete: u5 } = {}) {
    var h, d;
    try {
      NO(e, n4, i);
    } catch (m5) {
      B.error(m5);
      return;
    }
    if (!P(this, it).geometry3DMap.has(e) && !P(this, it).geometry2DMap.has(e)) {
      let m5 = new M(e, new me(G$1(F$1({}, i), { outline: false })));
      m5.addEventListener("childadded", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), m5.addEventListener("childremoved", () => {
        P(this, jr).call(this), P(this, ei).call(this);
      }), P(this, it).geometry3DMap.set(e, m5), m5.userData.dirty = true, m5.userData.modelURL = i.url;
      for (let x2 of n4.features) {
        let S4 = x2.id || x2.properties.id || E(), I3 = P(this, nt).meshOptimizationSystem.createModelFromFeature(S4, x2, i);
        (x2.properties.interactive !== void 0 || i.interactive != null) && Ei(I3, (h = x2.properties.interactive) != null ? h : i.interactive, P(this, it)), P(this, it).geometry3DMap.set(S4, I3), m5.userData.entities3D.add(S4);
      }
      let v3 = this.getParentContainer(a4);
      v3 instanceof z && v3.addEntity(m5), P(this, jr).call(this), (d = this.render()) == null || d.then(u5);
    } else B.error("Model group with ID '".concat(e, "' already exists. The model group cannot be added."));
    return { id: e, type: "geometry-group" };
  }
  addMarker2D(e, n4, i, a4) {
    var h;
    let u5 = i == null ? void 0 : i.id;
    try {
      Q9(e, n4, i || {});
    } catch (d) {
      B.error(d);
      return;
    }
    if (u5 === void 0 || !P(this, it).geometry2DMap.has(u5) && !P(this, it).geometry3DMap.has(u5)) {
      let d = S$1(this, Yi, vM).call(this, e, new fl(n4, i), i == null ? void 0 : i.occluderId, i == null ? void 0 : i.verticalOffset);
      d.id = u5 || String(d.id), u5 = d.id, (i == null ? void 0 : i.interactive) != null && i.interactive !== "pointer-events-auto" && Ei(d, i == null ? void 0 : i.interactive, P(this, it));
      let m5 = typeof (i == null ? void 0 : i.attachTo) == "string" || typeof (i == null ? void 0 : i.attachTo) == "number" ? P(this, it).geometry3DMap.get(i.attachTo) : void 0;
      m5 instanceof oe && m5.attach(d), (h = this.getParentContainer(a4)) == null || h.addEntity(d), this.render();
    } else B.error("Marker2D with ID '".concat(u5, "' already exists. The marker cannot be added."));
    return { id: u5, type: "marker" };
  }
  addText3D(e, n4, i, a4) {
    if (!P(this, it).geometry3DMap.has(e) && !P(this, it).geometry2DMap.has(e)) {
      let u5 = new Ec2(G$1(F$1({}, n4), { properties: G$1(F$1({}, n4.properties), { id: e, content: n4.properties.text }) })), h = new oe(u5, new je(i == null ? void 0 : i.appearance));
      h.id = e, u5.mesh.userData.entityId = e.toString(), u5.mesh.userData.type = "text3d", P(this, it).geometry3DMap.set(e, h);
      let d = this.getParentContainer(a4);
      d instanceof z && d.addEntity(h), P(this, jr).call(this), this.render();
    } else B.error("Text3D with ID '".concat(e, "' already exists. The text3d cannot be added."));
    return { id: e, type: "text3d" };
  }
  labelText3D(e, n4, i = {}) {
    var m5, v3;
    try {
      if (!n4 || !e) throw new Error("content and meshGeometryId are required");
      W8.parse(i);
    } catch (x2) {
      B.error(x2);
      return;
    }
    let a4 = P(this, it).geometry3DMap.get(e);
    if ((a4 == null ? void 0 : a4.type) !== "geometry") {
      B.error(".labelText3D failed: target incorrect");
      return;
    }
    let u5 = a4 == null ? void 0 : a4.components[0];
    if (!u5.feature.properties.textArea) return;
    if (u5.textEntityId) {
      let x2 = P(this, it).geometry3DMap.get(u5.textEntityId);
      if ((x2 == null ? void 0 : x2.type) !== "text3d") {
        B.error(".labelText3D failed: existing text3d not found");
        return;
      }
      return { id: x2.id, type: x2.type };
    }
    let h = new Ec2({ type: "Feature", geometry: { coordinates: (m5 = u5.feature.properties.textArea) == null ? void 0 : m5.position, type: "Point" }, properties: { textArea: u5.feature.properties.textArea, content: n4, id: E() } });
    h.polygonEntityId = e;
    let d = new oe(h, new je(i == null ? void 0 : i.appearance));
    return u5.textEntityId = d.id.toString(), h.mesh.userData.entityId = d.id.toString(), h.mesh.userData.type = "text3d", P(this, it).geometry3DMap.set(d.id.toString(), d), i.parentId && ((v3 = this.getParentContainer(i.parentId)) == null || v3.addEntity(d)), this.render(), { id: d.id, type: "text3d" };
  }
  addLabel2D(e, n4, i, a4) {
    var h;
    let u5 = i == null ? void 0 : i.id;
    try {
      U8(e, n4, i || {});
    } catch (d) {
      B.error(d);
      return;
    }
    if (u5 === void 0 || !P(this, it).geometry2DMap.has(u5) && !P(this, it).geometry3DMap.has(u5)) {
      let d = S$1(this, Yi, vM).call(this, e, new dl(n4, i || {}, P(this, it)), i == null ? void 0 : i.occluderId, i == null ? void 0 : i.verticalOffset);
      d.id = u5 || String(d.id), u5 = d.id, (i == null ? void 0 : i.interactive) != null && Ei(d, i == null ? void 0 : i.interactive, P(this, it));
      let m5 = typeof (i == null ? void 0 : i.attachTo) == "string" || typeof (i == null ? void 0 : i.attachTo) == "number" ? P(this, it).geometry3DMap.get(i.attachTo) : void 0;
      m5 instanceof oe && m5.attach(d), (h = this.getParentContainer(a4)) == null || h.addEntity(d), P(this, ei).call(this), this.render();
    } else B.error("Label2D with ID '".concat(u5, "' already exists. The label cannot be added."));
    return { id: u5, type: "label" };
  }
  addPath(e, n4 = {}, i) {
    var d;
    try {
      BO(e, n4 || {});
    } catch (m5) {
      B.error(m5);
      return;
    }
    let a4 = new Rc2(e, pI(n4)), u5 = new oe(a4, new Oe({ color: (d = n4 == null ? void 0 : n4.color) != null ? d : "#ff834c" }));
    u5.id = (n4 == null ? void 0 : n4.id) || E(), a4.mesh.userData = { entityId: u5.id, type: "path" }, P(this, it).geometry3DMap.set(u5.id, u5), (n4 == null ? void 0 : n4.interactive) != null && Ei(u5, n4 == null ? void 0 : n4.interactive, P(this, it));
    let h = this.getParentContainer(i);
    return h instanceof z && h.addEntity(u5), P(this, jr).call(this), this.render(), { id: u5.id, type: "path" };
  }
  updateWatermark(e) {
    P(this, nt).watermarkSystem.options = e, P(this, nt).watermarkSystem.dirty = true, P(this, nt).collisionSystem.collidersDirty = true, this.render();
  }
  remove(e) {
    var i;
    let n4;
    if (typeof e == "string" || typeof e == "number" ? (n4 = P(this, it).geometry2DMap.get(e), n4 == null && (n4 = P(this, it).geometry3DMap.get(e))) : typeof e.id == "string" || typeof e.id == "number" ? (n4 = P(this, it).geometry2DMap.get(e.id), n4 == null && (n4 = P(this, it).geometry3DMap.get(e.id))) : n4 = e, n4 != null) {
      if (n4.type === "custom-geometry") P(this, it).geometry3DMap.delete(n4.id), n4.object3d && Jr(n4.object3d);
      else if (n4.type === "group-container") {
        P(this, it).geometry3DMap.delete(n4.userData.entityId);
        for (let u5 of n4.childrenIds.values()) this.remove(u5), n4.userData.entities2D.delete(u5);
        let a4 = n4.components[2];
        a4 && a4.focusMesh && Jr(a4.focusMesh), Jr(n4);
      } else if (n4.type === "geometry-group") {
        P(this, it).geometry3DMap.delete(n4.userData.entityId);
        for (let a4 of n4.userData.entities3D.values()) this.remove(a4), n4.userData.entities3D.delete(a4);
        Jr(n4);
      } else if (n4.type === "geometry" || n4.type === "model" || n4.type === "path") {
        let a4 = n4.components[0], u5 = n4.components[4];
        if (n4.entities2D.size > 0) {
          for (let h of n4.entities2D.values()) this.remove(h);
          n4.removeAllEntities();
        }
        if (n4.object3d && (((i = n4.parentObject3D) == null ? void 0 : i.type) === "geometry-group" && n4.parentObject3D.userData.entities3D.delete(n4.id), Jr(n4.object3d)), n4.type === "geometry") {
          let h = n4.components[3];
          h && (h.visible = false, h.dirty = true);
        }
        u5 && "focusMesh" in u5 && u5.focusMesh != null && Jr(u5.focusMesh), "textMesh" in a4 && a4.textMesh != null && this.remove(a4.textMesh.userData.entityId), P(this, it).geometry3DMap.delete(n4.id);
      } else if (n4.type === "marker" || n4.type === "label") {
        let a4 = n4.attachedTo;
        if (a4) {
          let u5 = P(this, it).geometry3DMap.get(a4);
          u5 instanceof oe && u5.detach(n4);
        }
        n4.object3d && Jr(n4.object3d), n4.type === "label" && delete P(this, nt).twoDDrawSystem.textCache[n4.id], P(this, it).geometry2DMap.delete(n4.id);
      } else if (n4.type === "image") n4.object3d && Jr(n4.object3d), P(this, it).geometry3DMap.delete(n4.id);
      else if (n4.type === "text3d") {
        Jr(n4.object3d);
        let { batchedText: a4, textMesh: u5, polygonEntityId: h } = n4.components[0];
        if (u5 && (a4 && a4.removeText(u5), Jr(u5)), h) {
          P(this, nt).text3DSystem.remove(h);
          let d = P(this, it).geometry3DMap.get(h);
          (d == null ? void 0 : d.type) === "geometry" && (d.components[0].textMesh = void 0, d.components[0].textEntityId = void 0);
        }
        P(this, it).geometry3DMap.delete(n4.id);
      }
      P(this, jr).call(this), P(this, ei).call(this), this.render();
    }
  }
  getScene() {
    return this.getState("__scene");
  }
  getThreeScene() {
    return P(this, wn);
  }
  getThreeCamera() {
    return P(this, Cn);
  }
  async setEnvironment(e) {
    if (P(this, wn)) if (e === "basic") {
      P(this, qh3) || R$1(this, qh3, S$1(this, Yi, bM).call(this));
      let n4 = await P(this, qh3);
      P(this, wn).environment = n4;
    } else P(this, wn).environment = null;
  }
  getEnvironment() {
    var e;
    return (e = P(this, wn)) != null && e.environment ? "basic" : false;
  }
  getCurrentSceneGLTF(e) {
    return P(this, nt).exporterSystem.getCurrentSceneGLTF(e);
  }
  getBoundingArea(e) {
    (P(this, nt).renderSystem.threeDdirty || P(this, nt).renderSystem.twoDdirty) && this.renderSync();
    let n4 = new Pe$3();
    if (e == null) n4.setFromObject(P(this, it).entityScene);
    else {
      let i = dt(P(this, it), e);
      if ((i == null ? void 0 : i.type) === "geometry" && (i == null ? void 0 : i.object3d) != null) {
        let a4 = i.components[0], u5 = a4 instanceof mt ? a4.geometry : void 0;
        a4.mesh instanceof _l$2 && u5 ? (u5.computeBoundingBox(), u5.boundingBox && n4.union(u5.boundingBox)) : n4.setFromObject(i.object3d);
      } else ((i == null ? void 0 : i.type) === "geometry-group" || (i == null ? void 0 : i.type) === "group-container") && (i == null ? void 0 : i.userData.entityId) != null && n4.setFromObject(i);
    }
    if (Pt$1(n4)) return Ut(n4).map(this.convert3DMapPositionToCoordinate);
  }
  hasState(e) {
    return dt(P(this, it), e) != null;
  }
  getState(e) {
    var i, a4, u5, h, d, m5, v3, x2, S4, I3;
    if (e == null) return { type: "map-view", hoverColor: P(this, it).hoverColor, text3dHoverColor: P(this, it).text3dHoverColor };
    let n4 = dt(P(this, it), e);
    if ((n4 == null ? void 0 : n4.type) === "custom-geometry") {
      let w3 = n4.components[0], E4 = n4.components[1];
      return { id: n4.id, type: "custom-geometry", visible: E4.visible, altitude: E4.altitude, parent: (i = n4.parentObject3D) == null ? void 0 : i.userData.entityId, position: this.convert3DMapPositionToCoordinate(w3.position) };
    } else if ((n4 == null ? void 0 : n4.type) === "geometry-group") {
      let w3 = [];
      for (let T3 of n4.userData.entities3D.values()) {
        let D4 = this.getState(T3);
        ((D4 == null ? void 0 : D4.type) === "geometry" || (D4 == null ? void 0 : D4.type) === "model") && w3.push(D4);
      }
      let E4 = n4.components[0];
      return { id: n4.userData.entityId, type: "geometry-group", visible: n4.visible, opacity: E4.opacity, color: E4.color, initialColor: E4.initialColor, height: E4.height, altitude: n4.altitude, topColor: E4.topColor, outline: E4.outline, shading: E4.shading, texture: E4.texture, topTexture: E4.topTexture, interactive: Array.from(n4.userData.entities3D.values()).map((T3) => P(this, it).geometry3DMap.get(T3)).every((T3) => T3 && T3.components[2] != null), children: Array.from(n4.userData.entities3D.values()).map((T3) => this.getState(T3)).filter(Boolean) };
    } else {
      if ((n4 == null ? void 0 : n4.type) === "group-container") return { id: n4.userData.entityId, type: "group-container", visible: n4.visible, altitude: n4.altitude, opacity: n4.opacity, interactive: !!n4.components[1], children: Array.from(n4.childrenIds.values()).map((w3) => this.getState(w3)).filter(Boolean) };
      if ((n4 == null ? void 0 : n4.type) === "label") {
        let w3 = n4.components[0], E4 = n4.object3d.parent, T3 = E4 == null ? void 0 : E4.userData.entityId;
        return { id: n4.id, type: "label", text: w3.text || "", parent: { id: T3, type: E4 == null ? void 0 : E4.type }, position: this.convert3DMapPositionToCoordinate(n4.position), enabled: w3.enabled, visible: w3.visible, initialRank: hy(w3.initialRank), options: { rank: hy(w3.rank), appearance: w3.appearance, interactive: n4.components[1] != null, verticalOffset: n4.verticalOffset, attachTo: n4.attachedTo } };
      } else if ((n4 == null ? void 0 : n4.type) === "marker") {
        let w3 = n4.components[0], E4 = n4.object3d.parent, T3 = E4 == null ? void 0 : E4.userData.entityId;
        return { id: n4.id, type: "marker", enabled: w3.enabled, visible: w3.visible, anchor: w3.options.anchor, dynamicResize: w3.options.dynamicResize, parent: { id: T3, type: E4 == null ? void 0 : E4.type }, position: this.convert3DMapPositionToCoordinate(n4.position), element: w3.containerEl, initialRank: hy(w3.initialRank), contentHTML: w3.contentHtml, options: { rank: hy(w3.rank), interactive: n4.components[1] != null || false, verticalOffset: n4.verticalOffset, attachTo: n4.attachedTo, lowPriorityPin: w3.options.lowPriorityPin } };
      } else if ((n4 == null ? void 0 : n4.type) === "geometry") {
        let { color: w3, hoverColor: E4, initialColor: T3, initialTopColor: D4, topColor: A3, altitude: L3 } = n4.components[1], B3 = n4.components[0], j3 = n4.components[2], W4 = n4.components[1], $5 = n4.components[2], F3 = n4.components[3], J4 = n4.parentObject3D;
        return { id: n4.id, type: "geometry", opacity: W4.opacity, initialColor: T3, color: w3, focusable: j3 != null && j3.focusMesh != null, initialTopColor: D4, topColor: A3, hoverColor: E4, hovered: !!($5 != null && $5.hover), height: W4.height, visible: W4.visible, outline: F3 == null ? void 0 : F3.visible, showImage: W4.showImage, texture: W4.texture, topTexture: W4.topTexture, flipImageToFaceCamera: W4.flipImageToFaceCamera, parent: { id: J4 == null ? void 0 : J4.userData.entityId, type: J4 == null ? void 0 : J4.type }, altitude: L3, position: this.convert3DMapPositionToCoordinate(B3.position), interactive: n4.components[2] != null };
      } else if ((n4 == null ? void 0 : n4.type) === "model") {
        let w3 = n4.components[0], E4 = n4.components[1], T3 = n4.components[2];
        return { id: n4.id, type: "model", position: w3.mesh ? this.convert3DMapPositionToCoordinate((a4 = w3.mesh) == null ? void 0 : a4.getWorldPosition(new I$1())) : this.convert3DMapPositionToCoordinate(w3.position), interactive: T3 != null, material: E4.material, parent: (u5 = n4.parentObject3D) != null && u5.parent ? { id: n4.parentObject3D.parent.userData.entityId, type: n4.parentObject3D.parent.type } : void 0, visible: E4.visible, verticalOffset: E4.verticalOffset, color: E4.color, opacity: E4.opacity, rotation: (h = E4.rotation) != null ? h : nr, scale: (d = E4.scale) != null ? d : rr };
      } else if ((n4 == null ? void 0 : n4.type) === "path") {
        let w3 = n4.components[0], E4 = n4.components[2], T3 = n4.components[1];
        return { id: n4.id, type: "path", position: this.convert3DMapPositionToCoordinate(w3.position), visible: T3.visible, interactive: E4 != null, completeFraction: w3.completeFraction, color: T3.color, accentColor: w3.accentColor, nearRadius: w3.nearRadius, farRadius: w3.farRadius, animateArrowsOnPath: w3.animateArrowsOnPath, displayArrowsOnPath: w3.displayArrowsOnPath, nearZoomLevel: w3.nearZoomLevel, farZoomLevel: w3.farZoomLevel, altitude: T3.altitude };
      } else if ((n4 == null ? void 0 : n4.type) === "image") {
        let w3 = n4.components[0];
        return { id: n4.id, type: "image", position: this.convert3DMapPositionToCoordinate(w3.position), visible: n4.components[1].visible, verticalOffset: (m5 = w3.feature.properties.verticalOffset) != null ? m5 : 0, flipImageToFaceCamera: n4.components[1].flipImageToFaceCamera };
      } else if ((n4 == null ? void 0 : n4.type) === "text3d" && n4.components[0] instanceof Ec2 && "textArea" in n4.components[0].feature.properties) {
        dO(n4);
        let w3 = n4.components[0], E4 = n4.components[1], { textMesh: T3 } = w3, D4 = (v3 = w3.mesh) == null ? void 0 : v3.parent;
        D4 instanceof z && ((x2 = D4.children.find((B3) => B3.type === "batchedtext")) == null || x2.getWorldPosition(P(this, _1))), P(this, mm2).set(0, 0, 0);
        let A3 = T3 ? T3.getWorldPosition(P(this, mm2)) : P(this, mm2);
        return Object.assign({}, vt, E4.getState(), { id: n4.id, type: "text3d", position: this.convert3DMapPositionToCoordinate(A3.add(P(this, _1))), visible: (S4 = w3.visible) != null ? S4 : false, content: (I3 = w3.feature.properties.content) != null ? I3 : "" });
      } else return;
    }
  }
  setState(e, n4) {
    var a4, u5;
    if (typeof e == "object" && n4 == null) {
      "hoverColor" in e && (ue(e.hoverColor) ? P(this, it).hoverColor = (a4 = e.hoverColor) != null ? a4 : P(this, it).hoverColor : B.warn('Failed to update global hover color. Invalid color "'.concat(e.hoverColor, '".'))), "text3dHoverColor" in e && (P(this, it).text3dHoverColor = (u5 = e.text3dHoverColor) != null ? u5 : P(this, it).text3dHoverColor);
      return;
    }
    let i = dt(P(this, it), e);
    if (i != null) {
      if (i.type === "custom-geometry") {
        let h = P(this, it).geometry3DMap.get(i.id);
        if (h instanceof oe && h.components[0] instanceof lm) {
          let d = n4;
          ml(i, P(this, it), d.visible), tm2(i, d.altitude), aI(i, d.position, this.convertTo3DMapPosition), lI(i, this.getParentContainer(d.parent, false)), Ei(i, d.interactive, P(this, it)) && P(this, jr).call(this);
        }
      } else if (i.type === "path") {
        let h = n4;
        Ei(i, h.interactive, P(this, it)) && P(this, jr).call(this), tm2(i, h.altitude), fO(i, P(this, it), h);
      } else if (i.type === "model") {
        let h = n4;
        Ei(i, h.interactive, P(this, it)) && P(this, jr).call(this), ml(i, P(this, it), h.visible), gO(i, h);
      } else if (i.type === "group-container") {
        let h = n4;
        ml(i, P(this, it), h.visible) && (P(this, nt).outlineInterpolationSystem.outlineOpacitiesDirty = true, P(this, nt).pathSystem.altitudeDirty = true, P(this, nt).geometryInFocusSystem.focusablesDirty = true), tm2(i, h.altitude) && (P(this, nt).pathSystem.altitudeDirty = true), Ei(i, h.interactive, P(this, it)) && P(this, jr).call(this), cI(i, P(this, it), h.opacity) && (P(this, nt).outlineInterpolationSystem.outlineOpacitiesDirty = true), h.preloadGeometry && i.userData.preloadGeometry !== true && (i.userData.preloadGeometry = true, P(this, nt).outlineInterpolationSystem.geometries3DDirty = true), tx2(i, h.focusable) && (P(this, nt).geometryInFocusSystem.focusablesDirty = true);
      } else if (i.type === "geometry-group") {
        let h = n4;
        ml(i, P(this, it), h.visible) && (P(this, nt).outlineInterpolationSystem.outlineOpacitiesDirty = true), Q8(i, P(this, it), h), Qb(i, P(this, it), h.outline), h.height != null && oI(i, P(this, it), h.height), tm2(i, h.altitude), uO(i, h), tO(i, h.shading), cI(i, P(this, it), h.opacity) && (P(this, nt).outlineInterpolationSystem.outlineOpacitiesDirty = true), Ei(i, h.interactive, P(this, it)) && (P(this, jr).call(this), P(this, ei).call(this));
      } else if (i.type === "geometry") {
        if (i.components[0] instanceof mt) {
          let h = n4;
          ml(i, P(this, it), h.visible) && (P(this, nt).outlineInterpolationSystem.outlineOpacitiesDirty = true), Qb(i, P(this, it), h.outline), eO(i, h), tx2(i, h.focusable) && (P(this, nt).geometryInFocusSystem.focusablesDirty = true), hO(i, h.renderOrder) && (P(this, nt).meshDetachmentSystem.dirty = true), pO(i, h.opacity) && (P(this, nt).meshDetachmentSystem.dirty = true, P(this, nt).interactionSystem.dirty3D = true, P(this, nt).outlineInterpolationSystem.outlineOpacitiesDirty = true), uI(i, h.flipImageToFaceCamera), tm2(i, h.altitude), h.height != null && oI(i, P(this, it), h.height), cO(i, h) && (P(this, nt).meshDetachmentSystem.dirty = true), sI(i, h), sO(i, h.hoverColor), Ei(i, h.interactive, P(this, it)), aO(i, h.hovered);
        }
        P(this, jr).call(this);
      } else if (i.type === "label" || i.type === "marker") {
        let h = n4;
        oO(i, n4, P(this, it)), nO(i, n4, P(this, it)) && (P(this, ei).call(this), P(this, nt).domMutationSystem.dirty = true), aI(i, h.position, this.convertTo3DMapPosition), lI(i, this.getParentContainer(h.parent, false)) && (P(this, ei).call(this), P(this, nt).panBoundsSystem.dirty = true), rO(i, h.enabled), ml(i, P(this, it), h.visible);
      } else if (i.type === "image") {
        let h = n4;
        ml(i, P(this, it), h.visible), uI(i, h.flipImageToFaceCamera);
      } else if (i.type === "text3d") {
        let h = n4;
        mO(i, P(this, it), h);
      }
      this.render();
    }
  }
  convertTo3DMapPosition(e, n4, i = 0, a4) {
    var d, m5, v3, x2, S4;
    if (Array.isArray(e)) return this.convertTo3DMapPosition(e[1], e[0], (d = e[2]) != null ? d : i, typeof n4 == "function" ? n4 : void 0);
    if (typeof n4 != "number") throw new Error("convertTo3DMapPosition failed: longitude must be a number");
    let { x: u5, y: h } = Mi$1((v3 = (m5 = P(this, it).center) == null ? void 0 : m5[1]) != null ? v3 : 0, (S4 = (x2 = P(this, it).center) == null ? void 0 : x2[0]) != null ? S4 : 0, e, n4);
    return a4 ? (a4.set(u5, h, i), a4) : new I$1(u5, h, i);
  }
  get backgroundColor() {
    return typeof P(this, Oi2).backgroundColor == "string" ? P(this, Oi2).backgroundColor : "#".concat(P(this, Oi2).backgroundColor.getHexString());
  }
  get backgroundAlpha() {
    return P(this, Oi2).backgroundAlpha;
  }
  getThreeRenderer() {
    return P(this, Oi2);
  }
  getCenter(e) {
    let n4 = Array.isArray(e) ? e : this.getBoundingArea(e);
    return n4 ? Ii(n4) : void 0;
  }
  isInView(e) {
    let n4 = dt(P(this, it), e);
    if (P(this, b1).identity().multiply(P(this, Cn).projectionMatrix).multiply(P(this, Cn).matrixWorldInverse), P(this, Zh3).setFromProjectionMatrix(P(this, b1)), n4 instanceof ne) return P(this, Zh3).containsPoint(n4.position);
    if (n4 instanceof oe) {
      let i = n4 == null ? void 0 : n4.components[0];
      if (i instanceof lm || i instanceof Ac2) return P(this, Zh3).containsPoint(this.convertTo3DMapPosition(i.feature.geometry.coordinates));
      if (i instanceof mt) {
        let a4 = new Pe$3(this.convertTo3DMapPosition(i.featureBbox[1], i.featureBbox[0], 0), this.convertTo3DMapPosition(i.featureBbox[3], i.featureBbox[2], 0));
        return P(this, Zh3).intersectsBox(a4);
      }
    }
    return false;
  }
  getSystems() {
    return P(this, nt);
  }
  getInternalState() {
    return P(this, it);
  }
  getInternalTweenGroup() {
    return P(this, it).internalTweenGroup;
  }
  getExternalTweenGroup() {
    return P(this, it).externalTweenGroup;
  }
  computeMinZOffsetBetweenContainers(e, n4, i) {
    if (!e || !n4) return -1;
    _r(e, "group-container"), _r(n4, "group-container");
    let a4 = ki(e, this.getThreeCamera()), u5 = n4.clone(), h = ki(u5, this.getThreeCamera());
    if (!Pt$1(a4) || !Pt$1(h)) return -1;
    let d = 0, m5;
    i && this.container.querySelectorAll(".debug-box").forEach((x2) => x2.remove());
    do {
      if (d > 1e4) return -1;
      if (d += 20, u5.position.z = d, u5.updateMatrixWorld(), h.makeEmpty(), ki(u5, P(this, Cn), h), m5 = a4.intersectsBox(h), i) {
        let v3 = Gi(a4, "blue", this.container), x2 = Gi(h, m5 ? "red" : "green", this.container);
        v3.classList.add("debug-box"), x2.classList.add("debug-box");
      }
    } while (m5);
    return d;
  }
};
wn = /* @__PURE__ */ new WeakMap(), Cn = /* @__PURE__ */ new WeakMap(), qh3 = /* @__PURE__ */ new WeakMap(), p1 = /* @__PURE__ */ new WeakMap(), pm2 = /* @__PURE__ */ new WeakMap(), Gc2 = /* @__PURE__ */ new WeakMap(), Wh3 = /* @__PURE__ */ new WeakMap(), hm2 = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakSet(), yM = H$3(function(e) {
  var n4;
  P(this, Su) !== "outdoors-overlay" && ((n4 = this.map) == null || n4.setPixelRatio(e)), P(this, it).pixelRatio = this.resolutionScale;
}, "#setResolutionScale"), it = /* @__PURE__ */ new WeakMap(), Vr = /* @__PURE__ */ new WeakMap(), va2 = /* @__PURE__ */ new WeakMap(), Pn = /* @__PURE__ */ new WeakMap(), xl = /* @__PURE__ */ new WeakMap(), Oi2 = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap(), h1 = /* @__PURE__ */ new WeakMap(), ei = /* @__PURE__ */ new WeakMap(), jr = /* @__PURE__ */ new WeakMap(), dD = H$3(function() {
  R$1(this, Vr, document.createElement("div")), P(this, Vr).classList.add("mappedin__smart-collision-engine__container"), R$1(this, va2, document.createElement("canvas")), P(this, va2).classList.add("mappedin__smart-collision-engine-debug__container"), this.container.appendChild(P(this, Vr)), R$1(this, Pn, document.createElement("canvas")), P(this, Pn).classList.add("mappedin__smart-collision-engine__container"), P(this, Pn).width = P(this, Vr).clientWidth * this.resolutionScale, P(this, Pn).height = P(this, Vr).clientHeight * this.resolutionScale, P(this, Pn).style.width = P(this, Vr).clientWidth + "px", P(this, Pn).style.height = P(this, Vr).clientHeight + "px", P(this, Vr).appendChild(P(this, va2)), P(this, Vr).appendChild(P(this, Pn)), P(this, va2).width = P(this, Vr).clientWidth, P(this, va2).height = P(this, Vr).clientHeight, P(this, Pn).width = P(this, Vr).clientWidth * this.resolutionScale, P(this, Pn).height = P(this, Vr).clientHeight * this.resolutionScale, P(this, Pn).style.width = P(this, Vr).clientWidth + "px", P(this, Pn).style.height = P(this, Vr).clientHeight + "px";
}, "#renderEntity2DContainer"), mD = H$3(function() {
  R$1(this, xl, document.createElement("div")), P(this, xl).classList.add("mappedin-2d-entities"), Object.assign(P(this, xl).style, { position: "absolute", top: "0", left: "0", bottom: "0", right: "0", pointerEvents: "none", "transform-style": "preserve-3d" }), this.container.appendChild(P(this, xl));
}, "#renderEntityDOMContainer"), gD = H$3(function() {
  P(this, Pn).width = P(this, Vr).clientWidth * this.resolutionScale, P(this, Pn).height = P(this, Vr).clientHeight * this.resolutionScale, P(this, Pn).style.width = P(this, Vr).clientWidth + "px", P(this, Pn).style.height = P(this, Vr).clientHeight + "px", P(this, va2).width = P(this, Vr).clientWidth, P(this, va2).height = P(this, Vr).clientHeight, P(this, Pn).width = P(this, Vr).clientWidth * this.resolutionScale, P(this, Pn).height = P(this, Vr).clientHeight * this.resolutionScale, P(this, Pn).style.width = P(this, Vr).clientWidth + "px", P(this, Pn).style.height = P(this, Vr).clientHeight + "px", P(this, nt).collisionSystem.collidersDirty = true;
}, "#resizeCollisionCanvas"), Su = /* @__PURE__ */ new WeakMap(), a2 = /* @__PURE__ */ new WeakMap(), f1 = /* @__PURE__ */ new WeakMap(), d1 = /* @__PURE__ */ new WeakMap(), m1 = /* @__PURE__ */ new WeakMap(), fm2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), g1 = /* @__PURE__ */ new WeakMap(), y1 = /* @__PURE__ */ new WeakMap(), v1 = /* @__PURE__ */ new WeakMap(), dm2 = /* @__PURE__ */ new WeakMap(), vM = H$3(function(e, n4, i, a4) {
  let u5 = new ne(n4, this.convertTo3DMapPosition(e[1], e[0], e[2] || 0), a4);
  return u5.occluderId = i != null ? i : P(this, nt).occlusion2DSystem.backgroundId, P(this, it).geometry2DMap.set(u5.id, u5), u5;
}, "#createEntity2D"), Zh3 = /* @__PURE__ */ new WeakMap(), b1 = /* @__PURE__ */ new WeakMap(), x1 = /* @__PURE__ */ new WeakMap(), Oo = /* @__PURE__ */ new WeakMap(), Do = /* @__PURE__ */ new WeakMap(), bM = H$3(async function() {
  return kc2.load(J7).then((e) => {
    var n4;
    return P(this, wn) && ((n4 = P(this, wn).environment) == null || n4.dispose(), e.mapping = Na$1, P(this, wn).environment = e, this.render()), e;
  });
}, "#loadEnvMap"), mm2 = /* @__PURE__ */ new WeakMap(), _1 = /* @__PURE__ */ new WeakMap(), H$3(SM, "Core");
var gM = SM, C1 = gM;
a();
function WW(r5, t) {
  ZW(r5, t)(r5.getScene(), t), $W(r5, t), t.addFolder("Export").add({ export: H$3(async () => {
    let u5 = await r5.getCurrentSceneGLTF({ binary: true }), h = new Blob([u5], { type: "application/octet-stream" });
    var d = document.createElement("a");
    document.body.appendChild(d), d.style.display = "none";
    let m5 = window.URL.createObjectURL(h);
    d.href = m5, d.download = "scene.glb", d.click(), window.URL.revokeObjectURL(m5);
  }, "export") }, "export");
  let i = t.addFolder("Camera"), a4 = { get bearing() {
    return r5.camera.bearing;
  }, set bearing(u5) {
    r5.camera.setBearing(u5);
  }, get pitch() {
    return r5.camera.pitch;
  }, set pitch(u5) {
    r5.camera.setPitch(u5);
  }, get zoomLevel() {
    return r5.camera.zoomLevel;
  }, set zoomLevel(u5) {
    r5.camera.setZoomLevel(u5);
  } };
  i.add(a4, "bearing", -359, 359, 1), i.add(a4, "pitch", r5.camera.minPitch, r5.camera.maxPitch, 1), i.add(a4, "zoomLevel", r5.camera.minZoomLevel, r5.camera.maxZoomLevel, 0.1);
}
H$3(WW, "mountSceneGraphVisualizer");
function ZW(r5, t) {
  let e = t;
  return H$3(function n4(i, a4) {
    let u5 = a4.addFolder("".concat([i.type], " ").concat(i.id.slice(0, 16)));
    if (a4.close(), i.type === "geometry" || i.type === "model" || i.type === "path" || i.type === "image") {
      let h = { get height() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry" ? d.height : 0;
      }, set height(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry" && r5.setState(i, { height: d });
      }, set flipImageToFaceCamera(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "image" && r5.setState(i, { flipImageToFaceCamera: d });
      }, get flipImageToFaceCamera() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "image" ? d.flipImageToFaceCamera : false;
      }, set visible(d) {
        let m5 = r5.getState(i.id);
        ((m5 == null ? void 0 : m5.type) === "geometry" || (m5 == null ? void 0 : m5.type) === "path" || (m5 == null ? void 0 : m5.type) === "image") && r5.setState(i, { visible: d });
      }, get visible() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry" || (d == null ? void 0 : d.type) === "path" || (d == null ? void 0 : d.type) === "image" ? d.visible : false;
      }, set outline(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry" && r5.setState(i, { outline: d });
      }, get outline() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry" ? d.outline : false;
      }, get opacity() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry" ? d.opacity : 1;
      }, set opacity(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry" && r5.setState(m5, { opacity: d });
      }, get color() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry" && d.color ? Xt(d.color).toHexString() : "#ffffff";
      }, set color(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry" && r5.setState(m5, { color: d });
      }, set interactive(d) {
        let m5 = r5.getState(i.id);
        ((m5 == null ? void 0 : m5.type) === "geometry" || (m5 == null ? void 0 : m5.type) === "model" || (m5 == null ? void 0 : m5.type) === "path") && (r5.setState(i, { interactive: d }), e.controllersRecursive().forEach((v3) => v3.updateDisplay()));
      }, get interactive() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry" || (d == null ? void 0 : d.type) === "model" || (d == null ? void 0 : d.type) === "path" ? d.interactive : false;
      }, get completeFraction() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "path" ? d.completeFraction : 1;
      }, set completeFraction(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "path" && r5.setState(m5, { completeFraction: d });
      }, focus: H$3(() => {
      }, "focus") };
      u5.add(h, "focus").onChange(() => {
        let d = r5.getState(i.id);
        (d == null ? void 0 : d.type) === "model" || (d == null ? void 0 : d.type) === "path" || (d == null ? void 0 : d.type) === "image" ? r5.camera.focusOn([d.position]) : (d == null ? void 0 : d.type) === "geometry" && r5.camera.focusOn(r5.getBoundingArea(d));
      }), u5.add(h, "visible"), i.type === "image" ? u5.add(h, "flipImageToFaceCamera") : (u5.add(h, "interactive"), i.type === "path" && u5.add(h, "completeFraction", 0, 1, 0.1), i.type !== "model" && (u5.addColor(h, "color"), u5.add(h, "outline"))), i.type === "geometry" && (u5.add(h, "height"), u5.add(h, "opacity", 0, 1, 0.1));
    } else if (i.type === "marker") {
      let h = { get interactive() {
        var m5;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "marker" ? (m5 = d.options) == null ? void 0 : m5.interactive : false;
      }, set interactive(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "marker" && (r5.setState(m5, { options: { interactive: d } }), e.controllersRecursive().forEach((v3) => v3.updateDisplay()));
      }, focus: H$3(() => {
      }, "focus") };
      u5.add(h, "focus").onChange(() => {
        let d = r5.getState(i.id);
        (d == null ? void 0 : d.type) === "marker" && r5.camera.focusOn([d.position]);
      }), u5.add(h, "interactive");
    } else if (i.type === "label") {
      let h = { get interactive() {
        var m5;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (m5 = d.options) == null ? void 0 : m5.interactive : false;
      }, set interactive(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && (r5.setState(m5, { options: { interactive: d } }), e.controllersRecursive().forEach((v3) => v3.updateDisplay()));
      }, get text() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? d.text : "";
      }, set text(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(m5, { text: d });
      }, get "Text Color"() {
        var m5, v3;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (v3 = (m5 = d.options.appearance) == null ? void 0 : m5.text) == null ? void 0 : v3.foregroundColor : "#000000";
      }, set "Text Color"(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(i.id, { text: h.text, options: { appearance: { text: { foregroundColor: d } } } });
      }, get "Text Size"() {
        var m5, v3;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (v3 = (m5 = d.options.appearance) == null ? void 0 : m5.text) == null ? void 0 : v3.size : 10;
      }, set "Text Size"(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(m5, { text: h.text, options: { appearance: { text: { size: d } } } });
      }, get "Icon Size"() {
        var m5, v3;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (v3 = (m5 = d.options.appearance) == null ? void 0 : m5.marker) == null ? void 0 : v3.iconSize : 10;
      }, set "Icon Size"(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(m5, { text: h.text, options: { appearance: { marker: { iconSize: d } } } });
      }, get "Active Foreground Color"() {
        var m5, v3, x2;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (x2 = (v3 = (m5 = d.options.appearance) == null ? void 0 : m5.marker) == null ? void 0 : v3.foregroundColor) == null ? void 0 : x2.active : "#000000";
      }, set "Active Foreground Color"(d) {
        var v3, x2;
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(m5, { text: h.text, options: { appearance: { marker: { foregroundColor: G$1(F$1({}, (x2 = (v3 = m5.options.appearance) == null ? void 0 : v3.marker) == null ? void 0 : x2.foregroundColor), { active: d }) } } } });
      }, get "Inactive Foreground Color"() {
        var m5, v3, x2;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (x2 = (v3 = (m5 = d.options.appearance) == null ? void 0 : m5.marker) == null ? void 0 : v3.foregroundColor) == null ? void 0 : x2.inactive : "#000000";
      }, set "Inactive Foreground Color"(d) {
        var v3, x2;
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(m5, { text: h.text, options: { appearance: { marker: { foregroundColor: G$1(F$1({}, (x2 = (v3 = m5.options.appearance) == null ? void 0 : v3.marker) == null ? void 0 : x2.foregroundColor), { inactive: d }) } } } });
      }, get "Active Background Color"() {
        var m5, v3, x2;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (x2 = (v3 = (m5 = d.options.appearance) == null ? void 0 : m5.marker) == null ? void 0 : v3.backgroundColor) == null ? void 0 : x2.active : "#000000";
      }, set "Active Background Color"(d) {
        var v3, x2;
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(m5, { text: h.text, options: { appearance: { marker: { backgroundColor: G$1(F$1({}, (x2 = (v3 = m5.options.appearance) == null ? void 0 : v3.marker) == null ? void 0 : x2.backgroundColor), { active: d }) } } } });
      }, get "Inactive Background Color"() {
        var m5, v3, x2;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "label" ? (x2 = (v3 = (m5 = d.options.appearance) == null ? void 0 : m5.marker) == null ? void 0 : v3.backgroundColor) == null ? void 0 : x2.inactive : "#000000";
      }, set "Inactive Background Color"(d) {
        var v3, x2;
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "label" && r5.setState(m5, { text: h.text, options: { appearance: { marker: { backgroundColor: G$1(F$1({}, (x2 = (v3 = m5.options.appearance) == null ? void 0 : v3.marker) == null ? void 0 : x2.backgroundColor), { inactive: d }) } } } });
      }, focus: H$3(() => {
      }, "focus") };
      u5.add(h, "focus").onChange(() => {
        let d = r5.getState(i.id);
        (d == null ? void 0 : d.type) === "label" && r5.camera.focusOn([d.position]);
      }), u5.add(h, "interactive"), u5.add(h, "text"), u5.add(h, "Text Size", 10, 50), u5.add(h, "Icon Size", 10, 50), u5.addColor(h, "Text Color"), u5.addColor(h, "Active Background Color"), u5.addColor(h, "Inactive Background Color"), u5.addColor(h, "Active Foreground Color"), u5.addColor(h, "Inactive Foreground Color");
    } else if (i.type === "geometry-group") {
      let h = { get opacity() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" ? d.opacity : 1;
      }, set opacity(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && r5.setState(i, { opacity: d });
      }, set visible(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && r5.setState(i, { visible: d });
      }, get visible() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" ? d.visible : false;
      }, set outline(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && r5.setState(i, { outline: d });
      }, get outline() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" ? d.outline : false;
      }, set altitude(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && r5.setState(i, { altitude: d });
      }, get altitude() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" ? d.altitude : 0;
      }, set interactive(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && (r5.setState(i, { interactive: d }), e.controllersRecursive().forEach((v3) => v3.updateDisplay()));
      }, get interactive() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" ? d.interactive : false;
      }, get shadingStart() {
        var m5, v3;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" && (v3 = (m5 = d.shading) == null ? void 0 : m5.start) != null ? v3 : 0;
      }, set shadingStart(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && r5.setState(m5, { shading: { start: d } });
      }, get shadingEnd() {
        var m5, v3;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" && (v3 = (m5 = d.shading) == null ? void 0 : m5.end) != null ? v3 : 0;
      }, set shadingEnd(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && r5.setState(m5, { shading: { end: d } });
      }, get shadingIntensity() {
        var m5, v3;
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "geometry-group" && (v3 = (m5 = d.shading) == null ? void 0 : m5.intensity) != null ? v3 : 0;
      }, set shadingIntensity(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "geometry-group" && r5.setState(m5, { shading: { intensity: d } });
      } };
      u5.add(h, "visible"), u5.add(h, "opacity", 0, 1, 0.1), u5.add(h, "interactive"), u5.add(h, "outline"), u5.add(h, "altitude", 0, 100, 1), u5.add(h, "shadingStart", 0, 1, 0.1), u5.add(h, "shadingEnd", 0, 1, 0.1), u5.add(h, "shadingIntensity", 0, 1, 0.1);
    } else if (i.type === "group-container") {
      let h = { set visible(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "group-container" && r5.setState(i, { visible: d });
      }, get visible() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "group-container" ? d.visible : false;
      }, set interactive(d) {
        let m5 = r5.getState(i.id);
        (m5 == null ? void 0 : m5.type) === "group-container" && (r5.setState(m5, { interactive: d }), e.controllersRecursive().forEach((v3) => v3.updateDisplay()));
      }, get interactive() {
        let d = r5.getState(i.id);
        return (d == null ? void 0 : d.type) === "group-container" ? d.interactive : false;
      } };
      u5.add(h, "visible"), u5.add(h, "interactive");
    }
    if (u5.close(), i.children) for (let h of i.children.values()) n4(h, u5);
  }, "parseChild");
}
H$3(ZW, "createParseChild");
function $W(r5, t) {
  let e = t.addFolder("Watermark"), n4 = { padding: 16, iconOnly: false, position: "bottom-left", color: "dark", scale: 1 };
  e.add(n4, "padding", 0, 100, 1), e.add(n4, "scale", 0.5, 1.5, 0.1), e.add(n4, "color", ["dark", "light"]), e.add(n4, "position", ["top-left", "top-right", "bottom-left", "bottom-right", "center", "top", "bottom", "left", "right"]), e.add(n4, "iconOnly"), e.onChange(() => {
    r5.updateWatermark(n4);
  });
}
H$3($W, "createWatermarkChild");
a();
a();
a();
a();
a();
a();
var IM = class IM2 {
  constructor({ origin: t, destination: e, distance: n4 = 0, angle: i = 0, pathWeight: a4 = 0, multiplicativeDistanceWeightScaling: u5 = true }) {
    O(this, "origin");
    O(this, "destination");
    O(this, "distance");
    O(this, "angle");
    O(this, "weight");
    if (this.origin = t, this.destination = e, this.distance = n4, this.angle = i, this.weight = a4 || 0, u5 ? t.properties.floor === e.properties.floor && (this.weight = (this.weight >= 0 ? this.distance * this.weight : 0) + this.distance) : t.properties.map === e.properties.map && (this.weight = this.weight >= 0 ? this.distance + this.weight : 0), isNaN(this.angle)) throw new Error("Invalid angle: Expected a numeric value, but received NaN.");
  }
};
H$3(IM, "Edge");
var $h3 = IM;
a();
a();
a();
a();
function Iu([r5, t], [e, n4]) {
  let i = t - n4, a4 = r5 - e;
  return (Math.atan2(a4, i) + Math.PI * 3) % (Math.PI * 2);
}
H$3(Iu, "getAngle");
a();
var JW = 63710088e-1;
function ps(r5, t) {
  let [e, n4] = r5.map((v3) => v3 * Math.PI / 180), [i, a4] = t.map((v3) => v3 * Math.PI / 180), u5 = a4 - n4, h = i - e, d = Math.sin(u5 / 2) * Math.sin(u5 / 2) + Math.cos(n4) * Math.cos(a4) * Math.sin(h / 2) * Math.sin(h / 2), m5 = 2 * Math.atan2(Math.sqrt(d), Math.sqrt(1 - d));
  return JW * m5;
}
H$3(ps, "getDistance");
a();
a();
function u2(r5, t, e, n4) {
  let [i, a4] = r5, [u5, h] = t, [d, m5] = e, [v3, x2] = n4;
  if (a4 === h && i === u5 || m5 === x2 && d === v3) return null;
  let S4 = (v3 - d) * (h - a4) - (x2 - m5) * (u5 - i);
  if (S4 === 0) return null;
  let I3 = ((x2 - m5) * (i - d) - (v3 - d) * (a4 - m5)) / S4, w3 = ((h - a4) * (i - d) - (u5 - i) * (a4 - m5)) / S4;
  if (I3 < 0 || I3 > 1 || w3 < 0 || w3 > 1) return null;
  let E4 = a4 + I3 * (h - a4);
  return [i + I3 * (u5 - i), E4];
}
H$3(u2, "getLineIntersection");
a();
function MM(r5, t, e, n4) {
  let i = ss(r5, e / 1e3, n4), a4 = ss(t, e / 1e3, n4);
  return [i.geometry.coordinates, a4.geometry.coordinates];
}
H$3(MM, "getOffsetLine");
a();
function TM(r5) {
  let t = r5 * (180 / Math.PI);
  return t = t % 360, t > 180 ? t -= 360 : t < -180 && (t += 360), Object.is(t, -0) ? 0 : t;
}
H$3(TM, "radToDegNormalized");
var yD = 111e3;
function wM(r5, t, e = [], n4 = 0) {
  let i = true, a4 = r5.geometry.coordinates, u5 = t.geometry.coordinates, h = TM(Iu(a4, u5) - Math.PI / 2), d = TM(Iu(a4, u5) + Math.PI / 2), m5 = n4 / yD, v3 = n4 / (yD * Math.cos(a4[1] * Math.PI / 180)), x2 = Math.min(a4[1], u5[1]) - m5, S4 = Math.max(a4[1], u5[1]) + m5, I3 = Math.min(a4[0], u5[0]) - v3, w3 = Math.max(a4[0], u5[0]) + v3;
  for (let E4 of e) if (!(Math.max(E4[0][1], E4[1][1]) < x2 || Math.min(E4[0][1], E4[1][1]) > S4 || Math.max(E4[0][0], E4[1][0]) < I3 || Math.min(E4[0][0], E4[1][0]) > w3)) {
    if (n4 > 0) {
      let T3 = MM(a4, u5, n4, h), D4 = MM(a4, u5, n4, d);
      if (u2(T3[0], T3[1], E4[0], E4[1]) || u2(D4[0], D4[1], E4[0], E4[1])) {
        i = false;
        return;
      }
    } else if (u2(a4, u5, E4[0], E4[1])) {
      i = false;
      return;
    }
  }
  return i;
}
H$3(wM, "hasLineOfSight");
var Jh3, qi, PM, vD, bD, xD, _D, CD, SD, p2, EM = class EM2 {
  constructor({ nodes: t, groupBy: e, multiplicativeDistanceWeightScaling: n4 }) {
    Q$3(this, qi);
    O(this, "edges", {});
    O(this, "nodesById");
    O(this, "nodesByGroup", /* @__PURE__ */ new Map());
    Q$3(this, Jh3);
    Q$3(this, p2, H$3((t5, e4) => {
      let n5 = 0;
      for (let i5 of e4) (!i5[P(this, Jh3)] || i5[P(this, Jh3)] === t5.properties[P(this, Jh3)]) && cn$1(t5.geometry.coordinates, i5.geometry.geometry) && (n5 += Math.max(0, i5.cost));
      return n5;
    }, "#getZonalCost"));
    R$1(this, Jh3, e);
    let { features: i } = t;
    this.nodesById = S$1(this, qi, vD).call(this, i), S$1(this, qi, bD).call(this), S$1(this, qi, xD).call(this, i, e, { multiplicativeDistanceWeightScaling: n4 });
  }
  getShortestEuclideanDistance(t, e) {
    return e.reduce((n4, i) => {
      let a4 = ps(t.geometry.coordinates, i.geometry.coordinates);
      return Math.min(n4, a4);
    }, Number.MAX_VALUE);
  }
  aStar({ originIds: t, destinationNodeIds: e, excludedNodeIds: n4, disabledConnectionNodeIds: i, zones: a4, overrideEdgeWeights: u5 }) {
    var S4;
    let h = S$1(this, qi, PM).call(this, t), d = S$1(this, qi, PM).call(this, e);
    if (h.length === 0 || d.length === 0) return [];
    let { frontier: m5, cameFrom: v3, costSoFar: x2 } = S$1(this, qi, _D).call(this, h, d);
    for (; m5.length > 0; ) {
      let I3 = m5.shift();
      if (!I3) break;
      if (S$1(this, qi, CD).call(this, I3.origin, d)) return S$1(this, qi, SD).call(this, v3, I3.origin.properties.id);
      for (let w3 of this.edges[I3.origin.properties.id]) {
        let E4 = (S4 = u5 == null ? void 0 : u5.get(w3)) != null ? S4 : w3.weight;
        if (i != null && i.has(w3.origin.properties.id) && w3.destination.properties.map !== w3.origin.properties.map) continue;
        let T3 = x2[I3.origin.properties.id] + E4 + P(this, p2).call(this, w3.destination, a4);
        if (!(T3 === 1 / 0 || n4 != null && n4.has(w3.destination.properties.id)) && (x2[w3.destination.properties.id] == null || T3 < x2[w3.destination.properties.id])) {
          let D4 = T3 + this.getShortestEuclideanDistance(w3.destination, d);
          x2[w3.destination.properties.id] = T3, v3[w3.destination.properties.id] = w3, m5.push({ origin: w3.destination, priority: D4 });
        }
      }
      m5.sort((w3, E4) => w3.priority - E4.priority);
    }
    return [];
  }
};
Jh3 = /* @__PURE__ */ new WeakMap(), qi = /* @__PURE__ */ new WeakSet(), PM = H$3(function(t) {
  return t.map((e) => this.nodesById[e]).filter(Boolean);
}, "#filterValidNodes"), vD = H$3(function(t) {
  return t.reduce((e, n4) => (e[n4.properties.id] = n4, e), {});
}, "#createNodesById"), bD = H$3(function() {
  for (let t in this.nodesById) this.nodesById.hasOwnProperty(t) && (this.nodesById[t].properties.neighbors = this.nodesById[t].properties.neighbors.filter(({ id: e }) => !!this.nodesById[e]));
}, "#removeInvalidNeighbors"), xD = H$3(function(t, e, n4) {
  t.forEach((i) => {
    let a4 = e === "default" ? e : i.properties[e];
    this.nodesByGroup.has(a4) || this.nodesByGroup.set(a4, []), this.nodesByGroup.get(a4).push(i), this.edges[i.properties.id] = i.properties.neighbors.map(({ id: u5, weight: h }) => {
      let d = this.nodesById[u5], m5 = ps(i.geometry.coordinates, d.geometry.coordinates), v3 = Iu(i.geometry.coordinates, d.geometry.coordinates);
      return new $h3({ origin: i, destination: d, pathWeight: h, distance: m5, angle: v3, multiplicativeDistanceWeightScaling: n4 == null ? void 0 : n4.multiplicativeDistanceWeightScaling });
    });
  });
}, "#initializeEdgesAndGroups"), _D = H$3(function(t, e) {
  let n4 = [], i = {}, a4 = {};
  return t.forEach((u5) => {
    let h = this.getShortestEuclideanDistance(u5, e);
    n4.push({ origin: u5, priority: h }), i[u5.properties.id] = null, a4[u5.properties.id] = 0;
  }), n4.sort((u5, h) => u5.priority - h.priority), { frontier: n4, cameFrom: i, costSoFar: a4 };
}, "#initializeSearch"), CD = H$3(function(t, e) {
  return e.some((n4) => n4.properties.id === t.properties.id);
}, "#isDestinationNode"), SD = H$3(function(t, e) {
  let n4 = [], i = t[e];
  for (; i; ) n4.push(i), i = t[i.origin.properties.id];
  return n4.reverse();
}, "#reconstructPath"), p2 = /* @__PURE__ */ new WeakMap(), H$3(EM, "NavigationGraph");
var c2 = EM;
var ID = 0.4, OM = class OM2 {
  constructor({ nodes: t, geojsonCollection: e, groupBy: n4 = "default", multiplicativeDistanceWeightScaling: i }) {
    O(this, "groupBy");
    O(this, "graph");
    O(this, "geometryEdgesByMapId", /* @__PURE__ */ new Map());
    O(this, "generatePath", H$3((t5) => {
      let { destination: e4 } = t5[t5.length - 1], n5 = { type: "FeatureCollection", features: [] };
      for (let a4 = 0; a4 < t5.length; a4++) {
        let { origin: u5, destination: h } = t5[a4], d = { id: u5.properties.id, angle: t5[a4].angle, distance: t5[a4].distance, destination: h.properties.id, edges: this.graph.edges[u5.properties.id] };
        this.groupBy !== "default" && (d.groupBy = u5.properties[this.groupBy]), n5.features.push({ type: "Feature", geometry: { type: "Point", coordinates: [u5.geometry.coordinates[0], u5.geometry.coordinates[1]] }, properties: d });
      }
      let i5 = { id: e4.properties.id, edges: this.graph.edges[e4.properties.id] };
      return this.groupBy !== "default" && (i5.groupBy = e4.properties[this.groupBy]), n5.features.push({ type: "Feature", geometry: { type: "Point", coordinates: [e4.geometry.coordinates[0], e4.geometry.coordinates[1]] }, properties: i5 }), n5;
    }, "generatePath"));
    O(this, "hasLineOfSight", H$3((t5, e4, n5, i5 = ID) => wM({ geometry: { type: "Point", coordinates: t5 } }, { geometry: { type: "Point", coordinates: e4 } }, this.geometryEdgesByMapId.get(n5), i5) === true, "hasLineOfSight"));
    O(this, "getDistance", H$3((t5, e4) => ps(t5, e4), "getDistance"));
    O(this, "getAngle", H$3((t5, e4) => Iu(t5, e4), "getAngle"));
    this.groupBy = n4, this.graph = new c2({ nodes: t, groupBy: this.groupBy, multiplicativeDistanceWeightScaling: i }), ((e == null ? void 0 : e.features) || []).forEach((u5) => {
      let h = null;
      if (u5.geometry.type === "LineString" ? h = u5.geometry.coordinates : u5.geometry.type === "Polygon" && (h = u5.geometry.coordinates.flat()), h) {
        let d = this.groupBy === "default" ? this.groupBy : u5.properties[this.groupBy];
        this.geometryEdgesByMapId.has(d) || this.geometryEdgesByMapId.set(d, []), h.forEach((m5, v3) => {
          this.geometryEdgesByMapId.get(d).push([m5, h[v3 + 1] || h[0]]);
        });
      }
    });
  }
  getDirections({ zones: t, originIds: e, destinationNodeIds: n4, excludedNodeIds: i, disabledConnectionNodeIds: a4, simplify: u5, multiplicativeDistanceWeightScaling: h, overrideEdgeWeights: d }) {
    var S4, I3;
    let m5 = (S4 = u5 == null ? void 0 : u5.enabled) != null ? S4 : true, v3 = t != null ? t : [], x2 = this.graph.aStar({ originIds: e, destinationNodeIds: n4, zones: v3, excludedNodeIds: new Set(i), disabledConnectionNodeIds: new Set(a4), overrideEdgeWeights: d });
    return x2.length === 0 ? { type: "FeatureCollection", features: [] } : (m5 && (x2 = this.simplifyAllSteps(x2, (I3 = u5 == null ? void 0 : u5.bufferRadius) != null ? I3 : ID, h)), this.generatePath(x2));
  }
  simplifyAllSteps(t, e, n4) {
    var m5, v3;
    let i = [], a4 = [t[0]];
    for (let x2 = 1; x2 < t.length; x2++) if (this.groupBy !== "default" && t[x2].origin.properties[this.groupBy] !== t[x2 - 1].origin.properties[this.groupBy]) {
      let S4 = t[x2 - 1].origin.properties[this.groupBy], I3 = (m5 = this.geometryEdgesByMapId.get(S4)) != null ? m5 : [];
      i.push(...this.simplifySteps(a4, I3, e, n4)), a4 = [t[x2]];
    } else a4.push(t[x2]);
    let u5 = t[t.length - 1], h = this.groupBy === "default" ? this.groupBy : u5.origin.properties[this.groupBy], d = (v3 = this.geometryEdgesByMapId.get(h)) != null ? v3 : [];
    return i.push(...this.simplifySteps(a4, d, e, n4)), i;
  }
  simplifySteps(t, e, n4, i) {
    if (t.length < 3) return t;
    let a4 = [t[0]], u5 = 1;
    for (let h = u5 + 2; h < t.length; h++) if (t[u5].origin.properties.preventSmoothing || !wM(t[u5].origin, t[h].origin, e, n4)) {
      let d = h - 1;
      a4.push(new $h3(G$1(F$1({}, t[u5]), { destination: t[d].origin, distance: ps(t[u5].origin.geometry.coordinates, t[d].origin.geometry.coordinates), angle: Iu(t[u5].origin.geometry.coordinates, t[d].origin.geometry.coordinates) }))), u5 = d;
    }
    return a4.push(new $h3(G$1(F$1({}, t[u5]), { destination: t[t.length - 1].origin, distance: ps(t[u5].origin.geometry.coordinates, t[t.length - 1].origin.geometry.coordinates), angle: Iu(t[u5].origin.geometry.coordinates, t[t.length - 1].origin.geometry.coordinates), multiplicativeDistanceWeightScaling: i })), t[t.length - 1]), a4;
  }
};
H$3(OM, "Navigator");
var gm2 = OM;
var MD = "https://tiles-cdn.mappedin.com/styles/mappedin/style.json", KW = "https://auth.mappedin.com/oauth2/token";
var h2 = "";
function DM(r5) {
  h2 = r5, Hle(r5);
}
H$3(DM, "setMaplibreWorkerUrl");
var hh2 = "";
function LM(r5) {
  hh2 = r5;
}
H$3(LM, "setCollisionWorkerUrl");
async function TD(r5, t) {
  var i, a4, u5, h, d, m5, v3, x2;
  let e = (i = t == null ? void 0 : t.useWorkers) != null ? i : true, n4 = G$1(F$1({}, t), { watermark: t == null ? void 0 : t.watermark, attribution: t == null ? void 0 : t.attribution, antialias: t == null ? void 0 : t.antialias, occlusionEnabled: t == null ? void 0 : t.occlusionEnabled, transformImageRequest: t == null ? void 0 : t.transformImageRequest, naturalBearing: (a4 = t == null ? void 0 : t.naturalBearing) != null ? a4 : 0, imagePlacementOptions: t == null ? void 0 : t.imagePlacementOptions, onWebGLContextCreationError: t == null ? void 0 : t.onWebGLContextCreationError, onWebGLContextLost: t == null ? void 0 : t.onWebGLContextLost, onWebGLContextRestored: t == null ? void 0 : t.onWebGLContextRestored, onWebGLRendererError: t == null ? void 0 : t.onWebGLRendererError, useStandaloneCamera: (u5 = t == null ? void 0 : t.useStandaloneCamera) != null ? u5 : false, useCollisionWorker: (h = t == null ? void 0 : t.useCollisionWorker) != null ? h : true, useWorkers: e });
  if (e === true && ((d = t == null ? void 0 : t.outdoorView) != null && d.enabled)) {
    let { Map: S4, MercatorCoordinate: I3 } = await import("./outdoor-context-v4-FKKIRNTV-BGDJ1U6X.js"), w3 = t.outdoorView.headers;
    w3 == null && (w3 = await wi2(KW));
    let E4 = t.center || [0, 0], T3 = new S4({ container: r5, style: t.outdoorView.style || MD, center: E4, attributionControl: false, zoom: (m5 = t.zoomLevel) != null ? m5 : CM, pitch: (v3 = t.pitch) != null ? v3 : xM, bearing: (x2 = t.bearing) != null ? x2 : _M, transformRequest: qt(w3), trackResize: false, pixelRatio: t.outdoorView.lowDpi ? 1 : Wt(), antialias: typeof t.antialias == "boolean" ? t.antialias : true, boxZoom: false, doubleClickZoom: false, scrollZoom: false, dragPan: false, dragRotate: false, keyboard: false, touchZoomRotate: false }), D4 = T3.painter.context.gl, A3 = new C1(r5, F$1({ center: E4, zoomLevel: T3.getZoom(), pitch: T3.getPitch(), bearing: T3.getBearing(), gl: D4, map: T3, mode: "outdoors-interleaved" }, n4)), L3 = { center: T3.getCenter().toArray(), zoom: T3.getZoom(), bearing: T3.getBearing(), pitch: T3.getPitch() };
    T3.setMinZoom(A3.camera.minZoomLevel), T3.setMaxZoom(A3.camera.maxZoomLevel), A3.on("camera-change", (J4) => {
      L3.center = J4.center, L3.zoom = J4.zoomLevel, L3.bearing = J4.bearing, L3.pitch = J4.pitch, T3.jumpTo(L3);
    });
    let B$12 = I3.fromLngLat(E4, 0), j3 = Si(B$12, A3.viewCamera, A3.camera, () => {
      A3.renderSync();
    });
    T3.on("style.load", async () => {
      T3 && (T3.addLayer(j3), A3.renderSync());
    });
    let W4 = false, $5 = false;
    T3.on("idle", () => {
      T3 && (W4 || (A3.publish("outdoor-view-loaded"), W4 = true), $5 || ($5 = true, A3.publish("outdoor-style-loaded")));
    });
    let F3 = H$3((J4) => {
      J4 && (J4.sourceDataType === "metadata" || J4.sourceDataType === "visibility" || J4.dataType === "style" || J4.type === "terrain") && A3.getSystems().htmlControlsSystem.updateData(T3);
    }, "updateData");
    return T3.on("styledata", (J4) => {
      T3 && J4 && J4.dataType === "style" && J4.type === "styledata" && ($5 = false), F3(J4);
    }), T3.on("sourcedata", F3), T3.on("terrain", F3), T3.on("error", (J4) => {
      var ot2;
      if (((ot2 = J4.error) == null ? void 0 : ot2.url) === MD) {
        B.error('Failed to load outdoor view style, possibly due to invalid token "'.concat(w3["x-mappedin-tiles-key"], '"'));
        return;
      }
      B.warn(J4);
    }), A3;
  } else return new C1(r5, n4);
}
H$3(TD, "createRenderer");
a();
a();
a();
var AM = ((a4) => (a4.Departure = "Departure", a4.TakeConnection = "TakeConnection", a4.ExitConnection = "ExitConnection", a4.Turn = "Turn", a4.Arrival = "Arrival", a4))(AM || {}), f2 = ((u5) => (u5.Straight = "Straight", u5.Right = "Right", u5.SlightRight = "SlightRight", u5.Left = "Left", u5.SlightLeft = "SlightLeft", u5.Back = "Back", u5))(f2 || {}), NM = ((m5) => (m5.stairs = "stairs", m5.elevator = "elevator", m5.escalator = "escalator", m5.door = "door", m5.ramp = "ramp", m5.slide = "slide", m5.portal = "portal", m5.security = "security", m5.shuttle = "shuttle", m5))(NM || {}), S1 = ((e) => (e.Exterior = "exterior-walls", e.Interior = "interior-walls", e))(S1 || {}), I1 = ((e) => (e.Interior = "interior-doors", e.Exterior = "exterior-doors", e))(I1 || {});
a();
a();
var ym = class ym2 {
  constructor(t, e, n4) {
    O(this, "id");
    O(this, "text");
    O(this, "target");
    O(this, "__type", ym2.__type);
    this.id = t, this.text = e, this.target = n4;
  }
  static is(t) {
    return t.__type === ym2.__type;
  }
  get focusTarget() {
    return this.target.anchorTarget;
  }
};
H$3(ym, "Label"), O(ym, "__type", "Label");
var Vc2 = ym;
a();
var Qh3, Kh3 = class Kh4 {
  constructor(t, e, n4) {
    O(this, "id");
    Q$3(this, Qh3);
    O(this, "__type", Kh4.__type);
    O(this, "contentEl");
    this.id = t, this.contentEl = e, R$1(this, Qh3, n4);
  }
  get target() {
    return P(this, Qh3);
  }
  get coordinate() {
    return P(this, Qh3).anchorTarget;
  }
  toJSON() {
    return { id: this.id, __type: Kh4.__type, target: this.target, coordinate: this.coordinate };
  }
  static is(t) {
    return t.__type === Kh4.__type;
  }
  get focusTarget() {
    return this.target.anchorTarget;
  }
  updateTarget(t) {
    R$1(this, Qh3, t);
  }
};
Qh3 = /* @__PURE__ */ new WeakMap(), H$3(Kh3, "Marker"), O(Kh3, "__type", "Marker");
var Mu = Kh3;
a();
var T1, w1, vm2 = class vm3 {
  constructor(t, e, n4) {
    Q$3(this, T1);
    Q$3(this, w1);
    O(this, "target");
    O(this, "__type", vm3.__type);
    R$1(this, T1, t), R$1(this, w1, e), this.target = n4;
  }
  static is(t) {
    return t.__type === vm3.__type;
  }
  get id() {
    return P(this, T1);
  }
  get url() {
    return P(this, w1);
  }
};
T1 = /* @__PURE__ */ new WeakMap(), w1 = /* @__PURE__ */ new WeakMap(), H$3(vm2, "Image"), O(vm2, "__type", "Image");
var M1 = vm2;
a();
var ef2, tf2 = class tf3 {
  constructor(t, e, n4) {
    O(this, "id");
    O(this, "groupId");
    O(this, "__type", tf3.__type);
    Q$3(this, ef2);
    this.id = t, this.groupId = e, R$1(this, ef2, n4);
  }
  get target() {
    return P(this, ef2);
  }
  static is(t) {
    return t.__type === tf3.__type;
  }
  updateTarget(t) {
    R$1(this, ef2, t);
  }
  toJSON() {
    return { id: this.id, __type: tf3.__type, groupId: this.groupId, target: P(this, ef2) };
  }
};
ef2 = /* @__PURE__ */ new WeakMap(), H$3(tf2, "Model"), O(tf2, "__type", "Model");
var rf2 = tf2;
a();
var bm = class bm2 {
  constructor(t, e) {
    O(this, "id");
    O(this, "coordinates");
    O(this, "__type", bm2.__type);
    this.id = t, this.coordinates = e;
  }
  static is(t) {
    return t.__type === bm2.__type;
  }
  get focusTarget() {
    return this.coordinates;
  }
};
H$3(bm, "PathSegment"), O(bm, "__type", "PathSegment");
var xm = bm, nf2 = class nf3 {
  constructor(t, e, n4, i) {
    O(this, "id");
    O(this, "animation");
    O(this, "coordinates");
    O(this, "segments");
    O(this, "__type", nf3.__type);
    this.id = t, this.animation = e, this.coordinates = n4, this.segments = i.map(({ id: a4, coordinates: u5 }) => new xm(a4.toString(), u5));
  }
  static is(t) {
    return t.__type === nf3.__type;
  }
  get focusTarget() {
    return this.coordinates;
  }
  toJSON() {
    return { __type: nf3.__type, id: this.id, coordinates: this.coordinates, segments: this.segments };
  }
};
H$3(nf2, "Path"), O(nf2, "__type", "Path");
var ba2 = nf2;
a();
var jc2, kM = class kM2 {
  constructor(t) {
    Q$3(this, jc2);
    R$1(this, jc2, t);
  }
  toJSON() {
    return { center: this.center, bearing: this.bearing, pitch: this.pitch, zoomLevel: this.zoomLevel };
  }
  get center() {
    return P(this, jc2).center;
  }
  get bearing() {
    return P(this, jc2).bearing;
  }
  get pitch() {
    return P(this, jc2).pitch;
  }
  get zoomLevel() {
    return P(this, jc2).zoomLevel;
  }
};
jc2 = /* @__PURE__ */ new WeakMap(), H$3(kM, "CameraTransform");
var P1 = kM;
a();
var _m2 = class _m3 {
  constructor(t) {
    O(this, "id");
    O(this, "__type", _m3.__type);
    this.id = t;
  }
  static is(t) {
    return t.__type === _m3.__type;
  }
  get focusTarget() {
    return this;
  }
};
H$3(_m2, "Shape"), O(_m2, "__type", "Shape");
var Tu = _m2;
a();
var E1 = class E12 {
  constructor(t, e) {
    O(this, "id");
    O(this, "target");
    O(this, "__type", "Text3D");
    this.id = t, this.target = e;
  }
  static is(t) {
    return t.__type === E12.__type;
  }
};
H$3(E1, "Text3D"), O(E1, "__type", "Text3D");
var Uc2 = E1;
a();
a();
a();
var QW = /* @__PURE__ */ new Map([["search-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7C13 8.29583 12.5892 9.49572 11.8907 10.4765L15.4614 14.0472C15.6567 14.2425 15.6567 14.559 15.4614 14.7543L14.7543 15.4614C14.559 15.6567 14.2424 15.6567 14.0472 15.4614L10.4765 11.8907C9.49571 12.5892 8.29583 13 7 13C3.68629 13 1 10.3137 1 7ZM7 11C4.79086 11 3 9.20914 3 7C3 4.79086 4.79086 3 7 3C9.20914 3 11 4.79086 11 7C11 9.20914 9.20914 11 7 11Z"\n				stroke="none"\n			/>\n		</svg>'], ["close-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M12.5963 1.98959C12.7916 1.79433 13.1082 1.79433 13.3034 1.98959L14.0105 2.6967C14.2058 2.89196 14.2058 3.20855 14.0105 3.40381L3.40392 14.0104C3.20866 14.2057 2.89208 14.2057 2.69682 14.0104L1.98971 13.3033C1.79445 13.108 1.79445 12.7915 1.98971 12.5962L12.5963 1.98959Z"\n				stroke="none"\n			/>\n			<path\n				d="M1.98971 3.40381C1.79445 3.20855 1.79445 2.89196 1.98971 2.6967L2.69682 1.98959C2.89208 1.79433 3.20866 1.79433 3.40392 1.98959L14.0105 12.5962C14.2058 12.7915 14.2058 13.108 14.0105 13.3033L13.3034 14.0104C13.1082 14.2057 12.7916 14.2057 12.5963 14.0104L1.98971 3.40381Z"\n				stroke="none"\n			/>\n		</svg>'], ["empty-64x40", '<svg viewBox="0 0 64 40">\n			<g>\n				<g clipPath="url(#clip0_499_175492)">\n					<path\n						d="M32 39.7032C49.6731 39.7032 64 36.5925 64 32.7552C64 28.9179 49.6731 25.8071 32 25.8071C14.3269 25.8071 0 28.9179 0 32.7552C0 36.5925 14.3269 39.7032 32 39.7032Z"\n						stroke="none"\n						fill="#F5F5F5"\n					/>\n					<path\n						d="M55 13.6653L44.854 2.24866C44.367 1.47048 43.656 1 42.907 1H21.093C20.344 1 19.633 1.47048 19.146 2.24767L9 13.6663V22.8367H55V13.6653Z"\n						fill="none"\n					/>\n					<path\n						d="M41.613 16.8128C41.613 15.2197 42.607 13.9046 43.84 13.9036H55V31.9059C55 34.0132 53.68 35.7402 52.05 35.7402H11.95C10.32 35.7402 9 34.0122 9 31.9059V13.9036H20.16C21.393 13.9036 22.387 15.2167 22.387 16.8098V16.8317C22.387 18.4248 23.392 19.7111 24.624 19.7111H39.376C40.608 19.7111 41.613 18.4128 41.613 16.8198V16.8128Z"\n						fill="#FAFAFA"\n					/>\n				</g>\n				<defs>\n					<clipPath id="clip0_499_175492">\n						<rect width="64" height="40" fill="white" />\n					</clipPath>\n				</defs>\n			</g>\n		</svg>'], ["caret-12x12", '<svg viewBox="0 0 12 12">\n			<path\n				stroke="none"\n				d="M8.38828 5.78337L3.92578 1.93493C3.75938 1.79196 3.51562 1.92087 3.51562 2.15173V9.84861C3.51562 10.0795 3.75938 10.2084 3.92578 10.0654L8.38828 6.21696C8.51602 6.10681 8.51602 5.89353 8.38828 5.78337Z"\n			/>\n		</svg>'], ["plus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M7.5 1C7.22386 1 7 1.22386 7 1.5V7H1.5C1.22386 7 1 7.22386 1 7.5L1 8.5C1 8.77614 1.22386 9 1.5 9H7V14.5C7 14.7761 7.22386 15 7.5 15H8.5C8.77614 15 9 14.7761 9 14.5V9H14.5C14.7761 9 15 8.77614 15 8.5V7.5C15 7.22386 14.7761 7 14.5 7H9V1.5C9 1.22386 8.77614 1 8.5 1H7.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["recenter-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M0 2.5C0 2.22386 0.223858 2 0.5 2H1.5C1.77614 2 2 2.22386 2 2.5V13.5C2 13.7761 1.77614 14 1.5 14H0.5C0.223858 14 0 13.7761 0 13.5V2.5Z" />\n				<path\n					fillRule="evenodd"\n					clipRule="evenodd"\n					d="M4.5 4C4.22386 4 4 4.22386 4 4.5V11.5C4 11.7761 4.22386 12 4.5 12H11.5C11.7761 12 12 11.7761 12 11.5V4.5C12 4.22386 11.7761 4 11.5 4H4.5ZM6 6V10H10V6H6Z"\n				/>\n				<path d="M14.5 2C14.2239 2 14 2.22386 14 2.5V13.5C14 13.7761 14.2239 14 14.5 14H15.5C15.7761 14 16 13.7761 16 13.5V2.5C16 2.22386 15.7761 2 15.5 2H14.5Z" />\n			</g>\n		</svg>'], ["minus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M1.5 9C1.22386 9 1 8.77614 1 8.5L1 7.5C1 7.22386 1.22386 7 1.5 7L14.5 7C14.7761 7 15 7.22386 15 7.5V8.5C15 8.77614 14.7761 9 14.5 9L1.5 9Z"\n				stroke="none"\n			/>\n		</svg>'], ["logo-horizontal-206x48", '<svg viewBox="0 0 206 48">\n			<path d="M27.2678 14.2261H22.3187C21.0695 14.2261 20.4695 14.7801 20.4695 15.9852V31.142L10.3966 15.5591C9.69665 14.4784 9.2475 14.2773 7.8475 14.2261H2.97462C1.67462 14.2261 1.07631 14.7801 1.07631 15.9852V44.7665C1.07631 45.9716 1.67462 46.5256 2.97462 46.5256H7.92377C9.22207 46.5256 9.82207 45.9716 9.82207 44.7665V29.6847L19.9441 45.1926C20.695 46.3244 21.095 46.5256 22.4933 46.5256H27.2933C28.5916 46.5256 29.1916 45.9716 29.1916 44.7665V15.9852C29.1407 14.7801 28.5424 14.2261 27.2678 14.2261Z" />\n			<path d="M5.44915 10.9602C8.45863 10.9602 10.8983 8.50669 10.8983 5.48011C10.8983 2.45353 8.45863 0 5.44915 0C2.43967 0 0 2.45353 0 5.48011C0 8.50669 2.43967 10.9602 5.44915 10.9602Z" />\n			<path d="M61.7899 25.0449C63.2306 23.1903 65.078 22.2051 67.556 22.2051C72.0526 22.2051 74.7611 25.3347 74.7611 29.4511V39.2489C74.8187 39.7125 74.5306 39.9443 74.0695 39.9443H72.5136C72.0526 39.9443 71.7645 39.7125 71.8221 39.2489V29.5091C71.8221 27.1909 69.9187 25.2187 67.4984 25.2187C65.1339 25.2187 63.2323 27.1329 63.2323 29.2773V39.2489C63.2899 39.7125 63.0018 39.9443 62.5407 39.9443H60.9831C60.5221 39.9443 60.2916 39.7125 60.2916 39.2489V29.4511C60.2916 27.1329 58.3899 25.2187 56.0255 25.2187C53.7204 25.2187 51.7594 27.075 51.7594 29.2773V39.3068C51.817 39.7705 51.5289 40.0023 51.0102 40.0023H49.5119C49.0509 40.0023 48.7628 39.7705 48.7628 39.3068V23.25C48.7051 22.7864 48.9933 22.4966 49.5119 22.4966H50.9526C51.356 22.4966 51.5289 22.6704 51.5289 23.0182V24.2352C52.7407 22.9602 54.239 22.2648 56.0255 22.2648C58.4475 22.2068 60.3492 23.192 61.7899 25.0466V25.0449ZM77.1255 31.2477C77.1255 26.3216 81.1018 22.2051 86.1187 22.2051C88.539 22.2051 90.6136 23.1903 92.3441 25.1608V23.1903C92.3441 22.7267 92.5746 22.5528 93.0357 22.5528H94.4187C94.8797 22.5528 95.1102 22.7847 95.1102 23.3062V39.3648C95.1102 39.8284 94.8797 40.0602 94.4187 40.0602H93.0357C92.5746 40.0602 92.3441 39.8284 92.3441 39.4227V37.4523C90.6712 39.3648 88.5967 40.35 86.1746 40.35C81.1018 40.2341 77.1238 36.1773 77.1238 31.2477H77.1255ZM92.1136 31.2477C92.1136 27.8284 89.4611 25.2187 86.0594 25.2187C82.7746 25.2187 80.1221 27.8864 80.1221 31.2477C80.1221 34.6687 82.7746 37.2784 86.1187 37.2784C86.9062 37.2789 87.6861 37.1232 88.4138 36.8202C89.1414 36.5173 89.8026 36.0731 90.3593 35.513C90.9161 34.9528 91.3577 34.2878 91.6587 33.556C91.9597 32.8241 92.1143 32.0397 92.1136 31.2477ZM100.992 37.3943V46.3807C101.049 46.8443 100.761 47.1341 100.298 47.1341H98.7424C98.2814 47.1341 97.9933 46.9023 97.9933 46.3807V23.1903C97.9933 22.7267 98.2238 22.4369 98.7424 22.4369H100.183C100.646 22.379 100.934 22.6687 100.934 23.0744V24.9869C102.605 23.0744 104.68 22.1472 107.044 22.1472C112.002 22.1472 116.037 26.2619 116.037 31.1898C116.037 36.1176 112.059 40.2341 107.044 40.2341C104.622 40.2341 102.603 39.3068 100.992 37.3943ZM106.987 25.2187C103.7 25.2187 101.049 27.8864 101.049 31.2477C101.049 34.6687 103.7 37.2784 107.044 37.2784C110.446 37.2784 113.039 34.6108 113.039 31.2477C113.039 27.8864 110.388 25.2187 106.987 25.2187ZM121.11 37.3943V46.3807C121.168 46.8443 120.88 47.1341 120.419 47.1341H118.861C118.4 47.1341 118.112 46.9023 118.112 46.3807V23.1903C118.112 22.7267 118.342 22.4369 118.861 22.4369H120.302C120.764 22.379 121.053 22.6687 121.053 23.0744V24.9869C122.724 23.0744 124.798 22.1472 127.163 22.1472C132.12 22.1472 136.156 26.2619 136.156 31.1898C136.156 36.1176 132.178 40.2341 127.163 40.2341C124.742 40.2341 122.781 39.3068 121.11 37.3943ZM127.105 25.2187C123.819 25.2187 121.168 27.8864 121.168 31.2477C121.168 34.6687 123.819 37.2784 127.163 37.2784C130.564 37.2784 133.158 34.6108 133.158 31.2477C133.158 27.8864 130.507 25.2187 127.107 25.2187H127.105ZM153.97 32.3506H141.054C141.342 35.2483 143.995 37.4523 147.164 37.4523C148.893 37.4523 150.393 37.0466 151.719 36.0597C152.007 35.8858 152.295 35.7699 152.353 35.7699C152.583 35.7699 152.756 35.8858 152.929 36.1773L153.505 37.1625C153.622 37.3364 153.68 37.4523 153.68 37.5682C153.68 37.8 153.507 38.0318 153.103 38.3216C151.258 39.5966 149.183 40.292 146.992 40.292C141.688 40.292 137.883 36.3511 137.883 31.2477C137.883 26.204 141.803 22.2051 146.703 22.2051C151.546 22.2051 154.717 25.7983 154.717 31.0176C154.717 31.5972 154.717 32.3506 153.968 32.3506H153.97ZM141.056 30.0324H151.72C151.432 26.8432 149.473 24.929 146.648 24.929C145.241 24.8904 143.875 25.3995 142.833 26.3501C141.791 27.3007 141.154 28.6194 141.056 30.0307V30.0324ZM156.332 31.2477C156.332 26.3216 160.31 22.2051 165.326 22.2051C167.748 22.2051 169.707 23.1324 171.32 25.0449V16.2324C171.263 15.7687 171.551 15.479 172.012 15.479H173.57C174.031 15.479 174.319 15.7108 174.319 16.2324V39.3068C174.319 39.7705 174.088 40.0023 173.57 40.0023H172.129C171.666 40.0602 171.378 39.7705 171.378 39.3648V37.3943C169.649 39.3068 167.632 40.292 165.268 40.292C160.31 40.2341 156.332 36.1773 156.332 31.2477ZM171.264 31.2477C171.264 27.8284 168.612 25.2187 165.21 25.2187C161.924 25.2187 159.273 27.8864 159.273 31.2477C159.273 34.6687 161.924 37.2784 165.268 37.2784C166.057 37.2838 166.839 37.1316 167.569 36.8304C168.299 36.5292 168.962 36.0852 169.52 35.5241C170.077 34.963 170.519 34.296 170.818 33.5619C171.117 32.8277 171.268 32.0411 171.263 31.2477H171.264ZM177.72 19.0739C177.715 18.8594 177.754 18.646 177.833 18.4468C177.912 18.2476 178.031 18.0667 178.182 17.915C178.333 17.7633 178.512 17.6439 178.71 17.5642C178.909 17.4845 179.121 17.446 179.334 17.4511C179.546 17.4507 179.756 17.4923 179.952 17.5737C180.148 17.6551 180.326 17.7746 180.476 17.9254C180.626 18.0762 180.745 18.2553 180.826 18.4523C180.907 18.6494 180.948 18.8606 180.948 19.0739C180.953 19.2884 180.914 19.5017 180.835 19.7009C180.756 19.9001 180.637 20.081 180.486 20.2327C180.335 20.3845 180.156 20.5038 179.957 20.5835C179.759 20.6633 179.547 20.7017 179.334 20.6966C178.412 20.7545 177.72 20.0591 177.72 19.0739ZM177.836 39.2489V23.1903C177.836 22.7267 178.066 22.4369 178.527 22.4369H180.083C180.544 22.4369 180.832 22.6687 180.775 23.1903V39.2489C180.832 39.7125 180.544 39.9443 180.083 39.9443H178.527C178.066 39.9443 177.836 39.7125 177.836 39.2489ZM186.944 23.0165V24.1756C188.212 22.8426 189.71 22.2051 191.497 22.2051C195.937 22.2051 198.646 25.2767 198.646 29.3932V39.2489C198.703 39.7125 198.415 39.9443 197.954 39.9443H196.398C195.936 39.9443 195.705 39.7125 195.705 39.2489V29.4511C195.705 27.1329 193.803 25.2187 191.439 25.2187C189.134 25.2187 187.175 27.075 187.175 29.2773V39.3068C187.232 39.7705 186.944 40.0023 186.424 40.0023H184.868C184.407 40.0023 184.119 39.7705 184.119 39.3068V23.1903C184.061 22.7267 184.349 22.4949 184.868 22.4949H186.309C186.712 22.4949 186.944 22.6687 186.944 23.0165Z" />\n			<path d="M204 40C205.115 40 206 39.0857 206 38V37.9886C206 36.9029 205.126 36 204 36C202.885 36 202 36.9143 202 38V38.0114C202 39.0971 202.874 40 204 40ZM204 39.7829C202.989 39.7829 202.23 38.9829 202.23 38.0114V38C202.23 37.0286 203 36.2171 204 36.2171C205.011 36.2171 205.77 37.0171 205.77 37.9886V38C205.77 38.9714 205 39.7829 204 39.7829ZM203.218 38.9714H203.609V38.2743H204.034L204.517 38.9714H204.989L204.448 38.2057C204.724 38.1257 204.92 37.92 204.92 37.5886C204.92 37.1657 204.586 36.9486 204.138 36.9486H203.218V38.9714ZM203.609 37.9543V37.2914H204.103C204.368 37.2914 204.517 37.4057 204.517 37.6229C204.517 37.8171 204.368 37.9543 204.103 37.9543H203.609Z" />\n		</svg>'], ["share-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M13 6C14.6569 6 16 4.65685 16 3C16 1.34315 14.6569 0 13 0C11.3431 0 10 1.34315 10 3C10 3.13463 10.0089 3.26719 10.0261 3.39712L6.82972 5.17286C6.10576 4.44825 5.10523 4 4 4C1.79086 4 0 5.79086 0 8C0 10.2091 1.79086 12 4 12C5.10523 12 6.10576 11.5518 6.82972 10.8271L10.0261 12.6029C10.0089 12.7328 10 12.8654 10 13C10 14.6569 11.3431 16 13 16C14.6569 16 16 14.6569 16 13C16 11.3431 14.6569 10 13 10C12.2011 10 11.4752 10.3123 10.9376 10.8214L7.84579 9.1037C7.94622 8.75313 8 8.38284 8 8C8 7.61716 7.94622 7.24687 7.84579 6.8963L10.9376 5.17864C11.4752 5.68775 12.2011 6 13 6ZM13 4C13.5523 4 14 3.55228 14 3C14 2.44772 13.5523 2 13 2C12.4477 2 12 2.44772 12 3C12 3.55228 12.4477 4 13 4ZM4 10C5.10457 10 6 9.10457 6 8C6 6.89543 5.10457 6 4 6C2.89543 6 2 6.89543 2 8C2 9.10457 2.89543 10 4 10ZM14 13C14 13.5523 13.5523 14 13 14C12.4477 14 12 13.5523 12 13C12 12.4477 12.4477 12 13 12C13.5523 12 14 12.4477 14 13Z"\n				stroke="none"\n			/>\n		</svg>'], ["checkmark-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M15.387 3.31662C15.6008 3.49148 15.6323 3.80649 15.4574 4.02021L6.77402 14.6332C6.58509 14.8642 6.30292 14.9986 6.00457 15C5.70622 15.0013 5.42285 14.8694 5.23184 14.6402L0.551937 9.02429C0.375155 8.81215 0.403817 8.49687 0.615956 8.32009L1.38418 7.67991C1.59632 7.50312 1.9116 7.53179 2.08838 7.74392L5.99299 12.4295L13.9095 2.75374C14.0844 2.54002 14.3994 2.50852 14.6131 2.68338L15.387 3.31662Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-right-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.35355 1.64645C8.54881 1.45118 8.8654 1.45118 9.06066 1.64645L14.7071 7.29289C15.0976 7.68342 15.0976 8.31658 14.7071 8.70711L9.06066 14.3536C8.8654 14.5488 8.54882 14.5488 8.35355 14.3536L7.64645 13.6464C7.45118 13.4512 7.45118 13.1346 7.64645 12.9393L11.5858 9H0.5C0.223858 9 0 8.77614 0 8.5V7.5C0 7.22386 0.223858 7 0.5 7H11.5858L7.64645 3.06066C7.45118 2.8654 7.45118 2.54882 7.64645 2.35355L8.35355 1.64645Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-up-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.00015 0.5C8.34685 0.5 8.67835 0.642318 8.91714 0.893677L15.6517 7.98267C15.8441 8.18525 15.8359 8.50548 15.6333 8.69793L14.533 9.7433C14.3304 9.93575 14.0101 9.92754 13.8177 9.72496L9.26497 4.93262V15.4249C9.26497 15.7043 9.03846 15.9308 8.75904 15.9308H7.24125C6.96184 15.9308 6.73532 15.7043 6.73532 15.4249V4.93262L2.1826 9.72496C1.99015 9.92754 1.66992 9.93575 1.46734 9.7433L0.366945 8.69793C0.164367 8.50548 0.156156 8.18525 0.348604 7.98267L7.08315 0.893677C7.32194 0.642318 7.65344 0.5 8.00015 0.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M1 11.5C1 11.2239 1.22386 11 1.5 11H6V13.5C6 13.7761 5.77614 14 5.5 14H1.5C1.22386 14 1 13.7761 1 13.5V11.5Z" />\n				<path d="M4 8.5C4 8.22386 4.22386 8 4.5 8H9V10.5C9 10.7761 8.77614 11 8.5 11H4V8.5Z" />\n				<path d="M7 5.5C7 5.22386 7.22386 5 7.5 5H12V7.5C12 7.77614 11.7761 8 11.5 8H7V5.5Z" />\n				<path d="M10 2.5C10 2.22386 10.2239 2 10.5 2H14.5C14.7761 2 15 2.22386 15 2.5V4.5C15 4.77614 14.7761 5 14.5 5H10V2.5Z" />\n			</g>\n		</svg>'], ["connection-stairs-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.25 12H2.5C2.225 12 2 11.7429 2 11.4286C2 11.1143 2.225 10.8571 2.5 10.8571H4.25V7.91429H6.5V4.94286H8.75V2H11.5C11.775 2 12 2.25714 12 2.57143C12 2.88571 11.775 3.14286 11.5 3.14286H9.75V6.08571H7.5V9.02857H5.25V12Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path d="M1.625 8.1875C1.625 8.01491 1.76491 7.875 1.9375 7.875H4.75V9.4375C4.75 9.61009 4.61009 9.75 4.4375 9.75H1.9375C1.76491 9.75 1.625 9.61009 1.625 9.4375V8.1875Z" />\n			<path d="M3.5 6.3125C3.5 6.13991 3.63991 6 3.8125 6H6.625V7.5625C6.625 7.73509 6.48509 7.875 6.3125 7.875H3.5V6.3125Z" />\n			<path d="M5.375 4.4375C5.375 4.26491 5.51491 4.125 5.6875 4.125H8.5V5.6875C8.5 5.86009 8.36009 6 8.1875 6H5.375V4.4375Z" />\n			<path d="M7.25 2.5625C7.25 2.38991 7.38991 2.25 7.5625 2.25H10.0625C10.2351 2.25 10.375 2.38991 10.375 2.5625V3.8125C10.375 3.98509 10.2351 4.125 10.0625 4.125H7.25V2.5625Z" />\n		</svg>'], ["connection-escalator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3.63008 12H2C0.895431 12 0 12.8954 0 14C0 15.1046 0.89543 16 2 16H4.63008C4.86879 16 5.09962 15.9146 5.28087 15.7593L11.7191 10.2407C11.9004 10.0854 12.1312 10 12.3699 10H14C15.1046 10 16 9.10457 16 8C16 6.89543 15.1046 6 14 6H11.3699C11.1312 6 10.9004 6.08539 10.7191 6.24074L4.28087 11.7593C4.09962 11.9146 3.86879 12 3.63008 12Z" />\n				<path d="M5 6C5 4.89543 5.89543 4 7 4C8.10457 4 9 4.89543 9 6L5 9.5V6Z" />\n				<path d="M9 2C9 3.10457 8.10457 4 7 4C5.89543 4 5 3.10457 5 2C5 0.89543 5.89543 0 7 0C8.10457 0 9 0.89543 9 2Z" />\n			</g>\n		</svg>'], ["connection-escalator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.26686 2.98522C5.26686 2.44335 5.71573 2 6.26436 2C6.81299 2 7.26187 2.44335 7.26187 2.98522C7.26187 3.5271 6.81299 3.97045 6.26436 3.97045C5.71573 3.97045 5.26686 3.50246 5.26686 2.98522Z"\n				stroke="none"\n			/>\n			<path\n				d="M7.26188 5.48588V5.25125C7.26188 4.85716 6.91275 4.53696 6.48881 4.53696H6.03993C5.61599 4.53696 5.26687 4.88179 5.26687 5.25125V7.66458L4.3192 8.6995H3.67082C2.74813 8.6995 2 9.43842 2 10.3498C2 11.2611 2.74813 12 3.67082 12H4.61845C5.36658 12 6.11471 11.6798 6.61347 11.1133L9.6808 7.76354H10.3292C11.2519 7.76354 12 7.02463 12 6.11329C12 5.20196 11.2519 4.46305 10.3292 4.46305H9.38155C8.60848 4.46305 7.88529 4.78324 7.38653 5.34975L7.26188 5.48588ZM4.61846 11.0148H3.67083C3.29677 11.0148 2.99751 10.7192 2.99751 10.3498C2.99751 9.9803 3.29677 9.68473 3.67083 9.68473H4.61846C4.71821 9.68473 4.81796 9.63547 4.86784 9.56158L8.13467 5.99015C8.45886 5.64532 8.90774 5.44828 9.38155 5.44828H10.3292C10.7032 5.44828 11.0025 5.74384 11.0025 6.1133C11.0025 6.48276 10.7032 6.77833 10.3292 6.77833H9.38155C9.2818 6.77833 9.18205 6.82759 9.13218 6.87685L5.86534 10.4729C5.54115 10.8177 5.09228 11.0148 4.61846 11.0148Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3 5.5C3 6.32843 2.32843 7 1.5 7C0.671573 7 0 6.32843 0 5.5C0 4.67157 0.671573 4 1.5 4C2.32843 4 3 4.67157 3 5.5Z" />\n				<path d="M3 10.5C3 11.3284 2.32843 12 1.5 12C0.671573 12 0 11.3284 0 10.5C0 9.67157 0.671573 9 1.5 9C2.32843 9 3 9.67157 3 10.5Z" />\n				<path d="M11 1H14C14.5523 1 15 1.44772 15 2V14C15 14.5523 14.5523 15 14 15H11V1Z" />\n				<path d="M9 1H6C5.44772 1 5 1.44772 5 2V14C5 14.5523 5.44772 15 6 15H9V1Z" />\n			</g>\n		</svg>'], ["connection-elevator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M7.476 2H2.72693C1.77095 2 1 2.72464 1 3.62319V10.3768C1 11.2754 1.77095 12 2.72693 12H7.476C8.43198 12 9.20293 11.2754 9.20293 10.3768V3.62319C9.17209 2.72464 8.40114 2 7.476 2ZM7.476 3.15942C7.75354 3.15942 7.96941 3.36232 7.96941 3.62319V10.3768C7.96941 10.6377 7.75354 10.8406 7.476 10.8406H5.71824V3.15942H7.476ZM4.48472 3.15942V10.8406H2.72693C2.44939 10.8406 2.23352 10.6377 2.23352 10.3768V3.62319C2.23352 3.36232 2.44939 3.15942 2.72693 3.15942H4.48472Z"\n				stroke="none"\n			/>\n			<path\n				d="M12.4643 6.19064H10.6638C10.4456 6.19064 10.2546 6.06243 10.1728 5.88294C10.0909 5.70346 10.1455 5.47269 10.2819 5.31884L11.1821 4.47269C11.4004 4.26756 11.755 4.26756 11.946 4.47269L12.8462 5.31884C13.0099 5.47269 13.0371 5.67781 12.9553 5.88294C12.8735 6.08807 12.6825 6.19064 12.4643 6.19064Z"\n				stroke="none"\n			/>\n			<path\n				d="M11.564 9.65216C11.4276 9.65216 11.2912 9.60088 11.1821 9.49831L10.2819 8.65216C10.1182 8.49831 10.0909 8.29319 10.1728 8.08806C10.2546 7.90857 10.4456 7.78036 10.6638 7.78036H12.4643C12.6825 7.78036 12.8735 7.90857 12.9553 8.08806C13.0371 8.26754 12.9826 8.49831 12.8462 8.65216L11.9459 9.49831C11.8641 9.60088 11.7004 9.65216 11.564 9.65216Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<circle cx="1.9375" cy="4.4375" r="0.9375" />\n			<circle cx="1.9375" cy="7.5625" r="0.9375" />\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M7.6 2H9.4C9.73137 2 10 2.26863 10 2.6V9.41328C10 9.74465 9.73137 10.0133 9.4 10.0133H7.6V2ZM6.4 2H4.6C4.26863 2 4 2.26863 4 2.6V9.41328C4 9.74465 4.26863 10.0133 4.6 10.0133H6.4V2Z"\n			/>\n		</svg>'], ["new-tab-14x14", '<svg viewBox="0 0 14 14">\n			<g stroke="none">\n				<path d="M2.625 2.625H5.6875C5.92913 2.625 6.125 2.42912 6.125 2.1875V1.3125C6.125 1.07088 5.92913 0.875 5.6875 0.875H1.3125C1.07088 0.875 0.875 1.07088 0.875 1.3125V12.6875C0.875 12.9291 1.07088 13.125 1.3125 13.125H12.6875C12.9291 13.125 13.125 12.9291 13.125 12.6875V8.3125C13.125 8.07088 12.9291 7.875 12.6875 7.875H11.8125C11.5709 7.875 11.375 8.07088 11.375 8.3125V11.375H2.625V2.625Z" />\n				<path d="M12.9063 0.875H8.40311C8.20822 0.875 8.11063 1.11062 8.24843 1.24843L9.88124 2.88124L5.8156 6.94688C5.64475 7.11774 5.64475 7.39475 5.8156 7.5656L6.43432 8.18432C6.60517 8.35517 6.88218 8.35517 7.05304 8.18432L11.1187 4.11868L12.7516 5.75157C12.8894 5.88938 13.125 5.79178 13.125 5.59689V1.09375C13.125 0.972938 13.0271 0.875 12.9063 0.875Z" />\n			</g>\n		</svg>'], ["compress-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path\n					id="Vector"\n					d="M4.67773 10.7154H0.713449C0.556306 10.7154 0.427734 10.844 0.427734 11.0011V11.8583C0.427734 12.0154 0.556306 12.144 0.713449 12.144H3.82059V15.2868C3.82059 15.444 3.94916 15.5725 4.10631 15.5725H4.96345C5.12059 15.5725 5.24916 15.444 5.24916 15.2868V11.2868C5.24916 10.9708 4.99381 10.7154 4.67773 10.7154ZM4.96345 0.429688H4.10631C3.94916 0.429688 3.82059 0.558259 3.82059 0.715402V3.85826H0.713449C0.556306 3.85826 0.427734 3.98683 0.427734 4.14397V5.00112C0.427734 5.15826 0.556306 5.28683 0.713449 5.28683H4.67773C4.99381 5.28683 5.24916 5.03147 5.24916 4.7154V0.715402C5.24916 0.558259 5.12059 0.429688 4.96345 0.429688ZM15.2849 10.7154H11.3206C11.0045 10.7154 10.7492 10.9708 10.7492 11.2868V15.2868C10.7492 15.444 10.8777 15.5725 11.0349 15.5725H11.892C12.0492 15.5725 12.1777 15.444 12.1777 15.2868V12.144H15.2849C15.442 12.144 15.5706 12.0154 15.5706 11.8583V11.0011C15.5706 10.844 15.442 10.7154 15.2849 10.7154ZM15.2849 3.85826H12.1777V0.715402C12.1777 0.558259 12.0492 0.429688 11.892 0.429688H11.0349C10.8777 0.429688 10.7492 0.558259 10.7492 0.715402V4.7154C10.7492 5.03147 11.0045 5.28683 11.3206 5.28683H15.2849C15.442 5.28683 15.5706 5.15826 15.5706 5.00112V4.14397C15.5706 3.98683 15.442 3.85826 15.2849 3.85826Z"\n				/>\n			</g>\n		</svg>'], ["washroom-14x14", '<svg viewBox="0 0 14 14" stroke="none">\n			<path d="M4.55125 3.09062C4.55125 3.69326 4.07639 4.18176 3.49058 4.18176C2.90525 4.18176 2.43039 3.69326 2.43039 3.09062C2.43039 2.4885 2.90525 2 3.49058 2C4.07639 2 4.55125 2.4885 4.55125 3.09062Z" />\n			<path d="M5.1193 5.48047C4.81653 4.83116 4.17252 4.41571 3.47822 4.41571C2.78392 4.41571 2.13986 4.83116 1.83714 5.48047L1.04175 7.22034C0.940664 7.441 1.02893 7.70073 1.24393 7.81791C1.47077 7.90871 1.72324 7.81791 1.82433 7.59725L2.49349 6.15554L2.21587 11.4407C2.20305 11.7263 2.41805 11.9734 2.69567 11.9993C2.97329 12.0124 3.21344 11.7913 3.23859 11.5057L3.4028 8.285H3.567L3.73121 11.5057C3.74403 11.7913 3.97086 11.9993 4.23616 11.9993H4.26131C4.53893 11.9861 4.75343 11.7395 4.74111 11.4407L4.46349 6.15554L5.13265 7.59725C5.20858 7.75298 5.35997 7.85697 5.52418 7.85697C5.5873 7.85697 5.65042 7.84379 5.71354 7.81792C5.92804 7.71393 6.0163 7.44153 5.91572 7.22035L5.1193 5.48047Z" />\n			<path d="M12.9582 7.22034L12.1505 5.48047C11.8477 4.83116 11.2037 4.41571 10.5094 4.41571C9.81513 4.41571 9.17107 4.83116 8.86836 5.48047L8.06064 7.22034C7.95955 7.441 8.04782 7.70073 8.26282 7.81791C8.47732 7.9219 8.7298 7.8311 8.84371 7.60993L9.52519 6.12977L9.46207 7.2204L8.57842 8.92184C8.47733 9.11663 8.61638 9.36316 8.83089 9.36316H9.33584L9.22242 11.4668C9.2096 11.7397 9.41177 11.9862 9.68939 11.9994C9.95469 12.0126 10.1943 11.8046 10.2072 11.519L10.3581 9.33723H10.6737L10.7871 11.5058C10.7999 11.7787 11.0144 11.9862 11.2792 11.9862H11.3043C11.5696 11.973 11.7841 11.7396 11.7713 11.4535L11.6579 9.33718H12.1628C12.3773 9.33718 12.5287 9.09066 12.4153 8.89586L11.5317 7.19442L11.4685 6.1038L12.1757 7.5972C12.2516 7.75293 12.403 7.85692 12.5672 7.85692C12.6303 7.85692 12.6934 7.84373 12.7566 7.81786C12.9711 7.70068 13.0593 7.44102 12.9582 7.22034Z" />\n			<path d="M11.5696 3.09062C11.5696 3.69326 11.0948 4.18176 10.5094 4.18176C9.92363 4.18176 9.44876 3.69326 9.44876 3.09062C9.44876 2.4885 9.92363 2 10.5094 2C11.0948 2 11.5696 2.4885 11.5696 3.09062Z" />\n			<path d="M6.99996 2.00006C6.76031 2.00006 6.57095 2.19485 6.57095 2.44138V11.5575C6.57095 11.804 6.76031 11.9988 6.99996 11.9988C7.2396 11.9988 7.42896 11.804 7.42896 11.5575V2.44138C7.42896 2.19485 7.2396 2.00006 6.99996 2.00006Z" />\n		</svg>'], ["point-of-interest-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path\n				stroke="none"\n				id="Subtract"\n				// Do not change these to fillRule or clipRule, since they need to be rendered as actual SVGs in labels, not React SVGs\n				fill-rule="evenodd"\n				clip-rule="evenodd"\n				d="M6.24724 10.7516C7.94597 9.0358 9.85962 6.89195 9.85962 4.85965C9.85962 2.72802 8.13159 1 5.99997 1C3.86834 1 2.14032 2.72802 2.14032 4.85965C2.14032 6.89195 4.05397 9.0358 5.7527 10.7516C5.88904 10.8893 6.1109 10.8893 6.24724 10.7516ZM5.99994 6.26317C6.77508 6.26317 7.40345 5.6348 7.40345 4.85967C7.40345 4.08453 6.77508 3.45616 5.99994 3.45616C5.22481 3.45616 4.59644 4.08453 4.59644 4.85967C4.59644 5.6348 5.22481 6.26317 5.99994 6.26317Z"\n			/>\n		</svg>'], ["flag-20x20", '<svg viewBox="0 0 20 20" stroke="none">\n			<path\n				d="M16.9987 4.27111C16.936 5.06715 16.3836 5.93162 15.5238 6.57845C14.7549 7.15682 13.0885 8.04927 10.5434 7.55174C8.32167 7.1164 6.82156 8.02129 6.08085 10.2416L8.24615 17.3998C8.31833 17.6471 8.17711 17.9059 7.9292 17.9813C7.88527 17.9938 7.83976 18 7.79426 18C7.58634 18 7.40277 17.8647 7.34236 17.6673L5.1644 10.4686C5.13773 10.4173 5.12125 10.3613 5.11419 10.3038L3.41956 4.70042C3.38112 4.63512 3.35994 4.56127 3.3568 4.48587L3.02101 3.37886C2.98413 3.25992 2.9959 3.13165 3.05553 3.02203C3.11437 2.91242 3.21479 2.83079 3.33482 2.79504C3.45564 2.75928 3.5851 2.7725 3.69494 2.83235C3.80477 2.89144 3.88637 2.99172 3.92167 3.11143L3.9813 3.31355C4.38847 2.85956 4.90472 2.51439 5.48136 2.30915C6.97201 1.75566 8.95216 1.95467 10.6469 2.83156C11.6888 3.36951 14.3374 4.54493 16.3647 3.79553C16.5154 3.74111 16.684 3.76599 16.8127 3.86239C16.9406 3.95879 17.0105 4.11251 16.9987 4.27111Z"\n				stroke="none"\n			/>\n		</svg>'], ["link-16x16", '<svg viewBox="0 0 16 16" stroke="none">\n			<path\n				d="M9.10678 11.2433C9.07993 11.2167 9.04367 11.2018 9.00589 11.2018C8.9681 11.2018 8.93184 11.2167 8.90499 11.2433L6.82999 13.3183C5.86928 14.279 4.24785 14.3808 3.18714 13.3183C2.12464 12.2558 2.22642 10.6362 3.18714 9.67546L5.26214 7.60046C5.31749 7.5451 5.31749 7.45403 5.26214 7.39868L4.55142 6.68796C4.52457 6.66138 4.48832 6.64646 4.45053 6.64646C4.41274 6.64646 4.37649 6.66138 4.34964 6.68796L2.27464 8.76296C0.763923 10.2737 0.763923 12.7183 2.27464 14.2272C3.78535 15.7362 6.22999 15.738 7.73892 14.2272L9.81392 12.1522C9.86928 12.0969 9.86928 12.0058 9.81392 11.9505L9.10678 11.2433ZM13.7246 2.77903C12.2139 1.26832 9.76928 1.26832 8.26035 2.77903L6.18357 4.85403C6.15698 4.88088 6.14207 4.91714 6.14207 4.95493C6.14207 4.99271 6.15698 5.02897 6.18357 5.05582L6.89249 5.76475C6.94785 5.8201 7.03892 5.8201 7.09428 5.76475L9.16928 3.68975C10.13 2.72903 11.7514 2.62725 12.8121 3.68975C13.8746 4.75225 13.7729 6.37189 12.8121 7.3326L10.7371 9.4076C10.7106 9.43445 10.6956 9.47071 10.6956 9.5085C10.6956 9.54628 10.7106 9.58254 10.7371 9.60939L11.4479 10.3201C11.5032 10.3755 11.5943 10.3755 11.6496 10.3201L13.7246 8.2451C15.2336 6.73439 15.2336 4.28975 13.7246 2.77903ZM9.75142 6.00939C9.72457 5.9828 9.68832 5.96789 9.65053 5.96789C9.61275 5.96789 9.57649 5.9828 9.54964 6.00939L5.50499 10.0522C5.47841 10.0791 5.46349 10.1154 5.46349 10.1531C5.46349 10.1909 5.47841 10.2272 5.50499 10.254L6.21214 10.9612C6.26749 11.0165 6.35857 11.0165 6.41392 10.9612L10.4568 6.91832C10.5121 6.86296 10.5121 6.77189 10.4568 6.71653L9.75142 6.00939Z"\n				stroke="none"\n			/>\n		</svg>']]), tZ = /<svg([^>]*)>/g;
function wD(r5, t, e) {
  let n4 = QW.get(r5);
  return n4 ? n4.replace(tZ, '<svg$1 style="fill:'.concat(t, "; width:").concat(e, "px; height:").concat(e, 'px">')) : "";
}
H$3(wD, "getStyledIcon");
var eZ = H$3((r5) => '\n		<div class="pin-shadow" style="background: '.concat(r5, '"></div>\n		<svg width="').concat(20 * 0.9, 'px" height="').concat(48 * 0.9, 'px" viewBox="0 0 20 48">\n			<path\n				d="M1.37965 29.3246C1.5778 31.2167 2.27661 33.0694 3.83078 33.775C4.0998 37.1861 4.7451 40.2227 5.65918 42.4784C6.14556 43.6787 6.72883 44.71 7.41453 45.4578C8.10027 46.2056 8.97065 46.7527 9.99989 46.7527C11.0292 46.7527 11.8995 46.2055 12.585 45.4576C13.2706 44.7098 13.8536 43.6785 14.3398 42.4783C15.2536 40.2226 15.8988 37.186 16.1688 33.7752C17.7232 33.0697 18.422 31.2169 18.6201 29.3247C18.8386 27.2385 18.5165 24.6502 17.6475 22.0285L17.6473 22.0278C16.9657 19.9761 16.0319 18.1622 14.9848 16.7474C17.0884 15.1587 18.4471 12.5964 18.4471 9.7152C18.4471 4.93539 14.6967 1 9.99966 1C5.30272 1 1.54993 4.93527 1.54993 9.7152C1.54993 12.5961 2.90839 15.1583 5.01167 16.747C3.9635 18.1625 3.03185 19.977 2.3522 22.0286C1.48319 24.6503 1.16118 27.2385 1.37965 29.3246Z"\n				fill="').concat(r5, '"\n				stroke="white"\n				strokeWidth="2"\n			/>\n		</svg>\n	'), "getDeparturePin"), rZ = H$3((r5) => '\n		<div class="pin-shadow" style="background: '.concat(r5, '"></div>\n		<svg width="36" height="42" viewBox="-2 -2 40 46">\n			<path\n				d="M35.8372 5.86776C35.6765 7.92448 34.2625 10.158 32.0612 11.8292C30.0929 13.3235 25.8269 15.6292 19.3114 14.3438C13.6237 13.219 9.78333 15.5569 7.88708 21.2934L13.4303 39.7879C13.6151 40.4267 13.2536 41.0955 12.6189 41.2903C12.5064 41.3225 12.39 41.3385 12.2735 41.3385C11.7412 41.3385 11.2712 40.989 11.1166 40.4789L5.54093 21.88C5.47265 21.7474 5.43047 21.6028 5.41239 21.4542L1.07409 6.97696C0.975678 6.80825 0.921449 6.61744 0.913417 6.42263L0.053779 3.56251C-0.0406172 3.2552 -0.0104927 2.92379 0.142154 2.64058C0.29279 2.35738 0.549874 2.14649 0.857157 2.05411C1.16646 1.96172 1.49786 1.99587 1.77906 2.15052C2.06025 2.30317 2.26912 2.56226 2.35951 2.87155L2.51215 3.39375C3.55453 2.22081 4.87615 1.32902 6.35237 0.798742C10.1685 -0.631292 15.2377 -0.117113 19.5763 2.14846C22.2435 3.53834 29.0241 6.57524 34.2141 4.63904C34.5998 4.49845 35.0316 4.56272 35.361 4.81178C35.6884 5.06083 35.8673 5.45801 35.8372 5.86776Z"\n				fill="none"\n				stroke="white"\n				strokeWidth="4"\n			/>\n			<path\n				d="M35.8372 5.86776C35.6765 7.92448 34.2625 10.158 32.0612 11.8292C30.0929 13.3235 25.8269 15.6292 19.3114 14.3438C13.6237 13.219 9.78333 15.5569 7.88708 21.2934L13.4303 39.7879C13.6151 40.4267 13.2536 41.0955 12.6189 41.2903C12.5064 41.3225 12.39 41.3385 12.2735 41.3385C11.7412 41.3385 11.2712 40.989 11.1166 40.4789L5.54093 21.88C5.47265 21.7474 5.43047 21.6028 5.41239 21.4542L1.07409 6.97696C0.975678 6.80825 0.921449 6.61744 0.913417 6.42263L0.053779 3.56251C-0.0406172 3.2552 -0.0104927 2.92379 0.142154 2.64058C0.29279 2.35738 0.549874 2.14649 0.857157 2.05411C1.16646 1.96172 1.49786 1.99587 1.77906 2.15052C2.06025 2.30317 2.26912 2.56226 2.35951 2.87155L2.51215 3.39375C3.55453 2.22081 4.87615 1.32902 6.35237 0.798742C10.1685 -0.631292 15.2377 -0.117113 19.5763 2.14846C22.2435 3.53834 29.0241 6.57524 34.2141 4.63904C34.5998 4.49845 35.0316 4.56272 35.361 4.81178C35.6884 5.06083 35.8673 5.45801 35.8372 5.86776Z"\n				fill="').concat(r5, '"\n			/>\n		</svg>\n    '), "getDestinationPin"), RM = "#722ED1", FM = "#1890FF", PD = H$3(({ type: r5 = "departure", color: t = FM }) => '<div class="dropped-pin-wrapper">\n			'.concat(r5 === "departure" ? eZ(t) : rZ(t), "\n		</div>"), "DroppedPin"), nZ = H$3((r5) => {
  switch (r5) {
    case "default":
      return 28;
    case "selection":
      return 28;
    case "navigation":
      return 32;
  }
}, "getSize"), ED = H$3(({ type: r5 = "stairs", color: t = RM, direction: e = "up" }) => {
  let n4 = nZ("default"), i = n4 / 2 + 2, a4 = e && e !== "none";
  return '<div class="mappedin-connection-marker">\n			<div class="connection-circle"\n				role="button"\n                style="background:'.concat(t, "; width:").concat(n4, "px; height:").concat(n4, 'px;"\n			>\n                ').concat(wD("connection-" + r5 + "-16x16", "white", i) || "", "\n			</div>\n			").concat(a4 ? '<div style="margin-left: -'.concat(n4 * 0.2, 'px;">\n					<div class="bouncey">\n						<div class="connection-circle"\n							role="button"\n							style="width: ').concat(n4, "px; height: ").concat(n4, 'px;">\n							<div class="').concat(e === "up" ? "" : "arrow--down", '">\n                                <svg viewBox="0 0 16 16" style="fill: white; width: ').concat(i, "px; height: ").concat(i, 'px">\n                                    <path\n                                        fillRule="evenodd"\n                                        clipRule="evenodd"\n                                        d="M8.00015 0.5C8.34685 0.5 8.67835 0.642318 8.91714 0.893677L15.6517 7.98267C15.8441 8.18525 15.8359 8.50548 15.6333 8.69793L14.533 9.7433C14.3304 9.93575 14.0101 9.92754 13.8177 9.72496L9.26497 4.93262V15.4249C9.26497 15.7043 9.03846 15.9308 8.75904 15.9308H7.24125C6.96184 15.9308 6.73532 15.7043 6.73532 15.4249V4.93262L2.1826 9.72496C1.99015 9.92754 1.66992 9.93575 1.46734 9.7433L0.366945 8.69793C0.164367 8.50548 0.156156 8.18525 0.348604 7.98267L7.08315 0.893677C7.32194 0.642318 7.65344 0.5 8.00015 0.5Z"\n                                        stroke="none"\n                                    />\n                                </svg>\n							</div>\n						</div>\n					</div>\n				</div>') : "", "\n		</div>");
}, "ConnectionMarker");
a();
var OD = H$3(async (r5) => new Promise((t) => setTimeout(t, r5)), "ms");
var iZ = { drawDuration: 1e3, color: "#40A9FF", interactive: false, accentColor: "blue", nearRadius: 0.25, farRadius: 0.25 * 4, displayArrowsOnPath: false, animateArrowsOnPath: false }, oZ = { drawDuration: 1e3, color: "#B3DDFF", interactive: false, accentColor: "#40A9FF", nearRadius: 0.25, farRadius: 0.25 * 4, displayArrowsOnPath: false, animateArrowsOnPath: false }, zc3 = { setMapOnConnectionClick: true, setMapToDeparture: true, createMarkers: { departure: true, destination: true, connection: true }, pathOptions: iZ, inactivePathOptions: oZ, markerOptions: { departureColor: FM, destinationColor: RM }, animatePathDrawing: true }, wu, xa2, Gs2, yr, L1, Pu, of2, jn2, _a2, Xo, Vs2, Hc2, Kr2, DD, LD, BM, O1, d2, Cm, GM, Sm, VM = class VM2 {
  constructor(t, e, n4) {
    Q$3(this, Kr2);
    Q$3(this, wu, /* @__PURE__ */ new Map());
    Q$3(this, xa2);
    Q$3(this, Gs2);
    Q$3(this, yr, zc3);
    Q$3(this, L1);
    Q$3(this, Pu);
    Q$3(this, of2);
    Q$3(this, jn2, []);
    Q$3(this, _a2);
    Q$3(this, Xo, /* @__PURE__ */ new Map());
    Q$3(this, Vs2, /* @__PURE__ */ new Map());
    Q$3(this, Hc2, /* @__PURE__ */ new Map());
    Q$3(this, Sm, H$3((t5) => {
      var e4;
      if ((e4 = P(this, yr).createMarkers) != null && e4.connection && t5.markers.length > 0) {
        let { instruction: n5 } = P(this, wu).get(t5.markers[0]);
        n5 != null && n5.action.toFloor && (P(this, yr).setMapOnConnectionClick && this.currentMap.setFloor(n5.action.toFloor.id, "navigation-connection-click"), P(this, Gs2).publish("navigation-connection-click", { instruction: n5, fromFloor: n5.action.fromFloor, toFloor: n5.action.toFloor }));
      }
    }, "#handleClick"));
    R$1(this, xa2, t), R$1(this, L1, n4), R$1(this, Gs2, e);
  }
  get currentMap() {
    return P(this, L1).call(this);
  }
  get isMultiFloor() {
    if (!P(this, jn2).length) return false;
    let t = /* @__PURE__ */ new Set();
    for (let e of P(this, jn2)) for (let n4 of e.coordinates) if (n4.floorId && (t.add(n4.floorId), t.size > 1)) return true;
    return false;
  }
  getPathById(t) {
    return P(this, Xo).get(t);
  }
  getMarkerById(t) {
    return P(this, wu).get(t);
  }
  get paths() {
    let t = /* @__PURE__ */ new Set();
    return P(this, Xo).forEach(({ path: e }) => t.add(e)), Array.from(t);
  }
  get activeDirections() {
    return P(this, Hc2).get(P(this, _a2));
  }
  get activePath() {
    var t;
    if (P(this, _a2)) return (t = P(this, Xo).get(P(this, _a2).id)) == null ? void 0 : t.path;
  }
  get floorStacks() {
    let t = P(this, Gs2).getMapData();
    if (!P(this, jn2).length || !t) return [];
    let e = /* @__PURE__ */ new Set();
    for (let n4 of P(this, jn2)) for (let i of n4.coordinates) if (i.floorId) {
      let a4 = t.getById("floor", i.floorId);
      a4 && e.add(a4.floorStack);
    }
    return Array.from(e);
  }
  get floors() {
    let t = P(this, Gs2).getMapData();
    if (!P(this, jn2).length || !t) return [];
    let e = /* @__PURE__ */ new Set();
    for (let n4 of P(this, jn2)) for (let i of n4.coordinates) if (i.floorId) {
      let a4 = t.getById("floor", i.floorId);
      a4 && e.add(a4);
    }
    return Array.from(e);
  }
  setActivePathByIndex(t) {
    let e = P(this, jn2)[t];
    if (!P(this, jn2).length) {
      B.warn("Cannot set an active path before drawing. Call Navigation.draw() first.");
      return;
    }
    if (!P(this, jn2)[t]) {
      B.warn("Direction #".concat(t, " does not exist"));
      return;
    }
    let n4 = P(this, Vs2).get(e);
    if (!n4) {
      B.warn("The direction is not a part of muli-direcional path");
      return;
    }
    S$1(this, Kr2, d2).call(this, n4);
  }
  setActivePath(t) {
    if (!P(this, jn2).length) {
      B.warn("Cannot set an active path before drawing. Call Navigation.draw() first.");
      return;
    }
    if (!P(this, Hc2).get(t)) {
      B.warn('Path "'.concat(t.id, '" is not a part of muli-direcional path'));
      return;
    }
    S$1(this, Kr2, d2).call(this, t);
  }
  setActivePathByDirections(t) {
    if (!P(this, jn2).length) {
      B.warn("[setActivePathByDirections] Cannot set an active path before drawing. Call Navigation.draw() first.");
      return;
    }
    let e = P(this, Vs2).get(t);
    if (!e) {
      let n4 = P(this, jn2).find((i) => i.id === t.id);
      if (!n4) {
        B.warn("[setActivePathByDirections] Cannot find directions for id");
        return;
      }
      e = P(this, Vs2).get(n4);
    }
    if (!e) {
      B.warn("[setActivePathByDirections] Cannot find path for directions");
      return;
    }
    S$1(this, Kr2, d2).call(this, e);
  }
  drawSync(t, e = {}) {
    var h, d, m5;
    P(this, of2) && this.clear(), R$1(this, of2, true), S$1(this, Kr2, BM).call(this, e);
    let n4 = Array.isArray(t) ? t : [t], i = n4[0], a4 = n4[n4.length - 1], u5 = i.coordinates[0];
    R$1(this, jn2, n4), u5.floorId && P(this, yr).setMapToDeparture && this.currentMap.setFloor(u5.floorId), (h = P(this, yr).createMarkers) != null && h.departure && S$1(this, Kr2, Cm).call(this, i.coordinates[0], "departure", i.instructions[0]);
    for (let v3 = 0; v3 < n4.length; v3++) {
      let x2 = n4[v3], S4 = v3 ? F$1({}, P(this, yr).inactivePathOptions) : F$1({}, P(this, yr).pathOptions);
      if (x2.coordinates.length < 2) {
        B.warn("Directions must have at least 2 coordinates");
        return;
      }
      let I3 = this.currentMap.Paths.add(x2.coordinates, G$1(F$1({}, S4), { animateDrawing: P(this, yr).animatePathDrawing })), w3 = I3.paths.map((T3) => T3.id.toString()), E$12 = new ba2(E(), I3.animation, x2.coordinates, I3.paths);
      for (let T3 of w3) {
        P(this, Xo).set(T3, { path: E$12, entityIds: w3 });
        let D4 = v3 ? G$1(F$1({}, P(this, yr).inactivePathOptions), { altitude: 0 }) : G$1(F$1({}, P(this, yr).pathOptions), { altitude: 0.05 });
        P(this, xa2).setState(T3, D4);
      }
      P(this, Xo).set(E$12.id, { path: E$12, entityIds: w3 }), P(this, Vs2).set(x2, E$12), P(this, Hc2).set(E$12, x2), (d = P(this, yr).createMarkers) != null && d.connection && S$1(this, Kr2, GM).call(this, x2.instructions, "connection"), v3 === 0 && (R$1(this, _a2, P(this, Vs2).get(P(this, jn2)[0])), P(this, xa2).on("click", P(this, Sm)));
    }
    (m5 = P(this, yr).createMarkers) != null && m5.destination && S$1(this, Kr2, Cm).call(this, a4.coordinates[a4.coordinates.length - 1], "destination", a4.instructions[a4.instructions.length - 1]), P(this, Gs2).mapObjects.forEach((v3) => {
      v3.processFloorChange(v3.currentFloorId);
    }), S$1(this, Kr2, O1).call(this);
  }
  async draw(t, e = {}) {
    P(this, Pu) && this.clear(), S$1(this, Kr2, BM).call(this, e);
    let n4 = Array.isArray(t) ? t : [t], a4 = n4[0].coordinates[0];
    return R$1(this, jn2, n4), a4.floorId && P(this, yr).setMapToDeparture && this.currentMap.setFloor(a4.floorId), S$1(this, Kr2, LD).call(this, n4);
  }
  clear() {
    P(this, wu).forEach((t, e) => {
      this.currentMap.Markers.remove(e.toString());
    }), P(this, wu).clear(), P(this, Xo).forEach(({ path: t, entityIds: e }) => {
      P(this, Xo).delete(t.id), e.forEach((n4) => P(this, Xo).delete(n4)), this.currentMap.Paths.remove(e);
    }), P(this, Pu) && (P(this, Pu).cancel(), R$1(this, Pu, void 0)), P(this, of2) && R$1(this, of2, false), R$1(this, jn2, []), P(this, Vs2).clear(), P(this, Hc2).clear(), R$1(this, _a2, void 0), P(this, xa2).off("click", P(this, Sm)), P(this, Gs2).mapObjects.forEach((t) => {
      t.processFloorChange(t.currentFloorId);
    }), S$1(this, Kr2, O1).call(this);
  }
};
wu = /* @__PURE__ */ new WeakMap(), xa2 = /* @__PURE__ */ new WeakMap(), Gs2 = /* @__PURE__ */ new WeakMap(), yr = /* @__PURE__ */ new WeakMap(), L1 = /* @__PURE__ */ new WeakMap(), Pu = /* @__PURE__ */ new WeakMap(), of2 = /* @__PURE__ */ new WeakMap(), jn2 = /* @__PURE__ */ new WeakMap(), _a2 = /* @__PURE__ */ new WeakMap(), Xo = /* @__PURE__ */ new WeakMap(), Vs2 = /* @__PURE__ */ new WeakMap(), Hc2 = /* @__PURE__ */ new WeakMap(), Kr2 = /* @__PURE__ */ new WeakSet(), DD = H$3(function(t) {
  return t != null && ["TakeConnection", "ExitConnection", "TakeVortex", "ExitVortex"].includes(t.type);
}, "#isVortexAction"), LD = H$3(function(t) {
  let e = t[0], n4 = t[t.length - 1], i = false;
  return R$1(this, Pu, { promise: new Promise(async (a4) => {
    var u5, h, d;
    if (p$1.env.NODE_ENV !== "test" && await OD(500), i || !t.length) {
      a4();
      return;
    }
    (u5 = P(this, yr).createMarkers) != null && u5.departure && S$1(this, Kr2, Cm).call(this, e.coordinates[0], "departure", e.instructions[0]);
    for (let m5 = 0; m5 < t.length; m5++) {
      let v3 = t[m5], x2 = m5 ? F$1({}, P(this, yr).inactivePathOptions) : F$1({}, P(this, yr).pathOptions);
      if (v3.coordinates.length < 2) {
        B.warn("Directions must have at least 2 coordinates"), a4();
        return;
      }
      let S4 = this.currentMap.Paths.add(v3.coordinates, G$1(F$1({}, x2), { animateDrawing: P(this, yr).animatePathDrawing })), I3 = S4.paths.map((E4) => E4.id.toString()), w3 = new ba2(E(), S4.animation, v3.coordinates, S4.paths);
      for (let E4 of I3) {
        P(this, Xo).set(E4, { path: w3, entityIds: I3 });
        let T3 = m5 ? G$1(F$1({}, P(this, yr).inactivePathOptions), { altitude: 0 }) : G$1(F$1({}, P(this, yr).pathOptions), { altitude: 0.05 });
        P(this, xa2).setState(E4, T3);
      }
      if (P(this, Xo).set(w3.id, { path: w3, entityIds: I3 }), P(this, Vs2).set(v3, w3), P(this, Hc2).set(w3, v3), p$1.env.NODE_ENV !== "test" && await S4.animation, i) {
        a4();
        return;
      }
      (h = P(this, yr).createMarkers) != null && h.connection && S$1(this, Kr2, GM).call(this, v3.instructions, "connection"), m5 === 0 && (R$1(this, _a2, P(this, Vs2).get(P(this, jn2)[0])), P(this, xa2).on("click", P(this, Sm)));
    }
    if ((d = P(this, yr).createMarkers) != null && d.destination && S$1(this, Kr2, Cm).call(this, n4.coordinates[n4.coordinates.length - 1], "destination", n4.instructions[n4.instructions.length - 1]), i) {
      a4();
      return;
    }
    P(this, Gs2).mapObjects.forEach((m5) => {
      m5.processFloorChange(m5.currentFloorId);
    }), S$1(this, Kr2, O1).call(this), a4();
  }), cancel: H$3(() => {
    i = true;
  }, "cancel") }), P(this, Pu).promise;
}, "#drawAsync"), BM = H$3(function(t) {
  var e, n4, i;
  R$1(this, yr, { setMapOnConnectionClick: (e = t.setMapOnConnectionClick) != null ? e : zc3.setMapOnConnectionClick, setMapToDeparture: (n4 = t.setMapToDeparture) != null ? n4 : zc3.setMapToDeparture, pathOptions: F$1(F$1({}, zc3.pathOptions), t.pathOptions), inactivePathOptions: F$1(F$1({}, zc3.inactivePathOptions), t.inactivePathOptions), createMarkers: F$1(F$1({}, zc3.createMarkers), t.createMarkers), markerOptions: F$1(F$1({}, zc3.markerOptions), t.markerOptions), animatePathDrawing: (i = t.animatePathDrawing) != null ? i : zc3.animatePathDrawing });
}, "#setupOptions"), O1 = H$3(function() {
  P(this, Gs2).publish("navigation-state-change", { isMultiFloor: this.isMultiFloor, floorStacks: this.floorStacks, floors: this.floors, activeDirections: this.activeDirections, activePath: this.activePath, paths: this.paths });
}, "#emitNavigationStateChanged"), d2 = H$3(function(t) {
  R$1(this, _a2, t), P(this, jn2).forEach((e) => {
    let n4 = P(this, Vs2).get(e);
    if (n4) {
      let i = P(this, Xo).get(n4.id), a4 = i.path.id === P(this, _a2).id ? G$1(F$1({}, P(this, yr).pathOptions), { altitude: 0.05 }) : G$1(F$1({}, P(this, yr).inactivePathOptions), { altitude: 0 });
      i.entityIds.forEach((u5) => {
        P(this, xa2).setState(u5, a4);
      });
    }
  }), P(this, Gs2).publish("navigation-active-path-change", { directions: this.activeDirections, path: this.activePath }), S$1(this, Kr2, O1).call(this);
}, "#setActiveDirections"), Cm = H$3(function(t, e, n4) {
  var i, a4, u5, h, d;
  if (e === "connection" && n4) {
    let m5 = n4.action.type === "ExitConnection" ? P(this, yr).markerOptions.departureColor : P(this, yr).markerOptions.destinationColor, v3;
    if (typeof ((i = P(this, yr).createMarkers) == null ? void 0 : i.connection) == "function") {
      let S4 = P(this, yr).createMarkers.connection(n4);
      P(this, xa2).setState(S4.id.toString(), { options: { interactive: true } }), v3 = { id: S4.id, type: "marker" };
    } else v3 = this.currentMap.Markers.add(n4.coordinate, ED({ type: (u5 = (a4 = n4.action.connection) == null ? void 0 : a4.type) != null ? u5 : n4.action.connectionType, color: m5, direction: n4.action.direction }), { interactive: true, anchor: "top", rank: "always-visible" });
    let x2 = this.currentMap.Markers.getContentEl(v3.id.toString());
    if (!x2) throw new Error("marker component should exist");
    P(this, wu).set(v3.id, { instruction: n4, marker: new Mu(v3.id.toString(), x2, n4.coordinate) });
  } else {
    let m5 = e === "departure" ? P(this, yr).markerOptions.departureColor : P(this, yr).markerOptions.destinationColor, v3;
    typeof ((h = P(this, yr).createMarkers) == null ? void 0 : h.departure) == "function" && e === "departure" ? v3 = { id: P(this, yr).createMarkers.departure(n4).id, type: "marker" } : typeof ((d = P(this, yr).createMarkers) == null ? void 0 : d.destination) == "function" && e === "destination" ? v3 = { id: P(this, yr).createMarkers.destination(n4).id, type: "marker" } : v3 = this.currentMap.Markers.add(t, PD({ type: e, color: m5 }), { anchor: "top", rank: "always-visible" }), P(this, wu).set(v3.id, void 0);
  }
}, "#addMarker"), GM = H$3(function(t, e) {
  t.filter((i) => S$1(this, Kr2, DD).call(this, i.action)).forEach((i) => {
    S$1(this, Kr2, Cm).call(this, i.coordinate, e, i);
  });
}, "#addMarkers"), Sm = /* @__PURE__ */ new WeakMap(), H$3(VM, "Navigation");
var D1 = VM;
a();
a();
a();
var sZ = /* @__PURE__ */ new Map([["search-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7C13 8.29583 12.5892 9.49572 11.8907 10.4765L15.4614 14.0472C15.6567 14.2425 15.6567 14.559 15.4614 14.7543L14.7543 15.4614C14.559 15.6567 14.2424 15.6567 14.0472 15.4614L10.4765 11.8907C9.49571 12.5892 8.29583 13 7 13C3.68629 13 1 10.3137 1 7ZM7 11C4.79086 11 3 9.20914 3 7C3 4.79086 4.79086 3 7 3C9.20914 3 11 4.79086 11 7C11 9.20914 9.20914 11 7 11Z"\n				stroke="none"\n			/>\n		</svg>'], ["close-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M12.5963 1.98959C12.7916 1.79433 13.1082 1.79433 13.3034 1.98959L14.0105 2.6967C14.2058 2.89196 14.2058 3.20855 14.0105 3.40381L3.40392 14.0104C3.20866 14.2057 2.89208 14.2057 2.69682 14.0104L1.98971 13.3033C1.79445 13.108 1.79445 12.7915 1.98971 12.5962L12.5963 1.98959Z"\n				stroke="none"\n			/>\n			<path\n				d="M1.98971 3.40381C1.79445 3.20855 1.79445 2.89196 1.98971 2.6967L2.69682 1.98959C2.89208 1.79433 3.20866 1.79433 3.40392 1.98959L14.0105 12.5962C14.2058 12.7915 14.2058 13.108 14.0105 13.3033L13.3034 14.0104C13.1082 14.2057 12.7916 14.2057 12.5963 14.0104L1.98971 3.40381Z"\n				stroke="none"\n			/>\n		</svg>'], ["empty-64x40", '<svg viewBox="0 0 64 40">\n			<g>\n				<g clipPath="url(#clip0_499_175492)">\n					<path\n						d="M32 39.7032C49.6731 39.7032 64 36.5925 64 32.7552C64 28.9179 49.6731 25.8071 32 25.8071C14.3269 25.8071 0 28.9179 0 32.7552C0 36.5925 14.3269 39.7032 32 39.7032Z"\n						stroke="none"\n						fill="#F5F5F5"\n					/>\n					<path\n						d="M55 13.6653L44.854 2.24866C44.367 1.47048 43.656 1 42.907 1H21.093C20.344 1 19.633 1.47048 19.146 2.24767L9 13.6663V22.8367H55V13.6653Z"\n						fill="none"\n					/>\n					<path\n						d="M41.613 16.8128C41.613 15.2197 42.607 13.9046 43.84 13.9036H55V31.9059C55 34.0132 53.68 35.7402 52.05 35.7402H11.95C10.32 35.7402 9 34.0122 9 31.9059V13.9036H20.16C21.393 13.9036 22.387 15.2167 22.387 16.8098V16.8317C22.387 18.4248 23.392 19.7111 24.624 19.7111H39.376C40.608 19.7111 41.613 18.4128 41.613 16.8198V16.8128Z"\n						fill="#FAFAFA"\n					/>\n				</g>\n				<defs>\n					<clipPath id="clip0_499_175492">\n						<rect width="64" height="40" fill="white" />\n					</clipPath>\n				</defs>\n			</g>\n		</svg>'], ["caret-12x12", '<svg viewBox="0 0 12 12">\n			<path\n				stroke="none"\n				d="M8.38828 5.78337L3.92578 1.93493C3.75938 1.79196 3.51562 1.92087 3.51562 2.15173V9.84861C3.51562 10.0795 3.75938 10.2084 3.92578 10.0654L8.38828 6.21696C8.51602 6.10681 8.51602 5.89353 8.38828 5.78337Z"\n			/>\n		</svg>'], ["plus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M7.5 1C7.22386 1 7 1.22386 7 1.5V7H1.5C1.22386 7 1 7.22386 1 7.5L1 8.5C1 8.77614 1.22386 9 1.5 9H7V14.5C7 14.7761 7.22386 15 7.5 15H8.5C8.77614 15 9 14.7761 9 14.5V9H14.5C14.7761 9 15 8.77614 15 8.5V7.5C15 7.22386 14.7761 7 14.5 7H9V1.5C9 1.22386 8.77614 1 8.5 1H7.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["recenter-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M0 2.5C0 2.22386 0.223858 2 0.5 2H1.5C1.77614 2 2 2.22386 2 2.5V13.5C2 13.7761 1.77614 14 1.5 14H0.5C0.223858 14 0 13.7761 0 13.5V2.5Z" />\n				<path\n					fillRule="evenodd"\n					clipRule="evenodd"\n					d="M4.5 4C4.22386 4 4 4.22386 4 4.5V11.5C4 11.7761 4.22386 12 4.5 12H11.5C11.7761 12 12 11.7761 12 11.5V4.5C12 4.22386 11.7761 4 11.5 4H4.5ZM6 6V10H10V6H6Z"\n				/>\n				<path d="M14.5 2C14.2239 2 14 2.22386 14 2.5V13.5C14 13.7761 14.2239 14 14.5 14H15.5C15.7761 14 16 13.7761 16 13.5V2.5C16 2.22386 15.7761 2 15.5 2H14.5Z" />\n			</g>\n		</svg>'], ["minus-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				d="M1.5 9C1.22386 9 1 8.77614 1 8.5L1 7.5C1 7.22386 1.22386 7 1.5 7L14.5 7C14.7761 7 15 7.22386 15 7.5V8.5C15 8.77614 14.7761 9 14.5 9L1.5 9Z"\n				stroke="none"\n			/>\n		</svg>'], ["logo-horizontal-206x48", '<svg viewBox="0 0 206 48">\n			<path d="M27.2678 14.2261H22.3187C21.0695 14.2261 20.4695 14.7801 20.4695 15.9852V31.142L10.3966 15.5591C9.69665 14.4784 9.2475 14.2773 7.8475 14.2261H2.97462C1.67462 14.2261 1.07631 14.7801 1.07631 15.9852V44.7665C1.07631 45.9716 1.67462 46.5256 2.97462 46.5256H7.92377C9.22207 46.5256 9.82207 45.9716 9.82207 44.7665V29.6847L19.9441 45.1926C20.695 46.3244 21.095 46.5256 22.4933 46.5256H27.2933C28.5916 46.5256 29.1916 45.9716 29.1916 44.7665V15.9852C29.1407 14.7801 28.5424 14.2261 27.2678 14.2261Z" />\n			<path d="M5.44915 10.9602C8.45863 10.9602 10.8983 8.50669 10.8983 5.48011C10.8983 2.45353 8.45863 0 5.44915 0C2.43967 0 0 2.45353 0 5.48011C0 8.50669 2.43967 10.9602 5.44915 10.9602Z" />\n			<path d="M61.7899 25.0449C63.2306 23.1903 65.078 22.2051 67.556 22.2051C72.0526 22.2051 74.7611 25.3347 74.7611 29.4511V39.2489C74.8187 39.7125 74.5306 39.9443 74.0695 39.9443H72.5136C72.0526 39.9443 71.7645 39.7125 71.8221 39.2489V29.5091C71.8221 27.1909 69.9187 25.2187 67.4984 25.2187C65.1339 25.2187 63.2323 27.1329 63.2323 29.2773V39.2489C63.2899 39.7125 63.0018 39.9443 62.5407 39.9443H60.9831C60.5221 39.9443 60.2916 39.7125 60.2916 39.2489V29.4511C60.2916 27.1329 58.3899 25.2187 56.0255 25.2187C53.7204 25.2187 51.7594 27.075 51.7594 29.2773V39.3068C51.817 39.7705 51.5289 40.0023 51.0102 40.0023H49.5119C49.0509 40.0023 48.7628 39.7705 48.7628 39.3068V23.25C48.7051 22.7864 48.9933 22.4966 49.5119 22.4966H50.9526C51.356 22.4966 51.5289 22.6704 51.5289 23.0182V24.2352C52.7407 22.9602 54.239 22.2648 56.0255 22.2648C58.4475 22.2068 60.3492 23.192 61.7899 25.0466V25.0449ZM77.1255 31.2477C77.1255 26.3216 81.1018 22.2051 86.1187 22.2051C88.539 22.2051 90.6136 23.1903 92.3441 25.1608V23.1903C92.3441 22.7267 92.5746 22.5528 93.0357 22.5528H94.4187C94.8797 22.5528 95.1102 22.7847 95.1102 23.3062V39.3648C95.1102 39.8284 94.8797 40.0602 94.4187 40.0602H93.0357C92.5746 40.0602 92.3441 39.8284 92.3441 39.4227V37.4523C90.6712 39.3648 88.5967 40.35 86.1746 40.35C81.1018 40.2341 77.1238 36.1773 77.1238 31.2477H77.1255ZM92.1136 31.2477C92.1136 27.8284 89.4611 25.2187 86.0594 25.2187C82.7746 25.2187 80.1221 27.8864 80.1221 31.2477C80.1221 34.6687 82.7746 37.2784 86.1187 37.2784C86.9062 37.2789 87.6861 37.1232 88.4138 36.8202C89.1414 36.5173 89.8026 36.0731 90.3593 35.513C90.9161 34.9528 91.3577 34.2878 91.6587 33.556C91.9597 32.8241 92.1143 32.0397 92.1136 31.2477ZM100.992 37.3943V46.3807C101.049 46.8443 100.761 47.1341 100.298 47.1341H98.7424C98.2814 47.1341 97.9933 46.9023 97.9933 46.3807V23.1903C97.9933 22.7267 98.2238 22.4369 98.7424 22.4369H100.183C100.646 22.379 100.934 22.6687 100.934 23.0744V24.9869C102.605 23.0744 104.68 22.1472 107.044 22.1472C112.002 22.1472 116.037 26.2619 116.037 31.1898C116.037 36.1176 112.059 40.2341 107.044 40.2341C104.622 40.2341 102.603 39.3068 100.992 37.3943ZM106.987 25.2187C103.7 25.2187 101.049 27.8864 101.049 31.2477C101.049 34.6687 103.7 37.2784 107.044 37.2784C110.446 37.2784 113.039 34.6108 113.039 31.2477C113.039 27.8864 110.388 25.2187 106.987 25.2187ZM121.11 37.3943V46.3807C121.168 46.8443 120.88 47.1341 120.419 47.1341H118.861C118.4 47.1341 118.112 46.9023 118.112 46.3807V23.1903C118.112 22.7267 118.342 22.4369 118.861 22.4369H120.302C120.764 22.379 121.053 22.6687 121.053 23.0744V24.9869C122.724 23.0744 124.798 22.1472 127.163 22.1472C132.12 22.1472 136.156 26.2619 136.156 31.1898C136.156 36.1176 132.178 40.2341 127.163 40.2341C124.742 40.2341 122.781 39.3068 121.11 37.3943ZM127.105 25.2187C123.819 25.2187 121.168 27.8864 121.168 31.2477C121.168 34.6687 123.819 37.2784 127.163 37.2784C130.564 37.2784 133.158 34.6108 133.158 31.2477C133.158 27.8864 130.507 25.2187 127.107 25.2187H127.105ZM153.97 32.3506H141.054C141.342 35.2483 143.995 37.4523 147.164 37.4523C148.893 37.4523 150.393 37.0466 151.719 36.0597C152.007 35.8858 152.295 35.7699 152.353 35.7699C152.583 35.7699 152.756 35.8858 152.929 36.1773L153.505 37.1625C153.622 37.3364 153.68 37.4523 153.68 37.5682C153.68 37.8 153.507 38.0318 153.103 38.3216C151.258 39.5966 149.183 40.292 146.992 40.292C141.688 40.292 137.883 36.3511 137.883 31.2477C137.883 26.204 141.803 22.2051 146.703 22.2051C151.546 22.2051 154.717 25.7983 154.717 31.0176C154.717 31.5972 154.717 32.3506 153.968 32.3506H153.97ZM141.056 30.0324H151.72C151.432 26.8432 149.473 24.929 146.648 24.929C145.241 24.8904 143.875 25.3995 142.833 26.3501C141.791 27.3007 141.154 28.6194 141.056 30.0307V30.0324ZM156.332 31.2477C156.332 26.3216 160.31 22.2051 165.326 22.2051C167.748 22.2051 169.707 23.1324 171.32 25.0449V16.2324C171.263 15.7687 171.551 15.479 172.012 15.479H173.57C174.031 15.479 174.319 15.7108 174.319 16.2324V39.3068C174.319 39.7705 174.088 40.0023 173.57 40.0023H172.129C171.666 40.0602 171.378 39.7705 171.378 39.3648V37.3943C169.649 39.3068 167.632 40.292 165.268 40.292C160.31 40.2341 156.332 36.1773 156.332 31.2477ZM171.264 31.2477C171.264 27.8284 168.612 25.2187 165.21 25.2187C161.924 25.2187 159.273 27.8864 159.273 31.2477C159.273 34.6687 161.924 37.2784 165.268 37.2784C166.057 37.2838 166.839 37.1316 167.569 36.8304C168.299 36.5292 168.962 36.0852 169.52 35.5241C170.077 34.963 170.519 34.296 170.818 33.5619C171.117 32.8277 171.268 32.0411 171.263 31.2477H171.264ZM177.72 19.0739C177.715 18.8594 177.754 18.646 177.833 18.4468C177.912 18.2476 178.031 18.0667 178.182 17.915C178.333 17.7633 178.512 17.6439 178.71 17.5642C178.909 17.4845 179.121 17.446 179.334 17.4511C179.546 17.4507 179.756 17.4923 179.952 17.5737C180.148 17.6551 180.326 17.7746 180.476 17.9254C180.626 18.0762 180.745 18.2553 180.826 18.4523C180.907 18.6494 180.948 18.8606 180.948 19.0739C180.953 19.2884 180.914 19.5017 180.835 19.7009C180.756 19.9001 180.637 20.081 180.486 20.2327C180.335 20.3845 180.156 20.5038 179.957 20.5835C179.759 20.6633 179.547 20.7017 179.334 20.6966C178.412 20.7545 177.72 20.0591 177.72 19.0739ZM177.836 39.2489V23.1903C177.836 22.7267 178.066 22.4369 178.527 22.4369H180.083C180.544 22.4369 180.832 22.6687 180.775 23.1903V39.2489C180.832 39.7125 180.544 39.9443 180.083 39.9443H178.527C178.066 39.9443 177.836 39.7125 177.836 39.2489ZM186.944 23.0165V24.1756C188.212 22.8426 189.71 22.2051 191.497 22.2051C195.937 22.2051 198.646 25.2767 198.646 29.3932V39.2489C198.703 39.7125 198.415 39.9443 197.954 39.9443H196.398C195.936 39.9443 195.705 39.7125 195.705 39.2489V29.4511C195.705 27.1329 193.803 25.2187 191.439 25.2187C189.134 25.2187 187.175 27.075 187.175 29.2773V39.3068C187.232 39.7705 186.944 40.0023 186.424 40.0023H184.868C184.407 40.0023 184.119 39.7705 184.119 39.3068V23.1903C184.061 22.7267 184.349 22.4949 184.868 22.4949H186.309C186.712 22.4949 186.944 22.6687 186.944 23.0165Z" />\n			<path d="M204 40C205.115 40 206 39.0857 206 38V37.9886C206 36.9029 205.126 36 204 36C202.885 36 202 36.9143 202 38V38.0114C202 39.0971 202.874 40 204 40ZM204 39.7829C202.989 39.7829 202.23 38.9829 202.23 38.0114V38C202.23 37.0286 203 36.2171 204 36.2171C205.011 36.2171 205.77 37.0171 205.77 37.9886V38C205.77 38.9714 205 39.7829 204 39.7829ZM203.218 38.9714H203.609V38.2743H204.034L204.517 38.9714H204.989L204.448 38.2057C204.724 38.1257 204.92 37.92 204.92 37.5886C204.92 37.1657 204.586 36.9486 204.138 36.9486H203.218V38.9714ZM203.609 37.9543V37.2914H204.103C204.368 37.2914 204.517 37.4057 204.517 37.6229C204.517 37.8171 204.368 37.9543 204.103 37.9543H203.609Z" />\n		</svg>'], ["share-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M13 6C14.6569 6 16 4.65685 16 3C16 1.34315 14.6569 0 13 0C11.3431 0 10 1.34315 10 3C10 3.13463 10.0089 3.26719 10.0261 3.39712L6.82972 5.17286C6.10576 4.44825 5.10523 4 4 4C1.79086 4 0 5.79086 0 8C0 10.2091 1.79086 12 4 12C5.10523 12 6.10576 11.5518 6.82972 10.8271L10.0261 12.6029C10.0089 12.7328 10 12.8654 10 13C10 14.6569 11.3431 16 13 16C14.6569 16 16 14.6569 16 13C16 11.3431 14.6569 10 13 10C12.2011 10 11.4752 10.3123 10.9376 10.8214L7.84579 9.1037C7.94622 8.75313 8 8.38284 8 8C8 7.61716 7.94622 7.24687 7.84579 6.8963L10.9376 5.17864C11.4752 5.68775 12.2011 6 13 6ZM13 4C13.5523 4 14 3.55228 14 3C14 2.44772 13.5523 2 13 2C12.4477 2 12 2.44772 12 3C12 3.55228 12.4477 4 13 4ZM4 10C5.10457 10 6 9.10457 6 8C6 6.89543 5.10457 6 4 6C2.89543 6 2 6.89543 2 8C2 9.10457 2.89543 10 4 10ZM14 13C14 13.5523 13.5523 14 13 14C12.4477 14 12 13.5523 12 13C12 12.4477 12.4477 12 13 12C13.5523 12 14 12.4477 14 13Z"\n				stroke="none"\n			/>\n		</svg>'], ["checkmark-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M15.387 3.31662C15.6008 3.49148 15.6323 3.80649 15.4574 4.02021L6.77402 14.6332C6.58509 14.8642 6.30292 14.9986 6.00457 15C5.70622 15.0013 5.42285 14.8694 5.23184 14.6402L0.551937 9.02429C0.375155 8.81215 0.403817 8.49687 0.615956 8.32009L1.38418 7.67991C1.59632 7.50312 1.9116 7.53179 2.08838 7.74392L5.99299 12.4295L13.9095 2.75374C14.0844 2.54002 14.3994 2.50852 14.6131 2.68338L15.387 3.31662Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-right-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.35355 1.64645C8.54881 1.45118 8.8654 1.45118 9.06066 1.64645L14.7071 7.29289C15.0976 7.68342 15.0976 8.31658 14.7071 8.70711L9.06066 14.3536C8.8654 14.5488 8.54882 14.5488 8.35355 14.3536L7.64645 13.6464C7.45118 13.4512 7.45118 13.1346 7.64645 12.9393L11.5858 9H0.5C0.223858 9 0 8.77614 0 8.5V7.5C0 7.22386 0.223858 7 0.5 7H11.5858L7.64645 3.06066C7.45118 2.8654 7.45118 2.54882 7.64645 2.35355L8.35355 1.64645Z"\n				stroke="none"\n			/>\n		</svg>'], ["arrow-up-16x16", '<svg viewBox="0 0 16 16">\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M8.00015 0.5C8.34685 0.5 8.67835 0.642318 8.91714 0.893677L15.6517 7.98267C15.8441 8.18525 15.8359 8.50548 15.6333 8.69793L14.533 9.7433C14.3304 9.93575 14.0101 9.92754 13.8177 9.72496L9.26497 4.93262V15.4249C9.26497 15.7043 9.03846 15.9308 8.75904 15.9308H7.24125C6.96184 15.9308 6.73532 15.7043 6.73532 15.4249V4.93262L2.1826 9.72496C1.99015 9.92754 1.66992 9.93575 1.46734 9.7433L0.366945 8.69793C0.164367 8.50548 0.156156 8.18525 0.348604 7.98267L7.08315 0.893677C7.32194 0.642318 7.65344 0.5 8.00015 0.5Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M1 11.5C1 11.2239 1.22386 11 1.5 11H6V13.5C6 13.7761 5.77614 14 5.5 14H1.5C1.22386 14 1 13.7761 1 13.5V11.5Z" />\n				<path d="M4 8.5C4 8.22386 4.22386 8 4.5 8H9V10.5C9 10.7761 8.77614 11 8.5 11H4V8.5Z" />\n				<path d="M7 5.5C7 5.22386 7.22386 5 7.5 5H12V7.5C12 7.77614 11.7761 8 11.5 8H7V5.5Z" />\n				<path d="M10 2.5C10 2.22386 10.2239 2 10.5 2H14.5C14.7761 2 15 2.22386 15 2.5V4.5C15 4.77614 14.7761 5 14.5 5H10V2.5Z" />\n			</g>\n		</svg>'], ["connection-stairs-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.25 12H2.5C2.225 12 2 11.7429 2 11.4286C2 11.1143 2.225 10.8571 2.5 10.8571H4.25V7.91429H6.5V4.94286H8.75V2H11.5C11.775 2 12 2.25714 12 2.57143C12 2.88571 11.775 3.14286 11.5 3.14286H9.75V6.08571H7.5V9.02857H5.25V12Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-stairs-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path d="M1.625 8.1875C1.625 8.01491 1.76491 7.875 1.9375 7.875H4.75V9.4375C4.75 9.61009 4.61009 9.75 4.4375 9.75H1.9375C1.76491 9.75 1.625 9.61009 1.625 9.4375V8.1875Z" />\n			<path d="M3.5 6.3125C3.5 6.13991 3.63991 6 3.8125 6H6.625V7.5625C6.625 7.73509 6.48509 7.875 6.3125 7.875H3.5V6.3125Z" />\n			<path d="M5.375 4.4375C5.375 4.26491 5.51491 4.125 5.6875 4.125H8.5V5.6875C8.5 5.86009 8.36009 6 8.1875 6H5.375V4.4375Z" />\n			<path d="M7.25 2.5625C7.25 2.38991 7.38991 2.25 7.5625 2.25H10.0625C10.2351 2.25 10.375 2.38991 10.375 2.5625V3.8125C10.375 3.98509 10.2351 4.125 10.0625 4.125H7.25V2.5625Z" />\n		</svg>'], ["connection-escalator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3.63008 12H2C0.895431 12 0 12.8954 0 14C0 15.1046 0.89543 16 2 16H4.63008C4.86879 16 5.09962 15.9146 5.28087 15.7593L11.7191 10.2407C11.9004 10.0854 12.1312 10 12.3699 10H14C15.1046 10 16 9.10457 16 8C16 6.89543 15.1046 6 14 6H11.3699C11.1312 6 10.9004 6.08539 10.7191 6.24074L4.28087 11.7593C4.09962 11.9146 3.86879 12 3.63008 12Z" />\n				<path d="M5 6C5 4.89543 5.89543 4 7 4C8.10457 4 9 4.89543 9 6L5 9.5V6Z" />\n				<path d="M9 2C9 3.10457 8.10457 4 7 4C5.89543 4 5 3.10457 5 2C5 0.89543 5.89543 0 7 0C8.10457 0 9 0.89543 9 2Z" />\n			</g>\n		</svg>'], ["connection-escalator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M5.26686 2.98522C5.26686 2.44335 5.71573 2 6.26436 2C6.81299 2 7.26187 2.44335 7.26187 2.98522C7.26187 3.5271 6.81299 3.97045 6.26436 3.97045C5.71573 3.97045 5.26686 3.50246 5.26686 2.98522Z"\n				stroke="none"\n			/>\n			<path\n				d="M7.26188 5.48588V5.25125C7.26188 4.85716 6.91275 4.53696 6.48881 4.53696H6.03993C5.61599 4.53696 5.26687 4.88179 5.26687 5.25125V7.66458L4.3192 8.6995H3.67082C2.74813 8.6995 2 9.43842 2 10.3498C2 11.2611 2.74813 12 3.67082 12H4.61845C5.36658 12 6.11471 11.6798 6.61347 11.1133L9.6808 7.76354H10.3292C11.2519 7.76354 12 7.02463 12 6.11329C12 5.20196 11.2519 4.46305 10.3292 4.46305H9.38155C8.60848 4.46305 7.88529 4.78324 7.38653 5.34975L7.26188 5.48588ZM4.61846 11.0148H3.67083C3.29677 11.0148 2.99751 10.7192 2.99751 10.3498C2.99751 9.9803 3.29677 9.68473 3.67083 9.68473H4.61846C4.71821 9.68473 4.81796 9.63547 4.86784 9.56158L8.13467 5.99015C8.45886 5.64532 8.90774 5.44828 9.38155 5.44828H10.3292C10.7032 5.44828 11.0025 5.74384 11.0025 6.1133C11.0025 6.48276 10.7032 6.77833 10.3292 6.77833H9.38155C9.2818 6.77833 9.18205 6.82759 9.13218 6.87685L5.86534 10.4729C5.54115 10.8177 5.09228 11.0148 4.61846 11.0148Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path d="M3 5.5C3 6.32843 2.32843 7 1.5 7C0.671573 7 0 6.32843 0 5.5C0 4.67157 0.671573 4 1.5 4C2.32843 4 3 4.67157 3 5.5Z" />\n				<path d="M3 10.5C3 11.3284 2.32843 12 1.5 12C0.671573 12 0 11.3284 0 10.5C0 9.67157 0.671573 9 1.5 9C2.32843 9 3 9.67157 3 10.5Z" />\n				<path d="M11 1H14C14.5523 1 15 1.44772 15 2V14C15 14.5523 14.5523 15 14 15H11V1Z" />\n				<path d="M9 1H6C5.44772 1 5 1.44772 5 2V14C5 14.5523 5.44772 15 6 15H9V1Z" />\n			</g>\n		</svg>'], ["connection-elevator-14x14", '<svg viewBox="0 0 14 14">\n			<path\n				d="M7.476 2H2.72693C1.77095 2 1 2.72464 1 3.62319V10.3768C1 11.2754 1.77095 12 2.72693 12H7.476C8.43198 12 9.20293 11.2754 9.20293 10.3768V3.62319C9.17209 2.72464 8.40114 2 7.476 2ZM7.476 3.15942C7.75354 3.15942 7.96941 3.36232 7.96941 3.62319V10.3768C7.96941 10.6377 7.75354 10.8406 7.476 10.8406H5.71824V3.15942H7.476ZM4.48472 3.15942V10.8406H2.72693C2.44939 10.8406 2.23352 10.6377 2.23352 10.3768V3.62319C2.23352 3.36232 2.44939 3.15942 2.72693 3.15942H4.48472Z"\n				stroke="none"\n			/>\n			<path\n				d="M12.4643 6.19064H10.6638C10.4456 6.19064 10.2546 6.06243 10.1728 5.88294C10.0909 5.70346 10.1455 5.47269 10.2819 5.31884L11.1821 4.47269C11.4004 4.26756 11.755 4.26756 11.946 4.47269L12.8462 5.31884C13.0099 5.47269 13.0371 5.67781 12.9553 5.88294C12.8735 6.08807 12.6825 6.19064 12.4643 6.19064Z"\n				stroke="none"\n			/>\n			<path\n				d="M11.564 9.65216C11.4276 9.65216 11.2912 9.60088 11.1821 9.49831L10.2819 8.65216C10.1182 8.49831 10.0909 8.29319 10.1728 8.08806C10.2546 7.90857 10.4456 7.78036 10.6638 7.78036H12.4643C12.6825 7.78036 12.8735 7.90857 12.9553 8.08806C13.0371 8.26754 12.9826 8.49831 12.8462 8.65216L11.9459 9.49831C11.8641 9.60088 11.7004 9.65216 11.564 9.65216Z"\n				stroke="none"\n			/>\n		</svg>'], ["connection-elevator-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<circle cx="1.9375" cy="4.4375" r="0.9375" />\n			<circle cx="1.9375" cy="7.5625" r="0.9375" />\n			<path\n				fillRule="evenodd"\n				clipRule="evenodd"\n				d="M7.6 2H9.4C9.73137 2 10 2.26863 10 2.6V9.41328C10 9.74465 9.73137 10.0133 9.4 10.0133H7.6V2ZM6.4 2H4.6C4.26863 2 4 2.26863 4 2.6V9.41328C4 9.74465 4.26863 10.0133 4.6 10.0133H6.4V2Z"\n			/>\n		</svg>'], ["new-tab-14x14", '<svg viewBox="0 0 14 14">\n			<g stroke="none">\n				<path d="M2.625 2.625H5.6875C5.92913 2.625 6.125 2.42912 6.125 2.1875V1.3125C6.125 1.07088 5.92913 0.875 5.6875 0.875H1.3125C1.07088 0.875 0.875 1.07088 0.875 1.3125V12.6875C0.875 12.9291 1.07088 13.125 1.3125 13.125H12.6875C12.9291 13.125 13.125 12.9291 13.125 12.6875V8.3125C13.125 8.07088 12.9291 7.875 12.6875 7.875H11.8125C11.5709 7.875 11.375 8.07088 11.375 8.3125V11.375H2.625V2.625Z" />\n				<path d="M12.9063 0.875H8.40311C8.20822 0.875 8.11063 1.11062 8.24843 1.24843L9.88124 2.88124L5.8156 6.94688C5.64475 7.11774 5.64475 7.39475 5.8156 7.5656L6.43432 8.18432C6.60517 8.35517 6.88218 8.35517 7.05304 8.18432L11.1187 4.11868L12.7516 5.75157C12.8894 5.88938 13.125 5.79178 13.125 5.59689V1.09375C13.125 0.972938 13.0271 0.875 12.9063 0.875Z" />\n			</g>\n		</svg>'], ["compress-16x16", '<svg viewBox="0 0 16 16">\n			<g stroke="none">\n				<path\n					id="Vector"\n					d="M4.67773 10.7154H0.713449C0.556306 10.7154 0.427734 10.844 0.427734 11.0011V11.8583C0.427734 12.0154 0.556306 12.144 0.713449 12.144H3.82059V15.2868C3.82059 15.444 3.94916 15.5725 4.10631 15.5725H4.96345C5.12059 15.5725 5.24916 15.444 5.24916 15.2868V11.2868C5.24916 10.9708 4.99381 10.7154 4.67773 10.7154ZM4.96345 0.429688H4.10631C3.94916 0.429688 3.82059 0.558259 3.82059 0.715402V3.85826H0.713449C0.556306 3.85826 0.427734 3.98683 0.427734 4.14397V5.00112C0.427734 5.15826 0.556306 5.28683 0.713449 5.28683H4.67773C4.99381 5.28683 5.24916 5.03147 5.24916 4.7154V0.715402C5.24916 0.558259 5.12059 0.429688 4.96345 0.429688ZM15.2849 10.7154H11.3206C11.0045 10.7154 10.7492 10.9708 10.7492 11.2868V15.2868C10.7492 15.444 10.8777 15.5725 11.0349 15.5725H11.892C12.0492 15.5725 12.1777 15.444 12.1777 15.2868V12.144H15.2849C15.442 12.144 15.5706 12.0154 15.5706 11.8583V11.0011C15.5706 10.844 15.442 10.7154 15.2849 10.7154ZM15.2849 3.85826H12.1777V0.715402C12.1777 0.558259 12.0492 0.429688 11.892 0.429688H11.0349C10.8777 0.429688 10.7492 0.558259 10.7492 0.715402V4.7154C10.7492 5.03147 11.0045 5.28683 11.3206 5.28683H15.2849C15.442 5.28683 15.5706 5.15826 15.5706 5.00112V4.14397C15.5706 3.98683 15.442 3.85826 15.2849 3.85826Z"\n				/>\n			</g>\n		</svg>'], ["washroom-14x14", '<svg viewBox="0 0 14 14" stroke="none">\n			<path d="M4.55125 3.09062C4.55125 3.69326 4.07639 4.18176 3.49058 4.18176C2.90525 4.18176 2.43039 3.69326 2.43039 3.09062C2.43039 2.4885 2.90525 2 3.49058 2C4.07639 2 4.55125 2.4885 4.55125 3.09062Z" />\n			<path d="M5.1193 5.48047C4.81653 4.83116 4.17252 4.41571 3.47822 4.41571C2.78392 4.41571 2.13986 4.83116 1.83714 5.48047L1.04175 7.22034C0.940664 7.441 1.02893 7.70073 1.24393 7.81791C1.47077 7.90871 1.72324 7.81791 1.82433 7.59725L2.49349 6.15554L2.21587 11.4407C2.20305 11.7263 2.41805 11.9734 2.69567 11.9993C2.97329 12.0124 3.21344 11.7913 3.23859 11.5057L3.4028 8.285H3.567L3.73121 11.5057C3.74403 11.7913 3.97086 11.9993 4.23616 11.9993H4.26131C4.53893 11.9861 4.75343 11.7395 4.74111 11.4407L4.46349 6.15554L5.13265 7.59725C5.20858 7.75298 5.35997 7.85697 5.52418 7.85697C5.5873 7.85697 5.65042 7.84379 5.71354 7.81792C5.92804 7.71393 6.0163 7.44153 5.91572 7.22035L5.1193 5.48047Z" />\n			<path d="M12.9582 7.22034L12.1505 5.48047C11.8477 4.83116 11.2037 4.41571 10.5094 4.41571C9.81513 4.41571 9.17107 4.83116 8.86836 5.48047L8.06064 7.22034C7.95955 7.441 8.04782 7.70073 8.26282 7.81791C8.47732 7.9219 8.7298 7.8311 8.84371 7.60993L9.52519 6.12977L9.46207 7.2204L8.57842 8.92184C8.47733 9.11663 8.61638 9.36316 8.83089 9.36316H9.33584L9.22242 11.4668C9.2096 11.7397 9.41177 11.9862 9.68939 11.9994C9.95469 12.0126 10.1943 11.8046 10.2072 11.519L10.3581 9.33723H10.6737L10.7871 11.5058C10.7999 11.7787 11.0144 11.9862 11.2792 11.9862H11.3043C11.5696 11.973 11.7841 11.7396 11.7713 11.4535L11.6579 9.33718H12.1628C12.3773 9.33718 12.5287 9.09066 12.4153 8.89586L11.5317 7.19442L11.4685 6.1038L12.1757 7.5972C12.2516 7.75293 12.403 7.85692 12.5672 7.85692C12.6303 7.85692 12.6934 7.84373 12.7566 7.81786C12.9711 7.70068 13.0593 7.44102 12.9582 7.22034Z" />\n			<path d="M11.5696 3.09062C11.5696 3.69326 11.0948 4.18176 10.5094 4.18176C9.92363 4.18176 9.44876 3.69326 9.44876 3.09062C9.44876 2.4885 9.92363 2 10.5094 2C11.0948 2 11.5696 2.4885 11.5696 3.09062Z" />\n			<path d="M6.99996 2.00006C6.76031 2.00006 6.57095 2.19485 6.57095 2.44138V11.5575C6.57095 11.804 6.76031 11.9988 6.99996 11.9988C7.2396 11.9988 7.42896 11.804 7.42896 11.5575V2.44138C7.42896 2.19485 7.2396 2.00006 6.99996 2.00006Z" />\n		</svg>'], ["point-of-interest-12x12", '<svg viewBox="0 0 12 12" stroke="none">\n			<path\n				stroke="none"\n				id="Subtract"\n				fill-rule="evenodd"\n				clip-rule="evenodd"\n				d="M6.24724 10.7516C7.94597 9.0358 9.85962 6.89195 9.85962 4.85965C9.85962 2.72802 8.13159 1 5.99997 1C3.86834 1 2.14032 2.72802 2.14032 4.85965C2.14032 6.89195 4.05397 9.0358 5.7527 10.7516C5.88904 10.8893 6.1109 10.8893 6.24724 10.7516ZM5.99994 6.26317C6.77508 6.26317 7.40345 5.6348 7.40345 4.85967C7.40345 4.08453 6.77508 3.45616 5.99994 3.45616C5.22481 3.45616 4.59644 4.08453 4.59644 4.85967C4.59644 5.6348 5.22481 6.26317 5.99994 6.26317Z"\n			/>\n		</svg>'], ["flag-20x20", '<svg viewBox="0 0 20 20" stroke="none">\n			<path\n				d="M16.9987 4.27111C16.936 5.06715 16.3836 5.93162 15.5238 6.57845C14.7549 7.15682 13.0885 8.04927 10.5434 7.55174C8.32167 7.1164 6.82156 8.02129 6.08085 10.2416L8.24615 17.3998C8.31833 17.6471 8.17711 17.9059 7.9292 17.9813C7.88527 17.9938 7.83976 18 7.79426 18C7.58634 18 7.40277 17.8647 7.34236 17.6673L5.1644 10.4686C5.13773 10.4173 5.12125 10.3613 5.11419 10.3038L3.41956 4.70042C3.38112 4.63512 3.35994 4.56127 3.3568 4.48587L3.02101 3.37886C2.98413 3.25992 2.9959 3.13165 3.05553 3.02203C3.11437 2.91242 3.21479 2.83079 3.33482 2.79504C3.45564 2.75928 3.5851 2.7725 3.69494 2.83235C3.80477 2.89144 3.88637 2.99172 3.92167 3.11143L3.9813 3.31355C4.38847 2.85956 4.90472 2.51439 5.48136 2.30915C6.97201 1.75566 8.95216 1.95467 10.6469 2.83156C11.6888 3.36951 14.3374 4.54493 16.3647 3.79553C16.5154 3.74111 16.684 3.76599 16.8127 3.86239C16.9406 3.95879 17.0105 4.11251 16.9987 4.27111Z"\n				stroke="none"\n			/>\n		</svg>'], ["link-16x16", '<svg viewBox="0 0 16 16" stroke="none">\n			<path\n				d="M9.10678 11.2433C9.07993 11.2167 9.04367 11.2018 9.00589 11.2018C8.9681 11.2018 8.93184 11.2167 8.90499 11.2433L6.82999 13.3183C5.86928 14.279 4.24785 14.3808 3.18714 13.3183C2.12464 12.2558 2.22642 10.6362 3.18714 9.67546L5.26214 7.60046C5.31749 7.5451 5.31749 7.45403 5.26214 7.39868L4.55142 6.68796C4.52457 6.66138 4.48832 6.64646 4.45053 6.64646C4.41274 6.64646 4.37649 6.66138 4.34964 6.68796L2.27464 8.76296C0.763923 10.2737 0.763923 12.7183 2.27464 14.2272C3.78535 15.7362 6.22999 15.738 7.73892 14.2272L9.81392 12.1522C9.86928 12.0969 9.86928 12.0058 9.81392 11.9505L9.10678 11.2433ZM13.7246 2.77903C12.2139 1.26832 9.76928 1.26832 8.26035 2.77903L6.18357 4.85403C6.15698 4.88088 6.14207 4.91714 6.14207 4.95493C6.14207 4.99271 6.15698 5.02897 6.18357 5.05582L6.89249 5.76475C6.94785 5.8201 7.03892 5.8201 7.09428 5.76475L9.16928 3.68975C10.13 2.72903 11.7514 2.62725 12.8121 3.68975C13.8746 4.75225 13.7729 6.37189 12.8121 7.3326L10.7371 9.4076C10.7106 9.43445 10.6956 9.47071 10.6956 9.5085C10.6956 9.54628 10.7106 9.58254 10.7371 9.60939L11.4479 10.3201C11.5032 10.3755 11.5943 10.3755 11.6496 10.3201L13.7246 8.2451C15.2336 6.73439 15.2336 4.28975 13.7246 2.77903ZM9.75142 6.00939C9.72457 5.9828 9.68832 5.96789 9.65053 5.96789C9.61275 5.96789 9.57649 5.9828 9.54964 6.00939L5.50499 10.0522C5.47841 10.0791 5.46349 10.1154 5.46349 10.1531C5.46349 10.1909 5.47841 10.2272 5.50499 10.254L6.21214 10.9612C6.26749 11.0165 6.35857 11.0165 6.41392 10.9612L10.4568 6.91832C10.5121 6.86296 10.5121 6.77189 10.4568 6.71653L9.75142 6.00939Z"\n				stroke="none"\n			/>\n		</svg>']]), aZ = /<svg([^>]*)>/g;
function AD(r5, t, e) {
  let n4 = sZ.get(r5);
  return n4 ? n4.replace(aZ, '<svg$1 xmlns="http://www.w3.org/2000/svg" style="fill:'.concat(t, "; width:").concat(e, "px; height:").concat(e, 'px">')) : "";
}
H$3(AD, "getStyledIcon");
var sf2, Im, Yo, jM, ND, kD, UM, RD, zM = class zM2 {
  constructor(t, e) {
    Q$3(this, Yo);
    Q$3(this, sf2);
    Q$3(this, Im);
    O(this, "colors", { default: "#3D5676", connection: "#128387", washroom: "#3161B4", point: "#AD468F" });
    R$1(this, sf2, t), R$1(this, Im, e);
  }
  auto() {
    let t = [], e = P(this, Im)[Object.keys(P(this, Im))[0]];
    return [...e.getByType("connection"), ...e.getByType("point-of-interest"), ...e.getByType("space")].forEach((n4) => {
      if (n4.__type === "connection") n4.coordinates.forEach((i) => {
        let a4 = n4.name || n4.externalId;
        if (a4) {
          let u5 = P(this, sf2).Labels.add(i, a4, S$1(this, Yo, jM).call(this, n4));
          t.push(u5);
        }
      });
      else {
        n4.__type === "space" && n4.name !== "" && P(this, sf2).updateState(n4, { interactive: true, hoverColor: "#F0F0F0" });
        let i = n4.name;
        if (i) {
          let a4 = P(this, sf2).Labels.add(n4, i, S$1(this, Yo, jM).call(this, n4));
          t.push(a4);
        }
      }
    }), { labels: t };
  }
};
sf2 = /* @__PURE__ */ new WeakMap(), Im = /* @__PURE__ */ new WeakMap(), Yo = /* @__PURE__ */ new WeakSet(), jM = H$3(function(t) {
  let e = AD(S$1(this, Yo, ND).call(this, t), "white", 12);
  return { appearance: { text: { foregroundColor: S$1(this, Yo, UM).call(this, t) }, marker: { foregroundColor: { active: S$1(this, Yo, UM).call(this, t) }, icon: e, iconSize: 12 } }, interactive: true, rank: S$1(this, Yo, RD).call(this, t) };
}, "#generatLabelAppearance"), ND = H$3(function(t) {
  return t.__type === "connection" ? S$1(this, Yo, kD).call(this, t.type) : t.name.includes("Washroom") ? "washroom-14x14" : t.__type === "point-of-interest" ? "point-of-interest-12x12" : "";
}, "#getIconName"), kD = H$3(function(t) {
  let e = "";
  switch (t) {
    case "elevator":
      e = "connection-elevator-12x12";
      break;
    case "escalator":
      e = "connection-escalator-12x12";
      break;
    case "stairs":
      e = "connection-stairs-12x12";
      break;
  }
  return e;
}, "#attemptIconNameForConnection"), UM = H$3(function(t) {
  return t.__type === "connection" ? this.colors.connection : t.__type === "point-of-interest" ? this.colors.point : "name" in t && t.name.includes("Washroom") ? this.colors.washroom : this.colors.default;
}, "#getLabelColor"), RD = H$3(function(t) {
  return t.__type === "connection" ? "high" : (t.__type === "point-of-interest", "medium");
}, "#getDefaultLabelRank"), H$3(zM, "Labels");
var m2 = zM;
var HM = class HM2 {
  constructor(t, e) {
    O(this, "Labels");
    O(this, "auto", H$3(() => this.Labels.auto(), "auto"));
    this.Labels = new m2(t, e);
  }
};
H$3(HM, "DefaultTheme");
var g2 = HM;
a();
var he, N1, Eu, y2, XM, YM = class YM2 {
  constructor(t) {
    Q$3(this, Eu);
    Q$3(this, he);
    Q$3(this, N1);
    O(this, "interactions", { set: H$3((t5) => {
      (t5 == null ? void 0 : t5.pan) != null && (P(this, he).getSystems().cameraSystem.enablePan = t5.pan), (t5 == null ? void 0 : t5.zoom) != null && (P(this, he).getSystems().cameraSystem.enableZoom = t5.zoom), (t5 == null ? void 0 : t5.bearingAndPitch) != null && (P(this, he).getSystems().cameraSystem.enableRotate = t5.bearingAndPitch);
    }, "set"), enable: H$3(() => {
      P(this, he).getSystems().cameraSystem.enablePan = true, P(this, he).getSystems().cameraSystem.enableZoom = true, P(this, he).getSystems().cameraSystem.enableRotate = true;
    }, "enable"), disable: H$3(() => {
      P(this, he).getSystems().cameraSystem.enablePan = false, P(this, he).getSystems().cameraSystem.enableZoom = false, P(this, he).getSystems().cameraSystem.enableRotate = false;
    }, "disable") });
    O(this, "setMinPitch", H$3((t5) => {
      P(this, he).camera.setMinPitch(t5);
    }, "setMinPitch"));
    O(this, "setMaxPitch", H$3((t5) => {
      P(this, he).camera.setMaxPitch(t5);
    }, "setMaxPitch"));
    O(this, "setMinZoomLevel", H$3((t5) => {
      P(this, he).camera.setMinZoomLevel(t5, true);
    }, "setMinZoomLevel"));
    O(this, "setMaxZoomLevel", H$3((t5) => {
      P(this, he).camera.setMaxZoomLevel(t5);
    }, "setMaxZoomLevel"));
    R$1(this, N1, t), R$1(this, he, t.core);
  }
  setScreenOffsets(t) {
    P(this, he).camera.setInsetPadding(t);
  }
  get screenOffsets() {
    return P(this, he).camera.insetsPadding;
  }
  get panMode() {
    return P(this, he).camera.panMode;
  }
  setPanMode(t) {
    if (t !== "default" && t !== "elevation") throw new Error("Invalid pan mode");
    t !== this.panMode && P(this, he).camera.setPanMode(t);
  }
  getFocusOnTransform(t, e) {
    var i, a4, u5;
    let n4 = P(this, he).camera.getCameraFrameForCoordinates(S$1(this, Eu, XM).call(this, t), { pitch: e == null ? void 0 : e.pitch, bearing: e == null ? void 0 : e.bearing, padding: (e == null ? void 0 : e.screenOffsets) || this.screenOffsets, maxZoomLevel: e == null ? void 0 : e.maxZoomLevel, verticalPadding: (i = e == null ? void 0 : e.axisAlignedPadding) == null ? void 0 : i.vertical, minZoomLevel: e == null ? void 0 : e.minZoomLevel, duration: e == null ? void 0 : e.duration, easing: e == null ? void 0 : e.easing });
    return { center: new ve2(n4.center[1], n4.center[0]), zoomLevel: n4.zoomLevel, bearing: (a4 = e == null ? void 0 : e.bearing) != null ? a4 : this.bearing, pitch: (u5 = e == null ? void 0 : e.pitch) != null ? u5 : this.pitch };
  }
  focusOn(t, e) {
    var n4;
    return P(this, he).camera.focusOn(S$1(this, Eu, XM).call(this, t), { pitch: e == null ? void 0 : e.pitch, bearing: e == null ? void 0 : e.bearing, padding: (e == null ? void 0 : e.screenOffsets) || this.screenOffsets, maxZoomLevel: e == null ? void 0 : e.maxZoomLevel, minZoomLevel: e == null ? void 0 : e.minZoomLevel, duration: e == null ? void 0 : e.duration, verticalPadding: (n4 = e == null ? void 0 : e.axisAlignedPadding) == null ? void 0 : n4.vertical, easing: e == null ? void 0 : e.easing });
  }
  animateTo(t, e) {
    var d;
    let { center: n4, zoomLevel: i, bearing: a4, pitch: u5 } = t, h = n4 != null ? n4 : this.center;
    return P(this, he).camera.animateTo({ center: n4 != null ? [h.longitude, h.latitude, P(this, he).camera.elevation] : void 0, zoomLevel: i, bearing: a4, pitch: u5, duration: (d = e == null ? void 0 : e.duration) != null ? d : 600, easing: e == null ? void 0 : e.easing });
  }
  set(t) {
    let { center: e = this.center, zoomLevel: n4 = this.zoomLevel, bearing: i = this.bearing, pitch: a4 = this.pitch } = t, u5 = [e.longitude, e.latitude];
    P(this, he).camera.setCenter(u5), P(this, he).camera.setZoomLevel(n4), P(this, he).camera.setBearing(i), P(this, he).camera.setPitch(a4);
  }
  get center() {
    let t = P(this, he).camera.center;
    return new ve2(t[1], t[0], void 0);
  }
  setAutoMinZoomLevel(t) {
    P(this, he).camera.setAutoMinZoomLevel(t);
  }
  get autoMinZoomLevel() {
    return P(this, he).camera.autoMinZoomLevel;
  }
  get zoomLevel() {
    return P(this, he).camera.zoomLevel;
  }
  get pitch() {
    return P(this, he).camera.pitch;
  }
  get minPitch() {
    return P(this, he).camera.minPitch;
  }
  get maxPitch() {
    return P(this, he).camera.maxPitch;
  }
  get bearing() {
    let t = P(this, he).camera.bearing;
    return (t < 0 ? t + 360 : t) % 360;
  }
  get minZoomLevel() {
    return P(this, he).camera.minZoomLevel;
  }
  get maxZoomLevel() {
    return P(this, he).camera.maxZoomLevel;
  }
  setElevation(t) {
    P(this, he).camera.setElevation(t);
  }
  get elevation() {
    return P(this, he).camera.elevation;
  }
  animateElevation(t, e) {
    return P(this, he).camera.animateElevation(t, e);
  }
  updateFacadesInView() {
    P(this, he).getSystems().geometryInFocusSystem.raycast();
  }
};
he = /* @__PURE__ */ new WeakMap(), N1 = /* @__PURE__ */ new WeakMap(), Eu = /* @__PURE__ */ new WeakSet(), y2 = H$3(function(t) {
  var n4, i, a4, u5, h, d;
  let e = P(this, he).camera.elevation;
  return ve2.is(t) && t.floorId != null ? (i = (n4 = P(this, he).getState(t.floorId)) == null ? void 0 : n4.altitude) != null ? i : e : Io.is(t) ? (u5 = (a4 = P(this, he).getState(t.id)) == null ? void 0 : a4.altitude) != null ? u5 : e : "floor" in t && Io.is(t.floor) && (d = (h = P(this, he).getState(t.floor.id)) == null ? void 0 : h.altitude) != null ? d : e;
}, "#getFloorAltitude"), XM = H$3(function(t) {
  var a4;
  let e = [], i = (Array.isArray(t) ? t : [t]).flatMap((u5) => {
    var h;
    return (h = u5 == null ? void 0 : u5.focusTarget) != null ? h : [u5];
  });
  for (let u5 of i) if (u5 != null) if (ve2.is(u5)) {
    let h = S$1(this, Eu, y2).call(this, u5);
    e.push([u5.longitude, u5.latitude, h]);
  } else if ((u5 == null ? void 0 : u5.id) != null) {
    let h = S$1(this, Eu, y2).call(this, u5);
    if (Io.is(u5) && ((a4 = P(this, N1).getMapDataInternal()) != null && a4.enterpriseMode)) {
      e.push(u5.id);
      continue;
    } else if ("geoJSON" in u5 && u5.geoJSON.geometry.coordinates.length > 0) {
      Z$1(u5.geoJSON, (m5) => {
        e.push([m5[0], m5[1], h]);
      });
      continue;
    }
    let d = P(this, he).getBoundingArea(u5.id);
    if (d) e.push(...d.map((m5) => [m5[0], m5[1], h]));
    else if ("geoJSONBoundingBox" in u5) {
      let m5 = S$1(this, Eu, y2).call(this, u5);
      if (u5.geoJSONBoundingBox != null) {
        let v3 = [[u5.geoJSONBoundingBox[0], u5.geoJSONBoundingBox[1], m5], [u5.geoJSONBoundingBox[2], u5.geoJSONBoundingBox[3], m5]];
        e.push(...v3);
      }
    }
  } else nS(u5) && e.push(u5);
  return e;
}, "#computeCoordinateCloud"), H$3(YM, "Camera");
var A1 = YM;
a();
var Mm, qM = class qM2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, Mm);
    R$1(this, Mm, t);
  }
  get currentMap() {
    return P(this, Mm).call(this);
  }
  async getCurrentSceneGLTF(t) {
    let e = P(this, Mm).call(this);
    return e ? e == null ? void 0 : e.Exporter.getCurrentSceneGLTF(t) : (B.error("There is no map to export. Please load a map first."), new Blob());
  }
};
Mm = /* @__PURE__ */ new WeakMap(), H$3(qM, "Exporter");
var k1 = qM;
a();
var _l, F1, WM = class WM2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, _l, /* @__PURE__ */ new Map());
    Q$3(this, F1);
    R$1(this, F1, t);
  }
  get currentMap() {
    return P(this, F1).call(this);
  }
  getById(t) {
    return P(this, _l).get(t);
  }
  add(t, e, n4) {
    let i = t.anchorTarget, a4 = this.currentMap;
    if (!a4) throw new Error("currentMap should exist");
    let u5 = a4.Labels.add(i, e, G$1(F$1({}, n4), { attachTo: Tm2(t), rank: (n4 == null ? void 0 : n4.rank) == null || (n4 == null ? void 0 : n4.rank) === "initial" ? "medium" : n4.rank })), h = new Vc2(u5.id.toString(), e, t);
    return P(this, _l).set(h.id, { label: h, entityId: h.id }), h;
  }
  all(t) {
    var n4;
    let e = [];
    return (n4 = this.currentMap) == null || n4.Labels.all({ onCreate: H$3((i, a4, u5) => {
      let h = new Vc2(i.toString(), a4, u5);
      P(this, _l).set(h.id, { label: h, entityId: h.id }), e.push(h);
    }, "onCreate"), labelOptions: t }), e;
  }
  remove(t) {
    var n4;
    let e = P(this, _l).get(t.id);
    e && ((n4 = this.currentMap) == null || n4.Labels.remove(e), P(this, _l).delete(t.id.toString()));
  }
  removeAll() {
    let t = [];
    return P(this, _l).forEach(({ label: e }) => {
      this.remove(e), t.push(e), P(this, _l).delete(e.id.toString());
    }), t;
  }
};
_l = /* @__PURE__ */ new WeakMap(), F1 = /* @__PURE__ */ new WeakMap(), H$3(WM, "Labels");
var R1 = WM;
a();
a();
var ZM = { altitude: 0, height: 1, color: "#ffffff", opacity: 1, width: 0.15 }, FD = { opacity: 0.25, color: "#a7d1ec", height: 0.8, width: 0.05, altitude: 0.1, cap: "square", visible: false }, BD = 0.5, KM = class KM2 {
  constructor(t, e, n4 = /* @__PURE__ */ new Map()) {
    O(this, "containerId");
    O(this, "layers");
    O(this, "renderer");
    this.containerId = e, this.layers = n4, this.renderer = t;
  }
  get visible() {
    return this.renderer.getState(this.containerId).visible;
  }
  setVisible(t) {
    this.renderer.setState(this.containerId, { visible: t });
  }
};
H$3(KM, "Layer");
var Ou2 = KM, af2, QM = class QM2 {
  constructor(t, e, n4, i, a4, u5, h, d) {
    O(this, "id");
    O(this, "name");
    O(this, "elevation");
    O(this, "containerId");
    O(this, "externalId");
    O(this, "metadata");
    O(this, "shortName");
    O(this, "subtitle");
    O(this, "occluderId");
    O(this, "loaded", false);
    O(this, "styleMap", {});
    O(this, "obstructions");
    O(this, "entrances");
    O(this, "spaces");
    O(this, "floorImages");
    O(this, "floorText");
    O(this, "renderer");
    O(this, "options");
    O(this, "layers", /* @__PURE__ */ new Map());
    O(this, "footprint");
    O(this, "floorStackId");
    O(this, "multiFloorView");
    O(this, "mapDataInternal");
    O(this, "facadesByStyleId", /* @__PURE__ */ new Map());
    Q$3(this, af2);
    O(this, "load", H$3(() => {
      var i5, a10, u6, h4, d4, m8, v4, x3, S6, I4, w4, E$12, T3, D4, A3, L3;
      if (this.loaded || this.obstructions == null && this.spaces == null) return this;
      this.loaded = true;
      let t5 = this.renderer.addGroupContainer("".concat(iu2, "-").concat(this.id), {}, this.id);
      this.layers.set(iu2, new Ou2(this.renderer, t5.id.toString()));
      let e4 = this.renderer.addGroupContainer("".concat(ol, "-").concat(this.id), {}, this.id);
      this.layers.set(ol, new Ou2(this.renderer, e4.id.toString()));
      let n5 = this.renderer.addGroupContainer("".concat(Gn2, "-").concat(this.id), {}, this.id);
      if (this.layers.set(Gn2, new Ou2(this.renderer, n5.id.toString())), ((i5 = this.footprint) == null ? void 0 : i5.geometry) != null && ((a10 = this.footprint) == null ? void 0 : a10.geometry.coordinates.length) !== 0) {
        let B3 = ZM;
        if (this.obstructions != null && this.obstructions.features.length > 0) {
          let $5 = this.obstructions.features.filter((F3) => {
            var J4;
            return F3.geometry.type === "LineString" && ((J4 = F3.properties.kind) == null ? void 0 : J4.toLowerCase()) === "wall" && F3.properties.footprintComponent === true;
          });
          $5 != null && $5.length > 0 && (B3 = this.styleMap[(u6 = $5[0].properties) == null ? void 0 : u6.id]);
        }
        let j3 = this.renderer.addGeometryGroup("Footprint-".concat(this.id), { features: [{ geometry: this.footprint.geometry, properties: { id: "Footprint-Floor-".concat(this.id) } }] }, G$1(F$1({}, B3), { height: (d4 = (h4 = this.multiFloorView) == null ? void 0 : h4.floorHeight) != null ? d4 : 10, altitude: 0, outline: (v4 = (m8 = this.options.style) == null ? void 0 : m8.outlines) != null ? v4 : true, visible: false, opacity: this.elevation < 0 ? 1 : 0.4, side: this.elevation < 0 ? "back" : "front", color: this.elevation < 0 ? "#F0EEE8" : B3.color, renderOrder: 2 }), this.id);
        this.layers.set(qg, new Ou2(this.renderer, j3.id.toString()));
        let W4 = this.renderer.addGroupContainer("".concat(qp, "-").concat(this.id), {}, this.id);
        this.layers.set(qp, new Ou2(this.renderer, W4.id.toString()));
      }
      if (this.spaces != null && this.spaces.features.length > 0) {
        let B3 = [], j3 = /* @__PURE__ */ new Map();
        this.spaces.features.filter((J4) => {
          var ot2;
          return J4.geometry.type === "Polygon" && ((ot2 = J4.properties.kind) == null ? void 0 : ot2.toLowerCase()) !== "void";
        }).forEach((J4) => {
          var K4;
          let ot2 = (K4 = this.mapDataInternal) == null ? void 0 : K4.facadesBySpaceId[J4.properties.id];
          if (ot2) {
            let H5 = j3.get(ot2.id) || [];
            j3.set(ot2.id, [...H5, J4]);
          } else B3.push(J4);
        });
        let W4 = v2(B3, this.styleMap), $5 = this.renderer.addGroupContainer("spaces-".concat(this.id), {}, n5), F3 = 0;
        for (let [J4, ot2] of W4) {
          let K4 = this.renderer.addGeometryGroup("Spaces-".concat(this.id, "-").concat(F3), { features: ot2 }, wm(J4, this.options), $5);
          F3++;
          let H5 = $5.id.toString();
          this.layers.get(Gn2).layers.set(J4.id || H5, K4.id.toString());
        }
        if (j3.size > 0) {
          let J4 = this.renderer.addGroupContainer("".concat(Wp, "-").concat(this.id), {}, this.id);
          this.layers.set(Wp, new Ou2(this.renderer, J4.id.toString()));
          for (let [ot2, K4] of j3) {
            let H5 = this.renderer.addGroupContainer(ot2, { focusable: true }, J4), _t2 = this.renderer.addGroupContainer("".concat(ot2, "-geometry"), {}, H5), ct2 = v2(K4, this.styleMap), ft2 = 0;
            for (let [mt2, St2] of ct2) {
              let dt2 = this.renderer.addGeometryGroup("Facades-".concat(this.id, "-").concat(ot2, "-").concat(ft2), { features: St2 }, G$1(F$1({}, wm(mt2, this.options)), { renderOrder: 3 }), _t2);
              ft2++;
              let xt2 = mt2.id || dt2.id.toString();
              this.layers.get(Wp).layers.set("".concat(ot2, "-").concat(xt2), dt2.id.toString()), this.facadesByStyleId.has(xt2) ? (x3 = this.facadesByStyleId.get(xt2)) == null || x3.push(ot2) : this.facadesByStyleId.set(xt2, [ot2]);
            }
          }
        }
      }
      if (this.obstructions != null && this.obstructions.features.length > 0) {
        let B3 = this.obstructions.features.filter((_t2) => _t2.geometry.type === "Polygon" && (_t2.properties.kind === "object" || _t2.properties.kind === "unknown")), j3 = v2(B3, this.styleMap), W4 = this.renderer.addGroupContainer("objects-".concat(this.id), {}, n5), $5 = 0;
        for (let [_t2, ct2] of j3) {
          let ft2 = this.renderer.addGeometryGroup("Objects-".concat(this.id, "-").concat($5), { features: ct2 }, wm(_t2, this.options), W4);
          $5++;
          let mt2 = W4.id.toString();
          this.layers.get(Gn2).layers.set(_t2.id || mt2, ft2.id.toString());
        }
        let F3 = this.obstructions.features.filter((_t2) => {
          var ct2;
          return _t2.geometry.type === "LineString" && ((ct2 = _t2.properties.kind) == null ? void 0 : ct2.toLowerCase()) === "wall" && _t2.properties.footprintComponent === false;
        }), J4 = this.obstructions.features.filter((_t2) => {
          var ct2;
          return _t2.geometry.type === "LineString" && ((ct2 = _t2.properties.kind) == null ? void 0 : ct2.toLowerCase()) === "wall" && _t2.properties.footprintComponent === true;
        }), ot2 = this.entrances, K4 = ZM, H5 = ZM;
        if (F3 != null && F3.length > 0) {
          let _t2 = this.styleMap[(S6 = F3[0].properties) == null ? void 0 : S6.id];
          _t2 != null && (K4 = F$1({}, _t2)), H5 = K4;
          let { walls: ct2, entrances: ft2 } = $M(F3, (ot2 == null ? void 0 : ot2.features) || []), mt2 = Math.max(K4.height - 0.11, BD), St2 = G$1(F$1({}, FD), { height: mt2 }), dt2 = this.renderer.addGeometryGroup("InteriorDoors-".concat(this.id), ft2, St2, n5);
          this.layers.get(Gn2).layers.set(Sd2, dt2.id.toString());
          let xt2 = this.renderer.addGeometryGroup("Walls-".concat(this.id), { features: [ct2] }, wm(K4, this.options), n5);
          this.layers.get(Gn2).layers.set(yc, xt2.id.toString());
        }
        if (J4 != null && J4.length > 0) {
          let _t2 = this.styleMap[(I4 = J4[0].properties) == null ? void 0 : I4.id];
          _t2 != null && (H5 = G$1(F$1({}, _t2), { id: il2 }));
          let { walls: ct2, entrances: ft2 } = $M(J4, (ot2 == null ? void 0 : ot2.features) || []), mt2 = Math.max(H5.height - 0.11, BD), St2 = G$1(F$1({}, FD), { height: mt2 }), dt2 = this.renderer.addGeometryGroup("ExteriorDoors-".concat(this.id), ft2, St2, n5);
          this.layers.get(Gn2).layers.set(Id2, dt2.id.toString());
          let xt2 = this.renderer.addGeometryGroup("ExteriorWalls-".concat(this.id), { features: [ct2] }, wm(H5, this.options), n5);
          this.layers.get(Gn2).layers.set(il2, xt2.id.toString());
        }
      }
      if (this.floorImages != null) {
        let B3 = this.renderer.addGroupContainer("images-".concat(this.id), {}, this.id);
        for (let j3 of this.floorImages.features || []) "anchorId" in j3.properties || "anchorId" in j3.properties && ((w4 = j3.properties) == null ? void 0 : w4.anchorId) == null || this.renderer.addImage(E(), j3, { url: j3.properties.path, flipImageToFaceCamera: (E$12 = this.options.flipImagesToFaceCamera) != null ? E$12 : true }, B3);
        this.layers.set(sl, new Ou2(this.renderer, B3.id.toString()));
      }
      if (this.floorText != null) for (let B3 of this.floorText.features || []) {
        let j3 = 0;
        "geometryId" in B3.properties ? j3 = (D4 = (T3 = this.renderer.getState(B3.properties.geometryId)) == null ? void 0 : T3.height) != null ? D4 : 0 : j3 = (A3 = B3.properties.verticalOffset) != null ? A3 : 0, this.renderer.addText3D(E(), G$1(F$1({}, B3), { properties: G$1(F$1({}, B3.properties), { verticalOffset: j3 }) }), {}, this.id);
      }
      return (L3 = this.multiFloorView) != null && L3.enabled && this.renderer.setState(this.id, { altitude: this.elevation * this.multiFloorView.floorHeight }), this.renderer.render(), this;
    }, "load"));
    var v3, x2, S4, I3, w3;
    this.id = e.id, this.options = a4;
    let m5 = n4.addGroupContainer(this.id, { visible: false, interactive: true, preloadGeometry: (v3 = a4.preloadFloors) == null ? void 0 : v3.map((E4) => E4.id).includes(e.id) }, t);
    this.containerId = m5.id.toString(), this.externalId = e.externalId, this.metadata = e.metadata, this.shortName = e.shortName, this.subtitle = e.subtitle, this.name = e.name, this.elevation = e.elevation, u5 != null && h != null && (this.styleMap = h, this.spaces = u5.space[this.id], this.entrances = u5.entrance[this.id], this.obstructions = u5.obstruction[this.id], this.floorImages = (x2 = u5.floorImages) == null ? void 0 : x2[this.id], this.floorText = (I3 = (S4 = u5.enterprise) == null ? void 0 : S4.floorText) == null ? void 0 : I3[this.id], this.footprint = (w3 = u5["floor.geojson"]) == null ? void 0 : w3.features.find((E4) => E4.properties.id === e.id)), this.renderer = n4, this.floorStackId = t, this.multiFloorView = i, this.mapDataInternal = d;
  }
  get geoJSONBoundingBox() {
    if (P(this, af2)) return P(this, af2);
    if (!this.footprint) {
      B.warn("Attempting to get bounding box with no footprint for floor ".concat(this.id));
      return;
    }
    return R$1(this, af2, b2(this.footprint)), P(this, af2);
  }
  addOccluder() {
    let t = this.layers.get(qp);
    if (t == null || t.containerId == null || this.footprint == null) {
      B.warn("Tried to add occluder to floor ".concat(this.id, " but the floor does not have an occlusion layer."));
      return;
    }
    this.occluderId = this.renderer.addOccluder(this.footprint, t.containerId);
  }
  get hasFacadeGeometry() {
    return this.facadesByStyleId.size > 0;
  }
  get visible() {
    return this.renderer.getState(this.containerId).visible;
  }
  setVisible(t) {
    this.renderer.setState(this.containerId, { visible: t });
  }
};
af2 = /* @__PURE__ */ new WeakMap(), H$3(QM, "FloorObject");
var B1 = QM;
a();
var tT = 50, eT = false, lZ = 1e3, fn, Pm2, Cl, Ca, Di, V1, Yc2, Em, qc2, Wi, nT, lf2, j1, U1, z1, H1, Du, UD, X1, Wc2, iT, oT, zD, HD, uf2, sT = class sT2 extends Se$1 {
  constructor({ currentMapGetter: e }) {
    super();
    Q$3(this, Wi);
    Q$3(this, fn);
    Q$3(this, Pm2, 0);
    Q$3(this, Cl);
    Q$3(this, Ca, false);
    Q$3(this, Di, []);
    Q$3(this, V1, 0);
    Q$3(this, Yc2, tT);
    Q$3(this, Em, false);
    Q$3(this, qc2, "collapsed");
    O(this, "expandedFactor", 0);
    Q$3(this, lf2, "all-floors");
    Q$3(this, j1, H$3(() => {
      let e4 = P(this, fn).call(this);
      if (P(this, V1) === this.expandedFactor || e4 == null || !P(this, Ca)) return;
      R$1(this, V1, this.expandedFactor);
      let n5 = nn(this.expandedFactor, 0, 1, 0, this.distanceBetweenFloors), a4 = nn(this.expandedFactor, 0, 0.1, 0, 1) === 0;
      P(this, Di).forEach((u5, h) => {
        e4.api.updateState(u5.containerId, { visible: a4 ? u5.id === e4.currentFloorId : true, altitude: n5 * h });
      }), this.expandedFactor === 0 ? (R$1(this, Ca, false), e4.renderer.camera.setPanMode("default"), P(this, Wc2) && P(this, Wc2).call(this)) : this.expandedFactor === 1 && (R$1(this, Ca, false), P(this, Wc2) && P(this, Wc2).call(this));
    }, "#handlePreRender"));
    Q$3(this, U1, H$3(() => {
      var e4, n5, i;
      this.expanded && R$1(this, Pm2, (n5 = (e4 = P(this, fn).call(this)) == null ? void 0 : e4.renderer.camera.elevation) != null ? n5 : 0), (i = P(this, fn).call(this)) == null || i.renderer.on("user-interaction-end", P(this, H1));
    }, "#handleUserInteractionStart"));
    Q$3(this, z1, H$3(() => {
      var n5;
      let e4 = P(this, fn).call(this);
      if (e4 != null && this.expanded && P(this, Em) && !P(this, Ca)) {
        let i = e4.currentFloorId, a4 = [1 / 0, e4.currentFloorId];
        for (let u5 = 0; u5 < P(this, Di).length; u5++) {
          let h = P(this, Di)[u5], d = Math.abs(((n5 = e4.renderer.camera.elevation) != null ? n5 : 0) - u5 * this.distanceBetweenFloors);
          d < this.distanceBetweenFloors / 3 && (a4[0] = d, a4[1] = h.id);
        }
        a4[1] !== e4.currentFloorId && (e4.currentFloorId = a4[1], P(this, Di).forEach((u5) => {
          e4.api.updateState(u5.containerId, { visible: P(this, lf2) === "all-floors" ? true : e4.currentFloor.id === u5.id });
        }), e4.publish("floor-change", { reason: "stacked-maps-elevation-change", floorId: e4.currentFloorId, previousFloorId: i }));
      }
    }, "#determineCurrentMapBasedOnElevation"));
    Q$3(this, H1, H$3(() => {
      var n5, i;
      let e4 = P(this, fn).call(this);
      if (this.expanded && e4 && P(this, Pm2) !== ((n5 = e4.renderer.camera.elevation) != null ? n5 : 0)) {
        let a4 = [1 / 0, e4.currentFloorId, 0];
        for (let u5 = 0; u5 < P(this, Di).length; u5++) {
          let h = P(this, Di)[u5], d = Math.abs(((i = e4.renderer.camera.elevation) != null ? i : 0) - u5 * this.distanceBetweenFloors);
          d < a4[0] && (a4[0] = d, a4[1] = h.id, a4[2] = u5 * this.distanceBetweenFloors);
        }
        P(this, Em) && S$1(this, Wi, UD).call(this, a4[2]), R$1(this, Pm2, 0), e4.renderer.off("user-interaction-end", P(this, H1));
      }
    }, "#handleUserInteractionEnd"));
    Q$3(this, Du, null);
    Q$3(this, X1, null);
    Q$3(this, Wc2);
    Q$3(this, uf2);
    R$1(this, fn, e);
    let n4 = P(this, fn).call(this);
    n4 != null && n4.id !== "outdoors" && (n4.renderer.on("user-interaction-start", P(this, U1)), n4.renderer.on("camera-change", P(this, z1)), n4.renderer.on("pre-render", P(this, j1)));
  }
  get state() {
    return P(this, qc2);
  }
  get expanded() {
    return P(this, qc2) !== "collapsed";
  }
  get distanceBetweenFloors() {
    if (P(this, Yc2) === "auto") {
      if (P(this, uf2) != null) return P(this, uf2);
      let e = S$1(this, Wi, HD).call(this);
      if (e) return R$1(this, uf2, e), e;
    }
    return typeof P(this, Yc2) == "number" ? P(this, Yc2) : tT;
  }
  clearCachedFloorSeparationDistance() {
    R$1(this, uf2, void 0);
  }
  get includedFloors() {
    var e;
    return (e = P(this, Wi, nT)) != null && e.api.mapData ? P(this, Di).map((n4) => {
      var i, a4;
      return (a4 = (i = P(this, Wi, nT)) == null ? void 0 : i.api.mapData) == null ? void 0 : a4.getById("floor", n4.id);
    }).filter(Boolean) : [];
  }
  get floorVisibilityMode() {
    return P(this, lf2);
  }
  setFloorVisiblityMode(e) {
    R$1(this, lf2, e);
    let n4 = P(this, fn).call(this);
    n4 != null && P(this, Di).forEach((i) => {
      n4.api.updateState(i.containerId, { visible: P(this, lf2) === "all-floors" ? true : n4.currentFloor.id === i.id });
    });
  }
  changeFloorOnElevationChanges(e) {
    R$1(this, Em, e);
  }
  async expand(e) {
    var i, a4, u5;
    let n4 = P(this, fn).call(this);
    if (n4 != null) return (e == null ? void 0 : e.distanceBetweenFloors) === "auto" ? R$1(this, Yc2, "auto") : R$1(this, Yc2, (i = e == null ? void 0 : e.distanceBetweenFloors) != null ? i : tT), R$1(this, Di, (e == null ? void 0 : e.includedFloors) != null && (e == null ? void 0 : e.includedFloors.length) > 0 ? e == null ? void 0 : e.includedFloors.map((h) => n4.floorsById.get(h.id)).filter(Boolean) : n4.currentFloorStack.floorObjects), P(this, Di).sort((h, d) => h.elevation - d.elevation), P(this, Di).length <= 1 || this.expanded === true ? Promise.resolve() : (R$1(this, Ca, true), n4.api.Camera.setPanMode((a4 = e == null ? void 0 : e.cameraPanMode) != null ? a4 : "elevation"), this.changeFloorOnElevationChanges((u5 = e == null ? void 0 : e.changeFloorOnElevationChanges) != null ? u5 : true), S$1(this, Wi, iT).call(this, "expand", e).then(() => {
      R$1(this, qc2, "expanded"), S$1(this, Wi, oT).call(this), this.publish("stacked-maps-state-change", { state: "expanded" });
    }).finally(() => {
      R$1(this, Ca, false);
    }));
  }
  async collapse(e) {
    let n4 = P(this, fn).call(this);
    if (n4 != null) return this.expanded === true ? (R$1(this, Ca, true), n4.api.Camera.setPanMode("default"), this.changeFloorOnElevationChanges(false), S$1(this, Wi, iT).call(this, "collapse", e).then(() => {
      R$1(this, qc2, "collapsed"), S$1(this, Wi, oT).call(this), this.publish("stacked-maps-state-change", { state: "collapsed" });
    }).finally(() => {
      R$1(this, Ca, false);
    })) : Promise.resolve();
  }
  destroy() {
    let e = P(this, fn).call(this);
    e != null && (e.renderer.off("user-interaction-start", P(this, U1)), e.renderer.off("camera-change", P(this, z1)), e.renderer.off("pre-render", P(this, j1)));
  }
};
fn = /* @__PURE__ */ new WeakMap(), Pm2 = /* @__PURE__ */ new WeakMap(), Cl = /* @__PURE__ */ new WeakMap(), Ca = /* @__PURE__ */ new WeakMap(), Di = /* @__PURE__ */ new WeakMap(), V1 = /* @__PURE__ */ new WeakMap(), Yc2 = /* @__PURE__ */ new WeakMap(), Em = /* @__PURE__ */ new WeakMap(), qc2 = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakSet(), nT = H$3(function() {
  return P(this, fn).call(this);
}, "#currentMap"), lf2 = /* @__PURE__ */ new WeakMap(), j1 = /* @__PURE__ */ new WeakMap(), U1 = /* @__PURE__ */ new WeakMap(), z1 = /* @__PURE__ */ new WeakMap(), H1 = /* @__PURE__ */ new WeakMap(), Du = /* @__PURE__ */ new WeakMap(), UD = H$3(function(e) {
  var i, a4, u5;
  P(this, Du) && P(this, Du).stop();
  let n4 = P(this, fn).call(this);
  n4 != null && (R$1(this, Du, new Ho({ elevation: (i = n4.renderer.camera.elevation) != null ? i : 0 }).to({ elevation: e }, 150).easing(Vn.Quadratic.Out).onComplete(() => {
    var h;
    P(this, Du) && ((h = P(this, fn).call(this)) == null || h.renderer.getInternalTweenGroup().remove(P(this, Du)));
  }).onUpdate(({ elevation: h }) => {
    n4.renderer.camera.setElevation(h);
  }).start()), (a4 = P(this, fn).call(this)) == null || a4.renderer.getInternalTweenGroup().add(P(this, Du)), (u5 = P(this, fn).call(this)) == null || u5.renderer.render());
}, "#animateElevationTo"), X1 = /* @__PURE__ */ new WeakMap(), Wc2 = /* @__PURE__ */ new WeakMap(), iT = H$3(function(e, n4) {
  var h, d, m5, v3;
  P(this, Cl) && P(this, Cl).stop();
  let i = P(this, fn).call(this);
  if (i == null) return Promise.reject(new Error("No current map"));
  let a4 = P(this, Di).indexOf(i.currentFloor), u5 = (h = i.renderer.camera.elevation) != null ? h : 0;
  return R$1(this, X1, new Promise((x2) => {
    R$1(this, Wc2, x2);
  })), R$1(this, Cl, new Ho({ percentExpanded: this.expandedFactor }).to({ percentExpanded: e === "expand" ? 1 : 0 }, (d = n4 == null ? void 0 : n4.duration) != null ? d : lZ).easing(xu2[(n4 == null ? void 0 : n4.easing) || "ease-in-out"]).onUpdate(({ percentExpanded: x2 }) => {
    this.expandedFactor = x2;
    let S4 = a4 * this.distanceBetweenFloors;
    i.renderer.camera.setElevation(e === "expand" ? S4 * x2 : u5 * x2);
  }).onComplete(() => {
    var x2;
    P(this, Cl) && ((x2 = P(this, fn).call(this)) == null || x2.renderer.getInternalTweenGroup().remove(P(this, Cl)));
  }).start()), P(this, Cl).cameraAnimation = true, (m5 = P(this, fn).call(this)) == null || m5.renderer.getInternalTweenGroup().add(P(this, Cl)), (v3 = P(this, fn).call(this)) == null || v3.renderer.render(), P(this, X1);
}, "#animate"), oT = H$3(function() {
  var n4, i;
  let e = P(this, fn).call(this);
  if (e != null && e.options.hideImagesNotOnCurrentFloor) for (let a4 of P(this, Di)) {
    let u5 = e.floorsById.get(a4.id);
    u5 && (P(this, qc2) === "expanded" ? (n4 = u5.layers.get(sl)) == null || n4.setVisible(true) : (i = u5.layers.get(sl)) == null || i.setVisible(u5.id === e.currentFloor.id));
  }
}, "#showOrHideImagesOnAllFloorsInStack"), zD = H$3(function(e, n4, i, a4) {
  let u5 = rT(e, i), h = n4.clone(), d = rT(h, i);
  if (!Pt$1(u5) || !Pt$1(d)) return -1;
  let m5 = 0, v3;
  do {
    if (m5 > 1e4) return -1;
    if (m5 += 20, h.position.z = m5, h.updateMatrixWorld(), d.makeEmpty(), rT(h, i, d), v3 = u5.intersectsBox(d), eT) ;
  } while (v3);
  return m5;
}, "#computeMinZOffsetToSeparateFirstTwoFloors"), HD = H$3(function() {
  let e = P(this, fn).call(this);
  if (!e) return;
  let n4 = e.renderer, i = n4.getThreeScene();
  if (!e.api.mapData || !i) return;
  let u5 = P(this, Di).length > 0 ? P(this, Di) : e.currentFloorStack.floorObjects;
  if (u5.length < 2) return;
  let h = n4.getInternalState().geometry3DMap.get(u5[0].id), d = n4.getInternalState().geometry3DMap.get(u5[1].id);
  if (!h || !d) return;
  if (_r(h, "group-container"), _r(d, "group-container"), eT) ;
  let m5 = S$1(this, Wi, zD).call(this, h, d, n4.getThreeCamera(), n4.container);
  if (m5 !== -1) return m5;
}, "#computeZOffsetSeparatesFirstTwoFloorsInClipSpace"), uf2 = /* @__PURE__ */ new WeakMap(), H$3(sT, "StackedMaps");
var G1 = sT, Xc2 = new I$1(), GD = new ot$1();
function rT(r5, t, e = new Jl$2()) {
  return r5.traverse((n4) => {
    if (n4 instanceof ye$1) {
      let a4 = n4.geometry.attributes.position;
      if (t.position.distanceTo(n4.position) < t.near) return;
      for (let h = 0; h < a4.count; h++) Xc2.fromBufferAttribute(a4, h), Xc2.applyMatrix4(n4.matrixWorld), Xc2.applyMatrix4(t.matrixWorldInverse), Xc2.applyMatrix4(t.projectionMatrix), Xc2.z < 1 && Xc2.z > 0 && (GD.set(Xc2.x, Xc2.y), e.expandByPoint(GD));
    }
  }), e;
}
H$3(rT, "projectToBox2D");
function VD(r5, t) {
  let e = t.clientWidth, n4 = t.clientHeight;
  return new ot$1((r5.x + 1) * e / 2, (1 - r5.y) * n4 / 2);
}
H$3(VD, "ndcToScreen");
function jD(r5, t, e) {
  let n4 = document.createElement("div");
  n4.style.position = "absolute", n4.style.border = "2px solid ".concat(t), n4.style.pointerEvents = "none";
  let i = VD(new ot$1(r5.min.x, r5.min.y), e), a4 = VD(new ot$1(r5.max.x, r5.max.y), e);
  n4.style.left = "".concat(i.x, "px"), n4.style.top = "".concat(a4.y, "px");
  let u5 = Math.abs(a4.x - i.x), h = Math.abs(a4.y - i.y);
  return n4.style.width = "".concat(u5, "px"), n4.style.height = "".concat(h, "px"), e.appendChild(n4), n4;
}
H$3(jD, "drawProjectedBox");
a();
var Om2, aT = class aT2 {
  constructor(t, e, n4, i) {
    O(this, "id");
    O(this, "externalId");
    O(this, "name");
    O(this, "type");
    O(this, "floorIds");
    O(this, "defaultFloorId");
    O(this, "floorObjects", []);
    O(this, "floorObjectsByElevation", /* @__PURE__ */ new Map());
    O(this, "metadata");
    O(this, "containerId");
    O(this, "facade");
    O(this, "renderer");
    Q$3(this, Om2);
    var u5;
    this.id = t.id, this.externalId = t.externalId, this.name = t.name, this.type = t.type, this.metadata = t.metadata, this.floorIds = (u5 = t.floors) != null ? u5 : t.maps, this.defaultFloorId = t.defaultFloor, this.renderer = n4;
    let a4 = n4.addGroupContainer(this.id, { visible: true, interactive: true }, e);
    this.containerId = a4.id.toString(), this.facade = i;
  }
  get defaultFloor() {
    if (P(this, Om2) == null) {
      if (this.floorObjects.length === 0) throw new Y("No floors in floor stack (".concat(this.id, "). Could not get default floor."));
      let t;
      this.defaultFloorId && (t = this.floorObjects.find((e) => e.id === this.defaultFloorId)), t || (t = this.floorObjects.reduce((e, n4) => Math.abs(n4.elevation) < Math.abs(e.elevation) ? n4 : e)), R$1(this, Om2, t);
    }
    return P(this, Om2);
  }
  get isOutdoors() {
    var e;
    return ((e = this.type) == null ? void 0 : e.toLowerCase()) === "outdoor" ? true : this.facade != null ? false : this.floorObjects.some((n4) => n4.hasFacadeGeometry);
  }
  addFloor(t) {
    if (this.floorObjectsByElevation.has(t.elevation)) {
      B.error("Floor with same elevation ".concat(t.elevation, " already exists in Stack (").concat(this.id, "). Floor (").concat(t.id, ") will not be added."));
      return;
    }
    t.load(), this.floorObjects.push(t), this.floorObjectsByElevation.set(t.elevation, t), this.facade && this.renderer.setState(t.containerId, { focusable: true }), !this.isOutdoors && !t.hasFacadeGeometry && t.footprint != null && t.addOccluder();
  }
};
Om2 = /* @__PURE__ */ new WeakMap(), H$3(aT, "FloorStackObject");
var Y1 = aT;
a();
function XD(r5, t, e, n4) {
  let i = { outdoorOpacity: 1, floorStates: [] }, a4 = r5.sort((v3, x2) => v3.elevation - x2.elevation), u5 = Math.min(0, a4[0].elevation), h = a4[a4.length - 1].elevation, d, m5;
  for (let v3 = u5; v3 <= h; v3++) {
    let x2 = a4.find((T3) => T3.elevation === v3);
    if (x2 == null) {
      v3 >= 0 && (d == null ? d = v3 : m5 = v3);
      continue;
    }
    let S4 = 0, I3 = v3 < 0 ? Math.abs(x2.elevation) * e : e, w3 = false;
    if (d === 0 && m5 != null) {
      let T3 = e * m5;
      S4 = -T3, I3 = T3, w3 = true;
    } else if (d != null && m5 != null) {
      let T3 = d, D4 = r5.find((L3) => L3.elevation === T3 - 1), A3 = i.floorStates.find((L3) => L3.floor === D4);
      if (A3) {
        let L3 = e * (m5 - d + 2);
        A3.state.footprint = G$1(F$1({}, A3.state.footprint), { altitude: 0, height: L3, visible: true });
      }
    }
    d = void 0, m5 = void 0;
    let E4 = { floor: x2, state: { type: "floor", visible: false, geometry: { visible: false }, labels: { enabled: false }, markers: { enabled: false }, footprint: { visible: false }, occlusion: { enabled: false } } };
    i.floorStates.push(E4), x2.id === t.id ? (E4.state.visible = true, E4.state.geometry.visible = true, E4.state.labels.enabled = true, E4.state.markers.enabled = true, E4.state.occlusion.enabled = true, (x2.elevation < 0 || w3) && (x2.elevation < 0 && (i.outdoorOpacity = 0.2), E4.state.footprint.height = I3, E4.state.footprint.altitude = S4, E4.state.footprint.visible = true)) : n4.includes(x2.id) && x2.elevation < t.elevation ? (E4.state.visible = true, E4.state.geometry.visible = true, E4.state.markers.enabled = true, E4.state.occlusion.enabled = true, E4.state.footprint.visible = true, x2.elevation < 0 ? (E4.state.footprint.height = I3, E4.state.footprint.altitude = S4, i.outdoorOpacity = 0.2) : (E4.state.footprint.height = I3, E4.state.footprint.altitude = S4)) : t.elevation > 0 && x2.elevation < t.elevation && x2.elevation >= 0 && (E4.state.visible = true, E4.state.footprint.visible = true, E4.state.footprint.height = e, E4.state.footprint.altitude = S4);
  }
  return i;
}
H$3(XD, "getMultiFloorState");
var uZ = { linear: Vn.Linear.None, easeIn: Vn.Quadratic.In, easeOut: Vn.Quadratic.Out, easeInOut: Vn.Quadratic.InOut }, Sl, cT = class cT2 extends Se$1 {
  constructor(e, n4, i, a4) {
    var m5, v3, x2, S4;
    super();
    O(this, "floorStacksById", /* @__PURE__ */ new Map());
    O(this, "floorsById", /* @__PURE__ */ new Map());
    O(this, "startingFloorId", "");
    O(this, "currentFloorId", "");
    O(this, "currentFloorStackId", "");
    O(this, "outdoorFloorStacks", /* @__PURE__ */ new Set());
    O(this, "id");
    O(this, "renderer");
    O(this, "api");
    O(this, "mvf");
    O(this, "options", {});
    O(this, "styleMap");
    O(this, "StackedMaps");
    O(this, "animations", /* @__PURE__ */ new Map());
    O(this, "Models", { add: H$3((e4, n5, i5) => {
      let x3 = i5, { floorId: a10, scale: u6 } = x3, h4 = J$1(x3, ["floorId", "scale"]), d4 = a10 ? this.floorsById.get(a10) : this.currentFloor, m8 = F$1({}, h4);
      u6 != null && (m8.scale = Array.isArray(i5.scale) ? i5.scale : [i5.scale, i5.scale, i5.scale]);
      let v4 = this.renderer.addModelGroup(e4, { type: "FeatureCollection", features: n5.map((S6) => {
        var I3;
        return { type: "Feature", properties: { id: E(), rotation: i5.rotation, scale: m8.scale, interactive: i5.interactive, verticalOffset: S6.verticalOffset + ((I3 = i5.verticalOffset) != null ? I3 : 0) }, geometry: { type: "Point", coordinates: js2(S6) } };
      }) }, m8, { parent: d4.id });
      if (v4 == null) throw new Y("error creating model");
      return this.renderer.getState(v4).children;
    }, "add"), remove: H$3((e4, n5) => {
      this.renderer.remove(e4), this.renderer.getState(n5).children.length === 0 && this.renderer.remove(n5);
    }, "remove") });
    O(this, "Images", { add: H$3((e4, n5, i5) => {
      let v4 = i5, { floorId: a10, flipImageToFaceCamera: u6 } = v4, h4 = J$1(v4, ["floorId", "flipImageToFaceCamera"]), d4 = a10 ? this.floorsById.get(a10) : this.currentFloor, m8 = { type: "Feature", properties: h4, geometry: { type: "Point", coordinates: e4 } };
      return this.renderer.addImage(E(), m8, { url: n5, flipImageToFaceCamera: u6 != null ? u6 : false }, d4.id);
    }, "add"), remove: H$3((e4) => {
      this.renderer.remove(e4);
    }, "remove"), removeAll: H$3(() => {
    }, "removeAll") });
    O(this, "Markers", { add: H$3((e4, n5, i5) => {
      let a10 = uT(e4, this.floorsById, this.api.mapObjects[0].floorsById.get("default-floor")), x3 = i5, { attachTo: u6 } = x3, h4 = J$1(x3, ["attachTo"]), d4 = h4;
      h4.rank === "initial" && (d4.rank = "medium");
      let m8 = a10.layers.get(ol), v4 = this.renderer.addMarker2D(js2(e4), n5, G$1(F$1({}, d4), { occluderId: a10 == null ? void 0 : a10.occluderId, attachTo: u6 }), m8 == null ? void 0 : m8.containerId);
      if (!v4) throw new Y("Failed to create Marker");
      return v4;
    }, "add"), remove: H$3((e4) => {
      this.renderer.remove(e4);
    }, "remove"), getContentEl: H$3((e4) => {
      let n5 = this.renderer.getState(e4);
      if ((n5 == null ? void 0 : n5.type) === "marker") return n5.element;
    }, "getContentEl"), removeAll: H$3(() => {
    }, "removeAll"), setPosition: H$3((e4, n5, i5) => {
      var h4;
      let a10 = this.renderer.getState(e4), u6 = i5 ? this.floorsById.get(i5) : this.currentFloor;
      if (!a10) {
        B.error('Failed to retrieve state for Marker with id "'.concat(e4, '".'));
        return;
      }
      if (a10.type !== "marker") {
        B.error('Geometry with id "'.concat(e4, '" is not of type "marker".'));
        return;
      }
      this.renderer.setState(a10, { position: n5, parent: (h4 = u6 == null ? void 0 : u6.layers.get(ol)) == null ? void 0 : h4.containerId });
    }, "setPosition"), animateTo: H$3((e4, n5, i5, a10) => {
      let u6 = this.renderer.getState(e4), h4 = i5 ? this.floorsById.get(i5) : this.currentFloor;
      if (!u6) return B.error('Failed to retrieve state for Marker with id "'.concat(e4, '".')), Promise.resolve();
      if (u6.type !== "marker") return B.error('Geometry with id "'.concat(e4, '" is not of type "marker".')), Promise.resolve();
      let d4 = F$1({ duration: 1e3, easing: "ease-in-out" }, a10);
      this.cancelAnimation(e4);
      let m8 = new Ho({ lon: u6.position[0], lat: u6.position[1] }).to({ lon: n5[0], lat: n5[1] }, d4.duration).easing(uZ[d4.easing]).onUpdate(({ lon: v4, lat: x3 }) => {
        var I3;
        if (!this.renderer.getState(e4)) this.cancelAnimation(e4);
        else {
          let w3 = (I3 = h4 == null ? void 0 : h4.layers.get(ol)) == null ? void 0 : I3.containerId;
          w3 && this.Markers.setPosition(e4, [v4, x3], w3);
        }
      }).start();
      return this.renderer.getInternalTweenGroup().add(m8), this.renderer.render(), this.animations.set(e4, m8), lT(m8).then(() => {
        this.animations.delete(e4);
      });
    }, "animateTo") });
    O(this, "Exporter", { getCurrentSceneGLTF: H$3(async (e4) => this.renderer.getCurrentSceneGLTF(e4), "getCurrentSceneGLTF") });
    O(this, "Shapes", { add: H$3((e4, n5, i5) => {
      let a10 = i5 != null && i5.floorId ? this.floorsById.get(i5 == null ? void 0 : i5.floorId) : this.currentFloor, u6 = "shape-" + E();
      return this.renderer.addGeometryGroup(u6, e4, n5, a10.id), u6;
    }, "add"), remove: H$3((e4) => (this.renderer.remove(e4.id), e4.id), "remove") });
    O(this, "Text3D", { label: H$3((e4, n5, i5) => {
      var u6;
      if (!((u6 = this.api.getMapDataInternal()) != null && u6.enterpriseMode)) {
        B.warn("Enterprise mode is not enabled, skipping label creation");
        return;
      }
      let a10 = YD(this.renderer, e4, n5, i5);
      if (a10) return { textInfo: a10, target: e4 };
    }, "label"), labelAll: H$3((e4 = {}) => {
      var a10;
      if (!((a10 = this.api.getMapDataInternal()) != null && a10.enterpriseMode)) return B.warn("Enterprise mode is not enabled, skipping label creation"), [];
      let n5 = this.api.getMapData();
      if (!n5) return [];
      let i5 = [];
      return n5.getByType("space").forEach((u6) => {
        var h4, d4;
        if (u6.locations[0]) {
          let m8 = YD(this.renderer, u6, (d4 = (h4 = u6.locations[0]) == null ? void 0 : h4.name) != null ? d4 : u6.name, e4);
          m8 && i5.push({ textInfo: m8, target: u6 });
        }
      }), i5;
    }, "labelAll"), remove: H$3((e4) => {
      var n5;
      if (!((n5 = this.api.getMapDataInternal()) != null && n5.enterpriseMode)) {
        B.warn("Remove text label only works in enterprise mode");
        return;
      }
      return this.renderer.remove(e4), e4;
    }, "remove") });
    O(this, "Labels", { all: H$3(({ onCreate: e4, labelOptions: n5 = {} }) => {
      for (let i5 of Object.entries(this.mvf.space)) {
        let [a10, u6] = i5;
        u6 && u6.features.forEach((h4) => {
          var E4, T3, D4, A3, L3;
          let d4 = (E4 = this.api.getMapData()) == null ? void 0 : E4.getById("space", h4.properties.id);
          if (!d4) return;
          let m8 = (T3 = this.styleMap[h4.properties.id]) == null ? void 0 : T3.showImage, v4 = (D4 = h4.properties.details) == null ? void 0 : D4.images, x3 = m8 && ((A3 = v4 == null ? void 0 : v4[0]) != null && A3.url) ? { icon: v4[0].url } : {}, S6 = F$1({ marker: F$1(F$1({}, x3), (L3 = n5.appearance) == null ? void 0 : L3.marker) }, n5.appearance), w3 = (a10 ? this.floorsById.get(a10) : this.currentFloor).layers.get(iu2);
          if (h4.properties.center && d4.name !== "") {
            let B3 = this.renderer.addLabel2D(h4.properties.center, d4.name, G$1(F$1({ id: h4.properties.id + "-label" }, n5), { appearance: S6, rank: n5.rank, attachTo: Tm2(d4) }), ui.is(d4) ? d4.id : w3 == null ? void 0 : w3.containerId);
            B3 && e4(B3.id, d4.name, d4);
          }
        });
      }
    }, "all"), add: H$3((e4, n5, i5 = {}) => {
      let v4 = i5, { attachTo: a10 } = v4, u6 = J$1(v4, ["attachTo"]), h4 = uT(e4, this.floorsById, this.api.mapObjects[0].floorsById.get("default-floor")), d4 = h4.layers.get(iu2), m8 = this.renderer.addLabel2D(js2(e4), n5, G$1(F$1({}, u6), { occluderId: h4.occluderId, attachTo: a10 }), d4 == null ? void 0 : d4.containerId);
      if (!m8) throw new Y("label creating failed");
      return m8;
    }, "add"), remove: H$3(({ entityId: e4 }) => {
      this.renderer.remove(e4);
    }, "remove"), removeAll: H$3(() => {
    }, "removeAll") });
    O(this, "Paths", { add: H$3((e4, n5) => {
      var m8;
      let i5 = (m8 = n5 == null ? void 0 : n5.animateDrawing) != null ? m8 : true, a10 = [], u6 = e4[0].floorId || "root", h4 = 0;
      for (let v4 of e4) {
        let { floorId: x3 = "root", latitude: S6, longitude: I3 } = v4;
        x3 !== u6 && (h4++, u6 = x3), a10[h4] == null && a10.push({ floorId: x3, coordinates: [] });
        let w3 = x3 === v4.floorId ? v4 : new ve2({ longitude: I3, latitude: S6, floorId: x3 });
        a10[h4].coordinates.push(w3);
      }
      let d4 = a10.reduce((v4, { floorId: x3, coordinates: S6 }, I3) => {
        if (I3 !== 0) {
          let E4 = a10[I3 - 1], T3 = E4.coordinates[E4.coordinates.length - 1], D4 = S6[0], A3 = js2(T3), L3 = js2(D4), B3 = this.renderer.addPath({ type: "FeatureCollection", features: [{ type: "Feature", properties: { parentId: E4.floorId }, geometry: { type: "Point", coordinates: A3 } }, { type: "Feature", properties: { parentId: x3 }, geometry: { type: "Point", coordinates: L3 } }] }, n5, this.id);
          B3 && (n5 != null && n5.animateDrawing && this.renderer.setState(B3.id, { completeFraction: 0 }), v4.push(G$1(F$1({}, B3), { coordinates: [T3, D4] })));
        }
        let w3 = this.renderer.addPath({ type: "FeatureCollection", features: S6.map((E4) => ({ type: "Feature", properties: {}, geometry: { type: "Point", coordinates: js2(E4) } })) }, n5, x3);
        return w3 && (n5 != null && n5.animateDrawing && this.renderer.setState(w3.id, { completeFraction: 0 }), v4.push(G$1(F$1({}, w3), { coordinates: S6 }))), v4;
      }, []);
      if (i5) {
        let v4 = [], x3 = this.api.getMapData();
        return d4.forEach((S6) => {
          var w3;
          let I3 = WD(S6, x3, this.api);
          v4.push(new Ho({ fraction: 0 }).to({ fraction: 1 }, I3 === false ? 0 : (w3 = n5 == null ? void 0 : n5.drawDuration) != null ? w3 : 1500).onUpdate((E4) => {
            this.renderer.setState(S6.id, { completeFraction: E4.fraction });
          }));
        }), v4.forEach((S6, I3) => {
          I3 < v4.length - 1 && S6.chain(v4[I3 + 1]), this.renderer.getInternalTweenGroup().add(S6);
        }), v4[0].start(), this.renderer.render(), this.animations.set(d4[0].id.toString(), v4[0]), { paths: d4, animation: lT(v4[v4.length - 1]).then(() => {
          this.animations.delete(d4[0].id.toString());
        }) };
      } else return { paths: d4, animation: Promise.resolve() };
    }, "add"), remove: H$3((e4) => {
      e4.forEach((n5) => {
        this.cancelAnimation(n5), this.renderer.remove(n5);
      });
    }, "remove") });
    Q$3(this, Sl, { enabled: false, floorHeight: 10, updateCameraElevationOnFloorChange: true });
    this.renderer = a4.core, this.api = a4, this.id = e, this.renderer.addGroupContainer(e, {}, "root"), this.options = i != null ? i : {}, this.StackedMaps = new G1({ currentMapGetter: H$3(() => this, "currentMapGetter") }), this.mvf = (m5 = n4 == null ? void 0 : n4.mvf) != null ? m5 : {};
    let u5 = qD(this.mvf["styles.json"] || {});
    if (this.styleMap = u5, R$1(this, Sl, F$1({ enabled: false, floorHeight: 10, updateCameraElevationOnFloorChange: true }, i == null ? void 0 : i.multiFloorView)), !n4) {
      this.id !== "outdoors-container" && B.warn("Map (".concat(this.id, ") created with no data."));
      let I3 = new Y1({ id: "default-stack", externalId: "default-stack", name: "Default Stack", maps: ["default-floor"] }, this.id, this.renderer);
      this.floorStacksById.set(I3.id, I3), this.currentFloorStackId = I3.id;
      let w3 = new B1(I3.id, { id: "default-floor", externalId: "default-floor", name: "Default Floor", elevation: 0 }, this.renderer, P(this, Sl), i != null ? i : {});
      I3.addFloor(w3), this.floorsById.set(w3.id, w3), this.setFloor(w3.id);
      return;
    }
    let h = n4.getMVFFeatureByType("floor-stack");
    if (h == null || h.length === 0) throw new Y("MVF does not contain any Floor Stacks.");
    for (let I3 of h) {
      let w3 = new Y1(I3, this.id, this.renderer, (v3 = this.mvf.facade) == null ? void 0 : v3[I3.id]);
      if (w3.floorIds.length !== 0) {
        for (let E4 of w3.floorIds) {
          let T3 = n4.getMVFFeatureById("floor", E4);
          if (T3 != null) {
            let D4 = this.mvf.space[T3.id], A3 = this.mvf.obstruction[T3.id];
            if ((D4 == null || D4.features.length === 0) && (A3 == null || A3.features.length === 0)) continue;
            let L3 = new B1(w3.id, T3, this.renderer, P(this, Sl), i != null ? i : {}, this.mvf, u5, n4);
            w3.addFloor(L3), this.floorsById.set(L3.id, L3);
          }
        }
        this.floorStacksById.set(I3.id, w3), this.currentFloorStackId || (this.currentFloorStackId = I3.id);
      }
    }
    for (let [I3] of Object.entries(n4.facadesBySpaceId)) {
      let w3 = n4.getById("space", I3);
      w3 && (this.outdoorFloorStacks.add(w3.floor.floorStack.id), (x2 = this.floorsById.get(w3.floor.id)) == null || x2.setVisible(true));
    }
    let d = (S4 = this.mvf.enterprise) == null ? void 0 : S4.venue.defaultMap;
    if (i != null && i.initialFloor) {
      let I3 = Ug2(i.initialFloor);
      I3 && this.floorsById.has(I3) ? d = I3 : B.error("Invalid initial floor specified (".concat(i.initialFloor, "), using default behavior instead"));
    }
    d || (d = this.currentFloorStack.defaultFloor.id), this.startingFloorId = d;
  }
  get currentFloorStack() {
    let e = this.floorStacksById.get(this.currentFloorStackId);
    if (!e) throw new Y('Current floor stack with id "'.concat(this.currentFloorStackId, '" not found'));
    return e;
  }
  setFloorStack(e, n4) {
    if (this.currentFloorStackId === e) return;
    let i = this.floorStacksById.get(e);
    if (i == null) {
      B.error("Invalid floor stack passed to setFloorStack (".concat(e, "), the floor stack was not changed. Current floor stack is still ").concat(this.currentFloorStack.id, "."));
      return;
    }
    if (i.floorObjects.length === 0) {
      B.error("Floor stack (".concat(e, ") has no floors. The floor stack was not changed. Current floor stack is still ").concat(this.currentFloorStack.id, "."));
      return;
    }
    this.setFloor(i.defaultFloor.id, n4);
  }
  get currentFloor() {
    let e = this.floorsById.get(this.currentFloorId);
    if (!e) throw new Y('Floor with id "'.concat(this.currentFloorId, '" not found'));
    return e;
  }
  get floors() {
    return Array.from(this.floorsById.values());
  }
  processFloorChange(e) {
    var a4, u5, h, d, m5, v3, x2;
    if (this.api.manualFloorVisibility === true || this.StackedMaps.expandedFactor !== 0) return;
    let n4 = (a4 = this.api.getMapDataInternal()) == null ? void 0 : a4.getById("floor", e), i = (u5 = this.api.getMapDataInternal()) == null ? void 0 : u5.getById("floor-stack", this.currentFloorStackId);
    if (n4 && i) if (!((h = P(this, Sl)) != null && h.enabled) || n4.floorStack.id !== (i == null ? void 0 : i.id)) for (let S4 of this.floorStacksById.values()) S4.floorObjects.forEach((I3) => {
      I3.id !== e && I3.setVisible(false);
    });
    else {
      let S4 = XD(i.floors, n4, P(this, Sl).floorHeight, ((m5 = (d = this.api.Navigation) == null ? void 0 : d.floors) == null ? void 0 : m5.map((I3) => I3.id)) || []);
      (x2 = (v3 = this.api) == null ? void 0 : v3.Outdoor) == null || x2.setOpacity(S4.outdoorOpacity), S4.floorStates.forEach((I3) => {
        var w3;
        if (I3.floor) {
          let E4 = (w3 = this.api.getMapData()) == null ? void 0 : w3.getById("floor", I3.floor.id);
          E4 && this.api.updateState(E4, I3.state);
        }
      }), P(this, Sl).updateCameraElevationOnFloorChange && this.api.Camera.setElevation(n4.elevation * P(this, Sl).floorHeight);
    }
  }
  setFloor(e, n4) {
    if (this.currentFloorId === e) return;
    if (!this.floorsById.get(e)) {
      B.error("Invalid floor passed to setFloor (".concat(e, "), the floor was not changed. Current floor is still ").concat(this.currentFloor.id));
      return;
    }
    let a4 = this.currentFloorId;
    this.publish("floor-change-start", { previousFloorId: a4, floorId: e, reason: n4 }), !this.StackedMaps.expanded && this.currentFloorStack && this.processFloorChange(e), this.currentFloorId = e, this.currentFloorStackId = this.currentFloor.floorStackId, this.currentFloor.setVisible(true), this.hideImagesOnAllFloorsExceptCurrent(), this.publish("floor-change", { reason: n4, floorId: this.currentFloor.id, previousFloorId: a4 });
  }
  hideImagesOnAllFloorsExceptCurrent() {
    var e, n4;
    if (this.options.hideImagesNotOnCurrentFloor && !((e = this.options.multiFloorView) != null && e.enabled)) for (let i of this.floorsById.values()) (n4 = i.layers.get(sl)) == null || n4.setVisible(i.id === this.currentFloor.id);
  }
  cancelAnimation(e) {
    let n4 = this.animations.get(e);
    n4 && (n4.stop(), this.animations.delete(e), this.renderer.getInternalTweenGroup().remove(n4));
  }
};
Sl = /* @__PURE__ */ new WeakMap(), H$3(cT, "GeojsonApiMapObject");
var q1 = cT;
function YD(r5, t, e, n4) {
  return r5.labelText3D(t.id, e != null ? e : t.name, G$1(F$1({}, n4), { parentId: t.floor.id }));
}
H$3(YD, "labelSpace");
a();
var Sa2, Z1, pT = class pT2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, Sa2, /* @__PURE__ */ new Map());
    Q$3(this, Z1);
    R$1(this, Z1, t);
  }
  get currentMap() {
    return P(this, Z1).call(this);
  }
  getById(t) {
    return P(this, Sa2).get(t);
  }
  add(t, e, n4) {
    let i = t.anchorTarget;
    if (!i) throw new Error("get coordinate failed");
    let a4 = this.currentMap;
    if (!a4) throw new Error("currentMap should exist");
    let u5 = a4.Markers.add(i, e, G$1(F$1({}, n4), { rank: (n4 == null ? void 0 : n4.rank) || "medium", dynamicResize: (n4 == null ? void 0 : n4.dynamicResize) || false, attachTo: Tm2(t) }));
    if (u5 == null) throw new Error("error creating marker");
    let h = a4.Markers.getContentEl(u5.id.toString());
    if (!h) throw new Error("marker component should exist");
    let d = new Mu(u5.id.toString(), h, t);
    return P(this, Sa2).set(d.id, { marker: d, entityId: u5.id.toString() }), d;
  }
  remove(t) {
    var n4;
    let e = P(this, Sa2).get(t.id);
    e && ((n4 = this.currentMap) == null || n4.Markers.remove(e.entityId), P(this, Sa2).delete(t.id.toString()));
  }
  removeAll() {
    let t = [];
    return P(this, Sa2).forEach(({ marker: e }) => {
      this.remove(e), t.push(e), P(this, Sa2).delete(e.id.toString());
    }), t;
  }
  setPosition(t, e) {
    var u5;
    let n4 = e.anchorTarget;
    if (!n4) {
      B.error("Cannot determine coordinate from target.");
      return;
    }
    let i = this.currentMap;
    if (!i) {
      B.error("Cannot determine the current map.");
      return;
    }
    let a4 = P(this, Sa2).get(t.id);
    if (!a4) {
      B.error('Cannot find the Marker with id "'.concat(t.id, '".'));
      return;
    }
    i.Markers.setPosition(a4.entityId, js2(n4), (u5 = n4.floorId) != null ? u5 : i.currentFloorId), a4.marker.updateTarget(e);
  }
  animateTo(t, e, n4) {
    var h;
    let i = e.anchorTarget;
    if (!i) return B.error("Cannot determine coordinate from target."), Promise.resolve();
    let a4 = this.currentMap;
    if (!a4) return B.error("Cannot determine the current map."), Promise.resolve();
    let u5 = P(this, Sa2).get(t.id);
    return u5 ? (u5.marker.updateTarget(e), a4.Markers.animateTo(u5.entityId, js2(i), (h = i.floorId) != null ? h : a4.currentFloorId, n4)) : (B.error('Cannot find the Marker with id "'.concat(t.id, '".')), Promise.resolve());
  }
};
Sa2 = /* @__PURE__ */ new WeakMap(), Z1 = /* @__PURE__ */ new WeakMap(), H$3(pT, "Markers");
var W1 = pT;
a();
var Lu2, J1, hT = class hT2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, Lu2, /* @__PURE__ */ new Map());
    Q$3(this, J1);
    R$1(this, J1, t);
  }
  get currentMap() {
    return P(this, J1).call(this);
  }
  getById(t) {
    return P(this, Lu2).get(t);
  }
  add(t, e, n4) {
    var d;
    let i = t.anchorTarget;
    if (!i) throw new Error("Target does not implement IAnchorable.");
    let a4 = this.currentMap;
    if (!a4) throw new Error("currentMap should exist");
    let u5 = a4.Images.add(js2(i), e, G$1(F$1({}, n4), { floorId: i.floorId, verticalOffset: i.verticalOffset + ((d = n4.verticalOffset) != null ? d : 0) }));
    if (!u5) throw new Error("image component should exist");
    let h = new M1(u5.id.toString(), e, t);
    return P(this, Lu2).set(h.id, { image: h, entityId: u5.id.toString() }), h;
  }
  remove(t) {
    var n4;
    let e = P(this, Lu2).get(t.id);
    e && ((n4 = this.currentMap) == null || n4.Images.remove(e.entityId), P(this, Lu2).delete(t.id.toString()));
  }
  removeAll() {
    let t = [];
    return P(this, Lu2).forEach(({ image: e }) => {
      this.remove(e), t.push(e), P(this, Lu2).delete(e.id.toString());
    }), t;
  }
};
Lu2 = /* @__PURE__ */ new WeakMap(), J1 = /* @__PURE__ */ new WeakMap(), H$3(hT, "Images");
var $1 = hT;
a();
var Il, Q1, fT = class fT2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, Il, /* @__PURE__ */ new Map());
    Q$3(this, Q1);
    R$1(this, Q1, t);
  }
  get currentMap() {
    return P(this, Q1).call(this);
  }
  getById(t) {
    return P(this, Il).get(t);
  }
  add(t, e, n4) {
    let i = [t], a4 = i.reduce((d, m5) => {
      var v3;
      return m5 ? (d.has(m5.floorId) || d.set(m5.floorId, []), (v3 = d.get(m5.floorId)) == null || v3.push(m5), d) : (B.error("Cannot determine coordinate from options."), d);
    }, /* @__PURE__ */ new Map());
    if (!i.length) throw new Error("targets should not be empty when adding a model");
    let u5 = this.currentMap;
    if (!u5) throw new Error("currentMap should exist");
    let h = [];
    return a4.forEach((d, m5) => {
      let v3 = E();
      u5.Models.add(v3, d, G$1(F$1({}, n4), { url: e, floorId: m5 })).forEach(({ id: S4 }) => {
        let I3 = new rf2(S4.toString(), v3, d[0]);
        P(this, Il).set(I3.id, { model: I3, entityId: S4.toString(), groupId: v3 }), h.push(I3);
      });
    }), h[0];
  }
  remove(t) {
    var n4;
    let e = P(this, Il).get(t.id);
    e && ((n4 = this.currentMap) == null || n4.Models.remove(e.entityId, e.groupId), P(this, Il).delete(t.id.toString()));
  }
  removeAll() {
    let t = [];
    return P(this, Il).forEach(({ model: e }) => {
      var i;
      let n4 = P(this, Il).get(e.id);
      n4 && (t.push(e), (i = this.currentMap) == null || i.Models.remove(n4.entityId, n4.groupId), P(this, Il).delete(e.id.toString()));
    }), t;
  }
};
Il = /* @__PURE__ */ new WeakMap(), Q1 = /* @__PURE__ */ new WeakMap(), H$3(fT, "Models");
var K1 = fT;
a();
var Ml, e0, dT = class dT2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, Ml, /* @__PURE__ */ new Map());
    Q$3(this, e0);
    R$1(this, e0, t);
  }
  get currentMap() {
    return P(this, e0).call(this);
  }
  getById(t) {
    return P(this, Ml).get(t);
  }
  add(t, e) {
    let n4 = this.currentMap;
    if (!n4) throw new Error("currentMap should exist");
    let i = n4.Paths.add(t, e), a4 = i.paths.map((h) => h.id.toString()), u5 = new ba2(E(), i.animation, t, i.paths);
    for (let h of a4) P(this, Ml).set(h, { path: u5, entityIds: a4 });
    return P(this, Ml).set(u5.id, { path: u5, entityIds: a4 }), u5;
  }
  remove(t) {
    var n4;
    let e = P(this, Ml).get(t.id);
    e && ((n4 = this.currentMap) == null || n4.Paths.remove(e.entityIds), P(this, Ml).delete(t.id), e.entityIds.forEach((i) => P(this, Ml).delete(i)));
  }
  removeAll() {
    let t = [];
    return P(this, Ml).forEach(({ path: e }) => {
      this.remove(e), t.push(e);
    }), t;
  }
};
Ml = /* @__PURE__ */ new WeakMap(), e0 = /* @__PURE__ */ new WeakMap(), H$3(dT, "Paths");
var t0 = dT;
a();
a();
var aL = N$2(z3(), 1);
a();
var r0 = "blue-dot", ZD = "blue-dot-accuracy-ring";
var mT = "#2266ff", cZ = "#808080", $D = "#f5f5f5";
var JD = { radius: 10, color: mT, inactiveColor: cZ, heading: { color: mT, opacity: 0.7 }, accuracyRing: { color: mT, opacity: 0.3 }, timeout: 3e4, watchDevicePosition: true, debug: false };
a();
var KD = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAkklEQVRoge3awQ3AIAxD0VAMYf+F0yUixbL8JshXuLSwIqJCwDc9QBeZEOy9p2doAQDTM7TQ2cg5Z3qGFjpHS2YjDiGDe+/0DC0cwkYpJKdnaIFMkY1kymzEIVQcwsYhbPDem56hhc5GHELGIWwcwsYhbJS+2R1CxSFsdH5iO4SMr97Y6FxPqxytVVV+HcTEIWx+9mcIqHSOm9QAAAAASUVORK5CYII=";
a();
var QD = H$3((r5, t, e = 0) => {
  if (Math.abs(r5) >= Math.PI) throw new Error("Sector angle too wide!");
  let n4 = e / Math.tan(r5 / 2), i = e / Math.sin(r5 / 2), a4 = i + t, u5 = 10, h = new ta$1();
  h.moveTo(-i * Math.sin(r5 / 2), i * Math.cos(r5 / 2) - n4);
  for (let d = 0; d < u5; d++) h.lineTo(-(a4 * Math.sin(r5 / 2 - r5 / u5 * d)), a4 * Math.cos(r5 / 2 - r5 / u5 * d) - n4);
  for (let d = 0; d < u5; d++) h.lineTo(-(e * Math.sin(Math.PI / -2 + Math.PI / u5 * d)), e * Math.cos(Math.PI / -2 + Math.PI / u5 * d));
  return new Al$1(h, { depth: 0.1, bevelEnabled: false, UVGenerator: hZ(t) });
}, "createSectorGeometry"), gT = H$3((r5, t, e) => {
  let i = Math.sqrt(Math.pow(r5, 2) + Math.pow(t, 2)) / e;
  return i > 1 ? i = 1 : i < 0 && (i = 0), new ot$1(0, i);
}, "generateRadialUV"), hZ = H$3((r5) => ({ generateTopUV: H$3((t, e, n4, i, a4) => {
  let u5 = e[n4 * 3], h = e[n4 * 3 + 1], d = e[i * 3], m5 = e[i * 3 + 1], v3 = e[a4 * 3], x2 = e[a4 * 3 + 1];
  return [gT(u5, h, r5), gT(d, m5, r5), gT(v3, x2, r5)];
}, "generateTopUV"), generateSideWallUV: H$3(() => [new ot$1(0, 1), new ot$1(0, 1), new ot$1(0, 1), new ot$1(0, 1)], "generateSideWallUV") }), "radialUVGenerator");
function tL(r5, t) {
  if (t == null) return r5;
  let e = { latitude: r5 == null ? void 0 : r5.latitude, longitude: r5 == null ? void 0 : r5.longitude, accuracy: r5 == null ? void 0 : r5.accuracy, floor: r5 == null ? void 0 : r5.floor, heading: r5 == null ? void 0 : r5.heading };
  return "latitude" in t && (e.latitude = (t == null ? void 0 : t.latitude) == null || t.latitude === "device" ? r5 == null ? void 0 : r5.latitude : t.latitude), "longitude" in t && (e.longitude = t.longitude == null || t.longitude === "device" ? r5 == null ? void 0 : r5.longitude : t.longitude), "accuracy" in t && (e.accuracy = t.accuracy === "device" ? r5 == null ? void 0 : r5.accuracy : t.accuracy), "floor" in t && (e.floor = t.floor === "device" ? r5 == null ? void 0 : r5.floor : t.floor), "heading" in t && (e.heading = t.heading === "device" ? r5 == null ? void 0 : r5.heading : t.heading), e;
}
H$3(tL, "getPositionWithOverrides");
function fZ([r5, t], [e, n4], [i, a4]) {
  let u5 = e - r5, h = n4 - t, d = u5 ** 2 + h ** 2;
  if (d === 0) return;
  let m5 = ((i - r5) * u5 + (a4 - t) * h) / d, v3;
  m5 <= 0 ? v3 = [r5, t] : m5 >= 1 ? v3 = [e, n4] : v3 = [r5 + m5 * u5, t + m5 * h];
  let x2 = Pr$1([i, a4], v3);
  return { proportion: Math.max(0, Math.min(1, m5)), intersection: v3, distance: x2 };
}
H$3(fZ, "getPointLineIntersection");
function eL(r5, t) {
  if (r5 == null || r5.length < 2) return;
  let e = Number.MAX_SAFE_INTEGER, n4, i = 0, a4 = 0;
  for (let u5 = 0; u5 < r5.length - 1; u5++) {
    let h = r5[u5], d = r5[u5 + 1], m5 = fZ(h, d, t);
    m5 != null && m5.distance < e && (e = m5.distance, n4 = m5.intersection, i = u5, a4 = m5.proportion);
  }
  if (n4) return { intersection: n4, distance: e, segmentIndex: i, proportion: a4 };
}
H$3(eL, "findBlueDotOnPath");
function rL(r5, t) {
  let e = new Il$2({ color: r5, opacity: t, transparent: true, depthTest: false, depthWrite: false }), n4 = 0.35, i = 0.35 * 4, a4 = QD(Math.PI / 6, i, n4);
  new Ul().load(KD, (h) => {
    e.alphaMap = h, e.needsUpdate = true;
  });
  let u5 = new ye$1(a4, e);
  return u5.position.z = -0.05, u5.renderOrder = 0, u5;
}
H$3(rL, "createHeadingCone");
function nL(r5, t) {
  let e = new Sl$2(1, 1, 0.05, 32), n4 = new Il$2({ transparent: true, color: r5, opacity: t, depthTest: false, depthWrite: false }), i = new ye$1(e, n4);
  return i.scale.set(0, 0, 0.05), i.renderOrder = 1, i.rotation.x = Math.PI / 2, i;
}
H$3(nL, "createAccuracyRing");
function iL(r5) {
  let t = new Sl$2(0.35, 0.35, 0.07, 32), e = new Il$2({ transparent: true, color: $D, depthTest: false, depthWrite: false }), n4 = new ye$1(t, e);
  n4.renderOrder = 2;
  let i = new Sl$2(0.35 * 0.8, 0.35 * 0.8, 0.01, 32), a4 = new Il$2({ transparent: true, color: r5, depthTest: false, depthWrite: false }), u5 = new ye$1(i, a4);
  return u5.renderOrder = 3, n4.rotation.x = Math.PI / 2, n4.position.z = 0.07 / 2, u5.rotation.x = Math.PI / 2, u5.position.z = 0.07, { outerMesh: n4, innerMesh: u5 };
}
H$3(iL, "createBlueDot");
var lL = N$2(oL(), 1);
var Or, Qr, cf2, Au, hs, fs2, Nu2, pf2, hf2, ff2, Un2, qo, n0, ku2, i0, o0, s0, _2, C2, a0, S2, l0, I2, Tl, Ru2, M2, $c2, Lm2, wl, u0, yT = class yT2 {
  constructor(t, e) {
    Q$3(this, Or);
    Q$3(this, Qr);
    Q$3(this, cf2, null);
    O(this, "primaryGeometry");
    O(this, "secondaryGeometry");
    Q$3(this, Au);
    Q$3(this, hs);
    Q$3(this, fs2);
    Q$3(this, Nu2);
    Q$3(this, pf2);
    Q$3(this, hf2);
    Q$3(this, ff2);
    Q$3(this, Un2, JD);
    Q$3(this, qo, 1);
    Q$3(this, n0);
    Q$3(this, ku2);
    O(this, "bounds");
    O(this, "state", "disabled");
    O(this, "following", false);
    Q$3(this, i0, H$3((t5) => {
      var e4;
      return (e4 = P(this, Qr).getMapData()) == null ? void 0 : e4.getById("floor", t5);
    }, "#getFloorByFloorId"));
    Q$3(this, o0, H$3((t5) => {
      var n4;
      let e4;
      if (t5 != null) {
        let i = (n4 = P(this, Qr).currentMap) == null ? void 0 : n4.currentFloorStack.floorObjectsByElevation.get(t5);
        e4 = i ? P(this, i0).call(this, i.id) : void 0;
      }
      return e4;
    }, "#getFloorByFloorLevel"));
    Q$3(this, s0, H$3(() => this.state !== "hidden" && this.state !== "disabled", "#shouldUpdateGeometry"));
    Q$3(this, _2, H$3((t5, e4) => {
      P(this, I2).call(this), t5.scale.set(P(this, qo), P(this, qo), P(this, qo)), t5.position.z = 0.07 / 2 * P(this, qo), e4.scale.set(P(this, qo), P(this, qo), P(this, qo)), e4.position.z = 0.07 * P(this, qo), this.state === "active" ? e4.material.color.set(P(this, Un2).color) : this.state === "inactive" && e4.material.color.set(P(this, Un2).inactiveColor);
    }, "#updatePrimaryGeometry"));
    Q$3(this, C2, H$3((t5, e4) => {
      if (this.state === "active") {
        let n4 = this.accuracy;
        n4 != null ? (t5.visible = true, P(this, hf2) && P(this, hf2).stop(), R$1(this, hf2, new Ho({ scale: t5.scale.x }).to({ scale: n4 / 2 }, 150).onUpdate(({ scale: a4 }) => {
          t5.scale.set(a4, 1, a4);
        }).start()), P(this, Or).getInternalTweenGroup().add(P(this, hf2))) : t5.visible = false;
        let i = this.heading;
        if (i != null) {
          e4.visible = true, P(this, ff2) && P(this, ff2).stop();
          let { start: a4, end: u5 } = Ir(e4.rotation.z, -Zp$2.degToRad(i));
          R$1(this, ff2, new Ho({ rotation: a4 }).to({ rotation: u5 }, 150).onUpdate(({ rotation: h }) => {
            e4.rotation.z = h;
          }).start()), P(this, Or).getInternalTweenGroup().add(P(this, ff2)), e4.scale.set(P(this, qo), P(this, qo), 1);
        } else e4.visible = false;
      } else this.state === "inactive" && (e4.visible = false, t5.visible = false);
    }, "#updateSecondaryGeometry"));
    Q$3(this, a0, H$3((t5) => {
      if (!P(this, s0).call(this)) return;
      let [e4, n4] = t5.children;
      P(this, _2).call(this, e4, n4);
    }, "#updatePrimaryGeometryPerFrame"));
    Q$3(this, S2, H$3((t5) => {
      if (!P(this, s0).call(this)) return;
      let [e4, n4] = t5.children;
      P(this, C2).call(this, e4, n4);
    }, "#updateSecondaryGeometryPerFrame"));
    Q$3(this, l0, H$3((t5) => {
      var h, d;
      let e4;
      try {
        e4 = vZ.parse(tL(t5, P(this, hs)));
      } catch (m5) {
        P(this, Tl).call(this, "error"), B.error("BlueDot: Position parse failed", m5 instanceof Q.ZodError ? m5.message : String(m5));
        return;
      }
      P(this, Un2).debug && B.log("BlueDot: Parsed position", e4);
      let { min: n4, max: i } = this.bounds || {};
      if (n4 != null && i != null && isFinite(n4.x) && isFinite(n4.y) && isFinite(i.x) && isFinite(i.y)) {
        let m5 = P(this, Or).convertTo3DMapPosition(e4.latitude, e4.longitude, 0);
        if (!(m5.x >= n4.x && m5.x <= i.x && m5.y >= n4.y && m5.y <= i.y)) {
          B.warn("BlueDot: Position [".concat(e4.longitude, ", ").concat(e4.latitude, "] is outside map bounds. Position update will be discarded."));
          return;
        }
      }
      R$1(this, fs2, e4), P(this, Tl).call(this, "position-update"), P(this, Nu2) && clearTimeout(P(this, Nu2)), typeof P(this, Un2).timeout == "number" && P(this, Un2).timeout < 1 / 0 && R$1(this, Nu2, setTimeout(() => {
        P(this, Un2).debug && B.log("BlueDot: Position timed out after ".concat(P(this, Un2).timeout, "ms")), P(this, Tl).call(this, "timeout"), P(this, Or).render();
      }, P(this, Un2).timeout)), (d = P(this, Qr).getMapDataInternal()) == null || d.Analytics.updateState({ userPosition: { bluedotTimestamp: Date.now(), latitude: e4.latitude, longitude: e4.longitude, floorLevel: (h = e4.floor) == null ? void 0 : h.elevation, accuracy: e4.accuracy } });
      let a4 = e4.floor != null ? e4.floor.id : P(this, Qr).currentFloor.id || "outdoors-container", u5 = [e4.longitude, e4.latitude];
      if (!this.primaryGeometry) this.primaryGeometry = P(this, Or).addCustomGeometry(r0, { type: "Feature", properties: {}, geometry: { type: "Point", coordinates: u5 } }, { setup: H$3((m5) => {
        let { outerMesh: v3, innerMesh: x2 } = iL(P(this, Un2).color);
        m5.add(v3), m5.add(x2), P(this, a0).call(this, m5);
      }, "setup"), update: P(this, a0) }, { visible: true, interactive: true }, a4), this.secondaryGeometry = P(this, Or).addCustomGeometry(ZD, { type: "Feature", properties: {}, geometry: { type: "Point", coordinates: u5 } }, { setup: H$3((m5) => {
        let v3 = nL(P(this, Un2).accuracyRing.color, P(this, Un2).accuracyRing.opacity), x2 = rL(P(this, Un2).heading.color, P(this, Un2).heading.opacity);
        m5.add(v3), v3.visible = false, m5.add(x2), x2.visible = false;
      }, "setup"), update: P(this, S2) }, { visible: true, interactive: false }, a4);
      else {
        let m5 = P(this, Or).getState(this.primaryGeometry);
        u5 = [m5.position[0], m5.position[1]];
      }
      P(this, pf2) && P(this, pf2).stop(), R$1(this, pf2, new Ho(u5).to([e4.longitude, e4.latitude], 1e3).easing(Vn.Cubic.Out).onUpdate((m5) => {
        let v3 = { position: [m5[0], m5[1]] };
        v3.parent = a4, this.primaryGeometry && this.secondaryGeometry && P(this, Or).setState(this.primaryGeometry, v3), this.secondaryGeometry && P(this, Or).setState(this.secondaryGeometry, v3);
      }).start()), P(this, Or).getInternalTweenGroup().add(P(this, pf2)), P(this, Qr).publish("blue-dot-position-update", { floor: this.floor, heading: this.heading, accuracy: this.accuracy, coordinate: this.coordinate }), P(this, Or).render();
    }, "#setPosition"));
    O(this, "onPositionUpdate", H$3((t5) => {
      var e4, n4, i, a4, u5;
      if (this.state !== "disabled") {
        try {
          yZ.parse(t5);
        } catch (h) {
          P(this, Tl).call(this, "error"), B.error("BlueDot: Browser sent invalid position", h instanceof Q.ZodError ? h.message : String(h));
          return;
        }
        R$1(this, Au, { latitude: (e4 = t5.coords) == null ? void 0 : e4.latitude, longitude: (n4 = t5.coords) == null ? void 0 : n4.longitude, accuracy: (i = t5.coords) == null ? void 0 : i.accuracy, heading: (a4 = t5.coords) == null ? void 0 : a4.heading, floor: P(this, o0).call(this, (u5 = t5.coords) == null ? void 0 : u5.floorLevel) }), P(this, l0).call(this, P(this, Au));
      }
    }, "onPositionUpdate"));
    O(this, "onPositionError", H$3((t5) => {
      var e4;
      switch (P(this, Tl).call(this, "error"), t5.code) {
        case t5.PERMISSION_DENIED:
          B.error("Geolocation permission denied by the user.", t5), (e4 = P(this, Qr).getMapDataInternal()) == null || e4.Analytics.sendWatchPositionDenied();
          break;
        case t5.POSITION_UNAVAILABLE:
          B.error("Geolocation position unavailable.", t5);
          break;
        case t5.TIMEOUT:
          B.error("Geolocation request timed out.", t5);
          break;
        default:
          B.error("An unknown geolocation error occurred.", t5);
          break;
      }
      P(this, Qr).publish("blue-dot-position-error", t5);
    }, "onPositionError"));
    Q$3(this, I2, H$3(() => {
      var e4;
      let t5 = Math.round(P(this, Or).camera.zoomLevel * 1e5);
      if (t5 !== P(this, n0)) {
        R$1(this, n0, t5);
        let n4 = (e4 = P(this, Or).getMetresPerPixel()) != null ? e4 : 1;
        R$1(this, qo, Math.max(P(this, Un2).radius / (0.35 / n4), 1));
      }
    }, "#updateScale"));
    Q$3(this, Tl, H$3((t5) => {
      let e4 = gZ[this.state].actions[t5];
      if (e4) {
        switch (P(this, Un2).debug && B.log("BlueDot: Transitioning from ".concat(this.state, " to ").concat(e4, " using ").concat(t5)), e4) {
          case "hidden":
          case "disabled":
            this.primaryGeometry && P(this, Or).setState(this.primaryGeometry, { visible: false }), this.secondaryGeometry && P(this, Or).setState(this.secondaryGeometry, { visible: false });
            break;
          case "active":
            this.primaryGeometry && P(this, Or).setState(this.primaryGeometry, { visible: true }), this.secondaryGeometry && P(this, Or).setState(this.secondaryGeometry, { visible: true });
            break;
        }
        this.state !== e4 && (this.state = e4, P(this, Qr).publish("blue-dot-state-change", { state: e4, action: t5 }));
      } else B.warn("BlueDot: Invalid state transition from ".concat(this.state, " to ").concat(e4, " using ").concat(t5));
    }, "#transitionAction"));
    Q$3(this, Ru2);
    Q$3(this, M2, H$3(() => {
      if (P(this, Ru2) == null && P(this, Qr).Navigation.activeDirections != null) {
        let e4 = (Array.isArray(P(this, Qr).Navigation.activeDirections) ? P(this, Qr).Navigation.activeDirections.flatMap((n4) => n4.coordinates) : P(this, Qr).Navigation.activeDirections.coordinates).filter((n4) => n4.floorId === P(this, Qr).currentFloor.id);
        R$1(this, Ru2, (0, lL.default)(e4.map((n4) => ({ x: n4.longitude, y: n4.latitude })), 1e-5).map((n4) => [n4.x, n4.y]));
      }
      return P(this, Ru2);
    }, "#getSimplifiedDirections"));
    Q$3(this, $c2, H$3(() => {
      P(this, Or).camera.isAnimating && P(this, Or).camera.cancelAnimation(), P(this, wl) && (P(this, Qr).off("blue-dot-position-update", P(this, wl)), R$1(this, wl, void 0)), this.following = false, R$1(this, Ru2, void 0), P(this, Or).off("user-interaction-start", P(this, $c2)), P(this, Qr).off("navigation-active-path-change", P(this, Lm2)), P(this, Qr).publish("blue-dot-follow-change", { following: false });
    }, "#cancelFollow"));
    Q$3(this, Lm2, H$3(() => {
      R$1(this, Ru2, void 0);
    }, "#pathChangeHandler"));
    Q$3(this, wl);
    O(this, "follow", H$3((t5, e4) => {
      var i, a4, u5, h;
      if (t5 === false) {
        P(this, $c2).call(this);
        return;
      }
      t5 !== "position-only" && (e4 == null ? void 0 : e4.bearing) != null && B.warn("BlueDot: Camera bearing option will be ignored in follow mode '".concat(t5, "'. To control the bearing manually, use mode 'position-only'."));
      let n4 = { zoomLevel: (i = e4 == null ? void 0 : e4.zoomLevel) != null ? i : 21, bearing: t5 === "position-only" ? e4 == null ? void 0 : e4.bearing : void 0, pitch: (a4 = e4 == null ? void 0 : e4.pitch) != null ? a4 : 45, duration: (u5 = e4 == null ? void 0 : e4.duration) != null ? u5 : 1e3, easing: (h = e4 == null ? void 0 : e4.easing) != null ? h : "ease-in-out" };
      this.following ? P(this, wl) && P(this, Qr).off("blue-dot-position-update", P(this, wl)) : (this.following = true, P(this, Or).on("user-interaction-start", P(this, $c2)), P(this, Qr).on("navigation-active-path-change", P(this, Lm2))), R$1(this, wl, (d) => {
        let { coordinate: m5, heading: v3, floor: x2 } = d;
        if (n4.center = [m5.longitude, m5.latitude], x2 != null && x2.id !== P(this, Qr).currentFloor.id && (P(this, Qr).currentMap.setFloor(x2.id), R$1(this, Ru2, void 0)), t5 === "position-and-heading") n4.bearing = v3 != null ? v3 : void 0;
        else if (t5 === "position-and-path-direction") {
          let S4 = P(this, M2).call(this);
          if (S4 != null) {
            let I3 = eL(S4, [m5.longitude, m5.latitude]);
            if (I3 != null) {
              let w3 = S4[I3.segmentIndex], E4 = S4[I3.segmentIndex + 1];
              n4.bearing = Cr(w3, E4);
            }
          }
        }
        P(this, Or).camera.animateTo(n4);
      }), P(this, Qr).on("blue-dot-position-update", P(this, wl)), P(this, Qr).publish("blue-dot-follow-change", { following: true, mode: t5 });
    }, "follow"));
    Q$3(this, u0, H$3((t5) => {
      this.bounds = t5;
    }, "#handlePanBoundsChange"));
    R$1(this, Or, t), R$1(this, Qr, e);
  }
  get heading() {
    var t;
    return (t = P(this, fs2)) == null ? void 0 : t.heading;
  }
  get accuracy() {
    var t;
    return (t = P(this, fs2)) == null ? void 0 : t.accuracy;
  }
  get coordinate() {
    var t, e;
    if (P(this, fs2) != null) return (P(this, ku2) == null || ((t = this.floor) == null ? void 0 : t.id) !== P(this, ku2).floorId || P(this, fs2).latitude !== P(this, ku2).latitude || P(this, fs2).longitude !== P(this, ku2).longitude) && R$1(this, ku2, new ve2(P(this, fs2).latitude, P(this, fs2).longitude, (e = this.floor) == null ? void 0 : e.id)), P(this, ku2);
  }
  get floor() {
    var t;
    return (t = P(this, fs2)) == null ? void 0 : t.floor;
  }
  enable(t) {
    R$1(this, Un2, (0, aL.default)({}, t, P(this, Un2))), P(this, Tl).call(this, "enable"), this.watchDevicePosition(P(this, Un2).watchDevicePosition), this.bounds || (this.bounds = P(this, Or).getSystems().cameraSystem.panBounds, P(this, Or).on("pan-bounds-change", P(this, u0)));
  }
  disable() {
    this.primaryGeometry && (P(this, Or).remove(this.primaryGeometry.id), this.primaryGeometry = void 0), this.secondaryGeometry && (P(this, Or).remove(this.secondaryGeometry.id), this.secondaryGeometry = void 0), P(this, Nu2) && (clearTimeout(P(this, Nu2)), R$1(this, Nu2, void 0)), this.following && P(this, $c2).call(this), this.watchDevicePosition(false), R$1(this, fs2, void 0), R$1(this, hs, void 0), P(this, Tl).call(this, "disable"), P(this, Or).off("user-interaction-start", P(this, $c2)), P(this, Qr).off("navigation-active-path-change", P(this, Lm2)), P(this, Or).off("pan-bounds-change", P(this, u0));
  }
  watchDevicePosition(t) {
    if (P(this, cf2) && (navigator.geolocation.clearWatch(P(this, cf2)), R$1(this, cf2, null)), P(this, Au) && R$1(this, Au, void 0), t) {
      if (this.state === "disabled") {
        B.warn("BlueDot must be enabled before watching browser position.");
        return;
      }
      R$1(this, cf2, navigator.geolocation.watchPosition(this.onPositionUpdate, this.onPositionError, { enableHighAccuracy: true }));
    }
  }
  update(t) {
    var n4, i;
    t == null ? R$1(this, hs, void 0) : "coords" in t ? R$1(this, hs, Object.assign({}, P(this, hs), { latitude: t.coords.latitude, longitude: t.coords.longitude, accuracy: t.coords.accuracy, heading: t.coords.heading, floor: P(this, o0).call(this, t.coords.floorLevel) })) : (R$1(this, hs, Object.assign({}, P(this, hs), t)), "floorOrFloorId" in t && (P(this, hs).floor = typeof t.floorOrFloorId == "string" && t.floorOrFloorId !== "device" ? P(this, i0).call(this, t.floorOrFloorId) : t.floorOrFloorId)), (((n4 = P(this, hs)) == null ? void 0 : n4.latitude) != null && ((i = P(this, hs)) == null ? void 0 : i.longitude) != null || P(this, Au) != null) && P(this, l0).call(this, P(this, Au));
  }
};
Or = /* @__PURE__ */ new WeakMap(), Qr = /* @__PURE__ */ new WeakMap(), cf2 = /* @__PURE__ */ new WeakMap(), Au = /* @__PURE__ */ new WeakMap(), hs = /* @__PURE__ */ new WeakMap(), fs2 = /* @__PURE__ */ new WeakMap(), Nu2 = /* @__PURE__ */ new WeakMap(), pf2 = /* @__PURE__ */ new WeakMap(), hf2 = /* @__PURE__ */ new WeakMap(), ff2 = /* @__PURE__ */ new WeakMap(), Un2 = /* @__PURE__ */ new WeakMap(), qo = /* @__PURE__ */ new WeakMap(), n0 = /* @__PURE__ */ new WeakMap(), ku2 = /* @__PURE__ */ new WeakMap(), i0 = /* @__PURE__ */ new WeakMap(), o0 = /* @__PURE__ */ new WeakMap(), s0 = /* @__PURE__ */ new WeakMap(), _2 = /* @__PURE__ */ new WeakMap(), C2 = /* @__PURE__ */ new WeakMap(), a0 = /* @__PURE__ */ new WeakMap(), S2 = /* @__PURE__ */ new WeakMap(), l0 = /* @__PURE__ */ new WeakMap(), I2 = /* @__PURE__ */ new WeakMap(), Tl = /* @__PURE__ */ new WeakMap(), Ru2 = /* @__PURE__ */ new WeakMap(), M2 = /* @__PURE__ */ new WeakMap(), $c2 = /* @__PURE__ */ new WeakMap(), Lm2 = /* @__PURE__ */ new WeakMap(), wl = /* @__PURE__ */ new WeakMap(), u0 = /* @__PURE__ */ new WeakMap(), H$3(yT, "BlueDot");
var Am = yT, gZ = { hidden: { actions: { enable: "hidden", error: "hidden", "position-update": "active", disable: "disabled", timeout: "hidden" } }, active: { actions: { enable: "active", disable: "disabled", "position-update": "active", error: "inactive", timeout: "inactive" } }, inactive: { actions: { enable: "inactive", disable: "disabled", "position-update": "active", error: "inactive", timeout: "inactive" } }, disabled: { actions: { enable: "hidden", disable: "disabled" } } }, yZ = Q.object({ coords: Q.object({ latitude: Q.number(), longitude: Q.number(), accuracy: Q.number(), altitude: Q.number().optional().nullable(), altitudeAccuracy: Q.number().optional().nullable(), heading: Q.number().optional().nullable(), speed: Q.number().optional().nullable(), floorLevel: Q.number().optional().nullable() }), timestamp: Q.number() }), vZ = Q.object({ latitude: Q.number(), longitude: Q.number(), floor: Q.custom().optional(), accuracy: Q.number().optional(), heading: Q.number().optional().nullable() });
a();
var Fu2, p0, vT = class vT2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, Fu2, /* @__PURE__ */ new Map());
    Q$3(this, p0);
    R$1(this, p0, t);
  }
  get currentMap() {
    return P(this, p0).call(this);
  }
  getById(t) {
    return P(this, Fu2).get(t);
  }
  add(t, e, n4) {
    let i = this.currentMap;
    if (!i) throw new Error("currentMap should exist");
    let a4 = i.Shapes.add(t, e || {}, { floorId: n4 == null ? void 0 : n4.id }), u5 = new Tu(a4);
    return P(this, Fu2).set(u5.id, u5), u5;
  }
  remove(t) {
    var n4;
    P(this, Fu2).get(t.id) && ((n4 = this.currentMap) == null || n4.Shapes.remove(t), P(this, Fu2).delete(t.id.toString()));
  }
  removeAll() {
    let t = [];
    return P(this, Fu2).forEach((e) => {
      this.remove(e), t.push(e.id), P(this, Fu2).delete(e.id.toString());
    }), t;
  }
};
Fu2 = /* @__PURE__ */ new WeakMap(), p0 = /* @__PURE__ */ new WeakMap(), H$3(vT, "Shapes");
var c0 = vT;
a();
var f0, bT = class bT2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, f0);
    R$1(this, f0, t);
  }
  get currentMap() {
    return P(this, f0).call(this);
  }
  setFromStyleCollection(t) {
    var e, n4, i, a4;
    for (let u5 in t) for (let h of ((e = this.currentMap) == null ? void 0 : e.floors) || []) {
      if (t[u5] == null || !h.layers.has(Gn2)) continue;
      let d = h.layers.get(Gn2);
      if (d != null && d.layers.has(u5) && "color" in t[u5]) {
        let x2 = d.layers.get(u5);
        x2 && ((n4 = this.currentMap) == null || n4.renderer.setState(x2, { color: t[u5].color }));
      }
      if (d && u5 === yc && !(il2 in t)) {
        let x2 = d.layers.get(il2);
        x2 && "color" in t[u5] && ((i = this.currentMap) == null || i.renderer.setState(x2, { color: t[u5].color }));
      }
      if (!h.layers.has(Wp)) continue;
      let m5 = h.layers.get(Wp), v3 = h.facadesByStyleId.get(u5);
      if (v3 && v3.length > 0) for (let x2 of v3) {
        let S4 = m5.layers.get("".concat(x2, "-").concat(u5));
        S4 && "color" in t[u5] && ((a4 = this.currentMap) == null || a4.renderer.setState(S4, { color: t[u5].color }));
      }
    }
  }
};
f0 = /* @__PURE__ */ new WeakMap(), H$3(bT, "Style");
var h0 = bT;
a();
var xT = { opacity: 1 }, lo, d0, m0, Jc2, Bu2, df2, _T, uL, CT = class CT2 {
  constructor(t, e) {
    Q$3(this, df2);
    Q$3(this, lo);
    Q$3(this, d0, []);
    Q$3(this, m0, { opacity: "initial" });
    Q$3(this, Jc2, { opacity: /* @__PURE__ */ new Map() });
    Q$3(this, Bu2, /* @__PURE__ */ new Set());
    R$1(this, lo, t), R$1(this, d0, e || []);
    let n4 = P(this, lo).map;
    n4 && n4.on("idle", () => {
      P(this, Jc2).opacity.size || S$1(this, df2, _T).call(this, n4);
    });
  }
  setStyle(t) {
    var e, n4;
    if (P(this, lo).map) {
      (e = P(this, lo).map) == null || e.setStyle(t), P(this, Bu2).size && (P(this, Bu2).clear(), this.hide()), S$1(this, df2, uL).call(this), S$1(this, df2, _T).call(this, P(this, lo).map), this.setOpacity(P(this, m0).opacity), (n4 = P(this, lo).map) == null || n4.moveLayer(pt);
      for (let [i, a4, u5] of P(this, d0) || []) P(this, lo).hideOutdoorLayersIntersectingPolygons(i, a4, u5);
    }
  }
  get map() {
    return P(this, lo).map;
  }
  get enabled() {
    return !!P(this, lo).map;
  }
  get visible() {
    return P(this, Bu2).size === 0;
  }
  show() {
    let t = P(this, lo).map;
    if (!t) return;
    let e = t.getStyle().layers;
    e && (e.forEach((n4) => {
      P(this, Bu2).has(n4.id) && t.setLayoutProperty(n4.id, "visibility", "visible");
    }), P(this, Bu2).clear());
  }
  hide(t = []) {
    let e = P(this, lo).map;
    if (!e) return;
    let n4 = e.getStyle().layers;
    n4 && n4.forEach((i) => {
      let a4 = e.getLayoutProperty(i.id, "visibility");
      !t.includes(i.id) && a4 !== "none" && (e.setLayoutProperty(i.id, "visibility", "none"), P(this, Bu2).add(i.id));
    });
  }
  setOpacity(t, e = []) {
    var a4, u5;
    let n4 = P(this, lo).map;
    if (!n4) return;
    let i = (u5 = (a4 = P(this, lo).map) == null ? void 0 : a4.getStyle()) == null ? void 0 : u5.layers;
    i && n4.once("idle", () => {
      i.forEach((h) => {
        let d = n4.getLayoutProperty(h.id, "visibility");
        if (!e.includes(h.id) && d !== "none") try {
          let m5 = P(this, Jc2).opacity.get(h.id);
          m5 !== void 0 && (h.id === "background" || (h.type === "symbol" ? (n4.setPaintProperty(h.id, "icon-opacity", t === "initial" ? m5[0] : t), n4.setPaintProperty(h.id, "text-opacity", t === "initial" ? m5[1] : t)) : n4.setPaintProperty(h.id, "".concat(h.type, "-opacity"), t === "initial" ? m5[0] : t)), P(this, m0).opacity = t);
        } catch (m5) {
          B.warn("Error setting opacity:", m5);
        }
      });
    });
  }
};
lo = /* @__PURE__ */ new WeakMap(), d0 = /* @__PURE__ */ new WeakMap(), m0 = /* @__PURE__ */ new WeakMap(), Jc2 = /* @__PURE__ */ new WeakMap(), Bu2 = /* @__PURE__ */ new WeakMap(), df2 = /* @__PURE__ */ new WeakSet(), _T = H$3(function(t) {
  let e = t.getStyle().layers;
  e && e.forEach((n4) => {
    var a4, u5, h;
    t.getLayoutProperty(n4.id, "visibility") !== "none" && (n4.id === "background" || (n4.type === "symbol" ? P(this, Jc2).opacity.set(n4.id, [(a4 = t.getPaintProperty(n4.id, "icon-opacity")) != null ? a4 : xT.opacity, (u5 = t.getPaintProperty(n4.id, "text-opacity")) != null ? u5 : xT.opacity]) : P(this, Jc2).opacity.set(n4.id, [(h = t.getPaintProperty(n4.id, "".concat(n4.type, "-opacity"))) != null ? h : xT.opacity, void 0])));
  });
}, "#setInitialStyle"), uL = H$3(function() {
  Object.values(P(this, Jc2)).forEach((t) => t.clear());
}, "#clearInitialStyle"), H$3(CT, "Outdoor");
var Nm = CT;
a();
function cL() {
  Jb(false);
}
H$3(cL, "disableText3DWorker");
var Gu, Vu2, Kc2, ST = class ST2 {
  constructor({ currentMapGetter: t }) {
    Q$3(this, Gu);
    Q$3(this, Vu2, /* @__PURE__ */ new Map());
    Q$3(this, Kc2, /* @__PURE__ */ new Map());
    R$1(this, Gu, t);
  }
  labelAll(t = {}) {
    var i, a4;
    let e = [], n4 = /* @__PURE__ */ new Set();
    return (a4 = (i = P(this, Gu).call(this)) == null ? void 0 : i.Text3D.labelAll(t)) == null || a4.forEach(({ textInfo: u5, target: h }) => {
      let d = u5.id.toString(), m5 = P(this, Kc2).get(d);
      if (m5) {
        n4.has(d) || e.push(m5.text3DView), n4.add(d);
        return;
      }
      n4.add(d);
      let v3 = new Uc2(d, h);
      P(this, Vu2).set(v3.id, { targetId: h.id, text3d: d, text3DView: v3 }), P(this, Kc2).set(d, { text3DView: v3 }), e.push(v3);
    }), e;
  }
  label(t, e, n4 = {}) {
    var a4;
    if (P(this, Gu).call(this)) if (ui.is(t)) {
      let u5 = (a4 = P(this, Gu).call(this)) == null ? void 0 : a4.Text3D.label(t, e, n4);
      if (!u5) return;
      let h = u5.textInfo.id.toString(), d = P(this, Kc2).get(h);
      if (d) return d.text3DView;
      let m5 = new Uc2(h, u5.target);
      return P(this, Vu2).set(m5.id, { targetId: u5.target.id, text3d: h, text3DView: m5 }), P(this, Kc2).set(h, { text3DView: m5 }), m5;
    } else throw new Error("Non-space target is not supported");
  }
  remove(t) {
    var i;
    let e = typeof t == "string" ? t : t.id, n4 = P(this, Vu2).get(e);
    n4 && ((i = P(this, Gu).call(this)) == null || i.Text3D.remove(n4.text3d), P(this, Vu2).delete(e), P(this, Kc2).delete(n4.text3d));
  }
  removeAll() {
    P(this, Vu2).forEach((t) => {
      var e;
      (e = P(this, Gu).call(this)) == null || e.Text3D.remove(t.text3d);
    }), P(this, Vu2).clear();
  }
};
Gu = /* @__PURE__ */ new WeakMap(), Vu2 = /* @__PURE__ */ new WeakMap(), Kc2 = /* @__PURE__ */ new WeakMap(), H$3(ST, "Text3D");
var T2 = ST;
var w2 = 0.05, y0, MT = class MT2 extends Se$1 {
  constructor(e, n4, i) {
    super();
    O(this, "core");
    O(this, "mapObjects", []);
    O(this, "id");
    O(this, "mapDataExternal", {});
    O(this, "mapsByFloorId", {});
    O(this, "mapData");
    O(this, "currentMap");
    O(this, "hiddenOutdoorGeometries", []);
    O(this, "lastFacadeIntersected");
    Q$3(this, y0, false);
    O(this, "mapView");
    O(this, "externalPubSub");
    O(this, "Camera");
    O(this, "Labels");
    O(this, "Text3D");
    O(this, "Markers");
    O(this, "Models");
    O(this, "Paths");
    O(this, "Exporter");
    O(this, "Navigation");
    O(this, "Outdoor");
    O(this, "BlueDot");
    O(this, "Shapes");
    O(this, "Style");
    O(this, "Images");
    O(this, "update", H$3(() => {
      this.core.render();
    }, "update"));
    this.core = e, this.mapView = n4, this.externalPubSub = i, this.Camera = new A1(this), this.id = this.core.addGroupContainer("root").id.toString();
    let a4 = new q1("outdoors-container", void 0, void 0, this);
    this.mapObjects.push(a4), this.currentMap = a4, this.core.on("pre-render", () => {
      i.publish("pre-render");
    }), this.core.on("post-render", () => {
      i.publish("post-render");
    }), this.core.on("resize", () => {
      i.publish("resize");
    }), this.core.on("render-error", ({ error: x2 }) => {
      i.publish("render-error", { error: new Xe(x2 instanceof Error ? x2.message : "Unknown error") });
    });
    let u5 = H$3((x2) => {
      let S4 = this.getMapDataObject(x2);
      switch (S4 == null ? void 0 : S4.__type) {
        case "facade":
          return S4;
        case "floor":
          return S4.floorStack.facade;
        default:
          return null;
      }
    }, "getFacadeFromEntityId");
    this.core.on("geometry-in-focus", (x2) => {
      let S4 = /* @__PURE__ */ new Set();
      for (let I3 of x2) {
        let w3 = u5(I3);
        w3 && S4.add(w3);
      }
      i.publish("facades-in-view-change", { facades: Array.from(S4) });
    }), this.core.getSystems().renderSystem.on("camera-state-change", () => {
      i.publish("state-change-internal", { Camera: this.getCameraState() });
    });
    let h = new P1(this.Camera);
    this.core.on("camera-change", () => {
      i.publish("camera-change", h);
    });
    let d = H$3((x2) => (S4) => {
      let I3 = [], w3 = [], E4 = [], T3 = [];
      S4.labels.forEach((J4) => {
        let ot2 = this.Labels.getById(J4.toString());
        ot2 && I3.push(ot2.label);
      }), S4.markers.forEach((J4) => {
        let ot2 = this.Markers.getById(J4.toString()) || this.Navigation.getMarkerById(J4.toString());
        ot2 && w3.push(ot2.marker);
      }), S4.models.forEach((J4) => {
        let ot2 = this.Models.getById(J4.toString());
        ot2 && E4.push(ot2.model);
      }), S4.paths.forEach((J4) => {
        let ot2 = this.Paths.getById(J4.toString()) || this.Navigation.getPathById(J4.toString());
        ot2 && T3.push(ot2.path);
      });
      let D4 = S4.geometry.includes(r0), A3 = S4.geometry.filter((J4) => J4 !== r0), L3;
      A3.length > 0 && (L3 = A3.map((J4) => {
        var ot2;
        return (ot2 = this.getMapDataInternal()) == null ? void 0 : ot2.getById("space", J4);
      }).filter(Boolean)[0], L3 || (L3 = A3.map((J4) => {
        var ot2;
        return (ot2 = this.getMapDataInternal()) == null ? void 0 : ot2.getById("object", J4);
      }).filter(Boolean)[0]), L3 || (L3 = A3.map((J4) => this.Shapes.getById(J4)).filter(Boolean)[0]));
      let B3 = S4.containers.reduce((J4, ot2) => {
        var H5;
        let K4 = (H5 = this.getMapDataInternal()) == null ? void 0 : H5.getById("floor", ot2);
        return K4 && Io.is(K4) && J4.push(K4), J4;
      }, []), j3, W4 = 0;
      if (B3.length > 0) {
        j3 = B3[0].id;
        let J4 = this.core.getState(j3);
        W4 = S4.coordinate[2] ? S4.coordinate[2] - J4.altitude : W4;
      }
      let $5;
      this.lastFacadeIntersected && this.lastFacadeIntersected.spaces.forEach((J4) => {
        this.core.setState(J4.id, { hovered: false });
      }), L3 && ui.is(L3) && ($5 = A3.map((J4) => {
        var ot2;
        return (ot2 = this.getMapDataInternal()) == null ? void 0 : ot2.facadesBySpaceId[J4];
      }).filter(Boolean)[0], $5 && $5.spaces.forEach((J4) => {
        this.core.setState(J4.id, { hovered: true });
      })), this.lastFacadeIntersected = $5;
      let F3 = { coordinate: new ve2({ latitude: S4.coordinate[1], longitude: S4.coordinate[0], floorId: j3, verticalOffset: W4 }), spaces: L3 && ui.is(L3) ? [L3] : [], objects: L3 && Vo.is(L3) ? [L3] : [], shapes: L3 && Tu.is(L3) ? [L3] : [], markers: w3, labels: I3, models: E4, paths: T3, blueDot: D4, floors: B3, facades: $5 ? [$5] : [] };
      "pointerEvent" in S4 && (F3.pointerEvent = S4.pointerEvent), i.publish(x2, F3);
    }, "createHandler");
    this.core.on("hover", d("hover")), this.core.on("click", d("click")), this.core.on("user-interaction-start", () => {
      i.publish("user-interaction-start");
    }), this.core.on("user-interaction-end", () => {
      i.publish("user-interaction-end");
    });
    let m5 = { currentMapGetter: H$3(() => this.currentMap, "currentMapGetter") };
    this.Markers = new W1(m5), this.Models = new K1(m5), this.Labels = new R1(m5), this.Text3D = new T2(m5), this.Exporter = new k1(m5), this.Paths = new t0(m5), this.Navigation = new D1(this.core, this, m5.currentMapGetter), this.on("navigation-state-change", (x2) => {
      this.externalPubSub.publish("state-change-internal", { Navigation: x2 });
    }), this.on("navigation-connection-click", (x2) => {
      this.externalPubSub.publish("navigation-connection-click", x2);
    }), this.on("navigation-active-path-change", (x2) => {
      this.externalPubSub.publish("navigation-active-path-change", x2);
    }), this.BlueDot = new Am(this.core, this), this.on("blue-dot-position-update", (x2) => {
      this._publishBlueDotState({ coordinate: this.BlueDot.coordinate, heading: this.BlueDot.heading, accuracy: this.BlueDot.accuracy, floor: this.BlueDot.floor }), i.publish("blue-dot-position-update", x2);
    }), this.on("blue-dot-state-change", (x2) => {
      this._publishBlueDotState({ state: this.BlueDot.state }), i.publish("blue-dot-state-change", x2);
    }), this.on("blue-dot-position-error", (x2) => {
      i.publish("blue-dot-position-error", x2);
    }), this.on("blue-dot-follow-change", (x2) => {
      this._publishBlueDotState({ following: this.BlueDot.following }), i.publish("blue-dot-follow-change", x2);
    }), this.Outdoor = new Nm(this.core, this.hiddenOutdoorGeometries), this.Outdoor.enabled && (this.core.on("outdoor-view-loaded", () => {
      i.publish("outdoor-view-loaded");
    }), this.core.on("outdoor-style-loaded", () => {
      i.publish("outdoor-style-loaded");
    })), this.Images = new $1(m5), this.Shapes = new c0(m5), this.Style = new h0(m5);
    let v3 = new g2(n4, this.mapDataExternal);
    this.auto = v3.auto;
  }
  get manualFloorVisibility() {
    return P(this, y0);
  }
  set manualFloorVisibility(e) {
    R$1(this, y0, e), this.externalPubSub.publish("state-change-internal", { manualFloorVisibility: e });
  }
  get StackedMaps() {
    return this.currentMap.StackedMaps;
  }
  preloadFloors(e) {
    e.forEach((n4) => {
      n4 instanceof Io && this.core.setState(n4.id, { preloadGeometry: true });
    });
  }
  updateState(e, n4) {
    if (e === "interior-walls") {
      this.currentMap.floors.forEach((u5) => {
        let h = u5.layers.get(Gn2);
        if (h) {
          let d = h.layers.get(yc);
          d && this.core.hasState(d) && this.core.setState(d, IT(n4, this.core.getState(d)));
        }
      });
      return;
    } else if (e === "exterior-walls") {
      this.currentMap.floors.forEach((u5) => {
        let h = u5.layers.get(Gn2);
        if (h) {
          let d = h.layers.get(il2);
          d && this.core.hasState(d) && this.core.setState(d, IT(n4, this.core.getState(d)));
        }
      });
      return;
    } else if (e === "interior-doors") {
      this.currentMap.floors.forEach((u5) => {
        let h = u5.layers.get(Gn2);
        if (h) {
          let d = h.layers.get(Sd2);
          d && this.core.hasState(d) && this.core.setState(d, P2(n4, this.core.getState(d)));
        }
      });
      return;
    } else if (e === "exterior-doors") {
      this.currentMap.floors.forEach((u5) => {
        let h = u5.layers.get(Gn2);
        if (h) {
          let d = h.layers.get(Id2);
          d && this.core.hasState(d) && this.core.setState(d, P2(n4, this.core.getState(d)));
        }
      });
      return;
    }
    let i = typeof e == "string" ? this.getMapDataObject(e) : e;
    if (i) {
      if (i.__type !== "Path" && !this.core.hasState(i.id)) {
        B.warn('Failed to update state for "'.concat(i.id, '". No ').concat(i.__type, " found with that ID."));
        return;
      }
      if (Vc2.is(i)) return this.core.setState(i.id, pL(G$1(F$1({}, n4), { type: "label" }), this.core.getState(i.id)));
      if (Mu.is(i)) return this.core.setState(i.id, hL(G$1(F$1({}, n4), { type: "marker" }), this.core.getState(i.id)));
      if (ui.is(i) || Vo.is(i)) {
        let u5 = this.core.getState(i.id);
        if (u5 != null) {
          let h = u5.parent && u5.parent.type === "geometry-group" ? this.core.getState(u5.parent) : void 0;
          this.core.setState(i.id, fL(G$1(F$1({}, n4), { type: "geometry" }), u5, h));
        }
      }
      if (ca.is(i) && this.core.setState(i.id, P2(G$1(F$1({}, n4), { type: "doors" }), this.core.getState(i.id))), Tu.is(i) && this.core.setState(i.id, Yt(n4, ["altitude", "color", "opacity", "height", "visible", "interactive"])), rf2.is(i)) {
        let a4 = n4, { position: u5, scale: h } = a4, m5 = J$1(a4, ["position", "scale"]);
        u5 && (m5.position = [u5.longitude, u5.latitude, u5.verticalOffset]), h != null && (Array.isArray(h) ? m5.scale = h : m5.scale = [h, h, h]), u5 && i.updateTarget(u5), this.core.setState(i.id, m5);
      }
      if (Io.is(i)) {
        let u5 = this.currentMap.floorsById.get(i.id);
        if (u5 == null) return;
        this.core.setState(i.id, Yt(n4, ["visible", "altitude"]));
        let h = u5.layers.get(Gn2);
        h != null && "geometry" in n4 && this.core.setState(h.containerId, Yt(n4.geometry, ["opacity", "visible"]));
        let d = u5.layers.get(iu2);
        d != null && "labels" in n4 && "enabled" in n4.labels && typeof n4.labels.enabled == "boolean" && d.setVisible(n4.labels.enabled);
        let m5 = u5.layers.get(ol);
        m5 != null && "markers" in n4 && "enabled" in n4.markers && typeof n4.markers.enabled == "boolean" && m5.setVisible(n4.markers.enabled);
        let v3 = u5.layers.get(qg);
        v3 != null && "footprint" in n4 && this.core.setState(v3.containerId, Yt(n4.footprint, ["visible", "height", "opacity", "side", "color", "altitude"]));
        let x2 = u5.layers.get(qp);
        x2 != null && "occlusion" in n4 && "enabled" in n4.occlusion && typeof n4.occlusion.enabled == "boolean" && x2.setVisible(n4.occlusion.enabled);
        let S4 = u5.layers.get(sl);
        S4 != null && "images" in n4 && "visible" in n4.images && typeof n4.images.visible == "boolean" && S4.setVisible(n4.images.visible);
      }
      if (Ps.is(i)) {
        let u5 = this.core.getState(i.id);
        for (let h of u5.children) h.type === "group-container" && this.core.setState(h.id, Yt(n4, ["opacity", "visible"]));
      }
      if (Uc2.is(i) && this.core.setState(i.id, Yt(n4, ex2)), ba2.is(i)) for (let u5 of i.segments) this.core.setState(u5.id, Yt(n4, bZ));
      xm.is(i) && this.core.setState(i.id, Yt(n4, xZ));
    }
  }
  getMapDataObject(e) {
    var n4;
    return (n4 = this.getMapDataInternal()) == null ? void 0 : n4.getMapDataById(e);
  }
  getMapDataInternal() {
    if (this.mapData) return py(this.mapData);
  }
  getMapData() {
    return this.mapData;
  }
  addMap(e, n4) {
    return new Promise((i) => {
      var S4, I3, w3, E4;
      let a4;
      try {
        a4 = py(e);
      } catch (T3) {
        B.error("Error adding map", T3), i(e);
        return;
      }
      this.mapDataExternal[e.mapName] = e, this.mapData = e;
      let { mvf: u5 } = a4, h = u5["manifest.geojson"].features[0].geometry.coordinates;
      this.core.mode !== "outdoors-overlay" && this.Camera.set({ center: new ve2(h[1], h[0]) });
      let d = u5["manifest.geojson"].features[0].properties.name, m5 = new q1("mapObject-".concat(d), a4, n4, this);
      this.currentMap = m5, this.currentMap.setFloor(this.currentMap.startingFloorId);
      let v3 = this.core.getBoundingArea(m5.currentFloor.id);
      v3 == null && B.error("Could not determine bounding box for map:", m5.currentFloor.id);
      let x2 = (I3 = (S4 = n4 == null ? void 0 : n4.outdoorView) == null ? void 0 : S4.layersHiddenByGeometry) != null ? I3 : [];
      if (x2.length > 0) {
        let T3, D4 = [];
        for (let A3 of m5.floorStacksById.values()) if (A3.defaultFloor.footprint && A3.defaultFloor.footprint.geometry != null && ((w3 = A3.defaultFloor.footprint.geometry) == null ? void 0 : w3.coordinates.length) > 0) {
          let L3 = A3.defaultFloor.footprint, B3 = b2(L3);
          T3 == null ? T3 = B3 : mL(T3, B3), D4.push(L3);
        }
        D4.length > 0 && T3 != null && (this.core.hideOutdoorLayersIntersectingPolygons(T3, D4, x2), this.hiddenOutdoorGeometries.push([T3, D4, x2]));
      }
      if (this.mapObjects.push(m5), a4.getMVFFeatureByType("floor").forEach((T3) => {
        this.mapsByFloorId[T3.id] = m5;
      }), m5.StackedMaps.on("stacked-maps-state-change", ({ state: T3 }) => {
        this.externalPubSub.publish("stacked-maps-state-change", { state: T3 });
      }), m5.on("floor-change-start", (T3) => {
        var D4, A3, L3, B3;
        this.externalPubSub.publish("floor-change-start", { reason: T3.reason, floor: (A3 = (D4 = this.getMapDataInternal()) == null ? void 0 : D4.getById("floor", T3.floorId)) != null ? A3 : this.currentFloor, previousFloor: (B3 = (L3 = this.getMapDataInternal()) == null ? void 0 : L3.getById("floor", T3.previousFloorId)) != null ? B3 : this.currentFloor });
      }), m5.on("floor-change", (T3) => {
        var D4, A3;
        this.externalPubSub.publish("floor-change", { reason: T3.reason, floor: this.currentFloor, previousFloor: (A3 = (D4 = this.getMapDataInternal()) == null ? void 0 : D4.getById("floor", T3.previousFloorId)) != null ? A3 : this.currentFloor }), this.externalPubSub.publish("state-change-internal", { currentFloor: this.currentFloor, currentFloorStack: this.currentFloorStack });
      }), (n4 == null ? void 0 : n4.zoomLevel) != null) this.core.camera.setZoomLevel(n4.zoomLevel), i(e);
      else if (this.core.mode !== "outdoors-overlay" && v3) {
        let T3 = (E4 = n4 == null ? void 0 : n4.screenOffsets) != null ? E4 : { top: w2 * this.core.canvasHeight, left: w2 * this.core.canvasWidth, right: w2 * this.core.canvasWidth, bottom: w2 * this.core.canvasHeight };
        this.core.camera.focusOn(v3, { duration: y7, padding: T3 }).then(() => {
          this.Camera.setElevation(this.currentFloor.elevation), i(e);
        });
      } else i(e);
    });
  }
  setFloor(e, n4) {
    return this.currentMap.setFloor(Ug2(e), n4);
  }
  setFloorStack(e, n4) {
    return this.currentMap.setFloorStack(Ug2(e), n4);
  }
  updateWatermark(e) {
    this.core.updateWatermark(e);
  }
  get currentFloorStack() {
    var i;
    let e = this.currentMap.currentFloorStack.id;
    if (!e) throw new Y("Missing currentFloorStack.");
    let n4 = (i = this.mapData) == null ? void 0 : i.getById("floor-stack", e);
    if (!n4) throw new Y("FloorStack was not found in map data.");
    return n4;
  }
  get currentFloor() {
    var i;
    let e = this.currentMap.currentFloor.id;
    if (!e) throw new Y("Missing currentFloor object from GeoJsonApi");
    let n4 = (i = this.mapData) == null ? void 0 : i.getById("floor", e);
    if (!n4) throw new Y("Missing currentFloor");
    return n4;
  }
  getState(e) {
    var a4, u5, h, d, m5, v3, x2, S4, I3, w3, E4, T3, D4, A3, L3, B$12, j3, W4, $5, F3, J4, ot2;
    typeof e == "object" && ba2.is(e) && B.warn("Cannot get state of a Path directly. Use getState() on individual segments within Path.segments[] instead.");
    let n4 = dL(e, this), i = this.core.getState(n4);
    if (i) if (["interior-walls", "exterior-walls"].includes(e)) {
      let { color: K4, topColor: H5, texture: _t2, topTexture: ct2, visible: ft2, height: mt2, opacity: St2 } = i;
      return { type: "walls", visible: ft2, color: K4, topColor: H5, texture: _t2 ? { url: _t2 } : void 0, topTexture: ct2 ? { url: ct2 } : void 0, height: mt2, opacity: St2 };
    } else if (["interior-doors", "exterior-doors"].includes(e)) {
      let { color: K4, topColor: H5, texture: _t2, topTexture: ct2, visible: ft2, opacity: mt2 } = i;
      return { type: "doors", visible: ft2, color: K4, topColor: H5, opacity: mt2, texture: _t2 ? { url: _t2 } : void 0, topTexture: ct2 ? { url: ct2 } : void 0 };
    } else if (i.type === "geometry") {
      let K4;
      "parent" in i && i.parent && i.parent.type === "geometry-group" && (K4 = this.core.getState(i.parent));
      let H5 = K4 != null && K4.altitude ? i.altitude + K4.altitude : i.altitude;
      return { type: "geometry", interactive: i.interactive, hoverColor: i.hoverColor, color: i.color, visible: i.visible, opacity: i.opacity, height: i.height, texture: i.texture ? { url: i.texture } : void 0, topTexture: i.topTexture ? { url: i.topTexture } : void 0, flipImageToFaceCamera: i.flipImageToFaceCamera, topColor: i.topColor, altitude: H5 };
    } else {
      if (i.type === "label" && i.options.appearance && i.options.rank !== void 0 && i.options.interactive !== void 0) return { type: "label", text: i.text, appearance: i.options.appearance, rank: i.options.rank, enabled: i.enabled, interactive: i.options.interactive };
      if (i.type === "marker" && ((a4 = i.options) == null ? void 0 : a4.rank) !== void 0 && i.options.interactive !== void 0) {
        let K4 = typeof i.parent == "object" ? i.parent.id : i.parent, H5 = this.Markers.getById(i.id.toString()), _t2 = H5 != null && H5.marker.target ? H5 == null ? void 0 : H5.marker.target.anchorTarget : void 0;
        return _t2 == null && (_t2 = new ve2(i.position[1], i.position[0], K4.toString())), { type: "marker", rank: i.options.rank, interactive: i.options.interactive, enabled: i.enabled, element: i.element, anchor: i.anchor, zIndex: i.options.zIndex, dynamicResize: i.dynamicResize, lowPriorityPin: i.options.lowPriorityPin, contentHTML: i.contentHTML };
      } else if (i.type === "model") {
        let K4 = i != null && typeof i.parent == "object" ? i.parent.id.toString() : (u5 = i.parent) == null ? void 0 : u5.toString();
        return delete i.parent, G$1(F$1({}, i), { position: new ve2({ latitude: i.position[1], longitude: i.position[0], verticalOffset: i.position[2], floorId: K4 }), type: "model" });
      } else {
        if (i.type === "image") return { type: "image" };
        if (i.type === "text3d") return i;
        if (i.type === "geometry-group" && e && typeof e != "string" && Tu.is(e)) {
          let [K4] = i.children;
          if (K4.type !== "geometry") throw new Error("expect shape first child to be geometry");
          return { type: "Shape", altitude: (h = i.altitude) != null ? h : 0, visible: i.visible, color: i.color, height: K4.height, opacity: i.opacity, interactive: i.interactive };
        } else {
          if (i.type === "path") return { type: "path", color: i.color, visible: i.visible, nearRadius: i.nearRadius, farRadius: i.farRadius, altitude: i.altitude, completeFraction: i.completeFraction };
          if (i.type === "group-container" && typeof e != "string" && Io.is(e)) {
            let K4 = (d = this.currentMap.floorsById.get(e.id)) == null ? void 0 : d.layers.get(Gn2), H5 = K4 ? this.core.getState(K4.containerId) : void 0, _t2 = (m5 = this.currentMap.floorsById.get(e.id)) == null ? void 0 : m5.layers.get(iu2), ct2 = (v3 = this.currentMap.floorsById.get(e.id)) == null ? void 0 : v3.layers.get(ol), ft2 = (x2 = this.currentMap.floorsById.get(e.id)) == null ? void 0 : x2.layers.get(qg), mt2 = ft2 ? this.core.getState(ft2.containerId) : void 0, St2 = (S4 = this.currentMap.floorsById.get(e.id)) == null ? void 0 : S4.layers.get(qp), dt2 = St2 ? this.core.getState(St2.containerId) : void 0, xt2 = (I3 = this.currentMap.floorsById.get(e.id)) == null ? void 0 : I3.layers.get(sl), q4 = xt2 ? this.core.getState(xt2.containerId) : void 0;
            return { type: "floor", geometry: { opacity: (w3 = H5 == null ? void 0 : H5.opacity) != null ? w3 : 0, visible: (E4 = H5 == null ? void 0 : H5.visible) != null ? E4 : true }, labels: { enabled: (T3 = _t2 == null ? void 0 : _t2.visible) != null ? T3 : false }, markers: { enabled: (D4 = ct2 == null ? void 0 : ct2.visible) != null ? D4 : false }, footprint: { altitude: (A3 = mt2 == null ? void 0 : mt2.altitude) != null ? A3 : 0, visible: (L3 = mt2 == null ? void 0 : mt2.visible) != null ? L3 : false, height: (B$12 = mt2 == null ? void 0 : mt2.height) != null ? B$12 : 0, opacity: (j3 = mt2 == null ? void 0 : mt2.opacity) != null ? j3 : 0, side: (W4 = mt2 == null ? void 0 : mt2.side) != null ? W4 : "double", color: ($5 = mt2 == null ? void 0 : mt2.color) != null ? $5 : "white" }, images: { visible: (F3 = q4 == null ? void 0 : q4.visible) != null ? F3 : false }, occlusion: { enabled: (J4 = dt2 == null ? void 0 : dt2.visible) != null ? J4 : false }, visible: i.visible, altitude: (ot2 = i.altitude) != null ? ot2 : 0 };
          } else if (i.type === "group-container" && i.children.length > 0 && typeof e != "string" && Ps.is(e)) {
            let K4 = this.core.getState(i.children[0].id);
            return { type: "facade", opacity: K4.opacity, visible: K4.visible };
          }
        }
      }
    }
  }
  setHoverColor(e) {
    this.core.setState({ hoverColor: e });
  }
  getHoverColor() {
    let e = this.core.getState();
    return (e == null ? void 0 : e.type) === "map-view" ? e.hoverColor : void 0;
  }
  createCoordinateFromScreenCoordinate(e, n4, i) {
    var m5;
    if (i != null) {
      let v3 = this.core.projectScreenXYToCoordinate(e, n4, true);
      return v3 ? new ve2(v3.coordinate[1], v3.coordinate[0], i.id) : void 0;
    }
    let a4 = this.core.projectScreenXYToCoordinate(e, n4);
    if (a4 == null || a4.coordinate == null) return;
    let { coordinate: u5, groupContainers: h } = a4, d = (m5 = h == null ? void 0 : h.find((v3) => {
      let x2 = v3.userData.entityId.toString();
      return x2.includes("f_") || x2.includes("m_");
    })) == null ? void 0 : m5.userData.entityId.toString();
    return new ve2(u5[1], u5[0], d);
  }
  getScreenCoordinateFromCoordinate(e) {
    var i, a4, u5;
    let n4 = 0;
    if (e.floorId != null) {
      let h = (i = this.mapData) == null ? void 0 : i.getById("floor", e.floorId);
      h != null && (n4 = (u5 = (a4 = this.getState(h)) == null ? void 0 : a4.altitude) != null ? u5 : 0);
    }
    return this.core.projectCoordinateToScreenXY([e.longitude, e.latitude, n4]);
  }
  isInView(e) {
    return this.core.isInView(typeof e == "string" ? e : e.id);
  }
  auto() {
    return { labels: this.Labels.all() };
  }
  tween(e) {
    let n4 = new Ho(e);
    return this.core.getExternalTweenGroup().add(n4), this.core.render(), n4;
  }
  removeTween(e) {
    this.core.getExternalTweenGroup().remove(e);
  }
  tweenGroup() {
    return this.core.getExternalTweenGroup();
  }
  get __core() {
    return this.core;
  }
  getCameraState() {
    return this.core.camera.getState();
  }
  getNavigationState() {
    return { isMultiFloor: this.Navigation.isMultiFloor, floorStacks: this.Navigation.floorStacks, floors: this.Navigation.floors, activeDirections: this.Navigation.activeDirections, activePath: this.Navigation.activePath, paths: this.Navigation.paths };
  }
  getAllState() {
    return { currentFloor: this.currentFloor, currentFloorStack: this.currentFloorStack, Camera: this.getCameraState(), Navigation: this.getNavigationState(), manualFloorVisibility: this.manualFloorVisibility };
  }
  publishAllState() {
    this.externalPubSub.publish("state-change-internal", this.getAllState());
  }
  clear() {
    this.Navigation.clear(), this.BlueDot.disable(), this.Shapes.removeAll(), this.Paths.removeAll(), this.Models.removeAll(), this.Markers.removeAll(), this.Images.removeAll(), this.Labels.removeAll();
  }
  destroy() {
    this.clear(), this.core.destroy();
  }
  _publishBlueDotState(e) {
    let n4;
    if (e) n4 = e;
    else {
      let { state: i, following: a4, heading: u5, accuracy: h, coordinate: d, floor: m5 } = this.BlueDot;
      n4 = { state: i, following: a4, heading: u5, accuracy: h, coordinate: d, floor: m5 };
    }
    this.externalPubSub.publish("state-change-internal", { BlueDot: n4 });
  }
  getOptimalVisualDistanceBetweenFloors(e, n4 = false) {
    let i = this.currentMap;
    if (!i) {
      B.error("Cannot compute optimal visual distance between floors. Missing current map.");
      return;
    }
    if (e.length < 2) {
      B.warn("Cannot compute optimal visual distance between floors. Must provide at least 2 floors.");
      return;
    }
    let a4 = i.renderer.getInternalState().geometry3DMap.get(e[0].id), u5 = i.renderer.getInternalState().geometry3DMap.get(e[1].id);
    if (!a4 || !u5) {
      B.warn("Cannot compute optimal visual distance between floors. Floors not found in current map.");
      return;
    }
    if (_r(a4, "group-container"), _r(u5, "group-container"), n4) {
      let d = new Pe$3();
      d.setFromObject(a4);
      let m5 = new Pe$3();
      if (m5.setFromObject(u5), a4.children.forEach((T3) => {
        T3 instanceof ye$1 && T3.userData.debugBox && Jr(T3);
      }), u5.children.forEach((T3) => {
        T3 instanceof ye$1 && T3.userData.debugBox && Jr(T3);
      }), !Pt$1(d) || !Pt$1(m5)) return;
      let v3 = new Xi$2(d.max.x - d.min.x, d.max.y - d.min.y, d.max.z - d.min.z), x2 = new vs$1({ color: 255, transparent: true, opacity: 0.5 }), S4 = new ye$1(v3, x2);
      S4.position.set((d.min.x + d.max.x) / 2, (d.min.y + d.max.y) / 2, (d.min.z + d.max.z) / 2), S4.userData.debugBox = true;
      let I3 = new Xi$2(m5.max.x - m5.min.x, m5.max.y - m5.min.y, m5.max.z - m5.min.z), w3 = new vs$1({ color: "cyan", transparent: true, opacity: 0.5 }), E4 = new ye$1(I3, w3);
      E4.position.set((m5.min.x + m5.max.x) / 2, (m5.min.y + m5.max.y) / 2, (m5.min.z + m5.max.z) / 2), E4.userData.debugBox = true, a4.add(S4), u5.add(E4);
    }
    let h = i.renderer.computeMinZOffsetBetweenContainers(a4, u5);
    if (h !== -1) return h;
  }
};
y0 = /* @__PURE__ */ new WeakMap(), H$3(MT, "GeoJsonApi");
var g0 = MT;
function gL(r5) {
  if (r5 === "") {
    LM(""), DM("");
    return;
  }
  DM("".concat(r5, "/").concat(jo$1)), LM("".concat(r5, "/").concat(Vo$1));
}
H$3(gL, "setWorkersUrl");
var bZ = ["color", "nearRadius", "farRadius", "visible", "completeFraction", "altitude"], xZ = ["color", "altitude"];
a();
var TT = class TT2 {
  constructor(t) {
    O(this, "state");
    O(this, "update");
    this.update = t.Debug.update.bind(t.Debug), this.state = t.Debug.state;
  }
};
H$3(TT, "Debug");
var E2 = TT;
a();
var yL = Pi.object({ environment: Pi.union([Pi.literal("basic"), Pi.literal(false)]).optional(), text3d: Pi.object({ hoverColor: Pi.string().optional() }).optional(), geometry: Pi.object({ hoverColor: Pi.string().optional() }).optional(), backgroundColor: Pi.string().optional(), backgroundAlpha: Pi.number().optional() }).strict();
a();
var wT = N$2(P3(), 1);
var _Z = H$3((r5, t) => {
  let e = {}, n4 = H$3((i, a4, u5) => {
    for (let h in a4) {
      let d = i[h], m5 = a4[h];
      typeof m5 == "object" && !Array.isArray(m5) && m5 !== null && typeof d == "object" && !Array.isArray(d) && d !== null ? (u5[h] = {}, n4(d, m5, u5[h])) : u5[h] = d;
    }
  }, "processObject");
  return n4(r5, t, e), e;
}, "extractProperties"), vL = H$3((r5, t) => {
  let e = _Z(r5, t), n4 = (0, wT.default)({}, e, t), i = (0, wT.default)({}, e), a4 = H$3((u5, h, d, m5 = i) => {
    for (let v3 in h) {
      let x2 = u5[v3], S4 = h[v3];
      if (typeof S4 == "number" && typeof x2 == "number") m5[v3] = x2 + (S4 - x2) * d;
      else if (typeof S4 == "string" && typeof x2 == "string") {
        if (ue(x2) && ue(S4)) {
          let I3 = Xr$1(x2), w3 = Xr$1(S4);
          I3 && w3 ? m5[v3] = Zr([I3[0] + (w3[0] - I3[0]) * d, I3[1] + (w3[1] - I3[1]) * d, I3[2] + (w3[2] - I3[2]) * d]) : B.warn('Color "'.concat(v3, '" could not be animated!'));
        }
      } else typeof S4 == "object" && S4 !== null && typeof x2 == "object" && x2 !== null ? a4(x2, S4, d, m5[v3]) : B.warn('Value "'.concat(v3, '" could not be animated!'));
    }
  }, "interpolate");
  return (u5) => (u5 = Math.min(Math.max(u5, 0), 1), u5 === 0 ? r5 : u5 === 1 ? n4 : (a4(e, t, u5), i));
}, "animationFactory");
var mf2, jt, Pl, PT = class PT2 {
  constructor(t) {
    Q$3(this, mf2);
    Q$3(this, jt);
    Q$3(this, Pl);
    O(this, "Camera");
    O(this, "Labels");
    O(this, "Text3D");
    O(this, "Markers");
    O(this, "Images");
    O(this, "Models");
    O(this, "Paths");
    O(this, "Exporter");
    O(this, "Navigation");
    O(this, "BlueDot");
    O(this, "Style");
    O(this, "Shapes");
    O(this, "Outdoor");
    O(this, "update", H$3(() => {
      P(this, jt).core.render();
    }, "update"));
    O(this, "getDirections", H$3((t5, e4, n4) => {
      var i;
      return (i = P(this, jt).getMapData()) == null ? void 0 : i.getDirections(t5, e4, n4);
    }, "getDirections"));
    O(this, "getDirectionsMultiDestination", H$3((t5, e4, n4) => {
      var i;
      return (i = P(this, jt).getMapData()) == null ? void 0 : i.getDirectionsMultiDestination(t5, e4, n4);
    }, "getDirectionsMultiDestination"));
    O(this, "on", H$3((t5, e4) => {
      P(this, mf2).on(t5, e4);
    }, "on"));
    O(this, "off", H$3((t5, e4) => {
      P(this, mf2).off(t5, e4);
    }, "off"));
    O(this, "Debug");
    R$1(this, mf2, new Se$1()), R$1(this, Pl, t);
    let e = new g0(t, this, P(this, mf2));
    R$1(this, jt, e), this.Camera = P(this, jt).Camera, this.Markers = P(this, jt).Markers, this.Models = P(this, jt).Models, this.Labels = P(this, jt).Labels, this.Text3D = P(this, jt).Text3D, this.Exporter = P(this, jt).Exporter, this.Paths = P(this, jt).Paths, this.Navigation = P(this, jt).Navigation, this.BlueDot = P(this, jt).BlueDot, this.Shapes = P(this, jt).Shapes, this.Style = P(this, jt).Style, this.auto = P(this, jt).auto, this.Outdoor = P(this, jt).Outdoor, this.Images = P(this, jt).Images, P(this, Pl).container.dataset.version = p$1.env.npm_package_version, this.Debug = new E2(P(this, jt).core);
  }
  get StackedMaps() {
    return P(this, jt).currentMap.StackedMaps;
  }
  updateState(t, e) {
    return P(this, jt).updateState(t, e);
  }
  animateState(t, e, n4) {
    var d;
    let i = P(this, jt).getState(t);
    if (i == null) return B.warn("Cannot animate state of ".concat(t, ".")), new Promise((v3) => v3({ result: "completed" }));
    let a4 = vL(i, e), u5 = P(this, jt).tween({ percent: 0 }).to({ percent: 1 }, (d = n4 == null ? void 0 : n4.duration) != null ? d : 1e3).onUpdate(({ percent: m5 }) => {
      P(this, jt).updateState(t, a4(m5));
    });
    n4 != null && n4.easing && n4.easing in xu2 && u5.easing(xu2[n4.easing]);
    let h = new Promise((m5) => {
      u5.onComplete(() => {
        P(this, jt).removeTween(u5), m5({ result: "completed" });
      }).onStop(() => {
        P(this, jt).removeTween(u5), m5({ result: "cancelled" });
      }), u5.start();
    });
    return h.cancel = () => {
      u5.stop(), P(this, jt).updateState(t, a4(0));
    }, h;
  }
  updateGlobalState(t) {
    var e, n4, i, a4;
    try {
      yL.parse(t);
    } catch (u5) {
      B.error("updateGlobalState", u5);
      return;
    }
    if (typeof t == "object") {
      let u5 = {};
      if ((e = t.text3d) != null && e.hoverColor && (u5.text3dHoverColor = t.text3d.hoverColor), (n4 = t.geometry) != null && n4.hoverColor && (u5.hoverColor = t.geometry.hoverColor), t.backgroundColor || t.backgroundAlpha !== void 0) {
        let h = (i = t.backgroundColor) != null ? i : P(this, jt).core.backgroundColor, d = (a4 = t.backgroundAlpha) != null ? a4 : P(this, jt).core.backgroundAlpha;
        P(this, jt).core.setBackgroundColor(h, d);
      }
      t.environment != null && P(this, jt).core.setEnvironment(t.environment), P(this, jt).core.setState(u5);
    }
  }
  get options() {
    return _7(P(this, jt).currentMap.options);
  }
  getGlobalState() {
    let t = P(this, jt).core.getState();
    return { backgroundColor: P(this, jt).core.backgroundColor, backgroundAlpha: P(this, jt).core.backgroundAlpha, environment: P(this, jt).core.getEnvironment(), geometry: { hoverColor: t.hoverColor }, text3d: { hoverColor: t.text3dHoverColor } };
  }
  getMapData() {
    if (P(this, jt).mapData == null) throw new Y("MapData not found.");
    return P(this, jt).mapData;
  }
  getDimensions() {
    return { width: P(this, Pl).canvasWidth, height: P(this, Pl).canvasHeight };
  }
  expand(t) {
    var e;
    return (e = P(this, jt).currentMap) == null ? void 0 : e.StackedMaps.expand(t);
  }
  collapse(t) {
    var e;
    return (e = P(this, jt).currentMap) == null ? void 0 : e.StackedMaps.collapse(t);
  }
  addMap(t, e) {
    return P(this, jt).addMap(t, e);
  }
  setFloor(t, e) {
    return P(this, jt).setFloor(t, e == null ? void 0 : e.context);
  }
  setFloorStack(t, e) {
    return P(this, jt).setFloorStack(t, e == null ? void 0 : e.context);
  }
  preloadFloors(t) {
    P(this, jt).preloadFloors(t);
  }
  tween(t) {
    return P(this, jt).tween(t);
  }
  removeTween(t) {
    P(this, jt).removeTween(t);
  }
  get tweenGroup() {
    return P(this, jt).tweenGroup();
  }
  get currentFloorStack() {
    return P(this, jt).currentFloorStack;
  }
  get currentFloor() {
    return P(this, jt).currentFloor;
  }
  updateWatermark(t) {
    P(this, jt).updateWatermark(t);
  }
  getState(t) {
    return P(this, jt).getState(t);
  }
  setHoverColor(t) {
    P(this, jt).setHoverColor(t);
  }
  getHoverColor() {
    return P(this, jt).getHoverColor();
  }
  convertAltitudeToMercatorZoomLevel(t) {
    return P(this, jt).core.getSystems().cameraSystem.convertAltitudeToZoomLevel(t);
  }
  convertMercatorZoomLevelToAltitude(t) {
    return P(this, jt).core.getSystems().cameraSystem.convertZoomLevelToAltitude(t);
  }
  isInView(t) {
    return P(this, jt).isInView(t);
  }
  getDistance(t, e) {
    var n4;
    return (n4 = P(this, jt).getMapData()) == null ? void 0 : n4.getDistance(t, e);
  }
  createCoordinate(t, e, n4) {
    return typeof t == "object" ? new ve2(t) : new ve2(t, e, n4 == null ? void 0 : n4.id);
  }
  createCoordinateFromScreenCoordinate(t, e, n4) {
    return P(this, jt).createCoordinateFromScreenCoordinate(t, e, n4);
  }
  getScreenCoordinateFromCoordinate(t) {
    return P(this, jt).getScreenCoordinateFromCoordinate(t);
  }
  auto() {
    return { labels: this.Labels.all() };
  }
  get __core() {
    if (p$1.env.INTERNAL === "true") return P(this, jt).core;
    throw new Error("__core is not available.");
  }
  get container() {
    return P(this, Pl).container;
  }
  publishAllState() {
    P(this, jt).publishAllState();
  }
  clear() {
    P(this, jt).clear();
  }
  destroy() {
    P(this, jt).destroy();
  }
  async enableDebug(t = {}) {
    let { Inspector: e } = await import("./inspector-DPNZIY36-Ck5Td1ZT.js");
    await new e(this, P(this, jt)).enable(t);
  }
  async takeScreenshot() {
    return await P(this, Pl).renderSync(), P(this, Pl).rendererDomElement.toDataURL("image/png");
  }
  get manualFloorVisibility() {
    return P(this, jt).manualFloorVisibility;
  }
  set manualFloorVisibility(t) {
    P(this, jt).manualFloorVisibility = t;
  }
  getOptimalVisualDistanceBetweenFloors(t) {
    return P(this, jt).getOptimalVisualDistanceBetweenFloors(t);
  }
};
mf2 = /* @__PURE__ */ new WeakMap(), jt = /* @__PURE__ */ new WeakMap(), Pl = /* @__PURE__ */ new WeakMap(), H$3(PT, "MapView");
var km = PT;
a();
a();
var ET = class ET2 extends Se$1 {
  constructor(e) {
    super();
    O(this, "gl");
    O(this, "el", document.createElement("div"));
    O(this, "core");
    O(this, "origin");
    O(this, "map");
    O(this, "layer");
    O(this, "handleStyleChange", H$3(() => {
      !this.map || !this.layer || this.map.getLayer(this.layer.id) || (this.map.addLayer(this.layer), this.core.camera.setMinZoomLevel(this.map.getMinZoom()), this.core.camera.setMaxZoomLevel(this.map.getMaxZoom()), this.core.camera.setMinPitch(this.map.getMinPitch()), this.core.camera.setMaxPitch(this.map.getMaxPitch()));
    }, "handleStyleChange"));
    O(this, "handleMove", H$3(() => {
      if (!this.map) return;
      let [e4, n4] = this.map.getCenter().toArray();
      this.core.getSystems().cameraSystem.setCenter(e4, n4), this.core.getSystems().cameraSystem.setZoomLevel(this.map.getZoom()), this.core.getSystems().cameraSystem.setRotation(Zp$2.degToRad(this.map.getBearing())), this.core.getSystems().cameraSystem.setTilt(Zp$2.degToRad(this.map.getPitch()));
    }, "handleMove"));
    O(this, "handleError", H$3((e4) => {
      B.warn(e4);
    }, "handleError"));
    this.origin = e;
  }
  onAdd(e) {
    this.origin = this.origin || e.getCenter().toArray(), this.gl = e.painter.context.gl, this.core = new C1(e._container, { center: this.origin, zoomLevel: e.getZoom(), pitch: e.getPitch(), bearing: e.getBearing(), gl: this.gl, map: e, mode: "outdoors-overlay" }), this.map = e, this.core.camera.setMinZoomLevel(e.getMinZoom()), this.core.camera.setMaxZoomLevel(e.getMaxZoom()), this.core.camera.setMinPitch(e.getMinPitch()), this.core.camera.setMaxPitch(e.getMaxPitch()), this.map.on("error", this.handleError);
    let n4 = Fe$1.fromLngLat(this.origin, 0);
    return this.layer = Si(n4, this.core.viewCamera, this.core.camera, () => {
      this.core.renderSync();
    }), this.map.on("styledata", this.handleStyleChange), this.map.on("move", this.handleMove), this.handleStyleChange(), this.el;
  }
  onRemove() {
    this.map && (this.map.off("styledata", this.handleStyleChange), this.map.off("move", this.handleMove), this.map.off("error", this.handleError), this.layer && this.map.removeLayer(this.layer.id)), this.layer = void 0, this.map = void 0, this.core && this.core.destroy(), this.core = void 0;
  }
};
H$3(ET, "MapLibreOverlay");
var O2 = ET;
var gf2, yf2, Rm, Qc2, vf2, v0 = class v02 {
  constructor(t, e, n4) {
    Q$3(this, gf2);
    Q$3(this, yf2);
    Q$3(this, Rm);
    Q$3(this, Qc2);
    Q$3(this, vf2);
    O(this, "on", H$3((t5, e4) => {
      P(this, gf2).on(t5, e4);
    }, "on"));
    O(this, "off", H$3((t5, e4) => {
      P(this, gf2).off(t5, e4);
    }, "off"));
    R$1(this, gf2, new Se$1()), R$1(this, vf2, new O2(t)), R$1(this, yf2, e), R$1(this, Rm, n4);
  }
  onAdd(t) {
    var i, a4;
    let e = P(this, vf2).onAdd(t), n4 = G$1(F$1(F$1({}, Yp), (i = P(this, Rm)) != null ? i : {}), { outdoorView: F$1({ token: P(this, yf2).outdoorViewToken }, (a4 = P(this, Rm)) == null ? void 0 : a4.outdoorView) });
    return R$1(this, Qc2, new km(P(this, vf2).core)), P(this, Qc2).addMap(P(this, yf2), n4).then(() => {
      P(this, gf2).publish("loaded", { mapView: P(this, Qc2), mapData: P(this, yf2) });
    }), e;
  }
  onRemove() {
    P(this, Qc2) && P(this, Qc2).clear(), v02.instance = null, P(this, vf2).onRemove();
  }
};
gf2 = /* @__PURE__ */ new WeakMap(), yf2 = /* @__PURE__ */ new WeakMap(), Rm = /* @__PURE__ */ new WeakMap(), Qc2 = /* @__PURE__ */ new WeakMap(), vf2 = /* @__PURE__ */ new WeakMap(), H$3(v0, "MappedinMapLibreOverlay"), O(v0, "instance");
var Fm = v0;
a();
var CZ = 1e3 * 60 * 60 * 2, tp, Gm2, on, Ia, Ma2, Us2, Ta2, Vm2, jm, b0, dn, bL, xL, Bm2, D2, OT, DT, LT, AT = class AT2 {
  constructor(t, e) {
    Q$3(this, dn);
    Q$3(this, tp, new Se$1());
    Q$3(this, Gm2);
    Q$3(this, on);
    Q$3(this, Ia);
    Q$3(this, Ma2);
    Q$3(this, Us2);
    Q$3(this, Ta2);
    Q$3(this, Vm2);
    Q$3(this, jm);
    Q$3(this, b0, H$3(() => {
      "key" in P(this, on) && "secret" in P(this, on) && S$1(this, dn, Bm2).call(this), S$1(this, dn, D2).call(this);
    }, "#handleWindowFocus"));
    O(this, "on", H$3((t5, e4) => P(this, tp).on(t5, e4), "on"));
    O(this, "off", H$3((t5, e4) => P(this, tp).off(t5, e4), "off"));
    R$1(this, Gm2, t), R$1(this, on, e);
  }
  setMapIds(t) {
    R$1(this, Gm2, t);
  }
  setEnterprise(t) {
    P(this, on).enterprise = t;
  }
  async readySync() {
    var i;
    if ((!("key" in P(this, on)) || !("secret" in P(this, on))) && !("accessToken" in P(this, on))) {
      B.error("No API keys or access token provided! Cannot preload tokens.");
      return;
    }
    let t = [S$1(this, dn, Bm2).call(this), null];
    P(this, on).enterprise || (t[1] = this.getSasTokensAsync());
    let [e, n4] = await Promise.all(t);
    S$1(this, dn, LT).call(this), S$1(this, dn, OT).call(this, e), n4 != null && S$1(this, dn, DT).call(this, n4), Ar() && ((i = globalThis.addEventListener) == null || i.call(globalThis, "focus", P(this, b0)));
  }
  async refreshing() {
    let t = [];
    return P(this, Ia) != null && t.push(P(this, Ia)), P(this, Ma2) != null && t.push(P(this, Ma2)), Promise.all(t);
  }
  getAccessTokenAsync() {
    return S$1(this, dn, Bm2).call(this);
  }
  getSasTokensAsync() {
    return S$1(this, dn, D2).call(this);
  }
  getAccessToken() {
    return P(this, Us2) == null ? (B.error("Tokens must be loaded before reading synchronously! Try awaiting readySync() first."), { token: "" }) : P(this, Us2);
  }
  getSasToken(t) {
    return this.isEnterpriseMode() ? (B.error("SAS tokens are not available in the enterprise mode!"), { token: "" }) : P(this, Ta2) == null ? (B.error("Tokens must be loaded before reading synchronously! Try awaiting readySync() first."), { token: "" }) : t in P(this, Ta2).tokens ? P(this, Ta2).tokens[t] : (B.error("SAS token for map ".concat(t, " not found!")), { token: "" });
  }
  isEnterpriseMode() {
    var t;
    return (t = P(this, on).enterprise) != null ? t : false;
  }
  destroy() {
    S$1(this, dn, LT).call(this), P(this, tp).destroy(), Ar() && globalThis.removeEventListener("focus", P(this, b0));
  }
};
tp = /* @__PURE__ */ new WeakMap(), Gm2 = /* @__PURE__ */ new WeakMap(), on = /* @__PURE__ */ new WeakMap(), Ia = /* @__PURE__ */ new WeakMap(), Ma2 = /* @__PURE__ */ new WeakMap(), Us2 = /* @__PURE__ */ new WeakMap(), Ta2 = /* @__PURE__ */ new WeakMap(), Vm2 = /* @__PURE__ */ new WeakMap(), jm = /* @__PURE__ */ new WeakMap(), b0 = /* @__PURE__ */ new WeakMap(), dn = /* @__PURE__ */ new WeakSet(), bL = H$3(function(t) {
  var n4;
  let e = t.token !== ((n4 = P(this, Us2)) == null ? void 0 : n4.token);
  R$1(this, Us2, t), e && P(this, tp).publish("access-token-refreshed", { accessToken: t });
}, "#setAccessToken"), xL = H$3(function(t) {
  var n4;
  let e = JSON.stringify(t.tokens) !== JSON.stringify((n4 = P(this, Ta2)) == null ? void 0 : n4.tokens);
  R$1(this, Ta2, t), e && P(this, tp).publish("sas-tokens-refreshed", { sasTokens: t.tokens });
}, "#setSasTokens"), Bm2 = H$3(async function(t = false) {
  var e;
  if ("accessToken" in P(this, on) && typeof P(this, on).accessToken == "string") {
    let n4 = { token: P(this, on).accessToken, expires: Date.now() + 72e5 };
    return R$1(this, Us2, n4), n4;
  }
  if (!("key" in P(this, on)) || !("secret" in P(this, on)) || typeof P(this, on).key != "string" || typeof P(this, on).secret != "string") throw new Error("No API keys or access token provided!");
  return P(this, Ia) != null ? P(this, Ia) : P(this, Us2) != null && P(this, Us2).expires != null && P(this, Us2).expires > Date.now() && !t ? P(this, Us2) : (R$1(this, Ia, iy2(G$1(F$1({}, P(this, on)), { key: P(this, on).key, secret: P(this, on).secret }), (e = P(this, on).enterprise) != null ? e : false).then((n4) => {
    let i = { token: n4.accessToken, expires: n4.expiresTimestamp * 1e3 };
    return S$1(this, dn, bL).call(this, i), i;
  })), P(this, Ia).finally(() => {
    R$1(this, Ia, void 0);
  }), P(this, Ia));
}, "#refreshAccessToken"), D2 = H$3(async function(t = false) {
  return this.isEnterpriseMode() ? { tokens: {}, expires: 1 / 0 } : P(this, Ma2) != null ? P(this, Ma2) : P(this, Ta2) != null && P(this, Ta2).expires > Date.now() && !t ? P(this, Ta2) : (R$1(this, Ma2, new Promise((e, n4) => {
    S$1(this, dn, Bm2).call(this).then((i) => {
      let a4 = {}, u5 = P(this, Gm2).map((h) => IS(G$1(F$1({}, P(this, on)), { mapId: h }), i.token).then((d) => {
        a4[h] = { token: d.token, expires: d.expires };
      }).catch((d) => {
        B.error("Error getting SAS token for map ".concat(h, ":"), d);
      }));
      Promise.all(u5).then(() => {
        let h = { tokens: a4, expires: Math.min(...Object.values(a4).map((d) => {
          var m5;
          return (m5 = d.expires) != null ? m5 : 1 / 0;
        })) };
        S$1(this, dn, xL).call(this, h), e(h);
      });
    }).catch((i) => {
      n4(i);
    });
  })), P(this, Ma2).catch((e) => {
    throw e;
  }).finally(() => {
    R$1(this, Ma2, void 0);
  }), P(this, Ma2));
}, "#refreshSasTokens"), OT = H$3(function(t) {
  if (!("key" in P(this, on)) || !("secret" in P(this, on))) return;
  let e = t.expires != null ? t.expires - Date.now() : CZ;
  isFinite(e) && R$1(this, Vm2, setTimeout(() => {
    S$1(this, dn, Bm2).call(this, true).then((n4) => {
      S$1(this, dn, OT).call(this, n4);
    });
  }, e - G7));
}, "#setAccessTokenRefresh"), DT = H$3(function(t) {
  let e = t.expires - Date.now();
  isFinite(e) && R$1(this, jm, setTimeout(() => {
    S$1(this, dn, D2).call(this, true).then((n4) => {
      S$1(this, dn, DT).call(this, n4);
    });
  }, e - U7));
}, "#setSasTokensRefresh"), LT = H$3(function() {
  P(this, Vm2) != null && clearTimeout(P(this, Vm2)), P(this, jm) != null && clearTimeout(P(this, jm));
}, "#stopRefreshing"), H$3(AT, "TokenManager");
var Um = AT;
a();
var _L = H$3(async (r5, t) => {
  var w3, E4, T3, D4, A3, L3, B$12;
  let e = (T3 = "mvfVersion" in (t != null ? t : {}) ? t == null ? void 0 : t.mvfVersion : void 0) != null ? T3 : "options" in r5 && "version" in ((w3 = r5.options) != null ? w3 : {}) ? (E4 = r5.options) == null ? void 0 : E4.version : void 0, n4 = G$1(F$1({ prefetchTokens: true }, t || {}), { mvfVersion: e }), i, a4 = Sc2();
  a4.updateByUserOption(n4);
  let u5 = {};
  if ("type" in r5 && typeof r5.type == "string") {
    if (u5.enterprise = (D4 = r5.options) == null ? void 0 : D4.enterprise, r5.type === "binary" && r5.main instanceof Uint8Array) {
      i = await oy(r5.main, n4.mvfVersion), u5.languagePacks = [];
      for (let j3 of (A3 = r5.languagePacks) != null ? A3 : []) j3.localePack instanceof Uint8Array && u5.languagePacks.push({ language: j3.language, localePack: await Od2(j3.localePack) });
    } else if (r5.type === "json") i = r5.main, u5.languagePacks = (L3 = r5.languagePacks) != null ? L3 : [];
    else throw new Error("Invalid backup type");
    r5.type === "binary" && r5.main instanceof Uint8Array && (u5.binaryBundle = r5.main);
  } else i = r5, u5.enterprise = i.enterprise != null;
  let h = fb(i), d = h.length > 0 ? h : [n4.mapId], m5 = new Um(d, G$1(F$1({}, n4), { enterprise: u5.enterprise })), v3;
  if ("accessToken" in n4) v3 = n4.accessToken;
  else if ("key" in n4 && "secret" in n4) {
    n4.baseAuthUri = a4.getBaseAuthUri(u5.enterprise);
    let j3 = await m5.getAccessTokenAsync();
    v3 = (j3 == null ? void 0 : j3.token) || "";
  }
  if (u5.outdoorViewToken = v3, u5.env = a4, u5.getMapDataOptions = n4, n4.prefetchTokens) try {
    await m5.readySync();
  } catch (j3) {
    B.error("Failed to ready token manager!", j3);
  }
  let x2 = new bf2(i, u5);
  v3 && x2.Analytics.init(G$1(F$1({ accessToken: v3, mapId: n4.mapId, key: "key" in n4 ? n4.key : void 0, secret: "secret" in n4 ? n4.secret : void 0 }, n4.analytics), { baseUri: a4.getAnalyticsBaseUri(), context: (B$12 = n4.analytics) == null ? void 0 : B$12.context }));
  let S4 = new cy(x2), I3 = x2.findPreferredLanguage({ languageCode: n4.language, fallbackToNavigatorLanguage: false });
  if (I3) try {
    await S4.changeLanguage(I3.code);
  } catch (j3) {
  }
  return typeof (t == null ? void 0 : t.onMVFParsed) == "function" && t.onMVFParsed(i), S4;
}, "hydrateMapData");
a();
var CL = H$3((r5, { id: t } = {}) => {
  let e = Array.isArray(r5) ? r5 : [r5];
  if (!e.every((a4) => typeof a4 == "string")) return;
  let n4 = e.join(""), i = null;
  if (t) {
    let a4 = document.getElementById(t);
    a4 instanceof HTMLStyleElement && (i = a4);
  }
  i == null && (i = document.createElement("style")), t && t !== "" && (i.id = t), i.textContent = n4, document.head.appendChild(i);
}, "injectCSS");
var SL = ":root {\n	--pin-shadow-hover-scale: 0.9;\n	--pin-shadow-width: 12px;\n	--pin-shadow-height: 5px;\n	--pin-shadow-opacity: 0.35;\n	--pin-drop-animation-duration-ms: 250ms;\n}\n\n@keyframes drop-pin {\n	0% {\n		transform: translateY(-200%);\n	}\n\n	100% {\n		transform: translateY(0);\n	}\n}\n\n@keyframes pin-shadow {\n	0% {\n		transform: scale(var(--pin-shadow-hover-scale));\n	}\n\n	100% {\n		transform: scale(1);\n	}\n}\n\n.mappedin-dropped-pin-wrapper {\n	position: relative;\n\n	width: fit-content;\n	height: fit-content;\n	width: 36px;\n	height: 42px;\n\n	& svg {\n		position: absolute;\n		left: calc(50% - var(--pin-shadow-width));\n		animation: drop-pin var(--pin-drop-animation-duration-ms) ease-in;\n	}\n\n	& > .pin-shadow {\n		position: absolute;\n		left: calc(50% - (var(--pin-shadow-width) / 2));\n		bottom: 0;\n\n		height: var(--pin-shadow-height);\n		width: var(--pin-shadow-width);\n		border-radius: 100%;\n\n		opacity: var(--pin-shadow-opacity);\n\n		animation: pin-shadow 250ms ease-in;\n	}\n}\n\n@keyframes bounce {\n	0% {\n		transform: translateY(-10px);\n		opacity: 0;\n	}\n	12.5% {\n		transform: translateY(0);\n		opacity: 1;\n	}\n	25% {\n		transform: translateY(0);\n	}\n	37.5% {\n		transform: translateY(-10px);\n	}\n	50% {\n		transform: translateY(0);\n	}\n	62.5% {\n		transform: translateY(-10px);\n	}\n	75% {\n		transform: translateY(0);\n	}\n	87.5% {\n		transform: translateY(-10px);\n	}\n	100% {\n		transform: translateY(0);\n	}\n}\n\n.mappedin-connection-marker {\n	position: relative;\n	display: flex;\n\n	.bouncey {\n		animation: bounce 2.5s linear;\n	}\n\n	.arrow--down {\n		transform: rotate(180deg);\n	}\n\n	.connection-circle {\n		display: flex;\n		box-sizing: border-box;\n		justify-content: center;\n		align-items: center;\n		border-radius: 50%;\n		border: 2px solid white;\n		box-shadow: 0px 2px 8px 0px rgba(0, 0, 0, 0.15);\n		background: #595959;\n	}\n}\n";
var IL = `.mappedin-marker {
	font-family: 'InterUI-Regular', Helvetica, Arial, sans-serif;
	font-weight: normal;
	top: 0;
	position: absolute;
	font-weight: bold;
	color: black;
	display: flex;
	flex-direction: row;
	will-change: transform, opacity;
	transition: opacity 150ms ease-in-out;
	justify-content: center;
	opacity: 0;
}

/* Low priority pin strategy styles */

/* Hide child elements as well */
.mappedin-marker[data-anchor="low-priority-pin"]> .mappedin-marker-content {
	visibility: hidden;
}

/* Create the pin using ::before pseudo-element */
.mappedin-marker::before {
	content: '';
	display: none;
	border-radius: 50%;
	position: relative;
	/* Default values - will be overridden by inline styles */
	width: var(--mappedin-pin-size, 2px);
	height: var(--mappedin-pin-size, 2px);
	background-color: var(--pin-color, #666);
}

.mappedin-marker[data-anchor="low-priority-pin"]::before {
	display: block;
}
`;
var ML = ".mappedin__smart-collision-engine__container {\n	position: absolute;\n	left: 0px;\n	top: 0px;\n	bottom: 0px;\n	right: 0px;\n	pointer-events: none;\n	/* Enables colliders to use translate3D */\n	transform-style: preserve-3d;\n	font-family: 'InterUI-Regular', Helvetica, Arial, sans-serif;\n}\n\n.mappedin__smart-collision-engine-debug__container {\n	position: absolute;\n	left: 0px;\n	top: 0px;\n	bottom: 0px;\n	right: 0px;\n	transition: opacity 300ms ease-in-out;\n	pointer-events: none;\n	will-change: opacity;\n	&.interacting {\n		opacity: 0.2;\n	}\n}\n";
var TL = ".mappedin-map {\n	.mappedin-interactive {\n		cursor: grab;\n\n		&:active {\n			cursor: grabbing;\n		}\n\n		&.mappedin-interaction-hover {\n			cursor: pointer;\n		}\n	}\n}\n";
var wL = ".mappedin-map {\n	.mappedin-control-container {\n		position: absolute;\n		left: 0px;\n		top: 0px;\n		bottom: 0px;\n		right: 0px;\n		pointer-events: none;\n		font-family: 'InterUI-Regular', Helvetica, Arial, sans-serif;\n\n		.mappedin-ctrl-top-left,\n		.mappedin-ctrl-top-right,\n		.mappedin-ctrl-bottom-left,\n		.mappedin-ctrl-bottom-right {\n			position: absolute;\n			pointer-events: none;\n		}\n\n		.mappedin-ctrl-top-left {\n			top: 0;\n			left: 0;\n		}\n\n		.mappedin-ctrl-top-right {\n			top: 0;\n			right: 0;\n		}\n\n		.mappedin-ctrl-bottom-left {\n			bottom: 0;\n			left: 0;\n		}\n\n		.mappedin-ctrl-bottom-right {\n			bottom: 0;\n			right: 0;\n		}\n\n		.mappedin-ctrl-attrib {\n			display: block;\n			position: relative;\n			pointer-events: auto;\n			font: 9px/11px 'InterUI-Regular', Helvetica, Arial, sans-serif;\n			padding: 3px 5px 1px 5px;\n			background-color: rgba(255, 255, 255, 0.5);\n			margin: 0;\n			min-width: 11px;\n			min-height: 11px;\n			user-select: none;\n\n			summary.mappedin-ctrl-attrib-button {\n				appearance: none;\n				list-style: none;\n			}\n\n			summary.mappedin-ctrl-attrib-button::-webkit-details-marker {\n				display: none;\n			}\n\n			&.mappedin-compact .mappedin-ctrl-attrib-button,\n			&.mappedin-compact-show .mappedin-ctrl-attrib-inner {\n				display: inline-block;\n			}\n\n			&.mappedin-compact {\n				background-color: transparent;\n			}\n\n			&.mappedin-compact-show {\n				min-width: 15px;\n				min-height: 15px;\n				box-sizing: border-box;\n				background-color: rgba(255, 255, 255, 0.5);\n			}\n		}\n\n		.mappedin-ctrl-attrib-top-left {\n			float: left;\n			border-bottom-right-radius: 4px;\n		}\n\n		.mappedin-ctrl-attrib-top-right {\n			float: right;\n			border-bottom-left-radius: 4px;\n		}\n\n		.mappedin-ctrl-attrib-bottom-left {\n			float: left;\n			border-top-right-radius: 4px;\n		}\n\n		.mappedin-ctrl-attrib-bottom-right {\n			float: right;\n			border-top-left-radius: 4px;\n		}\n		.mappedin-ctrl-attrib-top-left,\n		.mappedin-ctrl-attrib-bottom-left {\n			padding: 3px 5px 1px 20px;\n		}\n\n		.mappedin-ctrl-attrib-inner {\n			display: inline-block;\n			margin-right: 12px;\n		}\n\n		.mappedin-ctrl-attrib-inner,\n		.mappedin-ctrl-attrib-inner a {\n			color: rgba(0, 0, 0, 0.75);\n			text-decoration: none;\n		}\n\n		.mappedin-ctrl-attrib-inner-bold,\n		.mappedin-ctrl-attrib-inner-bold a {\n			font-weight: bold;\n		}\n\n		.mappedin-ctrl-attrib-inner a:hover {\n			color: #017ef1;\n			text-decoration: underline;\n			cursor: pointer;\n		}\n\n		.mappedin-ctrl-attrib-button {\n			display: none;\n			cursor: pointer;\n			position: absolute;\n			width: 15px;\n			height: 15px;\n			box-sizing: border-box;\n			border-radius: 50%;\n			top: 0;\n			right: 2px;\n			border: 1px;\n		}\n		.mappedin-ctrl-attrib-top-left .mappedin-ctrl-attrib-button,\n		.mappedin-ctrl-attrib-bottom-left .mappedin-ctrl-attrib-button {\n			left: 2px;\n		}\n	}\n}\n";
var PL = '.maplibregl-map {\n    font: 12px/20px "Helvetica Neue", Arial, Helvetica, sans-serif;\n    overflow: hidden;\n    position: relative;\n    -webkit-tap-highlight-color: rgb(0 0 0 / 0%);\n}\n\n.maplibregl-canvas {\n    position: absolute;\n    left: 0;\n    top: 0;\n}\n\n.maplibregl-map:fullscreen {\n    width: 100%;\n    height: 100%;\n}\n\n.maplibregl-ctrl-group button.maplibregl-ctrl-compass {\n    touch-action: none;\n}\n\n.maplibregl-canvas-container.maplibregl-interactive,\n.maplibregl-ctrl-group button.maplibregl-ctrl-compass {\n    cursor: grab;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.maplibregl-canvas-container.maplibregl-interactive.maplibregl-track-pointer {\n    cursor: pointer;\n}\n\n.maplibregl-canvas-container.maplibregl-interactive:active,\n.maplibregl-ctrl-group button.maplibregl-ctrl-compass:active {\n    cursor: grabbing;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate,\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate .maplibregl-canvas {\n    touch-action: pan-x pan-y;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-drag-pan,\n.maplibregl-canvas-container.maplibregl-touch-drag-pan .maplibregl-canvas {\n    touch-action: pinch-zoom;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan,\n.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan .maplibregl-canvas {\n    touch-action: none;\n}\n\n.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures,\n.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures .maplibregl-canvas {\n    touch-action: pan-x pan-y;\n}\n\n.maplibregl-ctrl-top-left,\n.maplibregl-ctrl-top-right,\n.maplibregl-ctrl-bottom-left,\n.maplibregl-ctrl-bottom-right { position: absolute; pointer-events: none; z-index: 2; }\n\n.maplibregl-ctrl-top-left { top: 0; left: 0; }\n\n.maplibregl-ctrl-top-right { top: 0; right: 0; }\n\n.maplibregl-ctrl-bottom-left { bottom: 0; left: 0; }\n\n.maplibregl-ctrl-bottom-right { right: 0; bottom: 0; }\n\n.maplibregl-ctrl {\n    clear: both;\n    pointer-events: auto;\n\n    /* workaround for a Safari bug https://github.com/mapbox/mapbox-gl-js/issues/8185 */\n    transform: translate(0, 0);\n}\n\n.maplibregl-ctrl-top-left .maplibregl-ctrl { margin: 10px 0 0 10px; float: left; }\n\n.maplibregl-ctrl-top-right .maplibregl-ctrl { margin: 10px 10px 0 0; float: right; }\n\n.maplibregl-ctrl-bottom-left .maplibregl-ctrl { margin: 0 0 10px 10px; float: left; }\n\n.maplibregl-ctrl-bottom-right .maplibregl-ctrl { margin: 0 10px 10px 0; float: right; }\n\n.maplibregl-ctrl-group {\n    border-radius: 4px;\n    background: #fff;\n}\n\n.maplibregl-ctrl-group:not(:empty) {\n    box-shadow: 0 0 0 2px rgb(0 0 0 / 10%);\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl-group:not(:empty) {\n        box-shadow: 0 0 0 2px ButtonText;\n    }\n}\n\n.maplibregl-ctrl-group button {\n    width: 29px;\n    height: 29px;\n    display: block;\n    padding: 0;\n    outline: none;\n    border: 0;\n    box-sizing: border-box;\n    background-color: transparent;\n    cursor: pointer;\n}\n\n.maplibregl-ctrl-group button + button {\n    border-top: 1px solid #ddd;\n}\n\n.maplibregl-ctrl button .maplibregl-ctrl-icon {\n    display: block;\n    width: 100%;\n    height: 100%;\n    background-repeat: no-repeat;\n    background-position: center center;\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl-icon {\n        background-color: transparent;\n    }\n\n    .maplibregl-ctrl-group button + button {\n        border-top: 1px solid ButtonText;\n    }\n}\n\n/* https://bugzilla.mozilla.org/show_bug.cgi?id=140562 */\n.maplibregl-ctrl button::-moz-focus-inner {\n    border: 0;\n    padding: 0;\n}\n\n.maplibregl-ctrl-attrib-button:focus,\n.maplibregl-ctrl-group button:focus {\n    box-shadow: 0 0 2px 2px rgb(0 150 255 / 100%);\n}\n\n.maplibregl-ctrl button:disabled {\n    cursor: not-allowed;\n}\n\n.maplibregl-ctrl button:disabled .maplibregl-ctrl-icon {\n    opacity: 0.25;\n}\n\n.maplibregl-ctrl button:not(:disabled):hover {\n    background-color: rgb(0 0 0 / 5%);\n}\n\n.maplibregl-ctrl-group button:focus:focus-visible {\n    box-shadow: 0 0 2px 2px rgb(0 150 255 / 100%);\n}\n\n.maplibregl-ctrl-group button:focus:not(:focus-visible) {\n    box-shadow: none;\n}\n\n.maplibregl-ctrl-group button:focus:first-child {\n    border-radius: 4px 4px 0 0;\n}\n\n.maplibregl-ctrl-group button:focus:last-child {\n    border-radius: 0 0 4px 4px;\n}\n\n.maplibregl-ctrl-group button:focus:only-child {\n    border-radius: inherit;\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-zoom-out.svg", fill: #333);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #333);\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-out.svg", fill: #fff);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #fff);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-out.svg", fill: #000);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-zoom-in.svg", fill: #000);\n    }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-fullscreen.svg", fill: #333);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-shrink.svg");\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-fullscreen.svg", fill: #fff);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-shrink.svg", fill: #fff);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-fullscreen.svg", fill: #000);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-shrink.svg", fill: #000);\n    }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {\n    background-image: svg-load("svg/maplibregl-ctrl-compass.svg", fill: #333);\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {\n        @svg-load ctrl-compass-white url("svg/maplibregl-ctrl-compass.svg") {\n            fill: #fff;\n            #south { fill: #999; }\n        }\n\n        background-image: svg-inline(ctrl-compass-white);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {\n        background-image: svg-load("svg/maplibregl-ctrl-compass.svg", fill: #000);\n    }\n}\n\n@svg-load ctrl-terrain url("svg/maplibregl-ctrl-terrain.svg") {\n    fill: #333;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-terrain-enabled url("svg/maplibregl-ctrl-terrain.svg") {\n    fill: #33b5e5;\n    #stroke { display: none; }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-terrain .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-terrain);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-terrain-enabled .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-terrain-enabled);\n}\n\n@svg-load ctrl-geolocate url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #333;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-white url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #fff;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-black url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #000;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-disabled url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #aaa;\n    #stroke { fill: #f00; }\n}\n\n@svg-load ctrl-geolocate-disabled-white url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #999;\n    #stroke { fill: #f00; }\n}\n\n@svg-load ctrl-geolocate-disabled-black url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #666;\n    #stroke { fill: #f00; }\n}\n\n@svg-load ctrl-geolocate-active url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #33b5e5;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-active-error url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #e58978;\n    #stroke { display: none; }\n}\n\n@svg-load ctrl-geolocate-background url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #33b5e5;\n    #stroke { display: none; }\n    #dot { display: none; }\n}\n\n@svg-load ctrl-geolocate-background-error url("svg/maplibregl-ctrl-geolocate.svg") {\n    fill: #e54e33;\n    #stroke { display: none; }\n    #dot { display: none; }\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-disabled);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-active);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-active-error);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-background);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon {\n    background-image: svg-inline(ctrl-geolocate-background-error);\n}\n\n.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-waiting .maplibregl-ctrl-icon {\n    animation: maplibregl-spin 2s infinite linear;\n}\n\n@media (-ms-high-contrast: active) {\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-white);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-disabled-white);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-active);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-active-error);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-background);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-background-error);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-black);\n    }\n\n    .maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {\n        background-image: svg-inline(ctrl-geolocate-disabled-black);\n    }\n}\n\n@keyframes maplibregl-spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\na.maplibregl-ctrl-logo {\n    width: 88px;\n    height: 23px;\n    margin: 0 0 -4px -4px;\n    display: block;\n    background-repeat: no-repeat;\n    cursor: pointer;\n    overflow: hidden;\n    background-image: svg-load("svg/maplibregl-ctrl-logo.svg");\n}\n\na.maplibregl-ctrl-logo.maplibregl-compact {\n    width: 14px;\n}\n\n@media (-ms-high-contrast: active) {\n    a.maplibregl-ctrl-logo {\n        @svg-load ctrl-logo-white url("svg/maplibregl-ctrl-logo.svg") {\n            #outline { opacity: 1; }\n            #fill { opacity: 1; }\n        }\n\n        background-color: transparent;\n        background-image: svg-inline(ctrl-logo-white);\n    }\n}\n\n@media (-ms-high-contrast: black-on-white) {\n    a.maplibregl-ctrl-logo {\n        @svg-load ctrl-logo-black url("svg/maplibregl-ctrl-logo.svg") {\n            #outline { opacity: 1; fill: #fff; stroke: #fff; }\n            #fill { opacity: 1; fill: #000; }\n        }\n\n        background-image: svg-inline(ctrl-logo-black);\n    }\n}\n\n.maplibregl-ctrl.maplibregl-ctrl-attrib {\n    padding: 0 5px;\n    background-color: rgb(255 255 255 / 50%);\n    margin: 0;\n}\n\n@media screen {\n    .maplibregl-ctrl-attrib.maplibregl-compact {\n        min-height: 20px;\n        padding: 2px 24px 2px 0;\n        margin: 10px;\n        position: relative;\n        background-color: #fff;\n        color: #000;\n        border-radius: 12px;\n        box-sizing: content-box;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact-show {\n        padding: 2px 28px 2px 8px;\n        visibility: visible;\n    }\n\n    .maplibregl-ctrl-top-left > .maplibregl-ctrl-attrib.maplibregl-compact-show,\n    .maplibregl-ctrl-bottom-left > .maplibregl-ctrl-attrib.maplibregl-compact-show {\n        padding: 2px 8px 2px 28px;\n        border-radius: 12px;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner {\n        display: none;\n    }\n\n    .maplibregl-ctrl-attrib-button {\n        display: none;\n        cursor: pointer;\n        position: absolute;\n        background-image: svg-load("svg/maplibregl-ctrl-attrib.svg");\n        background-color: rgb(255 255 255 / 50%);\n        width: 24px;\n        height: 24px;\n        box-sizing: border-box;\n        border-radius: 12px;\n        outline: none;\n        top: 0;\n        right: 0;\n        border: 0;\n    }\n\n    .maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button {\n        appearance: none;\n        list-style: none;\n    }\n\n    .maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button::-webkit-details-marker {\n        display: none;\n    }\n\n    .maplibregl-ctrl-top-left .maplibregl-ctrl-attrib-button,\n    .maplibregl-ctrl-bottom-left .maplibregl-ctrl-attrib-button {\n        left: 0;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-button,\n    .maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-inner {\n        display: block;\n    }\n\n    .maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-button {\n        background-color: rgb(0 0 0 / 5%);\n    }\n\n    .maplibregl-ctrl-bottom-right > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        bottom: 0;\n        right: 0;\n    }\n\n    .maplibregl-ctrl-top-right > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        top: 0;\n        right: 0;\n    }\n\n    .maplibregl-ctrl-top-left > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        top: 0;\n        left: 0;\n    }\n\n    .maplibregl-ctrl-bottom-left > .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        bottom: 0;\n        left: 0;\n    }\n}\n\n@media screen and (-ms-high-contrast: active) {\n    .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        background-image: svg-load("svg/maplibregl-ctrl-attrib.svg", fill=#fff);\n    }\n}\n\n@media screen and (-ms-high-contrast: black-on-white) {\n    .maplibregl-ctrl-attrib.maplibregl-compact::after {\n        background-image: svg-load("svg/maplibregl-ctrl-attrib.svg");\n    }\n}\n\n.maplibregl-ctrl-attrib a {\n    color: rgb(0 0 0 / 75%);\n    text-decoration: none;\n}\n\n.maplibregl-ctrl-attrib a:hover {\n    color: inherit;\n    text-decoration: underline;\n}\n\n.maplibregl-attrib-empty {\n    display: none;\n}\n\n.maplibregl-ctrl-scale {\n    background-color: rgb(255 255 255 / 75%);\n    font-size: 10px;\n    border-width: medium 2px 2px;\n    border-style: none solid solid;\n    border-color: #333;\n    padding: 0 5px;\n    color: #333;\n    box-sizing: border-box;\n}\n\n.maplibregl-popup {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: flex;\n    will-change: transform;\n    pointer-events: none;\n}\n\n.maplibregl-popup-anchor-top,\n.maplibregl-popup-anchor-top-left,\n.maplibregl-popup-anchor-top-right {\n    flex-direction: column;\n}\n\n.maplibregl-popup-anchor-bottom,\n.maplibregl-popup-anchor-bottom-left,\n.maplibregl-popup-anchor-bottom-right {\n    flex-direction: column-reverse;\n}\n\n.maplibregl-popup-anchor-left {\n    flex-direction: row;\n}\n\n.maplibregl-popup-anchor-right {\n    flex-direction: row-reverse;\n}\n\n.maplibregl-popup-tip {\n    width: 0;\n    height: 0;\n    border: 10px solid transparent;\n    z-index: 1;\n}\n\n.maplibregl-popup-anchor-top .maplibregl-popup-tip {\n    align-self: center;\n    border-top: none;\n    border-bottom-color: #fff;\n}\n\n.maplibregl-popup-anchor-top-left .maplibregl-popup-tip {\n    align-self: flex-start;\n    border-top: none;\n    border-left: none;\n    border-bottom-color: #fff;\n}\n\n.maplibregl-popup-anchor-top-right .maplibregl-popup-tip {\n    align-self: flex-end;\n    border-top: none;\n    border-right: none;\n    border-bottom-color: #fff;\n}\n\n.maplibregl-popup-anchor-bottom .maplibregl-popup-tip {\n    align-self: center;\n    border-bottom: none;\n    border-top-color: #fff;\n}\n\n.maplibregl-popup-anchor-bottom-left .maplibregl-popup-tip {\n    align-self: flex-start;\n    border-bottom: none;\n    border-left: none;\n    border-top-color: #fff;\n}\n\n.maplibregl-popup-anchor-bottom-right .maplibregl-popup-tip {\n    align-self: flex-end;\n    border-bottom: none;\n    border-right: none;\n    border-top-color: #fff;\n}\n\n.maplibregl-popup-anchor-left .maplibregl-popup-tip {\n    align-self: center;\n    border-left: none;\n    border-right-color: #fff;\n}\n\n.maplibregl-popup-anchor-right .maplibregl-popup-tip {\n    align-self: center;\n    border-right: none;\n    border-left-color: #fff;\n}\n\n.maplibregl-popup-close-button {\n    position: absolute;\n    right: 0;\n    top: 0;\n    border: 0;\n    border-radius: 0 3px 0 0;\n    cursor: pointer;\n    background-color: transparent;\n}\n\n.maplibregl-popup-close-button:hover {\n    background-color: rgb(0 0 0 / 5%);\n}\n\n.maplibregl-popup-content {\n    position: relative;\n    background: #fff;\n    border-radius: 3px;\n    box-shadow: 0 1px 2px rgb(0 0 0 / 10%);\n    padding: 15px 10px;\n    pointer-events: auto;\n}\n\n.maplibregl-popup-anchor-top-left .maplibregl-popup-content {\n    border-top-left-radius: 0;\n}\n\n.maplibregl-popup-anchor-top-right .maplibregl-popup-content {\n    border-top-right-radius: 0;\n}\n\n.maplibregl-popup-anchor-bottom-left .maplibregl-popup-content {\n    border-bottom-left-radius: 0;\n}\n\n.maplibregl-popup-anchor-bottom-right .maplibregl-popup-content {\n    border-bottom-right-radius: 0;\n}\n\n.maplibregl-popup-track-pointer {\n    display: none;\n}\n\n.maplibregl-popup-track-pointer * {\n    pointer-events: none;\n    user-select: none;\n}\n\n.maplibregl-map:hover .maplibregl-popup-track-pointer {\n    display: flex;\n}\n\n.maplibregl-map:active .maplibregl-popup-track-pointer {\n    display: none;\n}\n\n.maplibregl-marker {\n    position: absolute;\n    top: 0;\n    left: 0;\n    will-change: transform;\n    transition: opacity 0.2s;\n}\n\n.maplibregl-user-location-dot {\n    background-color: #1da1f2;\n    width: 15px;\n    height: 15px;\n    border-radius: 50%;\n}\n\n.maplibregl-user-location-dot::before {\n    background-color: #1da1f2;\n    content: "";\n    width: 15px;\n    height: 15px;\n    border-radius: 50%;\n    position: absolute;\n    animation: maplibregl-user-location-dot-pulse 2s infinite;\n}\n\n.maplibregl-user-location-dot::after {\n    border-radius: 50%;\n    border: 2px solid #fff;\n    content: "";\n    height: 19px;\n    left: -2px;\n    position: absolute;\n    top: -2px;\n    width: 19px;\n    box-sizing: border-box;\n    box-shadow: 0 0 3px rgb(0 0 0 / 35%);\n}\n\n@keyframes maplibregl-user-location-dot-pulse {\n    0%   { transform: scale(1); opacity: 1; }\n    70%  { transform: scale(3); opacity: 0; }\n    100% { transform: scale(1); opacity: 0; }\n}\n\n.maplibregl-user-location-dot-stale {\n    background-color: #aaa;\n}\n\n.maplibregl-user-location-dot-stale::after {\n    display: none;\n}\n\n.maplibregl-user-location-accuracy-circle {\n    background-color: #1da1f233;\n    width: 1px;\n    height: 1px;\n    border-radius: 100%;\n}\n\n.maplibregl-crosshair,\n.maplibregl-crosshair .maplibregl-interactive,\n.maplibregl-crosshair .maplibregl-interactive:active {\n    cursor: crosshair;\n}\n\n.maplibregl-boxzoom {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 0;\n    height: 0;\n    background: #fff;\n    border: 2px dotted #202020;\n    opacity: 0.5;\n}\n\n.maplibregl-cooperative-gesture-screen {\n    background: rgba(0 0 0 / 40%);\n    position: absolute;\n    inset: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: white;\n    padding: 1rem;\n    font-size: 1.4em;\n    line-height: 1.2;\n    opacity: 0;\n    pointer-events: none;\n    transition: opacity 1s ease 1s;\n    z-index: 99999;\n}\n\n.maplibregl-cooperative-gesture-screen.maplibregl-show {\n    opacity: 1;\n    transition: opacity 0.05s;\n}\n\n.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {\n    display: none;\n}\n\n@media (hover: none), (width <= 480px) {\n    .maplibregl-cooperative-gesture-screen .maplibregl-desktop-message {\n        display: none;\n    }\n\n    .maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {\n        display: block;\n    }\n}\n\n.maplibregl-pseudo-fullscreen {\n    position: fixed !important;\n    width: 100% !important;\n    height: 100% !important;\n    top: 0 !important;\n    left: 0 !important;\n    z-index: 99999;\n}\n';
a();
function EZ(r5) {
  var t, e;
  if (!(!r5.languages || !Ar() || !((e = (t = globalThis.navigator) == null ? void 0 : t.languages) != null && e.length))) for (let n4 = 0; n4 < globalThis.navigator.languages.length; n4++) {
    let i = r5.languages.find((a4) => a4.code.toLowerCase() === globalThis.navigator.languages[n4].toLowerCase());
    if (i) return { code: i.code, name: i.name };
  }
}
H$3(EZ, "findNavigatorPreferredLanguageInVenue");
function L2(r5, t) {
  var u5, h, d;
  let e = (u5 = t == null ? void 0 : t.languageCode) != null ? u5 : "", n4 = (h = t == null ? void 0 : t.fallbackToNavigatorLanguage) != null ? h : true, i = (d = r5 == null ? void 0 : r5.languages) == null ? void 0 : d.find((m5) => m5.code.toLowerCase() === e.toLowerCase()), a4;
  if (i) a4 = i;
  else if (n4 == null || n4) try {
    let m5 = EZ(r5);
    m5 && (a4 = m5);
  } catch (m5) {
    B.error("fallbackToNavigatorLanguage is set, however, there was an error getting the navigator language", m5);
  }
  return a4 != null ? a4 : r5.defaultLanguage;
}
H$3(L2, "findPreferredLanguageInVenue");
var OZ = [SL, IL, ML, TL, wL, PL], EL;
function DZ(r5) {
  EL = r5;
}
H$3(DZ, "__setWatermarkOnClickFn");
var LZ = H$3(async (r5, t) => {
  let e, n4 = Sc2();
  t && n4.updateByUserOption(t);
  try {
    t && (e = (await iy2(G$1(F$1({}, t), { baseAuthUri: n4.getBaseAuthUri() }))).accessToken);
  } catch (u5) {
    B.warn("Getting access token failed. Outdoor map disabled.", u5);
  }
  let i = new bf2(r5, { outdoorViewToken: e, languagePacks: t == null ? void 0 : t.languagePacks, env: n4 });
  return new cy(i);
}, "hydrateMapDataFromMVF"), OL = false;
function AZ(r5) {
  OL = r5;
}
H$3(AZ, "setUseEnterpriseAPI");
var DL = H$3(async (r5) => {
  var T3, D4;
  let t = OL, e, n4 = Sc2();
  n4.updateByUserOption(r5);
  let i = G$1(F$1({ prefetchTokens: true }, r5), { fallbackToNavigatorLanguage: (T3 = r5.fallbackToNavigatorLanguage) != null ? T3 : true }), a4 = new Um([i.mapId], i);
  if ("accessToken" in i) {
    e = i.accessToken;
    let { aud: A3, sub: L3 } = Sr(e);
    (v7.some((B3) => A3.includes(B3)) || L3 && L3.startsWith("client")) && (t = true, a4.setEnterprise(t));
  } else if ("key" in i && "secret" in i) {
    if (i.key.startsWith("mipk_")) throw new Error("Partner API keys detected! \n\nPartner API keys should not be passed directly to the SDK. See https://developer.mappedin.com/docs/rest-apis/partner for more details.");
    i.key.startsWith("mik_") || (t = true, a4.setEnterprise(t)), i.baseAuthUri = n4.getBaseAuthUri(t), e = (await a4.getAccessTokenAsync()).token;
  } else throw new Error("Missing key or secret.");
  i.layoutId != null && (t ? i.layoutId !== "draft" && B.warn('Invalid layoutId! Use "draft" to load draft data or leave unspecified to load live data.') : B.warn("layoutId is currently unsupported!")), i.baseUri = n4.getBaseUri(t);
  let u5 = performance.now(), h, d;
  if (t) {
    let A3 = G$1(F$1({}, i), { venue: i.mapId, clientId: i.key, clientSecret: i.secret, version: "1.0.0", perspective: i.viewId, useDraftData: i.layoutId === "draft" }), L3 = await wS(A3);
    h = L3.compressed, d = L3.localePacks;
  } else h = await PS(i, e);
  let m5 = performance.now(), v3 = await oy(h, i.mvfVersion), x2 = performance.now();
  typeof r5.onMVFParsed == "function" && r5.onMVFParsed(v3);
  let S4 = fb(v3);
  if (S4.length > 0 ? a4.setMapIds(S4) : a4.setMapIds([i.mapId]), i.prefetchTokens) try {
    await a4.readySync();
  } catch (A3) {
    B.error("Failed to ready token manager!", A3);
  }
  let I3 = new bf2(v3, { env: n4, outdoorViewToken: e, tokenManager: a4, enterprise: t, localePacksUrls: d, binaryBundle: h, getMapDataOptions: i }), w3 = new cy(I3, { search: r5.search });
  I3.Analytics.init(G$1(F$1({ accessToken: e, mapId: i.mapId, key: "key" in i ? i.key : void 0, secret: "secret" in i ? i.secret : void 0 }, i.analytics), { baseUri: n4.getAnalyticsBaseUri(), context: (D4 = i.analytics) == null ? void 0 : D4.context })), I3.Analytics.sendGetMapDataEvent({ parseDuration: x2 - m5, downloadDuration: m5 - u5, viewId: i.viewId });
  let E4 = I3.findPreferredLanguage({ languageCode: i.language, fallbackToNavigatorLanguage: i.fallbackToNavigatorLanguage });
  if (E4) try {
    await w3.changeLanguage(E4.code);
  } catch (A3) {
  }
  return w3;
}, "getMapData"), NZ = DL, kZ = H$3((r5, t) => {
  Fm.instance != null && B.warn("Only a single map venue is supported at this time.");
  let e = new Fm([r5.mapCenter.longitude, r5.mapCenter.latitude], r5, t);
  return Fm.instance = e, e;
}, "createMapLibreOverlay"), LL = H$3(async () => {
  if (hh2 === "" || h2 === "") return false;
  let r5 = [fetch(hh2, { mode: "same-origin" }), fetch(h2, { mode: "same-origin" })], [t, e] = [{ ok: false }, { ok: false }];
  try {
    [t, e] = await Promise.all(r5);
  } catch (n4) {
  }
  return { collision: t.ok, maplibre: e.ok };
}, "checkWorkerUrls"), AL = H$3(async (r5, t, e) => {
  var S4, I3, w3, E4, T3, D4, A3, L3, B3, j3, W4, $5, F3, J4, ot2, K4;
  let n4 = performance.now(), i = pS(e, t);
  i && cS(i), ((S4 = i.injectStyles) == null || S4) && CL(OZ, { id: "mappedin__styles" });
  let a4 = x7((I3 = t.outdoorViewToken) != null ? I3 : ""), u5 = py(t);
  (w3 = i.outdoorView) != null && w3.style && u5.envControl.updateTileServerBaseUrl((E4 = i.outdoorView) == null ? void 0 : E4.style);
  let h = false, d = false, m5 = await LL();
  m5 && (m5.collision || (h = true), m5.maplibre || (d = true));
  let v3 = await TD(r5, { center: [t.mapCenter.longitude, t.mapCenter.latitude], bearing: i.bearing, pitch: i.pitch, zoomLevel: i.zoomLevel, backgroundAlpha: (T3 = i.style) == null ? void 0 : T3.backgroundAlpha, backgroundColor: (D4 = i.style) == null ? void 0 : D4.backgroundColor, outdoorView: !d && ((A3 = i.outdoorView) != null && A3.token) ? { headers: { "x-mappedin-tiles-key": (L3 = i.outdoorView) == null ? void 0 : L3.token }, style: t.getEnv().tileServerUri, enabled: !!((B3 = i.outdoorView) != null && B3.enabled), lowDpi: (j3 = i.outdoorView) == null ? void 0 : j3.lowDpi } : void 0, watermark: G$1(F$1({}, i.watermark), { visible: ($5 = (W4 = i.watermark) == null ? void 0 : W4.visible) != null ? $5 : !u5.enterpriseMode && !a4.remove_watermark, onClick: EL || void 0 }), attribution: i.attribution, antialias: typeof i.antialiasing == "boolean" ? i.antialiasing : !!((F3 = i.antialiasing) != null && F3.enabled), accessToken: t.outdoorViewToken, occlusionEnabled: (J4 = i.occlusion) == null ? void 0 : J4.enabled, transformImageRequest: u5.enterpriseMode ? void 0 : u5.transformImageRequest, naturalBearing: t.naturalBearing, imagePlacementOptions: i.imagePlacementOptions, onWebGLContextCreationError: i.onWebGLContextCreationError, onWebGLContextLost: i.onWebGLContextLost, onWebGLContextRestored: i.onWebGLContextRestored, onWebGLRendererError: i.onWebGLRendererError, useStandaloneCamera: (ot2 = i.useStandaloneCamera) != null ? ot2 : false, useWorkers: !((K4 = i.disableWorkers) != null && K4), useCollisionWorker: !h }), x2 = new km(v3);
  return await x2.addMap(t, i), u5.Analytics.sendMapViewLoadedEvent({ firstRenderDuration: performance.now() - n4, dimension: x2.getDimensions(), collisionWorkerDisabled: h, outdoorsWorkerDisabled: d }), x2;
}, "show3dMap"), RZ = AL;
function js2(r5) {
  return r5.verticalOffset === 0 ? [r5.longitude, r5.latitude] : [r5.longitude, r5.latitude, r5.verticalOffset];
}
H$3(js2, "convertCoordinateToPosition");
function BZ(r5) {
  return new Map(r5.map((t) => {
    let { properties: e } = t, { id: n4 } = e;
    return [n4, t];
  }));
}
H$3(BZ, "getEntranceMap");
var $M = H$3((r5, t) => {
  let e = BZ(t), n4 = { entrances: { type: "FeatureCollection", features: [] }, walls: { type: "Feature", properties: { id: r5[0].properties.id }, geometry: { type: "MultiLineString", coordinates: [] } } };
  for (let i of r5) {
    let a4 = [i.geometry.coordinates], u5 = (i.properties.entrances || []).reduce((h, d) => (e.has(d) && h.push(e.get(d)), h), []);
    if (u5.length) {
      let { entrances: h, obstructions: d } = AS(i, u5);
      a4 = d.map((m5) => m5.geometry.coordinates), n4.entrances.features.push(...h);
    }
    n4.walls.geometry.coordinates.push(...a4);
  }
  return n4;
}, "cutEntrancesFromLineStrings");
function pL(r5, t) {
  let e = { options: {} };
  if (!e.options) throw new Error("options should exist");
  return r5.text && (e.text = r5.text), r5.appearance && (e.options.appearance = r5.appearance), r5.rank != null && (r5.rank === "initial" ? e.options.rank = t.initialRank || 2 : e.options.rank = r5.rank), r5.enabled !== void 0 && (e.enabled = r5.enabled), r5.interactive !== void 0 && (e.options.interactive = r5.interactive), r5.enabled !== void 0 && (e.enabled = r5.enabled), e;
}
H$3(pL, "translateLabelStateToGeojsonCore");
function hL(r5, t) {
  let e = { options: {} };
  if (!e.options) throw new Error("options should exist");
  return r5.rank != null && (r5.rank === "initial" ? e.options.rank = t.initialRank || 2 : e.options.rank = r5.rank), r5.enabled != null && (e.enabled = r5.enabled), r5.interactive != null && (e.options.interactive = r5.interactive), r5.enabled !== null && (e.enabled = r5.enabled), r5.contentHTML !== void 0 && (e.contentHTML = r5.contentHTML), e;
}
H$3(hL, "translateMarkerStateToGeojsonCore");
function P2(r5, t) {
  var n4, i;
  let e = {};
  return t == null || (r5.color && (r5.color === "initial" ? e.color = t.initialColor : e.color = r5.color), r5.topColor && (r5.topColor === "initial" ? e.topColor = t.initialTopColor : e.topColor = r5.topColor), r5.visible !== void 0 && (e.visible = r5.visible), ((n4 = r5.texture) == null ? void 0 : n4.url) !== void 0 && (e.texture = r5.texture.url), ((i = r5.topTexture) == null ? void 0 : i.url) !== void 0 && (e.topTexture = r5.topTexture.url), r5.opacity !== void 0 && (e.opacity = r5.opacity)), e;
}
H$3(P2, "translateDoorsStateToGeojsonCore");
function IT(r5, t) {
  var n4, i;
  let e = {};
  return t == null || (r5.color && (r5.color === "initial" ? e.color = t.initialColor : e.color = r5.color), r5.topColor && (r5.topColor === "initial" ? e.topColor = t.initialTopColor : e.topColor = r5.topColor), r5.visible !== void 0 && (e.visible = r5.visible), ((n4 = r5.texture) == null ? void 0 : n4.url) !== void 0 && (e.texture = r5.texture.url), ((i = r5.topTexture) == null ? void 0 : i.url) !== void 0 && (e.topTexture = r5.topTexture.url), r5.height !== void 0 && (e.height = r5.height), r5.opacity !== void 0 && (e.opacity = r5.opacity)), e;
}
H$3(IT, "translateWallsStateToGeojsonCore");
function fL(r5, t, e) {
  var i, a4, u5;
  let n4 = {};
  return t == null || (r5.color && (r5.color === "initial" ? n4.color = t.initialColor : n4.color = r5.color), r5.topColor && (r5.topColor === "initial" ? n4.topColor = t.initialTopColor : n4.topColor = r5.topColor), r5.visible !== void 0 && (n4.visible = r5.visible), ((i = r5.texture) == null ? void 0 : i.url) !== void 0 && (n4.texture = r5.texture.url), ((a4 = r5.topTexture) == null ? void 0 : a4.url) !== void 0 && (n4.topTexture = r5.topTexture.url), r5.hoverColor !== void 0 && (n4.hoverColor = r5.hoverColor), r5.interactive !== void 0 && (n4.interactive = r5.interactive), r5.height !== void 0 && (n4.height = r5.height), r5.opacity !== void 0 && (n4.opacity = r5.opacity), r5.flipImageToFaceCamera !== void 0 && (n4.flipImageToFaceCamera = r5.flipImageToFaceCamera), r5.altitude !== void 0 && (n4.altitude = r5.altitude - ((u5 = e == null ? void 0 : e.altitude) != null ? u5 : 0))), n4;
}
H$3(fL, "translateSpaceStateToGeojsonCore");
function NL(r5, t) {
  return ((t - r5 + Math.PI) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2) - Math.PI;
}
H$3(NL, "differenceBetweenAngles");
function kL(r5, t) {
  let e = "Left";
  return r5 <= -Math.PI / 4 ? e = "Right" : r5 <= -t ? e = "SlightRight" : r5 <= t ? e = "Straight" : r5 <= Math.PI / 4 ? e = "SlightLeft" : e = "Left", e;
}
H$3(kL, "getRelativeBearing");
function qD(r5) {
  let t = {};
  for (let e in r5) {
    let n4 = r5[e];
    if (n4 != null) {
      if (n4.id = e, "polygons" in n4) for (let i of n4.polygons) t[i] = n4;
      else if ("lineStrings" in n4) for (let i of n4.lineStrings) t[i] = n4;
      else if ("points" in n4) for (let i of n4.points) t[i] = n4;
    }
  }
  return t;
}
H$3(qD, "extractStyleMap");
function v2(r5, t) {
  return r5.reduce((e, n4) => {
    let i = t[n4.properties.id];
    if (i == null) return e;
    if ("textures" in n4.properties && Array.isArray(n4.properties.textures) && n4.properties.textures.length > 0) {
      let a4 = G$1(F$1({}, i), { id: i.id + "-textures" });
      e.set(a4, [n4]);
    } else e.has(i) || e.set(i, []), e.get(i).push(n4);
    return e;
  }, /* @__PURE__ */ new Map());
}
H$3(v2, "groupGeometryByStyle");
function wm(r5, t = {}) {
  var i, a4, u5, h, d, m5, v3;
  let e = G$1(F$1({}, r5), { flipImageToFaceCamera: (i = t == null ? void 0 : t.flipImagesToFaceCamera) != null ? i : true }), n4 = (u5 = (a4 = t == null ? void 0 : t.style) == null ? void 0 : a4.shading) != null ? u5 : t == null ? void 0 : t.shadingAndOutlines;
  if (n4 === true ? e.shading = { start: 0.1, end: 0.15, intensity: 0.4 } : typeof n4 == "object" && (e.shading = { start: n4.start, end: n4.end, intensity: n4.intensity }), e.outline = (d = (h = t == null ? void 0 : t.style) == null ? void 0 : h.outlines) != null ? d : t == null ? void 0 : t.shadingAndOutlines, "lineStrings" in r5) {
    let x2 = (v3 = (m5 = t == null ? void 0 : t.style) == null ? void 0 : m5.wallTopColor) != null ? v3 : t == null ? void 0 : t.wallTopColor;
    x2 != null && (e.topColor = x2);
  }
  return e;
}
H$3(wm, "translateToCoreStyle");
var dL = H$3((r5, t) => {
  var i;
  let n4 = ((i = t.currentMap) == null ? void 0 : i.currentFloor).layers.get(Gn2);
  switch (r5) {
    case "interior-walls":
      return n4 == null ? void 0 : n4.layers.get(yc);
    case "exterior-walls":
      return n4 == null ? void 0 : n4.layers.get(il2);
    case "interior-doors":
      return n4 == null ? void 0 : n4.layers.get(Sd2);
    case "exterior-doors":
      return n4 == null ? void 0 : n4.layers.get(Id2);
    default:
      return typeof r5 == "string" ? r5 : r5.id;
  }
}, "getTargetID");
function lT(r5) {
  return new Promise((t) => {
    r5.onComplete(t), r5.onStop(t);
  });
}
H$3(lT, "tweenToPromise");
function b2(r5) {
  return r5.bbox ? r5.bbox : lt(r5);
}
H$3(b2, "getBoundingBox");
function mL(r5, t) {
  return [Math.min(r5[0], t[0]), Math.min(r5[1], t[1]), Math.max(r5[2], t[2]), Math.max(r5[3], t[3])];
}
H$3(mL, "expandBbox");
function RL(r5) {
  return [...new Set(r5)];
}
H$3(RL, "unique");
function uT(r5, t, e) {
  return r5.floorId && t.has(r5.floorId) ? t.get(r5.floorId) : e;
}
H$3(uT, "getTargetFloorObject");
function Tm2(r5) {
  if (ui.is(r5) || Vo.is(r5)) return r5.id;
}
H$3(Tm2, "getAttachableGeometryId");
function WD(r5, t, e) {
  var a4, u5, h, d, m5, v3;
  let n4 = r5.coordinates.length === 2, i = true;
  if (n4 && r5.coordinates[0].floorId != null && r5.coordinates[1].floorId != null) {
    let x2 = t == null ? void 0 : t.getById("floor", r5.coordinates[0].floorId), S4 = t == null ? void 0 : t.getById("floor", r5.coordinates[1].floorId);
    x2 && S4 && (i = ((u5 = (a4 = e.getState(x2)) == null ? void 0 : a4.visible) != null ? u5 : true) && ((d = (h = e.getState(S4)) == null ? void 0 : h.visible) != null ? d : true));
  } else {
    let x2 = r5.coordinates[0].floorId != null ? t == null ? void 0 : t.getById("floor", r5.coordinates[0].floorId) : void 0;
    i = x2 && (v3 = (m5 = e.getState(x2)) == null ? void 0 : m5.visible) != null ? v3 : true;
  }
  return i;
}
H$3(WD, "determineFloorVisibleBasedOnPath");
a();
function Uu2(r5, t) {
  var e, n4, i, a4;
  if (ih2.is(r5)) return r5.navigationTarget.flatMap((u5) => Uu2(u5, t));
  if (nu2.is(r5)) {
    let u5 = t.Query.nearest(r5, { types: ["node"], lineOfSight: true });
    return (e = u5 == null ? void 0 : u5[0]) != null && e.feature.id ? [u5[0].feature.id] : [];
  } else if (ve2.is(r5)) {
    let u5 = t.Query.nearest(r5, { types: ["node"], lineOfSight: true });
    return (n4 = u5 == null ? void 0 : u5[0]) != null && n4.feature.id ? [u5[0].feature.id] : [];
  } else if (ru2.is(r5)) {
    let u5 = t.Query.nearest(r5, { types: ["node"], lineOfSight: true });
    return (i = u5 == null ? void 0 : u5[0]) != null && i.feature.id ? [u5[0].feature.id] : [];
  } else if (ca.is(r5)) {
    let u5 = t == null ? void 0 : t.getMVFFeatureById("entrance", r5.id);
    return u5 != null && u5.properties.node ? [u5 == null ? void 0 : u5.properties.node] : [];
  } else if (tu2.is(r5)) {
    let u5 = t == null ? void 0 : t.getMVFFeatureById("area", r5.id);
    return (a4 = u5 == null ? void 0 : u5.properties.destinationNodes) != null ? a4 : [];
  } else if (ui.is(r5)) {
    let u5 = t == null ? void 0 : t.getMVFFeatureById("space", r5.id);
    return u5 == null ? [] : u5.properties.destinationNodes;
  } else {
    if (bc2.is(r5)) return r5.coordinates.reduce((u5, h) => {
      var m5;
      let d = t.Query.nearest(h, { types: ["node"], lineOfSight: true });
      return (m5 = d == null ? void 0 : d[0]) != null && m5.feature.id && u5.push(d[0].feature.id), u5;
    }, []);
    if (Vo.is(r5)) {
      let u5 = t == null ? void 0 : t.objectEntranceNodeIdsByObstructionId[r5.id];
      return u5 != null ? u5 : [];
    } else return Ps.is(r5) ? r5.spaces.flatMap((u5) => {
      var h, d;
      return (d = (h = t == null ? void 0 : t.getMVFFeatureById("space", u5.id)) == null ? void 0 : h.properties.destinationNodes) != null ? d : [];
    }).filter((u5) => typeof u5 == "string") : nl.is(r5) ? r5.nodes.map((u5) => u5.id) : $l.is(r5) ? [r5.id] : [];
  }
}
H$3(Uu2, "getNodesFromTarget");
var FL = Math.PI * 0.1, zn, uo, Li, zu2, Hu2, Xu, xf2, Hm, zs2, BL, zm, GL, NT = class NT2 {
  constructor(t, e, n4, i, a4) {
    Q$3(this, zs2);
    O(this, "id");
    Q$3(this, zn, {});
    Q$3(this, uo);
    Q$3(this, Li);
    Q$3(this, zu2);
    Q$3(this, Hu2);
    Q$3(this, Xu);
    Q$3(this, xf2);
    Q$3(this, Hm);
    var u5;
    this.id = (u5 = a4 == null ? void 0 : a4.id) != null ? u5 : E(), R$1(this, uo, e), R$1(this, Li, t.features), R$1(this, zu2, n4), R$1(this, Hu2, i);
  }
  get path() {
    return P(this, Li).map((t) => P(this, uo).getById("node", t.properties.id)).filter(Boolean);
  }
  get departure() {
    if (P(this, zn).departure) return P(this, zn).departure;
    if (P(this, Li).length === 0 || P(this, zu2).length === 0) return;
    let t = P(this, Li)[0].properties.id, e = P(this, zu2)[0];
    if (P(this, zu2).length > 1) {
      for (let n4 of P(this, zu2)) if (Uu2(n4, P(this, uo)).includes(t)) {
        e = n4;
        break;
      }
    }
    return P(this, zn).departure = e, e;
  }
  get destination() {
    if (P(this, zn).destination) return P(this, zn).destination;
    if (P(this, Li).length === 0 || P(this, Hu2).length === 0) return;
    let t = P(this, Li)[P(this, Li).length - 1].properties.id, e = P(this, Hu2)[0];
    if (P(this, Hu2).length > 1) {
      for (let n4 of P(this, Hu2)) if (Uu2(n4, P(this, uo)).includes(t)) {
        e = n4;
        break;
      }
    }
    return P(this, zn).destination = e, e;
  }
  get coordinates() {
    return P(this, zn).coordinates ? P(this, zn).coordinates : (P(this, zn).coordinates = P(this, Li).map((t) => new ve2(t.geometry.coordinates[1], t.geometry.coordinates[0], t.properties.groupBy)), P(this, zn).coordinates);
  }
  get distance() {
    return P(this, zn).distance ? P(this, zn).distance : (P(this, zn).distance = P(this, Li).reduce((t, e) => t + (e.properties.distance || 0), 0), P(this, zn).distance);
  }
  get instructions() {
    if (P(this, Li).length < 2) return [];
    if (P(this, zn).instructions) return P(this, zn).instructions;
    let t = [], e = 0;
    for (let n4 = 0; n4 < P(this, Li).length; n4++) {
      let i = P(this, Li)[n4], a4 = P(this, Li)[n4 - 1], u5 = P(this, Li)[n4 + 1], h = new ve2(i.geometry.coordinates[1], i.geometry.coordinates[0], i.properties.groupBy), d = S$1(this, zs2, BL).call(this, { prevDirection: a4, direction: i, nextDirection: u5 });
      e += (a4 == null ? void 0 : a4.properties.distance) || 0;
      for (let m5 of d) m5 && (t.push({ action: m5, distance: e, coordinate: h, node: P(this, uo).getById("node", i.properties.id) }), e = 0);
    }
    return P(this, zn).instructions = t, P(this, zn).instructions;
  }
  toJSON() {
    return { id: this.id, directions: P(this, Li), __type: "directions", from: P(this, zu2), to: P(this, Hu2) };
  }
};
zn = /* @__PURE__ */ new WeakMap(), uo = /* @__PURE__ */ new WeakMap(), Li = /* @__PURE__ */ new WeakMap(), zu2 = /* @__PURE__ */ new WeakMap(), Hu2 = /* @__PURE__ */ new WeakMap(), Xu = /* @__PURE__ */ new WeakMap(), xf2 = /* @__PURE__ */ new WeakMap(), Hm = /* @__PURE__ */ new WeakMap(), zs2 = /* @__PURE__ */ new WeakSet(), BL = H$3(function(t) {
  var w3, E4;
  let { prevDirection: e, direction: n4, nextDirection: i } = t, a4 = e && P(this, uo).getById("floor", e.properties.groupBy), u5 = P(this, uo).getById("floor", n4.properties.groupBy), h = i && P(this, uo).getById("floor", i.properties.groupBy), d = [];
  e || d.push({ type: "Departure" });
  let m5 = P(this, uo).getMVFFeatureByNodeId("connection", n4.properties.id), v3 = m5 ? P(this, uo).getById("connection", m5.id) : void 0, x2 = m5 && m5.nodes.length > 1, S4 = P(this, uo).enterpriseMode && (!n4.properties.destination || !(m5 != null && m5.nodes.includes(n4.properties.destination)) || !(m5 != null && m5.nodes.includes(n4.properties.id)));
  if (m5 && !(!x2 || S4)) if (!P(this, Xu) || P(this, Xu) === "exit") d.push(S$1(this, zs2, zm).call(this, "TakeConnection", u5, h, v3, m5)), R$1(this, Xu, "take"), R$1(this, xf2, v3), R$1(this, Hm, m5);
  else {
    let T3 = P(this, uo).getMVFFeatureByNodeId("connection", (w3 = e == null ? void 0 : e.properties.id) != null ? w3 : ""), D4 = P(this, uo).getById("connection", (E4 = T3 == null ? void 0 : T3.id) != null ? E4 : "");
    d.push(S$1(this, zs2, zm).call(this, "ExitConnection", u5, a4, D4, T3)), R$1(this, Xu, "exit"), R$1(this, xf2, v3), R$1(this, Hm, m5);
  }
  else P(this, Xu) === "take" ? (d.push(S$1(this, zs2, zm).call(this, "ExitConnection", u5, a4, P(this, xf2), P(this, Hm))), R$1(this, Xu, "exit"), R$1(this, xf2, v3)) : h && u5.id !== h.id ? d.push(S$1(this, zs2, zm).call(this, "TakeConnection", u5, h, v3)) : a4 && a4.id !== u5.id ? d.push(S$1(this, zs2, zm).call(this, "ExitConnection", u5, a4, v3)) : d.push(S$1(this, zs2, GL).call(this, e, n4));
  return i || d.push({ type: "Arrival" }), d;
}, "#getActions"), zm = H$3(function(t, e, n4, i, a4) {
  var d, m5;
  let u5 = "none";
  if (e.elevation != null && (n4 == null ? void 0 : n4.elevation) != null) {
    let v3 = e.elevation - n4.elevation;
    v3 > 0 ? u5 = "down" : v3 < 0 && (u5 = "up");
  }
  let h = (m5 = (d = i == null ? void 0 : i.type) != null ? d : a4 == null ? void 0 : a4.type) != null ? m5 : "stairs";
  return { type: t, fromFloor: e, toFloor: n4, direction: u5, connection: i, connectionType: h };
}, "#createConnectionAction"), GL = H$3(function(t, e) {
  let n4 = e.properties.edges;
  if (!n4 || n4.filter((u5) => u5.destination.properties.id !== (t == null ? void 0 : t.properties.id) && u5.destination.properties.id !== e.properties.destination).length === 0) return null;
  let a4 = t ? -NL(t.properties.angle, e.properties.angle) : 0;
  return Math.abs(a4) >= FL ? { type: "Turn", bearing: kL(a4, FL), referencePosition: "At" } : null;
}, "#createTurnAction"), H$3(NT, "Directions");
var ju = NT;
a();
var kT = class kT2 {
  constructor({ nodes: t, geojsonCollection: e, connections: n4, groupBy: i, multiplicativeDistanceWeightScaling: a4 }) {
    O(this, "navigator");
    O(this, "connections");
    O(this, "getDirections", H$3((t5, e4, n5, i5) => {
      let { accessible: a10, smoothing: { enabled: u5, radius: h }, connectionIdWeightMap: d } = n5, m5 = t5.flatMap((T3) => Uu2(T3, i5)), v3 = e4.flatMap((T3) => Uu2(T3, i5)), x2 = this.getExcludedNodeIds(n5.excludedConnections).filter((T3) => !m5.includes(T3) && !v3.includes(T3)), S4 = this.getDisabledConnectionNodeIds(a10).filter((T3) => !m5.includes(T3) && !v3.includes(T3)), I3 = /* @__PURE__ */ new Map();
      for (let T3 in d) {
        let D4 = i5.getMVFFeatureById("connection", T3);
        if (!D4) continue;
        let A3 = this.navigator.graph.edges[D4.nodes[0]];
        if (A3) {
          let L3 = A3.find((B3) => B3.destination.properties.id === D4.nodes[1]);
          L3 && I3.set(L3, d[T3]);
        }
      }
      let w3 = this.navigator.getDirections({ zones: n5.zones.map((T3) => {
        var D4;
        return { geometry: T3.geometry, cost: T3.cost, map: (D4 = T3.floor) == null ? void 0 : D4.id };
      }), originIds: m5, destinationNodeIds: v3, excludedNodeIds: x2, disabledConnectionNodeIds: S4, simplify: { enabled: u5, bufferRadius: h }, overrideEdgeWeights: I3, multiplicativeDistanceWeightScaling: !i5.enterpriseMode });
      this.addCoordinateDirections(w3, t5, e4);
      let E4 = new ju(w3, i5, t5, e4);
      if (!(E4.distance === 0 && (/* @__PURE__ */ new Set([...m5, ...v3])).size === m5.length + v3.length)) return E4;
    }, "getDirections"));
    O(this, "getExcludedNodeIds", H$3((t5) => {
      if (t5.length === 0) return [];
      let e4 = new Set(t5.map((n5) => n5.id));
      return this.connections.reduce((n5, i5) => e4.has(i5.id) ? n5.concat(i5.nodes) : n5, []);
    }, "getExcludedNodeIds"));
    O(this, "getDisabledConnectionNodeIds", H$3((t5) => t5 === false ? [] : this.connections.reduce((e4, n5) => n5.accessible ? e4 : e4.concat(n5.nodes), []), "getDisabledConnectionNodeIds"));
    O(this, "addCoordinateDirections", H$3((t5, [e4], [n5]) => {
      if (t5.features.length) {
        if (ve2.is(e4)) {
          let i5 = this.createDirectionFeature(e4, this.navigator.getAngle([e4.longitude, e4.latitude], t5.features[0].geometry.coordinates), this.navigator.getDistance([e4.longitude, e4.latitude], t5.features[0].geometry.coordinates));
          t5.features.splice(0, 0, i5);
        }
        if (ve2.is(n5)) {
          let i5 = this.createDirectionFeature(n5, 0, 0), a10 = t5.features[t5.features.length - 1];
          a10.properties.distance = this.navigator.getDistance(a10.geometry.coordinates, [n5.longitude, n5.latitude]), a10.properties.angle = this.navigator.getAngle(a10.geometry.coordinates, [n5.longitude, n5.latitude]), t5.features.push(i5);
        }
      }
    }, "addCoordinateDirections"));
    O(this, "createDirectionFeature", H$3((t5, e4, n5) => ({ type: "Feature", geometry: { type: "Point", coordinates: [t5.longitude, t5.latitude] }, properties: { groupBy: t5.floorId, id: t5.id, angle: e4, distance: n5, edges: [] } }), "createDirectionFeature"));
    this.navigator = new gm2({ nodes: t, geojsonCollection: this.createCollection(e), groupBy: i, multiplicativeDistanceWeightScaling: a4 }), this.connections = n4;
  }
  createCollection(t) {
    return { type: "FeatureCollection", features: Object.entries(t).reduce((e, [n4, i]) => e.concat(i.features.map((a4) => (a4.properties.map = n4, a4))), []) };
  }
};
H$3(kT, "DirectionsInternal");
var Xm2 = kT;
a();
a();
a();
a();
a();
a();
function RT(r5) {
  let t = +this._x.call(null, r5), e = +this._y.call(null, r5);
  return VL(this.cover(t, e), t, e, r5);
}
H$3(RT, "default");
function VL(r5, t, e, n4) {
  if (isNaN(t) || isNaN(e)) return r5;
  var i, a4 = r5._root, u5 = { data: n4 }, h = r5._x0, d = r5._y0, m5 = r5._x1, v3 = r5._y1, x2, S4, I3, w3, E4, T3, D4, A3;
  if (!a4) return r5._root = u5, r5;
  for (; a4.length; ) if ((E4 = t >= (x2 = (h + m5) / 2)) ? h = x2 : m5 = x2, (T3 = e >= (S4 = (d + v3) / 2)) ? d = S4 : v3 = S4, i = a4, !(a4 = a4[D4 = T3 << 1 | E4])) return i[D4] = u5, r5;
  if (I3 = +r5._x.call(null, a4.data), w3 = +r5._y.call(null, a4.data), t === I3 && e === w3) return u5.next = a4, i ? i[D4] = u5 : r5._root = u5, r5;
  do
    i = i ? i[D4] = new Array(4) : r5._root = new Array(4), (E4 = t >= (x2 = (h + m5) / 2)) ? h = x2 : m5 = x2, (T3 = e >= (S4 = (d + v3) / 2)) ? d = S4 : v3 = S4;
  while ((D4 = T3 << 1 | E4) === (A3 = (w3 >= S4) << 1 | I3 >= x2));
  return i[A3] = a4, i[D4] = u5, r5;
}
H$3(VL, "add");
function jL(r5) {
  var t, e, n4 = r5.length, i, a4, u5 = new Array(n4), h = new Array(n4), d = 1 / 0, m5 = 1 / 0, v3 = -1 / 0, x2 = -1 / 0;
  for (e = 0; e < n4; ++e) isNaN(i = +this._x.call(null, t = r5[e])) || isNaN(a4 = +this._y.call(null, t)) || (u5[e] = i, h[e] = a4, i < d && (d = i), i > v3 && (v3 = i), a4 < m5 && (m5 = a4), a4 > x2 && (x2 = a4));
  if (d > v3 || m5 > x2) return this;
  for (this.cover(d, m5).cover(v3, x2), e = 0; e < n4; ++e) VL(this, u5[e], h[e], r5[e]);
  return this;
}
H$3(jL, "addAll");
a();
function FT(r5, t) {
  if (isNaN(r5 = +r5) || isNaN(t = +t)) return this;
  var e = this._x0, n4 = this._y0, i = this._x1, a4 = this._y1;
  if (isNaN(e)) i = (e = Math.floor(r5)) + 1, a4 = (n4 = Math.floor(t)) + 1;
  else {
    for (var u5 = i - e || 1, h = this._root, d, m5; e > r5 || r5 >= i || n4 > t || t >= a4; ) switch (m5 = (t < n4) << 1 | r5 < e, d = new Array(4), d[m5] = h, h = d, u5 *= 2, m5) {
      case 0:
        i = e + u5, a4 = n4 + u5;
        break;
      case 1:
        e = i - u5, a4 = n4 + u5;
        break;
      case 2:
        i = e + u5, n4 = a4 - u5;
        break;
      case 3:
        e = i - u5, n4 = a4 - u5;
        break;
    }
    this._root && this._root.length && (this._root = h);
  }
  return this._x0 = e, this._y0 = n4, this._x1 = i, this._y1 = a4, this;
}
H$3(FT, "default");
a();
function BT() {
  var r5 = [];
  return this.visit(function(t) {
    if (!t.length) do
      r5.push(t.data);
    while (t = t.next);
  }), r5;
}
H$3(BT, "default");
a();
function GT(r5) {
  return arguments.length ? this.cover(+r5[0][0], +r5[0][1]).cover(+r5[1][0], +r5[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
H$3(GT, "default");
a();
a();
function fi(r5, t, e, n4, i) {
  this.node = r5, this.x0 = t, this.y0 = e, this.x1 = n4, this.y1 = i;
}
H$3(fi, "default");
function VT(r5, t, e) {
  var n4, i = this._x0, a4 = this._y0, u5, h, d, m5, v3 = this._x1, x2 = this._y1, S4 = [], I3 = this._root, w3, E4;
  for (I3 && S4.push(new fi(I3, i, a4, v3, x2)), e == null ? e = 1 / 0 : (i = r5 - e, a4 = t - e, v3 = r5 + e, x2 = t + e, e *= e); w3 = S4.pop(); ) if (!(!(I3 = w3.node) || (u5 = w3.x0) > v3 || (h = w3.y0) > x2 || (d = w3.x1) < i || (m5 = w3.y1) < a4)) if (I3.length) {
    var T3 = (u5 + d) / 2, D4 = (h + m5) / 2;
    S4.push(new fi(I3[3], T3, D4, d, m5), new fi(I3[2], u5, D4, T3, m5), new fi(I3[1], T3, h, d, D4), new fi(I3[0], u5, h, T3, D4)), (E4 = (t >= D4) << 1 | r5 >= T3) && (w3 = S4[S4.length - 1], S4[S4.length - 1] = S4[S4.length - 1 - E4], S4[S4.length - 1 - E4] = w3);
  } else {
    var A3 = r5 - +this._x.call(null, I3.data), L3 = t - +this._y.call(null, I3.data), B3 = A3 * A3 + L3 * L3;
    if (B3 < e) {
      var j3 = Math.sqrt(e = B3);
      i = r5 - j3, a4 = t - j3, v3 = r5 + j3, x2 = t + j3, n4 = I3.data;
    }
  }
  return n4;
}
H$3(VT, "default");
a();
function jT(r5) {
  if (isNaN(v3 = +this._x.call(null, r5)) || isNaN(x2 = +this._y.call(null, r5))) return this;
  var t, e = this._root, n4, i, a4, u5 = this._x0, h = this._y0, d = this._x1, m5 = this._y1, v3, x2, S4, I3, w3, E4, T3, D4;
  if (!e) return this;
  if (e.length) for (; ; ) {
    if ((w3 = v3 >= (S4 = (u5 + d) / 2)) ? u5 = S4 : d = S4, (E4 = x2 >= (I3 = (h + m5) / 2)) ? h = I3 : m5 = I3, t = e, !(e = e[T3 = E4 << 1 | w3])) return this;
    if (!e.length) break;
    (t[T3 + 1 & 3] || t[T3 + 2 & 3] || t[T3 + 3 & 3]) && (n4 = t, D4 = T3);
  }
  for (; e.data !== r5; ) if (i = e, !(e = e.next)) return this;
  return (a4 = e.next) && delete e.next, i ? (a4 ? i.next = a4 : delete i.next, this) : t ? (a4 ? t[T3] = a4 : delete t[T3], (e = t[0] || t[1] || t[2] || t[3]) && e === (t[3] || t[2] || t[1] || t[0]) && !e.length && (n4 ? n4[D4] = e : this._root = e), this) : (this._root = a4, this);
}
H$3(jT, "default");
function UL(r5) {
  for (var t = 0, e = r5.length; t < e; ++t) this.remove(r5[t]);
  return this;
}
H$3(UL, "removeAll");
a();
function UT() {
  return this._root;
}
H$3(UT, "default");
a();
function zT() {
  var r5 = 0;
  return this.visit(function(t) {
    if (!t.length) do
      ++r5;
    while (t = t.next);
  }), r5;
}
H$3(zT, "default");
a();
function HT(r5) {
  var t = [], e, n4 = this._root, i, a4, u5, h, d;
  for (n4 && t.push(new fi(n4, this._x0, this._y0, this._x1, this._y1)); e = t.pop(); ) if (!r5(n4 = e.node, a4 = e.x0, u5 = e.y0, h = e.x1, d = e.y1) && n4.length) {
    var m5 = (a4 + h) / 2, v3 = (u5 + d) / 2;
    (i = n4[3]) && t.push(new fi(i, m5, v3, h, d)), (i = n4[2]) && t.push(new fi(i, a4, v3, m5, d)), (i = n4[1]) && t.push(new fi(i, m5, u5, h, v3)), (i = n4[0]) && t.push(new fi(i, a4, u5, m5, v3));
  }
  return this;
}
H$3(HT, "default");
a();
function XT(r5) {
  var t = [], e = [], n4;
  for (this._root && t.push(new fi(this._root, this._x0, this._y0, this._x1, this._y1)); n4 = t.pop(); ) {
    var i = n4.node;
    if (i.length) {
      var a4, u5 = n4.x0, h = n4.y0, d = n4.x1, m5 = n4.y1, v3 = (u5 + d) / 2, x2 = (h + m5) / 2;
      (a4 = i[0]) && t.push(new fi(a4, u5, h, v3, x2)), (a4 = i[1]) && t.push(new fi(a4, v3, h, d, x2)), (a4 = i[2]) && t.push(new fi(a4, u5, x2, v3, m5)), (a4 = i[3]) && t.push(new fi(a4, v3, x2, d, m5));
    }
    e.push(n4);
  }
  for (; n4 = e.pop(); ) r5(n4.node, n4.x0, n4.y0, n4.x1, n4.y1);
  return this;
}
H$3(XT, "default");
a();
function zL(r5) {
  return r5[0];
}
H$3(zL, "defaultX");
function YT(r5) {
  return arguments.length ? (this._x = r5, this) : this._x;
}
H$3(YT, "default");
a();
function HL(r5) {
  return r5[1];
}
H$3(HL, "defaultY");
function qT(r5) {
  return arguments.length ? (this._y = r5, this) : this._y;
}
H$3(qT, "default");
function x0(r5, t, e) {
  var n4 = new WT(t == null ? zL : t, e == null ? HL : e, NaN, NaN, NaN, NaN);
  return r5 == null ? n4 : n4.addAll(r5);
}
H$3(x0, "quadtree");
function WT(r5, t, e, n4, i, a4) {
  this._x = r5, this._y = t, this._x0 = e, this._y0 = n4, this._x1 = i, this._y1 = a4, this._root = void 0;
}
H$3(WT, "Quadtree");
function XL(r5) {
  for (var t = { data: r5.data }, e = t; r5 = r5.next; ) e = e.next = { data: r5.data };
  return t;
}
H$3(XL, "leaf_copy");
var Lo = x0.prototype = WT.prototype;
Lo.copy = function() {
  var r5 = new WT(this._x, this._y, this._x0, this._y0, this._x1, this._y1), t = this._root, e, n4;
  if (!t) return r5;
  if (!t.length) return r5._root = XL(t), r5;
  for (e = [{ source: t, target: r5._root = new Array(4) }]; t = e.pop(); ) for (var i = 0; i < 4; ++i) (n4 = t.source[i]) && (n4.length ? e.push({ source: n4, target: t.target[i] = new Array(4) }) : t.target[i] = XL(n4));
  return r5;
};
Lo.add = RT;
Lo.addAll = jL;
Lo.cover = FT;
Lo.data = BT;
Lo.extent = GT;
Lo.find = VT;
Lo.remove = jT;
Lo.removeAll = UL;
Lo.root = UT;
Lo.size = zT;
Lo.visit = HT;
Lo.visitAfter = XT;
Lo.x = YT;
Lo.y = qT;
var wa, Yu, qu, Ym2, ZT = class ZT2 {
  constructor(t, e) {
    Q$3(this, wa, {});
    Q$3(this, Yu, {});
    Q$3(this, qu);
    Q$3(this, Ym2);
    R$1(this, qu, t), R$1(this, Ym2, e);
  }
  getTreeByType(t, e, n4, i = []) {
    var m5, v3;
    P(this, wa)[t] || (P(this, wa)[t] = {}), P(this, Yu)[t] || (P(this, Yu)[t] = {}), P(this, Yu)[t][e] || (P(this, Yu)[t][e] = {});
    let a4 = P(this, Yu)[t][e][n4], u5 = !Or$1(a4, i);
    if ((m5 = P(this, wa)[t][e]) != null && m5[n4] && !u5) return P(this, wa)[t][e][n4];
    P(this, wa)[t][e] || (P(this, wa)[t][e] = {}), P(this, wa)[t][e][n4] = x0();
    let h = P(this, wa)[t][e][n4];
    h.x((x2) => P(this, Ym2).call(this, x2.geometry.coordinates).x), h.y((x2) => P(this, Ym2).call(this, x2.geometry.coordinates).y);
    let d = [];
    switch (t) {
      case "node":
        d = ((v3 = P(this, qu).directions.navigator.graph.nodesByGroup.get(n4)) == null ? void 0 : v3.filter((x2) => x2.properties.neighbors.length > 0)) || [];
        break;
      case "point-of-interest":
        d = P(this, qu).mvfPoisByFloorId[n4] || [];
        break;
      case "door":
        d = P(this, qu).mvfEntrancesByFloorId[n4] || [];
        break;
      case "annotation":
        d = P(this, qu).mvfAnnotationsByFloorId[n4] || [];
        break;
    }
    if ((i == null ? void 0 : i.length) > 0 && (d == null ? void 0 : d.length) > 0) {
      let x2 = new Set(i);
      d = d.filter((S4) => {
        let I3 = P(this, qu).getById(t, S4.properties.id);
        return I3 && !x2.has(I3);
      });
    }
    return (d == null ? void 0 : d.length) > 0 && h.addAll(d), P(this, Yu)[t][e][n4] = i ? [...i] : void 0, h;
  }
};
wa = /* @__PURE__ */ new WeakMap(), Yu = /* @__PURE__ */ new WeakMap(), qu = /* @__PURE__ */ new WeakMap(), Ym2 = /* @__PURE__ */ new WeakMap(), H$3(ZT, "QueryCache");
var A2 = ZT;
var GZ = 0.1, VZ = 5, jZ = 100, UZ = 2, YL = 1e3, qL = 111319.9, zZ = Pi.object({ limit: Pi.enum(["same-floor", "same-elevation"]).optional(), radius: Pi.number().optional(), useLineOfSight: Pi.boolean().optional(), types: Pi.array(Pi.enum(["node", "point-of-interest", "door", "annotation"])).min(1) }), Ao, _f2, Cf2, C0, N2, S0, k2, $T = class $T2 {
  constructor(t) {
    Q$3(this, Ao);
    Q$3(this, _f2);
    Q$3(this, Cf2, H$3(([t5, e]) => {
      let [n4, i] = [P(this, Ao).mapCenter.longitude, P(this, Ao).mapCenter.latitude], a4 = qL, u5 = qL * Math.cos(e * Math.PI / 180), h = (t5 - n4) * u5, d = (e - i) * a4;
      return { x: h, y: d };
    }, "#projectOntoCartesianPlane"));
    Q$3(this, C0, /* @__PURE__ */ new Map());
    Q$3(this, N2, H$3((t5, e) => {
      var a4;
      let n4 = (a4 = P(this, C0).get(t5)) == null ? void 0 : a4.get(e);
      if (n4) return n4;
      let i = P(this, _f2).getTreeByType(t5, P(this, Ao).mapName, e);
      if (typeof i.extent == "function") if (i.extent()) {
        let [[u5, h], [d, m5]] = i.extent(), v3 = d - u5, x2 = m5 - h;
        n4 = Math.max(v3, x2);
      } else n4 = YL;
      else n4 = YL;
      return P(this, C0).set(t5, /* @__PURE__ */ new Map([[e, n4]])), n4;
    }, "#getMaxRadiusForFloorId"));
    Q$3(this, S0, H$3((t5, e, n4, i, a4, u5 = []) => {
      let h = [], d = 0, m5 = P(this, N2).call(this, e, n4);
      for (; h.length === 0 && d < jZ; ) {
        if (a4 > m5) return;
        h = P(this, k2).call(this, e, n4, i, [t5.longitude, t5.latitude], a4, u5), h.length === 0 && (a4 *= UZ, d++);
      }
      let v3 = h.sort((x2, S4) => {
        let I3 = ps([t5.longitude, t5.latitude], x2.geometry.coordinates), w3 = ps([t5.longitude, t5.latitude], S4.geometry.coordinates);
        return I3 - w3;
      });
      for (let x2 of v3) if (u5.push(x2.properties.id), P(this, Ao).directions.navigator.hasLineOfSight([t5.longitude, t5.latitude], x2.geometry.coordinates, n4, GZ)) return x2;
      return P(this, S0).call(this, t5, e, n4, i, a4, u5);
    }, "#searchWithLineOfSight"));
    Q$3(this, k2, H$3((t5, e, n4, i, a4, u5 = []) => {
      let { x: h, y: d } = P(this, Cf2).call(this, i), m5 = h - a4, v3 = h + a4, x2 = d - a4, S4 = d + a4, I3 = [];
      return P(this, _f2).getTreeByType(t5, P(this, Ao).mapName, e, n4).visit((w3, E4, T3, D4, A3) => {
        if (!w3.length) do {
          if (!("data" in w3)) continue;
          let L3 = w3.data;
          if (u5.includes(L3.properties.id)) continue;
          let B3 = P(this, Cf2).call(this, L3.geometry.coordinates);
          B3.x >= m5 && B3.x < v3 && B3.y >= x2 && B3.y < S4 && I3.push(L3);
        } while ("next" in w3 && w3.next && (w3 = w3.next));
        return E4 >= v3 || T3 >= S4 || D4 < m5 || A3 < x2;
      }), I3;
    }, "#searchWithinBounds"));
    R$1(this, Ao, t), R$1(this, _f2, new A2(P(this, Ao), P(this, Cf2)));
  }
  nearest(t, e) {
    var u5, h, d;
    try {
      zZ.parse(e);
    } catch (m5) {
      B.error(m5);
      return;
    }
    let n4 = Yg2(t);
    if (!n4) return;
    let i = n4.floorId ? [n4.floorId] : [];
    if (n4.floorId == null) for (let m5 of P(this, Ao).getByType("floor-stack")) {
      let v3 = m5.defaultFloor;
      v3 && i.push(v3.id);
    }
    else if (e.limit === "same-elevation") {
      let m5 = P(this, Ao).floorsById[n4.floorId];
      if (m5) {
        let v3 = m5 == null ? void 0 : m5.elevation;
        v3 && (i = P(this, Ao).getByType("floor-stack").map((x2) => {
          var S4;
          return (S4 = x2.floors.find((I3) => I3.elevation === v3)) == null ? void 0 : S4.id;
        }).filter(Boolean));
      }
    }
    let a4 = [];
    for (let m5 of RL(e.types)) for (let v3 of i) {
      let x2;
      if (((u5 = e.lineOfSight) == null || u5) && (x2 = P(this, S0).call(this, n4, m5, v3, (h = e.exclude) != null ? h : [], (d = e.radius) != null ? d : VZ)), !x2) {
        let S4 = P(this, Cf2).call(this, [n4.longitude, n4.latitude]);
        x2 = P(this, _f2).getTreeByType(m5, P(this, Ao).mapName, v3, e.exclude).find(S4.x, S4.y);
      }
      if (x2) {
        let S4 = P(this, Ao).getById(m5, x2.properties.id);
        S4 && a4.push({ distance: ps([n4.longitude, n4.latitude], x2.geometry.coordinates), feature: S4 });
      }
    }
    return a4.sort((m5, v3) => m5.distance - v3.distance);
  }
};
Ao = /* @__PURE__ */ new WeakMap(), _f2 = /* @__PURE__ */ new WeakMap(), Cf2 = /* @__PURE__ */ new WeakMap(), C0 = /* @__PURE__ */ new WeakMap(), N2 = /* @__PURE__ */ new WeakMap(), S0 = /* @__PURE__ */ new WeakMap(), k2 = /* @__PURE__ */ new WeakMap(), H$3($T, "Query");
var _0 = $T;
a();
a();
var I0, JT = class JT2 {
  constructor(t) {
    Q$3(this, I0);
    R$1(this, I0, t || []);
  }
  get raw() {
    return P(this, I0);
  }
};
I0 = /* @__PURE__ */ new WeakMap(), H$3(JT, "OpeningHours");
var R2 = JT;
var Zi, Ht, tn, Sf2 = class Sf3 extends si {
  constructor(e, n4) {
    super(n4.mvfData.id);
    O(this, "__type", Sf3.__type);
    O(this, "id", "loc_");
    O(this, "name", "");
    O(this, "externalId");
    O(this, "description");
    O(this, "logo");
    O(this, "phone");
    O(this, "social", []);
    O(this, "images", []);
    O(this, "links", []);
    O(this, "website");
    O(this, "icon");
    Q$3(this, Zi);
    Q$3(this, Ht, {});
    Q$3(this, tn);
    R$1(this, Zi, e), R$1(this, tn, n4.mvfData);
    for (let i in n4.mvfData) i === "links" ? this.links = n4.mvfData.links.map((a4) => new fc({ mvfData: a4 })) : i === "pictures" ? this.images = n4.mvfData.pictures.map((a4) => {
      var u5;
      return a4.url ? new mc({ mvfData: G$1(F$1({}, a4), { url: (u5 = a4.url) != null ? u5 : "" }), mapData: P(this, Zi) }) : void 0;
    }).filter((a4) => a4 != null) : i === "website" ? n4.mvfData.website && (this.website = new fc({ mvfData: n4.mvfData.website })) : i === "icon" ? n4.mvfData.icon && (this.icon = new mc({ mvfData: { url: n4.mvfData.icon }, mapData: P(this, Zi) })) : Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), i) || Object.defineProperty(this, i, { enumerable: true, get() {
      return P(this, tn)[i];
    } });
  }
  static is(e) {
    return e.__type === Sf3.__type;
  }
  get spaces() {
    if (P(this, Ht).spaces) return P(this, Ht).spaces;
    if (P(this, tn).spaces == null) return P(this, Ht).spaces = [], P(this, Ht).spaces;
    P(this, Ht).spaces = [];
    for (let e = 0; e < P(this, tn).spaces.length; e++) {
      let n4 = P(this, Zi).getById("space", P(this, tn).spaces[e].id);
      n4 && P(this, Ht).spaces.push(n4);
    }
    return P(this, Ht).spaces;
  }
  get points() {
    if (P(this, Ht).points) return P(this, Ht).points;
    if (P(this, tn).spaces == null) return P(this, Ht).points = [], P(this, Ht).points;
    P(this, Ht).points = [];
    for (let e = 0; e < P(this, tn).spaces.length; e++) {
      let n4 = P(this, Zi).getById("point-of-interest", P(this, tn).spaces[e].id);
      n4 && P(this, Ht).points.push(n4);
    }
    return P(this, Ht).points;
  }
  get doors() {
    if (P(this, Ht).doors) return P(this, Ht).doors;
    if (P(this, tn).entrances == null) return P(this, Ht).doors = [], P(this, Ht).doors;
    P(this, Ht).doors = [];
    for (let e = 0; e < P(this, tn).entrances.length; e++) {
      let n4 = P(this, Zi).getById("door", P(this, tn).entrances[e].id);
      n4 && P(this, Ht).doors.push(n4);
    }
    return P(this, Ht).doors;
  }
  get connections() {
    var n4;
    if (P(this, Ht).connections) return P(this, Ht).connections;
    if (P(this, tn).connections == null) return P(this, Ht).connections = [], P(this, Ht).connections;
    let e = /* @__PURE__ */ new Set();
    for (let i = 0; i < P(this, tn).connections.length; i++) {
      let a4 = P(this, tn).connections[i], u5 = P(this, Zi).mvfConnectionsById[a4], d = (u5 == null ? [] : u5.nodes).map((m5) => P(this, Zi).getById("node", m5)).filter(Boolean);
      for (let m5 of d) {
        if (m5 == null) continue;
        let v3 = el([m5.coordinate.longitude, m5.coordinate.latitude]), S4 = ((n4 = P(this, Zi).connectionSpaceIdsByLatLon[v3]) != null ? n4 : []).map((I3) => P(this, Zi).connectionsById[I3]).filter((I3) => I3 != null);
        for (let I3 of S4) e.add(I3);
      }
    }
    return P(this, Ht).connections = Array.from(e), P(this, Ht).connections;
  }
  get annotations() {
    if (P(this, Ht).annotations) return P(this, Ht).annotations;
    if (P(this, tn).annotations == null) return P(this, Ht).annotations = [], P(this, Ht).annotations;
    P(this, Ht).annotations = [];
    for (let e = 0; e < P(this, tn).annotations.length; e++) {
      let n4 = P(this, Zi).getById("annotation", P(this, tn).annotations[e].id);
      n4 && P(this, Ht).annotations.push(n4);
    }
    return P(this, Ht).annotations;
  }
  get categories() {
    return P(this, Ht).categories ? P(this, Ht).categories : P(this, tn).categories == null ? (P(this, Ht).categories = [], P(this, Ht).categories) : (P(this, Ht).categories = P(this, tn).categories.map((e) => P(this, Zi).getById("location-category", e)).filter((e) => e != null), P(this, Ht).categories);
  }
  get mapObjects() {
    return P(this, Ht).mapObjects ? P(this, Ht).mapObjects : P(this, tn).obstructions == null ? (P(this, Ht).mapObjects = [], P(this, Ht).mapObjects) : (P(this, Ht).mapObjects = P(this, tn).obstructions.map((e) => P(this, Zi).getById("object", e.id)).filter((e) => e != null), P(this, Ht).mapObjects);
  }
  get areas() {
    return P(this, Ht).areas ? P(this, Ht).areas : P(this, tn).areas == null ? (P(this, Ht).areas = [], P(this, Ht).areas) : (P(this, Ht).areas = P(this, tn).areas.map((e) => P(this, Zi).getById("area", e.id)).filter((e) => e != null), P(this, Ht).areas);
  }
  get focusTarget() {
    if (P(this, Ht).focusTarget) return P(this, Ht).focusTarget;
    let e = [];
    for (let n4 of this.spaces) e.push(n4);
    for (let n4 of this.connections) e.push(...n4.coordinates);
    for (let n4 of this.doors) e.push(n4.focusTarget);
    for (let n4 of this.mapObjects) e.push(n4.focusTarget);
    for (let n4 of this.annotations) e.push(n4.focusTarget);
    for (let n4 of this.points) e.push(n4.focusTarget);
    for (let n4 of this.areas) e.push(n4.focusTarget);
    return P(this, Ht).focusTarget = e, e;
  }
  get openingHours() {
    var e;
    return P(this, Ht).openingHours ? P(this, Ht).openingHours : (P(this, Ht).openingHours = new R2((e = P(this, tn).openingHoursSpecification) != null ? e : []), P(this, Ht).openingHours);
  }
  get navigationTarget() {
    if (P(this, Ht).navigationTarget) return P(this, Ht).navigationTarget;
    let e = [];
    for (let n4 of this.spaces) e.push(n4);
    for (let n4 of this.connections) e.push(...n4.coordinates);
    for (let n4 of this.doors) e.push(n4.focusTarget);
    for (let n4 of this.mapObjects) e.push(n4.focusTarget);
    for (let n4 of this.annotations) e.push(n4.focusTarget);
    for (let n4 of this.points) e.push(n4.focusTarget);
    return P(this, Ht).navigationTarget = e, e;
  }
  toJSON() {
    return { __type: Sf3.__type, id: this.id, name: this.name };
  }
};
Zi = /* @__PURE__ */ new WeakMap(), Ht = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new WeakMap(), H$3(Sf2, "LocationProfile"), O(Sf2, "__type", "location-profile");
var KT = Sf2, ih2 = KT;
a();
var ep, Wo, Mf2, If2 = class If3 extends si {
  constructor(e, n4) {
    super(n4.mvfData.id);
    O(this, "__type", If3.__type);
    O(this, "id", "cat_");
    O(this, "name", "");
    O(this, "icon", "");
    Q$3(this, ep);
    Q$3(this, Wo, {});
    Q$3(this, Mf2);
    R$1(this, ep, e), R$1(this, Mf2, n4.mvfData);
    for (let i in n4.mvfData) Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), i) || Object.defineProperty(this, i, { enumerable: true, get() {
      return P(this, Mf2)[i];
    } });
  }
  static is(e) {
    return e.__type === If3.__type;
  }
  get parent() {
    return P(this, Wo).parent ? P(this, Wo).parent : (P(this, Wo).parent = P(this, Mf2).parent ? P(this, ep).getById("location-category", P(this, Mf2).parent) : void 0, P(this, Wo).parent);
  }
  get children() {
    return P(this, Wo).children ? P(this, Wo).children : (P(this, Wo).children = P(this, ep).locationCategoriesByParentId[this.id] || [], P(this, Wo).children);
  }
  get locationProfiles() {
    if (P(this, Wo).locationProfiles) return P(this, Wo).locationProfiles;
    let e = [];
    for (let n4 of P(this, ep).locationProfilesByCategoryId[this.id] || []) {
      let i = P(this, ep).getById("location-profile", n4.id);
      i && e.push(i);
    }
    return P(this, Wo).locationProfiles = e, e;
  }
  toJSON() {
    return { __type: If3.__type, id: this.id, name: this.name };
  }
};
ep = /* @__PURE__ */ new WeakMap(), Wo = /* @__PURE__ */ new WeakMap(), Mf2 = /* @__PURE__ */ new WeakMap(), H$3(If2, "LocationCategory"), O(If2, "__type", "location-category");
var QT = If2, Qg2 = QT;
var re$1, F2, WL, qm2, tw = class tw2 extends Se$1 {
  constructor(e, n4) {
    var u5, h, d, m5, v3;
    super();
    Q$3(this, F2);
    O(this, "Analytics");
    Q$3(this, re$1, {});
    O(this, "Query");
    O(this, "mvf");
    O(this, "outdoorViewToken");
    O(this, "objectEntranceNodeIdsByObstructionId");
    O(this, "obstructionIdByEntranceId");
    O(this, "venue");
    O(this, "tokenManager");
    O(this, "directions");
    O(this, "enterpriseMode", false);
    O(this, "nodesById");
    O(this, "spacesById");
    O(this, "floorsById");
    O(this, "floorStacksById");
    O(this, "facadesById");
    O(this, "facadesBySpaceId");
    O(this, "connectionsById");
    O(this, "objectsById");
    O(this, "doorsById");
    O(this, "pointsOfInterestById");
    O(this, "annotationsById");
    O(this, "areasById");
    O(this, "locationProfilesById");
    O(this, "locationCategoriesById");
    O(this, "locationProfilesByExternalId");
    O(this, "locationProfilesByCategoryId");
    O(this, "locationCategoriesByParentId");
    O(this, "doorsByNodeId");
    O(this, "mvfAnnotationsById");
    O(this, "mvfConnectionsById");
    O(this, "mvfConnectionsByNodeId");
    O(this, "mvfConnectionIdsByLatLon");
    O(this, "mvfEntrancesById");
    O(this, "mvfNodesById");
    O(this, "mvfObstructionById");
    O(this, "mvfSpacesById");
    O(this, "mvfFloorsById");
    O(this, "mvfFloorStacksById");
    O(this, "mvfAreasById");
    O(this, "spacesByExternalId");
    O(this, "nodesByExternalId");
    O(this, "objectsByExternalId");
    O(this, "poisByExternalId");
    O(this, "floorsByExternalId");
    O(this, "floorStacksByExternalId");
    O(this, "doorsByExternalId");
    O(this, "areasByExternalId");
    O(this, "connectionSpaceIdsByLatLon", {});
    O(this, "locationProfilesByAttachedFeatureId", {});
    O(this, "locationsById", {});
    O(this, "categoriesById", {});
    O(this, "mvfLocationsBySpaceId", {});
    O(this, "locationIdsByNodeId", {});
    O(this, "spaceIdsByNodeId", {});
    O(this, "connectionsByExternalId", {});
    O(this, "locationsByExternalId", {});
    O(this, "categoriesByExternalId", {});
    O(this, "destinationNodesIdsBySpaceId", {});
    O(this, "mvfNodesByFloorId");
    O(this, "mvfSpacesByFloorId");
    O(this, "mvfPoisByFloorId");
    O(this, "mvfEntrancesByFloorId");
    O(this, "mvfAnnotationsByFloorId");
    O(this, "localePacksUrls");
    O(this, "currentLanguage");
    O(this, "languagePacks", {});
    O(this, "tilesets", {});
    O(this, "binaryBundle");
    O(this, "envControl");
    O(this, "getMapDataOptions");
    Q$3(this, qm2);
    O(this, "getDirectionsMultiDestination", H$3((e4, n5, i5) => this.getDirections(e4, n5, G$1(F$1({}, i5), { multiDestination: true })), "getDirectionsMultiDestination"));
    O(this, "getDirections", H$3((e4, n5, i5) => {
      let { accessible: a10 = false, smoothing: u6 = true, multiDestination: h4 = false } = i5 || {}, d4 = typeof u6 == "object" ? u6.enabled : u6, m8 = typeof u6 == "object" ? u6.radius : void 0, v4 = (i5 == null ? void 0 : i5.zones) || [], x2 = { accessible: a10, zones: v4, smoothing: { enabled: d4 != null ? d4 : true, radius: m8 != null ? m8 : 0.75 }, excludedConnections: (i5 == null ? void 0 : i5.excludedConnections) || [], connectionIdWeightMap: (i5 == null ? void 0 : i5.connectionIdWeightMap) || {} };
      if (h4 && Array.isArray(n5)) {
        let S4 = Array.isArray(e4) ? e4 : [e4], I3 = [];
        for (let w3 of n5) {
          let E4 = Array.isArray(w3) ? w3 : [w3], T3 = this.directions.getDirections(S4, E4, x2, this);
          if (!T3) {
            B.error("getDirections failed due to missing directions for one of the segments");
            return;
          }
          S4 = E4, I3.push(T3);
        }
        return I3;
      } else {
        let S4 = Array.isArray(e4) ? e4 : [e4], I3 = Array.isArray(n5) ? n5 : [n5];
        if (Array.isArray(I3[0])) {
          B.error("getDirections does not support multi-destination without multisegment option");
          return;
        }
        S4[0].id && I3[0].id && this.Analytics.sendGetDirectionsEvent(S4[0].id, I3[0].id);
        try {
          return this.directions.getDirections(S4, I3, x2, this);
        } catch (w3) {
          B.error("Unable to get directions", w3);
          return;
        }
      }
    }, "getDirections"));
    O(this, "transformImageRequest", H$3(async (e4) => {
      var i5;
      if (this.enterpriseMode || !this.getMapDataOptions) return { url: e4 };
      if (!m7(e4)) return { url: e4 };
      if (g7(e4)) return { url: e4 };
      let n5 = ob(e4);
      if (!n5) return { url: e4 };
      try {
        let a10 = await ((i5 = this.tokenManager) == null ? void 0 : i5.getSasTokensAsync()), u6 = a10 == null ? void 0 : a10[n5.mapId];
        if (u6 == null) throw new Error("SAS token not found");
        let [h4] = e4.split("?");
        return { url: "".concat(h4, "?").concat(u6.token) };
      } catch (a10) {
        return B.error("Failed to append SAS token to image request. Requests for private images may fail.", a10), { url: e4 };
      }
    }, "transformImageRequest"));
    let i = (u5 = n4 == null ? void 0 : n4.env) != null ? u5 : Sc2();
    if (this.envControl = i, this.binaryBundle = n4 == null ? void 0 : n4.binaryBundle, this.Analytics = new Td2(), this.localePacksUrls = (h = n4 == null ? void 0 : n4.localePacksUrls) != null ? h : {}, this.mvf = e, this.outdoorViewToken = n4 == null ? void 0 : n4.outdoorViewToken, this.getMapDataOptions = n4 == null ? void 0 : n4.getMapDataOptions, ((d = e["tileset.json"]) == null ? void 0 : d.default) != null && (this.tilesets[e["tileset.json"].default.key] = e["tileset.json"].default, i.updateTileServerBaseUrl(e["tileset.json"].default.url), e["tileset.json"].others != null)) for (let x2 of e["tileset.json"].others) this.tilesets[x2.key] = x2;
    this.enterpriseMode = (m5 = n4 == null ? void 0 : n4.enterprise) != null ? m5 : false, this.tokenManager = n4 == null ? void 0 : n4.tokenManager;
    let a4 = S7(e, this);
    if (this.nodesById = a4.nodesById, this.spacesById = a4.spacesById, this.floorsById = a4.floorsById, this.floorStacksById = a4.floorStacksById, this.facadesById = a4.facadesById, this.facadesBySpaceId = a4.facadesBySpaceId, this.connectionsById = a4.connectionsById, this.objectsById = a4.objectsById, this.doorsById = a4.doorsById, this.pointsOfInterestById = a4.poisById, this.annotationsById = a4.annotationsById, this.areasById = a4.areasById, this.locationProfilesById = a4.locationProfilesById, this.locationCategoriesById = a4.locationCategoriesById, this.locationProfilesByCategoryId = a4.locationProfilesByCategoryId, this.locationCategoriesByParentId = a4.locationCategoriesByParentId, this.spacesByExternalId = a4.spacesByExternalId, this.nodesByExternalId = a4.nodesByExternalId, this.objectsByExternalId = a4.objectsByExternalId, this.floorsByExternalId = a4.floorsByExternalId, this.locationProfilesByExternalId = a4.locationProfilesByExternalId, this.floorStacksByExternalId = a4.floorStacksByExternalId, this.poisByExternalId = a4.poisByExternalId, this.doorsByExternalId = a4.doorsByExternalId, this.areasByExternalId = a4.areasByExternalId, this.mvfAnnotationsById = a4.mvfAnnotationsById, this.mvfConnectionsById = a4.mvfConnectionsById, this.mvfConnectionsByNodeId = a4.mvfConnectionsByNodeId, this.mvfConnectionIdsByLatLon = a4.mvfConnectionIdsByLatLon, this.mvfEntrancesById = a4.mvfEntrancesById, this.mvfNodesById = a4.mvfNodesById, this.mvfObstructionById = a4.mvfObstructionById, this.mvfSpacesById = a4.mvfSpacesById, this.mvfFloorsById = a4.mvfFloorsById, this.mvfFloorStacksById = a4.mvfFloorStacksById, this.mvfNodesByFloorId = a4.mvfNodesByFloorId, this.mvfSpacesByFloorId = a4.mvfSpacesByFloorId, this.mvfPoisByFloorId = a4.mvfPoisByFloorId, this.mvfEntrancesByFloorId = a4.mvfEntrancesByFloorId, this.mvfAnnotationsByFloorId = a4.mvfAnnotationsByFloorId, this.mvfAreasById = a4.mvfAreasById, this.doorsByNodeId = a4.doorsByNodeId, this.objectEntranceNodeIdsByObstructionId = a4.objectEntranceNodeIdsByObstructionId, this.obstructionIdByEntranceId = a4.obstructionIdByEntranceId, this.connectionSpaceIdsByLatLon = a4.connectionIdsByLatLon, this.locationProfilesByAttachedFeatureId = a4.locationProfilesByAttachedFeatureId, this.enterpriseMode) {
      let x2 = C7(e, this);
      if (this.locationsById = x2.locationsById, this.categoriesById = x2.categoriesById, this.mvfLocationsBySpaceId = x2.mvfLocationsBySpaceId, this.locationIdsByNodeId = x2.locationIdsByNodeId, this.spaceIdsByNodeId = x2.spaceIdsByNodeId, this.connectionsByExternalId = x2.connectionsByExternalId, this.locationsByExternalId = x2.locationsByExternalId, this.categoriesByExternalId = x2.categoriesByExternalId, this.destinationNodesIdsBySpaceId = x2.destinationNodesIdsBySpaceId, x2.venue.name != null) {
        this.venue = new lb(this, { mvfData: x2.venue });
        let S4 = {};
        for (let I3 in x2.mvfLocationsById) S4[I3] = x2.mvfLocationsById[I3];
        for (let I3 in x2.locationInstancesById) S4[I3] = x2.locationInstancesById[I3];
        this.languagePacks[this.venue.defaultLanguage.code] = { type: "initial", optimized: { "enterprise-location": S4, "enterprise-category": x2.mvfCategoriesById, "floor-stack": a4.mvfFloorStacksById, floor: a4.mvfFloorsById } }, (v3 = n4 == null ? void 0 : n4.languagePacks) == null || v3.forEach(({ language: I3, localePack: w3 }) => {
          this.languagePacks[I3.code] = $C(w3);
        }), this.currentLanguage = this.venue.defaultLanguage;
      }
    }
    this.directions = new Xm2({ nodes: e["node.geojson"], geojsonCollection: e.enterprise ? e.space : e.obstruction, connections: e["connection.json"], groupBy: "map", multiplicativeDistanceWeightScaling: !this.enterpriseMode }), this.Query = new _0(this);
  }
  getEnv() {
    let e = this;
    return { get baseUri() {
      var n4;
      return e.envControl.getBaseUri((n4 = e.enterpriseMode) != null ? n4 : false);
    }, get baseAuthUri() {
      return e.envControl.getBaseAuthUri();
    }, get analyticsBaseUri() {
      return e.envControl.getAnalyticsBaseUri();
    }, get tileServerUri() {
      return e.envControl.getTileServerUri();
    } };
  }
  get mapName() {
    return this.mvf["manifest.geojson"].features[0].properties.name;
  }
  get organizationId() {
    var e;
    return (e = this.mvf["manifest.geojson"].features[0].properties.org_id) != null ? e : "";
  }
  get mapCenter() {
    return new ve2(this.mvf["manifest.geojson"].features[0].geometry.coordinates[1], this.mvf["manifest.geojson"].features[0].geometry.coordinates[0]);
  }
  get naturalBearing() {
    var e;
    return (e = this.mvf["manifest.geojson"].features[0].properties.naturalBearing) != null ? e : 0;
  }
  get spaces() {
    return P(this, re$1).spaces == null && (P(this, re$1).spaces = globalThis.Object.values(this.spacesById)), P(this, re$1).spaces;
  }
  get objects() {
    return P(this, re$1).objects == null && (P(this, re$1).objects = globalThis.Object.values(this.objectsById)), P(this, re$1).objects;
  }
  get connections() {
    return P(this, re$1).connections == null && (P(this, re$1).connections = globalThis.Object.values(this.connectionsById)), P(this, re$1).connections;
  }
  get floors() {
    return P(this, re$1).floors == null && (P(this, re$1).floors = globalThis.Object.values(this.floorsById)), P(this, re$1).floors;
  }
  get floorStacks() {
    return P(this, re$1).floorStacks == null && (P(this, re$1).floorStacks = globalThis.Object.values(this.floorStacksById)), P(this, re$1).floorStacks;
  }
  get facades() {
    return P(this, re$1).facades == null && (P(this, re$1).facades = globalThis.Object.values(this.facadesById)), P(this, re$1).facades;
  }
  get doors() {
    return P(this, re$1).doors == null && (P(this, re$1).doors = globalThis.Object.values(this.doorsById)), P(this, re$1).doors;
  }
  get pointsOfInterest() {
    return P(this, re$1).pointsOfInterest == null && (P(this, re$1).pointsOfInterest = globalThis.Object.values(this.pointsOfInterestById)), P(this, re$1).pointsOfInterest;
  }
  get annotations() {
    return P(this, re$1).annotations == null && (P(this, re$1).annotations = globalThis.Object.values(this.annotationsById)), P(this, re$1).annotations;
  }
  get areas() {
    return P(this, re$1).areas == null && (P(this, re$1).areas = globalThis.Object.values(this.areasById)), P(this, re$1).areas;
  }
  get nodes() {
    return P(this, re$1).nodes == null && (P(this, re$1).nodes = globalThis.Object.values(this.nodesById)), P(this, re$1).nodes;
  }
  get locations() {
    return P(this, re$1).locations == null && (P(this, re$1).locations = globalThis.Object.values(this.locationsById)), globalThis.Object.values(this.locationsById);
  }
  get categories() {
    return P(this, re$1).categories == null && (P(this, re$1).categories = globalThis.Object.values(this.categoriesById)), globalThis.Object.values(this.categoriesById);
  }
  get locationProfiles() {
    return P(this, re$1).locationProfiles == null && (P(this, re$1).locationProfiles = globalThis.Object.values(this.locationProfilesById)), P(this, re$1).locationProfiles;
  }
  get locationCategories() {
    return P(this, re$1).locationCategories == null && (P(this, re$1).locationCategories = globalThis.Object.values(this.locationCategoriesById)), P(this, re$1).locationCategories;
  }
  get mvfFloors() {
    return P(this, re$1).mvfFloors == null && (P(this, re$1).mvfFloors = globalThis.Object.values(this.mvfFloorsById)), P(this, re$1).mvfFloors;
  }
  get mvfFloorStacks() {
    return P(this, re$1).mvfFloorStacks == null && (P(this, re$1).mvfFloorStacks = globalThis.Object.values(this.mvfFloorStacksById)), P(this, re$1).mvfFloorStacks;
  }
  getByType(e) {
    switch (e) {
      case "location-profile":
        return this.locationProfiles;
      case "location-category":
        return this.locationCategories;
      case "area":
        return this.areas;
      case "node":
        return this.nodes;
      case "space":
        return this.spaces;
      case "door":
        return this.doors;
      case "floor":
        return this.floors;
      case "floor-stack":
        return this.floorStacks;
      case "connection":
        return this.connections;
      case "object":
        return this.objects;
      case "point-of-interest":
        return this.pointsOfInterest;
      case "annotation":
        return this.annotations;
      case "enterprise-location":
        return this.locations;
      case "enterprise-category":
        return this.categories;
      case "enterprise-venue":
        return this.venue;
      case "facade":
        return this.facades;
      default:
        return [];
    }
  }
  getById(e, n4) {
    let i = { "location-profile": this.locationProfilesById, "location-category": this.locationCategoriesById, space: this.spacesById, floor: this.floorsById, "floor-stack": this.floorStacksById, facade: this.facadesById, node: this.nodesById, door: this.doorsById, connection: this.connectionsById, "mvf-connection": H$3((h) => S$1(this, F2, WL).call(this, this.mvfConnectionsById[h]), "mvf-connection"), object: this.objectsById, "point-of-interest": this.pointsOfInterestById, annotation: this.annotationsById, area: this.areasById, "enterprise-location": this.locationsById, "enterprise-category": this.categoriesById }, a4 = H$3((h) => {
      let d = i[h];
      if (d != null) return typeof d == "function" ? d(n4) : d[n4];
    }, "getItemFromCollection"), u5 = H$3(() => {
      for (let h of Object.keys(i)) {
        let d = a4(h);
        if (d != null) return d;
      }
    }, "getItemFromAllCollections");
    return e === "unknown" ? u5() : a4(e);
  }
  getByExternalId(e, n4) {
    var i, a4, u5, h, d, m5, v3, x2, S4, I3, w3, E4;
    switch (e) {
      case "location-profile":
        return (i = this.locationProfilesByExternalId[n4]) != null ? i : [];
      case "location-category":
        return [];
      case "space":
        return (a4 = this.spacesByExternalId[n4]) != null ? a4 : [];
      case "floor":
        return (u5 = this.floorsByExternalId[n4]) != null ? u5 : [];
      case "floor-stack":
        return (h = this.floorStacksByExternalId[n4]) != null ? h : [];
      case "node":
        return (d = this.nodesByExternalId[n4]) != null ? d : [];
      case "door":
        return (m5 = this.doorsByExternalId[n4]) != null ? m5 : [];
      case "connection":
        return (v3 = this.connectionsByExternalId[n4]) != null ? v3 : [];
      case "object":
        return (x2 = this.objectsByExternalId[n4]) != null ? x2 : [];
      case "point-of-interest":
        return (S4 = this.poisByExternalId[n4]) != null ? S4 : [];
      case "area":
        return (I3 = this.areasByExternalId[n4]) != null ? I3 : [];
      case "enterprise-location":
        return (w3 = this.locationsByExternalId[n4]) != null ? w3 : [];
      case "enterprise-category":
        return (E4 = this.categoriesByExternalId[n4]) != null ? E4 : [];
      default:
        return [];
    }
  }
  getMapDataById(e) {
    var n4, i, a4, u5, h, d, m5, v3, x2, S4;
    return (S4 = (x2 = (v3 = (m5 = (d = (h = (u5 = (a4 = (i = (n4 = this.spacesById[e]) != null ? n4 : this.floorsById[e]) != null ? i : this.floorStacksById[e]) != null ? a4 : this.facadesById[e]) != null ? u5 : this.nodesById[e]) != null ? h : this.doorsById[e]) != null ? d : this.connectionsById[e]) != null ? m5 : this.objectsById[e]) != null ? v3 : this.pointsOfInterestById[e]) != null ? x2 : this.annotationsById[e]) != null ? S4 : this.areasById[e];
  }
  getMVFFeatureById(e, n4) {
    switch (e) {
      case "space":
        return this.mvfSpacesById[n4];
      case "node":
        return this.mvfNodesById[n4];
      case "obstruction":
        return this.mvfObstructionById[n4];
      case "floor":
        return this.mvfFloorsById[n4];
      case "floor-stack":
        return this.mvfFloorStacksById[n4];
      case "connection":
        return this.mvfConnectionsById[n4];
      case "entrance":
        return this.mvfEntrancesById[n4];
      case "annotation":
        return this.mvfAnnotationsById[n4];
      case "area":
        return this.mvfAreasById[n4];
      default:
        throw new Error("Unknown MVF feature type: ".concat(e));
    }
  }
  getMVFFeatureByNodeId(e, n4) {
    switch (e) {
      case "connection":
        return this.mvfConnectionsByNodeId[n4];
      default:
        throw new Error("Unsupported MVF feature type: ".concat(e));
    }
  }
  getMVFFeatureByType(e) {
    switch (e) {
      case "floor-stack":
        return this.mvfFloorStacks;
      case "floor":
        return this.mvfFloors;
      default:
        throw new Error("Unsupported MVF feature type: ".concat(e));
    }
  }
  getPropTranslation(e, n4, i, a4) {
    var d, m5;
    if (!this.currentLanguage) return a4;
    let { code: u5 } = this.currentLanguage, h = (m5 = (d = this.languagePacks[u5]) == null ? void 0 : d.optimized) == null ? void 0 : m5[e];
    if (h) {
      let v3 = h[i];
      if (v3 != null && v3[n4] !== void 0) return v3[n4];
    }
    return a4;
  }
  findPreferredLanguage(e) {
    if (!this.venue) return;
    let n4 = L2(this.venue, e);
    return (e == null ? void 0 : e.languageCode) != null && e.languageCode.toLowerCase() !== n4.code.toLowerCase() && B.warn('Language code "'.concat(e.languageCode, '" could not be found in the venue. Using "').concat(n4.code, '" instead.')), n4;
  }
  async changeLanguage(e) {
    var h;
    let n4 = e.toLowerCase();
    if (!n4) {
      B.error("Language code must be defined.");
      return;
    }
    if (!this.currentLanguage || !this.venue) {
      B.error("Changing the language is not supported for this map.");
      return;
    }
    let i = this.currentLanguage.code, a4 = (h = this.venue) == null ? void 0 : h.languages.find(({ code: d }) => d.toLowerCase() === n4.toLowerCase());
    if (!a4) {
      B.warn('Language code "'.concat(n4, '" could not be found in the venue.'));
      return;
    }
    if (i === a4.code) return;
    let u5 = this.languagePacks[a4.code];
    if (!u5) {
      let d = this.localePacksUrls[a4.code];
      if (!d) {
        B.error('Locale pack URL not found for language code "'.concat(a4.code, '".'));
        return;
      }
      P(this, qm2) && P(this, qm2).abort();
      let m5 = new AbortController();
      R$1(this, qm2, m5);
      let v3;
      try {
        v3 = await W7(d, { signal: m5.signal });
      } catch (x2) {
        B.error('Failed to download language pack for language code "'.concat(a4.code, '".'), x2);
        return;
      }
      if (!v3 || m5.signal.aborted) return;
      u5 = $C(v3), this.languagePacks[a4.code] = u5;
    }
    this.Analytics.sendChangeLanguageEvent({ fromLanguage: this.currentLanguage.code }), this.currentLanguage = a4, this.publish("language-change", this.currentLanguage);
  }
  getDistance(e, n4) {
    let i = Yg2(e), a4 = Yg2(n4);
    return ps([i.longitude, i.latitude], [a4.longitude, a4.latitude]);
  }
  async toJSONBundle({ downloadLanguagePacks: e = true } = {}) {
    var i;
    let n4 = [];
    if (e && this.enterpriseMode) {
      let a4 = new AbortController();
      for (let u5 of ((i = this.venue) == null ? void 0 : i.languages) || []) try {
        if (this.localePacksUrls[u5.code]) {
          let h = await TS(this.localePacksUrls[u5.code], { signal: a4.signal }), d = await Od2(h);
          d && n4.push({ language: { code: u5.code, name: u5.name }, localePack: d });
        }
      } catch (h) {
        B.warn("failed downloading language pack", h);
      }
    }
    return { type: "json", options: { enterprise: this.enterpriseMode }, languagePacks: n4, main: this.mvf };
  }
  async toBinaryBundle({ downloadLanguagePacks: e = true } = {}) {
    var i;
    if (!this.binaryBundle) {
      B.error("binary bundle not found");
      return;
    }
    let n4 = [];
    if (e && this.enterpriseMode) {
      let a4 = new AbortController();
      for (let u5 of ((i = this.venue) == null ? void 0 : i.languages) || []) try {
        if (this.localePacksUrls[u5.code]) {
          let h = await TS(this.localePacksUrls[u5.code], { signal: a4.signal });
          h && n4.push({ language: { code: u5.code, name: u5.name }, localePack: h });
        }
      } catch (h) {
        B.warn("failed downloading language pack", h);
      }
    }
    return { type: "binary", options: { enterprise: this.enterpriseMode }, languagePacks: n4, main: this.binaryBundle };
  }
  destroy() {
    for (let e of globalThis.Object.keys(P(this, re$1))) P(this, re$1)[e] = null;
  }
};
re$1 = /* @__PURE__ */ new WeakMap(), F2 = /* @__PURE__ */ new WeakSet(), WL = H$3(function(e) {
  var h;
  let n4 = (h = e == null ? void 0 : e.nodes) == null ? void 0 : h[0], i = this.getById("node", n4);
  if (i == null) return;
  let a4 = el([i.coordinate.longitude, i.coordinate.latitude]), u5 = this.connectionSpaceIdsByLatLon[a4];
  return u5 == null ? void 0 : u5.map((d) => this.connectionsById[d]).find((d) => d != null);
}, "#getConnectionFromMVFConnection"), qm2 = /* @__PURE__ */ new WeakMap(), H$3(tw, "MapDataInternal");
var bf2 = tw;
var Wm, wf2, Zm, El, Tf2 = class Tf3 extends la {
  constructor(e, n4) {
    super(n4.mvfData.id, e);
    O(this, "__type", Tf3.__type);
    Q$3(this, Wm);
    Q$3(this, wf2);
    Q$3(this, Zm);
    Q$3(this, El, {});
    R$1(this, Wm, n4.mvfData), R$1(this, wf2, e), R$1(this, Zm, n4.floorStackId);
  }
  static is(e) {
    return e.__type === Tf3.__type;
  }
  get floorStack() {
    return P(this, wf2).getById("floor-stack", P(this, Zm));
  }
  get spaces() {
    if (!P(this, El).spaces) {
      P(this, El).spaces = [];
      for (let e of P(this, Wm).spaces) {
        let n4 = P(this, wf2).getById("space", e.spaceId);
        n4 && P(this, El).spaces.push(n4);
      }
    }
    return P(this, El).spaces;
  }
  get center() {
    if (!P(this, El).center) {
      let e = { type: "FeatureCollection", features: [] };
      for (let i of this.spaces) {
        let a4 = P(this, wf2).mvfSpacesById[i.id];
        a4 && e.features.push(a4);
      }
      if (e.features.length === 0) throw new Y("No geometry found for facade!");
      let n4 = qa(e);
      P(this, El).center = new ve2({ latitude: n4.geometry.coordinates[1], longitude: n4.geometry.coordinates[0], floorId: P(this, Wm).spaces[0].floorId });
    }
    return P(this, El).center;
  }
  get focusTarget() {
    return this.spaces;
  }
  get anchorTarget() {
    return this.center;
  }
  toJSON() {
    return { id: this.id, __type: Tf3.__type, floorStackId: P(this, Zm), floorStack: this.floorStack, spaces: this.spaces };
  }
};
Wm = /* @__PURE__ */ new WeakMap(), wf2 = /* @__PURE__ */ new WeakMap(), Zm = /* @__PURE__ */ new WeakMap(), El = /* @__PURE__ */ new WeakMap(), H$3(Tf2, "Facade"), O(Tf2, "__type", "facade");
var ew = Tf2, Ps = ew;
a();
a();
a();
a();
var S = class S3 extends Error {
  constructor(t) {
    super("".concat(t, " must be used within a MapView component."));
  }
};
H$3(S, "MapViewNullError");
var m = S;
var p = createContext({ mapData: void 0, mapView: void 0 });
function q() {
  let { mapData: e, mapView: t } = useContext(p);
  if (!e || !t) throw new m("useMap");
  return { mapData: e, mapView: t };
}
H$3(q, "useMap");
a();
function s(e, t) {
  useEffect(() => {
    t != null && typeof e == "function" && e(t);
  }, [e, t]);
}
H$3(s, "useOnLoad");
function H4(e) {
  let { mapView: t } = useContext(p), r5 = useRef(), [o4, i] = useState(null);
  return useEffect(() => {
    if (t == null) throw new m("Marker");
    return r5.current = t.Markers.add(e.target, "", G$1(F$1({}, e.options), { dynamicResize: true })), i(r5.current), () => {
      t == null || r5.current == null || t.Markers.remove(r5.current);
    };
  }, [t, e.target]), useEffect(() => {
    o4 && (t == null || t.updateState(o4, F$1({}, e.options)));
  }, [e.options]), s(e.onLoad, o4), t == null || o4 == null ? null : createPortal(e.children, o4.contentEl, o4.id);
}
H$3(H4, "Marker");
function Z(e) {
  let { mapView: t } = useContext(p), [r5, o4] = useState(null), i = useRef(E()), f = useRef(e.target), c = useCallback((l) => {
    var P4;
    o4(l), (P4 = e.onLoad) == null || P4.call(e, l);
  }, [e.onLoad]);
  useEffect(() => {
    if (t == null) throw new m("Marker");
    if (r5 && r5.target !== e.target) {
      let { duration: l = 300, easing: P4 = "linear" } = e;
      t.Markers.animateTo(r5, e.target, { duration: l, easing: P4 });
    }
  }, [t, e.target, r5]);
  let M3 = useMemo(() => G$1(F$1({}, e), { duration: void 0, easing: void 0 }), [e.duration, e.easing]);
  return React__default.createElement(H4, G$1(F$1({}, M3), { key: i.current, target: f.current, onLoad: c }));
}
H$3(Z, "AnimatedMarker");
a();
function re(e) {
  let { mapView: t } = useContext(p), r5 = useRef(), [o4, i] = useState(void 0);
  return useEffect(() => {
    if (t == null) throw new m("Label");
    return r5.current = t.Labels.add(e.target, e.text, e.options), i(r5.current), () => {
      t == null || r5.current == null || t.Labels.remove(r5.current);
    };
  }, [t, e.target]), useEffect(() => {
    r5.current && (t == null || t.updateState(r5.current, F$1({ text: e.text }, e.options)));
  }, [e.text, e.options]), s(e.onLoad, o4), null;
}
H$3(re, "Label");
a();
function ie(e, t) {
  let { mapView: r5 } = useContext(p), o4 = useCallback((i) => t(i), [t]);
  useEffect(() => {
    if (r5 == null) throw new m("useEvent");
    return r5.on(e, o4), () => {
      r5 != null && r5.off(e, o4);
    };
  }, [r5, e, t]);
}
H$3(ie, "useEvent");
a();
function de(e) {
  let { mapView: t } = useContext(p), r5 = useRef(), [o4, i] = useState(void 0);
  return useEffect(() => {
    if (t == null) throw new m("Path");
    let f = t.Paths.add(e.coordinate, e.options);
    return f.animation.then(() => {
      var c;
      (c = e.onDrawComplete) == null || c.call(e);
    }), i(f), r5.current = f, () => {
      r5.current && t.Paths.remove(r5.current);
    };
  }, [t, e.coordinate, e.options]), s(e.onLoad, o4), null;
}
H$3(de, "Path");
a();
var Me = { width: "100%", height: "100%", position: "relative" };
function Pe(e) {
  let V3 = e, { mapData: t, options: r5, style: o4, fallback: i, children: f } = V3, c = J$1(V3, ["mapData", "options", "style", "fallback", "children"]), M3 = useRef(false), [l, P4] = useState(void 0), [x2, y4] = useState(true), h = useRef(null), A3 = useMemo(() => r5, []), E4 = useCallback(() => {
    if (t && (h != null && h.current)) {
      if (l) return;
      AL(h.current, t, A3).then((T3) => {
        P4(T3);
      }).catch((T3) => {
        B.error("Failed to render MapView", T3);
      }).finally(() => {
        y4(false);
      });
    }
  }, [t, h.current, A3]);
  return useEffect(() => {
    M3.current || (M3.current = true, E4());
  }, [E4]), s(e.onLoad, l), React__default.createElement(p.Provider, { value: { mapData: t, mapView: l } }, React__default.createElement("div", F$1({ "data-testid": "mappedin-map", ref: h, style: F$1(F$1({}, Me), o4) }, c)), x2 ? React__default.createElement(React__default.Fragment, null, i) : f);
}
H$3(Pe, "MapView");
a();
function xe(e) {
  let { mapView: t } = useContext(p), [r5, o4] = useState(false);
  return useEffect(() => {
    if (t == null) throw new m("Navigation");
    return t.Navigation.draw(e.directions, e.options).then(() => {
      var i;
      o4(true), (i = e.onDrawComplete) == null || i.call(e);
    }), () => {
      t.Navigation.clear();
    };
  }, [t, e.directions, e.options]), useEffect(() => {
    r5 !== false && typeof e.onLoad == "function" && e.onLoad();
  }, [e.onLoad, r5]), null;
}
H$3(xe, "Navigation");
a();
function Se(e) {
  let { mapView: t } = useContext(p), r5 = useRef(), [o4, i] = useState(void 0);
  return useEffect(() => {
    if (t == null) throw new Error("MapView not initialized");
    return r5.current = t.Shapes.add(e.geometry, e.style, e.floor), i(r5.current), () => {
      t == null || r5.current == null || t.Shapes.remove(r5.current);
    };
  }, [t, e.geometry, e.style, e.floor]), s(e.onLoad, o4), null;
}
H$3(Se, "Shape");
a();
function Ae2(e) {
  let { mapView: t } = useContext(p), r5 = useRef(), [o4, i] = useState(void 0);
  return useEffect(() => {
    if (t == null) throw new m("Model");
    return r5.current = t.Models.add(e.target, e.url, e.options), i(r5.current), () => {
      t == null || r5.current == null || t.Models.remove(r5.current);
    };
  }, [t, e.url]), useEffect(() => {
    r5.current && (t == null || t.updateState(r5.current, F$1({ position: e.target }, e.options)));
  }, [e.options, e.target]), s(e.onLoad, o4), null;
}
H$3(Ae2, "Model");
a();
function De2(e) {
  let [t, r5] = useState(void 0), [o4, i] = useState(true), [f, c] = useState(void 0), M3 = useRef(0), l = useMemo(() => e, []), P4 = useCallback(() => {
    let x2 = ++M3.current;
    i(true), c(void 0), DL(l).then((y4) => {
      M3.current === x2 && r5(y4);
    }).catch((y4) => {
      M3.current === x2 && (B.error("Failed to fetch MapData", y4), c(y4));
    }).finally(() => {
      M3.current === x2 && i(false);
    });
  }, [l]);
  return useEffect(() => {
    P4();
  }, [P4]), { mapData: t, isLoading: o4, error: f };
}
H$3(De2, "useMapData");
var tr = FZ;
const mappedin = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnimatedMarker: Z,
  Label: re,
  MapView: Pe,
  Marker: H4,
  Model: Ae2,
  Navigation: xe,
  Path: de,
  Shape: Se,
  default: tr,
  useEvent: ie,
  useMap: q,
  useMapData: De2
}, Symbol.toStringTag, { value: "Module" }));
function TypographyMuted({ children }) {
  return /* @__PURE__ */ jsx("p", { className: "text-muted-foreground text-sm", children });
}
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
function Select({
  ...props
}) {
  return /* @__PURE__ */ jsx(SelectPrimitive.Root, { "data-slot": "select", ...props });
}
function SelectGroup({
  ...props
}) {
  return /* @__PURE__ */ jsx(SelectPrimitive.Group, { "data-slot": "select-group", ...props });
}
function SelectValue({
  ...props
}) {
  return /* @__PURE__ */ jsx(SelectPrimitive.Value, { "data-slot": "select-value", ...props });
}
function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs(
    SelectPrimitive.Trigger,
    {
      "data-slot": "select-trigger",
      "data-size": size,
      className: cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx(SelectPrimitive.Icon, { asChild: true, children: /* @__PURE__ */ jsx(ChevronDownIcon, { className: "size-4 opacity-50" }) })
      ]
    }
  );
}
function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}) {
  return /* @__PURE__ */ jsx(SelectPrimitive.Portal, { children: /* @__PURE__ */ jsxs(
    SelectPrimitive.Content,
    {
      "data-slot": "select-content",
      className: cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
        position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      ),
      position,
      ...props,
      children: [
        /* @__PURE__ */ jsx(SelectScrollUpButton, {}),
        /* @__PURE__ */ jsx(
          SelectPrimitive.Viewport,
          {
            className: cn(
              "p-1",
              position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
            ),
            children
          }
        ),
        /* @__PURE__ */ jsx(SelectScrollDownButton, {})
      ]
    }
  ) });
}
function SelectLabel({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SelectPrimitive.Label,
    {
      "data-slot": "select-label",
      className: cn("text-muted-foreground px-2 py-1.5 text-xs", className),
      ...props
    }
  );
}
function SelectItem({
  className,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs(
    SelectPrimitive.Item,
    {
      "data-slot": "select-item",
      className: cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ jsx(SelectPrimitive.ItemIndicator, { children: /* @__PURE__ */ jsx(CheckIcon, { className: "size-4" }) }) }),
        /* @__PURE__ */ jsx(SelectPrimitive.ItemText, { children })
      ]
    }
  );
}
function SelectScrollUpButton({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SelectPrimitive.ScrollUpButton,
    {
      "data-slot": "select-scroll-up-button",
      className: cn(
        "flex cursor-default items-center justify-center py-1",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsx(ChevronUpIcon, { className: "size-4" })
    }
  );
}
function SelectScrollDownButton({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SelectPrimitive.ScrollDownButton,
    {
      "data-slot": "select-scroll-down-button",
      className: cn(
        "flex cursor-default items-center justify-center py-1",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsx(ChevronDownIcon, { className: "size-4" })
    }
  );
}
function Label({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    LabelPrimitive.Root,
    {
      "data-slot": "label",
      className: cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      ),
      ...props
    }
  );
}
const { useMap: useMap$9 } = mappedin;
function FloorSelector() {
  const { mapData, mapView } = useMap$9();
  const [currentFloorStackId, setCurrentFloorStackId] = useState(
    mapView.currentFloorStack.id
  );
  const [currentFloorId, setCurrentFloorId] = useState(mapView.currentFloor.id);
  function handleFloorStackChange(floorStackId) {
    mapView.setFloorStack(floorStackId);
    setCurrentFloorStackId(floorStackId);
  }
  function handleFloorChange(floorId) {
    mapView.setFloor(floorId);
    setCurrentFloorId(floorId);
  }
  const floorStacks = mapData.getByType("floor-stack");
  const floors = floorStacks.find((floorStack) => floorStack.id == currentFloorStackId)?.floors.sort((a4, b) => a4.elevation - b.elevation);
  mapView.on("floor-change", (payload) => {
    setCurrentFloorStackId(payload.floor.floorStack.id);
    setCurrentFloorId(payload.floor.id);
  });
  if (floorStacks.length < 2 && (!floors || floors.length < 2)) return null;
  return /* @__PURE__ */ jsxs("div", { className: "flex gap-3 p-3 bg-white/70 backdrop-blur-3xl rounded-xl", children: [
    floorStacks.length > 1 && /* @__PURE__ */ jsxs("div", { className: "space-y-1", children: [
      /* @__PURE__ */ jsx(Label, { children: "Building" }),
      /* @__PURE__ */ jsxs(
        Select,
        {
          value: currentFloorStackId,
          onValueChange: handleFloorStackChange,
          children: [
            /* @__PURE__ */ jsx(SelectTrigger, { className: "w-[180px]", children: /* @__PURE__ */ jsx(SelectValue, { placeholder: "Select a building" }) }),
            /* @__PURE__ */ jsx(SelectContent, { children: floorStacks.map((floorStack) => /* @__PURE__ */ jsx(SelectItem, { value: floorStack.id, children: floorStack.name }, floorStack.id)) })
          ]
        }
      )
    ] }),
    floors && floors.length > 1 && /* @__PURE__ */ jsxs("div", { className: "space-y-1", children: [
      /* @__PURE__ */ jsx(Label, { children: "Floor" }),
      /* @__PURE__ */ jsxs(Select, { value: currentFloorId, onValueChange: handleFloorChange, children: [
        /* @__PURE__ */ jsx(SelectTrigger, { className: "w-[180px]", children: /* @__PURE__ */ jsx(SelectValue, { placeholder: "Select a floor" }) }),
        /* @__PURE__ */ jsx(SelectContent, { children: floors?.map((floor) => /* @__PURE__ */ jsx(SelectItem, { value: floor.id, children: floor.name }, floor.id)) })
      ] })
    ] })
  ] });
}
const { useMap: useMap$8 } = mappedin;
function InteractionManager() {
  const { mapView, mapData } = useMap$8();
  useEffect(() => {
    if (!mapView || !mapData) return;
    mapData.getByType("space").filter(({ name }) => name?.length).forEach((space2) => {
      mapView.updateState(space2, {
        interactive: true,
        hoverColor: "lightgrey"
      });
    });
  }, [mapView, mapData]);
  return null;
}
const AppContext = createContext({});
function perlinNoise1D(seed, x2) {
  const hash = (str) => {
    let hash2 = 0;
    for (let i = 0; i < str.length; i++) {
      hash2 = (hash2 << 5) - hash2 + str.charCodeAt(i);
      hash2 |= 0;
    }
    return hash2;
  };
  const noise = Math.sin(hash(seed) + x2 * 0.1) * 0.5 + 0.5;
  return noise;
}
const THEMES = { light: "", dark: ".dark" };
const ChartContext = React.createContext(null);
function useChart() {
  const context = React.useContext(ChartContext);
  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />");
  }
  return context;
}
function ChartContainer({
  id: id3,
  className,
  children,
  config,
  ...props
}) {
  const uniqueId = React.useId();
  const chartId = `chart-${id3 || uniqueId.replace(/:/g, "")}`;
  return /* @__PURE__ */ jsx(ChartContext.Provider, { value: { config }, children: /* @__PURE__ */ jsxs(
    "div",
    {
      "data-slot": "chart",
      "data-chart": chartId,
      className: cn(
        "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsx(ChartStyle, { id: chartId, config }),
        /* @__PURE__ */ jsx(RechartsPrimitive.ResponsiveContainer, { children })
      ]
    }
  ) });
}
const ChartStyle = ({ id: id3, config }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config2]) => config2.theme || config2.color
  );
  if (!colorConfig.length) {
    return null;
  }
  return /* @__PURE__ */ jsx(
    "style",
    {
      dangerouslySetInnerHTML: {
        __html: Object.entries(THEMES).map(
          ([theme, prefix]) => `
${prefix} [data-chart=${id3}] {
${colorConfig.map(([key, itemConfig]) => {
            const color = itemConfig.theme?.[theme] || itemConfig.color;
            return color ? `  --color-${key}: ${color};` : null;
          }).join("\n")}
}
`
        ).join("\n")
      }
    }
  );
};
const ChartTooltip = RechartsPrimitive.Tooltip;
function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey
}) {
  const { config } = useChart();
  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null;
    }
    const [item] = payload;
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`;
    const itemConfig = getPayloadConfigFromPayload(config, item, key);
    const value = !labelKey && typeof label === "string" ? config[label]?.label || label : itemConfig?.label;
    if (labelFormatter) {
      return /* @__PURE__ */ jsx("div", { className: cn("font-medium", labelClassName), children: labelFormatter(value, payload) });
    }
    if (!value) {
      return null;
    }
    return /* @__PURE__ */ jsx("div", { className: cn("font-medium", labelClassName), children: value });
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey
  ]);
  if (!active || !payload?.length) {
    return null;
  }
  const nestLabel = payload.length === 1 && indicator !== "dot";
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      ),
      children: [
        !nestLabel ? tooltipLabel : null,
        /* @__PURE__ */ jsx("div", { className: "grid gap-1.5", children: payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`;
          const itemConfig = getPayloadConfigFromPayload(config, item, key);
          const indicatorColor = color || item.payload.fill || item.color;
          return /* @__PURE__ */ jsx(
            "div",
            {
              className: cn(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                indicator === "dot" && "items-center"
              ),
              children: formatter && item?.value !== void 0 && item.name ? formatter(item.value, item.name, item, index, item.payload) : /* @__PURE__ */ jsxs(Fragment, { children: [
                itemConfig?.icon ? /* @__PURE__ */ jsx(itemConfig.icon, {}) : !hideIndicator && /* @__PURE__ */ jsx(
                  "div",
                  {
                    className: cn(
                      "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                      {
                        "h-2.5 w-2.5": indicator === "dot",
                        "w-1": indicator === "line",
                        "w-0 border-[1.5px] border-dashed bg-transparent": indicator === "dashed",
                        "my-0.5": nestLabel && indicator === "dashed"
                      }
                    ),
                    style: {
                      "--color-bg": indicatorColor,
                      "--color-border": indicatorColor
                    }
                  }
                ),
                /* @__PURE__ */ jsxs(
                  "div",
                  {
                    className: cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    ),
                    children: [
                      /* @__PURE__ */ jsxs("div", { className: "grid gap-1.5", children: [
                        nestLabel ? tooltipLabel : null,
                        /* @__PURE__ */ jsx("span", { className: "text-muted-foreground", children: itemConfig?.label || item.name })
                      ] }),
                      item.value && /* @__PURE__ */ jsx("span", { className: "text-foreground font-mono font-medium tabular-nums", children: item.value.toLocaleString() })
                    ]
                  }
                )
              ] })
            },
            item.dataKey
          );
        }) })
      ]
    }
  );
}
function getPayloadConfigFromPayload(config, payload, key) {
  if (typeof payload !== "object" || payload === null) {
    return void 0;
  }
  const payloadPayload = "payload" in payload && typeof payload.payload === "object" && payload.payload !== null ? payload.payload : void 0;
  let configLabelKey = key;
  if (key in payload && typeof payload[key] === "string") {
    configLabelKey = payload[key];
  } else if (payloadPayload && key in payloadPayload && typeof payloadPayload[key] === "string") {
    configLabelKey = payloadPayload[key];
  }
  return configLabelKey in config ? config[configLabelKey] : config[key];
}
function formatTime(timestamp) {
  const flooredTimestamp = Math.floor(timestamp);
  return `${flooredTimestamp < 10 ? `0${flooredTimestamp}` : flooredTimestamp}:${timestamp === flooredTimestamp ? "00" : "30"}`;
}
function Card({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "card",
      className: cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      ),
      ...props
    }
  );
}
function CardHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "card-header",
      className: cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      ),
      ...props
    }
  );
}
function CardTitle({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "card-title",
      className: cn("leading-none font-semibold", className),
      ...props
    }
  );
}
function CardDescription({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "card-description",
      className: cn("text-muted-foreground text-sm", className),
      ...props
    }
  );
}
function CardAction({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "card-action",
      className: cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      ),
      ...props
    }
  );
}
function CardContent({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "card-content",
      className: cn("px-6", className),
      ...props
    }
  );
}
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button";
  return /* @__PURE__ */ jsx(
    Comp,
    {
      "data-slot": "button",
      className: cn(buttonVariants({ variant, size, className })),
      ...props
    }
  );
}
const { useMap: useMap$7 } = mappedin;
function HeatmapWidget() {
  const { heatmapSpaceId, setHeatmapSpaceId } = useContext(AppContext);
  const { mapData } = useMap$7();
  const space2 = mapData.getById("space", heatmapSpaceId);
  if (!space2) return null;
  const chartData = Array.from({ length: 24 }, (_, i) => ({
    hour: formatTime(i),
    occupancy: Math.floor(perlinNoise1D(heatmapSpaceId, i * 3) * 100)
  }));
  const chartConfig = {
    occupancy: {
      label: "Occupancy",
      color: "#ff7c43"
    }
  };
  return /* @__PURE__ */ jsxs(Card, { className: "w-[200px] bg-white/70 backdrop-blur-3xl shadow-none py-3", children: [
    /* @__PURE__ */ jsxs(CardHeader, { className: "items-center px-3", children: [
      /* @__PURE__ */ jsx(CardTitle, { className: "text-sm row-span-2", children: space2?.name }),
      /* @__PURE__ */ jsx(CardAction, { children: /* @__PURE__ */ jsx(
        Button,
        {
          onClick: () => setHeatmapSpaceId(void 0),
          variant: "ghost",
          size: "icon",
          className: "size-8",
          children: /* @__PURE__ */ jsx(X$3, {})
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx(CardContent, { className: "px-3", children: /* @__PURE__ */ jsx(ChartContainer, { config: chartConfig, className: "min-h-[100px] w-full", children: /* @__PURE__ */ jsxs(AreaChart, { accessibilityLayer: true, data: chartData, children: [
      /* @__PURE__ */ jsx(CartesianGrid, { vertical: false }),
      /* @__PURE__ */ jsx(
        XAxis,
        {
          dataKey: "hour",
          tickLine: false,
          tickMargin: 10,
          axisLine: false
        }
      ),
      /* @__PURE__ */ jsx(ChartTooltip, { content: /* @__PURE__ */ jsx(ChartTooltipContent, {}) }),
      /* @__PURE__ */ jsx(
        Area,
        {
          dataKey: "occupancy",
          type: "step",
          fill: "var(--color-occupancy)",
          fillOpacity: 0.4,
          stroke: "var(--color-occupancy)"
        }
      )
    ] }) }) })
  ] });
}
const { MapView, useMapData, useMap: useMap$6, Marker } = mappedin;
function MyCustomComponent() {
  const { mapData, mapView } = useMap$6();
  useEffect(() => {
    if (mapData && mapView) {
      async function initializeLabels() {
        mapView.Labels.all();
      }
      initializeLabels();
    }
  }, [mapData, mapView]);
  return null;
}
function ConnectionMarkers() {
  const { mapData } = useMap$6();
  const connections = mapData.getByType("connection");
  const connectionIcons = {
    door: /* @__PURE__ */ jsx(DoorOpen, {}),
    stairs: /* @__PURE__ */ jsx(Icon, { iconNode: stairsArrowUpRight }),
    escalator: /* @__PURE__ */ jsx(Icon, { iconNode: escalatorArrowUpRight }),
    elevator: /* @__PURE__ */ jsx(Icon, { iconNode: chevronsUpDownSquare }),
    ramp: /* @__PURE__ */ jsx(TriangleRight, {}),
    slide: /* @__PURE__ */ jsx(TriangleRight, {}),
    portal: /* @__PURE__ */ jsx(TriangleRight, {}),
    security: /* @__PURE__ */ jsx(ShieldUser, {}),
    shuttle: /* @__PURE__ */ jsx(BusFront, {})
  };
  return connections.map((connection) => {
    const ConnectionIcon = connectionIcons[connection.type];
    return /* @__PURE__ */ jsx(Marker, { target: connection.coordinates[0], children: /* @__PURE__ */ jsxs("div", { className: "bg-primary text-primary-foreground flex rounded-sm py-1 px-2 gap-2 items-center", children: [
      ConnectionIcon && cloneElement(ConnectionIcon, { size: 14 }),
      connection.name.length ? connection.name : connection.type
    ] }) }, connection.id);
  });
}
function MappedInMap({ mapId, children }) {
  const { isLoading, error, mapData } = useMapData({
    key: "mik_yeBk0Vf0nNJtpesfu560e07e5",
    secret: "mis_2g9ST8ZcSFb5R9fPnsvYhrX3RyRwPtDGbMGweCYKEq385431022",
    mapId
  });
  const { heatmapSpaceId } = useContext(AppContext);
  const mapClassName = "w-full h-full bg-(--sidebar) rounded-2xl overflow-hidden col-[2/3] row-[1/3] ring ring-gray-100";
  if (isLoading || error) {
    return /* @__PURE__ */ jsxs(
      "div",
      {
        className: `${mapClassName} flex flex-col items-center justify-center gap-6`,
        children: [
          isLoading && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(LoaderCircle, { size: 32, className: "animate-spin" }),
            /* @__PURE__ */ jsx(TypographyMuted, { children: "Loading map" })
          ] }),
          error && /* @__PURE__ */ jsx("span", { className: "text-red-500", children: error.message })
        ]
      }
    );
  }
  return mapData ? /* @__PURE__ */ jsxs(MapView, { mapData, className: mapClassName, children: [
    /* @__PURE__ */ jsx(MyCustomComponent, {}),
    /* @__PURE__ */ jsx(InteractionManager, {}),
    /* @__PURE__ */ jsx(ConnectionMarkers, {}),
    /* @__PURE__ */ jsx("aside", { className: "col-[1/2] row-[2/3] overflow-y-auto overflow-x-hidden", children }),
    /* @__PURE__ */ jsxs("nav", { className: "col-[2/3] row-[1/3] self-start justify-self-end relative z-10 p-2 overflox-y-auto space-y-4", children: [
      /* @__PURE__ */ jsx(FloorSelector, {}),
      heatmapSpaceId && /* @__PURE__ */ jsx(HeatmapWidget, {})
    ] })
  ] }) : null;
}
const MOBILE_BREAKPOINT = 768;
function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState(void 0);
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);
  return !!isMobile;
}
function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SeparatorPrimitive.Root,
    {
      "data-slot": "separator",
      decorative,
      orientation,
      className: cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      ),
      ...props
    }
  );
}
function Sheet({ ...props }) {
  return /* @__PURE__ */ jsx(SheetPrimitive.Root, { "data-slot": "sheet", ...props });
}
function SheetPortal({
  ...props
}) {
  return /* @__PURE__ */ jsx(SheetPrimitive.Portal, { "data-slot": "sheet-portal", ...props });
}
function SheetOverlay({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SheetPrimitive.Overlay,
    {
      "data-slot": "sheet-overlay",
      className: cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      ),
      ...props
    }
  );
}
function SheetContent({
  className,
  children,
  side = "right",
  ...props
}) {
  return /* @__PURE__ */ jsxs(SheetPortal, { children: [
    /* @__PURE__ */ jsx(SheetOverlay, {}),
    /* @__PURE__ */ jsxs(
      SheetPrimitive.Content,
      {
        "data-slot": "sheet-content",
        className: cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" && "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" && "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" && "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        ),
        ...props,
        children: [
          children,
          /* @__PURE__ */ jsxs(SheetPrimitive.Close, { className: "ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none", children: [
            /* @__PURE__ */ jsx(XIcon, { className: "size-4" }),
            /* @__PURE__ */ jsx("span", { className: "sr-only", children: "Close" })
          ] })
        ]
      }
    )
  ] });
}
function SheetHeader({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "sheet-header",
      className: cn("flex flex-col gap-1.5 p-4", className),
      ...props
    }
  );
}
function SheetTitle({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SheetPrimitive.Title,
    {
      "data-slot": "sheet-title",
      className: cn("text-foreground font-semibold", className),
      ...props
    }
  );
}
function SheetDescription({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SheetPrimitive.Description,
    {
      "data-slot": "sheet-description",
      className: cn("text-muted-foreground text-sm", className),
      ...props
    }
  );
}
function TooltipProvider({
  delayDuration = 0,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    TooltipPrimitive.Provider,
    {
      "data-slot": "tooltip-provider",
      delayDuration,
      ...props
    }
  );
}
function Tooltip({
  ...props
}) {
  return /* @__PURE__ */ jsx(TooltipPrimitive.Root, { "data-slot": "tooltip", ...props });
}
function TooltipTrigger({
  ...props
}) {
  return /* @__PURE__ */ jsx(TooltipPrimitive.Trigger, { "data-slot": "tooltip-trigger", ...props });
}
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsx(TooltipPrimitive.Portal, { children: /* @__PURE__ */ jsxs(
    TooltipPrimitive.Content,
    {
      "data-slot": "tooltip-content",
      sideOffset,
      className: cn(
        "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx(TooltipPrimitive.Arrow, { className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" })
      ]
    }
  ) });
}
const SIDEBAR_COOKIE_NAME = "sidebar_state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";
const SidebarContext = React.createContext(null);
function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }
  return context;
}
function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open2) => !open2) : setOpen((open2) => !open2);
  }, [isMobile, setOpen, setOpenMobile]);
  React.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
        event.preventDefault();
        toggleSidebar();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);
  const state = open ? "expanded" : "collapsed";
  const contextValue = React.useMemo(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );
  return /* @__PURE__ */ jsx(SidebarContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsx(TooltipProvider, { delayDuration: 0, children: /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "sidebar-wrapper",
      style: {
        "--sidebar-width": SIDEBAR_WIDTH,
        "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
        ...style
      },
      className: cn(
        "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
        className
      ),
      ...props,
      children
    }
  ) }) });
}
function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();
  if (collapsible === "none") {
    return /* @__PURE__ */ jsx(
      "div",
      {
        "data-slot": "sidebar",
        className: cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        ),
        ...props,
        children
      }
    );
  }
  if (isMobile) {
    return /* @__PURE__ */ jsx(Sheet, { open: openMobile, onOpenChange: setOpenMobile, ...props, children: /* @__PURE__ */ jsxs(
      SheetContent,
      {
        "data-sidebar": "sidebar",
        "data-slot": "sidebar",
        "data-mobile": "true",
        className: "bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden",
        style: {
          "--sidebar-width": SIDEBAR_WIDTH_MOBILE
        },
        side,
        children: [
          /* @__PURE__ */ jsxs(SheetHeader, { className: "sr-only", children: [
            /* @__PURE__ */ jsx(SheetTitle, { children: "Sidebar" }),
            /* @__PURE__ */ jsx(SheetDescription, { children: "Displays the mobile sidebar." })
          ] }),
          /* @__PURE__ */ jsx("div", { className: "flex h-full w-full flex-col", children })
        ]
      }
    ) });
  }
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: "group peer text-sidebar-foreground hidden md:block",
      "data-state": state,
      "data-collapsible": state === "collapsed" ? collapsible : "",
      "data-variant": variant,
      "data-side": side,
      "data-slot": "sidebar",
      children: [
        /* @__PURE__ */ jsx(
          "div",
          {
            "data-slot": "sidebar-gap",
            className: cn(
              "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
              "group-data-[collapsible=offcanvas]:w-0",
              "group-data-[side=right]:rotate-180",
              variant === "floating" || variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
            )
          }
        ),
        /* @__PURE__ */ jsx(
          "div",
          {
            "data-slot": "sidebar-container",
            className: cn(
              "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
              side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
              // Adjust the padding for floating and inset variants.
              variant === "floating" || variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
              className
            ),
            ...props,
            children: /* @__PURE__ */ jsx(
              "div",
              {
                "data-sidebar": "sidebar",
                "data-slot": "sidebar-inner",
                className: "bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm",
                children
              }
            )
          }
        )
      ]
    }
  );
}
function SidebarFooter({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "sidebar-footer",
      "data-sidebar": "footer",
      className: cn("flex flex-col gap-2 p-2", className),
      ...props
    }
  );
}
function SidebarContent({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "sidebar-content",
      "data-sidebar": "content",
      className: cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      ),
      ...props
    }
  );
}
function SidebarGroup({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "sidebar-group",
      "data-sidebar": "group",
      className: cn("relative flex w-full min-w-0 flex-col p-2", className),
      ...props
    }
  );
}
function SidebarGroupContent({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-slot": "sidebar-group-content",
      "data-sidebar": "group-content",
      className: cn("w-full text-sm", className),
      ...props
    }
  );
}
function SidebarMenu({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "ul",
    {
      "data-slot": "sidebar-menu",
      "data-sidebar": "menu",
      className: cn("flex w-full min-w-0 flex-col gap-1", className),
      ...props
    }
  );
}
function SidebarMenuItem({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "li",
    {
      "data-slot": "sidebar-menu-item",
      "data-sidebar": "menu-item",
      className: cn("group/menu-item relative", className),
      ...props
    }
  );
}
const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}) {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();
  const button = /* @__PURE__ */ jsx(
    Comp,
    {
      "data-slot": "sidebar-menu-button",
      "data-sidebar": "menu-button",
      "data-size": size,
      "data-active": isActive,
      className: cn(sidebarMenuButtonVariants({ variant, size }), className),
      ...props
    }
  );
  if (!tooltip) {
    return button;
  }
  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip
    };
  }
  return /* @__PURE__ */ jsxs(Tooltip, { children: [
    /* @__PURE__ */ jsx(TooltipTrigger, { asChild: true, children: button }),
    /* @__PURE__ */ jsx(
      TooltipContent,
      {
        side: "right",
        align: "center",
        hidden: state !== "collapsed" || isMobile,
        ...tooltip
      }
    )
  ] });
}
function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button";
  return /* @__PURE__ */ jsx(
    Comp,
    {
      "data-slot": "sidebar-menu-action",
      "data-sidebar": "menu-action",
      className: cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover && "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      ),
      ...props
    }
  );
}
function SidebarMenuSub({ className, ...props }) {
  return /* @__PURE__ */ jsx(
    "ul",
    {
      "data-slot": "sidebar-menu-sub",
      "data-sidebar": "menu-sub",
      className: cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      ),
      ...props
    }
  );
}
function SidebarMenuSubItem({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    "li",
    {
      "data-slot": "sidebar-menu-sub-item",
      "data-sidebar": "menu-sub-item",
      className: cn("group/menu-sub-item relative", className),
      ...props
    }
  );
}
function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}) {
  const Comp = asChild ? Slot : "a";
  return /* @__PURE__ */ jsx(
    Comp,
    {
      "data-slot": "sidebar-menu-sub-button",
      "data-sidebar": "menu-sub-button",
      "data-size": size,
      "data-active": isActive,
      className: cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      ),
      ...props
    }
  );
}
function AppSidebar() {
  const items = [
    {
      to: "/",
      label: "Info",
      icon: Info
    },
    {
      to: "/navigation",
      label: "Navigation",
      icon: Navigation
    },
    {
      to: "/demos",
      label: "Demos",
      icon: Settings2
    }
  ];
  const location2 = useLocation();
  return /* @__PURE__ */ jsxs(Sidebar, { collapsible: "icon", variant: "sidebar", children: [
    /* @__PURE__ */ jsx(SidebarContent, { children: /* @__PURE__ */ jsx(SidebarGroup, { children: /* @__PURE__ */ jsx(SidebarGroupContent, { children: items.map((item) => /* @__PURE__ */ jsxs(Tooltip, { children: [
      /* @__PURE__ */ jsx(TooltipTrigger$1, { children: /* @__PURE__ */ jsx(
        SidebarMenuButton,
        {
          asChild: true,
          isActive: location2.pathname === item.to,
          children: /* @__PURE__ */ jsx(NavLink, { to: item.to, children: item.icon && /* @__PURE__ */ jsx(item.icon, {}) })
        }
      ) }),
      /* @__PURE__ */ jsx(TooltipContent, { side: "right", children: item.label })
    ] }, item.to)) }) }) }),
    /* @__PURE__ */ jsx(SidebarFooter, { children: /* @__PURE__ */ jsxs(
      "h1",
      {
        className: "scroll-m-20 text-xl font-medium tracking-tight",
        style: { writingMode: "sideways-lr" },
        children: [
          "Scenwise",
          /* @__PURE__ */ jsx("span", { className: "text-muted-foreground", children: " | MappedIn Demo" })
        ]
      }
    ) })
  ] });
}
function AppContextProvider({
  children
}) {
  const [mapId, setMapId] = useState("65c0ff7430b94e3fabd5bb8c");
  const [navigationFrom, setNavigationFrom] = useState();
  const [navigationTo, setNavigationTo] = useState();
  const [heatmapSpaceId, setHeatmapSpaceId] = useState();
  return /* @__PURE__ */ jsx(
    AppContext.Provider,
    {
      value: {
        mapId,
        setMapId,
        navigationFrom,
        setNavigationFrom,
        navigationTo,
        setNavigationTo,
        heatmapSpaceId,
        setHeatmapSpaceId
      },
      children
    }
  );
}
function MapSelector({ value, onSelect }) {
  const mappedInDemos = [
    { label: "Airport", mapId: "6686b845c9f6d6000bc30300" },
    { label: "Arena", mapId: "672a6f4f3a45ba000b893e1c" },
    { label: "Community Centre", mapId: "660c0bb9ae0596d87766f2d9" },
    { label: "Craft Show", mapId: "67bf60e9679a9d000bfacd6f" },
    { label: "Event Space", mapId: "660c0c3aae0596d87766f2da" },
    { label: "Grocery Store", mapId: "6679882a8298d5000b85ee89" },
    { label: "Hospital", mapId: "67881b4666a208000badecc4" },
    { label: "Mall - Consumer", mapId: "660c0c6e7c0c4fe5b4cc484c" },
    { label: "Mall - Facility", mapId: "65c0ff7430b94e3fabd5bb8c" },
    { label: "Multifamily Mid-Rise", mapId: "666ca6a48dd908000bf47803" },
    { label: "Multifamily High-Rise", mapId: "67a6641530e940000bac3c1a" },
    { label: "Office", mapId: "64ef49e662fd90fe020bee61" },
    { label: "School", mapId: "65c12d9b30b94e3fabd5bb91" },
    { label: "School - Multi Floor", mapId: "66686f1af06f04000b18b8fa" },
    { label: "University Campus", mapId: "682e13a2703478000b567b66" },
    { label: "Warehouse", mapId: "667b26b38298d5000b85eeb0" }
  ];
  const mapLabel = mappedInDemos.find(({ mapId }) => mapId === value)?.label;
  return /* @__PURE__ */ jsxs(Select, { value, onValueChange: onSelect, children: [
    /* @__PURE__ */ jsx(SelectTrigger$1, { asChild: true, children: /* @__PURE__ */ jsxs(Button, { variant: "secondary", className: "w-full", children: [
      /* @__PURE__ */ jsx("span", { className: "text-sm font-semibold grow text-left", children: mapLabel }),
      /* @__PURE__ */ jsx(ChevronsUpDown, {})
    ] }) }),
    /* @__PURE__ */ jsx(SelectContent, { children: /* @__PURE__ */ jsxs(SelectGroup, { children: [
      /* @__PURE__ */ jsx(SelectLabel, { children: "Demo maps" }),
      mappedInDemos.map(({ label, mapId }) => /* @__PURE__ */ jsx(SelectItem, { value: mapId, children: label }, mapId))
    ] }) })
  ] });
}
const layout = UNSAFE_withComponentProps(function Layout2() {
  return /* @__PURE__ */ jsx(AppContextProvider, {
    children: /* @__PURE__ */ jsxs(SidebarProvider, {
      defaultOpen: false,
      className: "max-h-svh",
      children: [/* @__PURE__ */ jsx(AppSidebar, {}), /* @__PURE__ */ jsx(Main, {})]
    })
  });
});
function Main() {
  const {
    mapId,
    setMapId
  } = useContext(AppContext);
  return /* @__PURE__ */ jsxs("main", {
    className: "p-4 grow overflow-hidden grid grid-rows-[2.25rem_auto] grid-cols-[20rem_3fr_max-content] gap-4",
    children: [/* @__PURE__ */ jsx("div", {
      className: "col-[1/2] row-[1/3]",
      children: /* @__PURE__ */ jsx(MapSelector, {
        value: mapId,
        onSelect: setMapId
      })
    }), /* @__PURE__ */ jsx(MappedInMap, {
      mapId,
      children: /* @__PURE__ */ jsx(Outlet, {})
    }, mapId)]
  });
}
const route1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: layout
}, Symbol.toStringTag, { value: "Module" }));
function Tabs({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    TabsPrimitive.Root,
    {
      "data-slot": "tabs",
      className: cn("flex flex-col gap-2", className),
      ...props
    }
  );
}
function TabsList({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    TabsPrimitive.List,
    {
      "data-slot": "tabs-list",
      className: cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      ),
      ...props
    }
  );
}
function TabsTrigger({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    TabsPrimitive.Trigger,
    {
      "data-slot": "tabs-trigger",
      className: cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      ),
      ...props
    }
  );
}
function Collapsible({
  ...props
}) {
  return /* @__PURE__ */ jsx(CollapsiblePrimitive.Root, { "data-slot": "collapsible", ...props });
}
function CollapsibleTrigger({
  ...props
}) {
  return /* @__PURE__ */ jsx(
    CollapsiblePrimitive.CollapsibleTrigger,
    {
      "data-slot": "collapsible-trigger",
      ...props
    }
  );
}
function CollapsibleContent({
  ...props
}) {
  return /* @__PURE__ */ jsx(
    CollapsiblePrimitive.CollapsibleContent,
    {
      "data-slot": "collapsible-content",
      ...props
    }
  );
}
function SpaceTreeCollapsible({
  children,
  icon,
  label
}) {
  const [open, setOpen] = useState(true);
  return /* @__PURE__ */ jsx(
    Collapsible,
    {
      className: "group/collapsible",
      open,
      onOpenChange: setOpen,
      children: /* @__PURE__ */ jsxs(SidebarMenuItem, { children: [
        /* @__PURE__ */ jsx(CollapsibleTrigger, { asChild: true, children: /* @__PURE__ */ jsxs(SidebarMenuButton, { children: [
          icon,
          label,
          /* @__PURE__ */ jsx(SidebarMenuAction, { children: /* @__PURE__ */ jsx(
            ChevronRight,
            {
              className: `transition-transform ${open ? "rotate-90" : ""}`
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsx(CollapsibleContent, { children: /* @__PURE__ */ jsx(SidebarMenuSub, { className: "pr-0 mr-0", children }) })
      ] })
    }
  );
}
const { useEvent: useEvent$2 } = mappedin;
function useClickNavigation() {
  const navigate = useNavigate();
  useEvent$2("click", ({ spaces }) => {
    if (spaces.length) navigate(`/space/${spaces[0].id}`);
  });
}
function pageTitle(title) {
  const DEFAULT_TITLE = "Scenwise MappedIn Demo";
  if (title) return `${title} | ${DEFAULT_TITLE}`;
  return DEFAULT_TITLE;
}
function PageHeader({ title }) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("title", { children: pageTitle(title) }),
    /* @__PURE__ */ jsx("div", { className: "sticky top-0 bg-background z-10 py-2", children: /* @__PURE__ */ jsx("h2", { className: "text-lg font-semibold", children: title }) })
  ] });
}
const {
  useMap: useMap$5
} = mappedin;
const info = UNSAFE_withComponentProps(function Info2() {
  const {
    mapData
  } = useMap$5();
  useClickNavigation();
  const floors = mapData.getByType("floor").sort((a4, b) => a4.elevation - b.elevation);
  const floorStacks = mapData.getByType("floor-stack");
  const spaces = mapData.getByType("space").filter(({
    name
  }) => name.length);
  const pois = mapData.getByType("point-of-interest");
  const spacesPerFloor = floors.map((floor) => ({
    floor,
    spaces: spaces.filter((space2) => space2.floor.id === floor.id).sort((a4, b) => a4.name.localeCompare(b.name)).sort((a4, b) => a4.name.length === 0 && b.name.length > 0 ? 1 : -1),
    // Sort unnamed spaces to the end
    pois: pois.filter((poi) => poi.floor.id === floor.id)
  }));
  const floorsPerStack = floorStacks.map((stack) => ({
    stack,
    floors: stack.floors.map((floor) => spacesPerFloor.find((f) => f.floor.id === floor.id)).filter((f) => f !== void 0)
  }));
  const stackIcons = {
    Building: /* @__PURE__ */ jsx(Building, {}),
    Trees: /* @__PURE__ */ jsx(Trees, {})
  };
  const [tab, setTab] = useState("spaces");
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(PageHeader, {
      title: "Info"
    }), /* @__PURE__ */ jsx("div", {
      className: "py-2",
      children: /* @__PURE__ */ jsxs(Tabs, {
        value: tab,
        onValueChange: (e) => setTab(e),
        children: [/* @__PURE__ */ jsxs(TabsList, {
          children: [/* @__PURE__ */ jsx(TabsTrigger, {
            value: "spaces",
            children: "Spaces"
          }), /* @__PURE__ */ jsx(TabsTrigger, {
            value: "pois",
            children: "Points of Interest"
          })]
        }), /* @__PURE__ */ jsx(SidebarMenu, {
          children: floorsPerStack.length === 1 ? /* @__PURE__ */ jsx(FloorsTree, {
            floors: floorsPerStack[0].floors,
            tab
          }) : floorsPerStack.map(({
            stack,
            floors: floors2
          }) => /* @__PURE__ */ jsx(SpaceTreeCollapsible, {
            icon: stackIcons[stack.type],
            label: stack.name,
            children: /* @__PURE__ */ jsx(FloorsTree, {
              floors: floors2,
              tab
            })
          }, stack.id))
        })]
      })
    })]
  });
});
function FloorsTree({
  floors,
  tab
}) {
  if (floors.length === 1) return /* @__PURE__ */ jsx(SpacesTree, {
    spaces: floors[0].spaces,
    pois: floors[0].pois,
    tab
  });
  return floors.filter((floor) => floor[tab].length).map(({
    floor,
    spaces,
    pois
  }) => /* @__PURE__ */ jsx(SpaceTreeCollapsible, {
    icon: /* @__PURE__ */ jsx("div", {
      className: "bg-primary text-primary-foreground size-4 place-content-center grid rounded-sm text-[0.65rem]",
      children: floor.elevation
    }),
    label: floor.name,
    children: /* @__PURE__ */ jsx(SpacesTree, {
      spaces,
      pois,
      tab
    })
  }, floor.id));
}
function SpacesTree({
  spaces,
  pois,
  tab
}) {
  const {
    mapView
  } = useMap$5();
  const navigate = useNavigate();
  function focusOnSpace(space2) {
    mapView.setFloor(space2.floor.id);
    mapView.Camera.focusOn(space2);
    navigate(`/space/${space2.id}`);
  }
  if (tab === "pois") return pois.map((poi) => /* @__PURE__ */ jsx(SidebarMenuSubItem, {
    children: /* @__PURE__ */ jsxs(SidebarMenuSubButton, {
      onClick: () => focusOnSpace(poi),
      children: [poi.name, " - ", poi.locationProfiles.length]
    })
  }, poi.id));
  if (tab === "spaces") return spaces.map((space2) => /* @__PURE__ */ jsx(SidebarMenuSubItem, {
    children: /* @__PURE__ */ jsx(SidebarMenuSubButton, {
      onClick: () => focusOnSpace(space2),
      children: /* @__PURE__ */ jsx("span", {
        children: space2.name
      })
    })
  }, space2.id));
  return null;
}
const route2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: info
}, Symbol.toStringTag, { value: "Module" }));
const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Badge({
  className,
  variant,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "span";
  return /* @__PURE__ */ jsx(
    Comp,
    {
      "data-slot": "badge",
      className: cn(badgeVariants({ variant }), className),
      ...props
    }
  );
}
const {
  useMap: useMap$4
} = mappedin;
const space = UNSAFE_withComponentProps(function Space({
  params
}) {
  const {
    mapData
  } = useMap$4();
  useClickNavigation();
  const space2 = mapData.getById("space", params.id);
  if (!space2) {
    return /* @__PURE__ */ jsxs("div", {
      className: "flex flex-col items-center justify-center gap-2",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Space not found"
      }), /* @__PURE__ */ jsx(Button, {
        asChild: true,
        variant: "secondary",
        children: /* @__PURE__ */ jsxs(Link, {
          to: "/",
          children: [/* @__PURE__ */ jsx(ArrowLeft, {}), /* @__PURE__ */ jsx("span", {
            children: "Back to home"
          })]
        })
      })]
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx("header", {
      className: "sticky top-0 bg-background py-2",
      children: /* @__PURE__ */ jsx(Button, {
        asChild: true,
        variant: "secondary",
        size: "icon",
        className: "size-8",
        children: /* @__PURE__ */ jsx(Link, {
          to: "/",
          children: /* @__PURE__ */ jsx(ArrowLeft, {})
        })
      })
    }), /* @__PURE__ */ jsxs("main", {
      className: "space-y-4 overflow-x-scroll",
      children: [!!space2.images?.length && /* @__PURE__ */ jsx("img", {
        src: space2.images[0].url,
        alt: space2.name,
        className: "w-full h-auto rounded-xl overflow-hidden aspect-video object-cover bg-sidebar"
      }), /* @__PURE__ */ jsxs("div", {
        className: "space-y-2",
        children: [/* @__PURE__ */ jsx(Badge, {
          variant: "secondary",
          className: "capitalize",
          children: space2.type
        }), /* @__PURE__ */ jsx("h2", {
          className: "text-lg font-semibold",
          children: space2.name
        }), /* @__PURE__ */ jsx("p", {
          className: "leading-7 text-muted-foreground",
          children: space2.description
        }), /* @__PURE__ */ jsxs("span", {
          className: "text-muted-foreground text-xs",
          children: [/* @__PURE__ */ jsx(Layers, {
            className: "inline-block mr-1",
            size: 12
          }), " ", space2.floor.name]
        })]
      }), /* @__PURE__ */ jsx("div", {
        className: "flex gap-2",
        children: space2.links?.map((link) => /* @__PURE__ */ jsx(Button, {
          asChild: true,
          variant: "default",
          size: "sm",
          children: /* @__PURE__ */ jsxs("a", {
            href: link.url,
            target: "_blank",
            rel: "noopener noreferrer",
            children: [link.name, /* @__PURE__ */ jsx(ExternalLink, {})]
          })
        }, link.id))
      })]
    })]
  });
});
const route3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: space
}, Symbol.toStringTag, { value: "Module" }));
const { useEvent: useEvent$1, useMap: useMap$3 } = mappedin;
function LocationSelector({
  location: location2,
  onLocationSelect
}) {
  const { mapData } = useMap$3();
  const floors = mapData.getByType("floor").sort((a4, b) => a4.elevation - b.elevation);
  const spaces = mapData.getByType("space").filter(({ name }) => name.length);
  const spacesPerFloor = floors.map((floor) => ({
    floor,
    spaces: spaces.filter((space2) => space2.floor.id === floor.id).sort((a4, b) => a4.name.localeCompare(b.name))
  }));
  const [spaceId, setSpaceId] = useState(
    location2?.__type === "space" ? location2.id : " "
  );
  const [coordinate, setCoordinate] = useState(
    location2?.__type === "coordinate" ? location2 : void 0
  );
  function handleSpaceSelect(spaceId2) {
    setSpaceId(spaceId2);
    setCoordinate(void 0);
    const space2 = spaces.find(({ id: id3 }) => id3 === spaceId2);
    if (space2) onLocationSelect(space2);
  }
  const [clickSelectEnabled, setClickSelectEnabled] = useState(false);
  useEvent$1("click", ({ spaces: spaces2, coordinate: coordinate2 }) => {
    if (clickSelectEnabled) {
      if (spaces2.length) {
        handleSpaceSelect(spaces2[0].id);
      } else {
        setSpaceId(" ");
        setCoordinate(coordinate2);
        onLocationSelect(coordinate2);
      }
      setClickSelectEnabled(false);
    }
  });
  return /* @__PURE__ */ jsxs("div", { className: "flex items-center gap-2 w-full *:min-w-0", children: [
    /* @__PURE__ */ jsxs(Select, { value: spaceId, onValueChange: handleSpaceSelect, children: [
      /* @__PURE__ */ jsx(SelectTrigger, { className: "grow", children: /* @__PURE__ */ jsx(SelectValue, { placeholder: "Select a space", className: "truncate", children: coordinate ? coordinate.latitude + " " + coordinate.longitude : spaces.find(({ id: id3 }) => id3 === spaceId)?.name }) }),
      /* @__PURE__ */ jsx(SelectContent, { children: spacesPerFloor.map(({ floor, spaces: spaces2 }) => /* @__PURE__ */ jsxs(SelectGroup, { children: [
        /* @__PURE__ */ jsx(SelectLabel, { children: floor.name }),
        spaces2.map((space2) => /* @__PURE__ */ jsx(SelectItem, { value: space2.id, children: space2.name }, space2.id))
      ] }, floor.id)) })
    ] }),
    /* @__PURE__ */ jsxs(Tooltip, { children: [
      /* @__PURE__ */ jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsx(
        Button,
        {
          size: "icon",
          variant: "ghost",
          className: "size-8 shrink-0",
          onClick: () => setClickSelectEnabled(!clickSelectEnabled),
          children: clickSelectEnabled ? /* @__PURE__ */ jsx(LocateOff, {}) : /* @__PURE__ */ jsx(Locate, {})
        }
      ) }),
      /* @__PURE__ */ jsx(TooltipContent, { side: "right", children: "Select on map" })
    ] })
  ] });
}
const {
  useMap: useMap$2
} = mappedin;
const navigation = UNSAFE_withComponentProps(function Navigation2() {
  const {
    mapData,
    mapView
  } = useMap$2();
  const {
    navigationFrom,
    setNavigationFrom,
    navigationTo,
    setNavigationTo
  } = useContext(AppContext);
  useEffect(() => {
    if (navigationFrom && navigationTo) {
      const directions = mapData.getDirections(navigationFrom, navigationTo);
      if (!directions) return;
      mapView.Navigation.clear();
      mapView.Navigation.draw(directions);
    }
  }, [navigationFrom, navigationTo, mapData, mapView.Navigation]);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(PageHeader, {
      title: "Navigation"
    }), /* @__PURE__ */ jsxs("div", {
      className: "space-y-2 py-2",
      children: [/* @__PURE__ */ jsx(LocationSelector, {
        location: navigationFrom,
        onLocationSelect: setNavigationFrom
      }), /* @__PURE__ */ jsx(LocationSelector, {
        location: navigationTo,
        onLocationSelect: setNavigationTo
      })]
    })]
  });
});
const route4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: navigation
}, Symbol.toStringTag, { value: "Module" }));
function Switch({
  className,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    SwitchPrimitive.Root,
    {
      "data-slot": "switch",
      className: cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsx(
        SwitchPrimitive.Thumb,
        {
          "data-slot": "switch-thumb",
          className: cn(
            "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
function DemoCard({
  title,
  description,
  defaultEnabled = false,
  onEnabled,
  disabled,
  children
}) {
  const [enabled, setEnabled] = useState(defaultEnabled);
  const onCheckedChange = (checked) => {
    setEnabled(checked);
    onEnabled(checked);
  };
  return /* @__PURE__ */ jsxs(
    Card,
    {
      className: `${enabled ? "ring-2 ring-primary ring-inset" : ""} shadow-none`,
      children: [
        /* @__PURE__ */ jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsx(CardTitle, { className: disabled ? "opacity-50" : "", children: title }),
          description && /* @__PURE__ */ jsx(CardDescription, { className: disabled ? "opacity-50" : "", children: description }),
          /* @__PURE__ */ jsx(CardAction, { children: /* @__PURE__ */ jsxs(Tooltip, { children: [
            /* @__PURE__ */ jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
              Switch,
              {
                checked: enabled,
                onCheckedChange,
                disabled: !!disabled
              }
            ) }) }),
            /* @__PURE__ */ jsx(TooltipContent, { side: "right", children: disabled ? /* @__PURE__ */ jsxs(Fragment, { children: [
              "Not available",
              /* @__PURE__ */ jsx("p", { className: "text-[0.625rem]", children: disabled })
            ] }) : enabled ? "Turn demo off" : "Turn demo on" })
          ] }) })
        ] }),
        enabled && children && /* @__PURE__ */ jsx(CardContent, { className: "space-y-2", children })
      ]
    }
  );
}
function interpolateColors(color1, color2, factor) {
  const hex = (c) => parseInt(c.replace("#", ""), 16);
  const r12 = hex(color1) >> 16 & 255;
  const g12 = hex(color1) >> 8 & 255;
  const b12 = hex(color1) & 255;
  const r22 = hex(color2) >> 16 & 255;
  const g22 = hex(color2) >> 8 & 255;
  const b22 = hex(color2) & 255;
  const r5 = Math.round(r12 + (r22 - r12) * factor);
  const g = Math.round(g12 + (g22 - g12) * factor);
  const b = Math.round(b12 + (b22 - b12) * factor);
  return `#${(1 << 24 | r5 << 16 | g << 8 | b).toString(16).slice(1)}`;
}
function Progress({
  className,
  value,
  ...props
}) {
  return /* @__PURE__ */ jsx(
    ProgressPrimitive.Root,
    {
      "data-slot": "progress",
      className: cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsx(
        ProgressPrimitive.Indicator,
        {
          "data-slot": "progress-indicator",
          className: "bg-primary h-full w-full flex-1 transition-all",
          style: { transform: `translateX(-${100 - (value || 0)}%)` }
        }
      )
    }
  );
}
const { useEvent, useMap: useMap$1 } = mappedin;
const COLOR1 = "#fff4e6";
const COLOR2 = "#ff7c43";
function StackedFloorsDemo$1() {
  const { mapData, mapView } = useMap$1();
  const isEnabled = useRef(false);
  const defaultStates = useRef({});
  useEffect(() => {
    defaultStates.current = mapData.getByType("space").reduce(
      (acc, space2) => {
        const state = mapView.getState(space2);
        if (state) acc[space2.id] = state;
        return acc;
      },
      {}
    );
  }, [mapData, mapView]);
  const [timestamp, setTimestamp] = useState(13.5);
  function updateSpaceColors(enabled) {
    isEnabled.current = enabled;
    if (!enabled) {
      setIsPlaying(false);
      setHeatmapSpaceId(void 0);
    }
    mapData.getByType("space").forEach((space2) => {
      const color = enabled ? interpolateColors(
        COLOR1,
        COLOR2,
        perlinNoise1D(space2.id, timestamp * 3)
      ) : defaultStates.current[space2.id]?.color || "white";
      const hoverColor = enabled ? color : defaultStates.current[space2.id]?.hoverColor || "lightgrey";
      mapView.updateState(space2, { color, hoverColor });
    });
  }
  const [isPlaying, setIsPlaying] = useState(false);
  useEffect(() => {
    const interval = setInterval(() => {
      if (timestamp == 24) {
        setIsPlaying(false);
      } else if (isPlaying) {
        setTimestamp((current) => current + 0.5);
        updateSpaceColors(true);
      }
    }, 250);
    return () => clearInterval(interval);
  });
  const handlePauseToggle = () => {
    if (timestamp == 24) setTimestamp(0);
    setIsPlaying(!isPlaying);
  };
  const { setHeatmapSpaceId } = useContext(AppContext);
  useEvent("click", ({ spaces }) => {
    if (isEnabled.current && spaces.length) {
      setHeatmapSpaceId(spaces[0].id);
    }
  });
  return /* @__PURE__ */ jsxs(
    DemoCard,
    {
      title: "Heatmap",
      description: "Show a heatmap overlay on the map",
      onEnabled: updateSpaceColors,
      defaultEnabled: isEnabled.current,
      children: [
        /* @__PURE__ */ jsx(Progress, { value: timestamp / 0.24 }),
        /* @__PURE__ */ jsxs("div", { className: "flex items-center justify-between mt-2", children: [
          /* @__PURE__ */ jsx(
            Button,
            {
              onClick: handlePauseToggle,
              variant: "ghost",
              size: "icon",
              className: "size-8",
              children: isPlaying ? /* @__PURE__ */ jsx(Pause, {}) : timestamp == 24 ? /* @__PURE__ */ jsx(RotateCcw, {}) : /* @__PURE__ */ jsx(Play, {})
            }
          ),
          /* @__PURE__ */ jsx("span", { className: "text-xs text-muted-foreground", children: formatTime(timestamp) })
        ] }),
        /* @__PURE__ */ jsx(Separator, {}),
        /* @__PURE__ */ jsxs("p", { children: [
          /* @__PURE__ */ jsx(
            Info,
            {
              size: "14",
              className: "inline align-middle mr-1 text-muted-foreground"
            }
          ),
          /* @__PURE__ */ jsx("i", { className: "text-muted-foreground text-xs", children: "Click on a space to show its daycurve." })
        ] })
      ]
    }
  );
}
const { useMap } = mappedin;
function StackedFloorsDemo() {
  const { mapData, mapView } = useMap();
  function onEnabled(enabled) {
    if (!mapView) return;
    if (enabled) {
      mapView.StackedMaps.expand({ distanceBetweenFloors: "auto" });
    } else {
      mapView.StackedMaps.collapse();
    }
  }
  const numberOfFloors = mapData.getByType("floor").length;
  return /* @__PURE__ */ jsx(
    DemoCard,
    {
      title: "Stacked floors",
      description: "Show all floors on top of eachother",
      defaultEnabled: mapView.StackedMaps.state === "expanded",
      onEnabled,
      disabled: numberOfFloors < 2 ? "Choose a different map with multiple floors." : void 0
    }
  );
}
const demos = UNSAFE_withComponentProps(function Demos() {
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(PageHeader, {
      title: "Demos"
    }), /* @__PURE__ */ jsxs("div", {
      className: "space-y-2",
      children: [/* @__PURE__ */ jsx(StackedFloorsDemo, {}), /* @__PURE__ */ jsx(StackedFloorsDemo$1, {})]
    })]
  });
});
const route5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: demos
}, Symbol.toStringTag, { value: "Module" }));
const serverManifest = { "entry": { "module": "/assets/entry.client-RZi-ff8t.js", "imports": ["/assets/chunk-UIGDSWPH-CIt85NzU.js", "/assets/index-BP1L8zXC.js"], "css": [] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": true, "module": "/assets/root-DKwwea1t.js", "imports": ["/assets/chunk-UIGDSWPH-CIt85NzU.js", "/assets/index-BP1L8zXC.js"], "css": ["/assets/root-DAtXX4TS.css"], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/layout": { "id": "routes/layout", "parentId": "root", "path": void 0, "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/layout-BLr_GTn0.js", "imports": ["/assets/chunk-UIGDSWPH-CIt85NzU.js", "/assets/index-LQx0N5oG.js", "/assets/select-Dj2JEEuD.js", "/assets/tooltip-BicAPSV1.js", "/assets/AppContext-Bo8Z6ja1.js", "/assets/card-NGpA5C1B.js", "/assets/button-BQnWc8Z8.js", "/assets/sidebar-DUZrABxk.js", "/assets/index-BP1L8zXC.js", "/assets/Combination-BM3GwNwT.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/info": { "id": "routes/info", "parentId": "routes/layout", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/info-B2wGv5Lv.js", "imports": ["/assets/chunk-UIGDSWPH-CIt85NzU.js", "/assets/index-LQx0N5oG.js", "/assets/sidebar-DUZrABxk.js", "/assets/tooltip-BicAPSV1.js", "/assets/Combination-BM3GwNwT.js", "/assets/use-click-navigation-C8qDvtLp.js", "/assets/PageHeader-DmSe1-NI.js", "/assets/index-BP1L8zXC.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/space": { "id": "routes/space", "parentId": "routes/layout", "path": "/space/:id", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/space-wwbBgkgW.js", "imports": ["/assets/chunk-UIGDSWPH-CIt85NzU.js", "/assets/index-LQx0N5oG.js", "/assets/button-BQnWc8Z8.js", "/assets/use-click-navigation-C8qDvtLp.js", "/assets/index-BP1L8zXC.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/navigation": { "id": "routes/navigation", "parentId": "routes/layout", "path": "/navigation", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/navigation-BFr7gZg5.js", "imports": ["/assets/chunk-UIGDSWPH-CIt85NzU.js", "/assets/select-Dj2JEEuD.js", "/assets/index-LQx0N5oG.js", "/assets/button-BQnWc8Z8.js", "/assets/tooltip-BicAPSV1.js", "/assets/PageHeader-DmSe1-NI.js", "/assets/AppContext-Bo8Z6ja1.js", "/assets/index-BP1L8zXC.js", "/assets/Combination-BM3GwNwT.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "routes/demos": { "id": "routes/demos", "parentId": "routes/layout", "path": "/demos", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/demos-DBhIV0Nz.js", "imports": ["/assets/chunk-UIGDSWPH-CIt85NzU.js", "/assets/index-LQx0N5oG.js", "/assets/card-NGpA5C1B.js", "/assets/tooltip-BicAPSV1.js", "/assets/AppContext-Bo8Z6ja1.js", "/assets/button-BQnWc8Z8.js", "/assets/PageHeader-DmSe1-NI.js", "/assets/index-BP1L8zXC.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 } }, "url": "/assets/manifest-2ff634ca.js", "version": "2ff634ca", "sri": void 0 };
const assetsBuildDirectory = "build/client";
const basename = "/";
const future = { "v8_middleware": false, "unstable_optimizeDeps": false, "unstable_splitRouteModules": false, "unstable_subResourceIntegrity": false, "unstable_viteEnvironmentApi": false };
const ssr = true;
const isSpaMode = false;
const prerender = [];
const routeDiscovery = { "mode": "lazy", "manifestPath": "/__manifest" };
const publicPath = "/";
const entry = { module: entryServer };
const routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: route0
  },
  "routes/layout": {
    id: "routes/layout",
    parentId: "root",
    path: void 0,
    index: void 0,
    caseSensitive: void 0,
    module: route1
  },
  "routes/info": {
    id: "routes/info",
    parentId: "routes/layout",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route2
  },
  "routes/space": {
    id: "routes/space",
    parentId: "routes/layout",
    path: "/space/:id",
    index: void 0,
    caseSensitive: void 0,
    module: route3
  },
  "routes/navigation": {
    id: "routes/navigation",
    parentId: "routes/layout",
    path: "/navigation",
    index: void 0,
    caseSensitive: void 0,
    module: route4
  },
  "routes/demos": {
    id: "routes/demos",
    parentId: "routes/layout",
    path: "/demos",
    index: void 0,
    caseSensitive: void 0,
    module: route5
  }
};
const build = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assets: serverManifest,
  assetsBuildDirectory,
  basename,
  entry,
  future,
  isSpaMode,
  prerender,
  publicPath,
  routeDiscovery,
  routes,
  ssr
}, Symbol.toStringTag, { value: "Module" }));
const _virtual_netlifyServer = createRequestHandler({
  build
});
export {
  $l as $,
  Ae$3 as A,
  Bt$2 as B,
  na$1 as C,
  De$3 as D,
  Es$2 as E,
  F$1 as F,
  G$1 as G,
  H$3 as H,
  I$2 as I,
  J$1 as J,
  Kg2 as K,
  L,
  M$1 as M,
  N$2 as N,
  O,
  P,
  Q$3 as Q,
  R$1 as R,
  S$1 as S,
  T$2 as T,
  U$2 as U,
  V$2 as V,
  bf$2 as W,
  Of$1 as X,
  Ht$2 as Y,
  Zp$2 as Z,
  _t as _,
  a,
  ya$1 as a$,
  p$1 as a0,
  En$1 as a1,
  ve$3 as a2,
  Aa$1 as a3,
  Ml$2 as a4,
  _s$1 as a5,
  In$2 as a6,
  ae$2 as a7,
  ps$2 as a8,
  hl$2 as a9,
  ea$1 as aA,
  pe$3 as aB,
  fl$2 as aC,
  X$2 as aD,
  wp$2 as aE,
  Cp$2 as aF,
  qr as aG,
  As$2 as aH,
  xl$2 as aI,
  yl$2 as aJ,
  ti$2 as aK,
  Te$1 as aL,
  ks$2 as aM,
  pl$2 as aN,
  Pl$2 as aO,
  Gr$1 as aP,
  ui$2 as aQ,
  dl$2 as aR,
  di as aS,
  hi$2 as aT,
  qt$2 as aU,
  Sn$2 as aV,
  ci$1 as aW,
  TD$1 as aX,
  $r as aY,
  $a as aZ,
  Da as a_,
  Ve$1 as aa,
  Fe$2 as ab,
  yf$2 as ac,
  Hs$1 as ad,
  Oa$1 as ae,
  Wn$1 as af,
  zn$2 as ag,
  Ur$1 as ah,
  Nr$2 as ai,
  Fr$1 as aj,
  Gn$2 as ak,
  Hl$1 as al,
  Ll$1 as am,
  Rl$1 as an,
  ri$1 as ao,
  Fl$1 as ap,
  Bl$1 as aq,
  kl$1 as ar,
  ml$2 as as,
  fe$2 as at,
  Ul as au,
  Wl$1 as av,
  ul$1 as aw,
  Yr$2 as ax,
  nn$2 as ay,
  Ts$2 as az,
  Q as b,
  Ha as b0,
  Ga as b1,
  qa$1 as b2,
  ja as b3,
  Ea2 as b4,
  de$1 as b5,
  ma$1 as b6,
  ka as b7,
  Lt$1 as b8,
  Ua as b9,
  Zle as bA,
  $le as bB,
  Hk as bC,
  A2$1 as bD,
  jle as bE,
  Ole as bF,
  Gle as bG,
  Hle as bH,
  WW as bI,
  ui as bJ,
  ve2 as bK,
  Se$1 as bL,
  _virtual_netlifyServer as bM,
  ie$1 as ba,
  ut$1 as bb,
  Wa as bc,
  vx$1 as bd,
  nt$2 as be,
  Ur as bf,
  La as bg,
  En as bh,
  Fe$1 as bi,
  fa$1 as bj,
  vi as bk,
  Na as bl,
  Tn$1 as bm,
  Va as bn,
  Oa as bo,
  Ba as bp,
  Za$1 as bq,
  pa$1 as br,
  da$1 as bs,
  M2$1 as bt,
  $k as bu,
  Ke as bv,
  qle as bw,
  Vle as bx,
  Ule as by,
  Nle as bz,
  Vg2 as c,
  Ps as d,
  Pe$3 as e,
  Oe$1 as f,
  Ft$3 as g,
  Pp$2 as h,
  I$1 as i,
  Vt$2 as j,
  kn$1 as k,
  ot$1 as l,
  m$1 as m,
  nl as n,
  or as o,
  vt as p,
  Gl as q,
  en$1 as r,
  $t$3 as s,
  cn$3 as t,
  Os$2 as u,
  vs$1 as v,
  we$2 as w,
  ia$1 as x,
  ye$1 as y,
  z3 as z
};
